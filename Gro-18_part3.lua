--Stealed clientside server code by exechack.cc
--Hostname: Große Armee der Republik ★EGM★ [57 / 100] [v4.0.11] - Part 3/5 - 06/04/2025


--lua/includes/extensions/coroutine.lua:

--
-- The client needs this file
--
AddCSLuaFile()

if ( !coroutine ) then return end

--
-- Name: coroutine.wait
-- Desc: Yield's the coroutine for so many seconds before returning.\n\nThis should only be called in a coroutine. This function uses CurTime() - not RealTime().
-- Arg1: number|seconds|The number of seconds to wait
-- Ret1: 
--
function coroutine.wait( seconds )

	local endtime = CurTime() + seconds
	while ( true ) do

		if ( endtime < CurTime() ) then return end

		coroutine.yield()

	end
	  
end

--addons/bkeypads/lua/bkeypads/sh_fading_doors.lua:
if SERVER then
	for _, ent in ipairs(ents.GetAll()) do
		if ent:GetClass() == "bkeypads_fading_door_link" then
			ent:Remove()
		end
	end
end

if SERVER then util.AddNetworkString("bKeypads.FadingDoors.Fade") end

local L = bKeypads.L

bKeypads.FadingDoors = {}

cleanup.Register("_bkeypads_fading_doors")

hook.Add("canLockpick", "bKeypads.FadingDoors.canLockpick", function(ply, ent)
	if not bKeypads.Config.FadingDoors.Lockpick and IsValid(ent) and bKeypads.FadingDoors:IsFadingDoor(ent) then
		return false
	end
end)

function bKeypads.FadingDoors:IsFaded(fading_door)
	local controller = bKeypads.FadingDoors:GetController(fading_door)
	if IsValid(controller) then
		if controller:GetReversed() then
			return not fading_door.fadeActive
		else
			return fading_door.fadeActive
		end
	end
	return false
end

function bKeypads.FadingDoors:DoFade(fading_door)
	if not bKeypads.FadingDoors:IsFadingDoor(fading_door) then return end

	local controller = bKeypads.FadingDoors:GetController(fading_door)
	local config = controller:GetConfig()

	local shouldOpen = fading_door.fadeActive
	if config.Reversed then shouldOpen = not shouldOpen end

	if shouldOpen then

		if controller:GetRestoreData() then return end
		
		if controller.m_FadingDoorData.GetCustomCollisionCheck ~= nil then
			fading_door:SetCustomCollisionCheck(controller.m_FadingDoorData.GetCustomCollisionCheck)
			controller.m_FadingDoorData.GetCustomCollisionCheck = nil
		end
		controller.m_FadingDoorData.stuckPlys = nil
		if SERVER then timer.Remove(controller.StuckTickTimer) end

		controller:SaveRestoreData()

		fading_door:SetMaterial(config.FadeMaterial)
		fading_door:DrawShadow(false)
		fading_door:SetSolidFlags(FSOLID_CUSTOMRAYTEST)
		fading_door:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)

		local phys = fading_door:GetPhysicsObject()
		if IsValid(phys) then
			phys:EnableMotion(false)
		end

		if SERVER and (not IsValid(fading_door:GetCreator()) or bKeypads.Permissions:Check(fading_door:GetCreator(), "fading_doors/sounds")) then
			if config.OpenSound then
				fading_door:EmitSound(config.OpenSound, 350, 100)
			end
			if config.ActiveSound then
				fading_door.FadeDoorSound = CreateSound(fading_door, config.ActiveSound)
				fading_door.FadeDoorSound:Play()
				fading_door.FadeDoorSound:ChangeVolume(.25)
			end
		end

	elseif SERVER then

		if not controller:GetRestoreData() then return end

		if bKeypads.Config.FadingDoors.KeepOpen then
			local stuckPlys = bKeypads.FadingDoors:GetStuckPlayers(fading_door)
			if #stuckPlys > 0 then
				local timerName = controller.StuckTickTimer
				if not timer.Exists(timerName) then
					timer.Create(timerName, engine.TickInterval() * bKeypads.Config.FadingDoors.TickIntervalMul, 0, function()
						if not IsValid(fading_door) or not IsValid(controller) or not bKeypads.FadingDoors:IsFadingDoor(fading_door) then
							timer.Remove(timerName)
							return
						end

						local doorMins, doorMaxs = fading_door:GetCollisionBounds()
						for i = #stuckPlys, 1, -1 do
							local ply = stuckPlys[i]
							if not IsValid(ply) or not bKeypads.FadingDoors:IsPlayerStuck(doorMins, doorMaxs, fading_door, ply) then
								table.remove(stuckPlys, i)
							end
						end
						
						if #stuckPlys == 0 then
							timer.Remove(timerName)

							if config.Reversed then
								fading_door:fadeActivate()
							else
								fading_door:fadeDeactivate()
							end
						end
					end)

					return
				end
			end
		end

		if not IsValid(fading_door:GetCreator()) or bKeypads.Permissions:Check(fading_door:GetCreator(), "fading_doors/sounds") then
			if config.CloseSound then
				fading_door:EmitSound(config.CloseSound, 350, 100)
			end
			if fading_door.FadeDoorSound then
				fading_door.FadeDoorSound:Stop()
				fading_door.FadeDoorSound = nil
			end
		end

		controller:Restore()

		--[[
		if SERVER and (not IsValid(fading_door:GetCreator()) or bKeypads.Permissions:Check(fading_door:GetCreator(), "fading_doors/sounds")) then
			if config.CloseSound then
				fading_door:EmitSound(config.CloseSound, 350, 100)
			end
			if fading_door.FadeDoorSound then
				fading_door.FadeDoorSound:Stop()
				fading_door.FadeDoorSound = nil
			end
		end

		if bKeypads.FadingDoors.PickedUp[fading_door] then
			bKeypads.FadingDoors.PickedUp[fading_door] = nil
		end

		controller:Restore()

		local stuckPlys = bKeypads.FadingDoors:GetStuckPlayers(fading_door)
		if #stuckPlys > 0 then
			controller.m_FadingDoorData.stuckPlys = stuckPlys
			controller.m_FadingDoorData.stuckPlysDict = {}

			controller.m_FadingDoorData.GetCustomCollisionCheck = fading_door:GetCustomCollisionCheck()
			fading_door:SetCustomCollisionCheck(true)

			if SERVER then
				net.Start("bKeypads.FadingDoors.StuckPlayers")
					net.WriteEntity(fading_door)
					for _, stuckPly in ipairs(stuckPlys) do
						controller.m_FadingDoorData.stuckPlysDict[stuckPly] = true

						net.WriteBool(true)
						net.WriteEntity(stuckPly)
					end
					net.WriteBool(false)
				net.Broadcast()

				local timerName = controller.StuckTickTimer
				timer.Create(controller.StuckTickTimer, engine.TickInterval() * 8, 0, function()
					if not IsValid(fading_door) or not IsValid(controller) or not bKeypads.FadingDoors:IsFadingDoor(fading_door) or not controller.m_FadingDoorData.stuckPlys then
						timer.Remove(timerName)
						return
					end

					local stuckPlys = bKeypads.FadingDoors:GetStuckPlayers(fading_door, controller.m_FadingDoorData.stuckPlys)
					if #stuckPlys == 0 then

						controller.m_FadingDoorData.stuckPlys = nil
						controller.m_FadingDoorData.stuckPlysDict = nil

						net.Start("bKeypads.FadingDoors.StuckPlayers")
							net.WriteEntity(fading_door)
							net.WriteBool(false)
						net.Broadcast()

					elseif #stuckPlys ~= #controller.m_FadingDoorData.stuckPlys then
					
						controller.m_FadingDoorData.stuckPlys = stuckPlys
						controller.m_FadingDoorData.stuckPlysDict = {}

						net.Start("bKeypads.FadingDoors.StuckPlayers")
							net.WriteEntity(fading_door)
							for _, stuckPly in ipairs(stuckPlys) do
								controller.m_FadingDoorData.stuckPlysDict[stuckPly] = true

								net.WriteBool(true)
								net.WriteEntity(stuckPly)
							end
							net.WriteBool(false)
						net.Broadcast()
						
					end
				end)
			end
		end
		]]
	end

	if CLIENT and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gmod_tool" then
		bKeypads.ESP:Refresh()
	end
end

do
	if SERVER then
		function bKeypads.FadingDoors:IsPlayerStuck(doorMins, doorMaxs, fading_door, ply)
			local plyPosRel = fading_door:WorldToLocal(ply:GetPos())

			local plyMins, plyMaxs = ply:GetCollisionBounds()
			plyMins:Mul(1.5) plyMaxs:Mul(1.5)
			plyMins:Add(plyPosRel) plyMaxs:Add(plyPosRel)

			return (doorMins[1] <= plyMaxs[1] and doorMaxs[1] >= plyMins[1])
			   and (doorMins[2] <= plyMaxs[2] and doorMaxs[2] >= plyMins[2])
			   and (doorMins[3] <= plyMaxs[3] and doorMaxs[3] >= plyMins[3])
		end

		function bKeypads.FadingDoors:GetStuckPlayers(fading_door)
			local stuckPlys = {}

			local doorMins, doorMaxs = fading_door:GetCollisionBounds()
			for _, ply in ipairs(player.GetAll()) do
				if bKeypads.FadingDoors:IsPlayerStuck(doorMins, doorMaxs, fading_door, ply) then
					table.insert(stuckPlys, ply)
				end
			end

			return stuckPlys
		end
	end

	-- FIXME https://github.com/Facepunch/garrysmod-issues/issues/642
	--[[local stuckTrOutput = {}
	local stuckTrData = {
		collisiongroup = COLLISION_GROUP_PLAYER,
		ignoreworld = true,
		output = stuckTrOutput
	}
	function bKeypads.FadingDoors:GetStuckPlayers(fading_door, checkPlys)
		fading_door:CollisionRulesChanged()

		local stuckPlys = {}
		local m_stuckPlys = checkPlys
		if not m_stuckPlys then
			local boxMins, boxMaxs = fading_door:GetCollisionBounds()
			boxMins, boxMaxs = fading_door:LocalToWorld(boxMins), fading_door:LocalToWorld(boxMaxs)
			m_stuckPlys = ents.FindInBox(boxMins, boxMaxs)
		end
		for _, ent in ipairs(m_stuckPlys) do
			local ply
			if ent:IsPlayer() then
				ply = ent
			elseif CLIENT and ent:IsWeapon() then
				-- Issue #4480
				local prnt = ent:GetParent()
				if prnt == LocalPlayer() then
					ply = prnt
				end
			end
			if IsValid(ply) then
				local mins, maxs = ply:GetCollisionBounds()
				local filter = { ply }
				stuckTrData.start = ply:GetPos()
				stuckTrData.endpos = ply:GetPos()
				stuckTrData.mins = mins
				stuckTrData.maxs = maxs
				stuckTrData.filter = filter
				while true do
					util.TraceHull(stuckTrData)
					if not stuckTrOutput.Hit or not IsValid(stuckTrOutput.Entity) then break end
					if stuckTrOutput.Entity == fading_door then
						table.insert(stuckPlys, ply)
						ply:CollisionRulesChanged()
						break
					end
					table.insert(filter, stuckTrOutput.Entity)
				end
			end
		end
		return stuckPlys
	end

	if SERVER then
		util.AddNetworkString("bKeypads.FadingDoors.StuckPlayers")
	else
		net.Receive("bKeypads.FadingDoors.StuckPlayers", function()
			local fading_door = net.ReadEntity()
			if not IsValid(fading_door) or not bKeypads.FadingDoors:IsFadingDoor(fading_door) then return end

			local controller = bKeypads.FadingDoors:GetController(fading_door)
			controller.m_FadingDoorData.stuckPlys = {}
			controller.m_FadingDoorData.stuckPlysDict = {}
			while net.ReadBool() do
				local ply = net.ReadEntity()
				table.insert(controller.m_FadingDoorData.stuckPlys, ply)
				controller.m_FadingDoorData.stuckPlysDict[ply] = true
			end
			if #controller.m_FadingDoorData.stuckPlys == 0 then
				controller.m_FadingDoorData.stuckPlys = nil
				controller.m_FadingDoorData.stuckPlysDict = nil
			end
		end)
	end
	hook.Add("ShouldCollide", "bKeypads.FadingDoors.StuckPlayers", function(ent1, ent2)
		local fading_door, ply
		if bKeypads.FadingDoors:IsFadingDoor(ent1) then
			fading_door = ent1
			ply = ent2
		elseif bKeypads.FadingDoors:IsFadingDoor(ent2) then
			fading_door = ent2
			ply = ent1
		end
		if not fading_door or not ply then return end

		local controller = bKeypads.FadingDoors:GetController(fading_door)
		if not controller or not controller.m_FadingDoorData.stuckPlysDict or not controller.m_FadingDoorData.stuckPlysDict[ply] then return end

		return false
	end)]]
end

function bKeypads.FadingDoors:CanFadingDoor(ent)
	return IsValid(ent) and ent:GetClass():lower():StartWith("prop_") and not ent:IsVehicle() and not bKeypads.MapLinking:IsDoor(ent)
end

function bKeypads.FadingDoors:GetController(fading_door)
	if IsValid(fading_door) and IsValid(fading_door.bKeypads_FadingDoor) then
		local controller = fading_door.bKeypads_FadingDoor
		if controller:GetParent() ~= fading_door then
			controller:ParentTo(fading_door) -- prevents weird error probably caused by NetworkVar being shit
		end
		return controller
	end
end

function bKeypads.FadingDoors:IsFadingDoor(ent)
	return IsValid(ent) and bKeypads.FadingDoors:GetController(ent) ~= nil
end

function bKeypads.FadingDoors:GetConfig(fading_door)
	return bKeypads.FadingDoors:IsFadingDoor(fading_door) and bKeypads.FadingDoors:GetController(fading_door):GetConfig()
end

if SERVER then
	function bKeypads.FadingDoors:Create(ply, ent, toggle, reversed, mat, opensound, activesound, closesound, key)
		if IsValid(ply) and not bKeypads.Permissions:Check(ply, "fading_doors/create") then return end

		if not list.Contains("bKeypads_FDoorMaterials", mat) then return end

		local opensound = bKeypads.Config.FadingDoors.EnableSounds and opensound ~= "" and opensound ~= 0 and list.Contains("bKeypads_FDoorSounds", opensound) and opensound or ""
		local activesound = bKeypads.Config.FadingDoors.EnableSounds and activesound ~= "" and activesound ~= 0 and list.Contains("bKeypads_FDoorLoopSounds", activesound) and activesound or ""
		local closesound = bKeypads.Config.FadingDoors.EnableSounds and closesound ~= "" and closesound ~= 0 and list.Contains("bKeypads_FDoorSounds", closesound) and closesound or ""

		local controller = bKeypads.FadingDoors:GetController(ent)
		if controller then
			ent:fadeCancel()
		else
			controller = ents.Create("bkeypads_fading_door")
			controller:SetCreator(ply)
			controller:ParentTo(ent)
			controller:Spawn()

			bKeypads_FadingDoors_Registry[ent] = controller

			if IsValid(ply) then
				ply:AddCount("_bkeypads_fading_doors", controller)
				ply:AddCleanup("_bkeypads_fading_doors", controller)

				undo.Create("bKeypads_FadingDoor")
					undo.AddEntity(controller)
					undo.SetPlayer(ply)
				undo.Finish()
			end
		end

		controller:SetToggle(toggle)
		controller:SetReversed(bKeypads.Config.FadingDoors.Reversible and reversed)
		controller:SetFadeMaterial(mat)
		if (not IsValid(ply) or bKeypads.Permissions:Check(ply, "fading_doors/keyboard")) and key > 0 then
			controller:SetKeyboardButton(key)
		end
		if not IsValid(ply) or bKeypads.Permissions:Check(ply, "fading_doors/sounds") then
			controller:SetOpenSound(opensound)
			controller:SetActiveSound(activesound)
			controller:SetCloseSound(closesound)
		end

		if controller.m_FadingDoorData.GetCustomCollisionCheck then
			bKeypads.FadingDoors:SetCustomCollisionCheck(controller.m_FadingDoorData.GetCustomCollisionCheck)
		end
		bKeypads.FadingDoors:DoFade(ent)
	end
	duplicator.RegisterEntityModifier("bKeypads.FadingDoor", function(ply, ent, data)
		bKeypads.FadingDoors:Create(ply, ent, data.Toggle, data.Reversed, data.FadeMaterial, data.OpenSound, data.ActiveSound, data.CloseSound, data.KeyboardButton)
	end)

	function bKeypads.FadingDoors:Remove(ent)
		local controller = bKeypads.FadingDoors:GetController(ent)
		if IsValid(controller) then
			controller:Remove()
		end
	end
else
	net.Receive("bKeypads.FadingDoors.Fade", function()
		local ent = net.ReadEntity()
		ent.fadeActive = net.ReadBool()
		bKeypads.FadingDoors:DoFade(ent)
	end)
end

--## Linking ##--

bKeypads.FadingDoors.Links = {}
bKeypads.FadingDoors.LinkEnts = {}

function bKeypads.FadingDoors:GetLinks(keypad_or_fading_door)
	return bKeypads.FadingDoors.Links[keypad_or_fading_door] or bKeypads.FadingDoors.Links[keypad_or_fading_door] or nil
end

function bKeypads.FadingDoors:IsLinked(keypad, fading_door)
	return IsValid(keypad) and IsValid(fading_door) and bKeypads.FadingDoors.Links[fading_door] and bKeypads.FadingDoors.Links[fading_door][keypad] and next(bKeypads.FadingDoors.Links[fading_door][keypad]) ~= nil
end

function bKeypads.FadingDoors:RegisterLink(link, keypad, fading_door, accessType)
	bKeypads.FadingDoors.Links[keypad] = bKeypads.FadingDoors.Links[keypad] or {}
	bKeypads.FadingDoors.Links[keypad][fading_door] = bKeypads.FadingDoors.Links[keypad][fading_door] or {}
	bKeypads.FadingDoors.Links[keypad][fading_door][accessType] = link

	bKeypads.FadingDoors.Links[fading_door] = bKeypads.FadingDoors.Links[fading_door] or {}
	bKeypads.FadingDoors.Links[fading_door][keypad] = bKeypads.FadingDoors.Links[fading_door][keypad] or {}
	bKeypads.FadingDoors.Links[fading_door][keypad][accessType] = link
end

function bKeypads.FadingDoors:DeregisterLink(keypad, fading_door, accessType)
	if bKeypads.FadingDoors.Links[fading_door] and bKeypads.FadingDoors.Links[fading_door][keypad] and bKeypads.FadingDoors.Links[fading_door][keypad][accessType] then
		bKeypads.FadingDoors.Links[fading_door][keypad] = nil
		if table.IsEmpty(bKeypads.FadingDoors.Links[fading_door]) then
			bKeypads.FadingDoors.Links[fading_door] = nil
		end
	end
	if bKeypads.FadingDoors.Links[keypad] and bKeypads.FadingDoors.Links[keypad][fading_door] and bKeypads.FadingDoors.Links[keypad][fading_door][accessType] then
		bKeypads.FadingDoors.Links[keypad][fading_door] = nil
		if table.IsEmpty(bKeypads.FadingDoors.Links[keypad]) then
			bKeypads.FadingDoors.Links[keypad] = nil
		end
	end
end

if SERVER then
	function bKeypads.FadingDoors:Link(keypad, fading_door, accessType, ply)
		if not IsValid(fading_door) or not IsValid(keypad) then return end

		bKeypads.FadingDoors:Unlink(keypad, fading_door)

		local link = ents.Create("bkeypads_fading_door_link")
		link:SetKeypad(keypad)
		link:SetLinkedEnt(fading_door)
		link:SetAccessType(accessType)

		bKeypads.FadingDoors:RegisterLink(link, keypad, fading_door, accessType)

		keypad:RefreshCanKeypadCrack()

		if SERVER then
			if IsValid(ply) then
				undo.Create("bKeypads_FadingDoor_Link")
					undo.SetPlayer(ply)
					undo.AddEntity(link)
				undo.Finish()

				hook.Run("bKeypads.Link.FadingDoor", ply, keypad, fading_door, accessType)
			end
		else
			bKeypads.ESP:Refresh()
		end
	end

	function bKeypads.FadingDoors:Unlink(keypad, fading_door, ply)
		local link = bKeypads.FadingDoors.Links[keypad] and bKeypads.FadingDoors.Links[keypad][fading_door] and (bKeypads.FadingDoors.Links[keypad][fading_door][true] or bKeypads.FadingDoors.Links[keypad][fading_door][false])
		if IsValid(link) then
			if IsValid(link:GetLinkedEnt()) then
				link:GetLinkedEnt():fadeCancel()
			end

			if IsValid(ply) and IsValid(keypad) and IsValid(fading_door) then
				hook.Run("bKeypads.Unlink.FadingDoor", ply, keypad, fading_door, link:GetAccessType())
			end

			link:Remove()
		end
	end
end

function bKeypads.FadingDoors:BuildLinksTable()
	bKeypads.FadingDoors.RebuildLinkTable = nil

	bKeypads.FadingDoors.Links = {}

	for link in pairs(bKeypads.FadingDoors.LinkEnts) do
		if not IsValid(link) then
			bKeypads.FadingDoors.LinkEnts[link] = nil
			continue
		end

		local keypad, fading_door, accessType = link:GetKeypad(), link:GetLinkedEnt(), link:GetAccessType()
		if IsValid(fading_door) and IsValid(keypad) then
			bKeypads.FadingDoors:RegisterLink(link, keypad, fading_door, accessType)
		end
	end

	if CLIENT then bKeypads.ESP:Refresh() end
end

--## STOOL ##--

bKeypads.FadingDoors.STOOL = {}

function bKeypads.FadingDoors.STOOL.Reset(self)
	self:SetOperation(0)
	self:SetStage(0)
end

function bKeypads.FadingDoors.STOOL.LeftClick(self, tr)
	if (
		not IsValid(self:GetOwner()) or
		not bKeypads.FadingDoors:CanFadingDoor(tr.Entity) or
		not bKeypads.Permissions:Check(self:GetOwner(), "fading_doors/create")
	) then return false end

	if not bKeypads.STOOL:CheckLimit(self:GetOwner(), bKeypads.STOOL.LIMIT_FADING_DOORS) then return true end

	-- Create/Update fading door
	if not tr.Entity.bKeypad then
		if not list.Contains("bKeypads_FDoorMaterials", self:GetClientInfo("mat")) then return false end

		if SERVER then
			bKeypads.FadingDoors:Create(
				self:GetOwner(),
				tr.Entity,
				self:GetClientNumber("toggle") == 1,
				self:GetClientNumber("reversed") == 1,
				self:GetClientInfo("mat"),
				self:GetClientInfo("opensound"),
				self:GetClientInfo("activesound"),
				self:GetClientInfo("closesound"),
				self:GetClientNumber("key")
			)
		elseif IsFirstTimePredicted() then
			if bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then
				notification.AddLegacy(L"FadingDoorUpdated", NOTIFY_UNDO, 4)
				surface.PlaySound("buttons/button5.wav")
			else
				notification.AddLegacy(L"FadingDoorCreated", NOTIFY_GENERIC, 2)
				surface.PlaySound("buttons/button5.wav")
			end
		end

		return true
	end
	
	return false
end

local copyDictionary = {
	["Toggle"] = "toggle",
	["Reversed"] = "reversed",
	["FadeMaterial"] = "mat",
	["ActiveSound"] = "activesound",
	["OpenSound"] = "opensound",
	["CloseSound"] = "closesound",
	["KeyboardButton"] = "key",
}
function bKeypads.FadingDoors.STOOL.RightClick(self, tr)
	if (
		not IsValid(self:GetOwner()) or
		not bKeypads.FadingDoors:IsFadingDoor(tr.Entity) or
		not bKeypads.Permissions:Check(self:GetOwner(), "fading_doors/create")
	) then return false end

	if CLIENT and IsFirstTimePredicted() then
		local config = bKeypads.FadingDoors:GetConfig(tr.Entity)
		for option, cvar in pairs(copyDictionary) do
			local ConVar = GetConVar("bkeypads_fading_door_" .. cvar)
			local val = config[option]
			if val ~= nil then
				if isbool(val) then
					ConVar:SetBool(val)
				elseif isnumber(val) then
					if val % 0 == 0 then
						ConVar:SetInt(val)
					else
						ConVar:SetFloat(val)
					end
				else
					ConVar:SetString(val)
				end
			end
		end

		notification.AddLegacy(L"FadingDoorSettingsCopied", NOTIFY_GENERIC, 2)
		surface.PlaySound("buttons/button5.wav")
	end

	return true
end

function bKeypads.FadingDoors.STOOL.Reload(self, tr)
	if not bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then return end

	if SERVER then
		bKeypads.FadingDoors:Remove(tr.Entity)
	elseif IsFirstTimePredicted() then
		notification.AddLegacy(L"FadingDoorRemoved", NOTIFY_ERROR, 2)
		surface.PlaySound("buttons/button6.wav")
	end

	return true
end

if CLIENT then
	local function HelpCategory_OnToggle(self)
		if not self:GetExpanded() then
			cookie.Set("bkeypads_fading_doors_help_viewed", 1)
		end
	end

	function bKeypads.FadingDoors.STOOL.BuildCPanel(CPanel)
		bKeypads:InjectSmoothScroll(CPanel)
		bKeypads:STOOLMatrix(CPanel)

		local KeypadOnlyFadingDoor = bKeypads:AddHelp(CPanel, L"KeypadOnlyFadingDoor")
		KeypadOnlyFadingDoor:DockMargin(0, 0, 0, 0)

		local FadingDoorLinkTip = bKeypads:AddHelp(CPanel, L"FadingDoorLinkTip")
		FadingDoorLinkTip:DockMargin(0, 0, 0, 0)

		CPanel.HelpCategory = vgui.Create("DForm", CPanel)
		CPanel.HelpCategory:SetLabel(L"Help")
		CPanel.HelpCategory:SetExpanded(cookie.GetNumber("bkeypads_fading_doors_help_viewed", 0) == 0)
		CPanel.HelpCategory.OnToggle = HelpCategory_OnToggle

			CPanel.Video = vgui.Create("bKeypads.DockedImage", CPanel.HelpCategory)
			CPanel.Video:SetMaterial(Material("bkeypads/fading_door_animation"))
			CPanel.Video:SetAspectRatio(330 / 512)
			CPanel.HelpCategory:AddItem(CPanel.Video)

			CPanel.HelpCategory:Help(L"FadingDoorHelp"):DockMargin(0, 0, 0, 0)

			CPanel.Tutorial = vgui.Create("DButton", CPanel)
			CPanel.Tutorial:SetText(L"Tutorial")
			CPanel.Tutorial:SetIcon("icon16/emoticon_grin.png")
			CPanel.Tutorial:SetTall(25)
			CPanel.Tutorial.DoClick = function()
				bKeypads.Tutorial:OpenMenu()
			end
			CPanel.HelpCategory:AddItem(CPanel.Tutorial)
		
		CPanel:AddItem(CPanel.HelpCategory)

		CPanel.ConfigCategory = vgui.Create("ControlPanel", CPanel)
		CPanel.ConfigCategory:SetLabel(L"Configuration")

			local OpenButtonLabel = CPanel.ConfigCategory:Help(L"FadingDoorKey")
			OpenButtonLabel:DockMargin(0, 0, 0, 0)
			OpenButtonLabel:SetContentAlignment(5)
			OpenButtonLabel:SetWrap(false)

			local OpenButton = vgui.Create("DBinder", CPanel)
			OpenButton:SetConVar("bkeypads_fading_door_key")
			OpenButton.bKeypads_Tooltip = L"FadingDoorKeyTip" .. "\n" .. L"FadingDoorLinkTip" .. "\n" .. L"DBinderTip"
			CPanel.ConfigCategory:AddItem(OpenButton)

			local Reversed = CPanel.ConfigCategory:CheckBox(L"Reversed", "bkeypads_fading_door_reversed")
			CPanel.ConfigCategory:CheckBox(L"ToggleActive", "bkeypads_fading_door_toggle")

			if bKeypads.Config.FadingDoors.EnableSounds then
				local SoundPreviewID = 0
				local ActiveSound
				local function PlaySoundOverride(self, ...)
					self:_OnCursorEntered(...)

					if IsValid(ActiveSound) then
						ActiveSound:Stop()
						ActiveSound = nil
					end

					if self.Data ~= "" then
						SoundPreviewID = SoundPreviewID + 1

						local myID = SoundPreviewID

						sound.PlayFile("sound/" .. self:GetValue(), "noplay", function(station, errCode, errStr)
							if myID == SoundPreviewID and IsValid(station) then
								station:Play()
								ActiveSound = station
							end
						end)
					end
				end
				local function StopSoundOverride(self, ...)
					self:_OnCursorExited(self, ...)

					if IsValid(ActiveSound) then
						ActiveSound:Stop()
						ActiveSound = nil
					end
				end
				local function StopSoundSelectedOverride(self, ...)
					if IsValid(ActiveSound) then
						ActiveSound:Stop()
						ActiveSound = nil
					end

					return self:_OnSelect(...)
				end
				local function SoundPreviewOverride(self, ...)
					self:_OpenMenu(...)

					if IsValid(self.Menu) then
						for k, option in ipairs(self.Menu:GetCanvas():GetChildren()) do
							option._OnCursorEntered = option.OnCursorEntered
							option.OnCursorEntered = PlaySoundOverride

							option._OnCursorExited = option.OnCursorExited
							option.OnCursorExited = StopSoundOverride

							option.Data = self:GetOptionData(k)
						end
					end
				end

				local OpenSound = CPanel.ConfigCategory:ComboBox(L"OpenSound", "bkeypads_fading_door_opensound")
				OpenSound:Dock(TOP)
				OpenSound:SetTall(25)
				OpenSound:SetSortItems(false)
				OpenSound:AddChoice(L"None", "", false, "icon16/cross.png")

				local CloseSound = CPanel.ConfigCategory:ComboBox(L"CloseSound", "bkeypads_fading_door_closesound")
				CloseSound:Dock(TOP)
				CloseSound:SetTall(25)
				CloseSound:SetSortItems(false)
				CloseSound:AddChoice(L"None", "", false, "icon16/cross.png")

				for _, snd in ipairs(list.Get("bKeypads_FDoorSounds")) do
					OpenSound:AddChoice(snd)
					CloseSound:AddChoice(snd)
				end
				
				local ActiveSound = CPanel.ConfigCategory:ComboBox(L"ActiveSound", "bkeypads_fading_door_activesound")
				ActiveSound:Dock(TOP)
				ActiveSound:SetTall(25)
				ActiveSound:SetSortItems(false)
				ActiveSound:AddChoice(L"None", "", false, "icon16/cross.png")
				for _, snd in ipairs(list.Get("bKeypads_FDoorLoopSounds")) do
					ActiveSound:AddChoice(snd)
				end

				OpenSound._OpenMenu = OpenSound.OpenMenu
				CloseSound._OpenMenu = CloseSound.OpenMenu
				ActiveSound._OpenMenu = ActiveSound.OpenMenu
				OpenSound.OpenMenu = SoundPreviewOverride
				CloseSound.OpenMenu = SoundPreviewOverride
				ActiveSound.OpenMenu = SoundPreviewOverride
				
				OpenSound._OnSelect = OpenSound.OnSelect
				CloseSound._OnSelect = CloseSound.OnSelect
				ActiveSound._OnSelect = ActiveSound.OnSelect
				OpenSound.OnSelect = StopSoundSelectedOverride
				CloseSound.OnSelect = StopSoundSelectedOverride
				ActiveSound.OnSelect = StopSoundSelectedOverride

				ActiveSound._Think = ActiveSound.Think
				ActiveSound.Think = function()
					if ActiveSound._Think then ActiveSound:_Think() end

					local has_permission = bKeypads.Permissions:Cached(LocalPlayer(), "fading_doors/sounds")
					OpenSound:SetDisabled(not has_permission)
					CloseSound:SetDisabled(not has_permission)
					ActiveSound:SetDisabled(not has_permission)

					local canKeyboardPress = bKeypads.Config.FadingDoors.EnableKeyboardPress and bKeypads.Permissions:Cached(LocalPlayer(), "fading_doors/keyboard")
					if canKeyboardPress ~= OpenButtonLabel:IsVisible() then
						OpenButtonLabel:SetVisible(canKeyboardPress)
						OpenButtonLabel:InvalidateParent()
					end
					if canKeyboardPress ~= OpenButton:IsVisible() then
						OpenButton:SetVisible(canKeyboardPress)
						OpenButton:InvalidateParent()
					end
					if canKeyboardPress == KeypadOnlyFadingDoor:IsVisible() then
						KeypadOnlyFadingDoor:SetVisible(not canKeyboardPress)
						KeypadOnlyFadingDoor:InvalidateParent()
					end
					
					if bKeypads.Config.FadingDoors.Reversible ~= Reversed:IsVisible() then
						Reversed:SetVisible(bKeypads.Config.FadingDoors.Reversible)
						Reversed:InvalidateParent()
					end
				end
			end

			CPanel.ConfigCategory:MatSelect("bkeypads_fading_door_mat", list.Get("bKeypads_FDoorMaterials"), true, 0.33, 0.33)
		
		CPanel:AddItem(CPanel.ConfigCategory)
		
		hook.Run("bKeypads.BuildCPanel", CPanel)
	end
end

if SERVER and bKeypads_FadingDoors_Registry then
	for _, controller in pairs(bKeypads_FadingDoors_Registry) do
		if IsValid(controller) then
			controller:Remove()
		end
	end
end
bKeypads_FadingDoors_Registry = {}

do
	bKeypads.FadingDoors.PickedUp = {}
	function bKeypads.FadingDoors:AllowPickup(ply, fadingDoor, pickup)
		if not IsValid(ply) or not IsValid(fadingDoor) then return end
		if pickup then
			if bKeypads.FadingDoors:IsFaded(fadingDoor) and (not bKeypads.FadingDoors.PickedUp[fadingDoor] or not bKeypads.FadingDoors.PickedUp[fadingDoor][ply]) then
				local canPickup = hook.Run("PhysgunPickup", ply, fadingDoor)
				if canPickup then
					fadingDoor:SetCollisionGroup(COLLISION_GROUP_WORLD)

					bKeypads.FadingDoors.PickedUp[fadingDoor] = bKeypads.FadingDoors.PickedUp[fadingDoor] or {}
					bKeypads.FadingDoors.PickedUp[fadingDoor][ply] = true

					if CLIENT then
						net.Start("bKeypads.FadingDoors.Pickup")
							net.WriteEntity(fadingDoor)
						net.SendToServer()
					end
				end
			end
		else
			if bKeypads.FadingDoors.PickedUp[fadingDoor] and bKeypads.FadingDoors.PickedUp[fadingDoor][ply] then
				bKeypads.FadingDoors.PickedUp[fadingDoor][ply] = nil

				if table.IsEmpty(bKeypads.FadingDoors.PickedUp[fadingDoor]) then
					if bKeypads.FadingDoors:IsFaded(fadingDoor) then
						fadingDoor:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
						local phys = fadingDoor:GetPhysicsObject()
						if IsValid(phys) then
							phys:EnableMotion(false)
						end
					end
					bKeypads.FadingDoors.PickedUp[fadingDoor] = nil
				end
			end
		end
	end

	function bKeypads.FadingDoors:TraceActiveFadingDoor(ply)
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() == "weapon_physgun" and CurTime() >= (wep:GetNextPrimaryFire() or 0) then
			local tr = ply:GetEyeTrace()
			local rayEnts = ents.FindAlongRay(ply:EyePos(), ply:EyePos() + ply:EyeAngles():Forward() * 16384)
			for _, ent in ipairs(rayEnts) do
				if ent == ply or (IsValid(ent:GetParent()) and ent:GetParent() == ply) then
					continue
				end
				if bKeypads.FadingDoors:IsFadingDoor(ent) and bKeypads.FadingDoors:IsFaded(ent) and tr.HitPos:DistToSqr(tr.StartPos) >= ent:NearestPoint(tr.StartPos):DistToSqr(tr.StartPos) then
					return ent
				end
				break
			end
		end
	end

	hook.Add("OnPhysgunFreeze", "bKeypads.FadingDoors.CancelFade", function(wep, phys, ent, ply)
		if bKeypads.FadingDoors:IsFadingDoor(ent) and bKeypads.FadingDoors:IsFaded(ent) and bKeypads.FadingDoors.PickedUp[ent] and bKeypads.FadingDoors.PickedUp[ent][ply] and bKeypads.Permissions:Check(ply, "fading_doors/freeze_cancel") then
			ent.fadeActive = ent.fadeReversed
			bKeypads.FadingDoors:DoFade(ent)
		end
	end)

	hook.Add("PhysgunDrop", "bKeypads.FadingDoors.Drop", function(ply, ent)
		if IsValid(ent) and bKeypads.FadingDoors:IsFadingDoor(ent) then
			bKeypads.FadingDoors:AllowPickup(ply, ent, false)
		end
	end)

	if SERVER then
		util.AddNetworkString("bKeypads.FadingDoors.Pickup")
		net.Receive("bKeypads.FadingDoors.Pickup", function(_, ply)
			local ent = net.ReadEntity()
			if IsValid(ent) and bKeypads.FadingDoors:IsFadingDoor(ent) and ent == bKeypads.FadingDoors:TraceActiveFadingDoor(ply) then
				bKeypads.FadingDoors:AllowPickup(ply, ent, true)
			end
		end)
	else
		hook.Add("FinishMove", "bKeypads.FadingDoors.AllowPickup", function(mv)
			if mv:KeyDown(IN_ATTACK) then
				local wep = LocalPlayer():GetActiveWeapon()
				if IsValid(wep) and wep:GetClass() == "weapon_physgun" and CurTime() >= (wep:GetNextPrimaryFire() or 0) then
					local fadingDoor = bKeypads.FadingDoors:TraceActiveFadingDoor(LocalPlayer())
					if IsValid(fadingDoor) then
						bKeypads.FadingDoors:AllowPickup(LocalPlayer(), fadingDoor, true)
					end
					return
				end
			end
			if not table.IsEmpty(bKeypads.FadingDoors.PickedUp) then
				bKeypads.FadingDoors.PickedUp = {}
			end
		end)
	end
end
--addons/bkeypads/lua/bkeypads_custom_access.lua:
bKeypads.CustomAccess:Reset() --[[ Don't delete this line
               
                  ___          _                      ___                           
                 / __\   _ ___| |_ ___  _ __ ___     / _ \_ __ ___  _   _ _ __  ___ 
                / / | | | / __| __/ _ \| '_ ` _ \   / /_\/ '__/ _ \| | | | '_ \/ __|
               / /__| |_| \__ \ || (_) | | | | | | / /_\\| | | (_) | |_| | |_) \__ \
               \____/\__,_|___/\__\___/|_| |_| |_| \____/|_|  \___/ \__,_| .__/|___/
                                                                         |_|        

In this file you can define custom groups of teams and custom Lua functions which players can use
to authorize people on their keypads.

Some basic knowledge of Lua syntax is required.

By the way, in case you didn't know, DarkRP jobs are the same thing as teams.

====================================================================================================

                             __                           _           
                            /__\_  ____ _ _ __ ___  _ __ | | ___  ___ 
                           /_\ \ \/ / _` | '_ ` _ \| '_ \| |/ _ \/ __|
                          //__  >  < (_| | | | | | | |_) | |  __/\__ \
                          \__/ /_/\_\__,_|_| |_| |_| .__/|_|\___||___/
                                                   |_|                
                            	
Example 1
=========
This example defines a TEAM GROUP which represents all law enforcement teams.

bKeypads:AddTeamGroup("Law Enforcement", {
	TEAM_POLICE,
	TEAM_CHIEF,
	TEAM_MAYOR,
})

Example 2
=========
This example defines a TEAM GROUP which represents all hospital workers.

bKeypads:AddTeamGroup("Hospital Staff", {
	TEAM_PARAMEDIC,
	TEAM_DOCTOR,
	TEAM_NURSE,
	TEAM_COLONOSCOPIST,
})

Example 3
=========
This example defines a LUA FUNCTION which returns whether the player has law enforcement
permissions on DarkRP.

This is basically Example 1, but using a Lua function instead.

bKeypads:AddCustomGroup("Police", function(ply, keypad, keycard)
	-- Note: keycard only exists if the keypad is scanning one
	return ply:isCP()
end)

Example 4
=========
This example defines a TEAM GROUP which represents all Class B personnel on SCP-RP.

bKeypads:AddTeamGroup("Class B", {
	TEAM_RESEARCHER,
	TEAM_SECURITY,
	TEAM_MTF,
	TEAM_MTF_COMMANDER,
	TEAM_O5,
	TEAM_FIELD_AGENT,
})

Yes I'm aware that I've probably spectacularly fucked up the lore there, but it's just an example :D

Example 5
=========
This example defines a LUA FUNCTION which returns whether a player has an SCP keycard whose level falls in a certain range.

This example would obviously only work if you've written a custom SCP keycard system for your server or are using a Workshop addon
or similar which exposes some custom Lua functions. PLAYER:GetSCPKeycardLevel() is a completely arbritrary example.

bKeypads:AddCustomGroup("Level 3", function(ply, keypad, keycard)
	-- Note: keycard only exists if the keypad is scanning one
	return ply:GetSCPKeycardLevel() >= 3
end)

====================================================================================================
                                      WRITE CODE BELOW THESE LINES
====================================================================================================]]

local function addFaction(targetFaction)
	bKeypads:AddCustomGroup(targetFaction:GetName(), function(keypad, ply, keycard)
		local char = ply:GetCurrentCharacter()
		if char then
			local faction = char:GetFaction()
			if faction and faction == targetFaction then
				return true
			end

			local extraFaction = char:GetExtraFaction()
			if extraFaction and extraFaction == targetFaction then
				return true
			end
		end

		return false
	end)
end

if Faction then
	for _, faction in pairs(Faction:GetCache()) do
		addFaction(faction)
	end
end

hook.Add("Faction.Load", "KeycardLoadFaction", function(faction)
	addFaction(faction)
end)

hook.Add("Faction.Created", "KeycardCreatedFaction", function(faction)
	addFaction(faction)
end)

--hook.Add("Faction.Delete", "KeycardDeleteFaction", function(faction)
--	bKeycardScanner.Config.customChecks[faction:GetName()] = nil
--end)

--addons/bkeypads_cracker/lua/bkeypads_cracker_config.lua:
bKeypads.Cracker:SetConfig({ -- Don't touch this line

--################################################################################################################--
--[[##############################################################################################################--
      
      
       ██████╗ ██╗██╗     ██╗  ██╗   ██╗███████╗    ██╗  ██╗███████╗██╗   ██╗██████╗  █████╗ ██████╗ ███████╗
       ██╔══██╗██║██║     ██║  ╚██╗ ██╔╝██╔════╝    ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗██╔════╝
       ██████╔╝██║██║     ██║   ╚████╔╝ ███████╗    █████╔╝ █████╗   ╚████╔╝ ██████╔╝███████║██║  ██║███████╗
       ██╔══██╗██║██║     ██║    ╚██╔╝  ╚════██║    ██╔═██╗ ██╔══╝    ╚██╔╝  ██╔═══╝ ██╔══██║██║  ██║╚════██║
       ██████╔╝██║███████╗███████╗██║   ███████║    ██║  ██╗███████╗   ██║   ██║     ██║  ██║██████╔╝███████║
       ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝   ╚══════╝    ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝
      

    https://www.gmodstore.com/market/view/billys-keypads
    
    Thank you for purchasing my script and supporting my work :D I hope this will enrich your server.
	Make sure you've followed the installation instructions and activated your license if you haven't already.

	Using a leak? That's okay -- sometimes it's hard to justify splashing out on a new server, for example.
	But please be safe - the VAST majority of leaks contain backdoors and malicious code that can destroy
	your server and attract malicious players.

	If your server is successful, don't forget to support the creators who provided you with their hard work.

--################################################################################################################--
--################################################################################################################--

	This Lua file allows you to configure Billy's Deployable Keypad Crackers.

	PLEASE DO NOT EDIT THIS FILE IN NOTEPAD - IT'S LIKE TRYING TO DO SURGERY WITH A KITCHEN KNIFE.
	Use one of these:
	https://www.sublimetext.com/
	https://notepad-plus-plus.org/downloads/
	https://code.visualstudio.com/

	Unfortunately I cannot provide support regarding configuring the addon as I would just get flooded and wouldn't
	have time to help people with bugs or errors so please reach out to friends or the Internet if you need help.

	It follows the same syntax as actual Lua code so if you make a typo you are likely to break it. Be careful.

	Don't change anything in this file except for the settings themselves unless you know what you are doing.

	This config file uses Simplerr (the same thing DarkRP uses) to help you understand any errors.
	https://fptje.github.io/glualint-web/ can also help you debug your config file.

	Good luck, have fun :D

]]--##############################################################################################################--
--##[[                                                  DarkRP                                                ]]##--

-- Want to make a job spawn with a keypad cracker?
-- Give them the bkeypads_cracker weapon :)

F4Cracker = {
	-- Should the keypad cracker be added to the DarkRP F4 menu as a purchaseable weapon?
	EnableSingle = true,

	-- Should the keypad cracker be added to the DarkRP F4 menu as a purchaseable shipment?
	EnableShipment = true,

	Single = {
		-- The name of the F4 menu weapon
		-- If changing this doesn't work, your F4 menu isn't very well made
		label = "Keypad Cracker",

		amount = 1,
		price = 500,

		sortOrder = 0,
		category = "Other",

		customCheck = function(ply)
			return table.HasValue(ply:getJobTable().weapons, "bkeypads_cracker") -- This means only people whose job spawns with a keypad cracker can buy it
		end,
	},

	Shipment = {
		-- The name of the F4 menu shipment
		-- If changing this doesn't work, your F4 menu isn't very well made
		label = "Keypad Cracker",

		amount = 10,
		allowed = { TEAM_GUN },
		price = 5000,

		sortOrder = 0,
		category = "Other",
	},
},

--################################################################################################################--
--##[[                                                  CONFIG                                                ]]##--

-- While cracking, should the keypad cracker be deployed on the keypad, or should it be held in the players hands?
Deployed = true,

-- How long does it take to crack a keypad in seconds?
-- The cracking time is chosen randomly in between the two numbers, e.g. between 20 and 30 seconds.
-- The first number is the lower range, and the second number is the higher range.
CrackTime = {20, 30},

-- Here you can define special crack times
-- If a player is eligible for multiple special crack times, the one with the shortest duration will be selected.
SpecialCrackTimes = {
	--[[
	Custom check functions for advanced users

	{
		-- This special crack time will only apply to DarkRP police
		function(ply, keypad)
			if DarkRP and ply.isCP and ply:isCP() then
				return true
			end
		end,

		{30, 60}
	},

	{
		function(ply, keypad)
			return ply:SteamID() == "STEAM_0:1:40314158"
		end,
		
		-- You can also specify your own custom function for the crack time
		function(ply, keypad)
			return math.random(1, 5)
		end,
	},

	--]]
},

-- Add sunglasses to keypad cracker faces for players with special crack times?
SpecialSunglasses = false,

-- (DarkRP only) How much money to give a police officer if they stunstick a keypad cracker?
SeizeReward = 500,

-- (DarkRP only) Should the stunstick destroy keypad crackers or simply drop them off keypads?
StunstickDestroys = false,

-- Distance keypad cracker can be deployed from
CrackDistance = 2500,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed when they disconnect?
DestroyDeployedCrackersOnDisconnect = true,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed when they disconnect?
DestroyDroppedCrackersOnDisconnect = true,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed if they die?
DestroyDeployedCrackersOnDeath = false,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed if they die?
DestroyDroppedCrackersOnDeath = true,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed if they switch teams?
DestroyDeployedCrackersOnSwitch = true,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed if they switch teams?
DestroyDroppedCrackersOnSwitch = true,

-- Should DEPLOYED (actively cracking) keypad crackers be destroyed when they finish cracking?
-- This makes them one-time use items.
DestroyCrackersWhenFinished = false,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be REPLACED if they crack a different keypad?
ReplaceOldDeployedCrackers = true,

-- Should a player's DROPPED (on the ground) keypad crackers be REPLACED if they crack a different keypad?
ReplaceOldDroppedCrackers = true,

-- If a player's keypad cracker gets destroyed, magically give them a new one?
ReplaceDestroyedCrackers = true,

-- In seconds, how long should it take for a DROPPED (on the ground) keypad cracker to destroy itself?
-- Set to 0 to disable
DroppedKeypadCrackerTimeout = 600,

-- Allow players to pick up DROPPED (on the ground) keypad crackers even if they didn't deploy them?
-- NOTE: This can be controlled through OpenPermissions (allowing you to specify teams that can pick them up)
AnyoneCanPickup = true,

-- Allow players to stop DEPLOYED (actively cracking) keypad crackers by pressing E even if they didn't deploy them?
-- Does nothing if keypad cracker damage is enabled.
-- NOTE: This can be controlled through OpenPermissions (allowing you to specify teams that can pick them up)
AnyoneCanStopCracker = true,

-- Allow players who spawned with the keypad cracker to pick up DROPPED (on the ground) keypad crackers even if they didn't deploy them?
LoadoutCanPickup = true,

-- Should DROPPED (on the ground) keypad crackers be visible through walls to the player who deployed it?
SeeDroppedCrackerThroughWalls = true,

Damage = {
	-- Can keypad crackers take damage?
	Enable = true,

	-- Should keypad crackers that take damage be destroyed by it?
	-- If not, they will simply drop off the keypad
	Destroy = true,

	-- Can DROPPED keypad crackers be destroyed?
	-- Does nothing if Destroy is false
	CanDestroyDropped = true,

	-- How much damage is required for a deployed cracker to drop off a keypad?
	-- Set to 0 for instant drop
	Health = 250,

	-- Show a health bar on DEPLOYED (actively cracking) keypad crackers?
	HealthBar = true,

	-- Should only certain damage types damage the keypad cracker?
	-- https://wiki.facepunch.com/gmod/Enums/DMG
	DamageTypeWhitelist = {
		-- DMG_BULLET,
		-- DMG_SLASH,
		-- DMG_CLUB,
		-- DMG_BUCKSHOT,
		-- DMG_SNIPER,
		-- DMG_GENERIC,
	},

	-- Should certain damage types be blocked from damaging the keypad cracker?
	-- https://wiki.facepunch.com/gmod/Enums/DMG
	DamageTypeBlacklist = {
		DMG_VEHICLE,
		DMG_POISON,
		DMG_PHYSGUN,
		DMG_CLUB
	},

	-- Allow bullets to damage keypads through walls?
	DamageThroughWalls = false,

	-- Should damage apply force to dropped keypad crackers?
	-- Players will be able to shoot dropped keypad crackers around
	DamageForce = true,
},

Beeps = {
	-- Emit the classic keypad cracking beep noises?
	Enable = true,

	-- How often should beeps be played?
	BeepInterval = 3,

	-- The distance/volume the beeps can be heard from.
	-- Measured in dB, https://wiki.facepunch.com/gmod/Enums/SNDLVL
	-- Don't actually use SNDLVL_* here, use the number they represent
	BeepVolume = 100,
},

-- Should there be a random chance that a keypad crack could fail entirely?
-- 0 = never fail
-- 1 = always fail
FailChance = 0.1,

-- Should the keypad cracker trigger "Access Denied" on the keypad if it fails?
AccessDeniedOnFail = true,

-- Should the keypad cracker trigger "Access Denied" on the keypad if cracking is somehow aborted?
AccessDeniedOnAbort = true,

-- The phrases shown on the keypad cracker's screen when it's being deployed
-- Only alphanumeric latin characters are supported (A-Z a-z 0-9)
CrackerPhrases = {
	"LET ME IN",
	"LETS GO",
	"ITS TIME",
	"PROTECT ME",
	"GOOD LUCK",
	"YOU GOT THIS",
}


--################################################################################################################--
--################################################################################################################--
}) -- Don't touch this line
--lua/autorun/awv2_addparticle.lua:
game.AddParticles( "particles/thw_river_aw.pcf" )
--addons/ballistic_shields/lua/autorun/ballistic_shields_loader.lua:
if SERVER then
	AddCSLuaFile("ballistic_shields/cl_bs_util.lua")
	AddCSLuaFile( "ballistic_shields/sh_bs_util.lua" )
	AddCSLuaFile( "ballistic_shields/sh_bs_lang.lua" )
	AddCSLuaFile("libraries/cl_surfacegeturl.lua")
	AddCSLuaFile("bs_config.lua")
	resource.AddWorkshop("1819166858")
end
include( "bs_config.lua" )
include( "libraries/cl_surfacegeturl.lua" )
include( "ballistic_shields/cl_bs_util.lua" )
include( "ballistic_shields/sh_bs_util.lua" )
include( "ballistic_shields/sh_bs_lang.lua" )
resource.AddFile( "resource/fonts/bfhud.ttf" )
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/bkeypads/lua/autorun/bkeypads_prediction.lua:
local Prediction_Deploy, Prediction_Holster
function bKeypads_Prediction(tbl)
	if SERVER then
		tbl.m_fbKeypadsDeploy = tbl.m_fbKeypadsDeploy or tbl.Deploy
		tbl.m_fbKeypadsHolster = tbl.m_fbKeypadsHolster or tbl.Holster

		tbl.Deploy = Prediction_Deploy
		tbl.Holster = Prediction_Holster
	end
end

if SERVER then
	util.AddNetworkString("bKeypads.PredictionWorkaround")

	function Prediction_Deploy(self)
		local returnVal
		if self.m_fbKeypadsDeploy then
			returnVal = self.m_fbKeypadsDeploy(self)
			if returnVal == false then return false end
		end

		if self.m_fbKeypadsDeployed == true then return returnVal end
		self.m_fbKeypadsDeployed = true
		self.m_fbKeypadsHolstered = nil

		if self.Deployed then self:Deployed() end

		if not IsValid(self:GetOwner()) then return returnVal end

		net.Start("bKeypads.PredictionWorkaround")
			net.WriteBool(self.Mode ~= nil)
			if self.Mode ~= nil then
				net.WriteString(self.Mode)
			else
				net.WriteEntity(self)
				net.WriteString(self:GetClass())
			end
			net.WriteBool(true)
		net.Send(self:GetOwner())

		return returnVal
	end

	function Prediction_Holster(self)
		local returnVal
		if self.m_fbKeypadsHolster then
			returnVal = self.m_fbKeypadsHolster(self)
			if returnVal == false then return false end
		end

		if self.m_fbKeypadsHolstered == true then return returnVal end
		self.m_fbKeypadsHolstered = true
		self.m_fbKeypadsDeployed = nil

		if self.Holstered then self:Holstered() end

		if not IsValid(self:GetOwner()) then return returnVal end

		net.Start("bKeypads.PredictionWorkaround")
			net.WriteBool(self.Mode ~= nil)
			if self.Mode ~= nil then
				net.WriteString(self.Mode)
			else
				net.WriteEntity(self)
				net.WriteString(self:GetClass())
			end
			net.WriteBool(false)
		net.Send(self:GetOwner())

		return returnVal
	end
else
	net.Receive("bKeypads.PredictionWorkaround", function()
		local interface
		if net.ReadBool() then
			-- STOOL

			interface = LocalPlayer():GetTool(net.ReadString())
			if not interface then return end
		else
			-- SWEP
			local SWEP = net.ReadEntity()
			local fallbackClass = net.ReadString()
			if not IsValid(SWEP) then
				local func = net.ReadBool() and "Deployed" or "Holstered"
				bKeypads:nextTick(function()
					local interface = LocalPlayer():GetWeapon(fallbackClass)
					if IsValid(interface) and isfunction(interface[func]) then
						interface[func](interface)
					end
				end)
				return
			end

			interface = SWEP
		end

		local func = interface[net.ReadBool() and "Deployed" or "Holstered"]
		if func then func(interface) end
	end)
end

if CLIENT then
	local function Initialize(self)
		-- Store initialized state
		self.m_bInitialized = true

		local initFunc = self._Initialize
		self._Initialize = nil

		-- Check if it has an Initialize function and call it
		if initFunc then
			initFunc(self)
		end

		-- Uninject Initialize fix
		self.Initialize = initFunc
	end
	local function Think(self)
		-- Check if Initialize function is our fixed one
		if not self.m_bInitialized and self.Initialize == Initialize then
			-- Initialize the entity, clearly gmod failed to call this for whatever reason
			self:Initialize()
		end

		-- Check if it has a Think function and call it
		if self._Think then
			self:_Think()
		end
		
		if self.m_bInitialized then
			-- Uninject Initialize fix
			self.Think = self._Think
			self._Think = nil
		end
	end
	function bKeypads_Initialize_Fix(ENT)
		if ENT.Initialize == Initialize or ENT.Think == Think or ENT._Initialize ~= nil or ENT._Think ~= nil then return end

		ENT._Initialize = ENT.Initialize
		ENT._Think = ENT.Think

		ENT.Initialize = Initialize
		ENT.Think = Think
	end
else
	bKeypads_Initialize_Fix = function() end
end
--lua/autorun/chirrut.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Chirrut",		"models/player/tiki/chirrut.mdl" )

--lua/autorun/cis_leaders.lua:
--Add Playermodel
player_manager.AddValidModel( "Poggle the Lesser", "models/player/nsn/poggle.mdl" ) 
list.Set( "PlayerOptionsModel",  "Poggle the Lesser", "models/player/nsn/poggle.mdl" ) 
player_manager.AddValidModel( "Nute Gunray", "models/player/nsn/gunray.mdl" ) 
list.Set( "PlayerOptionsModel",  "Nute Gunray", "models/player/nsn/gunray.mdl" ) 
player_manager.AddValidModel( "Wat Tambor", "models/player/nsn/wattambor_noanim.mdl" ) 
list.Set( "PlayerOptionsModel",  "Wat Tambor", "models/player/nsn/wattambor_noanim.mdl" )
--addons/climb_swep_2/lua/autorun/cl_roll.lua:
local curPitch = 0
local deg = 0
local inRoll = false

local function rollTo()
	if not ThirdPerson or not ThirdPerson.Enabled then
		deg = net.ReadInt(16)
		inRoll = true
		curPitch = deg-360
	end

end
net.Receive("ClimbRoll", rollTo)

hook.Add("CalcView", "ClimbRollEffect", function(ply, pos, ang, fov)
	
	if (!inRoll) then return; end
	
	local view = GAMEMODE:CalcView(ply, pos, ang, fov)
	curPitch = math.Approach(curPitch, deg, FrameTime() * 625)
	if curPitch == deg then inRoll = false; end
	view.angles.p = curPitch
	return view
	
end)


--lua/autorun/dutchess_satine.lua:
player_manager.AddValidModel( "Dutchess Satine", "models/player/mandalorian/dutchess_satine.mdl" );
--lua/autorun/egm_41st.lua:
-- Register the 41st material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.41stTrooper", function()
	-- 41st Body Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_trooper", "41st - Trooper Armor", {
		["body"] = "egm/41st/trooper/body",
		["body_mirrored"] = "egm/41st/trooper/body",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Body 2 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_trooper_2", "41st - Trooper 2 Armor", {
		["body"] = "egm/41st/trooper/body_2",
		["body_mirrored"] = "egm/41st/trooper/body_2",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Body RMC Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_trooper_rmc", "41st - Trooper rmc Armor", {
		["body"] = "egm/41st/trooper/body_rmc",
		["body_mirrored"] = "egm/41st/trooper/body_rmc",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Body TEB Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_trooper_teb", "41st - Trooper teb Armor", {
		["body"] = "egm/41st/trooper/body_teb",
		["body_mirrored"] = "egm/41st/trooper/body_teb",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Body Vet Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_trooper_vet", "41st - Trooper vet Armor", {
		["body"] = "egm/41st/trooper/body_vet",
		["body_mirrored"] = "egm/41st/trooper/body_vet",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_trooper", "41st - Trooper Helmet", {
		["helmet"] = "egm/41st/trooper/helmet",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Helmet 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_trooper_2", "41st - Trooper Helmet 2", {
		["helmet"] = "egm/41st/trooper/helmet_2",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Helmet RMC
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_trooper_rmc", "41st - Trooper Helmet RMC", {
		["helmet"] = "egm/41st/trooper/helmet_rmc",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Helmet vet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_trooper_vet", "41st - Trooper Helmet Vet", {
		["helmet"] = "egm/41st/trooper/helmet_vet",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	--41st Lore Chars -- 
	-- 41st Trooper Clanky Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Clanky", "41st - Trooper Clanky Armor", {
		["body"] = "egm/41st/lore/clanky/body",
		["body_mirrored"] = "egm/41st/lore/clanky/body",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Clanky Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Clanky", "41st - Trooper Clanky Helmet", {
		["helmet"] = "egm/41st/lore/clanky/helmet",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Cooker Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Cooker", "41st - Trooper Cooker Armor", {
		["body"] = "egm/41st/lore/cooker/body",
		["body_mirrored"] = "egm/41st/lore/cooker/body",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Cooker Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Cooker", "41st - Trooper Cooker Helmet", {
		["helmet"] = "egm/41st/lore/cooker/helmet",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Draa Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Draa", "41st - Trooper Draa Armor", {
		["body"] = "egm/41st/lore/draa/body_draa",
		["body_mirrored"] = "egm/41st/lore/draa/body_draa",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Draa Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Draa", "41st - Trooper Draa Helmet", {
		["helmet"] = "egm/41st/lore/draa/helmet_draa",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Faie Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Faie", "41st - Trooper Faie Armor", {
		["body"] = "egm/41st/lore/faie/body_faie",
		["body_mirrored"] = "egm/41st/lore/faie/body_faie",

		["kama"] = "egm/41st/lore/faie/heavy_faie",
		["kama_arc"] = "egm/41st/lore/faie/kama_arc_faie",

		["pauldron"] = "egm/41st/lore/faie/specialist_faie",
		["ammo_arm"] = "egm/41st/lore/faie/specialist_faie",

		["strap"] = "egm/41st/lore/faie/heavy_faie",
        ["ammo_shoulder"] = "egm/41st/lore/faie/heavy_faie",
	})
	-- 41st Trooper Faie Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Faie", "41st - Trooper Faie Helmet", {
		["helmet"] = "egm/41st/lore/faie/helmet_faie",
		["binoculars"] = "egm/41st/lore/faie/specialist_faie",
	})
	-- 41st Trooper Gett Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Gett", "41st - Trooper Gett Armor", {
		["body"] = "egm/41st/lore/gett/body_gett",
		["body_mirrored"] = "egm/41st/lore/gett/body_gett",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Gett Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Gett", "41st - Trooper Gett Helmet", {
		["helmet"] = "egm/41st/lore/gett/helmet_gett",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper Gree Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Gree", "41st - Trooper Gree Armor", {
		["body"] = "egm/41st/lore/gree/body_gree",
		["body_mirrored"] = "egm/41st/lore/gree/body_gree",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/41st/trooper/kama_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	-- 41st Trooper Gree Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Gree", "41st - Trooper Gree Helmet", {
		["helmet"] = "egm/41st/lore/gree/helmet_gree",
		["binoculars"] = "egm/41st/trooper/specialist",
	}) 
	-- 41st Trooper Gree Armor Camo
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_lore_Gree_Camo", "41st - Trooper Gree Armor Camo", {
		["body"] = "egm/41st/lore/gree/body_gree_camo",
		["body_mirrored"] = "egm/41st/lore/gree/body_gree_camo",

		["kama"] = "egm/41st/camo/heavy_camo",
		["kama_arc"] = "egm/41st/camo/kama_camo_arc",

		["pauldron"] = "egm/41st/camo/specialist_camo",
		["ammo_arm"] = "egm/41st/camo/specialist_camo",

		["strap"] = "egm/41st/camo/heavy_camo",
        ["ammo_shoulder"] = "egm/41st/camo/heavy_camo",
	})
	-- 41st Trooper Gree Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_lore_Gree_Camo", "41st - Trooper Gree Helmet Camo", {
		["helmet"] = "egm/41st/lore/gree/helmet_gree_camo",
		["binoculars"] = "egm/41st/camo/specialist_camo",
	}) 	
-- 41st GC
	-- 41st Trooper GC Armor 1
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_gc_Trooper", "41st - Trooper GC Armor", {
		["body"] = "egm/41st/gc/body_gc",
		["body_mirrored"] = "egm/41st/gc/body_gc",

		["kama"] = "egm/41st/gc/heavy_gc",
		["kama_arc"] = "egm/41st/gc/kama_gc_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/gc/heavy_gc",
        ["ammo_shoulder"] = "egm/41st/gc/heavy_gc",
	})
	-- 41st Trooper GC Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_gc_Trooper", "41st - Trooper GC Helmet", {
		["helmet"] = "egm/41st/gc/helmet_gc",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st Trooper GC Armor 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_gc_Trooper 2", "41st - Trooper GC Armor 2", {
		["body"] = "egm/41st/gc/body_gc_2",
		["body_mirrored"] = "egm/41st/gc/body_gc_2",

		["kama"] = "egm/41st/gc/heavy_gc",
		["kama_arc"] = "egm/41st/gc/kama_gc_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/gc/heavy_gc",
        ["ammo_shoulder"] = "egm/41st/gc/heavy_gc",
	})
	-- 41st Trooper GC Helmet 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_gc_Trooper 2", "41st - Trooper GC Helmet 2", {
		["helmet"] = "egm/41st/gc/helmet_gc_2",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
--41st Camo -- 
	-- 41st Trooper Camo Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_camo_Trooper", "41st - Trooper Camo Armor", {
		["body"] = "egm/41st/camo/body_camo",
		["body_mirrored"] = "egm/41st/camo/body_camo",

		["kama"] = "egm/41st/camo/heavy_camo",
		["kama_arc"] = "egm/41st/camo/kama_camo_arc",

		["pauldron"] = "egm/41st/camo/specialist_camo",
		["ammo_arm"] = "egm/41st/camo/specialist_camo",

		["strap"] = "egm/41st/camo/heavy_camo",
        ["ammo_shoulder"] = "egm/41st/camo/heavy_camo",
	})
	-- 41st Trooper Camo Medic Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_camo_Trooper_medic", "41st - Trooper Camo Medic Armor", {
		["body"] = "egm/41st/camo/body_camo_medic",
		["body_mirrored"] = "egm/41st/camo/body_camo_medic",

		["kama"] = "egm/41st/camo/heavy_camo",
		["kama_arc"] = "egm/41st/camo/kama_camo_arc",

		["pauldron"] = "egm/41st/camo/specialist_camo",
		["ammo_arm"] = "egm/41st/camo/specialist_camo",

		["strap"] = "egm/41st/camo/heavy_camo",
        ["ammo_shoulder"] = "egm/41st/camo/heavy_camo",
	})
	-- 41st Trooper Camo teb Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_camo_Trooper_teb", "41st - Trooper Camo teb Armor", {
		["body"] = "egm/41st/camo/body_camo_teb",
		["body_mirrored"] = "egm/41st/camo/body_camo_teb",

		["kama"] = "egm/41st/camo/heavy_camo",
		["kama_arc"] = "egm/41st/camo/kama_camo_arc",

		["pauldron"] = "egm/41st/camo/specialist_camo",
		["ammo_arm"] = "egm/41st/camo/specialist_camo",

		["strap"] = "egm/41st/camo/heavy_camo",
        ["ammo_shoulder"] = "egm/41st/camo/heavy_camo",
	})
	-- 41st Trooper Camo Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "41st_camo_Trooper", "41st - Trooper Camo Helmet", {
		["helmet"] = "egm/41st/camo/helmet_camo",
		["binoculars"] = "egm/41st/trooper/specialist",
	})
	-- 41st ARF Camo Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "41st_camo_arf", "41st - ARF Camo Helmet", {
		["helmet_arf"] = "egm/41st/camo/helmet_arf_camo",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
	})
	-- 41st Trooper ARF Armor 1 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_arf_Trooper_1", "41st - Trooper ARF Armor 1", {
		["body"] = "egm/41st/arf/body_arf",
		["body_mirrored"] = "egm/41st/arf/body_arf",

		["kama"] = "egm/41st/arf/heavy_arf",
		["kama_arc"] = "egm/41st/arf/kama_arf_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/arf/heavy_arf",
        ["ammo_shoulder"] = "egm/41st/arf/heavy_arf",
	})
	-- 41st ARF Camo Helmet 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "41st_arf_trooper_1", "41st - ARF Helmet1", {
		["helmet_arf"] = "egm/41st/arf/helmet_arf",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
		["armor"] = "egm/41st/arf/armor_arf",
	})
	-- 41st Trooper ARF Armor 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_arf_Trooper_2", "41st - Trooper ARF Armor 2", {
		["body"] = "egm/41st/arf/body_arf_2",
		["body_mirrored"] = "egm/41st/arf/body_arf_2",

		["kama"] = "egm/41st/arf/heavy_arf",
		["kama_arc"] = "egm/41st/arf/kama_arf_arc",

		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/arf/heavy_arf",
        ["ammo_shoulder"] = "egm/41st/arf/heavy_arf",
	})
	-- 41st ARF Camo Helmet 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "41st_arf_trooper_2", "41st - ARF Helmet2", {
		["helmet_arf"] = "egm/41st/arf/helmet_arf_2",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
		["armor"] = "egm/41st/arf/armor_arf",
	})
	-- 41st ARF Camo Helmet RMC
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "41st_arf_trooper_rmc", "41st - ARF Helmet RMC", {
		["helmet_arf"] = "egm/41st/arf/helmet_arf_rmc",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
		["armor"] = "egm/41st/arf/armor_arf",
	})
	-- 41 Synthmesh Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "41st_synthmesh", "41st - Synthmesh Body", {
		["synthmesh"] = "egm/41st/synthmesh/synthmesh",

		["kama"] = "egm/41st/synthmesh/heavy",
	})
	-- 41st Synthmesh Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "41st_synthmesh", "41st - Synthmesh Helmet", {
		["helmet_synthmesh"] = "egm/41st/synthmesh/helmet",
	})
	-- 41st Synthmesh Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "41st_synthmesh", "41st - Synthmesh Backpack", {
		["bp_utility"] = "egm/41st/synthmesh/bp_utility",
	})
	-- 41st CTP Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "41st_ctp", "41st - Pilot Helmet", {
		["helmet_pilot"] = "egm/41st/ctp/helmet_ctp",
	})
	-- 41st Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "41st_backpack", "41st - Backpack", {
		["backpack"] = "egm/41st/trooper/heavy",
	})
	-- 41st Backpack Camo
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "41st_backpack_camo", "41st - Backpack Camo", {
		["backpack"] = "egm/41st/camo/heavy_camo",
	})
end)
--lua/autorun/egm_basilikum.lua:
-- Register the CTP Custom Char Basilikum Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTPBasilikum", function()
	-- Basilikum Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_basilikum", "CTP Basilikum - Armor", {
        ["body"] = "egm/custom_char/ctp/basilikum/body",
		["body_mirrored"] = "egm/custom_char/ctp/basilikum/body",

		["kama_arc"] = "egm/custom_char/ctp/nymphix/arc_kama",
    })
	-- Helmet Pilot
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_basilikum", "CTP Basilikum Pilot - Helmet", {
		["helmet_pilot"] = "egm/custom_char/ctp/basilikum/helmet",
	})
end)
--lua/autorun/egm_burnout.lua:
-- Register the CTP Custom Char Burnout Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTPBurnout", function()
	-- Burnout Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_burnout", "CTP Burnout - Armor", {
        ["body"] = "egm/custom_char/ctp/burnout/body",
		["body_mirrored"] = "egm/custom_char/ctp/burnout/body_1",

		["kama_arc"] = "egm/custom_char/ctp/burnout/kama_arc",
    })
	-- Helmet Pilot
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_burnout", "CTP Burnout Pilot - Helmet", {
		["helmet_pilot"] = "egm/custom_char/ctp/burnout/helmet",
	})
	-- Helmet Airborne
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "ctp_burnout_airborne", "CTP Burnout Airborne - Helmet", {
		["helmet_airborne"] = "egm/custom_char/ctp/burnout/helmet_1",
	})
end)
--lua/autorun/egm_du_new.lua:
-- Register the Dooms Unit material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.DUTrooper", function()
	-- LC Doom -- 
	-- Doom Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "CMD_Doom", "Dooms Unit - Doom Armor", {
		["body"] = "egm/du/dooom/body",
		["body_mirrored"] = "egm/du/dooom/body2",

		["kama_arc"] = "egm/du/dooom/arc_kama",
		["rank_tab"] = "egm/du/doom/rank_tab", 
		
		["pauldron_big"] = "egm/du/dooom/pauldron_big",
		["holsters"] = "egm/du/dooom/gear",
		["pockets"] = "egm/du/dooom/gear",
		["arc_gear_body"] = "egm/du/dooom/gear",
		["arc_gear_legs"] = "egm/du/dooom/gear",
		["arc_gear_arms"] = "egm/du/dooom/gear",
		["pauldron_arc_pockets"] = "egm/du/dooom/gear", 
	})
	-- Doom Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "CMD_Doom", "Dooms Unit - Doom Helmet", {
		["helmet"] = "egm/du/dooom/helmet",
		["sunvisor"] = "egm/du/dooom/heavy", 
	})
	-- DU Body PVT 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DU_PVT", "Dooms Unit - PVT Armor", {
		["body"] = "egm/du/trooper/body",
		["body_mirrored"] = "egm/du/trooper/body",
		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy2",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})	
	-- DU Helmet PVT
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_PVT", "Dooms Unit - PVT Helmet", {
		["helmet"] = "egm/du/trooper/helmet_pvt",
	})
	-- DU Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "DU_PVT", "Dooms Unit - Backpack", {
		["backpack"] = "egm/du/shared/backpack",
	})
	-- Defense Trooper -- 
	-- DT Body PVT 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DT_PVT", "Dooms Unit - DT PVT Armor", {
		["body"] = "egm/du/dt/body_pvt",
		["body_mirrored"] = "egm/du/dt/body_pvt",
		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy2",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})	
	-- DT Body SGT 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DT_SGT", "Dooms Unit - DT SGT Armor", {
		["body"] = "egm/du/dt/body_sgt",
		["body_mirrored"] = "egm/du/dt/body_sgt",
		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})	
	-- DT Helmet SGT
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DT_SGT", "Dooms Unit - DT SGT Helmet", {
		["helmet"] = "egm/du/trooper/helmet_sgt",
	})
	-- DT Body LT
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DT_LT", "Dooms Unit - DT LT Armor", {
		["body"] = "egm/du/dt/body_lt",
		["body_mirrored"] = "egm/du/dt/body_lt",
		["kama"] = "egm/du/shared/heavy1", 
		["ammo_shoulder"] = "egm/du/shared/heavy1",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy1",
	})
	-- Heavy Trooper --
	-- HT Body PVT
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "HT_PVT", "Dooms Unit - HT PVT Armor", {
		["body"] = "egm/du/ht/body_pvt",
		["body_mirrored"] = "egm/du/ht/body_pvt",
		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy",
	})
	-- HT Body SGT 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "HT_SGT", "Dooms Unit - HT SGT Armor", {
		["body"] = "egm/du/ht/body_sgt",
		["body_mirrored"] = "egm/du/ht/body_sgt",
		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy2",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})	
	-- DT Helmet SGT
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "HT_SGT", "Dooms Unit - HT SGT Helmet", {
		["helmet"] = "egm/du/trooper/helmet_sgt",
	})
	-- HT Body LT 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "HT_LT", "Dooms Unit - HT LT Armor", {
		["body"] = "egm/du/ht/body_lt",
		["body_mirrored"] = "egm/du/ht/body_lt",
		["kama"] = "egm/du/shared/heavy1", 
		["ammo_shoulder"] = "egm/du/shared/heavy1",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy1",
	})	
	-- Dooms Unit RMC -- 
	-- DU RMC Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DU_RMC", "Dooms Unit - RMC Armor", {
		["body"] = "egm/du/rmc/body",
		["body_mirrored"] = "egm/du/rmc/body",
		["kama"] = "egm/du/rmc/heavy_rmc", 
		["ammo_shoulder"] = "egm/du/rmc/heavy_rmc",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy",
	})
	-- DU RMC Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "DU_RMC", "Dooms Unit - RMC Backpack", {
		["backpack"] = "egm/du/rmc/heavy_rmc",
	})
	-- Dooms Unit TEB -- 
	-- DU TEB Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "DU_TEB", "Dooms Unit - TEB Armor", {
		["body"] = "egm/du/teb/body",
		["body_mirrored"] = "egm/du/teb/body",
		["kama"] = "egm/du/teb/heavy_teb", 
		["ammo_shoulder"] = "egm/du/teb/heavy_teb",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy",
	})
	-- DU TEB Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "DU_TEB", "Dooms Unit - TEB Backpack", {
		["backpack"] = "egm/du/teb/heavy_teb",
	})
	-- Dooms Unit Pilot -- 
	    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "DU_PVT", "Dooms Unit - Pilot Helmet", {
        ["helmet_pilot"] = "egm/du/pilot/helmet_pilot",
	})
	-- DU Helmet 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_1", "Dooms Unit - Trooper Helmet 1", {
		["helmet"] = "egm/du/trooper/helmet_1",
	})
	-- DU Helmet 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_2", "Dooms Unit - Trooper Helmet 2", {
		["helmet"] = "egm/du/trooper/helmet_2",
	})
	-- DU Helmet 3
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_3", "Dooms Unit - Trooper Helmet 3", {
		["helmet"] = "egm/du/trooper/helmet_3",
	})
	-- DU Helmet 4
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_4", "Dooms Unit - Trooper Helmet 4", {
		["helmet"] = "egm/du/trooper/helmet_4",
	})
	-- DU Helmet 5
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_5", "Dooms Unit  - Trooper Helmet 5", {
		["helmet"] = "egm/du/trooper/helmet_5",
	})
	-- DU MJR Helmet 
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "DU_helmet_mjr", "Dooms Unit - Trooper Helmet MJR", {
		["helmet"] = "egm/du/trooper/helmet_mjr",
	})
		-- DU Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "DU", "Dooms Unit - Backpack", {
		["backpack"] = "egm/du/shared/backpack",
	})
end)

--lua/autorun/egm_forge.lua:
-- Register the Custom Char Forge Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.212thForge", function()
	-- Forge Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_forge", "Forge Body", {
		["body"] = "egm/custom_char/212th/forge/body",
		["body_mirrored"] = "egm/custom_char/212th/forge/body2",

		["kama"] = "egm/custom_char/212th/forge/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- Forge Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_forge", "Forge Helmet", {
		["helmet"] = "egm/custom_char/212th/forge/helmet",
		
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

		["camera"] = "egm/212th_new/lore/cody/camera",
	})
	--  Forge ARF Helmet 
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "212th_forge", "Forge ARF Helmet", {
		["helmet_arf"] = "egm/custom_char/212th/forge/helmet_arf",
        ["armor"] = "egm/custom_char/212th/forge/armor",
		["antenna_arf"] = "egm/212th_new/ghc/helmet_parts_camo",
	})

end)
--lua/autorun/egm_hypnotic.lua:
-- Register the Custom Char Hypnotic Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SwtHypnotic", function()
	-- Hypnotic Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic Armor", {
        ["body"] = "egm/custom_char/swt/hydra/body",
		["body_mirrored"] = "egm/custom_char/swt/hydra/body2",
		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",

        ["kama"] = "egm/custom_char/swt/hydra/heavy",
		["kama_arc"] = "egm/custom_char/swt/hydra/kama_arc",

        ["pauldron"] = "egm/custom_char/swt/hydra/specialist",
		["holsters"] = "egm/custom_char/swt/hydra/gear",
		["pockets"] = "egm/custom_char/swt/hydra/gear",
		
		["straps_double"] = "egm/custom_char/swt/hydra/heavy",
		["ammo_arm"] = "egm/swt/attachment/specialist",
    })
	-- Hypnotic Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic Helmet", {
		["helmet"] = "egm/custom_char/swt/hydra/helmet",
		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["binoculars"] = "egm/swt/attachment/specialist",
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
	})
	-- Airborne Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic Helmet Airborne", {
		["helmet_airborne"] = "egm/custom_char/swt/hydra/helmet_airborne",
		["sunvisor"] = "egm/swt/attachment/heavy",
		["binoculars"] = "egm/swt/attachment/specialist",
	})
	-- Backpacks
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic - Backpack", {
		["backpack"] = "egm/custom_char/swt/hydra/heavy",
	})
	-- Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic - Jumppack", {
		["bp_jumppack"] = "egm/custom_char/swt/hydra/specialist",
	})
	-- Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "shadowtrooper_hypnotic", "Swt Hypnotic - Jetpack", {
		["bp_jetpack"] = "egm/custom_char/swt/hydra/jetpack",
	})
end)
--lua/autorun/egm_kiv.lua:
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTKiv", function()
	-- CT Kiv Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ct_kiv", "CT Kiv - Armor", {
		["body"] = "egm/custom_char/ct/kiv/body/body",
		["body_mirrored"] = "egm/custom_char/ct/kiv/body/body_2",

		["kama"] = "egm/custom_char/ct/kiv/body/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})
	-- CT Kiv Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "ct_kiv", "CT Kiv - Helmet", {
		["helmet"] = "egm/custom_char/ct/kiv/body/helmet",
	})
end)
--lua/autorun/egm_rednex.lua:
-- Register the ST Custom Char Rednex Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.STGenex", function()
	-- Genex Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_genex", "ST Genex - Armor", {
        ["body"] = "egm/custom_char/st/rednex/body",
		["body_mirrored"] = "egm/custom_char/st/rednex/body",

		["kama"] = "egm/custom_char/st/rednex/heavy",
		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",

		["antenna_shoulder"] = "egm/custom_char/st/rednex/antenna_shoulder",
    })
	-- Helmet ARF
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "st_genex", "ST Genex - Helmet", {
		["helmet_arf"] = "egm/custom_char/st/rednex/helmet",
		["armor"] = "egm/shock_trooper_refresh/k9/armor",
		["antenna_arf"] = "egm/custom_char/st/rednex/antenna_arf",
	})
end)
--lua/autorun/egm_sauer.lua:
-- Register the Custom Char Sauer Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.swtSauer", function()
	-- Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_sauer", "SWT Sauer - Armor", {
        ["body"] = "egm/custom_char/swt/sauer/body",
		["body_mirrored"] = "egm/custom_char/swt/sauer/body",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",

		["kama"] = "egm/swt/attachment/heavy",
		["kama_arc"] = "egm/custom_char/swt/sauer/kama_arc",

		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
		["pauldron"] = "egm/custom_char/swt/sauer/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
    })

	-- Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_sauer", "SWT Sauer - Helmet", {
		["helmet"] = "egm/custom_char/swt/sauer/helmet",
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		["flashlight"] = "egm/custom_char/swt/sauer/flashlight",
		["sunvisor"] = "egm/swt/attachment/heavy",
		["binoculars"] = "egm/swt/attachment/specialist",
		["armor"] = "egm/swt/attachment/heavy",
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	
	-- Helmet Arf
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "swt_sauer", "SWT Sauer - Helmet Arf", {
		["helmet_arf"] = "egm/custom_char/swt/sauer/helmet_arf",
		["antenna_arf"] = "egm/custom_char/swt/sauer/armor",
		["flashlight"] = "egm/custom_char/swt/sauer/flashlight",
		["rangefinder"] = "egm/swt/attachment/rangefinder",
	})

	-- Backpacks und Sidebags
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "swt_sauer", "SWT Sauer - Backpack", {
		["bp_comms"] = "egm/custom_char/swt/sauer/bp_comms",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "swt_trooper", "SWT Trooper - Backpack", {
		["backpack"] = "egm/swt/attachment/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "swt_trooper", "SWT Trooper - Sidebag", {
		["sidebag"] = "egm/swt/attachment/heavy",
	})
end)
--lua/autorun/find_laggy_hooks.lua:
--- Ajouter le temps de rendu VGUI.



-- Note: GM functions that have been modified during a test will be restored with an older version.

addon_hooks_lag_finder = addon_hooks_lag_finder or {}

local concommand_name
if SERVER then
	concommand_name = "find_laggy_hooks_sv"
	util.AddNetworkString( "find_laggy_hooks" )
else
	concommand_name = "find_laggy_hooks_cl"
end

local SendToSuperAdmins -- parameter set below

---------- MESSAGE COLORS ----------
local ServerColor = Color( 255, 128, 192 )
local ResultColor
if SERVER then
	ResultColor = ServerColor
else
	ResultColor = Color( 255, 192, 0 )
end

---------- SEND MESSAGE ----------
local function NiceMsgN( ply, ... )
	if SERVER and IsValid( ply ) then
		ply:PrintMessage( HUD_PRINTCONSOLE, string.Implode( "", { ... } ) )
	else
		MsgN( ... )
	end
end

---------- FORMAT HOOK TIMINGS ----------
local IntroMessage = "\n\nHere are the %u laggiest hooks found during the last %u frames:\n"..
	( SERVER and game.IsDedicated() and " Identifier ------------------------------- Impact  Execs  Mean t /f  Max time \n" or--79
	" Identifier ------------------------------------------------------------ Impact  Executions  Mean t /f  Max time \n" )--113
local FormatTimings
do
	local function FillStringSlot( Input, Slot )
		Input = string.sub( Input, 1, Slot )
		Input = Input..( string.rep( " ", Slot-utf8.len( Input ) ) )
		return Input
	end
	local UnitFormats={ -- decimals+unit, multiplier
		-- Greek characters are not used because UTF-8 sub-strings are not supported.
		{"%01.3fus", 1000000},
		{"%01.2fus", 1000000},
		{"%01.1fus", 1000000},
		{"%01.0fus", 1000000},
		{"%01.2fms", 1000},
		{"%01.1fms", 1000},
		{"%01.0fms", 1000},
		{"%01.2fs", 1},
		{"%01.1fs", 1},
		{"%01.0fs", 1},
	}
	local function FillTimeSlot( Input, Slot )
		local NumString
		for i,UnitFormat in ipairs( UnitFormats ) do
			NumString=string.format( UnitFormat[1], Input*UnitFormat[2] )
			if utf8.len( NumString )<=Slot then
				break
			end
		end
		return FillStringSlot( NumString, Slot )
	end
	local function FillIntegerSlot( Input, Slot )
		local NumString = tostring( Input )
		if string.len( NumString )>Slot then
			for decimals=Slot-5,0,-1 do
				NumString = string.format( "%."..decimals.."e", Input )
				if string.len( NumString )<=Slot then
					break
				end
			end
		end
		return FillStringSlot( NumString, Slot )
	end
	local FormatBase = ' %s %s %s %s %s\n  in "%s" (lines %s to %s),\n  %s\n'
	local Slots -- string lengths for virtual table in console
	if CLIENT or !game.IsDedicated() then
		Slots = {
			identifier=71,
			Impact=7,
			count=11,
			meantime=10,
			maxtime=9,
		}
	else
		Slots = {
			identifier=42,
			Impact=7,
			count=6,
			meantime=10,
			maxtime=9,
		}
	end
	function FormatTimings( identifier, Impact, count, meantime, maxtime, LuaFile, linedefined, lastlinedefined, foundstr )
		return string.format( FormatBase,
			FillStringSlot( identifier, Slots.identifier ),
			FillStringSlot( string.format( Impact<10 and "%05.2f%%" or "%1.0f%%", Impact*100 ), Slots.Impact ),
			FillIntegerSlot( count, Slots.count ),
			FillTimeSlot( meantime, Slots.meantime ),
			FillTimeSlot( maxtime, Slots.maxtime ),
			-- FillStringSlot( string.format( "%.2e", meantime ), Slots.meantime ), -- debug
			-- FillStringSlot( string.format( "%.2e", maxtime ), Slots.maxtime ), -- debug
			LuaFile,
			tostring( linedefined ),
			tostring( lastlinedefined ),
			foundstr
		)
	end
end

---------- NETWORK ----------
if CLIENT then
	local function net_ReceiveRemoteTimings()
		local TopCount = net.ReadUInt( 32 )
		local NumFrames = net.ReadUInt( 32 )
		MsgC( ServerColor, string.format( IntroMessage, TopCount, NumFrames ) )
		for k=1,TopCount do
			local identifier = net.ReadString()
			local Impact = net.ReadFloat()
			local count = net.ReadUInt( 32 )
			local meantime = net.ReadFloat()
			local maxtime = net.ReadFloat()
			local LuaFile = net.ReadString()
			local linedefined = net.ReadUInt( 32 )
			local lastlinedefined = net.ReadUInt( 32 )
			local foundstr = net.ReadString()
			MsgC( ServerColor, FormatTimings( identifier, Impact, count, meantime, maxtime, LuaFile, linedefined, lastlinedefined, foundstr ) )
		end
	end
	net.Receive( "find_laggy_hooks", function()
		local Type = net.ReadUInt( 8 )
		if Type == 0 then
			net_ReceiveRemoteTimings()
		end
	end )
end

---------- STORE HOOK EXECUTION TIME ----------
addon_hooks_lag_finder.ReportedTimings = addon_hooks_lag_finder.ReportedTimings or {}
function addon_hooks_lag_finder.ReportHookTiming( identifier, HookFunction, start, finish )
	local Report = addon_hooks_lag_finder.ReportedTimings[identifier]
	if !Report then
		Report = {
			identifier = identifier,
			HookFunction = HookFunction,
			count = 0,
			time = 0.,
			maxtime = 0.,
		}
		addon_hooks_lag_finder.ReportedTimings[identifier] = Report
	end
	local RunTime = finish-start
	Report.count = Report.count+1
	Report.time = Report.time+RunTime
	Report.maxtime = math.max( RunTime, Report.maxtime )
end

---------- REPORT STATISTICS ----------
local find_laggy_hooks -- function defined below
local ReportStatistics
do
	local function SortReportedTimings( a, b )
		return a.Impact > b.Impact
	end
	function ReportStatistics()
		local NumFrames = addon_hooks_lag_finder.NumFrames
		local NumFrames1 = NumFrames-1
		local PeriodEnd = SysTime() -- true value
		local PeriodDuration = PeriodEnd-addon_hooks_lag_finder.PeriodStart
		-- Copy the ReportedTimings, with integer keys:
		local ReportedTimings = {}
		for _,Report in pairs( addon_hooks_lag_finder.ReportedTimings ) do
			-- Good method but the maxtime often gets crazy values:
			-- Report.Impact = (
				-- ( Report.maxtime*math.max( NumFrames, Report.count ) ) -- pessimistic: consider as always max time
				-- +Report.time -- optimistic: consider as always mean time
			-- )/( 2*PeriodDuration )
			-- Average method:
			if Report.count>=NumFrames1 then -- considering only mean execution time
				Report.Impact = Report.time/PeriodDuration
			else -- same, multiplied by NumFrames/Report.count
				Report.Impact = ( Report.time*NumFrames )/( PeriodDuration*Report.count )
			end
			table.insert( ReportedTimings, Report )
		end
		-- Sort the copied ReportedTimings:
		table.sort( ReportedTimings, SortReportedTimings )
		local TopCount=0 -- number of displayed values
		if addon_hooks_lag_finder.TopCountOrRatioThreshold < 1 then -- use RatioThreshold
			local RatioThreshold = addon_hooks_lag_finder.TopCountOrRatioThreshold
			-- Only keep impacts higher than the RatioThreshold:
			for k=#ReportedTimings,1,-1 do
				if ReportedTimings[k].Impact>=RatioThreshold then
					TopCount=k
					break
				end
			end
		else -- use TopCount
			TopCount=math.min( #ReportedTimings, addon_hooks_lag_finder.TopCountOrRatioThreshold )
		end
		-- Clear the ReportedTimings for next capture period:
		addon_hooks_lag_finder.ReportedTimings = {}
		addon_hooks_lag_finder.RunningFunctions = {} -- safety precaution
		addon_hooks_lag_finder.PeriodStart = PeriodEnd
		addon_hooks_lag_finder.PeriodEnd = PeriodEnd+addon_hooks_lag_finder.ReportInterval
		addon_hooks_lag_finder.NumFrames = 0
		-- Process info:
		for k=1,TopCount do
			local Report = ReportedTimings[k]
			Report.meantime = Report.time/NumFrames
			local info = debug.getinfo( Report.HookFunction, 'S' )
			Report.info = info
			local LuaFile = tostring( info.short_src )
			Report.LuaFile = LuaFile
			local foundstr
			if addon_hooks_conflict_finder and addon_hooks_conflict_finder.LocateLuaFile then
				local locations = addon_hooks_conflict_finder.LocateLuaFile( LuaFile )
				if !locations then
					foundstr = "not found in Workshop addons"
				elseif #locations == 1 then
					foundstr = "found in Workshop addon « "..locations[1].." »"
				else
					foundstr = "found in Workshop addons « "..string.Implode( " », « ", locations ).." »"
				end
			else
				foundstr = "Addon hooks Conflict Finder not available"
			end
			Report.foundstr = foundstr
		end
		if CLIENT or !SendToSuperAdmins then
			MsgC( ResultColor, string.format( IntroMessage, TopCount, NumFrames ) )
			for k=1,TopCount do
				local Report = ReportedTimings[k]
				local info = Report.info
				MsgC( ResultColor, FormatTimings( Report.identifier, Report.Impact, Report.count, Report.meantime, Report.maxtime, Report.LuaFile, info.linedefined, info.lastlinedefined, Report.foundstr ) )
			end
		else
			local superadmins = {}
			for _,ply in pairs( player.GetAll() ) do
				if ply:IsSuperAdmin() then
					superadmins[#superadmins+1] = ply
				end
			end
			if #superadmins > 0 then
				net.Start( "find_laggy_hooks" )
					net.WriteUInt( 0, 8 )
					net.WriteUInt( TopCount, 32 )
					net.WriteUInt( NumFrames, 32 )
					for k=1,TopCount do
						local Report = ReportedTimings[k]
						local info = Report.info
						net.WriteString( Report.identifier )
						net.WriteFloat( Report.Impact )
						net.WriteUInt( Report.count, 32 )
						net.WriteFloat( Report.meantime )
						net.WriteFloat( Report.maxtime )
						net.WriteString( Report.LuaFile )
						net.WriteUInt( info.linedefined or 0, 32 )
						net.WriteUInt( info.lastlinedefined or 0, 32 )
						net.WriteString( Report.foundstr )
					end
				net.Send( superadmins )
			else
				find_laggy_hooks( nil, concommand_name, { 0 }, concommand_name..' "0"' ) -- Stop sending to superadmins if none connected.
			end
		end
		-- Set the period start & end again (accurate time ignoring find_laggy_hooks' process):
		addon_hooks_lag_finder.PeriodStart = SysTime()
		addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+addon_hooks_lag_finder.ReportInterval -- expected value
	end
end
hook.Add( "Think", "find_laggy_hooks", function()
	if addon_hooks_lag_finder.RunningTest then
		addon_hooks_lag_finder.NumFrames = addon_hooks_lag_finder.NumFrames+1
		if SysTime()>=addon_hooks_lag_finder.PeriodEnd then
			ReportStatistics()
		end
	end
end )

---------- START TESTS ----------
local helpstr = concommand_name.." [ReportInterval=30 or 0] [TopCount=16 or RatioThreshold]\n   Displays laggy hooks on every ReportInterval seconds.\n   The optional second argument can be a top TopCount of laggiest hooks or a threshold ratio of (execution_time/frame_time).\n   To stop the test, type 0 as the first argument.\n"
local CancelTests
if addon_hooks_lag_finder.CancelTests then
	CancelTests = addon_hooks_lag_finder.CancelTests
else
	CancelTests = {
		-- hook={},-- contains event names, hook names, functions
		-- net={},-- contains message ids, functions
		-- usermessage={},-- contains message ids, functions
		-- ENT={},-- contains classes, event names, functions
		-- SWEP={},-- contains classes, event names, functions
		-- GM={},-- contains gamemodes, event names, functions
	}
	addon_hooks_lag_finder.CancelTests = CancelTests
end
local function GetModifiedHookFunction( identifier, HookFunction, ReportedFunction )
	-- Do not make re-used local variables: danger in case of recursive calls.
	local function new_HookFunction( ... )
		if !addon_hooks_lag_finder.RunningFunctions[HookFunction] then
			addon_hooks_lag_finder.RunningFunctions[HookFunction]=true
			local start,ret,finish
			start=SysTime()
			ret={ pcall( HookFunction, ... ) } -- protected to prevent malfunction
			finish=SysTime()
			addon_hooks_lag_finder.RunningFunctions[HookFunction]=false
			addon_hooks_lag_finder.ReportHookTiming( identifier, ReportedFunction or HookFunction, start, finish )
			if ret[1] then -- ok
				table.remove( ret, 1 ) -- remove the returned status
			else -- error
				error( ret[2] ) -- throw the returned error when safe
			end
			return unpack( ret )
		else -- ignore recursive calls
			return HookFunction( ... )
		end
	end
	return new_HookFunction
end
function addon_hooks_lag_finder.AddModifiedHook( EventName, HookName, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		if HookName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Event "'..tostring( EventName )..'", hook "'..tostring( HookName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.hook[EventName] = addon_hooks_lag_finder.CancelTests.hook[EventName] or {}
			addon_hooks_lag_finder.CancelTests.hook[EventName][HookName] = HookFunction
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	-- hook.Remove( EventName, HookName ) -- useless
	return addon_hooks_lag_finder.hook_Add( EventName, HookName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedNet( EventName, HookFunction, ... )
	local new_HookFunction
	local lower_EventName = tostring( EventName ):lower()
	if isfunction( HookFunction ) then
		if EventName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Net receiver "'..tostring( EventName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.net[lower_EventName] = HookFunction
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.net_Receive( lower_EventName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedUsermessage( EventName, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		if EventName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Usermessage receiver "'..tostring( EventName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.usermessage[EventName] = {
				Function = HookFunction,
				PreArgs = {...},
			}
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.usermessage_Hook( EventName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AdjustModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer "'..tostring( EventName )..'"',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Adjust( EventName, delay, repetitions, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer "'..tostring( EventName )..'"',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Create( EventName, delay, repetitions, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AdjustModifiedTimerSimple( delay, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer timer.Simple( '..tostring( delay )..', '..tostring( HookFunction )..' )',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Simple( delay, new_HookFunction, ... )
end
-- Modify timer.Adjust():
if !addon_hooks_lag_finder.timer_Adjust then
	addon_hooks_lag_finder.timer_Adjust = timer.Adjust
	timer.Adjust = function( EventName, delay, repetitions, HookFunction, ... )
		return addon_hooks_lag_finder.AdjustModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	end
end
-- Modify timer.Create():
if !addon_hooks_lag_finder.timer_Create then
	addon_hooks_lag_finder.timer_Create = timer.Create
	timer.Create = function( EventName, delay, repetitions, HookFunction, ... )
		return addon_hooks_lag_finder.AddModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	end
end
-- Modify timer.Simple():
if !addon_hooks_lag_finder.timer_Simple then
	addon_hooks_lag_finder.timer_Simple = timer.Simple
	timer.Simple = function( delay, HookFunction, ... )
		return addon_hooks_lag_finder.AdjustModifiedTimerSimple( delay, HookFunction, ... )
	end
end
-- Run or stop the test:
function find_laggy_hooks( ply, cmd, args, fullstring )
	if CLIENT or !IsValid( ply ) or ply:IsSuperAdmin() then
		local ReportInterval = tonumber( args[1] ) or 30
		if !ReportInterval then
			NiceMsgN( ply, " - "..helpstr )
			return
		end
		if addon_hooks_conflict_finder and addon_hooks_conflict_finder.FillAddonsList then
			if !addon_hooks_conflict_finder.AddonsList then
				addon_hooks_conflict_finder.FillAddonsList()
			end
		end
		local IsRunning = addon_hooks_lag_finder.RunningTest
		local HookTable = hook.GetTable() -- This may be a copy!
		local NetTable = net.Receivers
		local UsermessageTable = usermessage and usermessage.GetTable() or {}
		local ENTTable = scripted_ents.GetList()
		local SWEPTable = weapons.GetList()
		if ReportInterval>0 then -- begin operation
			if !IsRunning then
				if IsValid( ply ) then
					SendToSuperAdmins = true
				else
					SendToSuperAdmins = false
				end
				-- Modify hook.Add():
				if !addon_hooks_lag_finder.hook_Add then
					addon_hooks_lag_finder.hook_Add = hook.Add
					hook.Add = function( EventName, HookName, HookFunction, ... )
						if addon_hooks_lag_finder.RunningTest and HookName!="find_laggy_hooks" then
							return addon_hooks_lag_finder.AddModifiedHook( EventName, HookName, HookFunction, ... )
						else
							return addon_hooks_lag_finder.hook_Add( EventName, HookName, HookFunction, ... )
						end
					end
				end
				-- Modify net.Receive():
				if !addon_hooks_lag_finder.net_Receive then
					addon_hooks_lag_finder.net_Receive = net.Receive
					net.Receive = function( EventName, HookFunction, ... )
						if addon_hooks_lag_finder.RunningTest and EventName!="find_laggy_hooks" then
							return addon_hooks_lag_finder.AddModifiedNet( EventName, HookFunction, ... )
						else
							return addon_hooks_lag_finder.net_Receive( EventName, HookFunction, ... )
						end
					end
				end
				-- Modify usermessage.Hook():
				if !addon_hooks_lag_finder.usermessage_Hook then
					if usermessage then
						addon_hooks_lag_finder.usermessage_Hook = usermessage.Hook
						usermessage.Hook = function( EventName, HookFunction, ... )
							if addon_hooks_lag_finder.RunningTest and EventName!="find_laggy_hooks" then
								return addon_hooks_lag_finder.AddModifiedUsermessage( EventName, HookFunction, ... )
							else
								return addon_hooks_lag_finder.usermessage_Hook( EventName, HookFunction, ... )
							end
						end
					end
				end
				-- Mark test as running:
				addon_hooks_lag_finder.ReportedTimings = {}
				addon_hooks_lag_finder.RunningFunctions = {}
				addon_hooks_lag_finder.PeriodStart = SysTime()
				addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+ReportInterval
				addon_hooks_lag_finder.NumFrames = 0
				addon_hooks_lag_finder.TopCountOrRatioThreshold = tonumber( args[2] ) or 16
				addon_hooks_lag_finder.ReportInterval = ReportInterval
				addon_hooks_lag_finder.RunningTest = true
				-- Add hooks:
				CancelTests.hook={}
				do
					local TempHookTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,EventFunctions in pairs( HookTable ) do
						TempHookTable[EventName]={}
						for HookName,HookFunction in pairs( EventFunctions ) do
							TempHookTable[EventName][HookName]=HookFunction
						end
					end
					for EventName,EventFunctions in pairs( TempHookTable ) do
						for HookName,HookFunction in pairs( EventFunctions ) do
							pcall( addon_hooks_lag_finder.AddModifiedHook, EventName, HookName, HookFunction )
						end
					end
				end
				-- Add net receivers:
				CancelTests.net={}
				do
					local TempNetTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,HookFunction in pairs( NetTable ) do
						TempNetTable[EventName]=HookFunction
					end
					for EventName,HookFunction in pairs( TempNetTable ) do
						pcall( addon_hooks_lag_finder.AddModifiedNet, EventName, HookFunction )
					end
				end
				-- Add usermessage receivers:
				CancelTests.usermessage={}
				do
					local TempUsermessageTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,HookData in pairs( UsermessageTable ) do
						TempUsermessageTable[EventName]=HookData
					end
					for EventName,HookData in pairs( TempUsermessageTable ) do
						pcall( addon_hooks_lag_finder.AddModifiedUsermessage, EventName, HookData.Function, unpack( HookData.PreArgs ) )
					end
				end
				-- Add ENT functions:
				CancelTests.ENT={}
				do
					local TempENTTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for class,ClassTable in pairs( ENTTable ) do
						TempENTTable[class]={}
						for EventName,HookFunction in pairs( ClassTable.t ) do
							if isfunction( HookFunction ) then
								TempENTTable[class][EventName]=HookFunction
							end
						end
					end
					for class,ClassFunctions in pairs( TempENTTable ) do
						CancelTests.ENT[class] = {}
						local ENT = scripted_ents.GetStored( class ).t
						for EventName,HookFunction in pairs( ClassFunctions ) do
							local new_HookFunction = GetModifiedHookFunction(
								'Entity "'..tostring( class )..'", function ENT.'..tostring( EventName ),
								HookFunction
							)
							CancelTests.ENT[class][EventName] = HookFunction
							ENT[EventName] = new_HookFunction
						end
						pcall( scripted_ents.Register, ENT, class ) -- should not be required
					end
				end
				-- Add SWEP functions:
				CancelTests.SWEP={}
				do
					local TempSWEPTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for _,SWEP in pairs( SWEPTable ) do
						local class = SWEP.ClassName
						if class then
							TempSWEPTable[class]={}
							for EventName,HookFunction in pairs( SWEP ) do
								if isfunction( HookFunction ) then
									TempSWEPTable[class][EventName]=HookFunction
								end
							end
						end
					end
					for class,ClassFunctions in pairs( TempSWEPTable ) do
						CancelTests.SWEP[class] = {}
						local SWEP = weapons.GetStored( class )
						for EventName,HookFunction in pairs( ClassFunctions ) do
							local new_HookFunction = GetModifiedHookFunction(
								'Weapon "'..tostring( class )..'", function SWEP.'..tostring( EventName ),
								HookFunction
							)
							CancelTests.SWEP[class][EventName] = HookFunction
							SWEP[EventName] = new_HookFunction
						end
						pcall( weapons.Register, SWEP, class ) -- should not be required
					end
				end
				-- Add GM functions:
				CancelTests.GM={}
				do
					local Validated={} -- Prevent endless loops.
					local TempGamemodeTable = {} -- Copy: ensure that pairs() is safe while modifying table and prevent risk of multiply modified functions.
					local GM = GAMEMODE
					while GM and !Validated[GM] do
						TempGamemodeTable[GM]={}
						for EventName,HookFunction in pairs( GM ) do
							if isfunction( HookFunction ) then
								TempGamemodeTable[GM][EventName]=HookFunction
							end
						end
						Validated[GM]=true
						GM = GM.BaseClass
					end
					for GM,GM_functions in pairs( TempGamemodeTable ) do
						CancelTests.GM[GM] = {}
						for EventName,HookFunction in pairs( GM_functions ) do
							local new_HookFunction
							if CLIENT and EventName=="RenderScene" then
								addon_hooks_lag_finder.view = {
									dopostprocess = true,
									drawhud = true,
									drawmonitors = true,
									drawviewmodel = true,
									bloomtone = true,
								}
								local function RenderScene( ... )
									local result = HookFunction( ... )
									if result then
										return result
									else
										render.RenderView( addon_hooks_lag_finder.view )
										return true
									end
								end
								new_HookFunction = GetModifiedHookFunction(
									'Default scene rendering / GM.RenderScene',
									RenderScene,
									HookFunction
								)
							else
								new_HookFunction = GetModifiedHookFunction(
									'Function GM.'..tostring( EventName ),
									HookFunction
								)
							end
							CancelTests.GM[GM][EventName] = HookFunction -- to be restored first
							GM[EventName] = new_HookFunction
						end
					end
				end
				-- Re-adjust to accurate time reference:
				addon_hooks_lag_finder.PeriodStart = SysTime()
				addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+ReportInterval
				NiceMsgN( ply, 'Lag test started, next output in '..ReportInterval..' seconds!' )
			else
				NiceMsgN( ply, 'Lag test is already running!' )
			end
		else -- finish operation
			-- We only browse cancel tables because they are copies!
			if IsRunning then
				-- Restore GM functions:
				if CancelTests.GM then
					local Validated={} -- Prevent endless loops.
					local GM = GAMEMODE
					while GM and !Validated[GM] do
						if CancelTests.GM[GM] then
							for EventName,HookFunction in pairs( CancelTests.GM[GM] ) do
								if isfunction( GM[EventName] ) then
									GM[EventName]=HookFunction
								end
							end
						end
						CancelTests.GM[GM]=nil
						Validated[GM]=true
						GM = GM.BaseClass
					end
					CancelTests.GM=nil
				end
				-- Restore ENT functions:
				if CancelTests.ENT then
					for class,ClassFunctions in pairs( CancelTests.ENT ) do
						local ENT = scripted_ents.GetStored( class ).t
						if ENT then
							for EventName,HookFunction in pairs( ClassFunctions ) do
								if isfunction( ENT[EventName] ) then
									ENT[EventName]=HookFunction
								end
							end
							pcall( scripted_ents.Register, ENT, class ) -- should not be required
						end
					end
					CancelTests.ENT=nil
				end
				-- Restore SWEP functions:
				if CancelTests.SWEP then
					for class,ClassFunctions in pairs( CancelTests.SWEP ) do
						local SWEP = weapons.GetStored( class )
						if SWEP then
							for EventName,HookFunction in pairs( ClassFunctions ) do
								if isfunction( SWEP[EventName] ) then
									SWEP[EventName]=HookFunction
								end
							end
							pcall( scripted_ents.Register, SWEP, class ) -- should not be required
						end
					end
					CancelTests.SWEP=nil
				end
				-- Restore usermessage receivers:
				if CancelTests.usermessage then
					for EventName,HookData in pairs( CancelTests.usermessage ) do
						if istable( UsermessageTable[EventName] ) then
							addon_hooks_lag_finder.usermessage_Hook( EventName, HookData.Function, unpack( HookData.PreArgs ) )
						end
					end
					CancelTests.usermessage=nil
				end
				-- Restore net receivers:
				if CancelTests.net then
					for EventName,HookFunction in pairs( CancelTests.net ) do
						if isfunction( NetTable[EventName] ) then
							addon_hooks_lag_finder.net_Receive( EventName, HookFunction )
						end
					end
					CancelTests.net=nil
				end
				-- Restore hooks:
				if CancelTests.hook then
					for EventName,EventFunctions in pairs( CancelTests.hook ) do
						if istable( HookTable[EventName] ) then
							for HookName,HookFunction in pairs( EventFunctions ) do
								if isfunction( HookTable[EventName][HookName] ) then
									addon_hooks_lag_finder.hook_Add( EventName, HookName, HookFunction )
								end
							end
						end
					end
					CancelTests.hook=nil
				end
				-- Mark test as stopped:
				addon_hooks_lag_finder.RunningTest = false
				-- Report pending statistics:
				ReportStatistics()
				addon_hooks_lag_finder.ReportedTimings = {}
				addon_hooks_lag_finder.RunningFunctions = {}
				-- Confirm:
				NiceMsgN( ply, 'Lag test is now stopped!' )
			else
				NiceMsgN( ply, 'Lag test is not running!' )
			end
		end
	end
end
concommand.Add( concommand_name, find_laggy_hooks, nil, helpstr, 0 )

--addons/fprofiler/lua/autorun/fprofiler.lua:
FProfiler = {}
FProfiler.Internal = {}
FProfiler.UI = {}

AddCSLuaFile()
AddCSLuaFile("fprofiler/cami.lua")
AddCSLuaFile("fprofiler/gather.lua")
AddCSLuaFile("fprofiler/report.lua")
AddCSLuaFile("fprofiler/util.lua")
AddCSLuaFile("fprofiler/prettyprint.lua")

AddCSLuaFile("fprofiler/ui/model.lua")
AddCSLuaFile("fprofiler/ui/frame.lua")
AddCSLuaFile("fprofiler/ui/clientcontrol.lua")
AddCSLuaFile("fprofiler/ui/servercontrol.lua")

include("fprofiler/cami.lua")

CAMI.RegisterPrivilege{
	Name = "FProfiler",
	MinAccess = "superadmin"
}


include("fprofiler/prettyprint.lua")
include("fprofiler/util.lua")
include("fprofiler/gather.lua")
include("fprofiler/report.lua")


if CLIENT then
	include("fprofiler/ui/model.lua")
	include("fprofiler/ui/frame.lua")
	include("fprofiler/ui/clientcontrol.lua")
	include("fprofiler/ui/servercontrol.lua")
else
	include("fprofiler/ui/server.lua")
end

--addons/fprofiler/lua/fprofiler/prettyprint.lua:
-- Based on MDave's thing
-- https://gist.github.com/mentlerd/d56ad9e6361f4b86af84
if SERVER then AddCSLuaFile() end

local type_weight = {
	[TYPE_FUNCTION] = 1,
	[TYPE_TABLE]    = 2,
}

local type_colors = {
	[TYPE_BOOL]     = Color(175, 130, 255),
	[TYPE_NUMBER]   = Color(175, 130, 255),
	[TYPE_STRING]   = Color(230, 220, 115),
	[TYPE_FUNCTION] = Color(100, 220, 240)
}

local color_neutral   = Color(220, 220, 220)
local color_name      = Color(260, 150,  30)

local color_reference = Color(150, 230,  50)
local color_comment   = Color( 30, 210,  30)

-- 'nil' value
local NIL = {}

-- Localise for faster access
local pcall         = pcall

local string_len    = string.len
local string_sub    = string.sub
local string_find   = string.find

local table_concat  = table.concat
local table_insert  = table.insert
local table_sort    = table.sort


-- Stream interface
local gMsgF -- Print fragment
local gMsgN -- Print newline
local gMsgC -- Set print color

local PrintLocals, gBegin, gFinish, PrintTableGrep

do
	local grep_color   = Color(235, 70, 70)

	-- Grep parameters (static between gBegin/gEnd)
	local grep
	local grep_raw

	local grep_proximity


	-- Current line parameters
	local buffer
	local colors
	local markers

	local baseColor
	local currColor

	local length

	-- History
	local history
	local remain


	-- Actual printing
	local function gCheckMatch( buffer )
		local raw = table_concat(buffer)

		return raw, string_find(raw, grep, 0, grep_raw)
	end

	local function gFlushEx( raw, markers, colors, baseColor )

		-- Print entire buffer
		local len = string_len(raw)

		-- Keep track of the current line properties
		local index  = 1
		local marker = 1

		local currColor = baseColor

		-- Method to print to a preset area
		local function printToIndex( limit, color )
			local mark = markers and markers[marker]

			-- Print all marker areas until we would overshoot
			while mark and mark < limit do

				-- Catch up to the marker
				MsgC(color or currColor or color_neutral, string_sub(raw, index, mark))
				index = mark +1

				-- Set new color
				currColor = colors[marker]

				-- Select next marker
				marker = marker +1
				mark   = markers[marker]

			end

			-- Print the remaining between the last marker and the limit
			MsgC(color or currColor or color_neutral, string_sub(raw, index, limit))
			index = limit +1
		end

		-- Grep!
		local match, last = 1
		local from, to = string_find(raw, grep, 0, grep_raw)

		while from do
			printToIndex(from -1)
			printToIndex(to, grep_color)

			last     = to +1
			from, to = string_find(raw, grep, last, grep_raw)
		end

		printToIndex(len)
		MsgN()
	end


	local function gCommit()
		if grep_proximity then
			-- Check if the line has at least one match
			local raw, match = gCheckMatch(buffer)

			if match then

				-- Divide matches
				if history[grep_proximity] then
					MsgN("...")
				end

				-- Flush history
				if grep_proximity != 0 then
					local len = #history

					for index = len -1, 1, -1 do
						local entry = history[index]
							history[index] = nil

						gFlushEx( entry[1], entry[2], entry[3], entry[4] )
					end

					history[len] = nil
				end

				-- Flush line, allow next X lines to get printed
				gFlushEx( raw, markers, colors, baseColor )
				remain = grep_proximity -1

				history[grep_proximity +1] = nil
			elseif remain > 0 then
				-- Flush immediately
				gFlushEx( raw, markers, colors, baseColor )
				remain = remain -1
			else
				-- Store in history
				table_insert(history, 1, {raw, markers, colors, baseColor})
				history[grep_proximity +1] = nil
			end
		else
			-- Flush anyway
			gFlushEx( table_concat(buffer), markers, colors, baseColor )
		end

		-- Reset state
		length = 0
		buffer = {}

		markers = nil
		colors  = nil

		baseColor = nil
		currColor = nil
	end

	-- State machine
	function gBegin( new, prox )
		grep = isstring(new) and new

		if grep then
			grep_raw       = !pcall(string_find, ' ', grep)
			grep_proximity = isnumber(prox) and prox

			-- Reset everything
			buffer  = {}
			history = {}
		end

		length = 0
		remain = 0

		baseColor = nil
		currColor = nil
	end

	function gFinish()
		if grep_proximity and history and history[1] then
			MsgN("...")
		end

		-- Free memory
		buffer  = nil
		markers = nil
		colors  = nil

		history = nil
	end


	function gMsgC( color )
		if grep then

			-- Try to save some memory by not immediately allocating colors
			if length == 0 then
				baseColor = color
				return
			end

			-- Record color change
			if color != currColor then
				if !markers then
					markers = {}
					colors  = {}
				end

				-- Record color change
				table_insert(markers, length)
				table_insert(colors,  color)
			end
		end

		currColor = color
	end

	function gMsgF( str )
		if grep then

			-- Split multiline fragments to separate ones
			local fragColor = currColor or baseColor

			local last = 1
			local from, to = string_find(str, '\n')

			while from do
				local frag = string_sub(str, last, from -1)
				local len  = from - last

				-- Merge fragment to the line
				length = length + len
				table_insert(buffer, frag)

				-- Print finished line
				gCommit()

				-- Assign base color as previous fragColor
				baseColor = fragColor

				-- Look for more
				last     = to +1
				from, to = string_find(str, '\n', last)
			end

			-- Push last fragment
			local frag = string_sub(str, last)
			local len  = string_len(str) - last +1

			length = length + len
			table_insert(buffer, frag)
		else
			-- Push immediately
			MsgC(currColor or baseColor or color_neutral, str)
		end
	end

	function gMsgN()
		-- Print everything in the buffer
		if grep then
			gCommit()
		else
			MsgN()
		end

		baseColor = nil
		currColor = nil
	end
end


local function InternalPrintValue( value )

	-- 'nil' values can also be printed
	if value == NIL then
		gMsgC(color_comment)
		gMsgF("nil")
		return
	end

	local color = type_colors[ TypeID(value) ]

	-- For strings, place quotes
	if isstring(value) then
		if string_len(value) <= 1 then
			value = string.format([['%s']], value)
		else
			value = string.format([["%s"]], value)
		end

		gMsgC(color)
		gMsgF(value)
		return
	end

	-- Workaround for userdata not using MetaName
	if string_sub(tostring(value), 0, 8) == "userdata" then
		local meta = getmetatable(value)

		if meta and meta.MetaName then
			value = string.format("%s: %p", meta.MetaName, value)
		end
	end

	-- General print
	gMsgC(color)
	gMsgF(tostring(value))

	-- For functions append source info
	if isfunction(value) then
		local info = debug.getinfo(value, 'S')
		local aux

		if info.what == 'C' then
			aux = "\t-- [C]: -1"
		else
			if info.linedefined != info.lastlinedefined then
				aux = string.format("\t-- [%s]: %i-%i", info.short_src, info.linedefined, info.lastlinedefined)
			else
				aux = string.format("\t-- [%s]: %i", info.short_src, info.linedefined)
			end
		end

		gMsgC(color_comment)
		gMsgF(aux)
	end
end


-- Associated to object keys
local objID

local function isprimitive( value )
	local id = TypeID(value)

	return id <= TYPE_FUNCTION and id != TYPE_TABLE
end

local function InternalPrintTable( table, path, prefix, names, todo )

	-- Collect keys and some info about them
	local keyList  = {}
	local keyStr   = {}

	local keyCount = 0

	for key, value in pairs( table ) do
		-- Add to key list for later sorting
		table_insert(keyList, key)

		-- Describe key as string
		if isprimitive(key) then
			keyStr[key] = tostring(key)
		else
			-- Lookup already known name
			local name = names[key]

			-- Assign a new unique identifier
			if !name then
				objID = objID +1
				name  = string.format("%s: obj #%i", tostring(key), objID)

				names[key] = name
				todo[key]  = true
			end

			-- Substitute object with name
			keyStr[key] = name
		end

		keyCount = keyCount +1
	end


	-- Exit early for empty tables
	if keyCount == 0 then
		return
	end


	-- Determine max key length
	local keyLen = 4

	for key, str in pairs(keyStr) do
		keyLen = math.max(keyLen, string.len(str))
	end

	-- Sort table keys
	if keyCount > 1 then
		table_sort( keyList, function( A, B )

			-- Sort numbers numerically correct
			if isnumber(A) and isnumber(B) then
				return A < B
			end

			-- Weight types
			local wA = type_weight[ TypeID( table[A] ) ] or 0
			local wB = type_weight[ TypeID( table[B] ) ] or 0

			if wA != wB then
				return wA < wB
			end

			-- Order by string representation
			return keyStr[A] < keyStr[B]

		end )
	end

	-- Determine the next level ident
	local new_prefix = string.format( "%s║%s", prefix, string.rep(' ', keyLen) )

	-- Mark object as done
	todo[table] = nil

	-- Start describing table
	for index, key in ipairs(keyList) do
		local value = table[key]

		-- Assign names to already described keys/values
		local kName = names[key]
		local vName = names[value]

		-- Decide to either fully describe, or print the value
		local describe = !isprimitive(value) and ( !vName or todo[value] )

		-- Ident
		gMsgF(prefix)

		-- Fancy table guides
		local moreLines = (index != keyCount) or describe

		if index == 1 then
			gMsgF(moreLines and '╦ ' or '═ ')
		else
			gMsgF(moreLines and '╠ ' or '╚ ')
		end

		-- Print key
		local sKey = kName or keyStr[key]

		gMsgC(kName and color_reference or color_name)
		gMsgF(sKey)

		-- Describe non primitives
		describe = istable(value) and ( !names[value] or todo[value] ) and value != NIL

		-- Print key postfix
		local padding = keyLen - string.len(sKey)
		local postfix = string.format(describe and ":%s" or "%s = ", string.rep(' ', padding))

		gMsgC(color_neutral)
		gMsgF(postfix)

		-- Print the value
		if describe then
			gMsgN()

			-- Expand access path
			local new_path = sKey

			if isnumber(key) or kName then
				new_path = string.format("%s[%s]", path or '', key)
			elseif path then
				new_path = string.format("%s.%s", path, new_path)
			end

			-- Name the object to mark it done
			names[value] = names[value] or new_path

			-- Describe
			InternalPrintTable(value, new_path, new_prefix, names, todo)
		else
			-- Print the value (or the reference name)
			if vName and !todo[value] then
				gMsgC(color_reference)
				gMsgF(string.format("ref: %s",vName))
			else
				InternalPrintValue(value)
			end

			gMsgN()
		end
	end

end

function PrintTableGrep( table, grep, proximity )
	local base = {
		[_G]    = "_G",
		[table] = "root"
	}

	gBegin(grep, proximity)
		objID = 0
		InternalPrintTable(table, nil, "", base, {})
	gFinish()
end

function PrintLocals( level )
	local level = level or 2
	local hash  = {}

	for index = 1, 255 do
		local name, value = debug.getlocal(2, index)

		if !name then
			break
		end

		if value == nil then
			value = NIL
		end

		hash[name] = value
	end

	PrintTableGrep( hash )
end

function show(...)
	local n = select('#', ...)
	local tbl = {...}

	for i = 1, n do
		if istable(tbl[i]) then MsgN(tostring(tbl[i])) PrintTableGrep(tbl[i])
		else InternalPrintValue(tbl[i]) MsgN() end
	end
end

-- Hacky way of creating a pretty string from the above code
-- because I don't feel like refactoring the entire thing
local strResult
local toStringMsgF = function(txt)
	table.insert(strResult, txt)
end

local toStringMsgN = function()
	table.insert(strResult, "\n")
end

local toStringMsgC = function(_, txt)
	table.insert(strResult, txt)
end

function showStr(...)
	local oldF, oldN, oldMsgC, oldMsgN = gMsgF, gMsgN, MsgC, MsgN
	gMsgF, gMsgN, MsgC, MsgN = toStringMsgF, toStringMsgN, toStringMsgC, toStringMsgN

	strResult = {}
	show(...)

	gMsgF, gMsgN, MsgC, MsgN = oldF, oldN, oldMsgC, oldMsgN

	return table.concat(strResult, "")
end

--addons/fprofiler/lua/fprofiler/ui/clientcontrol.lua:
local get, update, onUpdate = FProfiler.UI.getModelValue, FProfiler.UI.updateModel, FProfiler.UI.onModelUpdate

--[[-------------------------------------------------------------------------
(Re)start clientside profiling
---------------------------------------------------------------------------]]
local function restartProfiling()
	if get({"client", "shouldReset"}) then
		FProfiler.Internal.reset()
		update({"client", "recordTime"}, 0)
	end

	local focus = get({"client", "focusObj"})

	update({"client", "sessionStart"}, CurTime())
	update({"client", "sessionStartSysTime"}, SysTime())
	FProfiler.Internal.start(focus)
end

--[[-------------------------------------------------------------------------
Stop profiling
---------------------------------------------------------------------------]]
local function stopProfiling()
	FProfiler.Internal.stop()

	local newTime = get({"client", "recordTime"}) + SysTime() - (get({"client", "sessionStartSysTime"}) or 0)

	-- Get the aggregated data
	local mostTime = FProfiler.Internal.getAggregatedResults(100)

	update({"client", "bottlenecks"}, mostTime)
	update({"client", "topLagSpikes"}, FProfiler.Internal.getMostExpensiveSingleCalls())

	update({"client", "recordTime"}, newTime)
	update({"client", "sessionStart"}, nil)
	update({"client", "sessionStartSysTime"}, nil)
end

--[[-------------------------------------------------------------------------
Start/stop recording when the recording status is changed
---------------------------------------------------------------------------]]
onUpdate({"client", "status"}, function(new, old)
	if new == old then return end
	(new == "Started" and restartProfiling or stopProfiling)()
end)

--[[-------------------------------------------------------------------------
Update the current selected focus object when data is entered
---------------------------------------------------------------------------]]
onUpdate({"client", "focusStr"}, function(new)
	update({"client", "focusObj"}, FProfiler.funcNameToObj(new))
end)

--[[-------------------------------------------------------------------------
Update info when a different line is selected
---------------------------------------------------------------------------]]
onUpdate({"client", "currentSelected"}, function(new)
	if not new or not new.info or not new.info.linedefined or not new.info.lastlinedefined or not new.info.short_src then return end

	update({"client", "sourceText"}, FProfiler.readSource(new.info.short_src, new.info.linedefined, new.info.lastlinedefined))
end)

--[[-------------------------------------------------------------------------
When a function is to be printed to console
---------------------------------------------------------------------------]]
onUpdate({"client", "toConsole"}, function(data)
	if not data then return end

	update({"client", "toConsole"}, nil)
	show(data)

	file.CreateDir("fprofiler")
	file.Write("fprofiler/profiledata.txt", showStr(data))
	MsgC(Color(200, 200, 200), "-----", Color(120, 120, 255), "NOTE", Color(200, 200, 200), "---------------\n")
	MsgC(Color(200, 200, 200), "If the above function does not fit in console, you can find it in data/fprofiler/profiledata.txt\n\n")
end)

--[[-------------------------------------------------------------------------
API function: start profiling
---------------------------------------------------------------------------]]
function FProfiler.start(focus)
	update({"client", "focusStr"}, tostring(focus))
	update({"client", "focusObj"}, focus)
	update({"client", "shouldReset"}, true)
	update({"client", "status"}, "Started")
end

--[[-------------------------------------------------------------------------
API function: stop profiling
---------------------------------------------------------------------------]]
function FProfiler.stop()
	update({"client", "status"}, "Stopped")
end

--[[-------------------------------------------------------------------------
API function: continue profiling
---------------------------------------------------------------------------]]
function FProfiler.continueProfiling()
	update({"client", "shouldReset"}, false)
	update({"client", "status"}, "Started")
end

--addons/gm_express/lua/autorun/gm_express_init.lua:
AddCSLuaFile( "includes/modules/pon.lua" )
include( "gm_express/sh_init.lua" )

--addons/gtawards/lua/gtawards/client/cl_vgui_listview.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

local GTawardsListView = {}

surface.CreateFont("GTawardsListViewLine", {
	font = "Default",
	size = ScreenScale(6),
	width = 150
})

surface.CreateFont("GTawardsListViewColumn", {
	font = "Default",
	size = ScreenScale(12),
	width = 150
})

function GTawardsListView:Init()
	self.backgroundColor = Color(20, 20, 20)
	self.scrollbarColor = Color(20, 20, 20)
	self.scrollbarGripColor = Color(229, 177, 58)
	self.scrollbarBtnUpColor = Color(10, 10, 10)
	self.scrollbarBtnUpBgColor = Color(229, 177, 58)
	self.scrollbarBtnDownColor = Color(10, 10, 10)
	self.scrollbarBtnDownBgColor = Color(229, 177, 58)
	self.lineBgColor = Color(30, 30, 30)
	self.lineAltBgColor = Color(20, 20, 20)
	self.lineSelectedBgColor = Color(75, 213, 238, 50)
	self.headerBgColor = Color(229, 177, 58)
	self.headerTextColor = Color(255, 255, 255)
	self.lineTextColor = Color(255, 255, 255)
end

function GTawardsListView:AddCustomLine(...)
	local listView = self
	local line = self:AddLine(...)
	local lineColumns = line.Columns

	for k, lineColumn in pairs(lineColumns) do
		lineColumn.Text = lineColumn:GetText()
		lineColumn:SetText("")
		function lineColumn:Paint(width, height)
			draw.DrawText(lineColumn.Text, "GTawardsListViewLine", self:GetWide() * 0.5, self:GetTall() * 0.1, listView.lineTextColor, TEXT_ALIGN_CENTER)
		end
	end
	
	function line:Paint(width, height)
		if self:IsSelected() then
			draw.RoundedBox(0, 0, 0, width, height, listView.lineSelectedBgColor)
		else
			if self:GetAltLine() then
				draw.RoundedBox(0, 0, 0, width, height, listView.lineAltBgColor)
			else
				draw.RoundedBox(0, 0, 0, width, height, listView.lineBgColor)
			end
		end
	end

	return line
end

function GTawardsListView:AddCustomColumn(...)
	local listView = self

	local column = self:AddColumn(...)
	local header = column.Header
	header:SetFont("GTawardsListViewColumn")
	header:SetTextColor(self.headerTextColor)

	function header:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, listView.headerBgColor)
	end

	return column
end
-- {{ user_id | 25 }}
function GTawardsListView:Paint(width, height)
	local listView = self

	draw.RoundedBox(0, 0, 0, width, height, self.backgroundColor)

	function self.VBar:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarColor)

		function self.btnUp:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarBtnUpBgColor)

			surface.SetDrawColor(listView.scrollbarBtnUpColor)
			draw.NoTexture()
			surface.DrawPoly({
				{x = 3, y = 11.5},
				{x = 7.5, y = 3.5},
				{x = 12, y = 11.5}
			})
		end

		function self.btnDown:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarBtnDownBgColor)

			surface.SetDrawColor(listView.scrollbarBtnDownColor)
			draw.NoTexture()
			surface.DrawPoly({
				{x = 12, y = 3.5},
				{x = 7.5, y = 11.5},
				{x = 3, y = 3.5}		
			})
		end

		function self.btnGrip:Paint(width, height)
			draw.RoundedBox(3, 0, 0, width, height, listView.scrollbarGripColor)
		end
	end
end

function GTawardsListView:BackgroundColor(color)
	self.backgroundColor = color
end

function GTawardsListView:ScrollbarColor(color)
	self.scrollbarColor = color
end

function GTawardsListView:BtnUpColor(color)
	self.scrollbarBtnUpColor = color
end

function GTawardsListView:BtnUpBgColor(color)
	self.scrollbarBtnUpBgColor = color
end

function GTawardsListView:BtnDownColor(color)
	self.scrollbarBtnDownColor = color
end

function GTawardsListView:BtnDownBgColor(color)
	self.scrollbarBtnDownBgColor = color
end

function GTawardsListView:GripColor(color)
	self.scrollbarGripColor = color
end

function GTawardsListView:LineBgColor(color)
	self.lineBgColor = color
end

function GTawardsListView:LineAltBgColor(color)
	self.lineAltBgColor = color
end

function GTawardsListView:LineSelectedBgColor(color)
	self.lineSelectedBgColor = color
end

function GTawardsListView:HeaderBgColor(color)
	self.headerBgColor = color
end

function GTawardsListView:HeaderTextColor(color)
	self.headerTextColor = color
end

function GTawardsListView:LineTextColor(color)
	self.lineTextColor = color
end

vgui.Register("GTawardsListView", GTawardsListView, "DListView")
--addons/gtawards/lua/gtawards/client/cl_vgui_pageselector.lua:
-- VGUI Element that generates a page selector.
--
-- Parent: DPanel
--
-- UpdateDockScaling() - Update the size of the page selector.
-- PerformLayout(width, height) - Update the size of the page selector whenever the panels layout was invalidated.
-- Refresh() - Refreshes the selector.
-- SetPage(page) - Sets the current page of the selector.
-- GetPage() - Returns the selected page.
-- SetPageCount(pageCount) - Sets the pagecount for all pages.
-- GetPageCount() - Returns the pagecount for all pages.
-- SetCallback(callback) - Sets callback.
-- SetEnabled(bool) - Enables/Disables the selector.

local GTawardsPageSelector = {}

-- Initializes the GTawardsPageSelector.
function GTawardsPageSelector:Init()
    local pageSelectorInstance = self

    self.Page = 1
    self.Pages = 1

    self.PagePreviousButton = vgui.Create("DButton", self)
    self.PagePreviousButton:Dock(LEFT)
    self.PagePreviousButton:SetText("<")
    self.PagePreviousButton:SetTextColor(GTawards.TextColor)
    self.PagePreviousButton:SetContentAlignment(5)
    self.PagePreviousButton:SetFont("GTawards.TopBar")
    function self.PagePreviousButton:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, GTawards.Color2)
    end
    function self.PagePreviousButton:DoClick()
        if self:GetDisabled() then return end

        local newPage = pageSelectorInstance.Page - 1

        if newPage > 0 and newPage <= pageSelectorInstance.Pages then
            pageSelectorInstance:SetPage(newPage)

            if isfunction(pageSelectorInstance.Callback) then
                pageSelectorInstance.Callback(newPage)
            end
        end
    end
    function self.PagePreviousButton:Refresh()
        self:SetTextColor((pageSelectorInstance.Page > 1) and GTawards.TextColor or Color(0,0,0,0))
    end

    self.PageNextButton = vgui.Create("DButton", self)
    self.PageNextButton:Dock(RIGHT)
    self.PageNextButton:SetText(">")
    self.PageNextButton:SetTextColor(GTawards.TextColor)
    self.PageNextButton:SetContentAlignment(5)
    self.PageNextButton:SetFont("GTawards.TopBar")
    function self.PageNextButton:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, GTawards.Color2)
    end
    function self.PageNextButton:DoClick()
        if self:GetDisabled() then return end

        local newPage = pageSelectorInstance.Page + 1

        if newPage > 0 and newPage <= pageSelectorInstance.Pages then
            pageSelectorInstance:SetPage(newPage)

            if isfunction(pageSelectorInstance.Callback) then
                pageSelectorInstance.Callback(newPage)
            end
        end
    end
    function self.PageNextButton:Refresh()
        self:SetTextColor((pageSelectorInstance.Page < pageSelectorInstance.Pages) and GTawards.TextColor or Color(0,0,0,0))
    end

    self.PageTextEntry = vgui.Create("DTextEntry", self)
    self.PageTextEntry:SetTextColor(Color(255, 255, 255))
    self.PageTextEntry:SetText(self.Page)
    self.PageTextEntry:SetFont("GTawards.TopBar")
    function self.PageTextEntry:Paint(width, height)
        if self:IsEditing() then
            draw.RoundedBox(5, 0, 0, width, height, Color(255, 255, 255, 20))
        else
            draw.RoundedBox(5, 0, 0, width, height, Color(20, 20, 20, 150))
        end

        draw.DrawText(self:GetValue(), self:GetFont(), width * 0.5, 0, self:GetTextColor(), TEXT_ALIGN_CENTER)
    end
    function self.PageTextEntry:Think()
        if self:IsEditing() then
            if not self.AlreadyCleared then
                self.AlreadyCleared = true
                self.OldText = self:GetText()
                self:SetText("")
            end
        else
            if self.AlreadyCleared then
                self.AlreadyCleared = false
                self:SetText(self.OldText)
            end
        end
    end
    function self.PageTextEntry:OnValueChange(value)
        if self:GetDisabled() then return end

        local newPage = tonumber(value)

        if isnumber(newPage) then
            if newPage > 0 and newPage <= pageSelectorInstance.Pages then
                pageSelectorInstance:SetPage(newPage)

                if isfunction(pageSelectorInstance.Callback) then
                    pageSelectorInstance.Callback(newPage)
                end
                
                self.AlreadyCleared = false
            end
        end
    end

    -- We need to do it in the next frame (timer.Simple(0)) to support docking.
    timer.Simple(0, function()
        self:UpdateDockScaling()
    end)
end

-- Update the size of the page selector.
function GTawardsPageSelector:UpdateDockScaling()
    if not IsValid(self) then return end

    local w, h = self:GetSize()

    self.PagePreviousButton:SetSize(w * 0.1, h)
    self.PageNextButton:SetSize(w * 0.1, h)

    self.PageTextEntry:SetSize(ScrW() * 0.02, h)
    self.PageTextEntry:SetPos(w * 0.5 - ScrW() * 0.01, 0)
end

-- Update the size of the page selector whenever the panels layout was invalidated.
--
-- @param Number width
-- @param Number height
function GTawardsPageSelector:PerformLayout(width, height)
    self:UpdateDockScaling()
end

-- Draws the selector.
--
-- @param Number width
-- @param Number height
local ofTranslation = GTawards:Translate("of")
local pageTranslation = GTawards:Translate("page")
function GTawardsPageSelector:Paint(width, height)
    draw.RoundedBox(0, 0, 0, width, height, GTawards.Color2)

    draw.DrawText(ofTranslation .. " " .. self.Pages, "GTawards.TopBar", width * 0.5 + ScrW() * 0.01 + 5, 0, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT)
    draw.DrawText(pageTranslation, "GTawards.TopBar", width * 0.5 - ScrW() * 0.01 - 6, 0, Color(255, 255, 255, 255), TEXT_ALIGN_RIGHT)
end

-- Refreshes the selector.
function GTawardsPageSelector:Refresh()
    self.PagePreviousButton:Refresh()
    self.PageNextButton:Refresh()
end

-- Sets the current page of the selector. Does not call the callback!
--
-- @param Number page
function GTawardsPageSelector:SetPage(page)
    if page < 1 then
        page = 1
    elseif page >= self.Pages then
        page = self.Pages
    end

    self.Page = page
    self.PageTextEntry:SetText(page)

    self:Refresh()
end

-- Returns the selected page.
--
-- @return Number page
function GTawardsPageSelector:GetPage()
    return self.Page
end

-- Sets the pagecount for all pages.
--
-- @param Number pageCount
function GTawardsPageSelector:SetPageCount(pageCount)
    if pageCount < 1 then
        pageCount = 1
    end

    self.Pages = pageCount

    if pageCount < self.Page then
        self:SetPage(pageCount)
    end

    self:Refresh()
end

-- Returns the pagecount for all pages.
--
-- @return Number pageCount
function GTawardsPageSelector:GetPageCount()
    return self.Pages
end

-- Sets callback.
--
-- @param Function callback
function GTawardsPageSelector:SetCallback(callback)
    self.Callback = callback
end

vgui.Register("GTawardsPageSelector", GTawardsPageSelector, "DPanel")

--addons/gtawards/lua/gtawards/localization/de.lua:
GTawards.Localization["of"] = "von"
GTawards.Localization["page"] = "Seite"
GTawards.Localization["congratulations"] = "Glückwunsch! Du bist jetzt $1!"
GTawards.Localization["rankup"] = "$1 ist jetzt $2!"

GTawards.Localization["timepanel.reached_max_rank"] = "Höchster Rang: $1"
GTawards.Localization["timepanel.time_left"] = "$1 verbleibend bis $2"

GTawards.Localization["topplayers.title"] = "Top-Spielerliste"
GTawards.Localization["topplayers.your_position"] = "Deine Position: $1"
GTawards.Localization["topplayers.name"] = "Name"
GTawards.Localization["topplayers.time"] = "Zeit"
GTawards.Localization["topplayers.rank"] = "Rang"
GTawards.Localization["topplayers.steam_profile"] = "Steam Profil"
GTawards.Localization["topplayers.loading"] = "Lädt..."
GTawards.Localization["topplayers.no_data"] = "Keine Daten"
--addons/hbombs_base/lua/autorun/hb_download_basics.lua:
-- DO NOT REMOVE THIS FILE! THIS IS BASIC FILE DOWNLOAD WHICH IS ABSOLUTELY REQUIRED BY ANY CLIENT! IF YOU REMOVE THIS THEN MOST CLIENTS WILL BE BLIND BY PURPLE CHECKERS!
AddCSLuaFile();
if (SERVER) then
  resource.AddSingleFile( "materials/hud/radiation.vmt" )
  resource.AddSingleFile( "materials/hud/radiation.vtf" )
  resource.AddSingleFile( "sound/natsu/firedrive.mp3" )
  resource.AddWorkshop( 668552230 )
  resource.AddWorkshop( 668558959 )
end

--addons/hbombs_base/lua/autorun/hb_emp_whitelist_ragdoll.lua:

if SERVER then
	AddCSLuaFile();
emp_whiteragdolllist = {"npc_combinedropship",
	"npc_strider",
	"npc_dog",
	"npc_stalker",
	"npc_combinegunship",
	"npc_hunter"}
end

--lua/autorun/homeone_bacta_v1.lua:
-- Created by Oninoni
-- Based on Code by Syphadias
-- Huge thanks to them!

-- This has to match the map Name
if not (game.GetMap() == "rp_home_one_v1" or game.GetMap() == "rp_home_one_v1_inf") then return end

-- The Ammount of Bacta Tanks that are used
local bactaCount = 4

-- The Name of the prop_vehicle_prisoner_pod without its suffix (e.g. bacta1, bacta2, ... -> bacta)
local entityName = "bacta"

-- Bacta Seat Don't fricking touch anything below this line!
local Category = "Map Utilities"
local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_GMOD_NOCLIP_LAYER )
end
local V = {
    Name = "Bacta Tank Seat",
	Model = "models/lordtrilobite/starwars/props/bactatankb.mdl",
    Class = "prop_vehicle_prisoner_pod",
    Category = Category,
 
    Author = "Syphadias, Oninoni",
    Information = "Seat with custom animation",
    Offset = 16,
 
    KeyValues = {
        vehiclescript = "scripts/vehicles/prisoner_pod.txt",
        limitview = "0"
    },
    Members = {
        HandleAnimation = StandAnimation
    }
}
list.Set( "Vehicles", "bacta_seat", V )
 
if SERVER then
    local seatCache = {}
    local function IsValidSeat(seat)
        local seat = seatCache[seat]
     
        if seat and IsValid(seat) then
			return true
        end
     
        return false
    end
	
	hook.Add("Think", "UpdateseatPosBacta", function()
		for i = 1, bactaCount, 1 do
			if !IsValidSeat(i) then
				seatCache[i] = ents.FindByName(entityName .. i)[1]

				if !IsValidSeat(i) then
					continue
				end
			end

			seatCache[i]:SetVehicleClass("bacta_seat")
		end
	end)
end
--lua/autorun/hondo_addon.lua:
player_manager.AddValidModel( "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );
list.Set( "PlayerOptionsModel",  "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );


--lua/autorun/jedi_female.lua:
player_manager.AddValidModel( "jedi_female", 				"models/cheek/jedi/jedi_female.mdl" )
list.Set( "PlayerOptionsModel",  "jedi_female",				"models/cheek/jedi/jedi_female.mdl" )
--lua/autorun/kingpommes_droid_playermodels.lua:
//	Created by KingPommes

//MSE-6 Mouse Droid
player_manager.AddValidModel( "MSE-6 Mouse Droid", "models/KingPommes/starwars/playermodels/mouse.mdl" );
list.Set( "PlayerOptionsModel", "MSE-6 Mouse Droid", "models/KingPommes/starwars/playermodels/mouse.mdl" );

//LIN-V8K
player_manager.AddValidModel( "LIN-V8K", "models/KingPommes/starwars/playermodels/lin.mdl" );
list.Set( "PlayerOptionsModel", "LIN-V8K", "models/KingPommes/starwars/playermodels/lin.mdl" );

//WED-15
player_manager.AddValidModel( "WED-15", "models/KingPommes/starwars/playermodels/wed.mdl" );
list.Set( "PlayerOptionsModel", "WED-15", "models/KingPommes/starwars/playermodels/wed.mdl" );

//GNK
player_manager.AddValidModel( "GNK", "models/KingPommes/starwars/playermodels/gnk.mdl" );
list.Set( "PlayerOptionsModel", "GNK", "models/KingPommes/starwars/playermodels/gnk.mdl" );

//Astromech
player_manager.AddValidModel( "Astromech", "models/KingPommes/starwars/playermodels/astromech.mdl" );
list.Set( "PlayerOptionsModel", "Astromech", "models/KingPommes/starwars/playermodels/astromech.mdl" );

--lua/autorun/lux.lua:
player_manager.AddValidModel( "Lux Bonteri", "models/player/TCW/human/lux_bonteri.mdl" );
--addons/lvs_base/lua/lvs_framework/autorun/cl_camera.lua:

function LVS:CalcView( vehicle, ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = vehicle:OBBMins()
	local mx = vehicle:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * radius * pod:GetCameraHeight()
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

hook.Add( "CalcView", "!!!!LVS_calcview", function(ply, pos, angles, fov)
	if ply:GetViewEntity() ~= ply then return end

	local pod = ply:GetVehicle()
	local vehicle = ply:lvsGetVehicle()

	if not IsValid( pod ) or not IsValid( vehicle ) then return end

	local newfov = vehicle:LVSCalcFov( fov, ply )

	local base = pod:lvsGetWeapon()

	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( base, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	else
		local weapon = vehicle:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( vehicle, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	end
end )

--addons/lvs_base/lua/lvs_framework/autorun/cl_circles.lua:
--[[
by SneakySquid, it's the best thing ever. 10000 times better than draw.Arc
see https://github.com/SneakySquid/Circles
]]

if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		if inner_r >= radius then
			self:SetShouldRender(false)
		else
			if inner_r >= 1 then
				inner:SetType(CIRCLE_FILLED)

				inner:SetRadius(inner_r)
				inner:SetAngles(start_angle, end_angle)

				inner:SetColor(false)
				inner:SetMaterial(false)

				inner:SetShouldRender(true)
			else
				inner:SetShouldRender(false)
			end

			self:SetShouldRender(true)
		end

		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then
			self:Calculate()
		end

		if not self.m_ShouldRender or not self:IsValid() then
			return false
		end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		if x == 0 and y == 0 then return end

		self.m_X = self.m_X + x
		self.m_Y = self.m_Y + y

		if not self:IsValid() then return end

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = vertex.x + x
			vertex.y = vertex.y + y
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Translate(x, y)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))
		if scale == 1 then return end

		self.m_Radius = self.m_Radius * scale

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = x + (vertex.x - x) * scale
			vertex.y = y + (vertex.y - y) * scale
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Scale(scale)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))
		if rotation == 0 then return end

		self.m_Rotation = self.m_Rotation + rotation

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y
		local vertices = self.m_Vertices
		local rotate_uv = self.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Rotate(rotation)
		end
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if isfunction(callback) then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesX(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function OffsetVerticesY(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesY(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function UpdateRotation(circle, old, new)
		if not circle:IsValid() then return end

		local vertices = circle.m_Vertices
		local x, y = circle.m_X, circle.m_Y
		local rotation = new - old
		local rotate_uv = circle.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			UpdateRotation(circle.m_ChildCircle, old, new)
		end

		return new
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)				-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)				-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)			-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")			-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")		-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")		-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")			-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)				-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)				-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")		-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or 0
		y = tonumber(y) or 0

		self:Translate(x - self.m_X, y - self.m_Y)
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--addons/lvs_base/lua/lvs_framework/autorun/cl_fonts.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 14,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LVS_VERSION", THE_FONT )

THE_FONT.extended = false
THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT", THE_FONT )

THE_FONT.size = 16
surface.CreateFont( "LVS_FONT_SWITCHER", THE_FONT )

THE_FONT.font = "Arial"
THE_FONT.size = 14
THE_FONT.weight = 1
THE_FONT.shadow = false
surface.CreateFont( "LVS_FONT_PANEL", THE_FONT )

THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT_HUD", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 2000
THE_FONT.shadow = true
surface.CreateFont( "LVS_FONT_HUD_LARGE", THE_FONT )
--addons/lvs_base/lua/lvs_framework/autorun/cl_menu.lua:

local icon_load_version = Material("gui/html/refresh")

local bgMat = Material( "lvs/controlpanel_bg.png" )
local adminMat = Material( "icon16/shield.png" )
local gradient_mat = Material( "gui/gradient" )
local gradient_down = Material( "gui/gradient_down" )

local FrameSizeX = 600
local FrameSizeY = 400

local function ClientSettings( Canvas )
	local TopPanel = vgui.Create( "DPanel", Canvas )
	TopPanel:SetSize( FrameSizeX, FrameSizeY * 0.35 )
	TopPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 1, 0, w, 1 )

		draw.DrawText( "Mouse", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	TopPanel:Dock( BOTTOM )

	local RightPanel = vgui.Create( "DPanel", Canvas )
	RightPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	RightPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_down )
		surface.DrawTexturedRect( 0, 0, 1, h )
		draw.DrawText( "Misc/Performance", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	RightPanel:Dock( RIGHT )

	local RightPanelRight = vgui.Create( "DPanel", RightPanel )
	RightPanelRight:SetSize( FrameSizeX * 0.25, FrameSizeY )
	RightPanelRight.Paint = function() end
	RightPanelRight:Dock( RIGHT )

	local LeftPanel = vgui.Create( "DPanel", Canvas )
	LeftPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	LeftPanel.Paint = function( self, w, h )
		draw.DrawText( "Preferences", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	LeftPanel:Dock( LEFT )

	local CheckBoxPanel = vgui.Create( "DPanel", TopPanel )
	CheckBoxPanel:DockMargin( 0, 0, 0, 0 )
	CheckBoxPanel:SetSize( FrameSizeX, 55 )
	CheckBoxPanel.Paint = function() end
	CheckBoxPanel:Dock( TOP )

	if GetConVar( "lvs_mouseaim_type" ):GetInt() == 1 and not LVS:IsDirectInputForced() then
		local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
		CheckBoxType:DockMargin( 16, 36, 0, 0 )
		CheckBoxType:Dock( LEFT )
		CheckBoxType:SetText( "Mouse-Aim for:" )
		CheckBoxType:SetConVar("lvs_mouseaim_type") 
		CheckBoxType.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end

		local DScrollPanel = vgui.Create("DScrollPanel", CheckBoxPanel )
		DScrollPanel:SetSize( FrameSizeX * 0.25, 55 )
		DScrollPanel:DockMargin( 8, 0, 8, 0 )
		DScrollPanel:Dock( LEFT )

		for _, vehicletype in pairs( LVS:GetVehicleTypes() ) do
			local ScrollOption = vgui.Create( "DCheckBoxLabel", DScrollPanel )
			ScrollOption:SetText( vehicletype )
			ScrollOption:Dock( TOP )
			ScrollOption:DockMargin( 0, 0, 0, 5 )
			ScrollOption:SetConVar("lvs_mouseaim_type_"..vehicletype) 
		end
	else
		local CheckBox = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBox:SetSize( FrameSizeX * 0.5, 55 )
		CheckBox:DockMargin( 16, 36, 0, 0 )
		CheckBox:Dock( LEFT )
		CheckBox:SetText( "Mouse-Aim Steering" )
		CheckBox:SetConVar("lvs_mouseaim") 
		CheckBox.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end
		if LVS:IsDirectInputForced() then
			CheckBox:SetText( "[DISABLED] Use Mouse-Aim Steering" )
			CheckBox:SetDisabled( true )
		end

		if not LVS:IsDirectInputForced() then
			local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
			CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
			CheckBoxType:DockMargin( 16, 36, 0, 0 )
			CheckBoxType:Dock( LEFT )
			CheckBoxType:SetText( "Edit Mouse-Aim per Type" )
			CheckBoxType:SetConVar("lvs_mouseaim_type") 
			CheckBoxType.OnChange = function( self, bVal )
				if not isbool( self.first ) then self.first = true return end
				timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
			end
		end
	end

	if GetConVar( "lvs_mouseaim" ):GetInt() == 0 or LVS:IsDirectInputForced() then
		local L = vgui.Create( "DPanel", TopPanel )
		L:SetSize( FrameSizeX * 0.5, FrameSizeY )
		L.Paint = function() end
		L:Dock( LEFT )

		local R = vgui.Create( "DPanel", TopPanel )
		R:SetSize( FrameSizeX * 0.5, FrameSizeY )
		R.Paint = function() end
		R:Dock( RIGHT )

		local slider = vgui.Create( "DNumSlider", R )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Y Sensitivity" )
		slider:SetMin( -10 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_y" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "X Sensitivity" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_x" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Return Delta" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_return_delta" )
	else
		local slider = vgui.Create( "DNumSlider", TopPanel )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Camera Focus" )
		slider:SetMin( -1 )
		slider:SetMax( 1 )
		slider:SetDecimals( 2 )
		slider:SetConVar( "lvs_camerafocus" )
	end

	local slider = vgui.Create( "DNumSlider", LeftPanel )
	slider:DockMargin( 16, 36, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Engine Volume" )
	slider:SetMin( 0 )
	slider:SetMax( 1 )
	slider:SetDecimals( 2 )
	slider:SetConVar( "lvs_volume" )

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Team Identifier" )
	CheckBox:SetConVar("lvs_show_identifier") 
	if LVS:IsIndicatorForced() then
		CheckBox:SetText( "[DISABLED] Team Identifier" )
		CheckBox:SetDisabled( true )
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Hit/Kill Marker" )
	CheckBox:SetConVar("lvs_hitmarker") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Enable HUD Editor" )
	CheckBox:SetConVar("lvs_edit_hud") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Trail Effects" )
	CheckBox:SetConVar("lvs_show_traileffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Wind/Dust FX/SFX" )
	CheckBox:SetConVar("lvs_show_effects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Scrape/Impact FX" )
	CheckBox:SetConVar("lvs_show_physicseffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Bullet near miss SFX" )
	CheckBox:SetConVar("lvs_bullet_nearmiss")
end

local function ClientControls( Canvas )
	local TextHint = vgui.Create("DPanel", Canvas)
	TextHint:DockMargin( 4, 20, 4, 2 )
	TextHint:SetText("")
	TextHint:Dock( TOP )
	TextHint.Paint = function(self, w, h ) 
		draw.DrawText( "You need to re-enter the vehicle in order for the changes to take effect!", "LVS_FONT_PANEL", w * 0.5, -1, Color( 255, 50, 50, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DScrollPanel = vgui.Create("DScrollPanel", Canvas)
	DScrollPanel:DockMargin( 0, 0, 0, 24 )
	DScrollPanel:Dock( FILL )

	for category, _ in pairs( LVS.KEYS_CATEGORIES ) do
		local Header = vgui.Create("DPanel", DScrollPanel )
		Header:DockMargin( 0, 4, 4, 2 )
		Header:SetText("")
		Header:Dock( TOP )
		Header.Paint = function(self, w, h ) 
			surface.SetMaterial( gradient_mat )
			surface.SetDrawColor( 80, 80, 80, 255 )
			surface.DrawTexturedRect( 0, 0, w, 1 )
	
			draw.DrawText( category, "LVS_FONT", 4, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			if entry.category ~= category then continue end

			local DPanel = vgui.Create( "DPanel", DScrollPanel )
			DPanel.Paint = function(self, w, h ) end
			DPanel:DockMargin( 4, 2, 4, 2 )
			DPanel:SetSize( FrameSizeX, 25 )
			DPanel:Dock( TOP )

			local ConVar = GetConVar( entry.cmd )

			local DLabel = vgui.Create("DLabel", DPanel)
			DLabel:DockMargin( 16, 0, 0, 0 )
			DLabel:SetText( entry.printname )
			DLabel:SetSize( FrameSizeX * 0.5, 32 )
			DLabel:Dock( LEFT )

			local DBinder = vgui.Create("DBinder", DPanel)
			DBinder:DockMargin( 0, 0, 0, 0 )
			DBinder:SetValue( ConVar:GetInt() )
			DBinder:SetSize( FrameSizeX * 0.5, 32 )
			DBinder:Dock( RIGHT )
			DBinder.ConVar = ConVar
			DBinder.OnChange = function(self,iNum)
				self.ConVar:SetInt(iNum)

				LocalPlayer():lvsBuildControls()
			end
		end
	end

	local Header = vgui.Create("DPanel", DScrollPanel )
	Header:DockMargin( 0, 16, 0, 0 )
	Header:SetText("")
	Header:Dock( TOP )
	Header.Paint = function(self, w, h ) 
		surface.SetMaterial( gradient_mat )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.DrawTexturedRect( 0, 0, w, 1 )
	end

	local DButton = vgui.Create("DButton",DScrollPanel)
	DButton:SetText("Reset")
	DButton:DockMargin( 4, 0, 4, 4 )
	DButton:SetSize( FrameSizeX, 32 )
	DButton:Dock( TOP )
	DButton.DoClick = function() 
		surface.PlaySound( "buttons/button14.wav" )

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			GetConVar( entry.cmd ):SetInt( entry.default ) 
		end

		LocalPlayer():lvsBuildControls()

		LVS:OpenClientControls()
	end
end

local function ServerSettings( Canvas )
	local slider = vgui.Create( "DNumSlider", Canvas )
	slider:DockMargin( 16, 32, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Player Default AI-Team" )
	slider:SetMin( 0 )
	slider:SetMax( 3 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lvs_default_teams" )
	function slider:OnValueChanged( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_default_teams")
			net.WriteString( tostring( math.Round(val,0) ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Freeze Player AI-Team" )
	CheckBox:SetValue( GetConVar( "lvs_freeze_teams" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_freeze_teams")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Only allow Players of matching AI-Team to enter Vehicles" )
	CheckBox:SetValue( GetConVar( "lvs_teampassenger" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_teampassenger")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore NPC's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignorenpcs" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignorenpcs")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore Players's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignoreplayers" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignoreplayers")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Disable Mouse Aim" )
	CheckBox:SetValue( GetConVar( "lvs_force_directinput" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_directinput")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Hide Team Identifier" )
	CheckBox:SetValue( GetConVar( "lvs_force_forceindicator" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_forceindicator")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end
end

function LVS:OpenClientSettings()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( LEFT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientControls()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 0, w-2, h-1)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientSettings( Canvas )
end

function LVS:OpenClientControls()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( RIGHT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 1, w-2, h-2)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientControls( Canvas )
end

function LVS:OpenServerMenu()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local ServerPanel = vgui.Create( "DPanel", DPanel )
	ServerPanel.Paint = function(self, w, h ) end
	ServerPanel:DockMargin( 0, 0, 0, 0 )
	ServerPanel:SetSize( FrameSizeX * 0.5, 32 )
	ServerPanel:Dock( RIGHT )
	ServerPanel.Paint = function(self, w, h ) 
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ServerSettings( Canvas )
end

function LVS:CloseMenu()
	if not IsValid( LVS.Frame ) then return end

	LVS.Frame:Close()
	LVS.Frame = nil
end

function LVS:OpenMenu( keep_position )
	local xPos
	local yPos

	if IsValid( LVS.Frame ) then
		if keep_position then
			xPos = LVS.Frame:GetX()
			yPos = LVS.Frame:GetY()
		end

		LVS:CloseMenu()
	end

	LVS.Frame = vgui.Create( "DFrame" )
	LVS.Frame:SetSize( FrameSizeX, FrameSizeY )
	LVS.Frame:SetTitle( "" )
	LVS.Frame:SetDraggable( true )
	LVS.Frame:SetScreenLock( true )
	LVS.Frame:MakePopup()
	LVS.Frame:Center()
	if keep_position and xPos and yPos then
		LVS.Frame:SetPos( xPos, yPos )
	end

	LVS.Frame.Paint = function(self, w, h )
		draw.RoundedBox( 8, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
		draw.RoundedBoxEx( 8, 1, 26, w-2, h-27, Color( 120, 120, 120, 255 ), false, false, true, true )
		draw.RoundedBoxEx( 8, 0, 0, w, 25, LVS.ThemeColor, true, true )

		draw.SimpleText( "[LVS] - Control Panel ", "LVS_FONT", 5, 11, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( 255, 255, 255, 50 )
		surface.SetMaterial( bgMat )
		surface.DrawTexturedRect( 0, -50, w, w )
	end
	LVS.Frame.CreatePanel = function( self )

		if IsValid( self.OldPanel ) then
			self.OldPanel:Remove()
			self.OldPanel = nil
		end

		local DPanel = vgui.Create( "DPanel", LVS.Frame )
		DPanel:SetPos( 0, 25 )
		DPanel:SetSize( FrameSizeX, FrameSizeY - 25 )
		DPanel.Paint = function(self, w, h )
			local Col = Color( 255, 191, 0, 255 ) 

			if LVS.VERSION_GITHUB == 0 then
				surface.SetMaterial( icon_load_version )
				surface.SetDrawColor( Col )
				surface.DrawTexturedRectRotated( w - 14, h - 14, 16, 16, -CurTime() * 200 )

				draw.SimpleText( "v"..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 23, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )

				return
			end

			local Current = LVS:GetVersion()
			local Latest = LVS.VERSION_GITHUB

			local Pref = "v"

			if Current >= Latest and not LVS.VERSION_ADDONS_OUTDATED then
				Col = Color(0,255,0,255)
			else
				Col = Color(255,0,0,255)
				Pref = "OUTDATED v"
			end

			draw.SimpleText( Pref..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 7, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		end

		self.OldPanel = DPanel

		return DPanel
	end

	LVS:OpenClientSettings()
end

list.Set( "DesktopWindows", "LVSMenu", {
	title = "[LVS] Settings",
	icon = "icon64/iconlvs.png",
	init = function( icon, window )
		LVS:OpenMenu()
	end
} )

concommand.Add( "lvs_openmenu", function( ply, cmd, args ) LVS:OpenMenu() end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

LVS.cVar_FreezeTeams = CreateConVar( "lvs_freeze_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"enable/disable auto ai-team switching" )
LVS.FreezeTeams = LVS.cVar_FreezeTeams and LVS.cVar_FreezeTeams:GetBool() or false
cvars.AddChangeCallback( "lvs_freeze_teams", function( convar, oldValue, newValue ) 
	LVS.FreezeTeams = tonumber( newValue ) ~=0
end, "lvs_freezeteams_callback" )

LVS.cVar_TeamPassenger = CreateConVar( "lvs_teampassenger", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"only allow players of matching ai-team to enter the vehicle? 1 = team only, 0 = everyone can enter" )
LVS.TeamPassenger = LVS.cVar_TeamPassenger and LVS.cVar_TeamPassenger:GetBool() or false
cvars.AddChangeCallback( "lvs_teampassenger", function( convar, oldValue, newValue ) 
	LVS.TeamPassenger = tonumber( newValue ) ~= 0
end, "lvs_teampassenger_callback" )

LVS.cVar_PlayerDefaultTeam = CreateConVar( "lvs_default_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"set default player ai-team" )
LVS.PlayerDefaultTeam = LVS.cVar_PlayerDefaultTeam and LVS.cVar_PlayerDefaultTeam:GetInt() or 0
cvars.AddChangeCallback( "lvs_default_teams", function( convar, oldValue, newValue ) 
	LVS.PlayerDefaultTeam = math.Round( tonumber( newValue ), 0 )
end, "lvs_defaultteam_callback" )

LVS.cVar_IgnoreNPCs = CreateConVar( "lvs_ai_ignorenpcs", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore NPCs?" )
LVS.IgnoreNPCs = LVS.cVar_IgnoreNPCs and LVS.cVar_IgnoreNPCs:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignoreplayers", function( convar, oldValue, newValue ) 
	LVS.IgnorePlayers = tonumber( newValue ) ~=0
end)

LVS.cVar_playerignore = CreateConVar( "lvs_ai_ignoreplayers", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore Players?" )
LVS.IgnorePlayers = LVS.cVar_playerignore and LVS.cVar_playerignore:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignorenpcs", function( convar, oldValue, newValue ) 
	LVS.IgnoreNPCs = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lvs_admin_setconvar" )

	net.Receive( "lvs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)

	return
end

CreateClientConVar( "lvs_mouseaim", 0, true, true)
CreateClientConVar( "lvs_mouseaim_type", 0, true, false)
CreateClientConVar( "lvs_edit_hud", 1, true, false)
CreateClientConVar( "lvs_sensitivity_x", 1, true, true)
CreateClientConVar( "lvs_sensitivity_y", 1, true, true)
CreateClientConVar( "lvs_return_delta", 2, true, true)

LVS.cvarCamFocus = CreateClientConVar( "lvs_camerafocus", 0, true, false)

local cvarVolume = CreateClientConVar( "lvs_volume", 0.5, true, false)
LVS.EngineVolume = cvarVolume and cvarVolume:GetFloat() or 0.5
cvars.AddChangeCallback( "lvs_volume", function( convar, oldValue, newValue ) 
	LVS.EngineVolume = math.Clamp( tonumber( newValue ), 0, 1 )
end)

local cvarTrail = CreateClientConVar( "lvs_show_traileffects", 1, true, false)
LVS.ShowTraileffects = cvarTrail and cvarTrail:GetBool() or true
cvars.AddChangeCallback( "lvs_show_traileffects", function( convar, oldValue, newValue ) 
	LVS.ShowTraileffects = tonumber( newValue ) ~=0
end)

local cvarEffects = CreateClientConVar( "lvs_show_effects", 1, true, false)
LVS.ShowEffects = cvarEffects and cvarEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_effects", function( convar, oldValue, newValue ) 
	LVS.ShowEffects = tonumber( newValue ) ~=0
end)

local cvarPhysEffects = CreateClientConVar( "lvs_show_physicseffects", 1, true, false)
LVS.ShowPhysicsEffects = cvarPhysEffects and cvarPhysEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_physicseffects", function( convar, oldValue, newValue ) 
	LVS.ShowPhysicsEffects = tonumber( newValue ) ~=0
end)

local cvarShowIdent = CreateClientConVar( "lvs_show_identifier", 1, true, false)
LVS.ShowIdent = cvarShowIdent and cvarShowIdent:GetBool() or true
cvars.AddChangeCallback( "lvs_show_identifier", function( convar, oldValue, newValue ) 
	LVS.ShowIdent = tonumber( newValue ) ~=0
end)

local cvarHitMarker = CreateClientConVar( "lvs_hitmarker", 1, true, false)
LVS.ShowHitMarker = cvarHitMarker and cvarHitMarker:GetBool() or false
cvars.AddChangeCallback( "lvs_hitmarker", function( convar, oldValue, newValue ) 
	LVS.ShowHitMarker = tonumber( newValue ) ~=0
end)

local cvarAntiAlias = GetConVar( "mat_antialias" )
LVS.AntiAliasingEnabled = cvarAntiAlias and (cvarAntiAlias:GetInt() > 3) or false
cvars.AddChangeCallback( "mat_antialias", function( convar, oldValue, newValue ) 
	LVS.AntiAliasingEnabled = tonumber( newValue ) > 3
end)

local cvarBulletSFX = CreateClientConVar( "lvs_bullet_nearmiss", 1, true, false)
LVS.EnableBulletNearmiss = cvarBulletSFX and cvarBulletSFX:GetBool() or true
cvars.AddChangeCallback( "lvs_bullet_nearmiss", function( convar, oldValue, newValue ) 
	LVS.EnableBulletNearmiss = tonumber( newValue ) ~=0
end)

local cvarDev = GetConVar( "developer" )
LVS.DeveloperEnabled = cvarDev and (cvarDev:GetInt() >= 1) or false
cvars.AddChangeCallback( "developer", function( convar, oldValue, newValue )
	LVS.DeveloperEnabled = (tonumber( newValue ) or 0) >= 1
end)

cvars.AddChangeCallback( "lvs_mouseaim", function( convar, oldValue, newValue )
	LocalPlayer():lvsBuildControls()

	net.Start("lvs_toggle_mouseaim")
	net.SendToServer()
end)

--addons/lvs_base/lua/lvs_framework/autorun/lvs_hookers.lua:

hook.Add( "InitPostEntity", "!!!lvsBullshitFixer", function()
	timer.Simple(1, function()
		LVS.MapDoneLoading = true
	end)

	if SERVER then return end

	-- this needs to be here to make sure all sents are registered
	for _, vehicletype in ipairs( LVS:GetVehicleTypes() ) do
		CreateClientConVar( "lvs_mouseaim_type_"..vehicletype, 0, true, false)
	end
end )

local function SetDistance( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraDistance then return end

	local newdist = math.Clamp( vehicle:GetCameraDistance() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraDistance() ), -1, 10 )

	vehicle:SetCameraDistance( newdist )
end

local function SetHeight( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraHeight then return end

	local newdist = math.Clamp( vehicle:GetCameraHeight() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraHeight() ), -1, 10 )

	vehicle:SetCameraHeight( newdist )
end

hook.Add( "VehicleMove", "!!!!lvs_vehiclemove", function( ply, vehicle, mv )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	if SERVER and ply:lvsKeyDown( "VIEWDIST" ) then
		if ply:lvsKeyDown( "VIEWHEIGHT" ) then
			SetHeight( vehicle, ply )
		else
			SetDistance( vehicle, ply )
		end
	end

	if CLIENT and not IsFirstTimePredicted() then return end
	
	local KeyThirdPerson = ply:lvsKeyDown("THIRDPERSON")

	if ply._lvsOldThirdPerson ~= KeyThirdPerson then
		ply._lvsOldThirdPerson = KeyThirdPerson

		if KeyThirdPerson and vehicle.SetThirdPersonMode then
			vehicle:SetThirdPersonMode( not vehicle:GetThirdPersonMode() )
		end
	end

	return true
end )

hook.Add("CalcMainActivity", "!!!lvs_playeranimations", function(ply)
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if IsValid( Ent ) then
		local A,B = Ent:CalcMainActivity( ply )

		if A and B then
			return A, B
		end
	end
end)

hook.Add("UpdateAnimation", "!!!lvs_playeranimations", function( ply, velocity, maxseqgroundspeed )
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if not IsValid( Ent ) then return end

	return Ent:UpdateAnimation( ply, velocity, maxseqgroundspeed )
end)

hook.Add( "StartCommand", "!!!!LVS_grab_command", function( ply, cmd )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	veh:StartCommand( ply, cmd )
end )

hook.Add( "CanProperty", "!!!!lvsEditPropertiesDisabler", function( ply, property, ent )
	if ent.LVS and not ply:IsAdmin() and property == "editentity" then return false end
end )

LVS.ToolsDisable = {
	["rb655_easy_animation"] = true,
	["rb655_easy_bonemerge"] = true,
	["rb655_easy_inspector"] = true,
}
hook.Add( "CanTool", "!!!!lvsCanToolDisabler", function( ply, tr, toolname, tool, button )
	if LVS.ToolsDisable[ toolname ] and IsValid( tr.Entity ) and tr.Entity.LVS then return false end
end )

if CLIENT then
	local hide = {
		["CHudHealth"] = true,
		["CHudBattery"] = true,
		["CHudAmmo"] = true,
	}
	local function HUDShouldDrawLVS( name )
		if hide[ name ] then return false end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, veh )
		hook.Add( "HUDShouldDraw", "!!!!lvs_hidehud", HUDShouldDrawLVS )

		if not IsValid( veh ) then return end

		local cvar = GetConVar( "lvs_mouseaim_type" )

		if not cvar or cvar:GetInt() ~= 1 or not veh.GetVehicleType then return end

		local vehicletype = veh:GetVehicleType()

		local cvar_type = GetConVar( "lvs_mouseaim_type_"..vehicletype )
		local cvar_mouseaim = GetConVar( "lvs_mouseaim" )

		if not cvar_type or not cvar_mouseaim then return end

		cvar_mouseaim:SetInt( cvar_type:GetInt() )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, veh )
		hook.Remove( "HUDShouldDraw", "!!!!lvs_hidehud" )
	end )

	hook.Add( "InitPostEntity", "!!!lvs_infmap_velocity_fixer", function()
		if not InfMap then

			hook.Remove( "InitPostEntity", "!!!lvs_infmap_velocity_fixer" )

			return
		end

		local meta = FindMetaTable( "Entity" )

		if not InfMapOriginalGetVelocity then
			InfMapOriginalGetVelocity = meta.GetVelocity
		end

		function meta:GetVelocity()
			local Velocity = InfMapOriginalGetVelocity( self )

			local EntTable = self:GetTable()

			if not EntTable.LVS and not EntTable._lvsRepairToolLabel then return Velocity end

			local Speed = Velocity:LengthSqr()

			local T = CurTime()

			if Speed > 10 then
				EntTable._infmapEntityVelocity = Velocity
				EntTable._infmapEntityVelocityTime = T + 0.6
			else
				if (EntTable._infmapEntityVelocityTime or 0) > T then
					return EntTable._infmapEntityVelocity or vector_origin
				end
			end

			return Velocity
		end
	end )

	return
end

local DamageFix = {
	["npc_hunter"] = true,
	["npc_stalker"] = true,
	["npc_strider"] = true,
	["npc_combinegunship"] = true,
	["npc_helicopter"] = true,
}

hook.Add( "EntityTakeDamage", "!!!_lvs_fix_vehicle_explosion_damage", function( target, dmginfo )
	if not target:IsPlayer() then
		if target.LVS then
			local attacker = dmginfo:GetAttacker()

			if IsValid( attacker ) and DamageFix[ attacker:GetClass() ] then
				dmginfo:SetDamageType( DMG_AIRBOAT )
				dmginfo:SetDamageForce( dmginfo:GetDamageForce():GetNormalized() * 15000 )
			end
		end

		return
	end

	local veh = target:lvsGetVehicle()

	if not IsValid( veh ) or dmginfo:IsDamageType( DMG_DIRECT ) then return end

	if target:GetCollisionGroup() == COLLISION_GROUP_PLAYER then return end

	dmginfo:SetDamage( 0 )
end )

hook.Add( "PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, Pod )
	local veh = ply:lvsGetVehicle()

	if IsValid( veh ) then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( true )
			net.WriteEntity( veh )
		net.Send( ply )

		ply._lvsIsInVehicle = true

		if istable( veh.PlayerBoneManipulate ) then
			local ID = Pod:lvsGetPodIndex()
			local BoneManipulate = veh.PlayerBoneManipulate[ ID ]

			if BoneManipulate then
				ply._lvsStopBoneManipOnExit = true
				ply:lvsStartBoneManip()
			end
		end

		if LVS.FreezeTeams then
			local nTeam = ply:lvsGetAITeam()

			if veh:GetAITEAM() ~= nTeam then
				veh:SetAITEAM( nTeam )

				ply:PrintMessage( HUD_PRINTTALK, "[LVS] This Vehicle's AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
			end
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( true )

	if pac then pac.TogglePartDrawing( ply, 0 ) end
end )

hook.Add( "PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, Pod )
	if ply._lvsIsInVehicle then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( false )
			net.WriteEntity( ply:lvsGetVehicle() )
		net.Send( ply )

		ply._lvsIsInVehicle = nil

		if ply._lvsStopBoneManipOnExit then
			ply._lvsStopBoneManipOnExit = nil

			ply:lvsStopBoneManip()
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( false )

	if pac then pac.TogglePartDrawing( ply, 1 ) end
end )

hook.Add( "PlayerDisconnected", "!!!!lvs_player_reset_bonemanip_client", function(ply)
	if not ply._lvsStopBoneManipOnExit then return end

	ply._lvsStopBoneManipOnExit = nil

	ply:lvsStopBoneManip()
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_keybinding.lua:

hook.Add( "LVS:Initialize", "!!11lvs_default_keys", function()
	local KEYS = {
		{
			name = "ATTACK",
			category = "Armament",
			name_menu = "Attack",
			default = MOUSE_LEFT,
			cmd = "lvs_lmb"
		},
		{
			name = "ZOOM",
			category = "Armament",
			name_menu = "Zoom",
			default = MOUSE_RIGHT,
			cmd = "lvs_rmb"
		},
		{
			name = "~SELECT~WEAPON#1",
			category = "Armament",
			name_menu = "Select Weapon 1",
			cmd = "lvs_select_weapon1"
		},
		{
			name = "~SELECT~WEAPON#2",
			category = "Armament",
			name_menu = "Select Weapon 2",
			cmd = "lvs_select_weapon2"
		},
		{
			name = "~SELECT~WEAPON#3",
			category = "Armament",
			name_menu = "Select Weapon 3",
			cmd = "lvs_select_weapon3"
		},
		{
			name = "~SELECT~WEAPON#4",
			category = "Armament",
			name_menu = "Select Weapon 4",
			cmd = "lvs_select_weapon4"
		},
		--[[ only adding 4 because i dont want to bloat the menu. There can be added as many keys as neededed the system should figure it out by itself
		{
			name = "~SELECT~WEAPON#5",
			category = "Armament",
			name_menu = "Select Weapon 5",
			cmd = "lvs_select_weapon5"
		},
		]]
		{
			name = "EXIT",
			category = "Misc",
			name_menu = "Exit Vehicle",
			default = "+use",
			cmd = "lvs_exit"
		},
		{
			name = "VIEWDIST",
			category = "Misc",
			name_menu = "Enable Mouse-Wheel Set-Camera-Distance",
			default = MOUSE_MIDDLE,
			cmd = "lvs_viewzoom"
		},
		{
			name = "VIEWHEIGHT",
			category = "Misc",
			name_menu = "Set-Camera-Distance => Set-Camera-Height",
			default = "phys_swap",
			cmd = "lvs_viewheight"
		},
		{
			name = "THIRDPERSON",
			category = "Misc",
			name_menu = "Toggle Thirdperson",
			default = "+duck",
			cmd = "lvs_thirdperson"
		},
		{
			name = "FREELOOK",
			category = "Misc",
			name_menu = "Freelook (Hold)",
			default = "+walk",
			cmd = "lvs_freelook"
		},
		{
			name = "ENGINE",
			category = "Misc",
			name_menu = "Toggle Engine",
			default = "+reload",
			cmd = "lvs_startengine"
		},
		{
			name = "VSPEC",
			category = "Misc",
			name_menu = "Toggle Vehicle-specific Function",
			default = "+jump",
			cmd = "lvs_special"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

if SERVER then return end

concommand.Add( "lvs_mouseaim_toggle", function( ply, cmd, args )
	local OldVar = GetConVar( "lvs_mouseaim" ):GetInt()

	if OldVar == 0 then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Enabled" )
		RunConsoleCommand( "lvs_mouseaim", "1" )

	else
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Disabled" )
		RunConsoleCommand( "lvs_mouseaim", "0" )
	end
end )

hook.Add( "PlayerBindPress", "!!!!_LVS_PlayerBindPress", function( ply, bind, pressed )
	if not ply.lvsGetVehicle then return end

	local vehicle = ply:lvsGetVehicle()

	if not IsValid( vehicle ) then return end

	if not ply:lvsKeyDown( "VIEWDIST" ) then
		if string.find( bind, "invnext" ) then
			vehicle:NextWeapon()
		end
		if string.find( bind, "invprev" ) then
			vehicle:PrevWeapon()
		end
	end

	if string.find( bind, "+zoom" ) then
		if vehicle.lvsDisableZoom then
			return true
		end
	end
end )

hook.Add( "SpawnMenuOpen", "!!!lvs_spawnmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableSpawnMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

hook.Add( "ContextMenuOpen", "!!!lvs_contextmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableContextMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

--addons/lvs_base/lua/lvs_framework/autorun/lvs_net.lua:

if SERVER then
	util.AddNetworkString( "lvs_player_request_filter" )
	util.AddNetworkString( "lvs_player_enterexit" )
	util.AddNetworkString( "lvs_toggle_mouseaim" )

	net.Receive( "lvs_toggle_mouseaim", function( length, ply )
		ply:lvsBuildControls()

		local veh = ply:lvsGetVehicle()

		if not IsValid( veh ) then return end

		veh:AlignView( ply )
	end)

	net.Receive( "lvs_player_request_filter", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.GetCrosshairFilterEnts then return end -- TODO: Make this loop around and wait for ent.IsInitialized to exist and ent:IsInitialized() to return true

		local CrosshairFilterEnts = table.Copy( ent:GetCrosshairFilterEnts() )

		for id, entity in pairs( CrosshairFilterEnts ) do
			if not IsValid( entity ) or entity:GetNoDraw() then
				CrosshairFilterEnts[ id ] = nil
			end
		end

		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( ent )
			net.WriteTable( CrosshairFilterEnts )
		net.Send( ply )
	end)
else
	net.Receive( "lvs_player_request_filter", function( length )
		local LVSent = net.ReadEntity()

		if not IsValid( LVSent ) then return end

		local Filter = {}

		for _, entity in pairs( net.ReadTable() ) do
			if not IsValid( entity ) then continue end
			table.insert( Filter, entity )
		end

		LVSent.CrosshairFilterEnts = Filter
	end )

	net.Receive( "lvs_player_enterexit", function( len )
		local Enable = net.ReadBool()
		local Vehicle = net.ReadEntity()

		if Enable then
			hook.Run( "LVS.PlayerEnteredVehicle", LocalPlayer(), Vehicle )
		else
			hook.Run( "LVS.PlayerLeaveVehicle", LocalPlayer(), Vehicle )
		end
	end )
end
--addons/lvs_base/lua/lvs_framework/autorun/lvs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lvsGetAITeam()
	return self:GetNWInt( "lvsAITeam", LVS.PlayerDefaultTeam )
end

function meta:lvsGetVehicle()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	if Pod.LVSchecked then

		return Pod.LVSBaseEnt

	else
		local Parent = Pod:GetParent()
		
		if not IsValid( Parent ) then return NULL end

		if not Parent.LVS then
			Pod.LVSchecked = LVS.MapDoneLoading
			Pod.LVSBaseEnt = NULL

			return NULL
		end

		Pod.LVSchecked = LVS.MapDoneLoading
		Pod.LVSBaseEnt = Parent

		return Parent
	end
end

function meta:lvsGetWeaponHandler()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	local weapon = Pod:lvsGetWeapon()

	if IsValid( weapon ) then
		return weapon
	else
		local veh = self:lvsGetVehicle()

		if not IsValid( veh ) then return NULL end

		if veh:GetDriver() == self then
			return veh
		else
			return NULL
		end
	end
end

function meta:lvsGetControls()
	if not istable( self.LVS_BINDS ) then
		self:lvsBuildControls()
	end
	
	return self.LVS_BINDS
end

function meta:lvsMouseAim()
	if LVS:IsDirectInputForced() then
		return false
	end

	return self._lvsMouseAim
end

function meta:lvsMouseSensitivity()
	local X = self._lvsMouseX or 1
	local Y = self._lvsMouseY or 1
	local delta = self._lvsReturnDelta or 1

	return X, Y, delta
end

function meta:lvsBuildControls()
	if istable( self.LVS_BINDS ) then
		table.Empty( self.LVS_BINDS )
	end

	if SERVER then
		self._lvsMouseAim = self:GetInfoNum( "lvs_mouseaim", 0 ) == 1

		self.LVS_BINDS = table.Copy( LVS.KEYS_CATEGORIES )

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local ButtonID = self:GetInfoNum( v.cmd, 0 )

			if not self.LVS_BINDS[v.category][ ButtonID ] then
				self.LVS_BINDS[v.category][ ButtonID ] = {}
			end

			table.insert( self.LVS_BINDS[v.category][ ButtonID ], v.id )
		end

		net.Start( "lvs_buildcontrols" )
		net.Send( self )

		self._lvsMouseX = self:GetInfoNum( "lvs_sensitivity_x", 1 )
		self._lvsMouseY = self:GetInfoNum( "lvs_sensitivity_y", 1 )
		self._lvsReturnDelta = self:GetInfoNum( "lvs_return_delta", 1 )
	else
		self._lvsMouseAim = GetConVar( "lvs_mouseaim" ):GetInt() == 1
		self._lvsMouseX = GetConVar(  "lvs_sensitivity_x" ):GetFloat()
		self._lvsMouseY = GetConVar( "lvs_sensitivity_y" ):GetFloat()
		self._lvsReturnDelta = GetConVar( "lvs_return_delta" ):GetFloat()

		self.LVS_BINDS = {}

		local KeySpawnMenu = input.LookupBinding( "+menu" )
		if isstring( KeySpawnMenu ) then
			KeySpawnMenu = input.GetKeyCode( KeySpawnMenu )
		end

		local KeyContextMenu = input.LookupBinding( "+menu_context" )
		if isstring( KeyContextMenu ) then
			KeyContextMenu = input.GetKeyCode( KeyContextMenu )
		end

		self._lvsDisableSpawnMenu = nil
		self._lvsDisableContextMenu = nil

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local KeyCode = GetConVar( v.cmd ):GetInt()

			self.LVS_BINDS[ v.id ] = KeyCode

			if KeyCode == KeySpawnMenu then
				self._lvsDisableSpawnMenu = true
			end
			if KeyCode == KeyContextMenu then
				self._lvsDisableContextMenu = true
			end
		end
	end
end

local IS_MOUSE_ENUM = {
	[MOUSE_LEFT] = true,
	[MOUSE_RIGHT] = true,
	[MOUSE_MIDDLE] = true,
	[MOUSE_4] = true,
	[MOUSE_5] = true,
	[MOUSE_WHEEL_UP] = true,
	[MOUSE_WHEEL_DOWN] = true,
}

local function GetInput( ply, name )
	if SERVER then
		if not ply._lvsKeyDown then
			ply._lvsKeyDown = {}
		end

		return ply._lvsKeyDown[ name ] == true
	else
		local Key = ply:lvsGetControls()[ name ] or 0

		if IS_MOUSE_ENUM[ Key ] then
			return input.IsMouseDown( Key ) 
		else
			return input.IsKeyDown( Key ) 
		end
	end
end

function meta:lvsKeyDown( name )
	if not self:lvsGetInputEnabled() then return false end

	local Pressed = GetInput( self, name )
	local NewPressed = hook.Run( "LVS.PlayerKeyDown", self, name, Pressed )

	if isbool( NewPressed ) then
		return NewPressed
	else
		return Pressed
	end
end

function meta:lvsGetInputEnabled()
	return (self._lvsKeyDisabler or 0) < CurTime()
end

function meta:lvsSetInputDisabled( disable )
	if CLIENT then
		net.Start( "lvs_buildcontrols" )
			net.WriteBool( disable )
		net.SendToServer()
	end

	if disable then
		self._lvsKeyDisabler = CurTime() + 120
	else
		self._lvsKeyDisabler = CurTime() + 0.25
	end
end

if CLIENT then
	function meta:lvsSetView( view )
		self._lvsViewPos = view.origin or vector_origin
		self._lvsViewAngles = view.angles or angle_zero

		return view
	end

	function meta:lvsGetView()
		local pos = self._lvsViewPos or vector_origin
		local ang = self._lvsViewAngles or angle_zero

		return pos, ang
	end

	net.Receive( "lvs_buildcontrols", function( len )
		local ply = LocalPlayer()
		if not IsValid( ply ) then return end
		ply:lvsBuildControls()
	end )

	local OldVisible = false
	local function KeyBlocker()
		local Visible = gui.IsGameUIVisible() or vgui.CursorVisible()

		if Visible ~= OldVisible then
			OldVisible = Visible

			local ply = LocalPlayer()

			if not IsValid( ply ) then return end

			if Visible then
				ply:lvsSetInputDisabled( true )
			else
				ply:lvsSetInputDisabled( false )
			end
		end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!!lvs_keyblocker_enable", function( ply, veh )
		hook.Add("PostDrawHUD", "!!!lvs_keyblocker", KeyBlocker )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!!lvs_keyblocker_disable", function( ply, veh )
		hook.Remove("PostDrawHUD", "!!!lvs_keyblocker" )
	end )

	local players_bonemanip = {}

	local function StartBoneManip( id )
		players_bonemanip[ id ] = true
	end

	local function StopBoneManip( id )
		if not players_bonemanip[ id ] then return end

		players_bonemanip[ id ] = nil

		local ply = Entity( id )

		if not IsValid( ply ) then return end

		local angle_zero = Angle(0,0,0)

		for i = 0, (ply:GetBoneCount() - 1) do
			ply:ManipulateBoneAngles( i, angle_zero )
		end
	end

	net.Receive( "lvs_bonemanip", function( len )
		local entindex = net.ReadInt( 9 )
		local enable = net.ReadBool()

		if enable then
			StartBoneManip( entindex )

			return
		end

		StopBoneManip( entindex )
	end )

	hook.Add( "Think", "!!!!!lvs_player_bonemanip", function()
		for EntID, _ in pairs( players_bonemanip ) do
			local ply = Entity( EntID )

			if not IsValid( ply ) or not ply:IsPlayer() then continue end

			local Pod = ply:GetVehicle()
			local vehicle = ply:lvsGetVehicle()

			if not IsValid( Pod ) or not IsValid( vehicle ) then return end

			local BoneManipulate = vehicle:GetPlayerBoneManipulation( ply, Pod:lvsGetPodIndex() )

			for name, ang in pairs( BoneManipulate ) do
				local bone = ply:LookupBone( name )

				if not bone then continue end

				ply:ManipulateBoneAngles( bone, ang )
			end
		end
	end )

	return
end

util.AddNetworkString( "lvs_buildcontrols" )
util.AddNetworkString( "lvs_bonemanip" )

function meta:lvsStartBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( true )
	net.Broadcast()
end

function meta:lvsStopBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( false )
	net.Broadcast()
end

net.Receive( "lvs_buildcontrols", function( len, ply )
	if not IsValid( ply ) then return end

	ply:lvsSetInputDisabled( net.ReadBool() )
end )

function meta:lvsSetInput( name, value )
	if not self._lvsKeyDown then
		self._lvsKeyDown = {}
	end

	self._lvsKeyDown[ name ] = value
end

LVS.TEAMS = {
	[0] = "FRIENDLY TO EVERYONE",
	[1] = "Team 1",
	[2] = "Team 2",
	[3] = "HOSTILE TO EVERYONE",
}

function meta:lvsSetAITeam( nTeam )
	nTeam = nTeam or LVS.PlayerDefaultTeam

	if self:lvsGetAITeam() ~= nTeam then
		self:PrintMessage( HUD_PRINTTALK, "[LVS] Your AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
	end

	self:SetNWInt( "lvsAITeam", nTeam )
end

hook.Add( "PlayerButtonUp", "!!!lvsButtonUp", function( ply, button )
	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, false )
		end
	end
end )

hook.Add( "PlayerButtonDown", "!!!lvsButtonDown", function( ply, button )
	if not ply:lvsGetInputEnabled() then return end

	local vehicle = ply:lvsGetVehicle()
	local vehValid = IsValid( vehicle )

	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, true )

			if not vehValid then continue end

			if string.StartWith( KeyName, "~SELECT~" ) then
				local exp_string = string.Explode( "#", KeyName )
				local base = ply:lvsGetWeaponHandler()

				if exp_string[2] and IsValid( base ) then
					base:SelectWeapon( tonumber( exp_string[2] ) )
				end
			end

			if KeyName == "EXIT" then
				if vehicle:GetDriver() == ply and vehicle:GetlvsLockedStatus() then vehicle:UnLock() end

				if vehicle:GetlvsLockedStatus() then continue end

				ply:ExitVehicle()
			end
		end
	end
end )

hook.Add("CanExitVehicle","!!!lvsCanExitVehicle",function(vehicle,ply)
	if IsValid( ply:lvsGetVehicle() ) then return false end
end)

--addons/lvs_base/lua/lvs_framework/autorun/lvs_soundscripts.lua:

sound.Add( {
	name = "LVS.Physics.Scrape",
	channel = CHAN_STATIC,
	level = 80,
	sound = "lvs/physics/scrape_loop.wav"
} )

sound.Add( {
	name = "LVS.Physics.Wind",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/wind_loop.wav",
} )

sound.Add( {
	name = "LVS.Physics.Water",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/water_loop.wav",
} )

sound.Add( {
	name = "LVS.DYNAMIC_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 110},
	sound = "^lvs/explosion_dist.wav"
} )

sound.Add( {
	name = "LVS.MISSILE_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 120},
	sound = {
		"ambient/levels/streetwar/city_battle17.wav",
		"ambient/levels/streetwar/city_battle18.wav",
		"ambient/levels/streetwar/city_battle19.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/dyn1.wav",
		"^lvs/explosions/dyn2.wav",
		"^lvs/explosions/dyn3.wav",
		"^lvs/explosions/dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/close1.wav",
		"lvs/explosions/close2.wav",
		"lvs/explosions/close3.wav",
		"lvs/explosions/close4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/med_dyn1.wav",
		"^lvs/explosions/med_dyn2.wav",
		"^lvs/explosions/med_dyn3.wav",
		"^lvs/explosions/med_dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/med_close1.wav",
		"lvs/explosions/med_close2.wav",
		"lvs/explosions/med_close3.wav",
		"lvs/explosions/med_close4.wav",
	}
} )


sound.Add( {
	name = "LVS.EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 115,
	pitch = {95, 115},
	sound = "lvs/explosion.wav"
} )

if CLIENT then
	local SoundList = {}

	hook.Add( "EntityEmitSound", "!!!lvs_fps_rape_fixer", function( t )
		if not t.Entity.LVS and not t.Entity._LVS then return end

		local SoundFile = t.SoundName

		if SoundList[ SoundFile ] == true then
			return true

		elseif SoundList[ SoundFile ] == false then
			return false

		else
			local File = string.Replace( SoundFile, "^", "" )

			local Exists = file.Exists( "sound/"..File , "GAME" )

			SoundList[ SoundFile ] = Exists

			if not Exists then
				print("[LVS] '"..SoundFile.."' not found. Soundfile will not be played and is filtered for this game session to avoid fps issues.")
			end
		end
	end )
end

--addons/lvs_base/lua/autorun/lvs_overhaul_config.lua:
-- This is the important stuff for servers

-- Using these settings are recommended to get the best experience for your players that you want

lvs_overhaul_config_open_menu_command 					= "!lvsConfig" -- Set this to whatever you want the command to be to open the config menu, if you dont want to use this file -- Default: !lvsMenu (Caps does not matter)

-- These next ones are for ALL clients, should these be false, the corrisponding feature will be disabled

lvs_overhaul_config_enable_friendly_name_crosshair		= lvs_overhaul_config_enable_friendly_name_crosshair 	or 		true -- Enables players to see friendly target ship pilot/driver name in crosshair -- Default: True
lvs_overhaul_config_enable_friendly_hp_crosshair		= lvs_overhaul_config_enable_friendly_hp_crosshair 	or 		true -- Enables players to see friendly target ship HP in crosshair -- Default: True
lvs_overhaul_config_enable_HUD						 	= lvs_overhaul_config_enable_HUD 						or 		true -- Enables HUD for all people in vehicles -- Default: True
lvs_overhaul_config_enable_voice_interactions		 	= lvs_overhaul_config_enable_voice_interactions 		or 		true -- Enables voice line interaction for all people in vehicles -- Default: True
lvs_overhaul_config_enable_alerts					 	= lvs_overhaul_config_enable_alerts 					or 		true -- Enables alerts/warnings for all people in vehicles -- Default: True
--lvs_overhaul_config_enable_rolling_with_ship			= lvs_overhaul_config_enable_rolling_with_ship 		or 		true -- Enables players camera to roll with vehicle while in it -- Default: True
lvs_overhaul_config_enable_radar					 	= lvs_overhaul_config_enable_radar 					or 		false -- Enables radar for all people in vehicles -- Default: True
lvs_overhaul_config_enable_hp_and_shield				= lvs_overhaul_config_enable_hp_and_shield 			or		true -- Enables health and shield visuals for all people in vehicles -- Default: True
lvs_overhaul_config_enable_hostile_alerts				= lvs_overhaul_config_enable_hostile_alerts 			or 		true -- Enables alerts about number of hostiles targeting player for all people in vehicles -- Default: True

---------------------------------------------------------------------------------------------------------
--addons/lvs_base/lua/autorun/lvs_overhaul_edits.lua:
local cvarShowPlaneIdent = GetConVar("lvs_show_identifier")
local cvarShowNameIndc = CreateClientConVar( "lvs_show_nameindc", 1, true, false)
local cvarShowHPIndc = CreateClientConVar( "lvs_show_hpindc", 1, true, false)
local cvarShowHud = CreateClientConVar( "lvs_show_hud", 1, true, false)
local cvarVoiceIndecs = CreateClientConVar( "lvs_voice_indicators", 1, true, false)
local cvarAlertIndecs = CreateClientConVar( "lvs_alert_indicators", 1, true, false)
--local cvarRollWithShip = CreateClientConVar( "lvs_roll_with_ship", 0, true, false)
local cvarEnableRadar = CreateClientConVar( "lvs_enable_radar", 1, true, false)
local cvarEnableHpShield = CreateClientConVar( "lvs_enable_hp_shield", 1, true, false)
local cvarShowHostileAlert = CreateClientConVar( "lvs_enable_hostile_alert", 1, true, false)
local cvarAlertVolume = CreateClientConVar("LVS_Voice_Alert_Volume", .45, true, false)

local cvarColorThemeR = CreateClientConVar("LVS_Color_ThemeR", 0, true, false)
local cvarColorThemeG = CreateClientConVar("LVS_Color_ThemeG", 255, true, false)
local cvarColorThemeB = CreateClientConVar("LVS_Color_ThemeB", 0, true, false)

----------
local cvarDisabledDamageChanges = CreateConVar("lvs_disable_damage_changes",0,{16384, 32, 128})
local cvarDisabledAdminNotify = CreateConVar("lvs_disable_admin_notify",0,{16384, 32, 128})
local cvarDisabledAdminNotifyAI = CreateConVar("lvs_disable_admin_notify_ai",0,{16384, 32, 128})

----------

local ShowPlaneIdent = cvarShowPlaneIdent and cvarShowPlaneIdent:GetBool() or true
local ShowNameIndc = lvs_overhaul_config_enable_friendly_name_crosshair and cvarShowNameIndc and cvarShowNameIndc:GetBool() or false
local ShowHPIndc = lvs_overhaul_config_enable_friendly_hp_crosshair and cvarShowHPIndc and cvarShowHPIndc:GetBool() or false
local ShowHUD = lvs_overhaul_config_enable_HUD and cvarShowHud and cvarShowHud:GetBool() or false
local VoiceActivate = lvs_overhaul_config_enable_voice_interactions and cvarVoiceIndecs and cvarVoiceIndecs:GetBool() or false
local ShowAlerts = lvs_overhaul_config_enable_alerts and cvarAlertIndecs and cvarAlertIndecs:GetBool() or false
--local AllowRollWithShip = lvs_overhaul_config_enable_rolling_with_ship and cvarRollWithShip and cvarRollWithShip:GetBool() or false
local EnableRadar = lvs_overhaul_config_enable_radar and cvarEnableRadar and cvarEnableRadar:GetBool() or false
local ShowHPAndShield = lvs_overhaul_config_enable_hp_and_shield and cvarEnableHpShield and cvarEnableHpShield:GetBool() or false
local EnableHostileAlert = lvs_overhaul_config_enable_hostile_alerts and cvarShowHostileAlert and cvarShowHostileAlert:GetBool() or false

local radarMat
local randomSoundList = {}

if (SERVER) then
	util.AddNetworkString("LVS_Open_Config_From_Server_Admin")
	util.AddNetworkString("LVS_Toggle_Damage_Reduction")
	util.AddNetworkString("LVS_Toggle_Admin_Notify")
	util.AddNetworkString("LVS_Toggle_Admin_Notify_AI_Only")

	hook.Add("PlayerSay", "LVSConfigOpenConfigMenu", function( ply, text )
		if (string.lower(text) == string.lower(lvs_overhaul_config_open_menu_command)) then
			net.Start("LVS_Open_Config_From_Server_Admin")
			net.Send(ply)
		end
	end)

	hook.Add("Initialize","InitLVSVoiceInteractions", function()
		print("LVS interface edits has been initalized!")
	end)

	hook.Add( "CanEditVariable", "restrict_lvs_ai_edit", function( ent, ply, key, val, editor )
		if (GetConVar("lvs_disable_admin_notify"):GetBool()) then return end
		if (!ent.LVS) then return end
		if (ply:IsAdmin() or ply:IsSuperAdmin()) then return end

		local playerList = player.GetAll()

		local var = editor.title
		local t = editor.type
		ply.lvs_var_currentVal = val
		if (GetConVar("lvs_disable_admin_notify_ai"):GetBool()) then
			if var != "AI" then return end
		end

		for i=1, #playerList do
			if (ply:IsAdmin() or ply:IsSuperAdmin()) then
				if (!ply.isOnChatAlertCoolDown) then
					ply.isOnChatAlertCoolDown = true
					ply.lvs_last_val_changed = val
					local time = .25
					if (t != "Boolean") then
						time = 3
					end
					timer.Simple(time, function()
						if (IsValid(ply)) then
							if (IsValid(ent)) then
								if (ply.lvs_last_val_changed != ply.lvs_var_currentVal or (t == "Boolean")) then
									playerList[i]:ChatPrint(ply:Nick() .. " has just set var: " .. var .. " to value " .. ply.lvs_var_currentVal .. " on an LVS vehicle")
								end
							end
							ply.isOnChatAlertCoolDown = false
						end
					end)
				end
			end
		end
	end )
end

if CLIENT then
	LVS = LVS or {}
	LVS.VehiclesStored = LVS.VehiclesStored or {}

	function LVSChangeConfig_HostileAlert(new)
		lvs_overhaul_config_enable_hostile_alerts = new
	end

	function LVSChangeConfig_HPShield(new)
		lvs_overhaul_config_enable_hp_and_shield = new
	end

	function LVSChangeConfig_Radar(new)
		lvs_overhaul_config_enable_radar = new
	end

	function LVSChangeConfig_Names(new)
		lvs_overhaul_config_enable_friendly_name_crosshair = new
	end

	function LVSChangeConfig_HP(new)
		lvs_overhaul_config_enable_friendly_hp_crosshair = new
	end

	function LVSChangeConfig_HUD(new)
		lvs_overhaul_config_enable_HUD = new
	end

	function LVSChangeConfig_Alerts(new)
		lvs_overhaul_config_enable_alerts = new
	end

	function LVSChangeConfig_VoiceInteractions(new)
		lvs_overhaul_config_enable_voice_interactions = new
	end

	--function LVSChangeConfig_Rolling(new)
		--lvs_overhaul_config_enable_rolling_with_ship = new
	--end

	local propertiesMenuClient = 
	{
		[1] = {name = "Enable Hostile Alert", desc = "Show # of hostiles targeting you in alerts", convar = "lvs_enable_hostile_alert", func = LVSChangeConfig_HostileAlert},
		[2] = {name = "Enable HP/Shield", desc = "See HP and shield bars / values", convar = "lvs_enable_hp_shield", func = LVSChangeConfig_HPShield},
		[3] = {name = "Enable Radar", desc = "See small scale ships in HUD", convar = "lvs_enable_radar", func = LVSChangeConfig_Radar},
		[4] = {name = "Show Names", desc = "See names of friendly vehicle pilots on your crosshair", convar = "lvs_show_nameindc", func = LVSChangeConfig_Names},
		[5] = {name = "Show HP", desc = "See HP of friendly vehicle pilots on your crosshair", convar = "lvs_show_hpindc", func = LVSChangeConfig_HP},
		[6] = {name = "Show HUD", desc = "Enables all HUD based elements,\nsuch as throttle meter, altitude meter, and pitch scroller", convar = "lvs_show_hud", size = 30, func = LVSChangeConfig_HUD},
		[7] = {name = "Show Alerts", desc = "Display important alerts on HUD, not\nlinked with HUD (Most FPS impact)", convar = "lvs_alert_indicators", size = 30, func = LVSChangeConfig_Alerts},
		[8] = {name = "Voice Alerts", desc = "Enable voice indicators for some events", convar = "lvs_voice_indicators", func = LVSChangeConfig_VoiceInteractions},
		--[9] = {name = "Roll with ship", desc = "Allow camera to roll with vehicle roll", convar = "lvs_roll_with_ship", func = LVSChangeConfig_Rolling},
	}

	local whiteCol = Color(200,200,200,255)

	local adminMat = Material( "icon16/shield.png" )
	radarMat = Material( "sprites/radar_base.png" )
	local NextFind = 0
	local nextClean = 0
	local LVS_AllPlanes = {}
	randomSoundList = {
		"npc/attack_helicopter/aheli_damaged_alarm1.wav",
	}

	local alertString = ""
	local alertNum = 0
	local boxX = 100
	local currWidth = 0
	local boxY = 100
	--local radarRotator = 0
	surface.CreateFont( "LVS_FONT", {
		font = "DebugFixed",
		extended = false,
		size = 20,
		weight = 1000,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = true,
		outline = false,
	} )

	surface.CreateFont( "LVS_FONT_PANEL", {
		font = "Arial",
		extended = false,
		size = 16,
		weight = 1000,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = true,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	} )

	surface.CreateFont( "LVS_FONT_RADAR_HEIGHT", {
		font = "Arial",
		extended = false,
		size = 25,
		weight = 1000,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	} )

	local function GetLVSColorTheme()
		return Color(cvarColorThemeR:GetString(),cvarColorThemeG:GetString(),cvarColorThemeB:GetString())
	end

	local function LVSPlaySound(ent, sound)
		ent:EmitSound( Sound(sound), 65, 100, cvarAlertVolume:GetFloat() or .45, CHAN_AUTO )
	end

	local function LVSGetPrimaryAmmo(ent)
		local val = -1

		if (ent.LVS) then
			if (ent.WEAPONS and ent.WEAPONS[1] and ent.WEAPONS[1][1] and ent.WEAPONS[1][1]["_CurAmmo"]) then
				val = ent.WEAPONS[1][1]["_CurAmmo"]
			end
		elseif (ent.LFS) then
			val = ent:GetAmmoPrimary()
		end
		return val
	end

	local function LVSGetSecondaryAmmo(ent)
		local val = -1
		if (ent.LVS) then
			if (ent.WEAPONS and ent.WEAPONS[1] and ent.WEAPONS[1][2] and ent.WEAPONS[1][2]["_CurAmmo"]) then
				val = ent.WEAPONS[1][2]["_CurAmmo"]
			end
		elseif (ent.LFS) then
			val = ent:GetAmmoSecondary()
		end
		return val
	end

	local function LVSContactNotify( ent )
		if !IsValid(ent) or ent == nil then return end
		if not ShowPlaneIdent then return end

		ShowNameIndc = lvs_overhaul_config_enable_friendly_name_crosshair and cvarShowNameIndc and cvarShowNameIndc:GetBool() or false
		ShowHPIndc = lvs_overhaul_config_enable_friendly_hp_crosshair and cvarShowHPIndc and cvarShowHPIndc:GetBool() or false
		ShowHUD = lvs_overhaul_config_enable_HUD and cvarShowHud and cvarShowHud:GetBool() or false
		VoiceActivate = lvs_overhaul_config_enable_voice_interactions and cvarVoiceIndecs and cvarVoiceIndecs:GetBool() or false
		ShowAlerts = lvs_overhaul_config_enable_alerts and cvarAlertIndecs and cvarAlertIndecs:GetBool() or false
		--AllowRollWithShip = lvs_overhaul_config_enable_rolling_with_ship and cvarRollWithShip and cvarRollWithShip:GetBool() or false
		EnableRadar = lvs_overhaul_config_enable_radar and cvarEnableRadar and cvarEnableRadar:GetBool() or false
		ShowHPAndShield = lvs_overhaul_config_enable_hp_and_shield and cvarEnableHpShield and cvarEnableHpShield:GetBool() or false
		EnableHostileAlert = lvs_overhaul_config_enable_hostile_alerts and cvarShowHostileAlert and cvarShowHostileAlert:GetBool() or false
		 
		local MyPos = ent:GetPos()
		local MyTeam = ent:GetAITEAM()

		-- Lets initalize some vars!

		if (ent.lvs_shield_alert == nil or ent.lvs_shield_charging == nil or ent.lvs_ammoNotifyPrimary == nil or ent.lvs_ammoNotifySecondary == nil or ent.lvs_healthCritialNotify == nil or ent.lvs_health_0_notify == nil) then
			ent.lvs_shield_alert = true
			ent.lvs_shield_charging = true
			ent.lvs_ammoNotifyPrimary = true
			ent.lvs_ammoNotifySecondary = true
			ent.lvs_healthCritialNotify = true
			ent.lvs_health_0_notify = true
		end

		if (ent.lvs_initalActivation == nil) then
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/voice_on.wav")
			end
			ent.lvs_initalActivation = false
		end

		if (ent.lvs_notify_contacts == nil or ent.lvs_speak_cooldown == nil) then
			ent.lvs_speak_cooldown = false
			ent.lvs_notify_contacts = {}
		end
		if NextFind < CurTime() then
			NextFind = CurTime() + 3
			LVS_AllPlanes = LVS:GetVehicles()
		end

		----------------------------

		-- SHIELD NOTIFICATIONS
		if (ent:GetShield() == 0 and ent.lvs_shield_charging and ent.MaxShield != 0) then
			ent.lvs_shield_alert = false
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/armor_gone.wav")
			end
			ent.lvs_shield_charging = false
			ent.lvs_shield_text = true
		end

		if (!ent.lvs_shield_alert) then
			if (ent:GetShield() == ent.MaxShield) then
				if (VoiceActivate) then
					LVSlaySound(ent, "HL1/fvox/power_restored.wav")
				end
				ent.lvs_shield_alert = true
			end
			if (ent:GetShield() > 0 and !ent.lvs_shield_charging) then
				ent.lvs_shield_charging = true
				ent.lvs_shield_text = false
			end
		end

		----------------------------

		-- AMMO NOTIFICATIONS

		if (LVSGetPrimaryAmmo(ent) == 0 and ent.lvs_ammoNotifyPrimary) then
			ent.lvs_ammoNotifyPrimary = false
			ent.lvs_ammoPrimary_text = true
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/ammo_depleted.wav")
			end
		end

		if (!ent.lvs_ammoNotifyPrimary) then
			if (LVSGetPrimaryAmmo(ent) > 0) then
				if (VoiceActivate) then
					LVSPlaySound(ent, "items/ammo_pickup")
				end
				ent.lvs_ammoNotifyPrimary = true
				ent.lvs_ammoPrimary_text = false
			end
		end

		if (LVSGetSecondaryAmmo(ent) == 0 and ent.lvs_ammoNotifySecondary) then
			ent.lvs_ammoNotifySecondary = false
			ent.lvs_ammoSecondary_text = true
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/ammo_depleted.wav")
			end
		end

		if (!ent.lvs_ammoNotifySecondary) then
			if (LVSGetSecondaryAmmo(ent) > 0) then
				if (VoiceActivate) then
					LVSPlaySound(ent, "items/ammo_pickup.wav")
				end
				ent.lvs_ammoNotifySecondary = true
				ent.lvs_ammoSecondary_text = false
			end
		end

		----------------------------

		-- HEALTH NOTIFICATIONS

		if (ent:GetHP() <= ent:GetMaxHP() / 2 and ent.lvs_healthCritialNotify) then
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/health_dropping.wav")
			end
			ent.lvs_health_text = true
			timer.Simple(3.5, function()
				if (IsValid(ent)) then
					local hpPercent = math.Round(math.Remap(ent:GetHP(),0,ent:GetMaxHP(),0,100) / 10) * 10
					local sound = "HL1/fvox/fifty.wav"
					local vol = 1
					if (VoiceActivate) then
						if (hpPercent <= 40) then
							sound = "HL1/fvox/fourty.wav"
							vol = .8
						end
						if (hpPercent <= 30) then
							sound = "HL1/fvox/thirty.wav"
						end
						if (hpPercent <= 20) then
							sound = "HL1/fvox/twenty.wav"
						end
						if (hpPercent <= 10) then
							sound = "HL1/fvox/ten.wav"
						end
						if (hpPercent > 40 and hpPercent < 50) then
							sound = "HL1/fvox/fifty.wav"
						end
						LVSPlaySound(ent, sound)
						timer.Simple(1, function()
							if (IsValid(ent)) then
								LVSPlaySound(ent, "HL1/fvox/percent.wav")
							end
						end)
					end
				end
			end)
			ent.lvs_healthCritialNotify = false
		end

		if (!ent.lvs_healthCritialNotify) then
			if (ent:GetHP() > ent:GetMaxHP() / 2) then
				if (VoiceActivate) then
					LVSPlaySound(ent, "HL1/fvox/medical_repaired.wav")
				end
				ent.lvs_healthCritialNotify = true
				ent.lvs_health_text = false
			end
		end

		if (ent:GetHP() == 0 and ent.lvs_health_0_notify) then
			if (VoiceActivate) then
				LVSPlaySound(ent, "HL1/fvox/health_critical.wav")
				timer.Simple(3.5, function()
					if (IsValid(ent)) then
						LVSPlaySound(ent, "HL1/fvox/evacuate_area.wav")
					end
				end)
			end
			ent.lvs_health_0_notify = false
		end

		if (!ent.lvs_health_0_notify) then
			if (ent:GetHP() > 0) then
				ent.lvs_health_0_notify = true
			end
		end

		local aimVector = 0
		local entVector = 0
		local angCos = 0
		local rPos = 0
		local screen_pos = 0
		local Size = 60
		local Dist = 0

		-- Crosshair changes
		for _, v in pairs( LVS_AllPlanes ) do
			if IsValid( v ) then
				if v ~= ent and (ent.LVS or ent.LFS) then
					if isvector( v:GetPos() ) then

						rPos = v:GetPos()
						screen_pos = rPos:ToScreen()
						Dist = (MyPos - rPos):Length()
						if (v:GetAITEAM() != MyTeam) then
							if (v:GetEngineActive()) then
								if (!table.HasValue(ent.lvs_notify_contacts,v)) then
									table.insert(ent.lvs_notify_contacts,v)
									if (!ent.lvs_speak_cooldown) then
										local s = Sound( randomSoundList[math.random(1,#randomSoundList)] )
										LVSPlaySound(ent, s)
										ent.lvs_speak_cooldown = true
										timer.Simple(3, function()
											if (IsValid(ent)) then
												ent.lvs_speak_cooldown = false
											end
										end)
									end
								end
							end
						end
						if Dist < 9850 then
							local Alpha = math.max(255 - Dist * 0.015,0) 
							local Team = v:GetAITEAM()
							surface.SetDrawColor(0, 127, 255, Alpha)
							if Team == 0 then
								surface.SetDrawColor( 255, 150, 0, Alpha )
								surface.SetMaterial(Material("sprites/team_0_square.png"))
							else
								if Team ~= MyTeam then
									surface.SetMaterial(Material("sprites/hostile_square.png"))
									surface.SetDrawColor( 255, 0, 0, Alpha )
								else
									surface.SetMaterial(Material("sprites/friendly_square.png"))
									local yPos = 1
									if (ShowNameIndc) then
										if (v:GetDriver()) then
											surface.SetFont( "LVS_FONT" )
											surface.SetTextColor( 0, 127, 255, Alpha )
											surface.SetTextPos( screen_pos.x + Size * 1.1, screen_pos.y - Size ) 
											if (v:GetDriver():IsPlayer()) then
												surface.DrawText(v:GetDriver():Nick())
											else
												if (v:GetAI()) then
													surface.DrawText("Automated Flight System")
												end
											end
											yPos = yPos - .5
										end
										if (v.lfsRepairDroid) then
											surface.DrawText("Repair Droid")
										end
									end
									if (ShowHPIndc) then
										if (v:GetDriver()) then
											surface.SetFont( "LVS_FONT" )
											surface.SetTextPos( screen_pos.x + Size * 1.1, screen_pos.y - Size * yPos ) 

											if (v:GetDriver():IsPlayer()) then
												local hp = math.Round(v:GetHP(),0)
												surface.DrawText("HP: " .. hp .. "/" .. v:GetMaxHP())
											else
												if (v:GetAI()) then
													local hp = math.Round(v:GetHP(),0)
													surface.DrawText("HP: " .. hp .. "/" .. v:GetMaxHP())
												end
											end
											yPos = yPos - .5
										end
									end
								end
							end

							aimVector = ent:GetForward()
							entVector = (v:GetPos() - LocalPlayer():GetPos()):GetNormalized()
							angCos = aimVector:Dot(entVector)

							if (angCos >= .985 and AICanSee(ent, v)) then
								local dist = ent:GetPos():Distance(v:GetPos())
								local actualDist = math.Round(dist / 39.37,1)
								draw.DrawText(actualDist .. "m","LVS_FONT",screen_pos.x - Size - 5,screen_pos.y + Size - draw.GetFontHeight("LVS_FONT"),(Team == MyTeam and Color(0,127,255,Alpha)) or (Team == 0 and Color( 255, 150, 0, Alpha )) or Color( 255, 0, 0, Alpha ),TEXT_ALIGN_RIGHT)
								surface.DrawTexturedRectRotated( screen_pos.x, screen_pos.y, Size * 2 , Size * 2, CurTime() * 75)
							end
						end
					end
				end
			end
		end
		-----------------------------------
	end

	function LVS_ToMeters(num)
		return math.Round(num / 39.37,1)
	end

	local function DrawAltitudeMeter(ply, ent)
		if (true) then
			local altitudePos = Vector(225,-350,0)
			local altW = 30
			local altH = 200

			local trFromShip = util.TraceLine( {
				start = ent:GetPos(),
				endpos = ent:GetPos() + Vector(0,0,-1000000000),
				filter = function( e ) if ( e == Entity(0) ) then return false end end
			} )

			local trFromGround = util.TraceLine( {
				start = trFromShip.HitPos,
				endpos = trFromShip.HitPos + Vector(0,0,1000000000),
				filter = function( e ) if ( e != Entity(0) ) then return false end end
			} )

			local height = ent:GetPos().z - trFromShip.HitPos.z

			local max = trFromGround.HitPos.z - trFromShip.HitPos.z

			local scaledAlt = (height / (max / altH))

			surface.SetDrawColor(GetLVSColorTheme())
			surface.SetMaterial(Material("sprites/pitch_meter.png"))
			surface.DrawTexturedRect(altitudePos.x,altitudePos.y,altW,altH)

			local matSize = 20

			surface.SetMaterial(Material("sprites/altitude_triangle.png"))
			local realY = altitudePos.y - scaledAlt + altH - matSize / 2
			surface.SetTextPos(altitudePos.x + altW + 30,realY)

			surface.SetTextColor(GetLVSColorTheme())
			surface.SetFont("LVS_FONT")
			surface.DrawText("ALT: " .. LVS_ToMeters(height) .. "m")
			surface.DrawTexturedRect(altitudePos.x + altW, realY,matSize,matSize)
		end
	end

	local function DrawThrottleMeter(ply, ent)
		if (true) then
			local throttlePos = Vector(-250,-350,0)
			local throttleW = 30
			local throttleH = 200

			surface.SetDrawColor(GetLVSColorTheme())
			surface.SetMaterial(Material("sprites/altitude_meter.png"))
			surface.DrawTexturedRect(throttlePos.x,throttlePos.y,throttleW,throttleH)

			local matSize = 20
			local throttle = 0
			local throttle_text = "NA"
			local posThrot = 0
			if (ent.LVS) then
				if (ent.GetThrottle) then
					local raw_throttle = ent:GetThrottle()
					local max_throttle = 1
					throttle = math.Round(raw_throttle / max_throttle * 100)
					posThrot = throttle
					if (throttle > 100) then
						posThrot = 100
					end
					throttle_text = throttle
				end
			elseif (ent.LFS) then
				if (ent.GetThrottlePercent) then
					local throttle = ent:GetThrottlePercent()
					posThrot = throttle
					if (throttle > 100) then
						posThrot = 100
					end
					throttle_text = throttle
				end
			end
			local realThrottle = throttlePos.y - (posThrot / (100 / throttleH)) + throttleH - matSize / 2

			surface.SetMaterial(Material("sprites/pitch_triangle.png"))
	
			draw.DrawText("THROTTLE: " .. throttle_text .. "%","LVS_FONT",throttlePos.x - throttleW,realThrottle,throttle <= 100 and GetLVSColorTheme() or Color(255,0,0,255),TEXT_ALIGN_RIGHT)
			surface.DrawTexturedRect(throttlePos.x - matSize, realThrottle,matSize,matSize)
		end
	end

	local function DrawAmmoMeter(ply, ent)
		if (true) then
			local primaryAmmoPos = Vector(-250,-380,0)
			local primary = LVSGetPrimaryAmmo(ent) or 0
			local secondary = LVSGetSecondaryAmmo(ent) or 0
			draw.DrawText("AMMO PRI: " .. primary,"LVS_FONT",primaryAmmoPos.x,primaryAmmoPos.y,GetLVSColorTheme(),TEXT_ALIGN_LEFT)

			local secondaryAmmoPos = Vector(255,-380,0)
			draw.DrawText("AMMO SEC: " .. secondary,"LVS_FONT",secondaryAmmoPos.x,secondaryAmmoPos.y,GetLVSColorTheme(),TEXT_ALIGN_RIGHT)
		end
	end

	local function DrawPitchScroller(ply, ent)
		if (true) then

			local pitchBarPos = Vector(0,-350,0)
			local ang = ent:GetAngles()

			if (ang.x >= -20 and ang.x <= 20) then
				local p = (pitchBarPos.y - ang.x * 16) + 100
				surface.SetDrawColor(GetLVSColorTheme())
				draw.DrawText("0°","LVS_FONT",pitchBarPos.x - 100,p - 25,GetLVSColorTheme(),TEXT_ALIGN_RIGHT)
				draw.DrawText("0°","LVS_FONT",pitchBarPos.x + 100,p - 25,GetLVSColorTheme(),TEXT_ALIGN_RIGHT)
				surface.DrawRect(pitchBarPos.x - 150,p,100,3)
				surface.DrawRect(pitchBarPos.x + 50,p,100,3)

				surface.DrawRect(pitchBarPos.x - 75,p + 50,50,3)
				surface.DrawRect(pitchBarPos.x + 25,p + 50,50,3)

				surface.DrawRect(pitchBarPos.x - 75,p - 50,50,3)
				surface.DrawRect(pitchBarPos.x + 25,p - 50,50,3)
			end

			if !((ang.x >= -20 and ang.x <= 20)) then
				local p = (pitchBarPos.y - ang.x * 16) + 100
				local txt = "20"
				surface.SetDrawColor(GetLVSColorTheme())
				if (ang.x < -20 and ang.x > -60) then
					txt = "40"
					p = (pitchBarPos.y - (ang.x + 40) * 16) + 100
				elseif (ang.x <= -60) then
					txt = "80"
					p = (pitchBarPos.y - (ang.x + 80) * 16) + 100
				end
				if (ang.x > 20 and ang.x <= 60) then
					txt = "-40"
					p = (pitchBarPos.y - (ang.x - 40) * 16) + 100
				elseif (ang.x > 60) then
					txt = "-80"
					p = (pitchBarPos.y - (ang.x - 80) * 16) + 100
				end

				draw.DrawText(txt .. "°","LVS_FONT",pitchBarPos.x - 100,p - 25,GetLVSColorTheme(),TEXT_ALIGN_RIGHT)
				draw.DrawText(txt .. "°","LVS_FONT",pitchBarPos.x + 100,p - 25,GetLVSColorTheme(),TEXT_ALIGN_RIGHT)
				surface.DrawRect(pitchBarPos.x - 150,p,100,3)
				surface.DrawRect(pitchBarPos.x + 50,p,100,3)

				surface.DrawRect(pitchBarPos.x - 75,p + 50,50,3)
				surface.DrawRect(pitchBarPos.x + 25,p + 50,50,3)

				surface.DrawRect(pitchBarPos.x - 75,p - 50,50,3)
				surface.DrawRect(pitchBarPos.x + 25,p - 50,50,3)
			end
		end
	end

	local function AddAlert(alert, boxSize)
		alertString = alertString .. "     -" .. alert .. "\n"
		alertNum = alertNum + 1
		boxX = math.max(boxX, boxSize)
	end

	local function DrawAlertPopup(ply, ent)
		if (!ply:GetVehicle():GetThirdPersonMode()) then
			local rPos = LocalPlayer():GetPos() + LocalPlayer():GetForward() * 100 + LocalPlayer():GetRight() * - 75 + LocalPlayer():GetUp() * 60
			local Pos = Vector(-400,-650,0)
			alertString = ""
			alertNum = 0
			if (ent.lvs_anyAlert == nil) then
				ent.lvs_anyAlert = false
			end

			if (ent.lvs_health_text == nil) then
				ent.lvs_health_text = false
			end
			if (ent.lvs_shield_text == nil) then
				ent.lvs_shield_text = false
			end
			if (ent.lvs_ammoPrimary_text == nil) then
				ent.lvs_ammoPrimary_text = false
			end
			if (ent.lvs_ammoSecondary_text == nil) then
				ent.lvs_ammoSecondary_text = false
			end

			if (ent.lvs_shield_text) then
				AddAlert("Warning, shields depleted", 320)
			end

			if (ent.lvs_health_text) then
				local hpPercent = math.Round(math.Remap(ent:GetHP(),0,ent:GetMaxHP(),0,100))
				AddAlert("Warning, health low -- " .. hpPercent .. "%", 400)
			end

			if (ent.lvs_ammoPrimary_text) then
				AddAlert("Warning, primary ammo depleted", 400)
			end

			if (ent.lvs_ammoSecondary_text) then
				AddAlert("Warning, secondary ammo depleted", 400)
			end

			if (ent.lvs_hostile_alert and EnableHostileAlert) then
				local num = #ent.lvs_notify_ai_target
				local h = "hostiles"
				if (num == 1) then
					h = "hostile"
				end
				AddAlert("You currently have " .. num .. " " .. h .. " targeting you", 500)
			end

			if (alertNum > 0) then
				ent.lvs_anyAlert = true
			else
				if (ent.lvs_anyAlert) then
					ent.lvs_anyAlert = false
					ent.lvs_animation_finished = false
				end
				if (currWidth > 0) then
					local h = draw.GetFontHeight("LVS_FONT")
					surface.SetDrawColor(25,25,25,255)
					surface.DrawRect(Pos.x - 15, Pos.y - 10, 5, 50 + boxY)
					surface.DrawRect(Pos.x - 10 + boxX, Pos.y - 10, 5, 50 + boxY)
					local reps = 1
					surface.SetDrawColor(50,50,50,200)
					currWidth = math.Approach(currWidth,0, (FrameTime() * boxX / reps))
					surface.DrawRect(Pos.x - 10, Pos.y - 10, currWidth, 50 + boxY)
					surface.DrawRect(Pos.x + boxX - currWidth - 10, Pos.y - 10, currWidth, 50 + boxY)
				else
					boxX = 0
				end
			end

			if (ent.lvs_animation_finished == nil) then
				ent.lvs_animation_finished = false
			end

			if (ent.lvs_anyAlert) then
				local h = draw.GetFontHeight("LVS_FONT")
				surface.SetDrawColor(25,25,25,255)
				boxY = (alertNum * h)
				surface.DrawRect(Pos.x - 15, Pos.y - 10, 5, 50 + boxY)
				surface.DrawRect(Pos.x - 10 + boxX, Pos.y - 10, 5, 50 + boxY)
				if (!ent.lvs_animation_finished) then
					local reps = 1
					currWidth = math.Approach(currWidth,boxX / 2, (FrameTime() * boxX / reps))
					surface.DrawRect(Pos.x - 10, Pos.y - 10, currWidth, 50 + boxY)
					surface.DrawRect(Pos.x + boxX - currWidth - 10, Pos.y - 10, currWidth, 50 + boxY)
					if (currWidth >= boxX / 2) then
						ent.lvs_animation_finished = true
					end
				end
				if (ent.lvs_animation_finished) then
					surface.SetDrawColor(50,50,50,200)
					surface.DrawRect(Pos.x - 10, Pos.y - 10, boxX, 50 + boxY)

					surface.SetTextColor(238,210,2,200)
					surface.SetFont("ALVS_FONT")
					surface.SetTextPos(Pos.x,Pos.y)
					surface.DrawText("! ALERT !")
					draw.DrawText(alertString,"LVS_FONT",Pos.x,Pos.y + 30,GetLVSColorTheme(),TEXT_ALIGN_LEFT)
					ent.lvs_animation_finished = true
				end
			end

		else
			ent.lvs_anyAlert = false
			ent.lvs_animation_finished = false
			currWidth = 0
		end
	end

	local function DrawHealthAndShield(ply, ent)
		if (true) then
			local shieldPos = Vector(0,-20,0)
			local barWidth = 250
			local barHeight = 6
			local shield = ent:GetShield()
			local maxShield = ent.MaxShield

			if (maxShield != 0) then
				local scaledShield = math.Remap(shield,0,ent.MaxShield,0,barWidth)
				local offSet = (barWidth - scaledShield)
				surface.SetDrawColor(0,255,255,255)
				surface.DrawRect(shieldPos.x + (offSet / 2) - (barWidth / 2),shieldPos.y,scaledShield,barHeight)
			else
				barHeight = 6
				shieldPos = Vector(0,-20 - barHeight,0)
			end

			local hp = ent:GetHP()

			local scaledHP = math.Remap(hp,0,ent:GetMaxHP(),0,barWidth)
			local offSetHp = (barWidth - scaledHP)
			surface.SetDrawColor(255,0,0,255)
			surface.DrawRect(shieldPos.x + (offSetHp / 2) - (barWidth / 2),shieldPos.y + barHeight,scaledHP,barHeight)


			local hpPos = Vector(-250,-140,0)

			draw.DrawText("HP: " .. math.Round(hp,0) .. "/" .. ent:GetMaxHP(),"LVS_FONT",hpPos.x,hpPos.y,GetLVSColorTheme(),TEXT_ALIGN_CENTER)

			local shieldPos2 = Vector(255,-140,0)
			draw.DrawText("SHIELD: " .. math.Round(shield,0) .. "/" .. ent.MaxShield,"LVS_FONT",shieldPos2.x,shieldPos2.y,GetLVSColorTheme(),TEXT_ALIGN_CENTER)
		end
	end

	local function CleanUpShipModel(entity)
		if (!entity.LVS or !entity.LFS) then return end
		if (entity.radar_models == nil) then return end
		for i=1,#entity.radar_models do
			local e = entity.radar_models[i]
			if (IsValid(e)) then
				if (!IsValid(e.ship)) then
					SafeRemoveEntityDelayed(e,0)
				end
			end
		end

		for i=1,#entity.radar_models do
			local m = entity.radar_models[i]
			if (!IsValid(m)) then
				table.remove(entity.radar_models,i)
			end
		end
	end

	function AITargetInFront(self, ent, range )
		if not IsValid( ent ) then return false end
		if not range then range = 45 end

		if range >= 180 then return true end

		local DirToTarget = (ent:GetPos() - self:GetPos()):GetNormalized()

		local InFront = math.deg( math.acos( math.Clamp( self:GetForward():Dot( DirToTarget ) ,-1,1) ) ) < range

		return InFront
	end

	function AICanSee(self, otherEnt )
		if not IsValid( otherEnt ) then return false end

		local trace = {
			start = self:LocalToWorld( self:OBBCenter() ),
			endpos = otherEnt:LocalToWorld( otherEnt:OBBCenter() ),
			filter = self:GetCrosshairFilterEnts(),
		}

		return util.TraceLine( trace ).Entity == otherEnt
	end


	local function AIGetTarget(self)

		if (self._lvsNextAICheck or 0) > CurTime() then return self._LastAITarget end

		self._lvsNextAICheck = CurTime() + 2
		
		local MyPos = self:GetPos()
		local MyTeam = self:GetAITEAM()

		if MyTeam == 0 then self._LastAITarget = NULL return NULL end

		local ClosestTarget = NULL
		local TargetDistance = 60000

		local ignore = false
		if (LVS) then
			ignore = LVS.IgnorePlayers
		elseif (LFS) then
			ignore = LFS.IgnorePlayers
		end

		if not ignore then
			for _, ply in pairs( player.GetAll() ) do
				if not ply:Alive() then continue end

				if ply:IsFlagSet( FL_NOTARGET ) then continue end

				local Dist = (ply:GetPos() - MyPos):Length()

				if Dist > TargetDistance then continue end

				local Veh = ply:lvsGetVehicle()

				if IsValid( Veh ) then
					if AICanSee(self, Veh ) and Veh ~= self then
						local HisTeam = Veh:GetAITEAM()

						if HisTeam == 0 then continue end

						if self.AISearchCone then
							if not AITargetInFront( self, Veh, self.AISearchCone ) then continue end
						end

						if HisTeam ~= MyTeam or HisTeam == 3 then
							ClosestTarget = Veh
							self._LastAITarget = ClosestTarget
							return Veh
						end
					end
				else
					local HisTeam = ply:lvsGetAITeam()
					if not ply:IsLineOfSightClear( self ) or HisTeam == 0 then continue end

					if self.AISearchCone then
						if not AITargetInFront(self, ply, self.AISearchCone ) then continue end
					end
					
					if HisTeam ~= MyTeam or HisTeam == 3 then
						ClosestTarget = ply
						self._LastAITarget = ClosestTarget
						return ply
					end
				end
			end
		end

		for _, veh in pairs(LVS_AllPlanes) do
			if veh:GetHP() ==0 then continue end

			if veh == self then continue end

			local Dist = (veh:GetPos() - MyPos):Length()

			if Dist > TargetDistance or not AITargetInFront(self, veh, (viewcone or 100) ) then continue end

			local HisTeam = veh:GetAITEAM()

			if HisTeam == 0 then continue end

			if HisTeam == self:GetAITEAM() then
				if HisTeam ~= 3 then continue end
			end

			if self.AISearchCone then
				if not AITargetInFront(self, veh, self.AISearchCone ) then continue end
			end

			if AICanSee(self, veh ) then
				ClosestTarget = veh
				self._LastAITarget = ClosestTarget
				return veh
			end
		end

		self._LastAITarget = ClosestTarget
		
		return ClosestTarget
	end


	local function DrawRadar(ply, ent, pos)
		local radarPos = Vector(0,-200,0)
		if (ent.lvs_notify_ai_target == nil or ent.lvs_hostile_alert == nil) then
			ent.lvs_notify_ai_target = {}
			ent.lvs_hostile_alert = false
		end
		ent.radar_models = ent.radar_models or {}
		surface.SetDrawColor(GetLVSColorTheme())
		surface.SetMaterial(radarMat)
		
		local matSize = 300

		surface.DrawTexturedRect(radarPos.x - (matSize / 2), radarPos.y,matSize,matSize)

		surface.DrawTexturedRect(radarPos.x - (matSize / 3), radarPos.y + (matSize /  6),matSize / 1.5,matSize / 1.5)

		surface.DrawTexturedRect(radarPos.x - (matSize / 2.3), radarPos.y + (matSize /  15),matSize / 1.15,matSize / 1.15)

		surface.DrawTexturedRect(radarPos.x - (matSize / 8), radarPos.y + (matSize / 2.75),matSize / 4,matSize / 4)

		local pos2 = ent:GetPos()
		local dist = 10000
		local entList = ents.FindInSphere(pos2,dist)

		local div = (dist / matSize)^2 / 1.5
		local teamColor = Color(0,127,255,255)
		local radarList = {}

		if (ent.updateTargetAlert == nil) then
			ent.updateTargetAlert = true
		end

		if (ent.updateTargetAlert and EnableHostileAlert) then

			if (#ent.lvs_notify_ai_target == 0) then
				ent.lvs_hostile_alert = false
			end
			for i=1,#ent.lvs_notify_ai_target do
				if (!IsValid(ent.lvs_notify_ai_target[i])) then
					table.remove(ent.lvs_notify_ai_target,i)
				end
			end

			ent.updateTargetAlert = false
			timer.Simple(1, function()
				if (IsValid(ent)) then
					ent.updateTargetAlert = true
				end
			end)
		end
		for i=1,#LVS_AllPlanes do
			local v = LVS_AllPlanes[i]
			if IsValid(v) and v != ent then
				if (EnableHostileAlert) then
					if (v.updateTargetFinder == nil) then
						v.updateTargetFinder = true
					end
					if (v != ent and v.updateTargetFinder and v:GetAITEAM() != ent:GetAITEAM() and v:GetAI()) then
						local target = AIGetTarget(v)
						if (target == ent:GetDriver() or target == ent) then
							if (!table.HasValue(ent.lvs_notify_ai_target,v)) then
								table.insert(ent.lvs_notify_ai_target,v)
								ent.lvs_hostile_alert = true
							end
						else
							if (table.HasValue(ent.lvs_notify_ai_target,v)) then
								table.RemoveByValue(ent.lvs_notify_ai_target,v)
							end
						end
						v.updateTargetFinder = false
						timer.Simple(1, function()
							if (IsValid(v)) then
								v.updateTargetFinder = true
							end
						end)
					end
				end

				local dist = (ent:GetPos() - v:GetPos()):Length2D()
				if (dist < 10000) then

					teamColor = Color(0,127,255,255)
					local model = v.MDL or v:GetModel()
					if (v:GetClass() == "acclamator_spawner_ai") then
						model = "models/acclamator/syphadias/acclamator.mdl"
					end
					if (v:GetClass() == "munificent_spawner_ai") then
						model = "models/munificent/syphadias/munificent.mdl"
					end
					if (v.lfsRepairDroid) then
						if (IsValid(v:GetParent()) and v:GetParent() != nil) then
							model = v:GetParent():GetModel()
						end
					end

					if (model == nil or model == "") then
						model = "models/Combine_Helicopter/helicopter_bomb01.mdl"
					end
					local shipProp = nil
					for i=1,#ent.radar_models do
						local sp = ent.radar_models[i]
						if (sp.ship == v and sp.ent == ent) then
							shipProp = sp
						end
					end
					if (!IsValid(shipProp) or shipProp == nil) then
						util.PrecacheModel(model)
						shipProp = ClientsideModel( model, RENDERGROUP_TRANSLUCENT )
						shipProp:SetCollisionGroup(10)
						shipProp.ship = v
						shipProp.ent = ent
						table.insert(ent.radar_models,shipProp)
					end
					if (IsValid(shipProp) and shipProp != nil) then
						--local midPos = (pos + ent:GetForward() * .75)
						--local actualPos = midPos + entPos / div
						--local entPos = (v:GetPos() - ent:GetPos())
						local midPos = (pos + ent:GetForward() * .75)

						local entPos = (v:GetPos() - midPos)

						local actualPos = midPos + entPos

						
						if (v != ent) then

							local textPos = (actualPos)

							if (v.lfsRepairDroid) then
								textPos = ((pos + ent:GetForward() * 1.5) + entPos / div)
							end
							local startPos = textPos

							local endPos = textPos

							--render.DrawLine(startPos,endPos,Color(0,255,0,255), false)

							local ang = ent:GetAngles()

							actualPos.x = math.Clamp(actualPos.x - midPos.x,-1.75,1.75) + midPos.x
							actualPos.y = math.Clamp(actualPos.y - midPos.y,-1.75,1.75) + midPos.y

							local pos = Vector(0,0,0)


							local worldVec = (WorldToLocal(v:GetPos(), v:GetAngles(), ent:GetPos(), ent:GetAngles())) / div / 2
							actualPos = LocalToWorld(worldVec,ent:GetAngles(),midPos,ent:GetAngles())

							cam.Start3D2D(midPos, ang, 1)
								local endSecondPos = Vector(worldVec.x ,-worldVec.y,worldVec.z)
								local firstStart = Vector(0,0,0)
								local firstEnd = Vector(worldVec.x ,-worldVec.y,0)
								render.DrawLine(firstStart,firstEnd,whiteCol)
								render.DrawLine(firstEnd,endSecondPos,whiteCol)

							cam.End3D2D()
						end

						if (v:GetAITEAM() != ent:GetAITEAM()) then
							teamColor = Color(255,0,0,255)
						end
						teamColor.a = ((v:GetHP() / v:GetMaxHP() ) * 255 / 10)

						shipProp:SetLOD(3)

						shipProp:SetModelScale(1 / (v:GetModelScale()) / div)
						shipProp:SetMaterial("models/wireframe", true)
						shipProp:SetRenderMode( RENDERMODE_TRANSALPHA )
						shipProp:SetColor(teamColor)
						shipProp:SetPos(actualPos)

						if (v.lfsRepairDroid) then
							shipProp:SetModelScale(v:GetModelScale() / div * 4)
							shipProp:Spawn()
							shipProp:SetAngles(v:GetParent():GetAngles())
							CleanUpShipModel(ent)
						else
							shipProp:Spawn()
							shipProp:SetAngles(v:GetAngles())

							CleanUpShipModel(ent)
						end
					end
				end
			end
		end
	end

	local function CleanUpModels(entity)
		if (!entity.LVS and !entity.LFS) then return end
		if (entity.radar_models == nil) then return end
		local temp_remove = {}
		for i=1,#entity.radar_models do
			local e = entity.radar_models[i]
			if (!IsValid(e) or e == nil) then continue end
			if (e.ship == entity or e.ent == entity) then
				SafeRemoveEntityDelayed(e,0)
				table.insert(temp_remove, i)
			end
		end


		for i=1,#temp_remove do
			table.remove(entity.radar_models,temp_remove[i])
		end
		entity.radar_models = {}
	end



	hook.Add("EntityRemoved","LVSOverHaulRadarCleanup", function(entity)
		CleanUpModels(entity)
	end)

	hook.Add( "HUDPaint", "!!!!!LVS_hud_interface", function()
		local ply = LocalPlayer()

		local ang = LocalPlayer():EyeAngles()
		local pos = Vector(0,0,0)
		
		if ply:GetViewEntity() ~= ply then return end

		if (LocalPlayer().GetVehicle and LocalPlayer():GetVehicle():IsValid()) then
			local Parent = LocalPlayer():GetVehicle()
			if !IsValid(Parent) or Parent == nil then return end
			local ent = Parent.LVSBaseEnt
			if !IsValid(ent) or ent == nil then
				ent = Parent.LFSBaseEnt
			end

			if (!IsValid(ent) or ent == nil) then return end

			LVSContactNotify( ent )
		end

	end)

	hook.Add("PostDrawTranslucentRenderables","!!!LVS_HUD_Draw", function(drawDepth, skybox)
		local ply = LocalPlayer()
		if (ply:Alive() and ply != nil) then
			if (nextClean < CurTime()) then
				for _, v in pairs( LVS:GetVehicles() ) do
					CleanUpModels(v)
				end
				nextClean = CurTime() + 2
			end

			if (ply.GetVehicle and ply:GetVehicle():IsValid()) then
				local Parent = ply:GetVehicle()
				if !IsValid(Parent) or Parent == nil then return end
				local ent = Parent.LVSBaseEnt
				if !IsValid(ent) or ent == nil then
					ent = Parent.LFSBaseEnt
				end

				if (!IsValid(ent) or ent == nil) then return end
				local ang = ent:GetAngles()

				local pos = ply:GetPos() + ent:GetForward() * 10 + ent:GetUp() * 22.5
				ang:RotateAroundAxis( ang:Forward(), 90 )
				ang:RotateAroundAxis( ang:Right(), 90 )

				cam.Start3D2D(pos, ang , .015)

					if (ShowHPAndShield) then
						DrawHealthAndShield(ply,ent)
					end

					if (ShowHUD) then
						DrawAltitudeMeter(ply, ent)
						DrawThrottleMeter(ply, ent)
						DrawPitchScroller(ply, ent)
						DrawAmmoMeter(ply,ent)
					end
					if (ShowAlerts) then
						DrawAlertPopup(ply, ent)
					end
				 
				cam.End3D2D()

				if (EnableRadar) then
					pos = pos + ent:GetForward() * 3

					cam.Start3D2D(pos, ang + Angle(0,0,-90), .015)

						DrawRadar(ply, ent, pos)
					 
					cam.End3D2D()
				end
			end

		end
	end)

	-- THIS IS A COPY OF THE LVS FUNCTIONS
	-- I have inserted this here so that players can still use only LFS and get the same results as if they were to use LVS for entity lists
	hook.Add( "OnEntityCreated", "!!!!lvsEntitySorter", function( ent )
		timer.Simple( 2, function() 
			if not IsValid( ent ) then return end

			if ent.LVS or ent.LFS then 
				table.insert( LVS.VehiclesStored, ent )
			end


		end )
	end )

	function LVS:GetVehicles()
		for index, ent in pairs( LVS.VehiclesStored ) do
			if not IsValid( ent ) then
				LVS.VehiclesStored[ index ] = nil
			end
		end

		return LVS.VehiclesStored
	end

	---------------------------------------

	cvars.AddChangeCallback( "lvs_show_nameindc", function( convar, oldValue, newValue ) 
		ShowNameIndc = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_show_hpindc", function( convar, oldValue, newValue ) 
		ShowHPIndc = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_show_identifier", function( convar, oldValue, newValue ) 
		ShowPlaneIdent = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_show_hud", function( convar, oldValue, newValue ) 
		ShowHud = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_voice_indicators", function( convar, oldValue, newValue ) 
		VoiceActivate = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_alert_indicators", function( convar, oldValue, newValue ) 
		ShowAlerts = tonumber( newValue ) ~=0
	end)

	--cvars.AddChangeCallback( "lvs_roll_with_ship", function( convar, oldValue, newValue ) 
		--AllowRollWithShip = tonumber( newValue ) ~=0
	--end)

	cvars.AddChangeCallback( "lvs_enable_radar", function( convar, oldValue, newValue ) 
		EnableRadar = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_enable_hp_shield", function( convar, oldValue, newValue ) 
		ShowHPAndShield = tonumber( newValue ) ~=0
	end)

	cvars.AddChangeCallback( "lvs_enable_hostile_alert", function( convar, oldValue, newValue ) 
		EnableHostileAlert = tonumber( newValue ) ~=0
	end)


	local Frame

	local function OpenSettingsMenu(admin)
		if not IsValid( Frame ) then
			local width = 400
			Frame = vgui.Create( "DFrame" )
			Frame:SetSize( width, 250 )
			Frame:SetTitle( "" )
			Frame:SetDraggable( true )
			Frame:MakePopup()
			Frame:Center()

			local y = 40
			if (admin) then
				y = 70
			end

			for i=1,#propertiesMenuClient do
				local name = propertiesMenuClient[i].name
				local desc = propertiesMenuClient[i].desc
				local cvar = propertiesMenuClient[i].convar
				local size = propertiesMenuClient[i].size or 20

				local CheckBox = vgui.Create( "DCheckBoxLabel", Frame )
				CheckBox:SetText( name .. " -- " .. desc )
				CheckBox:SetConVar(cvar) 
				CheckBox:SizeToContents()
				CheckBox:SetPos( 20, y )
				if (admin) then
					local func = propertiesMenuClient[i].func
					function CheckBox:OnChange(bVal)
						func(bVal)
					end
				end

				y = y + size
			end


			local volume_width = 350

			local volume_slider = vgui.Create( "DNumSlider", Frame )
			volume_slider:SetPos( 20, y )
			volume_slider:SetSize( width - 20, 20 )
			volume_slider:SetMin(0)
			volume_slider:SetMax(1)
			volume_slider:SetDecimals(2)
			volume_slider:SetConVar( "LVS_Voice_Alert_Volume" )
			volume_slider:SetText( "Voice Alerts Volume" )

			y = y + 30 

			-- Theme Color Changer -------------------------------------

			local admin_text = vgui.Create( "DLabel", Frame )
			admin_text:SetPos( 20, y )
			admin_text:SetText( "HUD Color Theme" )
			admin_text:SizeToContents()

			y = y + 20

			local theme_color_picker = vgui.Create("DColorMixer", Frame)
			theme_color_picker:SetPos(20, y)
			theme_color_picker:SetSize(width - 40,200)
			theme_color_picker:SetPalette(true)
			theme_color_picker:SetAlphaBar(true)
			theme_color_picker:SetWangs(true)
			theme_color_picker:SetColor(GetLVSColorTheme())
			theme_color_picker:SetConVarR("LVS_Color_ThemeR")
			theme_color_picker:SetConVarG("LVS_Color_ThemeG")
			theme_color_picker:SetConVarB("LVS_Color_ThemeB")

			

			y = y + 200
						
			----------------------------------- 
			-- Admin menu stuff

			if (admin) then
				y = y + 20 

				local admin_text = vgui.Create( "DLabel", Frame )
				admin_text:SetPos( 20, y )
				admin_text:SetText( "---------- OTHER ADMIN CONTROLS ----------" )
				admin_text:SizeToContents()

				y = y + 20
				local CheckBox = vgui.Create( "DCheckBoxLabel", Frame )
				CheckBox:SetText( "Enable Damage Changes -- If enabled, guns do less damage\nto LVS vehicles" )
				CheckBox:SetChecked(GetConVar("lvs_disable_damage_changes"):GetBool())
				CheckBox:SizeToContents()
				CheckBox:SetPos( 20, y )
				function CheckBox:OnChange(bVal)
					net.Start("LVS_Toggle_Damage_Reduction")
					net.WriteBool(bVal)
					net.SendToServer()
				end
				y = y + 30

				local CheckBoxTwo = vgui.Create( "DCheckBoxLabel", Frame )
				CheckBoxTwo:SetText( "Enable Staff notifications -- If enabled, staff will get notified\nwhenever someone changes a vehicles properties" )
				CheckBoxTwo:SetChecked(GetConVar("lvs_disable_admin_notify"):GetBool())
				CheckBoxTwo:SizeToContents()
				CheckBoxTwo:SetPos( 20, y )
				function CheckBoxTwo:OnChange(bVal)
					net.Start("LVS_Toggle_Admin_Notify")
					net.WriteBool(bVal)
					net.SendToServer()
				end
				y = y + 30

				local CheckBoxThree = vgui.Create( "DCheckBoxLabel", Frame )
				CheckBoxThree:SetText( "Enable Staff notifications (Except AI) -- If enabled, staff will get\nnotified whenever someone changes a vehicles AI property" )
				CheckBoxThree:SetChecked(GetConVar("lvs_disable_admin_notify_ai"):GetBool())
				CheckBoxThree:SizeToContents()
				CheckBoxThree:SetPos( 20, y )
				function CheckBoxThree:OnChange(bVal)
					net.Start("LVS_Toggle_Admin_Notify_AI_Only")
					net.WriteBool(bVal)
					net.SendToServer()
				end
				y = y + 30
			end

			Frame:SetSize( width, 40 + y - 30 )
			Frame:Center()
			Frame.Paint = function(self, w, h )
				draw.RoundedBox( 8, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
				draw.RoundedBox( 8, 1, 26, w-2, h-26, Color( 120, 120, 120, 255 ) )
				draw.RoundedBox( 8, 0, 0, w, 25, Color( 127, 0, 0, 255 ) )
				local title = "LVS Settings -- Client"
				if (admin) then
					title = "LVS Settings -- Admin"
					surface.SetDrawColor( 255, 255, 255, 255 )
					surface.SetMaterial( adminMat )
					surface.DrawTexturedRect( 285, 5, 16, 16 )
					draw.SimpleText( "This is the server config menu, any settings", "LVS_FONT_PANEL", width / 2, 38, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					draw.SimpleText( "you change here affects ALL players (EXCEPT HUD THEME COLOR)", "LVS_FONT_PANEL", width / 2 + 20, 53, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				draw.SimpleText( title, "LVS_FONT", 5, 11, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			end
		end
	end

	list.Set( "DesktopWindows", "LVSOverHaulMenu", {
		title = "LVS Overhaul Settings",
		icon = "icon64/lvs_icon.png",
		init = function( icon, window )
			OpenSettingsMenu(false)
		end
	} )

	net.Receive("LVS_Open_Config_From_Server_Admin", function()
		if (LocalPlayer():IsSuperAdmin()) then
			OpenSettingsMenu(true)
		else
			LocalPlayer():ChatPrint(LocalPlayer():Nick() .. ", you do not have permission to open this menu!" )
		end
	end)
end

if (SERVER) then
	net.Receive("LVS_Toggle_Damage_Reduction", function(len, ply)
		if !ply:IsSuperAdmin() then return end
		local b = net.ReadBool()
		GetConVar("lvs_disable_damage_changes"):SetBool(b)
	end)

	net.Receive("LVS_Toggle_Admin_Notify", function(len, ply)
		if !ply:IsSuperAdmin() then return end
		local b = net.ReadBool()
		GetConVar("lvs_disable_admin_notify"):SetBool(b)
	end)

	net.Receive("LVS_Toggle_Admin_Notify_AI_Only", function(len, ply)
		if !ply:IsSuperAdmin() then return end
		local b = net.ReadBool()
		GetConVar("lvs_disable_admin_notify_ai"):SetBool(b)
	end)

	-- This hook makes it so that specific damage types (guns/blasters) do much less damage to ships, as it is common for ground troops to shoot down ships wayyyy to quickly
	hook.Add("EntityTakeDamage","LVSDamageModifier", function(ent, dmginfo)
		if (GetConVar("lvs_disable_damage_changes"):GetBool()) then return end
		if (!ent.LVS or !ent.LFS) then return end
		if ((dmginfo:GetInflictor().LVS or dmginfo:GetInflictor().LFS) or dmginfo:GetInflictor() == Entity(0) or dmginfo:GetDamageType() == 0) then return end
		dmginfo:SetDamage(dmginfo:GetDamage() * .15)
	end)
end
--addons/playermodels/lua/autorun/materials.lua:
list.Add( "OverrideMaterials", "force_field")
list.Add( "OverrideMaterials", "force_fieldb")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_crate1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalceiling1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall2_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall3_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall6_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall8_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorpanels_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorgreebles02_mat")
list.Add( "OverrideMaterials", "models/wireframe" )
list.Add( "OverrideMaterials", "debug/env_cubemap_model" )
list.Add( "OverrideMaterials", "models/shadertest/shader3" )
list.Add( "OverrideMaterials", "models/shadertest/shader4" )
list.Add( "OverrideMaterials", "models/shadertest/shader5" )
list.Add( "OverrideMaterials", "models/shiny" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "Models/effects/comball_sphere" )
list.Add( "OverrideMaterials", "Models/effects/comball_tape" )
list.Add( "OverrideMaterials", "Models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "Models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/props_combine/stasisshield_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/portalball001_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_combine/tprings_globe" )
list.Add( "OverrideMaterials", "models/rendertarget" )
list.Add( "OverrideMaterials", "models/screenspace" )
list.Add( "OverrideMaterials", "brick/brick_model" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a" )
list.Add( "OverrideMaterials", "models/props_pipes/Pipesystem01a_skin3" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureFabric003a" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureMetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/paper01" )
list.Add( "OverrideMaterials", "models/flesh" )
list.Add( "OverrideMaterials", "models/airboat/airboat_blur02" )
list.Add( "OverrideMaterials", "models/alyx/emptool_glow" )
list.Add( "OverrideMaterials", "models/antlion/antlion_innards" )
list.Add( "OverrideMaterials", "models/barnacle/roots" )
list.Add( "OverrideMaterials", "models/combine_advisor/body9" )
list.Add( "OverrideMaterials", "models/combine_advisor/mask" )
list.Add( "OverrideMaterials", "models/combine_scanner/scanner_eye" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "models/dog/eyeglass" )
list.Add( "OverrideMaterials", "models/effects/comball_glow1" )
list.Add( "OverrideMaterials", "models/effects/comball_glow2" )
list.Add( "OverrideMaterials", "models/effects/portalrift_sheet" )
list.Add( "OverrideMaterials", "models/effects/slimebubble_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode1_sheet" )
list.Add( "OverrideMaterials", "models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode_sheet" )
list.Add( "OverrideMaterials", "models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs01" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs02" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs03" )
list.Add( "OverrideMaterials", "models/gibs/metalgibs/metal_gibs" )
list.Add( "OverrideMaterials", "models/items/boxsniperrounds" )
list.Add( "OverrideMaterials", "models/player/player_chrome1" )
list.Add( "OverrideMaterials", "models/props_animated_breakable/smokestack/brickwall002a" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_buildings/destroyedbuilldingwall01a" )
list.Add( "OverrideMaterials", "models/props_buildings/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric001a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric002a" )
list.Add( "OverrideMaterials", "models/props_c17/furnituremetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/gate_door02a" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder001" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder002" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder003" )
list.Add( "OverrideMaterials", "models/props_canal/canalmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01a" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01b" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01c" )
list.Add( "OverrideMaterials", "models/props_canal/coastmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/metalcrate001d" )
list.Add( "OverrideMaterials", "models/props_canal/metalwall005b" )
list.Add( "OverrideMaterials", "models/props_canal/rock_riverbed01a" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable_b" )
list.Add( "OverrideMaterials", "models/props_combine/combine_interface_disp" )
list.Add( "OverrideMaterials", "models/props_combine/combine_monitorbay_disp" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_combine/health_charger_glass" )
list.Add( "OverrideMaterials", "models/props_combine/metal_combinebridge001" )
list.Add( "OverrideMaterials", "models/props_combine/pipes01" )
list.Add( "OverrideMaterials", "models/props_combine/pipes03" )
list.Add( "OverrideMaterials", "models/props_combine/prtl_sky_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/stasisfield_beam" )
list.Add( "OverrideMaterials", "models/props_debris/building_template010a" )
list.Add( "OverrideMaterials", "models/props_debris/building_template022j" )
list.Add( "OverrideMaterials", "models/props_debris/composite_debris" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor013a" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor020a" )
list.Add( "OverrideMaterials", "models/props_debris/concretewall019a" )
list.Add( "OverrideMaterials", "models/props_debris/metalwall001a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterceiling008a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall009d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall039c" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall040c" )
list.Add( "OverrideMaterials", "models/props_debris/tilefloor001c" )
list.Add( "OverrideMaterials", "models/props_foliage/driftwood_01a" )
list.Add( "OverrideMaterials", "models/props_foliage/oak_tree01" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_interiors/metalfence007a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01b" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01c" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01d" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01e" )
list.Add( "OverrideMaterials", "models/props_lab/cornerunit_cloud" )
list.Add( "OverrideMaterials", "models/props_lab/door_klab01" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens2" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_lab/warp_sheet" )
list.Add( "OverrideMaterials", "models/props_lab/xencrystal_sheet" )
list.Add( "OverrideMaterials", "models/props_pipes/destroyedpipes01a" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a")
list.Add( "OverrideMaterials", "models/props_pipes/pipemetal001a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipeset_metal02" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin1" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin2" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001b" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001c" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretefloor010a" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall064b" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall066a" )
list.Add( "OverrideMaterials", "models/props_wasteland/dirtwall001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/metal_tram001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/quarryobjects01" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02b" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02c" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff04a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockgranite02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat01" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat02" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a_skin2" )
list.Add( "OverrideMaterials", "models/roller/rollermine_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crossbow/rebar_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crowbar/crowbar_cyl" )
list.Add( "OverrideMaterials", "models/weapons/v_grenade/grenade body" )
list.Add( "OverrideMaterials", "models/weapons/v_smg1/texture5" )
list.Add( "OverrideMaterials", "models/weapons/w_smg1/smg_crosshair" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light2" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/dollar" )
list.Add( "OverrideMaterials", "models/props/cs_assault/fireescapefloor" )
list.Add( "OverrideMaterials", "models/props/cs_assault/metal_stairs1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap02" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneytop" )
list.Add( "OverrideMaterials", "models/props/cs_assault/pylon" )
list.Add( "OverrideMaterials", "models/props/CS_militia/boulder01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milceil001" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarock" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarockb" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milwall006" )
list.Add( "OverrideMaterials", "models/props/CS_militia/rocks01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams02" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams03" )
list.Add( "OverrideMaterials", "models/props/CS_militia/RoofEdges" )
list.Add( "OverrideMaterials", "models/props/cs_office/clouds" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet2" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet3" )
list.Add( "OverrideMaterials", "models/props/cs_office/screen" )
list.Add( "OverrideMaterials", "models/props/cs_office/snowmana" )
list.Add( "OverrideMaterials", "models/props/de_inferno/de_inferno_boulder_03" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflra" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflrd" )
list.Add( "OverrideMaterials", "models/props/de_inferno/inftowertop" )
list.Add( "OverrideMaterials", "models/props/de_inferno/offwndwb_break" )
list.Add( "OverrideMaterials", "models/props/de_inferno/roofbits" )
list.Add( "OverrideMaterials", "models/props/de_inferno/tileroof01" )
list.Add( "OverrideMaterials", "models/props/de_inferno/woodfloor008a" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukconcretewalla" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukecardboard" )
list.Add( "OverrideMaterials", "models/props/de_nuke/pipeset_metal" )
list.Add( "OverrideMaterials", "models/shadertest/predator" )

list.Add( "OverrideMaterials", "models/lordtrilobite/glass_clear_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/glass_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_crate1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorpanels_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_exteriorgreebles02_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor2_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_floor2_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalceiling1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalceiling1_dirty_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalgrate01_mat")

list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall1_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall1_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall2_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall2_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall3_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall3_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall6_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall6_dirty_mat")
list.Add( "OverrideMaterials", "models/lordtrilobite/imp_metalwall8_mat")





--lua/autorun/mcfly_jka_jtg.lua:
--Add Playermodel
player_manager.AddValidModel( "Palpatine", "models/jazzmcfly/jka/palpatine/palpatine.mdl")


--lua/autorun/mcfly_jka_younglings.lua:
--Add Playermodel
player_manager.AddValidModel( "Young Anakin", "models/jazzmcfly/jka/younglings/jka_young_anikan.mdl" )
player_manager.AddValidModel( "Young Padiwan Male", "models/jazzmcfly/jka/younglings/jka_young_male.mdl" )
player_manager.AddValidModel( "Young Padiwan Female", "models/jazzmcfly/jka/younglings/jka_young_female.mdl" )
player_manager.AddValidModel( "Young Shaak Ti", "models/jazzmcfly/jka/younglings/jka_young_shak.mdl" )



--lua/autorun/med_droid.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "2-1B Medical Droid",		"models/player/tiki/med_droid.mdl" )

--lua/autorun/naboo_bacta_v2_3.lua:
-- Created by Oninoni
-- Based on Code by Syphadias
-- Huge thanks to them!

-- This has to match the map Name
if not (game.GetMap() == "rp_naboo_city_v2_3" or game.GetMap() == "rp_naboo_city_v2_3_night") then return end

-- The Ammount of Bacta Tanks that are used
local bactaCount = 4

-- The Name of the prop_vehicle_prisoner_pod without its suffix (e.g. bacta1, bacta2, ... -> bacta)
local entityName = "bacta"

-- Bacta Seat Don't fricking touch anything below this line!
local Category = "Map Utilities"
local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_GMOD_NOCLIP_LAYER )
end
local V = {
    Name = "Bacta Tank Seat",
	Model = "models/lordtrilobite/starwars/props/bactatankb.mdl",
    Class = "prop_vehicle_prisoner_pod",
    Category = Category,
 
    Author = "Syphadias, Oninoni",
    Information = "Seat with custom animation",
    Offset = 16,
 
    KeyValues = {
        vehiclescript = "scripts/vehicles/prisoner_pod.txt",
        limitview = "0"
    },
    Members = {
        HandleAnimation = StandAnimation
    }
}
list.Set( "Vehicles", "bacta_seat", V )
 
if SERVER then
    local seatCache = {}
    local function IsValidSeat(seat)
        local seat = seatCache[seat]
     
        if seat and IsValid(seat) then
			return true
        end
     
        return false
    end
	
	hook.Add("Think", "UpdateseatPosBacta", function()
		for i = 1, bactaCount, 1 do
			if !IsValidSeat(i) then
				seatCache[i] = ents.FindByName(entityName .. i)[1]

				if !IsValidSeat(i) then
					continue
				end
			end

			seatCache[i]:SetVehicleClass("bacta_seat")
		end
	end)
end
--lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 10 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--addons/openpermissions-config/lua/openpermissions_config.lua:
--[[

	   ____                   ____                      _           _                 
	  / __ \____  ___  ____  / __ \___  _________ ___  (_)_________(_)___  ____  _____
	 / / / / __ \/ _ \/ __ \/ /_/ / _ \/ ___/ __ `__ \/ / ___/ ___/ / __ \/ __ \/ ___/
	/ /_/ / /_/ /  __/ / / / ____/  __/ /  / / / / / / (__  |__  ) / /_/ / / / (__  ) 
	\____/ .___/\___/_/ /_/_/    \___/_/  /_/ /_/ /_/_/____/____/_/\____/_/ /_/____/  
	    /_/                                                                           

	Welcome to the OpenPermissions configuration file.
	This is where you'll define who is an OpenPermissions Operator.

	Operators have maximum permissions - you could call them "superadmins" of OpenPermissions.
	They have access to changing the permissions of the server, so only add people you trust here!

]]

-- Enter usergroups that should be Operators
OpenPermissions.Operators.Usergroups = {"gruender", "communityleitung", "superadmin"}

-- Enter SteamIDs or SteamID64s of people who should be Operators
OpenPermissions.Operators.SteamIDs = {
"76561198152415776", -- P4sca1
"76561198066776771", -- Airfox
"76561198039545371", -- Oninoni
"76561198068891112" -- Mattzi
}

-- Don't delete the line below; your config will break.
return true
--addons/openpermissions/lua/openpermissions/lang/english.lua:
return {
	Name = "English",
	Icon = "flags16/gb.png",
	Phrases = {
		operator_only_menu = "Only OpenPermissions Operators can access this menu.",
		permissions = "Permissions",
		help = "Help",
		tester = "Tester",
		access_groups = "Access Groups",
		access_group = "Access Group",
		type = "Type",
		add_access_group = "Add Access Group",
		custom_ellipsis = "Custom...",
		enter_usergroup = "Enter the name of a usergroup",
		enter_steamid = "Enter a SteamID or SteamID64. Examples:\nSteamID: %s\nSteamID64: %s",
		invalid_steamid = "That was not a valid SteamID.",
		error = "Error",
		ok = "OK",
		none_info = "(none)",
		key = "Key",
		access_group_exists = "This access group already exists.",
		operations = "Operations",
		select_an_access_group = "Please select access group(s) on the left",
		back_btn = "Back",
		delete_access_group = "Delete Selected Access Group(s)",
		copy = "Copy",
		paste = "Paste",
		all_permissions = "All Permissions",
		all_addons = "All Addons",
		save = "Save",
		not_an_addon = "That's not a valid addon.",
		hold_ctrl_to_select_multiple = "Hold CTRL to multiselect groups",
		permission_clash_msg = "WARNING: You have selected multiple access groups to copy, only permissions where\nall access groups have the same permission will be copied",
		Players = "Players",

		ACCESS_GROUP_OTHER = "Other",
		ACCESS_GROUP_USERGROUP = "Usergroup",
		ACCESS_GROUP_STEAMID = "SteamID",
		ACCESS_GROUP_TEAM = "Team",
		ACCESS_GROUP_LUA_FUNCTION = "Lua Function",
		ACCESS_GROUP_DARKRP_CATEGORY = "DarkRP Job Category",
	}
}
--lua/autorun/protocol_droids_by_grady.lua:
player_manager.AddValidModel( "Protocol Droid Black", 		"models/starwars/grady/protocol_droids/protocol-black.mdl" );
player_manager.AddValidHands( "Protocol Droid Black", 		"models/starwars/grady/protocol_droids/protocol_droids_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Protocol Droid Black", 	"models/starwars/grady/protocol_droids/protocol-black.mdl.mdl" );
--lua/autorun/pykes_new.lua:
list.Set( "PlayerOptionsModel",  "Pyke_Command", "models/gaminglight/pykes/pyke_command.mdl" )
player_manager.AddValidModel( "Pyke_Command", "models/gaminglight/pykes/pyke_command.mdl" )

list.Set( "PlayerOptionsModel",  "Pyke_NCO", "models/gaminglight/pykes/pyke_nco.mdl" )
player_manager.AddValidModel( "Pyke_NCO", "models/gaminglight/pykes/pyke_nco.mdl" )

list.Set( "PlayerOptionsModel",  "Pyke_Officer", "models/gaminglight/pykes/pyke_officer.mdl" )
player_manager.AddValidModel( "Pyke_Officer", "models/gaminglight/pykes/pyke_officer.mdl" )

list.Set( "PlayerOptionsModel",  "Pyke_Soldier", "models/gaminglight/pykes/pyke_soldier.mdl" )
player_manager.AddValidModel( "Pyke_Soldier", "models/gaminglight/pykes/pyke_soldier.mdl" )

list.Set( "PlayerOptionsModel",  "Pyke_Spice_Runner", "models/gaminglight/pykes/pyke_spice_runner.mdl" )
player_manager.AddValidModel( "Pyke_Spice_Runner", "models/gaminglight/pykes/pyke_spice_runner.mdl" )
--lua/autorun/r4.lua:
player_manager.AddValidModel( "Astromech R4", "models/ace/sw/r4.mdl" );
list.Set( "PlayerOptionsModel",  "Astromech R4", "models/ace/sw/r4.mdl" );
--lua/autorun/rb655_lightsaber.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------

-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------

]]

AddCSLuaFile()

-- -------------------------------------------------- Lightsaber effects -------------------------------------------------- --

-- game.AddDecal( "LSScorch", "effects/rb655_scorch" ) -- Why doesn't it work?

function rb655_DrawHit( trace, isBack )
	local pos = trace.HitPos
	local dir = trace.HitNormal

	local effectdata = EffectData()
	effectdata:SetOrigin( pos )
	effectdata:SetNormal( dir )
	util.Effect( "StunstickImpact", effectdata, true, true )

	--util.Decal( "LSScorch", pos + dir, pos - dir )
	util.Decal( "FadingScorch", pos + dir, pos - dir )
end

function rb655_IsLightsaber( ent )
	if ( !IsValid( ent ) ) then return false end
	if ( ent.IsLightsaber ) then return true end
	return false
end

function rb655_GetLightsaber( ply )
	if ( !IsValid( ply ) ) then return end

	for i, wep in ipairs( ply:GetWeapons() ) do
		if ( wep.IsLightsaber ) then return wep end
	end
end

-------------------------------------------------- FORCE POWERS --------------------------------------------------

rb655_gForcePowers = --[[rb655_gForcePowers ||]] {}

function rb655_AddForcePower( t )
	table.insert( rb655_gForcePowers, t )
end

rb655_AddForcePower( {
	name = "Force Leap",
	material = Material( "lightsaber_icons/leap.png" ),
	description = "Jump longer and higher.\nAim higher to jump higher/further.\nHold CTRL to negate fall damage, but stop moving for 1 sec",
	action = function( self, ply )
		if ( self:GetForce() < 10 or !ply:IsOnGround() or CLIENT ) then return end
		self:SetForce( self:GetForce() - 10 )

		self:SetNextAttack( 0.5 )

		ply:SetVelocity( ply:GetAimVector() * 512 + Vector( 0, 0, 512 ) )

		self:PlayWeaponSound( "lightsaber/force_leap.wav" )

		-- Trigger the jump animation, yay
		self:CallOnClient( "ForceJumpAnim", "" )
	end
} )

rb655_AddForcePower( {
	name = "Force Absorb",
	material = Material( "lightsaber_icons/absorb.png" ),
	description = "Hold Mouse 2 to protect yourself from harm",
	action = function( self, ply )
		if ( self:GetForce() < 1 --[[ or !ply:IsOnGround()]] or CLIENT ) then return end
		self:SetForce( self:GetForce() - 0.1 )

		self:SetNextAttack( 0.3 )
	end
} )

hook.Add( "EntityTakeDamage", "rb655_sabers_armor", function( victim, dmg )

	local ply = victim
	if ( !ply.GetActiveWeapon or !ply:IsPlayer() or !ply:KeyDown( IN_ATTACK2 ) --[[or !ply:IsOnGround()]] ) then return end

	local wep = ply:GetActiveWeapon()
	if ( !IsValid( wep ) or !rb655_IsLightsaber( wep ) or wep:GetActiveForcePowerType( wep:GetForceType() ).name != "Force Absorb" ) then return end

	local force = wep:GetForce()
	if ( force < 1 ) then return end

	local damage = dmg:GetDamage() / 5
	if ( force < damage ) then
		wep:SetForce( 0 )
		dmg:SetDamage( ( damage - force ) * 5 )
	else
		wep:SetForce( force - damage )
		dmg:SetDamage( 0 )
	end

end )

rb655_AddForcePower( {
	name = "Force Repulse",
	material = Material( "lightsaber_icons/repulse.png" ),
	description = "Hold to charge for greater distance/damage.\nKill everybody close to you.\nPush back everybody who is a bit farther away but still close enough.",
	think = function( self )
		if ( self:GetNextSecondaryFire() > CurTime() ) then return end
		if ( self:GetForce() < 1 or CLIENT ) then return end

		local owner = self:GetOwner()
		if ( !owner:KeyDown( IN_ATTACK2 ) and !owner:KeyReleased( IN_ATTACK2 ) ) then return end
		if ( !self._ForceRepulse and self:GetForce() < 16 ) then return end

		if ( !owner:KeyReleased( IN_ATTACK2 ) ) then
			if ( !self._ForceRepulse ) then self:SetForce( self:GetForce() - 16 ) self._ForceRepulse = 1 end

			if ( !self.NextForceEffect or self.NextForceEffect < CurTime() ) then
				local ed = EffectData()
				ed:SetOrigin( owner:GetPos() + Vector( 0, 0, 36 ) )
				ed:SetRadius( 128 * self._ForceRepulse )
				util.Effect( "rb655_force_repulse_in", ed, true, true )

				self.NextForceEffect = CurTime() + math.Clamp( self._ForceRepulse / 20, 0.1, 0.5 )
			end

			self._ForceRepulse = self._ForceRepulse + 0.025
			self:SetForce( self:GetForce() - 0.5 )
			if ( self:GetForce() > 0.99 ) then return end
		else
			if ( !self._ForceRepulse ) then return end
		end

		local maxdist = 128 * self._ForceRepulse

		for _, e in ipairs( ents.FindInSphere( owner:GetPos(), maxdist ) ) do
			if ( e == owner ) then continue end

			local dist = owner:GetPos():Distance( e:GetPos() )
			local mul = ( maxdist - dist ) / 256

			local v = ( owner:GetPos() - e:GetPos() ):GetNormalized()
			v.z = 0

			if ( e:IsNPC() and util.IsValidRagdoll( e:GetModel() or "" ) ) then

				local dmg = DamageInfo()
				dmg:SetDamagePosition( e:GetPos() + e:OBBCenter() )
				dmg:SetDamage( 48 * mul )
				dmg:SetDamageType( DMG_GENERIC )
				if ( ( 1 - dist / maxdist ) > 0.8 ) then
					dmg:SetDamageType( DMG_DISSOLVE )
					dmg:SetDamage( e:Health() * 3 )
				end
				dmg:SetDamageForce( -v * math.min( mul * 40000, 80000 ) )
				dmg:SetInflictor( owner )
				dmg:SetAttacker( owner )
				e:TakeDamageInfo( dmg )

				if ( e:IsOnGround() ) then
					e:SetVelocity( v * mul * -2048 + Vector( 0, 0, 64 ) )
				elseif ( !e:IsOnGround() ) then
					e:SetVelocity( v * mul * -1024 + Vector( 0, 0, 64 ) )
				end

			elseif ( e:IsPlayer() and e:IsOnGround() ) then
				e:SetVelocity( v * mul * -2048 + Vector( 0, 0, 64 ) )
			elseif ( e:IsPlayer() and !e:IsOnGround() ) then
				e:SetVelocity( v * mul * -384 + Vector( 0, 0, 64 ) )
			elseif ( e:GetPhysicsObjectCount() > 0 ) then
				for i = 0, e:GetPhysicsObjectCount() - 1 do
					e:GetPhysicsObjectNum( i ):ApplyForceCenter( v * mul * -512 * math.min( e:GetPhysicsObject():GetMass(), 256 ) + Vector( 0, 0, 64 ) )
				end
			end
		end

		local ed = EffectData()
		ed:SetOrigin( owner:GetPos() + Vector( 0, 0, 36 ) )
		ed:SetRadius( maxdist )
		util.Effect( "rb655_force_repulse_out", ed, true, true )

		self._ForceRepulse = nil

		self:SetNextAttack( 1 )

		self:PlayWeaponSound( "lightsaber/force_repulse.wav" )
	end
} )

rb655_AddForcePower( {
	name = "Force Heal",
	material = Material( "lightsaber_icons/healing.png" ),
	description = "Hold Mouse 2 to slowly heal yourself",
	action = function( self, ply )
		if ( self:GetForce() < 1 --[[|| !ply:IsOnGround()]] or ply:Health() >= (ply:GetMaxHealth() or 100) or CLIENT ) then return end
		self:SetForce( self:GetForce() - 1 )

		self:SetNextAttack( 0.2 )

		local ed = EffectData()
		ed:SetOrigin( ply:GetPos() )
		util.Effect( "rb655_force_heal", ed, true, true )

		ply:SetHealth( ply:Health() + 1 )
		ply:Extinguish()
	end
} )

rb655_AddForcePower( {
	name = "Force Combust",
	material = Material( "lightsaber_icons/combust.png" ),
	target = 1,
	description = "Ignite stuff infront of you.",
	action = function( self, ply )
		if ( CLIENT ) then return end

		local ent = self:SelectTargets( 1 )[ 1 ]

		if ( !IsValid( ent ) or ent:IsOnFire() ) then self:SetNextAttack( 0.2 ) return end

		local time = math.Clamp( 512 / ply:GetPos():Distance( ent:GetPos() ), 1, 16 )
		local neededForce = math.ceil( math.Clamp( time * 2, 10, 32 ) )

		if ( self:GetForce() < neededForce ) then self:SetNextAttack( 0.2 ) return end

		ent:Ignite( time, 0 )
		self:SetForce( self:GetForce() - neededForce )

		self:SetNextAttack( 1 )
	end
} )

rb655_AddForcePower( {
	name = "Force Lightning",
	material = Material( "lightsaber_icons/lighting.png" ),
	target = 3,
	description = "Torture people ( and monsters ) at will.",
	action = function( self )
		if ( self:GetForce() < 3 or CLIENT ) then return end

		local owner = self:GetOwner()
		local foundents = 0
		for id, ent in ipairs( self:SelectTargets( 3 ) ) do
			if ( !IsValid( ent ) ) then continue end

			foundents = foundents + 1
			local ed = EffectData()
			ed:SetOrigin( self:GetSaberPosAng() )
			ed:SetEntity( ent )
			util.Effect( "rb655_force_lighting", ed, true, true )

			local dmg = DamageInfo()
			dmg:SetAttacker( owner or self )
			dmg:SetInflictor( owner or self )

			dmg:SetDamage( math.Clamp( 512 / owner:GetPos():Distance( ent:GetPos() ), 1, 10 ) )
			if ( ent:IsNPC() ) then dmg:SetDamage( 4 ) end
			ent:TakeDamageInfo( dmg )

		end

		if ( foundents > 0 ) then
			self:SetForce( self:GetForce() - foundents )
			if ( !self.SoundLightning ) then
				self.SoundLightning = CreateSound( owner, "lightsaber/force_lightning" .. math.random( 1, 2 ) .. ".wav" )
				self.SoundLightning:Play()
			else
				self.SoundLightning:Play()
			end

			timer.Create( "rb655_force_lighting_soundkill", 0.2, 1, function() if ( self.SoundLightning ) then self.SoundLightning:Stop() self.SoundLightning = nil end end )
		end
		self:SetNextAttack( 0.1 )
	end
} )

--[[
rb655_AddForcePower( {
	name = "Force Push",
	icon = "P",
	description = "Push obstacles out of your way !Work In Progress!",
	action = function( self )
		if ( self:GetForce() < 16 or CLIENT ) then return end

		local owner = self:GetOwner()
		for id, ent in pairs( ents.FindInCone( owner:GetShootPos(), owner:GetAimVector(), 500, .01 ) ) do--self:SelectTargets( 5 ) ) do

		if ( ent == owner or ent:GetParent() == owner or ent:GetMoveType() == 0 ) then continue end
		print( id, ent, ent:GetMoveType() )
			ent:SetVelocity( owner:GetAimVector() * 5000 )
			if ( IsValid( ent:GetPhysicsObject() ) ) then
				for i = 0, ent:GetPhysicsObjectCount() - 1 do
					ent:GetPhysicsObjectNum( i ):SetVelocity( owner:GetAimVector() * 5000 )
				end
			end
		end

		self:SetNextAttack( 1 )
	end
} )

rb655_AddForcePower( {
	name = "Force Choke",
	icon = "CH",
	target = 3,
	description = "Vader it up! !WILL NEVER WORK!",
	action = function( self )
		if ( self:GetForce() < 3 or CLIENT ) then return end

		local owner = self:GetOwner()
		for id, ent in pairs( self:SelectTargets( 3 ) ) do
			if ( !IsValid( ent ) or ent:GetClass() != "npc_metropolice" or ent.Chocked ) then continue end
			ent.Chocked = true
			--print( ent, ent:LookupSequence("Choked_Barnacle") )
			--PrintTable( ent:GetSequenceList() )
			ent:ResetSequence( ent:LookupSequence("Choked_Barnacle") )
			--ent:ResetSequence( ent:LookupAttachment("") )

			local elev = 100
			local time = 1
			timer.Simple( 0.1, function() if ( !IsValid( ent ) ) then return end
				ent:SetPos( ent:GetPos() + Vector( 0, 0, elev / 3 * 1 ) )
			end )
			timer.Simple( 0.2, function() if ( !IsValid( ent ) ) then return end
				ent:SetPos( ent:GetPos() + Vector( 0, 0, elev / 3 * 1 ) )
			end )
			timer.Simple( 0.3, function() if ( !IsValid( ent ) ) then return end
				ent:SetPos( ent:GetPos() + Vector( 0, 0, elev / 3 * 1 ) )
			end )

			timer.Create( "test_22_" .. ent:EntIndex(), time + 3, 1, function() if ( !IsValid( ent ) ) then return end
				local dmg = DamageInfo()
				dmg:SetAttacker( owner or self )
				dmg:SetInflictor( owner or self )

				dmg:SetDamage( 400 )
				ent:TakeDamageInfo( dmg )
			end )

		end

		self:SetNextAttack( 0.1 )
	end
} )]]

function rb655_GetForcePowers()
	return rb655_gForcePowers
end

---------------------------------------------------

if ( CLIENT ) then return end

-- -------------------------------------------------- Prevent +use pickup some users were reporting -------------------------------------------------- --

hook.Add( "AllowPlayerPickup", "rb655_lightsaber_prevent_use_pickup", function( ply, ent )
	if ( ent:GetClass() == "ent_lightsaber" ) then return false end
end )

-- -------------------------------------------------- "Slice" or kill sounds -------------------------------------------------- --

local function DoSliceSound( victim, inflictor )
	if ( !IsValid( victim ) or !IsValid( inflictor ) ) then return end
	if ( string.find( inflictor:GetClass(), "_lightsaber" ) ) then
		victim:EmitSound( "lightsaber/saber_hit_laser" .. math.random( 1, 5 ) .. ".wav" )
	end
end

hook.Add( "PostEntityTakeDamage", "rb655_lightsaber_kill_snd", function( ent, dmg, took )
	if ( !IsValid( ent ) or !dmg or ent:IsNPC() or ent:IsPlayer() or !took ) then return end

	if ( ent:Health() > 0 and ( ent:Health() - dmg:GetDamage() ) <= 0 ) then
		local infl = dmg:GetInflictor()
		if ( !IsValid( infl ) and IsValid( dmg:GetAttacker() ) and dmg:GetAttacker().GetActiveWeapon ) then -- Ugly fucking haxing workaround, thanks VOLVO
			infl = dmg:GetAttacker():GetActiveWeapon()
		end

		DoSliceSound( ent, infl )
	end
end )

hook.Add( "PlayerDeath", "rb655_lightsaber_kill_snd_ply", function( victim, inflictor, attacker )
	if ( !IsValid( inflictor ) and IsValid( attacker ) and attacker.GetActiveWeapon ) then inflictor = attacker:GetActiveWeapon() end -- Ugly fucking haxing workaround, thanks VOLVO
	DoSliceSound( victim, inflictor )
end )

hook.Add( "OnNPCKilled", "rb655_lightsaber_kill_snd_npc", function( victim, attacker, inflictor )
	if ( !IsValid( inflictor ) and IsValid( attacker ) and attacker.GetActiveWeapon ) then inflictor = attacker:GetActiveWeapon() end -- Ugly fucking haxing workaround, thanks VOLVO
	DoSliceSound( victim, inflictor )
end )

-- -------------------------------------------------- Lightsaber Damage -------------------------------------------------- --

local cvar
if ( SERVER ) then
	cvar = CreateConVar( "rb655_lightsaber_allow_knockback", "1" )
end

local function IsKickbackAllowed()
	if ( cvar and cvar:GetBool() ) then return true end
	return false
end

-- A list of entities that we should not even try to deal damage to, due to them not taking dealt damage
local rb655_ls_nodamage = {
	npc_rollermine = true, -- Sigh, Lua could use arrays
	npc_turret_floor = true,
	npc_combinedropship = true,
	npc_helicopter = true,
	monster_tentacle = true,
	monster_bigmomma = true,
}
function rb655_LS_DoDamage( tr, wep )
	local ent = tr.Entity

	if ( !IsValid( ent ) or ( ent:Health() <= 0 and ent:GetClass() != "prop_ragdoll" ) or rb655_ls_nodamage[ ent:GetClass() ] ) then return end

	local dmg = hook.Run( "CanLightsaberDamageEntity", ent, wep, tr )
	if ( isbool( dmg ) and dmg == false ) then return end

	local dmginfo = DamageInfo()
	dmginfo:SetDamageForce( tr.HitNormal * -13.37 )
	dmginfo:SetDamageType( DMG_SLASH )

	if ( dmg ) then
		dmginfo:SetDamage( tonumber( dmg ) )
	else
		dmginfo:SetDamage( 25 )
	end

	if ( ( !ent:IsPlayer() or !wep:IsWeapon() ) or IsKickbackAllowed() ) then
		-- This causes the damage to apply force the the target, which we do not want
		-- For now, only apply it to the SENT
		dmginfo:SetInflictor( wep )
	end

	if ( ent:GetClass() == "npc_zombie" or ent:GetClass() == "npc_fastzombie" ) then
		dmginfo:SetDamageType( bit.bor( DMG_SLASH, DMG_CRUSH ) )
		dmginfo:SetDamageForce( tr.HitNormal * 0 )
		dmginfo:SetDamage( math.max( dmginfo:GetDamage(), 30 ) ) -- Make Zombies get cut in half
	end

	if ( !IsValid( wep.Owner ) ) then
		dmginfo:SetAttacker( wep )
	else
		dmginfo:SetAttacker( wep.Owner )
	end

	ent:TakeDamageInfo( dmginfo )
end

--lua/autorun/rb655_lightsaber_clientside.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------

-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------

]]

AddCSLuaFile()

if ( SERVER ) then

	CreateConVar( "rb655_lightsaber_disallow_custom_content", "1", FCVAR_NONE, "Disallows usage of custom Lightsaber content (models) that is not present in the tool options when loading settings from the Sandbox tool." )

	local hob_cvar = CreateConVar( "rb655_lightsaber_hiltonbelt", "1", FCVAR_NONE, "If set to non 0, enables the display of hilt model on the player's belt while the player has their lightsaber holstered." )

	cvars.AddChangeCallback( "rb655_lightsaber_hiltonbelt", function( cvar, old, new )
		SetGlobalBool( "rb655_lightsaber_hiltonbelt", new != "0" )
	end, "rb655_lightsaber_hiltonbelt" )

	hook.Add( "PlayerInitialSpawn", "rb655_lightsaber_hiltonbelt", function()
		SetGlobalBool( "rb655_lightsaber_hiltonbelt", hob_cvar:GetFloat() > 0 )
	end )

	return
end

-- --------------------------------------------------------- Fix the bad sounds and models --------------------------------------------------------- --

local tr = {
	["models/sgg/starwars/weapons/w_maul_saber_hilt.mdl"] = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
	["models/sgg/starwars/weapons/w_maul_saberstaff_hilt.mdl"] = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
	["models/sgg/starwars/weapons/w_dooku_saber_hilt.mdl"] = "models/weapons/starwars/w_dooku_saber_hilt.mdl",

	-- Sounds
	["lightsaber/darksaberloop.wav"] = "lightsaber/darksaber_loop.wav",
	["lightsaber/darksaberoff.wav"] = "lightsaber/darksaber_on.wav",
	["lightsaber/darksaberon.wav"] = "lightsaber/darksaber_off.wav",
	["lightsaber/darksaberswing.wav"] = "lightsaber/darksaber_swing.wav",

	["lightsaber/forceleap.wav"] = "lightsaber/force_leap.wav",
	["lightsaber/forcerepulse.wav"] = "lightsaber/force_repulse.wav",
	["lightsaber/forcelightning1.wav"] = "lightsaber/force_lightning1.wav", -- Pretty sure these two shouldn't be here, but just in case
	["lightsaber/forcelightning2.wav"] = "lightsaber/force_lightning2.wav",

	["lightsaber/saberhit.wav"] = "lightsaber/saber_hit.wav",
	["lightsaber/saberhitlaser1.wav"] = "lightsaber/saber_hit_laser1.wav",
	["lightsaber/saberhitlaser2.wav"] = "lightsaber/saber_hit_laser2.wav",
	["lightsaber/saberhitlaser3.wav"] = "lightsaber/saber_hit_laser3.wav",
	["lightsaber/saberhitlaser4.wav"] = "lightsaber/saber_hit_laser4.wav",
	["lightsaber/saberhitlaser5.wav"] = "lightsaber/saber_hit_laser5.wav",

	["lightsaber/saberswing1.wav"] = "lightsaber/saber_swing1.wav",
	["lightsaber/saberswing2.wav"] = "lightsaber/saber_swing2.wav",

	["lightsaber/saberloop1.wav"] = "lightsaber/saber_loop1.wav",
	["lightsaber/saberloop2.wav"] = "lightsaber/saber_loop2.wav",
	["lightsaber/saberloop3.wav"] = "lightsaber/saber_loop3.wav",
	["lightsaber/saberloop4.wav"] = "lightsaber/saber_loop4.wav",
	["lightsaber/saberloop5.wav"] = "lightsaber/saber_loop5.wav",
	["lightsaber/saberloop6.wav"] = "lightsaber/saber_loop6.wav",
	["lightsaber/saberloop7.wav"] = "lightsaber/saber_loop7.wav",
	["lightsaber/saberloop8.wav"] = "lightsaber/saber_loop8.wav",

	["lightsaber/saberon1.wav"] = "lightsaber/saber_on1.wav",
	["lightsaber/saberon1_fast.wav"] = "lightsaber/saber_on1_fast.wav",
	["lightsaber/saberoff1.wav"] = "lightsaber/saber_off1.wav",
	["lightsaber/saberoff1_fast.wav"] = "lightsaber/saber_off1_fast.wav",
	["lightsaber/saberon2.wav"] = "lightsaber/saber_on2.wav",
	["lightsaber/saberon2_fast.wav"] = "lightsaber/saber_on2_fast.wav",
	["lightsaber/saberoff2.wav"] = "lightsaber/saber_off2.wav",
	["lightsaber/saberoff2_fast.wav"] = "lightsaber/saber_off2_fast.wav",
	["lightsaber/saberon3.wav"] = "lightsaber/saber_on3.wav",
	["lightsaber/saberon3_fast.wav"] = "lightsaber/saber_on3_fast.wav",
	["lightsaber/saberoff3.wav"] = "lightsaber/saber_off3.wav",
	["lightsaber/saberoff3_fast.wav"] = "lightsaber/saber_off3_fast.wav",
	["lightsaber/saberon4.wav"] = "lightsaber/saber_on4.wav",
	["lightsaber/saberon4_fast.wav"] = "lightsaber/saber_on4_fast.wav",
	["lightsaber/saberoff4.wav"] = "lightsaber/saber_off4.wav",
	["lightsaber/saberoff4_fast.wav"] = "lightsaber/saber_off4_fast.wav",

	["lightsaber/saberon4.mp3"] = "lightsaber/saber_on4.wav",
	["lightsaber/saberoff4.mp3"] = "lightsaber/saber_off4.wav",
}

local convars = {
	"rb655_lightsaber_model",

	"rb655_lightsaber_humsound",
	"rb655_lightsaber_swingsound",
	"rb655_lightsaber_onsound",
	"rb655_lightsaber_offsound",
}

hook.Add( "Initialize", "rb655_fix_convars", function()
	if ( !GetConVar( "rb655_lightsaber_model" ) ) then return end

	for id, cvar in ipairs( convars ) do
		if ( tr[ GetConVar( cvar ):GetString():lower() ] ) then
			RunConsoleCommand( cvar, tr[ GetConVar( cvar ):GetString():lower() ] )
			print( "Fixing convar value for " .. cvar .. "!" )
		end
	end
end )

-- --------------------------------------------------------- Hilt On a Belt --------------------------------------------------------- --

hook.Add( "PostPlayerDraw", "rb655_lightsaber", function( ply )
	if ( !GetGlobalBool( "rb655_lightsaber_hiltonbelt", false ) --[[or !ply:HasWeapon( "weapon_lightsaber" )]] ) then return end

	local wep = rb655_GetLightsaber( ply ) --ply:GetWeapon( "weapon_lightsaber" )
	if ( !IsValid( wep ) or wep == ply:GetActiveWeapon() ) then return end

	if ( !IsValid( ply.LightsaberMDL ) ) then
		ply.LightsaberMDL = ClientsideModel( wep.WorldModel, RENDERGROUP_BOTH )
	end
	if ( !IsValid( ply.LightsaberMDL ) ) then return end -- We are still invalid, bail

	ply.LightsaberMDL:SetNoDraw( true )
	if ( !ply.LightsaberMDL:GetModel() or ply.LightsaberMDL:GetModel() != wep.WorldModel ) then
		ply.LightsaberMDL:SetModel( wep.WorldModel )
	end

	local pos, ang = ply:GetBonePosition( 0 )
	ang:RotateAroundAxis( ang:Up(), 80 )

	local len = ply:GetVelocity():Length()
	if ( ply:GetVelocity():Distance( ply:GetForward() * len ) < ply:GetVelocity():Distance( ply:GetForward() * -len ) ) then
		ang:RotateAroundAxis( ang:Right(), math.min( ply:GetVelocity():Length() / 8, 55 ) - 5 ) -- Forward
	else
		ang:RotateAroundAxis( ang:Right(), -math.min( ply:GetVelocity():Length() / 8, 55 ) + 5 )
	end

	if ( ply:GetVelocity():Distance( ply:GetRight() * len ) < ply:GetVelocity():Distance( ply:GetRight() * -len ) ) then
		--ang:RotateAroundAxis( ang:Right(), math.min( ply:GetVelocity():Length() / 8, 55 ) - 5 ) -- Right
	else
		ang:RotateAroundAxis( ang:Up(), -math.min( ply:GetVelocity():Length() / 16, 30 ) + 5 )
	end

	pos = pos - ang:Right() * 8 - ang:Forward() * 8
	if ( wep.WorldModel == "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" ) then
		pos = pos - ang:Forward() * 5
	elseif ( wep.WorldModel == "models/weapons/starwars/w_kr_hilt.mdl" ) then
		pos = pos + ang:Forward() * 5
	end

	ang:RotateAroundAxis( ang:Forward(), 90 )

	ply.LightsaberMDL:SetPos( pos )
	ply.LightsaberMDL:SetAngles( ang )

	ply.LightsaberMDL:DrawModel()

end )

-- --------------------------------------------------------- Lightsaber blade rendering --------------------------------------------------------- --

local HardLaser = Material( "lightsaber/hard_light" )
local HardLaserInner = Material( "lightsaber/hard_light_inner" )

local HardLaserTrail = Material( "lightsaber/hard_light_trail" )
local HardLaserTrailInner = Material( "lightsaber/hard_light_trail_inner" )

local HardLaserTrailEnd = Material( "lightsaber/hard_light_trail_end" )
local HardLaserTrailEndInner = Material( "lightsaber/hard_light_trail_end_inner" )

--[[local HardLaserTrailEnd = Material( "lightsaber/hard_light_trail" )
local HardLaserTrailEndInner = Material( "lightsaber/hard_light_trail_inner" )]]

local gOldBladePositions = {}
local gTrailLength = 1

function rb655_RenderBlade( pos, dir, length, maxlen, width, color, black_inner, eid, underwater, quillon, bladeNum )
	--render.DrawLine( pos + dir * length*-2, pos + dir * length*2, color, true )

	quillon = quillon or false
	bladeNum = bladeNum or 1

	if ( quillon ) then
		length = rb655_CalculateQuillonLength( length, maxlen )
		maxlen = rb655_CalculateQuillonMaxLength( maxlen )
		width = rb655_CalculateQuillonWidth( width )
	end

	if ( length <= 0 ) then rb655_SaberClean( eid, bladeNum ) return end

	if ( underwater ) then
		local ed = EffectData()
		ed:SetOrigin( pos )
		ed:SetNormal( dir )
		ed:SetRadius( length )
		util.Effect( "rb655_saber_underwater", ed )
	end

	local inner_color = color_white
	if ( black_inner ) then inner_color = Color( 0, 0, 0 ) end

	local bladeS = 1
	if ( quillon ) then
		bladeS = 0.25
	end

	render.SetMaterial( HardLaser )
	render.DrawBeam( pos, pos + dir * ( length * 1.01 ), width * 1.6, bladeS, 0.01, color )

	render.SetMaterial( HardLaserInner )
	render.DrawBeam( pos, pos + dir * length, width * 1, bladeS, 0.01, inner_color )

	-- Dynamic light
	if ( !quillon ) then
		local SaberLight = DynamicLight( eid + 1000 * bladeNum )
		if ( SaberLight ) then
			SaberLight.Pos = pos + dir * ( length / 2 )
			SaberLight.r = color.r
			SaberLight.g = color.g
			SaberLight.b = color.b
			SaberLight.Brightness = 0.6
			SaberLight.Size = 176 * ( length / maxlen )
			SaberLight.Decay = 0
			SaberLight.DieTime = CurTime() + 0.1
		end
	end

	if ( quillon ) then
		length = length * 0.93
	end

	local prevB = pos
	local prevT = pos + dir * length

	if ( !gOldBladePositions[ eid ] ) then gOldBladePositions[ eid ] = {} end
	if ( !gOldBladePositions[ eid ][ bladeNum ] ) then gOldBladePositions[ eid ][ bladeNum ] = {} end

	for id, prevpos in ipairs( gOldBladePositions[ eid ][ bladeNum ] ) do
		local posB = prevpos.pos
		local posT = prevpos.pos + prevpos.dir * prevpos.len
		--local posB = prevB
		--local posT = prevB + prevpos.dir * prevpos.len

		if ( id == gTrailLength ) then
			HardLaserTrailEnd:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
			render.SetMaterial( HardLaserTrailEnd )
		else
			HardLaserTrail:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
			render.SetMaterial( HardLaserTrail )
		end
		render.DrawQuad( posB, prevB, prevT, posT )

		if ( id == gTrailLength ) then
			HardLaserTrailEndInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
			render.SetMaterial( HardLaserTrailEndInner )
		else
			HardLaserTrailInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
			render.SetMaterial( HardLaserTrailInner )
		end
		render.DrawQuad( posB, prevB, prevT, posT )

		prevB = prevpos.pos
		prevT = prevpos.pos + prevpos.dir * prevpos.len
		--prevT = prevB + prevpos.dir * prevpos.len
	end
end

function rb655_SaberClean( eid, bladeNum )
	if ( !bladeNum ) then gOldBladePositions[ eid ] = nil return end
	if ( gOldBladePositions[ eid ] ) then
		gOldBladePositions[ eid ][ bladeNum ] = nil
	end
end

-- Extremely ugly hack workaround :(
function rb655_ProcessBlade( eid, pos, dir, len, bladeNum, quillon )
	if ( !gOldBladePositions[ eid ] ) then gOldBladePositions[ eid ] = {} end
	if ( !gOldBladePositions[ eid ][ bladeNum ] ) then gOldBladePositions[ eid ][ bladeNum ] = {} end

	if ( quillon ) then len = len * 0.93 end
	local hax = gOldBladePositions[ eid ][ bladeNum ]
	for i = 0, gTrailLength - 1 do
		hax[ gTrailLength - i ] = hax[ gTrailLength - i - 1 ]
		if ( gTrailLength - i == 1 ) then
			hax[ 1 ] = { dir = dir, len = len, pos = pos }
		end
	end
end

function rb655_CalculateQuillonMaxLength( maxLength )
	return maxLength / 6
end

function rb655_CalculateQuillonWidth( width )
	return width * 0.8
end

function rb655_CalculateQuillonLength( length, maxLength )
	local qlen = rb655_CalculateQuillonMaxLength( length )
	local maxLen = rb655_CalculateQuillonMaxLength( maxLength )
	return math.Clamp( maxLen - ( maxLength - length ), 0, qlen )
end

function rb655_ProcessLightsaberEntity( ent )
	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0
	for id, t in ipairs( ent:GetAttachments() or {} ) do -- TODO: Remove the {} part
		if ( !string.match( t.name, "blade(%d+)" ) and !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum and ent:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( bladeNum )
			rb655_ProcessBlade( ent:EntIndex(), pos, ang, ent:GetBladeLength(), blades )

			bladesFound = true
		end

		if ( quillonNum and ent:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( quillonNum, true )
			rb655_ProcessBlade( ent:EntIndex(), pos, ang, rb655_CalculateQuillonLength( ent:GetBladeLength(), ent:GetMaxLength() ), blades, true )
		end
	end

	if ( !bladesFound ) then
		local pos, ang = ent:GetSaberPosAng()
		rb655_ProcessBlade( ent:EntIndex(), pos, ang, ent:GetBladeLength(), 1 )
	end
end

-- Try to be faster.. This is kinda ugly
local ents_FindByClass = ents.FindByClass
local inext = ipairs( {} )
local LightsaberWCache = nil
local LightsaberECache = nil

local function rb655_lightsaberW_iterator()
	if ( LightsaberWCache == nil ) then LightsaberWCache = ents_FindByClass( "weapon_lightsaber*" ) end
	return inext, LightsaberWCache, 0
end
local function rb655_lightsaberE_iterator()
	if ( LightsaberECache == nil ) then LightsaberECache = ents_FindByClass( "ent_lightsaber*" ) end
	return inext, LightsaberECache, 0
end
local function InvalidateLightsaberCache( ent )
	LightsaberWCache = nil
	LightsaberECache = nil
end
hook.Add( "OnEntityCreated", "rb655_lightsaber_iterator", InvalidateLightsaberCache )
hook.Add( "EntityRemoved", "rb655_lightsaber_iterator", InvalidateLightsaberCache )



hook.Add( "Think", "rb655_lightsaber_ugly_fixes", function()
	for id, ent in rb655_lightsaberW_iterator() do
		if ( !IsValid( ent:GetOwner() ) or ent:GetOwner():GetActiveWeapon() != ent or !ent.GetBladeLength or ent:GetBladeLength() <= 0 ) then continue end

		rb655_ProcessLightsaberEntity( ent )
	end

	for id, ent in rb655_lightsaberE_iterator() do
		if ( !ent.GetBladeLength or ent:GetBladeLength() <= 0 ) then continue end

		rb655_ProcessLightsaberEntity( ent )
	end
end )

--lua/autorun/rb655_make_animatable.lua:

AddCSLuaFile()

properties.Add( "rb655_make_animatable", {
	MenuLabel = "#tool.rb655_easy_animation.property",
	Order = 654,
	MenuIcon = "icon16/tick.png",
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_make_animatable", ent ) ) then return false end
		if ( ent:GetClass() == "prop_animatable" ) then return false end
		if ( ent:IsPlayer() or !ent:GetModel() or ent:GetModel():StartWith( "*" ) ) then return false end
		--if ( string.find( ent:GetClass(), "prop_physics" ) or string.find( ent:GetClass(), "prop_ragdoll" ) ) then return true end
		return true
	end,
	Action = function( self, ent )
		self:MsgStart()
		net.WriteEntity( ent )
		self:MsgEnd()
	end,
	Receive = function( self, len, ply )
		local ent = net.ReadEntity()

		if ( !IsValid( ply ) or !IsValid( ent ) or !self:Filter( ent, ply ) ) then return false end

		local entActual = ent
		if ( IsValid( ent.AttachedEntity ) ) then
			ent = ent.AttachedEntity
		end

		local ragPos = ent:GetPos()

		-- Try to not make entity fly
		if ( ent:IsRagdoll() ) then
			for i = 0, ent:GetPhysicsObjectCount() - 1 do
				local bone = ent:GetPhysicsObjectNum( i )
				if ( IsValid( bone ) ) then
					local pos = bone:GetPos()

					-- Yes I like my pyramids
					if ( pos.z < ragPos.z ) then
						ragPos.z = pos.z
					end
				end
			end
		end

		local prop_animatable = ents.Create( "prop_animatable" )
		prop_animatable:SetModel( ent:GetModel() )
		prop_animatable:SetPos( ragPos )
		prop_animatable:SetAngles( ent:GetAngles() )
		prop_animatable:SetSequence( ent:GetSequence() )
		prop_animatable:SetCycle( ent:GetCycle() )
		--prop_animatable:SetPlaybackRate( ent:GetPlaybackRate() )

		if ( IsValid( ply ) ) then
			ply:AddCount( "prop_animatable", prop_animatable )
			ply:AddCleanup( "prop_animatable", prop_animatable )
			prop_animatable:SetPlayer( ply )
		end

		prop_animatable:SetSkin( ent:GetSkin() or 0 )
		prop_animatable:SetFlexScale( ent:GetFlexScale() )
		for i = 0, ent:GetFlexNum() - 1 do prop_animatable:SetFlexWeight( i, ent:GetFlexWeight( i ) ) end
		for i = 0, ( ent:GetNumBodyGroups() or 0 ) - 1 do prop_animatable:SetBodygroup( i, ent:GetBodygroup( i ) ) end
		for i = 0, ent:GetNumPoseParameters() - 1 do prop_animatable:SetPoseParameter( ent:GetPoseParameterName( i ) , ent:GetPoseParameter( i ) ) end
		for i = 0, ent:GetBoneCount() do
			prop_animatable:ManipulateBoneScale( i, ent:GetManipulateBoneScale( i ) )
			prop_animatable:ManipulateBoneAngles( i, ent:GetManipulateBoneAngles( i ) )
			prop_animatable:ManipulateBonePosition( i, ent:GetManipulateBonePosition( i ) )
			prop_animatable:ManipulateBoneJiggle( i, ent:GetManipulateBoneJiggle( i ) )
		end
		-- prop_animatable:InvalidateBoneCache()

		prop_animatable:Spawn()
		prop_animatable:Activate()

		prop_animatable.EntityMods = ent.EntityMods
		prop_animatable.BoneMods = ent.BoneMods
		duplicator.ApplyEntityModifiers( ply, prop_animatable )
		duplicator.ApplyBoneModifiers( ply, prop_animatable )

		-- We use string find because there are might be subclasses, like prop_ragdoll_multiplayer or something
		if ( string.find( entActual:GetClass(), "prop_ragdoll" ) or entActual:IsNPC() ) then
			prop_animatable:FixRagdoll() -- This WILL have false-positives, but it will have to do for now
		end

		undo.ReplaceEntity( entActual, prop_animatable )
		cleanup.ReplaceEntity( entActual, prop_animatable )

		constraint.RemoveAll( entActual ) -- Remove all constraints ( this stops ropes from hanging around )
		entActual:Remove()
	end
} )

properties.Add( "rb655_make_ragdoll", {
	MenuLabel = "#tool.rb655_easy_animation.property_ragdoll",
	Order = 653,
	MenuIcon = "icon16/tick.png",
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_make_ragdoll", ent ) ) then return false end
		if ( ent:GetClass() != "prop_animatable" ) then return false end
		if ( !ent.GetIsRagdoll or !ent:GetIsRagdoll() ) then return false end
		return true
	end,
	Action = function( self, ent )
		self:MsgStart()
		net.WriteEntity( ent )
		self:MsgEnd()
	end,
	Receive = function( self, len, ply )
		local ent = net.ReadEntity()

		if ( !IsValid( ply ) or !IsValid( ent ) or !self:Filter( ent, ply ) ) then return false end

		ent:BecomeRagdollLua()
	end
} )

local function MakeDTVarToggleProperty( class, tab )

	local origTab = {
		Type = "toggle",

		Filter = function( self, ent, ply )

			if ( !IsValid( ent ) ) then return false end
			if ( !gamemode.Call( "CanProperty", ply, class, ent ) ) then return false end

			if ( self.ClassRestrict and ent:GetClass() != self.ClassRestrict ) then return false end

			return true

		end,

		Checked = function( self, ent, ply )

			-- This should never happen
			if ( !isfunction( ent[ "Get" .. self.DTVariable ] ) ) then return false end

			return ent[ "Get" .. self.DTVariable ]( ent )

		end,

		Action = function( self, ent )

			self:MsgStart()
				net.WriteEntity( ent )
			self:MsgEnd()

		end,

		Receive = function( self, length, ply )

			local ent = net.ReadEntity()
			if ( !properties.CanBeTargeted( ent, ply ) ) then return end
			if ( !self:Filter( ent, ply ) ) then return end

			if ( !isfunction( ent[ "Get" .. self.DTVariable ] ) ) then return end
			if ( !isfunction( ent[ "Set" .. self.DTVariable ] ) ) then return end

			ent[ "Set" .. self.DTVariable ]( ent, !ent[ "Get" .. self.DTVariable ]( ent ) )

		end

	}

	properties.Add( class, table.Merge( origTab, tab ) )

end

MakeDTVarToggleProperty( "rb655_animatable_body_xy", {
	MenuLabel = "#tool.rb655_easy_animation.property_bodyxy",
	Order = 600,

	ClassRestrict = "prop_animatable",
	DTVariable = "AnimateBodyXY"
} )

MakeDTVarToggleProperty( "rb655_animatable_ragdoll_on_dmg", {
	MenuLabel = "#tool.rb655_easy_animation.property_damageragdoll",
	Order = 601,

	ClassRestrict = "prop_animatable",
	DTVariable = "BecomeRagdoll"
} )

--lua/autorun/saeseetiin.lua:
player_manager.AddValidModel( "saeseetiin", "models/gonzo/saeseetiin/saeseetiin.mdl" ) 
list.Set( "PlayerOptionsModel",  "saeseetiin", "models/gonzo/saeseetiin/saeseetiin.mdl" )



--addons/sam/lua/sam/libs/sh_netstream.lua:
if SAM_LOADED then return end

--[[
	NetStream - 2.0.1
	https://github.com/alexgrist/NetStream/blob/master/netstream2.lua

	Alexander Grist-Hucker
	http://www.revotech.org
]]--

--[[
	if SERVER then
		netstream.Hook("Hi", function(ply, ...) -- Third argument is called to check if the player has permission to send the net message before decoding
			print(...)
		end, function(ply)
			if not ply:IsAdmin() then
				return false
			end
		end)
		-- OR
		netstream.Hook("Hi", function(ply, ...)
			print(...)
		end)
		netstream.Start(Entity(1), "Hi", "a", 1, {}, true, false, nil, "!") -- First argument player or table of players or any other argument to send to all players
		netstream.Start({Entity(1), Entity(2)}, "Hi", "a", 1, {}, true, false, nil, "!")
		netstream.Start(nil, "Hi", "a", 1, {}, true, false, nil, "!")
	end
	if CLIENT then
		netstream.Hook("Hi", function(...)
			print(...)
		end)
		netstream.Start("Hi", "a", 1, {}, true, false, nil, "!")
	end
]]--

-- Config

local addonName = "SAM"
local mainTable = sam -- _G.netstream = netstream

local mp = sam.mp

--

local type = sam.type
local pcall = pcall
local unpack = unpack

local net = net
local table_maxn = table.maxn

local netStreamSend = addonName .. ".NetStreamDS.Sending"

local netstream = {}
if istable(mainTable) then
	mainTable.netstream = netstream
end

local checks = {}
local receivers = {}

local concat = table.concat
local pack = function(t, n)
	local buffer = {}
	mp.packers["array"](buffer, t, n)
	return concat(buffer)
end

if SERVER then
	util.AddNetworkString(netStreamSend)

	-- local str_sub = string.sub
	-- local function Split(str, buffer, result)
	--	 if not result then
	--		 result = {}
	--	 end

	--	 if not buffer then
	--		 buffer = 32768
	--	 end

	--	 local len = #str
	--	 if len >= buffer then
	--		 result[#result + 1] = str_sub(str, 1, buffer - 1)
	--		 str = str_sub(str, buffer, len)
	--	 else
	--		 result[#result + 1] = str
	--		 return result
	--	 end

	--	 return Split(str, buffer, result)
	-- end

	local player_GetAll = player.GetAll
	function netstream.Start(ply, name, ...)
		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local encoded_data = pack({...}, select("#", ...))
		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 17)
			net.WriteData(encoded_data, length)
		net.Send(ply)
	end

	function netstream.Hook(name, callback, check)
		receivers[name] = callback
		if type(check) == "function" then
			checks[name] = check
		end
	end

	net.Receive(netStreamSend, function(_, ply)
		local name = net.ReadString()

		local callback = receivers[name]
		if not callback then return end

		local length = net.ReadUInt(17)

		local check = checks[name]
		if check and check(ply, length) == false then return end

		local data = net.ReadData(length)

		local status
		status, data = pcall(mp.unpack, data)
		if not status or not sam.istable(data) then return end

		callback(ply, unpack(data, 1, table_maxn(data)))
	end)
else
	checks = nil

	function netstream.Start(name, ...)
		local encoded_data = pack({...}, select("#", ...))
		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 17)
			net.WriteData(encoded_data, length)
		net.SendToServer()
	end

	function netstream.Hook(name, callback)
		receivers[name] = callback
	end

	net.Receive(netStreamSend, function()
		local callback = receivers[net.ReadString()]
		if not callback then return end

		local length = net.ReadUInt(17)
		local data = net.ReadData(length)

		data = mp.unpack(data)
		callback(unpack(data, 1, table_maxn(data)))
	end)
end

return netstream
--addons/sam/lua/sam/libs/sh_async_netstream.lua:
if SAM_LOADED then return end

local netstream = sam.netstream
netstream.async = {}

if SERVER then
	local IsValid = IsValid
	function netstream.async.Hook(name, fn, check)
		netstream.Hook(name, function(ply, i, ...)
			if not sam.isnumber(i) then return end
			local res = function(...)
				if IsValid(ply) then
					netstream.Start(ply, name, i, ...)
				end
			end
			fn(res, ply, ...)
		end, check)
	end
else
	local count = 0
	local receivers = {}

	local hook_fn = function(i, ...)
		local receiver = receivers[i]
		if receiver[2] then
			receiver[2]()
		end
		receiver[1]:resolve(...)
		receivers[i] = nil
	end

	function netstream.async.Start(name, func_to_call, ...)
		local promise = sam.Promise.new()
		count = count + 1
		receivers[count] = {promise, func_to_call}
		netstream.Hook(name, hook_fn)
		if func_to_call then
			func_to_call()
		end
		netstream.Start(name, count, ...)
		return promise
	end
end
--addons/sam/lua/sam_languages/english.lua:
return {
	You = "You",
	Yourself = "Yourself",
	Themself = "Themself",
	Everyone = "Everyone",

	cant_use_as_console = "You need to be a player to use {S Red} command!",
	no_permission = "You don't have permission to use '{S Red}'!",

	cant_target_multi_players = "You can't target multiple players using this command!",
	invalid_id = "Invalid id ({S Red})!",
	cant_target_player = "You can't target {S Red}!",
	cant_target_self = "You can't target your self using {S Red} command!",
	player_id_not_found = "Player with id {S Red} is not found!",
	found_multi_players = "Found multiple players: {T}!",
	cant_find_target = "Can't find a player to target ({S Red})!",

	invalid = "Invalid {S} ({S_2 Red})",
	default_reason = "none",

	menu_help = "Open admin mod menu.",

	-- Chat Commands
	pm_to = "PM to {T}: {V}",
	pm_from = "PM from {A}: {V}",
	pm_help = "Send a personal message (PM) to a player.",

	to_admins = "{A} to admins: {V}",
	asay_help = "Send a message to admins.",

	mute = "{A} muted {T} for {V}. ({V_2})",
	mute_help = "Stop player(s) from sending messages in chat.",

	unmute = "{A} unmuted {T}.",
	unmute_help = "Unmute player(s).",

	you_muted = "You are muted.",

	gag = "{A} gagged {T} for {V}. ({V_2})",
	gag_help = "Stop player(s) from speaking.",

	ungag = "{A} ungagged {T}.",
	ungag_help = "Ungag player(s).",

	-- Fun Commands
	slap = "{A} slapped {T}.",
	slap_damage = "{A} slapped {T} with {V} damage.",
	slap_help = "Slap asses.",

	slay = "{A} slayed {T}.",
	slay_help = "Slay player(s).",

	set_hp = "{A} set the hp for {T} to {V}.",
	hp_help = "Set health for player(s).",

	set_armor = "{A} set the armor for {T} to {V}.",
	armor_help = "Set armor for player(s).",

	ignite = "{A} ignited {T} for {V}.",
	ignite_help = "Ignite player(s).",

	unignite = "{A} extinguished {T}.",
	unignite_help = "Extinguish player(s).",

	god = "{A} enabled god mode for {T}.",
	god_help = "Enable god mode for player(s).",

	ungod = "{A} disabled god mode for {T}.",
	ungod_help = "Disable god mode for player(s).",

	freeze = "{A} froze {T}.",
	freeze_help = "Freeze player(s).",

	unfreeze = "{A} unfroze {T}.",
	unfreeze_help = "Unfreeze player(s).",

	cloak = "{A} cloaked {T}.",
	cloak_help = "Cloak player(s).",

	uncloak = "{A} uncloaked {T}.",
	uncloak_help = "Uncloak player(s).",

	jail = "{A} jailed {T} for {V}. ({V_2})",
	jail_help = "Jail player(s).",

	unjail = "{A} unjailed {T}.",
	unjail_help = "Unjail player(s).",

	strip = "{A} stripped weapons from {T}.",
	strip_help = "Strip weapons from player(s).",

	respawn = "{A} respawned {T}.",
	respawn_help = "Respawn player(s).",

	setmodel = "{A} set the model for {T} to {V}.",
	setmodel_help = "Change player(s)'s model.",

	giveammo = "{A} gave {T} {V} ammo.",
	giveammo_help = "Give player(s) ammo.",

	scale = "{A} set model scale for {T} to {V}.",
	scale_help = "Scale player(s).",

	freezeprops = "{A} froze all props.",
	freezeprops_help = "Freezes all props on the map.",

	-- Teleport Commands
	dead = "You are dead!",
	leave_car = "Leave the vehicle first!",

	bring = "{A} teleported {T}.",
	bring_help = "Bring a player.",

	goto = "{A} teleported to {T}.",
	goto_help = "Goto a player.",

	no_location = "No previous location to return {T} to.",
	returned = "{A} returned {T}.",
	return_help = "Return a player to where he was.",

	-- User Management Commands
	setrank = "{A} set the rank for {T} to {V} for {V_2}.",
	setrank_help = "Set a player's rank.",
	setrankid_help = "Set a player's rank by his steamid/steamid64.",

	addrank = "{A} created a new rank {V}.",
	addrank_help = "Create a new rank.",

	removerank = "{A} removed rank {V}.",
	removerank_help = "Remove a rank.",

	super_admin_access = "superadmin has access to everything!",

	giveaccess = "{A} granted access {V} to {T}.",
	givepermission_help = "Give permission to rank.",

	takeaccess = "{A} taken access {V} from {T}.",
	takepermission_help = "Take permission from rank.",

	renamerank = "{A} renamed rank {T} to {V}.",
	renamerank_help = "Rename rank.",

	changeinherit = "{A} changed the rank to inherit from for {T} to {V}.",
	changeinherit_help = "Change the rank to inherit from.",

	rank_immunity = "{A} changed rank {T}'s immunity to {V}.",
	changerankimmunity_help = "Change rank immunity.",

	rank_ban_limit = "{A} changed rank {T}'s ban limit to {V}.",
	changerankbanlimit_help = "Change rank ban limit.",

	changeranklimit = "{A} changed {V} limit for {T} to {V_2}.",
	changeranklimit_help = "Change rank limits.",

	-- Utility Commands
	map_change = "{A} changing the map to {V} in 10 seconds.",
	map_change2 = "{A} changing the map to {V} with gamemode {V_2} in 10 seconds.",
	map_help = "Change current map and gamemode.",

	map_restart = "{A} restarting the map in 10 seconds.",
	map_restart_help = "Restart current map.",

	mapreset = "{A} reset the map.",
	mapreset_help = "Reset the map.",

	kick = "{A} kicked {T} Reason: {V}.",
	kick_help = "Kick a player.",

	ban = "{A} banned {T} for {V} ({V_2}).",
	ban_help = "Ban a player.",

	banid = "{A} banned ${T} for {V} ({V_2}).",
	banid_help = "Ban a player using his steamid.",

	-- ban message when admin name doesn't exists
	ban_message = [[


		You are banned by: {S}

		Reason: {S_2}

		You will be unbanned in: {S_3}]],

	-- ban message when admin name exists
	ban_message_2 = [[


		You are banned by: {S} ({S_2})

		Reason: {S_3}

		You will be unbanned in: {S_4}]],

	unban = "{A} unbanned {T}.",
	unban_help = "Unban a player using his steamid.",

	noclip = "{A} has toggled noclip for {T}.",
	noclip_help = "Toggle noclip on player(s).",

	cleardecals = "{A} cleared ragdolls and decals for all players.",
	cleardecals_help = "Clear ragdolls and decals for all players.",

	stopsound = "{A} stopped all sounds.",
	stopsound_help = "Stop all sounds for all players.",

	not_in_vehicle = "You are not in a vehicle!",
	not_in_vehicle2 = "{S Blue} is not in a vehicle!",
	exit_vehicle = "{A} forced {T} to get out from a vehicle.",
	exit_vehicle_help = "Force a player out of a vehicle.",

	time_your = "Your total time is {V}.",
	time_player = "{T} total time is {V}.",
	time_help = "Check a player's time.",

	admin_help = "Activate admin mode.",
	unadmin_help = "Deactivate admin mode.",

	buddha = "{A} enabled buddha mode for {T}.",
	buddha_help = "Make player(s) godmoded when their health is 1.",

	unbuddha = "{A} disabled buddha mode for {T}.",
	unbuddha_help = "Disable buddha mode for player(s).",

	give = "{A} gave {T} {V}.",
	give_help = "Give player(s) weapon/entity",

	-- DarkRP Commands
	arrest = "{A} arrested {T} forever.",
	arrest2 = "{A} arrested {T} for {V} seconds.",
	arrest_help = "Arrest player(s).",

	unarrest = "{A} unarrested {T}.",
	unarrest_help = "Unarrest player(s).",

	setmoney = "{A} set money for {T} to {V}.",
	setmoney_help = "Set money for a player.",

	addmoney = "{A} added {V} for {T}.",
	addmoney_help = "Add money for a player.",

	door_invalid = "invalid door to sell.",
	door_no_owner = "no one owns this door.",

	selldoor = "{A} sold a door/vehicle for {T}.",
	selldoor_help = "Unown the door/vehicle you are looking at.",

	sellall = "{A} sold every door/vehicle for {T}.",
	sellall_help = "Sell every door/vehicle owned for a player.",

	s_jail_pos = "{A} set a new jail position.",
	setjailpos_help = "Resets all jail positions and sets a new one at your location.",

	a_jail_pos = "{A} added a new jail position.",
	addjailpos_help = "Adds a jail position at your current location.",

	setjob = "{A} set {T}'s job to {V}.",
	setjob_help = "Change a player's job.",

	shipment = "{A} spawned {V} shipment.",
	shipment_help = "Spawn a shipment.",

	forcename = "{A} set the name for {T} to {V}.",
	forcename_taken = "Name already taken. ({V})",
	forcename_help = "Force name for a player.",

	report_claimed = "{A} claimed a report submitted by {T}.",
	report_closed = "{A} closed a report submitted by {T}.",
	report_aclosed = "Your report is closed. (Time expired)",

	rank_expired = "{V} rank for {T} expired.",

	-- TTT Commands
	setslays = "{A} set amount of auto-slays for {T} to {V}.",
	setslays_help = "Set amount of rounds to auto-slay a player for.",

	setslays_slayed = "{T} got auto-slayed, slays left: {V}.",

	removeslays = "{A} removed auto-slays for {T}.",
	removeslays_help = "Remove auto-slays for a player."
}
--addons/sam/lua/sam/sh_permissions.lua:
if SAM_LOADED then return end

local permissions = {}

local give_permission
if SERVER then
	local permissions_to_add = {}

	give_permission = function(name, permission)
		if sam.ranks.ranks_loaded() then
			local rank = sam.ranks.get_rank(name)
			if rank and rank.data.permissions[permission] == nil then
				sam.ranks.give_permission(name, permission)
			end
		else
			table.insert(permissions_to_add, {name, permission})
		end
	end

	hook.Add("SAM.LoadedRanks", "SAM.Command.GivePermissions", function()
		for k, v in ipairs(permissions_to_add) do
			give_permission(v[1], v[2])
		end
	end)
end

local get_next_Other = function()
	for i, v in ipairs(permissions) do
		if v.category == "Other" then
			return i
		end
	end
	return #permissions + 1
end

function sam.permissions.add(permission, category, rank)
	if not sam.isstring(category) then
		category = "Other"
	end

	local permission_data = {
		name = permission,
		category = category,
		rank = rank,
		value = value
	}

	local index = sam.permissions.get_index(permission)
	if not index then
		if category ~= "Other" then
			table.insert(permissions, get_next_Other(), permission_data)
		else
			table.insert(permissions, permission_data)
		end
		hook.Call("SAM.AddedPermission", nil, permission, category, rank, value)
	else
		permissions[index] = permission_data
		hook.Call("SAM.PermissionModified", nil, permission, category, rank, value)
	end

	if SERVER and rank then
		give_permission(rank, permission)
	end
end

function sam.permissions.get_index(permission)
	for i, v in ipairs(permissions) do
		if v.name == permission then
			return i
		end
	end
end

function sam.permissions.remove(permission)
	local index = sam.permissions.get_index(permission)
	if index then
		table.remove(permissions, index)
		hook.Call("SAM.RemovedPermission", nil, permission)
	end
end

function sam.permissions.exists(permission)
	return sam.permissions.get_index(permission) and true or false
end

function sam.permissions.get()
	return permissions
end
--addons/sui/lua/sui/libs/types.lua:
-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sui.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sui["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sui.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sui.IsEntity = sui.isentity

local type = sui.type
function sui.istable(value)
	return type(value) == "table"
end
--addons/sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--addons/sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs
local RealFrameTime = RealFrameTime

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + (14 * RealFrameTime() --[[ slowly increase scroll speed ]])
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- ¯\_(ツ)_/¯ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 14
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 14, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")
--addons/sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--addons/sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/sam/lua/sui/vgui/sam_player_line.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TDLib = sui.TDLib
local draw_material = sui.draw_material
local lerp_color = sui.lerp_color

local GetColor = SUI.GetColor
local RoundedBox = TDLib.RoundedBox
local CircleAvatar = TDLib.LibClasses.CircleAvatar
local CircleClick2 = TDLib.LibClasses.CircleClick2

local PLAYER_LINE_NAME = SUI.CreateFont("PlayerLineName", "Roboto Bold", 17)
local PLAYER_LINE_RANK = SUI.CreateFont("PlayerLineRank", "Roboto Bold", 13)
local PLAYER_LINE_STEAMID = SUI.CreateFont("PlayerLineSteamID", "Roboto Medium", 12)

local PANEL = {}

function PANEL:Init()
	local size = SUI.Scale(34)

	self:Dock(TOP)
	self:SetTall(size)

	self.size = size
end

local rank_Paint = function(s, w, h)
	RoundedBox(s.rect, SUI.Scale(10), 0, 0, w, h, s.col)
end

function PANEL:SetInfo(info)
	local size = self.size

	local container
	do
		local w = SUI.Scale(280) + size

		local _container = self:Add("Panel")
		_container:Dock(LEFT)
		_container:SetMouseInputEnabled(false)
		_container:SetWide(w)

		container = _container:Add("Panel")
		container:SetSize(w, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	do
		local avatar = container:Add("Panel")
		avatar:Dock(LEFT)
		avatar:DockMargin(0, 0, 5, 0)
		avatar:SetWide(size)
		avatar:SetMouseInputEnabled(false)
		CircleAvatar(avatar)

		avatar:SetSteamID(util.SteamIDTo64(info.steamid), size)
	end

	do
		local top_container = container:Add("Panel")
		top_container:Dock(TOP)
		top_container:DockMargin(0, 0, 0, 2)

		local name = top_container:Add("SAM.Label")
		name:Dock(LEFT)
		name:SetFont(PLAYER_LINE_NAME)
		self.name = name

		local pname = info.name
		if not pname or pname == "" then
			name:SetTextColor(GetColor("player_list_names_2"))
			self:SetName("N/A")
		else
			name:SetTextColor(GetColor("player_list_names"))
			self:SetName(pname)
		end

		if info.rank then
			local rank_bg = top_container:Add("Panel")
			rank_bg:Dock(LEFT)
			rank_bg:DockMargin(5, 0, 0, 0)

			rank_bg.rect = {}
			rank_bg.col = info.rank_bg or GetColor("player_list_rank")
			rank_bg.Paint = rank_Paint

			local rank = rank_bg:Add("SAM.Label")
			rank:Dock(FILL)
			rank:DockMargin(SUI.Scale(8), 0, 0, 0)
			rank:SetTextColor(GetColor("player_list_rank_text"))
			rank:SetFont(PLAYER_LINE_RANK)
			rank.bg = rank_bg

			self.rank = rank
			self:SetRank(info.rank)

			rank_bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
		end

		top_container:SizeToChildren(true, true)
	end

	local steamid = container:Add("SAM.Label")
	steamid:Dock(TOP)
	steamid:SetTextColor(GetColor("player_list_steamid"))
	steamid:SetFont(PLAYER_LINE_STEAMID)
	steamid:SetText(info.steamid)
	steamid:SizeToContents()
	steamid:SetAutoStretchVertical(true)

	self.container = container
end

function PANEL:SetName(new_name)
	local name =  self.name
	name:SetText(new_name)
	name:SizeToContents()
	if name:GetWide() > 160 then
		name:SetWide(158)
	end
end

function PANEL:SetRank(new_rank)
	local rank = self.rank
	rank:SetText(new_rank)
	rank:SizeToContents()
	rank.bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
end

function PANEL:Actions()
	local container
		do
		local size = self.size

		local _container = self:Add("Panel")
		_container:Dock(RIGHT)
		_container:SetWide(size)

		container = _container:Add("Panel")
		container:SetSize(size, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	local actions_button = container:Add("SAM.Button")
	actions_button:SetText("")
	actions_button:ClearPaint()

	function container:PerformLayout(w, h)
		actions_button:SetSize(h, h)
		actions_button:Center()
	end

	local image = actions_button:Add("SAM.Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/dots_verticle.png")

	local current_icon_color = Color(GetColor("actions_button_icon"):Unpack())
	function image:Draw(w, h)
		if not h then return end

		if actions_button.Hovered then
			lerp_color(current_icon_color, GetColor("actions_button_icon_hover"))
		else
			lerp_color(current_icon_color, GetColor("actions_button_icon"))
		end

		draw_material(nil, w / 2, h / 2, SUI.ScaleEven(20), current_icon_color)
	end

	CircleClick2(actions_button, Color(62, 62, 62), 10)
	actions_button:Center()

	return actions_button
end

sui.register("PlayerLine", PANEL, "Panel")
--addons/sam/lua/sam/menu/tabs/config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local tabs = {}
if CLIENT then
	function config.add_tab(name, func, check, pos)
		local tab = {
			name = name,
			func = func,
			check = check,
			pos = pos
		}
		for k, v in ipairs(tabs) do
			if v.name == name then
				tabs[k] = tab
				return
			end
		end
		table.insert(tabs, tab)
	end
end

for _, f in ipairs(file.Find("sam/menu/tabs/config/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/config/" .. f, "cl_")
end

if SERVER then return end

local SUI = sam.SUI
local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/config.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Config")
		title:SetTextColor(GetColor("menu_tabs_title"))
		title:SizeToContents()

		local total = tab_body:Add("SAM.Label")
		total:Dock(TOP)
		total:DockMargin(10, 6, 0, 0)
		total:SetFont(SAM_TAB_DESC_FONT)
		total:SetText("Some settings may require a server restart")
		total:SetTextColor(GetColor("menu_tabs_title"))
		total:SetPos(10, SUI.Scale(40))
		total:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body, nil, 0, 0, 0, 10)

	local sheet = body:Add("SAM.PropertySheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.name] = sheet:AddSheet(v.name, v.func)
	end

	local tab_scroller = sheet.tab_scroller:GetCanvas()
	function tab_body.Think()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.name]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end

	return tab_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 5)
--addons/sam/lua/sam/modules/ttt.lua:
if SAM_LOADED then return end

local run = function(fn)
	if not GAMEMODE then
		timer.Simple(0, fn)
	else
		fn()
	end
end

run(function()
	if engine.ActiveGamemode() ~= "terrortown" then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("TTT")

	command.new("setslays")
		:SetPermission("setslays", "admin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", optional = true, min = 1, default = 1, round = true})

		:Help("setslays_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:sam_set_pdata("slays_amount", amount)

			sam.player.send_message(nil, "setslays", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("removeslays")
		:SetPermission("removeslays", "admin")

		:AddArg("player", {single_target = true})

		:Help("removeslays_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]
			target:sam_set_pdata("slays_amount", nil)
			target:SetForceSpec(false)

			sam.player.send_message(nil, "removeslays", {
				A = ply, T = targets
			})
		end)
	:End()

	OldBeginRound = OldBeginRound or BeginRound
	function BeginRound(...)
		local players = player.GetAll()
		for i = 1, #players do
			local ply = players[i]

			local slays = ply:sam_get_pdata("slays_amount")
			if not slays then continue end

			if not ply:IsSpec() then
				ply:Kill()
			end

			GAMEMODE:PlayerSpawnAsSpectator(ply)

			ply:SetTeam(TEAM_SPEC)
			ply:SetForceSpec(true)
			ply:Spawn()

			ply:SetRagdollSpec(false) -- dying will enable this, we don't want it here

			slays = slays - 1

			if slays == 0 then
				timer.Simple(0, function()
					ply:SetForceSpec(false)
				end)
				ply:sam_set_pdata("slays_amount", nil)
			else
				ply:sam_set_pdata("slays_amount", slays)
			end

			sam.player.send_message(nil, "setslays_slayed", {
				T = {ply}, V = slays
			})
		end

		return OldBeginRound(...)
	end
end)
--addons/sam/lua/sam/cl_adverts.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local times = {}

local entry_OnValueChange = function(s)
	s:SetTall(s:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
end

local entry_OnEnter = function(s)
	local ads = config.get("Adverts")
	local txt = s:GetText()
	if txt == "" then
		s:Remove()
		if s.i then
			table.remove(ads, s.i)
		end
	else
		if txt == s.ad then return end
		ads[s.i] = txt
		s.ad = txt
	end
	config.set("Adverts", ads, true)
end

local entry_OnKeyCodeTyped = function(s, code)
	if code == KEY_ENTER then
		s:old_OnKeyCodeTyped(code)
		return true
	else
		return s:old_OnKeyCodeTyped(code)
	end
end

config.add_menu_setting("Adverts", function(body)
	local adverts_body

	local adverts = body:Add("SAM.LabelPanel")
	adverts:Dock(TOP)
	adverts:DockMargin(8, 6, 8, 0)
	adverts:SetLabel("Adverts\n- Random adverts print every 60 seconds\n- Timed adverts can be done like this: {1m} This advert prints every 1 minute")

	local add_advert = adverts:Add("SAM.Button")
	add_advert:SetText("+")
	add_advert:SetSize(25, 25)

	local zpos = 0
	local add_func = function(ad, ad_i)
		zpos = zpos + 1

		local entry = adverts_body:Add("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetNoBar(true)
		entry:Dock(TOP)
		entry:DockMargin(8, 6, 8, 0)
		entry:SetZPos(zpos)
		entry.ad = ad
		entry.no_scale = true

		if not sam.ispanel(ad) then
			entry.i = ad_i
			entry:SetValue(ad)
		else
			entry.i = #config.get("Adverts") + 1
		end

		entry.OnValueChange = entry_OnValueChange
		entry.OnEnter = entry_OnEnter
		entry.old_OnKeyCodeTyped = entry.OnKeyCodeTyped
		entry.OnKeyCodeTyped = entry_OnKeyCodeTyped
	end
	add_advert:On("DoClick", add_func)

	adverts_body = body:Add("Panel")
	adverts_body:Dock(TOP)

	function adverts_body:PerformLayout(w, h)
		for k, v in ipairs(self:GetChildren()) do
			entry_OnValueChange(v)
		end
		self:SizeToChildren(false, true)
	end

	sam.config.hook({"Adverts"}, function()
		if not IsValid(adverts_body) then return end
		adverts_body:Clear()

		for k, v in ipairs(config.get("Adverts")) do
			add_func(v, k)
		end
	end)
end)

local random = {}

timer.Create("SAM.Advert.RandomAdverts", 60, 0, function()
	local ad = random[math.random(1, #random)]
	if not ad then return end
	sam.player.send_message(nil, ad)
end)

sam.config.hook({"Adverts"}, function()
	for i = #times, 1, -1 do
		times[i] = nil
		timer.Remove("SAM.Adverts." .. i)
	end

	random = {}
	for k, v in ipairs(config.get("Adverts")) do
		if v:sub(1, 1) == "{" then
			local time
			time, v = v:match("(%b{}) *(.*)")
			time = sam.parse_length(time)
			if time then
				timer.Create("SAM.Adverts." .. table.insert(times, true), time * 60, 0, function()
					sam.player.send_message(nil, v)
				end)
			end
		else
			table.insert(random, v)
		end
	end
end)
--lua/autorun/saw.lua:
player_manager.AddValidModel( "Saw Gerrera", "models/player/TCW/human/saw_gerrera.mdl" );
--addons/scb_chatbox/lua/autorun/scb.lua:
if SCB_LOADED then return end

local types = {
	sv_ = SERVER and include or function() end,
	cl_ = SERVER and AddCSLuaFile or include,
	sh_ = function(name)
		if SERVER then
			AddCSLuaFile(name)
		end
		return include(name)
	end
}

local load_file = function(name, no, type)
	if not no then
		name = "scb/" .. name
	end

	local func = types[type or name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
	if func then
		return func(name)
	end
end

scb = {
	config = {}
}

function scb.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(65, 185, 255), "SCB",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

scb.print("Loading...")

	file.CreateDir("scb")

	require("sui")
	if CLIENT then
		scb.SUI = sui.new("SCB")
	end

	load_file("libs/sh_types.lua")
	scb.mp = load_file("libs/message_pack/sh_messagepack.lua")

	load_file("sh_scb_config.lua", true)

	for _, permissions in pairs(scb.config.permissions) do
		for k, v in ipairs(permissions) do
			if v ~= true then
				permissions[v], permissions[k] = true, nil
			end
		end
	end

	if SERVER then
		for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
			AddCSLuaFile("scb/settings/tabs/" .. f)
		end
	end

	load_file("cl_util.lua")
	load_file("settings/cl_settings.lua")
	load_file("sh_chatbox.lua")
	load_file("sv_chatbox.lua")
	load_file("cl_chatbox.lua")
	load_file("cl_overrides.lua")

	if SERVER then
		AddCSLuaFile("scb/cl_emojis_data.lua", "GAME")

		-- emojis need to be loaded once the player joins, so things like this https://www.gmodstore.com/market/view/4868 could break it
		local AddWorkshop = resource.OldAddWorkshop or resource.AddWorkshop
		AddWorkshop("1998633255")
	end

	for _, f in ipairs(file.Find("scb/vgui/*.lua", "LUA")) do
		load_file("vgui/" .. f, false, "cl_")
	end

scb.print("Loaded!")

SCB_LOADED = true
--addons/sui/lua/sui/vgui/sui_menu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4

function PANEL:Init()
	self:DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:PerformLayout()
	local w, h = self:ChildrenSize()
	self:SetSize(math.max(self:GetMinimumWidth(), w), h)
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--addons/scb_chatbox/lua/scb/libs/sh_types.lua:
if SCB_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function scb.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		scb["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function scb.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
scb.IsEntity = scb.isentity

local type = scb.type
function scb.istable(value)
	return type(value) == "table"
end
--addons/scb_chatbox/lua/sh_scb_config.lua:
if SCB_LOADED then return end

local config = scb.config

--
-- Chatbox title!@!
-- SERVER_NAME will be replaced with your server name
-- PLAYER_COUNT will be replaced with your online player count
-- EG.
-- config.chatbox_title = "SERVER_NAME (PLAYER_COUNT)" -- > Srlion Gaming (1)
--
config.chatbox_title = "SERVER_NAME"

--
-- By default it uses 12h format, for 24h use "%H:%M:%S"
--
config.timestamps_format = "%H:%M:%S"

--
-- Allow parsing in chat print functions? (chat.AddText/Player:ChatPrint/Player:PrintMessage)
-- If it causes problems then disable it.
--
config.parse_in_chat = true

--
-- Hide language sign that appears behing emojis if you are typing in a non-English language
--
config.hide_language_sign = true

--
-- Enable the custom join messages
--
config.enable_custom_join_messages = false

--
-- Enable the custom leave messages
--
config.enable_custom_leave_messages = false

--
-- Enable avatars
--
config.enable_avatars = true

--
-- You can use SteamID/SteamID64/Ranks
-- If the first value is 'true' then anyone can use it
--
config.permissions = {
	--
	-- Who can add/remove/edit emojis & tags?
	--
	menu = {
		"gruender",
		"communityleitung",
		"superadmin",
	},

	--
	-- Who can use rainbow texts?
	-- Eg.
	-- hi there {* everyone}!
	--
	rainbow = {
	true,
	},

	--
	-- Who can use flashing texts?
	-- Eg.
	-- hi there {! everyone}!
	--
	flashing = {
		true,
	},

	--
	-- Who can use colored texts?
	-- Eg.
	-- hi there {red Srlion}!
	-- hi there {#ff0000 Srlion}!
	--
	colored_texts = {
		true,
	},

	--
	-- Who can use custom emojis?
	--
	custom_emojis = {
		"gruender",
		"communityleitung",
		"superadmin",
		"admin"
	}
}

--
-- You can add colors that can be used in chatbox, eg. {my_new_color hi there!}
-- Use something like https://www.hexcolortool.com to get hex codes!
--
config.colors = {
	red = "f44336",
	pink = "E91E63",
	purple = "9C27B0",
	blue = "1773c4",
	cyan = "00BCD4",
	green = "4CAF50",
	yellow = "FFEB3B",
	orange = "FF9800",
	brown = "7b5804",
	grey = "9E9E9E",
	white = "E0E0E0",
	black = "080808"
}

scb.language = {
	save = "SPEICHERN",
	cancel = "ABBRECHEN",
	edit = "Bearbeiten",
	search = "Suchen...",
	team = "TEAM",
	dead = "*TOT* ",
	console = "Konsole",
	remove = "Entfernen",

	type_something = "Tippe etwas...",

	settings_title = "Einstellungen",

	client_title = "Client",
	tags_title = "Tags",
	emojis_title = "Emojis",

	show_avatars = "Avatare anzeigen",
	show_time = "Timestamps anzeigen",
	disable_rainbow = "Regenbogenfarben deaktivieren",
	disable_flashing = "Blinkder Text deaktivieren",
	blur_theme = "Blur Theme",
	join_messages = "Join/Disconnect Nachrichten",
	scale = "Scale",
	messages_fade = "Nachrichten - Ausblendzeit",
	max_messages = "Maximale Nachrichten",
	reset_size = "Fenstergröße Zurücksetzen",
	reset_position = "Fensterposition Zurücksetzen",
	clear_reload = "Bilder Neuladen (Kann Probleme mit veralteten Bildern beheben, die noch geladen sind.)",

	add_tag = "Tag hinzufügen",
	tag_owner = "SteamID/SteamID64/Rang",
	tag = "Tag",

	add_emoji = "Emoji hinzufügen",
	emoji_name = "Name",
	emoji_url = "URL",

	copy_text = "Text kopieren",
	copy_message = "Nachricht kopieren",
	copy_steamid = "Steamid kopieren",
	copy_steamid64 = "Steamid64 kopieren",
	show_profile = "Spielerprofil anzeigen",
	copy_time = "Nachrichtenzeit anzeigen",
	copy_url = "URL kopieren",

	bot_joined = "{#1773c4 NAME} hat das Spiel betreten",
	bot_left = "{#f44336 NAME} hat das Spiel verlassen",

	-- STEAMID gets replaced by the player steamid
	player_connecting = "{#1773c4 NAME} verbindet sich",
	player_left = "{#f44336 NAME} hat das Spiel verlassen: REASON",
}
--addons/scb_chatbox/lua/scb/cl_emojis_data.lua:
return {["jack_o_lantern"]="41",["sloth"]="254",["flag_nl"]="8179",["man_raising_hand"]="1240",["crossed_swords"]="6187",["flag_ck"]="853",["flag_mn"]="8160",["woman_kiss_man"]="1447",["heartpulse"]="1120",["man_girl"]="1472",["flag_se"]="8210",["woman_with_probing_cane"]="1372",["flag_bd"]="827",["rolled_up_newspaper"]="6117",["fog"]="5195",["flag_af"]="811",["aries"]="760",["japan"]="56",["arrow_forward"]="776",["stadium"]="517",["five"]="7139",["flag_kr"]="8135",["guitar"]="663",["woman_kiss_woman"]="1449",["flag_ro"]="8202",["man_getting_massage"]="1356",["exclamation"]="7127",["flag_gt"]="8103",["princess"]="1315",["skunk"]="256",["world_map"]="55",["flag_sm"]="8217",["crab"]="380",["flag_bl"]="834",["grey_exclamation"]="7126",["rainbow"]="5198",["woman_mountain_biking"]="1421",["racing_motorcycle"]="592",["deaf_person"]="1242",["kangaroo"]="257",["stethoscope"]="6212",["flag_cz"]="865",["spider"]="2101",["man_girl_boy"]="1473",["smirk"]="137",["ophiuchus"]="772",["flag_uy"]="8249",["cool"]="7154",["woman_getting_massage"]="1357",["whale"]="285",["frog"]="276",["man_standing"]="1365",["running_shirt_with_sash"]="451",["wind_chime"]="414",["imp"]="192",["thought_balloon"]="1148",["biohazard_sign"]="726",["m"]="7158",["sparkler"]="44",["jigsaw"]="465",["clock430"]="5149",["bust_in_silhouette"]="1481",["wine_glass"]="3105",["no_bicycles"]="718",["sneezing_face"]="152",["carousel_horse"]="558",["flag_ps"]="8196",["chipmunk"]="248",["ant"]="297",["man_running"]="1380",["nine"]="7143",["bamboo"]="411",["facepunch"]="1171",["earth_africa"]="51",["woman_running"]="1381",["lower_left_fountain_pen"]="6147",["wedding"]="538",["disappointed_relieved"]="176",["clock530"]="5151",["man_woman_girl_girl"]="1459",["computer"]="677",["mantelpiece_clock"]="5139",["woman_heart_woman"]="1453",["broom"]="6223",["trackball"]="682",["martial_arts_uniform"]="445",["lemon"]="35",["flag_qa"]="8200",["surfer"]="1401",["child"]="1199",["flag_cr"]="859",["male_singer"]="1288",["rice_scene"]="415",["metro"]="568",["flag_jo"]="8126",["drum_with_drumsticks"]="668",["black_right_pointing_double_triangle_with_vertical_bar"]="778",["blue_heart"]="1131",["house_buildings"]="521",["male_judge"]="1264",["wheelchair"]="74",["field_hockey_stick_and_ball"]="439",["fish_cake"]="374",["spoon"]="3119",["man_woman_boy_boy"]="1458",["dark_sunglasses"]="62",["lock_with_ink_pen"]="6177",["u5408"]="7178",["man_in_business_suit_levitating"]="1384",["raised_back_of_hand"]="1151",["probing_cane"]="6196",["currency_exchange"]="6130",["person_in_lotus_position"]="1437",["flag_pk"]="8191",["flag_ua"]="8244",["hot_pepper"]="323",["large_orange_circle"]="7185",["male_firefighter"]="1300",["paperclip"]="6167",["flag_km"]="8132",["pizza"]="346",["massage"]="1355",["female_astronaut"]="1298",["postbox"]="6143",["railway_track"]="5102",["label"]="6120",["microscope"]="6205",["mask"]="147",["ramen"]="368",["boxing_glove"]="444",["man_walking"]="1362",["jeans"]="68",["flag_iq"]="8120",["statue_of_liberty"]="540",["flag_bw"]="843",["flag_my"]="8171",["axe"]="6182",["money_with_wings"]="6126",["tophat"]="636",["flag_no"]="8180",["milky_way"]="5184",["flag_cu"]="860",["on"]="745",["flag_tk"]="8234",["high_brightness"]="793",["flag_eh"]="877",["arrow_double_up"]="784",["white_flower"]="2108",["flag_gb"]="889",["male_astronaut"]="1297",["face_palm"]="1248",["llama"]="237",["bald_man"]="1209",["angel"]="1325",["female_doctor"]="1256",["flag_om"]="8185",["abacus"]="687",["abcd"]="7146",["printer"]="679",["man_kiss_man"]="1448",["moyai"]="6233",["construction"]="5109",["arrow_upper_right"]="728",["man_dancing"]="1383",["female_artist"]="1292",["smile_cat"]="1104",["pig"]="228",["flag_sl"]="8216",["star2"]="5182",["tennis"]="435",["radio"]="661",["beers"]="3109",["custard"]="397",["blue_book"]="6108",["flag_bo"]="837",["flag_mq"]="8163",["flag_ls"]="8145",["flag_hk"]="8107",["volcano"]="510",["weary"]="184",["spider_web"]="2102",["sweat_smile"]="16",["leaves"]="2127",["car"]="585",["white_haired_man"]="1208",["flag_cm"]="855",["flag_tz"]="8243",["art"]="477",["pouch"]="623",["flag_ng"]="8177",["rooster"]="262",["boom"]="1138",["supervillain"]="1331",["u7121"]="7174",["earth_americas"]="52",["clock11"]="5162",["six"]="7140",["shopping_bags"]="624",["mushroom"]="329",["wc"]="79",["ng"]="7160",["flag_lc"]="8141",["flag_ge"]="891",["hatched_chick"]="265",["flag_pr"]="8195",["clock3"]="5146",["diamonds"]="469",["unlock"]="6176",["o"]="7106",["credit_card"]="6127",["flags"]="413",["mailbox_with_no_mail"]="6142",["softball"]="430",["melon"]="32",["bride_with_veil"]="1322",["unamused"]="138",["taco"]="349",["helicopter"]="5124",["snow_cloud"]="5192",["nazar_amulet"]="460",["goat"]="234",["flag_aq"]="817",["repeat_one"]="775",["astonished"]="169",["newspaper"]="6116",["speaking_head_in_silhouette"]="1480",["lower_left_crayon"]="6150",["purple_heart"]="1132",["athletic_shoe"]="627",["dancers"]="1385",["large_blue_circle"]="7188",["fries"]="345",["flag_lk"]="8143",["u7533"]="7177",["cinema"]="791",["flag_tr"]="8239",["pray"]="1179",["man_playing_water_polo"]="1429",["womans_clothes"]="620",["musical_note"]="654",["confused"]="163",["no_entry_sign"]="717",["calling"]="670",["cookie"]="389",["pushpin"]="6165",["female_pilot"]="1295",["weight_lifter"]="1413",["admission_tickets"]="420",["gift"]="418",["lightning"]="5193",["restroom"]="77",["broccoli"]="326",["manual_wheelchair"]="594",["sagittarius"]="768",["no_mobile_phones"]="723",["purse"]="621",["sunflower"]="2113",["double_vertical_bar"]="787",["om_symbol"]="750",["flag_za"]="8263",["flushed"]="170",["male_pilot"]="1294",["curry"]="367",["chair"]="6216",["panda_face"]="253",["large_blue_square"]="7197",["lollipop"]="396",["oden"]="371",["flying_disc"]="436",["flag_ai"]="813",["ice_cream"]="387",["flag_gg"]="893",["cow2"]="227",["sleuth_or_spy"]="1305",["high_heel"]="630",["flag_hr"]="8110",["fearful"]="174",["flag_mx"]="8170",["flag_nf"]="8176",["person_in_steamy_room"]="1388",["joystick"]="462",["garlic"]="327",["speaker"]="645",["video_camera"]="695",["male_farmer"]="1267",["flag_tj"]="8233",["female_detective"]="1307",["see_no_evil"]="1112",["dromedary_camel"]="235",["ear_of_rice"]="2121",["heavy_minus_sign"]="7114",["male_supervillain"]="1332",["straight_ruler"]="6169",["robot_face"]="1102",["flag_bv"]="842",["sparkling_heart"]="1119",["trumpet"]="665",["no_entry"]="716",["up"]="7165",["flag_dk"]="869",["ledger"]="6112",["headphones"]="660",["full_moon"]="5168",["no_smoking"]="719",["flag_pm"]="8193",["couplekiss"]="1446",["flag_cd"]="848",["chart_with_upwards_trend"]="6161",["two_women_holding_hands"]="1443",["man_woman_boy"]="1455",["tiger2"]="217",["sunrise_over_mountains"]="552",["flag_bf"]="829",["man_woman_girl"]="1456",["flag_so"]="8219",["hugging_face"]="128",["flag_mp"]="8162",["clock1030"]="5161",["yum"]="122",["chart"]="6129",["ox"]="225",["camping"]="512",["bath"]="1440",["onion"]="328",["rice_cracker"]="364",["beverage_box"]="3113",["flag_hu"]="8112",["clock830"]="5157",["flag_cl"]="854",["large_yellow_circle"]="7186",["last_quarter_moon_with_face"]="5175",["handball"]="1431",["spiral_note_pad"]="6158",["flag_tm"]="8236",["female_construction_worker"]="1313",["female_office_worker"]="1280",["yellow_heart"]="1129",["hotsprings"]="557",["beach_with_umbrella"]="513",["flag_bn"]="836",["shield"]="6190",["film_projector"]="690",["o2"]="7161",["ok_woman"]="1233",["flag_lb"]="8140",["flag_gd"]="890",["package"]="6138",["clock2"]="5144",["candle"]="699",["clock10"]="5160",["person_with_blond_hair"]="1203",["elephant"]="239",["small_red_triangle_down"]="7213",["man_man_girl"]="1461",["koko"]="7167",["elf"]="1346",["clock630"]="5153",["camera"]="693",["money_mouth_face"]="127",["first_quarter_moon"]="5166",["male_sign"]="798",["duck"]="270",["snow_capped_mountain"]="58",["clown_face"]="196",["no_bell"]="652",["flag_kw"]="8136",["kiwifruit"]="315",["tanabata_tree"]="410",["eyeglasses"]="61",["ok_hand"]="1155",["last_quarter_moon"]="5170",["lower_left_paintbrush"]="6149",["anguished"]="173",["womans_hat"]="635",["parking"]="7163",["flag_sg"]="8211",["wrestlers"]="1425",["closed_lock_with_key"]="6178",["circus_tent"]="562",["expressionless"]="135",["symbols"]="7148",["wrench"]="6191",["flag_lu"]="8147",["fire"]="5208",["phone"]="671",["flag_gn"]="898",["scarf"]="69",["man_gesturing_no"]="1231",["two_hearts"]="1123",["arrows_clockwise"]="741",["airplane_arriving"]="5121",["movie_camera"]="688",["man_man_girl_girl"]="1464",["woman_frowning"]="1226",["orange_book"]="6109",["petri_dish"]="6203",["clipboard"]="6164",["clock130"]="5143",["question"]="7124",["flag_yt"]="8262",["iphone"]="669",["dolls"]="412",["tea"]="3102",["three"]="7137",["flag_pt"]="8197",["baby_bottle"]="399",["film_frames"]="689",["spiral_calendar_pad"]="6159",["waxing_crescent_moon"]="5165",["octagonal_sign"]="5108",["male_construction_worker"]="1312",["shirt"]="67",["maple_leaf"]="2125",["female_police_officer"]="1304",["barber"]="561",["man_wrestling"]="1426",["menorah_with_nine_branches"]="758",["woman"]="1210",["burrito"]="350",["ballot_box_with_ballot"]="6144",["bus"]="575",["bell"]="651",["hamster"]="245",["heart_decoration"]="1124",["grinning"]="11",["man_boy"]="1470",["bulb"]="6100",["small_orange_diamond"]="7210",["flag_tt"]="8240",["secret"]="7181",["congratulations"]="7180",["male_superhero"]="1329",["chart_with_downwards_trend"]="6162",["flag_sv"]="8223",["part_alternation_mark"]="7118",["wavy_dash"]="7128",["yo_yo"]="456",["white_large_square"]="7201",["black_large_square"]="7200",["left_luggage"]="713",["arrow_down"]="731",["flag_is"]="8122",["small_red_triangle"]="7212",["tractor"]="590",["green_book"]="6107",["sleeping_accommodation"]="1441",["baseball"]="429",["thumbsdown"]="1169",["arrow_up"]="727",["shell"]="293",["arrow_heading_down"]="740",["arrow_heading_up"]="739",["koala"]="252",["desert"]="514",["loop"]="7117",["flag_vi"]="8255",["flag_pl"]="8192",["children_crossing"]="715",["lizard"]="279",["curly_loop"]="7116",["arrow_right"]="729",["middle_finger"]="1165",["heavy_division_sign"]="7115",["second_place_medal"]="426",["rowboat"]="1404",["stars"]="5183",["heavy_heart_exclamation_mark_ornament"]="1125",["flag_td"]="8229",["grey_question"]="7125",["cat2"]="214",["flag_ne"]="8175",["x"]="7111",["sparkle"]="7121",["flag_ye"]="8261",["flag_kg"]="8129",["bar_chart"]="6163",["hocho"]="3120",["snowflake"]="5204",["potable_water"]="73",["flag_jp"]="8127",["santa"]="1326",["accept"]="7176",["star_of_david"]="751",["busts_in_silhouette"]="1482",["eyes"]="1194",["wave"]="1150",["heavy_multiplication_x"]="7110",["heavy_check_mark"]="7109",["cocktail"]="3106",["black_nib"]="6146",["full_moon_with_face"]="5178",["pencil2"]="6145",["thermometer"]="5176",["flag_de"]="866",["calendar"]="6157",["flag_gw"]="8105",["flag_ht"]="8111",["writing_hand"]="1180",["v"]="1157",["rocket"]="5129",["point_up"]="1167",["email"]="6132",["door"]="6213",["satellite"]="5128",["scissors"]="6171",["zap"]="5203",["clock5"]="5150",["loudspeaker"]="648",["flag_by"]="844",["church"]="541",["footprints"]="1483",["fuelpump"]="5104",["tent"]="548",["flag_sn"]="8218",["capricorn"]="769",["customs"]="711",["person_with_ball"]="1410",["rice"]="366",["smiley_cat"]="1103",["hotel"]="530",["woman_bouncing_ball"]="1412",["man_heart_man"]="1452",["ice_skate"]="448",["skier"]="1396",["boat"]="5111",["flag_ms"]="8165",["female_fairy"]="1339",["female_cook"]="1271",["snowman"]="5205",["woman_girl_girl"]="1479",["palm_tree"]="2119",["european_post_office"]="527",["ferry"]="5115",["dress"]="613",["flag_dm"]="870",["golf"]="447",["female_supervillain"]="1333",["flag_zm"]="8264",["vibration_mode"]="795",["flag_uz"]="8250",["flag_wf"]="8258",["umbrella_on_ground"]="5202",["ribbon"]="417",["point_left"]="1162",["mouse2"]="243",["mountain"]="59",["shinto_shrine"]="545",["blond_haired_woman"]="1219",["large_purple_circle"]="7189",["orange_heart"]="1128",["flag_scotland"]="8267",["sunrise"]="553",["helmet_with_white_cross"]="639",["man_wearing_turban"]="1317",["pick"]="6183",["anchor"]="5110",["partly_sunny"]="5186",["snowman_without_snow"]="5206",["busstop"]="5100",["flag_na"]="8173",["loud_sound"]="647",["rat"]="244",["file_cabinet"]="6173",["beginner"]="7105",["flag_mc"]="8151",["fleur_de_lis"]="7102",["musical_score"]="653",["desktop_computer"]="678",["kiss"]="1115",["frowning"]="172",["postal_horn"]="650",["coffin"]="6231",["linked_paperclips"]="6168",["man_boy_boy"]="1471",["black_circle"]="7191",["tooth"]="1192",["warning"]="714",["face_with_cowboy_hat"]="158",["clock230"]="5145",["four_leaf_clover"]="2124",["flag_lt"]="8146",["meat_on_bone"]="340",["flag_sc"]="8208",["first_place_medal"]="425",["kissing_closed_eyes"]="120",["alembic"]="6201",["ticket"]="421",["medical_symbol"]="799",["flag_bq"]="838",["hammer"]="6181",["thunder_cloud_and_rain"]="5187",["derelict_house_building"]="522",["waving_black_flag"]="84",["flag_as"]="819",["flag_cg"]="850",["hammer_and_pick"]="6184",["sandal"]="631",["gift_heart"]="1118",["dragon"]="282",["japanese_ogre"]="197",["infinity"]="7100",["champagne"]="3104",["recycle"]="7101",["hearts"]="468",["right_facing_fist"]="1173",["oncoming_police_car"]="582",["chess_pawn"]="471",["flag_ni"]="8178",["pisces"]="771",["tram"]="571",["diamond_shape_with_a_dot_inside"]="7214",["scorpius"]="767",["flag_mk"]="8157",["wheel_of_dharma"]="752",["libra"]="766",["mosque"]="542",["virgo"]="765",["one"]="7135",["shopping_trolley"]="6229",["woman_rowing_boat"]="1406",["vertical_traffic_light"]="5107",["revolving_hearts"]="1122",["sound"]="646",["bowl_with_spoon"]="357",["female_technologist"]="1286",["man_with_bunny_ears_partying"]="1386",["rewind"]="781",["flag_ba"]="825",["crying_cat_face"]="1110",["free"]="7155",["flag_pw"]="8198",["female_sign"]="797",["flag_ac"]="88",["arrow_double_down"]="786",["white_frowning_face"]="166",["heartbeat"]="1121",["small_airplane"]="5119",["peace_symbol"]="757",["star_and_crescent"]="756",["orthodox_cross"]="755",["monkey"]="22",["radioactive_sign"]="725",["mega"]="649",["skull_and_crossbones"]="194",["old_key"]="6180",["flag_es"]="879",["fist"]="1170",["shamrock"]="2123",["black_circle_for_record"]="789",["coffee"]="3101",["file_folder"]="6153",["man_mountain_biking"]="1420",["male_detective"]="1306",["ballot_box_with_check"]="7108",["candy"]="395",["comet"]="5207",["flag_in"]="8118",["cloud"]="5185",["sunny"]="5177",["flag_gq"]="8100",["woman_in_steamy_room"]="1390",["id"]="7157",["cricket_bat_and_ball"]="438",["female_zombie"]="1354",["nerd_face"]="161",["flag_kn"]="8133",["white_medium_small_square"]="7205",["flag_ag"]="812",["page_with_curl"]="6113",["white_medium_square"]="7203",["dumpling"]="377",["copyright"]="7129",["clock330"]="5147",["fried_shrimp"]="373",["arrow_backward"]="780",["flag_bi"]="832",["fish"]="288",["fax"]="674",["drop_of_blood"]="6209",["house"]="523",["woman_wearing_turban"]="1318",["bald_woman"]="1217",["low_brightness"]="792",["seven"]="7141",["flag_ec"]="874",["card_index_dividers"]="6155",["safety_vest"]="65",["flag_ir"]="8121",["timer_clock"]="5138",["mag_right"]="698",["otter"]="255",["flag_mz"]="8172",["stopwatch"]="5137",["takeout_box"]="379",["alarm_clock"]="5136",["ocean"]="5210",["black_right_pointing_triangle_with_double_vertical_bar"]="779",["cl"]="7153",["black_left_pointing_double_triangle_with_vertical_bar"]="782",["relaxed"]="119",["fast_forward"]="777",["registered"]="7130",["woman_in_manual_wheelchair"]="1378",["eject"]="790",["keyboard"]="680",["flag_cv"]="861",["aerial_tramway"]="5127",["ballet_shoes"]="632",["male_scientist"]="1282",["smoking"]="6230",["woman_walking"]="1363",["leftwards_arrow_with_hook"]="737",["badger"]="258",["swimmer"]="1407",["hourglass_flowing_sand"]="5134",["underage"]="724",["woman_juggling"]="1436",["flamingo"]="273",["one_piece_swimsuit"]="616",["left_right_arrow"]="736",["information_source"]="7156",["woman_in_lotus_position"]="1439",["clock1130"]="5163",["fallen_leaf"]="2126",["woman_biking"]="1418",["horse_racing"]="1395",["interrobang"]="7123",["hushed"]="168",["man_in_motorized_wheelchair"]="1374",["mrs_claus"]="1327",["closed_umbrella"]="5199",["lower_left_ballpoint_pen"]="6148",["razor"]="6220",["ringed_planet"]="5180",["woman_heart_man"]="1451",["parachute"]="5122",["raised_hand_with_fingers_splayed"]="1152",["kite"]="457",["male_police_officer"]="1303",["star"]="5181",["trident"]="7103",["mute"]="644",["balloon"]="47",["relieved"]="142",["flag_cf"]="849",["kaaba"]="546",["flag_gi"]="895",["flag_fk"]="884",["earth_asia"]="53",["ambulance"]="579",["date"]="6156",["flag_sy"]="8225",["clock4"]="5148",["partying_face"]="159",["speak_no_evil"]="1114",["adhesive_bandage"]="6211",["blond_haired_man"]="1220",["rugby_football"]="434",["notebook_with_decorative_cover"]="6104",["flag_az"]="824",["white_small_square"]="7207",["shorts"]="618",["flag_to"]="8238",["flag_bg"]="830",["arrow_up_down"]="735",["open_file_folder"]="6154",["flag_np"]="8181",["police_car"]="581",["watch"]="5135",["guide_dog"]="27",["sponge"]="6227",["flag_mr"]="8164",["soap"]="6226",["roll_of_paper"]="6225",["basket"]="6224",["tongue"]="1196",["teddy_bear"]="466",["penguin"]="267",["male_cook"]="1270",["e_mail"]="6133",["spaghetti"]="369",["flag_st"]="8222",["eight"]="7142",["thread"]="478",["sa"]="7168",["flag_cn"]="856",["clock12"]="5140",["face_with_hand_over_mouth"]="129",["vampire"]="1340",["service_dog"]="28",["bed"]="6214",["clapper"]="691",["female_superhero"]="1330",["flag_um"]="8246",["bricks"]="520",["link"]="6197",["snowboarder"]="1397",["flag_pg"]="8189",["crown"]="634",["laughing"]="15",["new_moon_with_face"]="5173",["toolbox"]="6199",["diving_mask"]="450",["fire_extinguisher"]="6228",["compass"]="57",["large_purple_square"]="7198",["baby"]="1198",["test_tube"]="6202",["woozy_face"]="155",["red_envelope"]="416",["socks"]="612",["coat"]="611",["flag_gf"]="892",["flag_us"]="8248",["aquarius"]="770",["brain"]="1191",["fried_egg"]="354",["male_zombie"]="1353",["genie"]="1349",["adult"]="1202",["flag_ie"]="8115",["female_genie"]="1351",["hibiscus"]="2112",["joy_cat"]="1105",["male_elf"]="1347",["female_elf"]="1348",["merperson"]="1343",["merman"]="1344",["mermaid"]="1345",["butterfly"]="295",["lotion_bottle"]="6221",["flag_cw"]="862",["person_with_pouting_face"]="1227",["national_park"]="516",["shushing_face"]="130",["male_fairy"]="1338",["mage"]="1334",["fishing_pole_and_fish"]="449",["female_mage"]="1336",["flag_ar"]="818",["pineapple"]="37",["safety_pin"]="6222",["tm"]="7131",["juggling"]="1434",["traffic_light"]="5106",["male_factory_worker"]="1276",["clock7"]="5154",["avocado"]="318",["video_game"]="461",["flag_tg"]="8231",["control_knobs"]="658",["eye"]="1195",["family"]="1454",["t_rex"]="284",["person_with_headscarf"]="1320",["rhinoceros"]="240",["bow_and_arrow"]="6189",["eggplant"]="319",["older_adult"]="1221",["male_genie"]="1350",["bikini"]="619",["flag_im"]="8117",["face_with_monocle"]="162",["icecream"]="385",["deaf_man"]="1243",["flag_mu"]="8167",["deaf_woman"]="1244",["man_swimming"]="1408",["kneeling_person"]="1367",["man_kneeling"]="1368",["flag_sa"]="8206",["clock9"]="5158",["mortar_board"]="637",["ship"]="5117",["standing_person"]="1364",["crossed_flags"]="83",["ice_cube"]="3115",["red_haired_man"]="1206",["pancakes"]="337",["mate_drink"]="3114",["black_joker"]="472",["woman_swimming"]="1409",["croissant"]="333",["bouquet"]="2106",["butter"]="360",["speech_balloon"]="1144",["factory"]="535",["man_with_turban"]="1316",["grimacing"]="140",["place_of_worship"]="748",["salt"]="361",["flag_er"]="878",["basketball"]="431",["cupcake"]="392",["parrot"]="275",["sushi"]="372",["globe_with_meridians"]="54",["monorail"]="572",["motorized_wheelchair"]="595",["ear_with_hearing_aid"]="1189",["arrow_lower_left"]="732",["fountain"]="547",["superhero"]="1328",["flag_ky"]="8137",["flag_me"]="8153",["performing_arts"]="475",["flag_fr"]="887",["magnet"]="6200",["white_circle"]="7192",["foot"]="1187",["falafel"]="352",["city_sunrise"]="555",["smirk_cat"]="1107",["banjo"]="667",["hospital"]="528",["watermelon"]="33",["receipt"]="6128",["water_buffalo"]="226",["sweet_potato"]="370",["hash"]="7132",["oyster"]="384",["flag_bh"]="831",["hotdog"]="347",["arrow_upper_left"]="734",["orangutan"]="24",["swan"]="271",["microbe"]="2105",["ice_hockey_stick_and_puck"]="440",["tada"]="48",["woman_woman_boy"]="1465",["briefs"]="617",["gem"]="643",["raccoon"]="212",["flag_au"]="821",["train"]="574",["flag_wales"]="8268",["cheese_wedge"]="339",["man_pouting"]="1228",["hippopotamus"]="241",["flag_vc"]="8252",["peacock"]="274",["cricket"]="2100",["man"]="1204",["man_in_steamy_room"]="1389",["boar"]="230",["flag_mm"]="8159",["sauropod"]="283",["reminder_ribbon"]="419",["hedgehog"]="249",["telescope"]="6206",["zebra_face"]="222",["woman_golfing"]="1400",["giraffe_face"]="238",["squid"]="383",["shrimp"]="382",["tiger"]="216",["izakaya_lantern"]="6102",["flag_zw"]="8265",["bearded_person"]="1205",["evergreen_tree"]="2117",["gun"]="6188",["gorilla"]="23",["potato"]="320",["deer"]="223",["fox_face"]="211",["barely_sunny"]="5189",["man_surfing"]="1402",["nut_and_bolt"]="6192",["mountain_railway"]="573",["owl"]="272",["shark"]="291",["bat"]="250",["flag_ae"]="810",["eagle"]="269",["pound"]="6125",["leopard"]="218",["boot"]="633",["first_quarter_moon_with_face"]="5174",["desert_island"]="515",["sled"]="453",["turkey"]="260",["repeat"]="774",["scorpion"]="2103",["mailbox_closed"]="6140",["person_climbing"]="1391",["flag_eu"]="881",["womans_flat_shoe"]="629",["fireworks"]="43",["hole"]="1142",["tumbler_glass"]="3111",["hiking_boot"]="628",["ram"]="232",["flag_gh"]="894",["flag_fj"]="883",["female_teacher"]="1262",["large_orange_square"]="7194",["goggles"]="63",["flag_sx"]="8224",["sports_medal"]="424",["flag_tf"]="8230",["sake"]="3103",["lab_coat"]="64",["cupid"]="1117",["left_facing_fist"]="1172",["water_polo"]="1428",["pleading_face"]="171",["moneybag"]="6121",["cold_face"]="154",["hot_face"]="153",["fortune_cookie"]="378",["dove_of_peace"]="268",["firecracker"]="45",["radio_button"]="7215",["flag_am"]="815",["three_button_mouse"]="681",["chopsticks"]="3116",["notebook"]="6111",["smiling_face_with_3_hearts"]="114",["trophy"]="423",["pretzel"]="335",["vhs"]="696",["moon_cake"]="375",["woman_lifting_weights"]="1415",["bowling"]="437",["flag_ee"]="875",["ab"]="7151",["canned_food"]="362",["flag_it"]="8123",["four"]="7138",["sandwich"]="348",["ear"]="1188",["woman_pouting"]="1229",["rosette"]="2109",["hankey"]="195",["flag_do"]="871",["euro"]="6124",["bagel"]="336",["pie"]="393",["lobster"]="381",["cup_with_straw"]="3112",["flag_tn"]="8237",["gemini"]="762",["yawning_face"]="186",["peanuts"]="330",["heart_eyes"]="115",["luggage"]="5132",["egg"]="353",["male_doctor"]="1255",["8ball"]="458",["stuffed_flatbread"]="351",["female_guard"]="1310",["green_salad"]="358",["baguette_bread"]="334",["carrot"]="321",["dango"]="376",["bacon"]="343",["kimono"]="614",["round_pushpin"]="6166",["tulip"]="2115",["cucumber"]="324",["knife_fork_plate"]="3117",["woman_climbing"]="1393",["sparkles"]="46",["bathtub"]="6219",["camera_with_flash"]="694",["flag_th"]="8232",["flag_id"]="8114",["medal"]="422",["third_place_medal"]="427",["bear"]="251",["flag_ki"]="8131",["chocolate_bar"]="394",["ok"]="7162",["birthday"]="390",["heavy_plus_sign"]="7113",["rose"]="2110",["clinking_glasses"]="3110",["hear_no_evil"]="1113",["man_playing_handball"]="1432",["chicken"]="261",["flag_fm"]="885",["crocodile"]="277",["sari"]="615",["feet"]="259",["doughnut"]="388",["woman_wrestling"]="1427",["oncoming_taxi"]="584",["fencer"]="1394",["man_juggling"]="1435",["arrow_lower_right"]="730",["fork_and_knife"]="3118",["flag_nc"]="8174",["clock6"]="5152",["classical_building"]="518",["person_doing_cartwheel"]="1422",["cityscape"]="551",["man_cartwheeling"]="1423",["woman_cartwheeling"]="1424",["night_with_stars"]="550",["shrug"]="1251",["man_shrugging"]="1252",["woman_shrugging"]="1253",["man_in_tuxedo"]="1321",["male_teacher"]="1261",["handshake"]="1178",["no_pedestrians"]="722",["man_gesturing_ok"]="1234",["flag_il"]="8116",["red_circle"]="7184",["prince"]="1314",["office"]="525",["flag_mt"]="8166",["flag_lv"]="8148",["selfie"]="1182",["flag_tv"]="8241",["breast_feeding"]="1324",["i_love_you_hand_sign"]="1159",["male_artist"]="1291",["exploding_head"]="157",["violin"]="666",["flag_bs"]="840",["flag_dg"]="867",["runner"]="1379",["arrow_down_small"]="785",["face_vomiting"]="151",["oncoming_bus"]="576",["joy"]="18",["strawberry"]="314",["face_with_symbols_on_mouth"]="190",["u7a7a"]="7179",["zany_face"]="125",["stew"]="356",["the_horns"]="1160",["man_facepalming"]="1249",["woman_facepalming"]="1250",["lying_face"]="141",["stuck_out_tongue_winking_eye"]="124",["briefcase"]="6152",["compression"]="6194",["rolling_on_the_floor_laughing"]="17",["nauseated_face"]="150",["atom_symbol"]="749",["flag_ca"]="846",["older_woman"]="1223",["pregnant_woman"]="1323",["school"]="533",["cactus"]="2120",["triangular_ruler"]="6170",["studio_microphone"]="656",["clock8"]="5156",["flag_md"]="8152",["crossed_fingers"]="1158",["clubs"]="470",["slot_machine"]="463",["call_me_hand"]="1161",["lock"]="6175",["face_with_raised_eyebrow"]="133",["bangbang"]="7122",["muscle"]="1183",["man_rowing_boat"]="1405",["zipper_mouth_face"]="132",["brown_heart"]="1133",["pinching_hand"]="1156",["white_heart"]="1135",["flag_sh"]="8212",["large_brown_square"]="7199",["large_green_square"]="7196",["large_yellow_square"]="7195",["microphone"]="659",["camel"]="236",["soon"]="746",["blush"]="112",["large_red_square"]="7193",["large_brown_circle"]="7190",["chains"]="6198",["lips"]="1197",["large_green_circle"]="7187",["scroll"]="6114",["cherries"]="313",["flag_at"]="820",["auto_rickshaw"]="596",["skateboard"]="599",["christmas_tree"]="42",["sleepy"]="144",["canoe"]="5112",["pig2"]="229",["flag_xk"]="8260",["motor_scooter"]="593",["flag_ru"]="8204",["scooter"]="598",["flag_ci"]="852",["flag_ml"]="8158",["envelope_with_arrow"]="6135",["keycap_ten"]="7144",["non_potable_water"]="721",["white_check_mark"]="7107",["airplane_departure"]="5120",["cop"]="1302",["yin_yang"]="753",["waning_gibbous_moon"]="5169",["pig_nose"]="231",["keycap_star"]="7133",["man_frowning"]="1225",["man_golfing"]="1399",["motorway"]="5101",["oil_drum"]="5103",["hammer_and_wrench"]="6185",["name_badge"]="7104",["hindu_temple"]="543",["cold_sweat"]="175",["flag_ga"]="888",["no_mouth"]="136",["necktie"]="66",["left_speech_bubble"]="1146",["clock730"]="5155",["baggage_claim"]="712",["walking"]="1361",["passport_control"]="710",["flag_ad"]="89",["fairy"]="1337",["ferris_wheel"]="559",["toilet"]="6217",["baby_symbol"]="78",["oncoming_automobile"]="586",["mens"]="75",["mountain_bicyclist"]="1419",["flag_py"]="8199",["flag_re"]="8201",["umbrella_with_rain_drops"]="5201",["flag_kp"]="8134",["man_man_boy"]="1460",["flag_et"]="880",["card_index"]="6160",["man_biking"]="1417",["flag_ma"]="8150",["passenger_ship"]="5114",["football"]="433",["eight_pointed_black_star"]="7120",["monkey_face"]="21",["do_not_litter"]="720",["flag_vu"]="8257",["dvd"]="686",["clock1230"]="5141",["lion_face"]="215",["airplane"]="5118",["no_good"]="1230",["rotating_light"]="5105",["put_litter_in_its_place"]="72",["tropical_drink"]="3107",["speedboat"]="5113",["face_with_thermometer"]="148",["cancer"]="763",["woman_kneeling"]="1369",["hourglass"]="5133",["mountain_cableway"]="5126",["flag_rw"]="8205",["shaved_ice"]="386",["mechanical_arm"]="1184",["articulated_lorry"]="589",["flag_al"]="814",["a"]="7150",["1234"]="7147",["blue_car"]="587",["green_apple"]="310",["key"]="6179",["womens"]="76",["couple_with_heart"]="1450",["female_scientist"]="1283",["older_man"]="1222",["flag_cx"]="863",["crystal_ball"]="459",["spades"]="467",["fire_engine"]="580",["minibus"]="578",["trolleybus"]="577",["table_tennis_paddle_and_ball"]="442",["grin"]="14",["train2"]="567",["light_rail"]="569",["flag_ve"]="8253",["bullettrain_front"]="566",["dart"]="455",["love_hotel"]="531",["baby_chick"]="264",["bullettrain_side"]="565",["railway_car"]="564",["flag_bz"]="845",["steam_locomotive"]="563",["hand"]="1153",["female_vampire"]="1342",["leg"]="1186",["skull"]="193",["motor_boat"]="5116",["raised_hands"]="1175",["white_haired_woman"]="1215",["raising_hand"]="1239",["woman_raising_hand"]="1241",["post_office"]="526",["flag_nr"]="8182",["wilted_flower"]="2111",["bow"]="1245",["man_bowing"]="1246",["woman_bowing"]="1247",["woman_gesturing_ok"]="1235",["triangular_flag_on_post"]="82",["black_square_button"]="7217",["woman_gesturing_no"]="1232",["face_with_rolling_eyes"]="139",["u7981"]="7175",["slightly_smiling_face"]="19",["slightly_frowning_face"]="165",["u6708"]="7169",["pouting_cat"]="1111",["point_down"]="1166",["kissing_cat"]="1108",["heart_eyes_cat"]="1106",["bee"]="298",["man_bouncing_ball"]="1411",["woman_woman_girl_girl"]="1469",["prayer_beads"]="640",["couch_and_lamp"]="6215",["chestnut"]="331",["male_technologist"]="1285",["scream"]="179",["bellhop_bell"]="5131",["face_with_head_bandage"]="149",["open_mouth"]="167",["sob"]="178",["poultry_leg"]="341",["flag_ea"]="873",["green_heart"]="1130",["flying_saucer"]="5130",["level_slider"]="657",["thumbsup"]="1168",["triumph"]="187",["bridge_at_night"]="556",["broken_heart"]="1126",["cry"]="177",["rage"]="188",["beer"]="3108",["amphora"]="3121",["disappointed"]="182",["stuck_out_tongue_closed_eyes"]="126",["stuck_out_tongue"]="123",["rabbit"]="246",["flag_pa"]="8186",["kissing_smiling_eyes"]="121",["flag_je"]="8124",["kissing_heart"]="117",["flag_cp"]="858",["kissing"]="118",["mans_shoe"]="626",["confounded"]="180",["pensive"]="143",["sweat"]="183",["neutral_face"]="134",["large_blue_diamond"]="7209",["memo"]="6151",["sunglasses"]="160",["house_with_garden"]="524",["wink"]="111",["flag_io"]="8119",["smiling_imp"]="191",["flag_ss"]="8221",["european_castle"]="537",["flag_mw"]="8169",["flag_br"]="839",["woman_getting_haircut"]="1360",["smile"]="13",["flag_co"]="857",["red_haired_woman"]="1211",["tokyo_tower"]="539",["mount_fuji"]="511",["tired_face"]="185",["dagger_knife"]="6186",["drooling_face"]="145",["male_student"]="1258",["wastebasket"]="6174",["pear"]="311",["u6709"]="7170",["flag_ug"]="8245",["moon"]="5167",["soccer"]="428",["card_file_box"]="6172",["new"]="7159",["deciduous_tree"]="2118",["blossom"]="2114",["frame_with_picture"]="476",["u55b6"]="7182",["tomato"]="316",["flag_mh"]="8156",["back"]="743",["flag_nu"]="8183",["flag_jm"]="8125",["clock930"]="5159",["bento"]="363",["cake"]="391",["flag_ta"]="8227",["zombie"]="1352",["curling_stone"]="454",["flag_tc"]="8228",["synagogue"]="544",["b"]="7152",["banana"]="36",["suspension_railway"]="5125",["flag_bb"]="826",["flag_si"]="8213",["negative_squared_cross_mark"]="7112",["black_square_for_stop"]="788",["inbox_tray"]="6137",["flag_kz"]="8138",["spock_hand"]="1154",["hamburger"]="344",["pager"]="673",["flag_pf"]="8188",["abc"]="7149",["taxi"]="583",["flag_cc"]="847",["leo"]="764",["tornado"]="5194",["dash"]="1141",["sun_with_face"]="5179",["goal_net"]="446",["yen"]="6122",["peach"]="312",["flag_be"]="828",["golfer"]="1398",["syringe"]="6208",["waving_white_flag"]="85",["cyclone"]="5197",["flag_ly"]="8149",["honey_pot"]="398",["grapes"]="31",["flag_aw"]="822",["flashlight"]="6101",["rainbow_flag"]="86",["flag_ch"]="851",["twisted_rightwards_arrows"]="773",["corn"]="322",["thinking_face"]="131",["flag_sd"]="8209",["two"]="7136",["black_small_square"]="7206",["man_in_lotus_position"]="1438",["flag_ke"]="8128",["flag_mo"]="8161",["flag_fi"]="882",["lacrosse"]="441",["roller_coaster"]="560",["mechanical_leg"]="1185",["flag_sk"]="8215",["flag_ax"]="823",["scream_cat"]="1109",["flag_bj"]="833",["smiley"]="12",["umbrella"]="5200",["pirate_flag"]="87",["truck"]="588",["flag_mg"]="8155",["gloves"]="610",["woman_woman_girl_boy"]="1467",["rain_cloud"]="5191",["flag_hn"]="8109",["arrow_up_small"]="783",["flag_tl"]="8235",["wind_blowing_face"]="5196",["flag_tw"]="8242",["bug"]="296",["woman_girl"]="1477",["mailbox"]="6139",["female_farmer"]="1268",["100"]="1136",["woman_tipping_hand"]="1238",["couple"]="1444",["angry"]="189",["female_student"]="1259",["bomb"]="1143",["bike"]="597",["snake"]="280",["bone"]="1193",["man_with_probing_cane"]="1371",["flag_gy"]="8106",["book"]="6106",["black_medium_square"]="7202",["gear"]="6193",["flag_li"]="8142",["floppy_disk"]="684",["crescent_moon"]="5172",["mostly_sunny"]="5188",["dizzy_face"]="156",["clock1"]="5142",["diya_lamp"]="6103",["new_moon"]="5164",["top"]="747",["ski"]="452",["dragon_face"]="281",["cow"]="224",["coconut"]="317",["person_frowning"]="1224",["tv"]="692",["flag_ic"]="8113",["waning_crescent_moon"]="5171",["shower"]="6218",["woman_standing"]="1366",["game_die"]="464",["flag_va"]="8251",["flag_dz"]="872",["poodle"]="29",["bird"]="266",["zero"]="7134",["male_mage"]="1335",["foggy"]="549",["flag_ws"]="8259",["flag_ao"]="816",["building_construction"]="519",["dog2"]="26",["flag_rs"]="8203",["anger"]="1137",["cherry_blossom"]="2107",["space_invader"]="1101",["man_man_boy_boy"]="1463",["mahjong"]="473",["flag_nz"]="8184",["herb"]="2122",["tangerine"]="34",["white_square_button"]="7216",["u6e80"]="7183",["school_satchel"]="625",["black_medium_small_square"]="7204",["flag_sz"]="8226",["atm"]="71",["flag_gu"]="8104",["zzz"]="1149",["flag_lr"]="8144",["love_letter"]="1116",["popcorn"]="359",["page_facing_up"]="6115",["flag_pn"]="8194",["ideograph_advantage"]="7172",["man_girl_girl"]="1474",["flag_bm"]="835",["apple"]="39",["male_guard"]="1309",["convenience_store"]="532",["boy"]="1200",["flag_england"]="8266",["department_store"]="534",["cut_of_meat"]="342",["badminton_racquet_and_shuttlecock"]="443",["flag_la"]="8139",["flower_playing_cards"]="474",["rabbit2"]="247",["pill"]="6210",["black_heart"]="1134",["whale2"]="286",["snail"]="294",["racehorse"]="220",["woman_playing_handball"]="1433",["glass_of_milk"]="3100",["woman_boy_boy"]="1476",["octopus"]="292",["arrow_left"]="733",["nail_care"]="1181",["persevere"]="181",["notes"]="655",["woman_woman_boy_boy"]="1468",["flag_dj"]="868",["beetle"]="299",["tropical_fish"]="289",["outbox_tray"]="6136",["seedling"]="2116",["flag_un"]="8247",["dolphin"]="287",["mouse"]="242",["bookmark"]="6119",["bread"]="332",["sos"]="7164",["male_vampire"]="1341",["six_pointed_star"]="759",["cat"]="213",["wolf"]="210",["books"]="6110",["latin_cross"]="754",["nose"]="1190",["end"]="744",["flag_gr"]="8101",["female_firefighter"]="1301",["point_up_2"]="1164",["point_right"]="1163",["innocent"]="113",["sheep"]="233",["upside_down_face"]="110",["open_hands"]="1176",["clap"]="1174",["ghost"]="199",["people_holding_hands"]="1442",["star_struck"]="116",["female_mechanic"]="1274",["unicorn_face"]="221",["lipstick"]="641",["japanese_castle"]="536",["arrows_counterclockwise"]="742",["bookmark_tabs"]="6118",["bicyclist"]="1416",["man_woman_girl_boy"]="1457",["sleeping"]="146",["shallow_pan_of_food"]="355",["arrow_right_hook"]="738",["woman_girl_boy"]="1478",["flag_sr"]="8220",["man_tipping_hand"]="1237",["flag_gm"]="897",["information_desk_person"]="1236",["flag_hm"]="8108",["female_singer"]="1289",["vs"]="7166",["woman_playing_water_polo"]="1430",["flag_vn"]="8256",["mag"]="697",["closed_book"]="6105",["woman_woman_girl"]="1466",["curly_haired_woman"]="1213",["flag_kh"]="8130",["japanese_goblin"]="198",["incoming_envelope"]="6134",["mailbox_with_mail"]="6141",["musical_keyboard"]="664",["hatching_chick"]="263",["taurus"]="761",["female_judge"]="1265",["minidisc"]="683",["handbag"]="622",["man_with_gua_pi_mao"]="1319",["dna"]="6204",["u6307"]="7171",["woman_in_motorized_wheelchair"]="1375",["mosquito"]="2104",["alien"]="1100",["u5272"]="7173",["flag_ph"]="8190",["eight_spoked_asterisk"]="7119",["male_mechanic"]="1273",["rice_ball"]="365",["flag_mv"]="8168",["scales"]="6195",["dancer"]="1382",["city_sunset"]="554",["two_men_holding_hands"]="1445",["flag_sb"]="8207",["ring"]="642",["haircut"]="1358",["flag_cy"]="864",["flag_eg"]="876",["woman_with_bunny_ears_partying"]="1387",["horse"]="219",["flag_pe"]="8187",["flag_gs"]="8102",["woman_surfing"]="1403",["right_anger_bubble"]="1147",["sweat_drops"]="1140",["partly_sunny_rain"]="5190",["battery"]="675",["waffle"]="338",["dollar"]="6123",["saxophone"]="662",["guardsman"]="1308",["seat"]="5123",["bank"]="529",["man_getting_haircut"]="1359",["man_in_manual_wheelchair"]="1377",["large_orange_diamond"]="7208",["male_office_worker"]="1279",["man_climbing"]="1392",["confetti_ball"]="49",["girl"]="1201",["flag_fo"]="886",["leafy_green"]="325",["woman_boy"]="1475",["telephone_receiver"]="672",["cd"]="685",["satellite_antenna"]="6207",["turtle"]="278",["flag_mf"]="8154",["female_factory_worker"]="1277",["racing_car"]="591",["funeral_urn"]="6232",["mobile_phone_off"]="796",["mango"]="38",["volleyball"]="432",["billed_cap"]="638",["man_man_girl_boy"]="1462",["blowfish"]="290",["palms_up_together"]="1177",["heart"]="1127",["flag_gp"]="899",["dizzy"]="1139",["flag_sj"]="8214",["electric_plug"]="676",["man_lifting_weights"]="1414",["yarn"]="479",["station"]="570",["construction_worker"]="1311",["droplet"]="5209",["capital_abcd"]="7145",["curly_haired_man"]="1207",["flag_vg"]="8254",["flag_bt"]="841",["checkered_flag"]="81",["heavy_dollar_sign"]="6131",["flag_gl"]="896",["small_blue_diamond"]="7211",["signal_strength"]="794",["dog"]="25",["worried"]="164",}
--addons/scb_chatbox/lua/scb/settings/tabs/tags.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.tags = scb.tags or {}

net.Receive("SCB.SendTags", function()
	local tags = net.ReadData(net.ReadUInt(17))
	tags = util.Decompress(tags)
	scb.tags = scb.mp.unpack(tags)
end)

net.Receive("SCB.AddTag", function()
	local key = net.ReadString()
	local tag = net.ReadString()
	scb.tags[key] = tag

	local old = net.ReadString()

	if old ~= "" then
		scb.tags[old] = nil
	end

	hook.Call("SCB.TagsModified")
end)

net.Receive("SCB.RemoveTag", function()
	scb.tags[net.ReadString()] = nil
	hook.Call("SCB.TagsModified")
end)

local tags_menu = function(title, key, key_tag)
	key = key or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.tag_owner)
	name:SetValue(key)

	name:SetCheck(function(_name)
		if _name == "" or (scb.tags[_name] and key ~= _name) then
			return false
		end
	end)

	options.Add(name)

	local tag = querybox:Add("SCB.TextEntry")
	tag:Dock(TOP)
	tag:DockMargin(0, 4, 0, 0)
	tag:SetPlaceholder(language.tag)
	tag:SetValue(key_tag or "")

	tag:SetCheck(function(_tag)
		return _tag ~= ""
	end)

	options.Add(tag)

	local preview = querybox:Add("SCB.ChatLine")
	preview:DockMargin(0, 6, 0, 0)
	preview.x = 3
	preview.emoji_size = 18

	preview:ScaleChanged()
	preview:Parse(tag:GetValue())
	preview:SetMouseInputEnabled(false)

	tag:On("OnValueChange", function(s, v)
		preview.added = {}
		preview:ScaleChanged()
		preview:Parse(v)
		querybox:size_to_children()
	end)

	querybox:SetCallback(function()
		net.Start("SCB.AddTag")
			net.WriteString(name:GetText())
			net.WriteString(tag:GetText())
			net.WriteString(name:GetText() ~= key and key or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.tags_title,
	pos = 2,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local tags_list = body:Add("SCB.ThreeGrid")
		tags_list:Dock(FILL)
		tags_list:InvalidateLayout(true)
		tags_list:InvalidateParent(true)

		tags_list:SetColumns(2)
		tags_list:SetHorizontalMargin(2)
		tags_list:SetVerticalMargin(2)

		local load_tags = function()
			tags_list:Clear()

			for key, tag in SortedPairs(scb.tags) do
				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(560))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					tags_menu(language.edit .. " '" .. key .. "'", key, tag)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveTag")
							net.WriteString(key)
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end
				tags_list:AddCell(pnl)

				local name = pnl:Add("SCB.Label")
				name:Dock(TOP)
				name:SetFont(SCB_16)
				name:SetText(key)
				name:SetTextInset(3, 0)
				name:SetExpensiveShadow(1, color_black)
				name:SizeToContentsY(3)

				local _tag = pnl:Add("SCB.ChatLine")
				_tag:DockMargin(3, 0, 0, 0)
				_tag:SetFont(SCB_16)

				_tag.emoji_size = 16
				_tag:Parse(tag)
				_tag:SetMouseInputEnabled(false)

				pnl:SizeToChildren(false, true)
			end

			for k, v in ipairs(tags_list.Rows) do
				tags_list:CalculateRowHeight(v)
			end
		end
		load_tags()

		hook.Add("SCB.TagsModified", tags_list, load_tags)

		local add = body:Add("SCB.Button")
		add:Dock(BOTTOM)
		add:DockMargin(0, 4, 0, 0)
		add:SetText(language.add_tag:upper())

		add:On("DoClick", function()
			tags_menu(language.add_tag)
		end)

		return body
	end
}
--addons/scb_chatbox/lua/scb/sh_chatbox.lua:
if SCB_LOADED then return end

local scb = scb

local PLAYER = FindMetaTable("Player")
function PLAYER:IsTyping()
	return self:GetNWBool("SCB.IsTyping", false)
end

function PLAYER:SCB_GetTag()
	local tags = scb.tags
	return tags[self:SteamID()] or tags[self:SteamID64()] or tags[self:GetUserGroup()] or false
end

local permissions = scb.config.permissions
function scb.has_permission(ply, permission)
	if not IsValid(ply) then return true end

	permission = permissions[permission]
	return permission[1] or permission[ply:GetUserGroup()] or permission[ply:SteamID()] or permission[ply:SteamID64()]
end
--addons/playermodels/lua/autorun/sdt_kanani.lua:
-- Removed third unused variant to fix: https://steamcommunity.com/sharedfiles/filedetails/?id=2445854611

player_manager.AddValidModel( "STD Kalani", "models/player/swcw/std_kalani.mdl" );
list.Set( "PlayerOptionsModel",  "STD Kalani", "models/player/swcw/std_kalani.mdl" );
player_manager.AddValidModel( "STD Kraken", "models/player/swcw/std_kraken.mdl" );
list.Set( "PlayerOptionsModel",  "STD Kraken", "models/player/swcw/std_kraken.mdl" );
player_manager.AddValidModel( "STD A-UTO", "models/player/swcw/std_auto.mdl" );
list.Set( "PlayerOptionsModel",  "STD A-UTO", "models/player/swcw/std_auto.mdl" );
--lua/autorun/sh_adblocker.lua:
SL__AD_BLOCKER_Initial_Load = SL__AD_BLOCKER_Initial_Load or false

local TimerTime = 20
local MAX_TRY = 3
local data = data or {}

local RAW_URL = "https://github.com/StarLight-Oliver/Adware-blocker-gmod/raw/master/data/adware_block/data.json"

-- Remove all timers that match at the given execution time
local function timerRemoverFunc()
	for k, v in pairs(data.timers or {}) do
		if not timer.Exists(k) then return end

		timer.Remove(k)
	end
end

-- Remove all hooks that match at the given execution time
local function hookRemoverFunc(count)
	if count and count >= MAX_TRY then return end
	local hoooks, _ = hook.GetTable()
	for hookType, hookTbl in pairs(data.hooks or {}) do
		for hookName, _ in pairs(hookTbl) do
			if hoooks[hookType] and hoooks[hookType][hookName] then
				hook.Remove(hookType, hookName)
			end
		end
	end
	timerRemoverFunc()

	timer.Simple(TimerTime, function()

		hookRemoverFunc((count or 0) + 1)
	end)
end

local extractLastFunctionCall = function(stackTrace)
	local tbl = string.Explode("\n", stackTrace)

	local lastFunction = tbl[3]

	lastFunction = string.Trim(lastFunction)

	if lastFunction:sub(1, 6) == "addons" then
		-- Because of local addons or files in gmas we need to strip the addon name from the traceback
		local pos = lastFunction:find("lua")
		lastFunction = lastFunction:sub(pos)
	end

	local endPos = lastFunction:find(":")
	lastFunction = lastFunction:sub(1, endPos - 1)

	return lastFunction
end

-- Fetches new blacklist data via github
local function GetBlacklistData(fncCallback)
	http.Fetch(RAW_URL, function(body, size, headers, code)
		if not body then return end
		local jsonData = util.JSONToTable(body)

		if not jsonData then return end
		data = jsonData

		if not file.Exists( "adware_block", "DATA" ) then
			file.CreateDir("adware_block")
		end
		file.Write("adware_block/data.json", body)
		if not fncCallback then return end
		fncCallback(data)
	end,
	function(err)
		if (err) then
			print("[Ad Blocker Failed]",err)
		end
	end)
end

-- Read our hard-storage file for blacklists
local function ReadHardStorage()
	local fileData = file.Read("adware_block/data.json", "DATA")

	if (not fileData) then
		print("[Ad Blocker] Looks like you need to restart, we sadly can't override all addons first time.")
		return
	end

	local jsonData = util.JSONToTable(fileData)

	if not jsonData then return end
	data = jsonData

	hookRemoverFunc()
end

local overrideFunc = function(funcName, badFiles)

	print("Attempting to override " .. funcName)

	local reference = _G
	local oldFunc = nil

	local name = funcName

	if funcName:find(".") then
		local split = string.Explode(".", funcName)
		for i = 1, #split - 1 do
			-- This code can very easily error atm maybe wrap in xpcall?
			reference = reference[split[i]]

			if not reference then
				break
			end
		end

		name = split[#split]
	end

	oldFunc = reference[name]

	if (not oldFunc) then
		print("[Adware Block] Couldn't find function: " .. funcName)
		return
	end

	local newFunc = function(...)
		local lastFunc = extractLastFunctionCall(debug.traceback())
		if badFiles[lastFunc] then
			print("[Adware Block] Blocked: ", funcName, " call from", lastFunc)
			return
		end
		return oldFunc(...)
	end

	reference[name] = newFunc
end

local function FindAddonFiles(title)
	local rootDir = "lua"

	local FILES = {}


	local function WS_CHECK(dir)

		dir = dir .. "/"
		local File, Directory = file.Find(dir .. "*", title)

		for _, fileName in ipairs(File) do
			FILES[#FILES + 1] = dir .. fileName
		end

		for _, folderName in ipairs(Directory) do
			WS_CHECK(dir .. folderName)
		end

	end
	WS_CHECK(rootDir)

	return FILES
end

local InjectAddons = function(noPrints)
	data.addons = data.addons or {}

	if not data.addons then return end
	data.functions = data.functions or {}

	for k, v in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do

		local id = tonumber(v.wsid)
		if not data.addons[id] then continue end
		local files = FindAddonFiles(v.title)

		local badRealms = data.addons[id]

		for realm, badFuncs in pairs(badRealms) do
			data.functions[realm] = data.functions[realm] or {}
			for _, funcName in pairs(badFuncs) do
				data.functions[realm][funcName] = data.functions[realm][funcName] or {}

				for _, fileName in ipairs(files) do
					data.functions[realm][funcName][fileName] = true
				end
			end
		end
		if noPrints then continue end
		print("Blocked Workshop Addon (" .. v.title .. ") from running function.")
	end
end

local OverrideFunctions = function()

	InjectAddons()

	local functionsToOverride = data.functions

	if not functionsToOverride then return end

	for funcName, badFiles in pairs( functionsToOverride[ SERVER and "sv" or "cl" ] or {}) do
		overrideFunc(funcName, badFiles)
	end

	for funcName, badFiles in pairs( functionsToOverride[ "sh" ] or {}) do
		overrideFunc(funcName, badFiles)
	end
end


if (!SL__AD_BLOCKER_Initial_Load) then
	ReadHardStorage()
	OverrideFunctions()
	hookRemoverFunc()

	timer.Simple(0, function()
		GetBlacklistData(function(results)
			if (results) then
			else
				-- couldn't get new data, fallback to hard storage.
				print("[Adware Block] Failed to get blacklist github data. Using hard-storage (maybe out of date)")
				ReadHardStorage()
			end
			
			hookRemoverFunc()
			InjectAddons(true)
		end)
	end)
end

--addons/wos-alcs-custom/lua/autorun/sh_duallightsaber.lua:
hook.Add( "PreRegisterSWEP", "wOS.ALCS.PostRegisterFixerMaybe", function( swep, class )
    if class != "wos_adv_single_lightsaber_base" then return end

    local n_table = table.Copy(swep)
    n_table.ClassName = "wos_adv_dual_lightsaber_base"

    weapons.Register( n_table, "wos_adv_dual_lightsaber_base" )
end )
--addons/handschellen/lua/autorun/sh_handcuffs.lua:
---------------------------------------
--   		 SH | Handcuffs          --
---------------------------------------

AddCSLuaFile()

Handcuffs = Handcuffs || {}

-- Model Blacklist
Handcuffs.ModelWhitelist = {
	["models/novux/023/novux_scp-023_white.mdl"] = true,
	["models/Novux/023/Novux_SCP-023.mdl"] = true,
	["models/mrpounder1/player/massif.mdl"] = true,
}

function Handcuffs:CheckModel(ply)
	if Handcuffs.ModelWhitelist[ply:GetModel()] then
		return true
	end

	return false
end

-- Utility
local function GetTrace( ply )
	local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )

	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()

		if cuffed then return tr,wep end
	end
end

-- PLAYER extensions
local PLAYER = FindMetaTable( "Player" )

function PLAYER:IsHandcuffed()
	local wep = self:GetWeapon( "weapon_handcuffed" )

	if IsValid(wep) and wep.IsHandcuffs then
		return true, wep
	end

	return false
end

-- Override Movement
hook.Add( "SetupMove", "Cuffs Move Penalty", function(ply, mv, cmd)
	local cuffed, cuffs = ply:IsHandcuffed()

	if not (cuffed and IsValid(cuffs)) then return end

	if Handcuffs:CheckModel(ply) ~= true then
		if CurTime() < (ply.CuffsNextJumpTime or 0) then
			local buttons = mv:GetButtons()

			if bit.band( buttons, IN_JUMP ) ~= 0 then
				mv:SetButtons( buttons - IN_JUMP )
			end
		end

		mv:SetMaxClientSpeed( mv:GetMaxClientSpeed() * 0.6 )
	end

	if cuffs:GetRopeLength() <= 0 then return end -- No forced movement
	if not IsValid(cuffs:GetKidnapper()) then return end -- Nowhere to move to

	local kidnapper = cuffs:GetKidnapper()

	if kidnapper == ply then return end

	local TargetPoint = (kidnapper:IsPlayer() and kidnapper:GetShootPos()) or kidnapper:GetPos()
	local MoveDir = (TargetPoint - ply:GetPos()):GetNormal()
	local ShootPos = ply:GetShootPos() + (Vector(0,0, ply:Crouching() and 0))
	local Distance = cuffs:GetRopeLength()
	local distFromTarget = ShootPos:Distance( TargetPoint )

	if distFromTarget <= (Distance + 5) then return end

	if ply:InVehicle() then
		if SERVER and (distFromTarget > (Distance * 3)) then
			ply:ExitVehicle()
		end

		return
	end

	local TargetPos = TargetPoint - (MoveDir * Distance)

	local xDif = math.abs(ShootPos[1] - TargetPos[1])
	local yDif = math.abs(ShootPos[2] - TargetPos[2])
	local zDif = math.abs(ShootPos[3] - TargetPos[3])

	local speedMult = 3 + ( (xDif + yDif) * 0.5) ^ 1.01
	local vertMult = math.max((math.Max(300-(xDif + yDif), -10) * 0.08) ^ 1.01  + (zDif / 2), 0)

	if kidnapper:GetGroundEntity() == ply then vertMult = -vertMult end

	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1] = TargetVel[1] * speedMult
	TargetVel[2] = TargetVel[2] * speedMult
	TargetVel[3] = TargetVel[3] * vertMult

	local dir = mv:GetVelocity()
	local clamp = 50
	local vclamp = 20
	local accel = 500
	local vaccel = 30 * (vertMult / 50)

	dir[1] = (dir[1] > TargetVel[1]-clamp or dir[1] < TargetVel[1] + clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
	dir[2] = (dir[2] > TargetVel[2]-clamp or dir[2] < TargetVel[2] + clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]

	if ShootPos[3] < TargetPos[3] then
		dir[3] = (dir[3] > TargetVel[3]-vclamp or dir[3] < TargetVel[3] + vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]

		if vertMult > 0 then ply.Cuff_ForceJump = ply end
	end

	mv:SetVelocity( dir )

	if SERVER and mv:GetVelocity():Length() >= (mv:GetMaxClientSpeed() * 10) and ply:IsOnGround() and CurTime() > (ply.Cuff_NextDragDamage or 0) then
		ply:SetHealth( ply:Health() - 1 )
		if ply:Health() <= 0 then ply:Kill() end

		ply.Cuff_NextDragDamage = CurTime() + 0.1
	end
end)

Handcuffs.HitGroundSounds = {
	Sound("physics/body/body_medium_impact_soft1.wav"),
	Sound("physics/body/body_medium_impact_soft2.wav"),
	Sound("physics/body/body_medium_impact_soft3.wav"),
	Sound("physics/body/body_medium_impact_soft4.wav"),
	Sound("physics/body/body_medium_impact_soft5.wav"),
	Sound("physics/body/body_medium_impact_soft6.wav"),
	Sound("physics/body/body_medium_impact_soft7.wav"),
}

hook.Add( "OnPlayerHitGround", "Cuffs PlayerHitGround", function( ply, _, _, speed )
	if not (IsValid(ply) and ply:IsHandcuffed()) then return end

	ply.CuffsNextJumpTime = CurTime() + 2

	if SERVER then
		sound.Play( table.Random(Handcuffs.HitGroundSounds), ply:GetPos(), 75, 100, math.Clamp( (speed ^ 2) / 1000, 0, 0.5 ) )
	end
end)

-- Vehicles
hook.Add( "CanPlayerEnterVehicle", "Cuffs PreventVehicle", function( ply )
	if ply:IsHandcuffed() then return false end
end)

if CLIENT then
	local CuffsTable = {}

	local function UpdateCuffsTable()
		CuffsTable = {}

		for _,v in pairs(ents.GetAll()) do
			if IsValid(v) and v.IsHandcuffs then table.insert( CuffsTable, v ) end
		end
	end

	-- HUD
	local Col = {
		Text = Color(255,255,255), TextShadow = Color(0,0,0), Rope = Color(255,255,255),
		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
	}

	local matGrad = Material( "gui/gradient" )
	local NextCuffsTableUpdate = 0

	hook.Add( "HUDPaint", "Cuffs CuffedInteractPrompt", function()
		local ply = LocalPlayer()

		if ply:IsHandcuffed() then return end

		local w,h = (ScrW() / 2), (ScrH() / 2)
		local TextPos = h - 40

		local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )
		if tr.Hit then
			if CurTime() > NextCuffsTableUpdate then
				UpdateCuffsTable()
				NextCuffsTableUpdate = CurTime() + 5
			end

			for _,v in pairs(CuffsTable) do
				if IsValid(v) and v:GetKidnapper() == ply and v:GetRopeLength() > 0 then
					local str = string.format( "%s + %s um %s",
						(input.LookupBinding("+use") or "[Benutzen]"):upper(),
						(input.LookupBinding("+attack") or "[Linksklick]"):upper(),
						(IsValid(tr.Entity) and tr.Entity:IsPlayer()) and "Gefangenen zu übergeben" or "Gefangenen festzubinden"
					)
					draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
					draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
					TextPos = TextPos-30

					break
				end
			end
		end

		local tr, cuff = GetTrace( ply )

		if not (tr and IsValid(cuff)) then
			return
		end

		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )

		render.SetScissorRect( w-100, TextPos, (w-100) + ((cuff:GetCuffBroken() / 100) * 200), TextPos + 20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )

			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )

		TextPos = TextPos-25

		if IsValid(cuff:GetFriendBreaking()) then
			if cuff:GetFriendBreaking() == ply then
				draw.SimpleText( "Freilassen...", "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( "Freilassen...", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

				TextPos = TextPos-20
			end
		else
			local str = string.format( "%s zum freilassen", (input.LookupBinding("+use") or "[USE]"):upper() )

			draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end

		if cuff:GetRopeLength() > 0 then
			if IsValid(cuff:GetKidnapper()) then
				if cuff:GetKidnapper() == ply then
					local str = string.format( "%s um nicht mehr zu ziehen", (input.LookupBinding("+reload") or "[NACHLADEN]"):upper() )
					draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
					draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

					TextPos = TextPos-20
				end
			else
				local str = string.format( "%s um zu ziehen", (input.LookupBinding("+reload") or "[NACHLADEN]"):upper() )
				draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

				TextPos = TextPos-20
			end
		end

		if cuff:GetCanBlind() then
			local str = string.format( "%s to %sblindfold", (input.LookupBinding("+attack2") or "[LINKSKLICK]"):upper(), cuff:GetIsBlind() and "remove " or "" )

			draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

			TextPos = TextPos-20
		end

		if cuff:GetCanGag() then
			local str = string.format( "%s um %s ruhig zu stellen.", (input.LookupBinding("+attack") or "[LINKSKLICK]"):upper(), cuff:GetIsGagged() and "nicht mehr " or "" )
			draw.SimpleText( str, "HandcuffsText", w + 1, TextPos + 1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

			TextPos = TextPos-20
		end
	end)

	-- Bind hooks
	hook.Add( "PlayerBindPress", "Cuffs CuffedInteract", function(ply, bind, pressed)
		if ply ~= LocalPlayer() then return end

		if bind:lower() == "+attack" and pressed then
			if ply:KeyDown( IN_USE ) then
				local isDragging = false

				for _, c in pairs(ents.FindByClass("weapon_handcuffed")) do
					if c.GetRopeLength and c.GetKidnapper and c:GetRopeLength() > 0 and c:GetKidnapper() == ply then
						isDragging = true

						break
					end
				end

				if isDragging then
					net.Start("Cuffs_TiePlayers") net.SendToServer()

					return true
				end
			end

			local tr,cuffs = GetTrace( ply )

			if tr and cuffs:GetCanGag() then
				net.Start( "Cuffs_GagPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsGagged() )
				net.SendToServer()
				return true
			end
		elseif bind:lower() == "+attack2" and pressed then
			local tr,cuffs = GetTrace( ply )

			if tr and cuffs:GetCanBlind() then
				net.Start( "Cuffs_BlindPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsBlind() )
				net.SendToServer()

				return true
			end
		elseif bind:lower() == "+reload" and pressed then
			local tr,cuffs = GetTrace( ply )

			if tr and cuffs:GetRopeLength() > 0 then
				net.Start( "Cuffs_DragPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( LocalPlayer() ~= cuffs:GetKidnapper() )
				net.SendToServer()

				return true
			end
		elseif bind:lower() == "+use" and pressed then
			local tr, cuffs = GetTrace( ply )

			if tr then
				net.Start( "Cuffs_FreePlayer" )
					net.WriteEntity( tr.Entity )
				net.SendToServer()

				return true
			else
				local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )

				if IsValid(tr.Entity) and tr.Entity:GetNWBool("Cuffs_TieHook") then
					net.Start("Cuffs_UntiePlayers") net.SendToServer()
				end
			end
		end
	end)

	-- Render
	local DragBone = "ValveBiped.Bip01_R_Hand"
	local LeashBone = "ValveBiped.Bip01_Neck1"
	local LeashAltBone = "Neck"
	local LeashHolder = "ValveBiped.Bip01_R_Hand"
	local DefaultRope = Material("cable/rope")

	hook.Add( "PostDrawOpaqueRenderables", "Cuffs DragRope", function()
		local allCuffs = ents.FindByClass( "weapon_handcuffed" )

		for i = 1,#allCuffs do
			local cuff = allCuffs[i]
			if not (IsValid(cuff) and IsValid(cuff.Owner) and cuff.GetRopeLength and cuff:GetRopeLength() > 0 and cuff.GetKidnapper and IsValid(cuff:GetKidnapper())) then continue end

			local kidnapper = cuff:GetKidnapper()
			local kidPos = (kidnapper:IsPlayer() and kidnapper:GetPos() + Vector(0,0,37)) or kidnapper:GetPos()

			local carryPly = cuff.Owner:GetNWEntity("Unarmed.CarriedPlayer")
			if IsValid(carryPly) then
				continue
			end

			local pos = cuff.Owner:GetPos()
			if cuff:GetIsLeash() then
				local bone = cuff.Owner:LookupBone( LeashBone )

				if not bone then
					bone = cuff.Owner:LookupBone( LeashAltBone )
				end

				if bone then
					pos = cuff.Owner:GetBonePosition( bone )

					if (pos.x == 0 and pos.y == 0 and pos.z == 0) then pos = cuff.Owner:GetPos() end
				end

				if kidnapper ~= LocalPlayer() or (hook.Call("ShouldDrawLocalPlayer", GAMEMODE, LocalPlayer())) then -- Looks weird first-person
					local lBone = kidnapper:LookupBone(LeashHolder)

					if lBone then
						local newPos = kidnapper:GetBonePosition( lBone )

						if newPos and (newPos.x ~= 0 and newPos.y ~= 0 and newPos.z ~= 0) then
							kidPos = newPos
						end
					end
				end
			else
				local bone = cuff.Owner:LookupBone( DragBone )

				if bone then
					pos = cuff.Owner:GetBonePosition( bone )

					if (pos.x == 0 and pos.y == 0 and pos.z == 0) then pos = cuff.Owner:GetPos() end
				end
			end

			if not cuff.RopeMat then cuff.RopeMat = DefaultRope end

			render.SetMaterial( cuff.RopeMat )
			render.DrawBeam( kidPos, pos, 0.7, 0, 5, Col.Rope )
			render.DrawBeam( pos, kidPos, -0.7, 0, 5, Col.Rope )
		end
	end)

	local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
	local RopeCol = Color(255,255,255)

	local wrender = {
		left = {bone = "ValveBiped.Bip01_L_Hand", pos = Vector(0,0,0), ang = Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
		right = {bone = "ValveBiped.Bip01_R_Hand", pos = Vector(0.2,0,0), ang = Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
		rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
	}

	local function GetBonePos( bonename, vm )
		local bone = vm:LookupBone( bonename )
		if not bone then return end

		local pos,ang = Vector(0,0,0),Angle(0,0,0)

		local matrix = vm:GetBoneMatrix( bone )
		if matrix then
			pos = matrix:GetTranslation()
			ang = matrix:GetAngles()
		end

		return pos, ang
	end

	hook.Add( "PostDrawOpaqueRenderables", "Cuffs.Ragdoll", function()
		local allCuffs = ents.FindByClass( "prop_ragdoll" )

		for i = 1,#allCuffs do
			local cuff = allCuffs[i]

			if not (cuff:GetNWFloat("Cuff.RopeLength", 0) and cuff:GetNWFloat("Cuff.RopeLength", 0) > 0 and cuff:GetNWEntity("Cuff.Kidnapper", NULL) and IsValid(cuff:GetNWEntity("Cuff.Kidnapper", NULL))) then continue end
			if not (cuff:GetOwner() and IsValid(cuff:GetOwner())) then continue end
			if not (cuff:GetOwner():GetNWEntity("Deathsystem.Corpse", NULL) and cuff:GetOwner():GetNWEntity("Deathsystem.Corpse", NULL) == cuff) then continue end

			if not IsValid(cuff.cmdl_LeftCuff) then
				cuff.cmdl_LeftCuff = ClientsideModel(CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if not IsValid(cuff.cmdl_LeftCuff) then return end

				cuff.cmdl_LeftCuff:SetNoDraw(true)
			end

			if not IsValid(cuff.cmdl_RightCuff) then
				cuff.cmdl_RightCuff = ClientsideModel(CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if not IsValid(cuff.cmdl_RightCuff) then return end

				cuff.cmdl_RightCuff:SetNoDraw(true)
			end

			local lpos, lang = GetBonePos(wrender.left.bone, cuff)
			local rpos, rang = GetBonePos(wrender.right.bone, cuff)

			if not (lpos and rpos and lang and rang) then return end

			-- Left
			cuff.cmdl_LeftCuff:SetPos(lpos + (lang:Forward() * wrender.left.pos.x) + (lang:Right() * wrender.left.pos.y) + (lang:Up() * wrender.left.pos.z))

			local u, r, f = lang:Up(), lang:Right(), lang:Forward() -- Prevents moving axes
			lang:RotateAroundAxis(u, wrender.left.ang.y)
			lang:RotateAroundAxis(r, wrender.left.ang.p)
			lang:RotateAroundAxis(f, wrender.left.ang.r)

			cuff.cmdl_LeftCuff:SetAngles(lang)

			local matrix = Matrix()
			matrix:Scale(wrender.left.scale)

			cuff.cmdl_LeftCuff:EnableMatrix("RenderMultiply", matrix)
			cuff.cmdl_LeftCuff:SetMaterial(cuff:GetNWString("Cuff.CuffMaterial", ""))
			cuff.cmdl_LeftCuff:DrawModel()

			-- Right
			cuff.cmdl_RightCuff:SetPos(rpos + (rang:Forward() * wrender.right.pos.x) + (rang:Right() * wrender.right.pos.y) + (rang:Up() * wrender.right.pos.z))

			local u, r, f = rang:Up(), rang:Right(), rang:Forward() -- Prevents moving axes

			rang:RotateAroundAxis(u, wrender.right.ang.y)
			rang:RotateAroundAxis(r, wrender.right.ang.p)
			rang:RotateAroundAxis(f, wrender.right.ang.r)

			cuff.cmdl_RightCuff:SetAngles(rang)

			local matrix = Matrix()
			matrix:Scale(wrender.right.scale)

			cuff.cmdl_RightCuff:EnableMatrix("RenderMultiply", matrix)
			cuff.cmdl_RightCuff:SetMaterial(cuff:GetNWString("Cuff.CuffMaterial", ""))
			cuff.cmdl_RightCuff:DrawModel()

			-- Rope
			if (lpos.x == 0 and lpos.y == 0 and lpos.z == 0) or (rpos.x == 0 and rpos.y == 0 and rpos.z == 0) then return end -- Rope accross half the map...

			cuff.Rope = DefaultRope

			if cuff:GetNWString("Cuff.CuffRope", "") != "" then
				cuff.Rope = Material(cuff:GetNWString("Cuff.CuffRope", ""))
			end
			render.SetMaterial(cuff.Rope)
			render.DrawBeam(lpos + (lang:Forward() * wrender.rope.l.x) + (lang:Right() * wrender.rope.l.y) + (lang:Up() * wrender.rope.l.z), rpos + (rang:Forward() * wrender.rope.r.x) + (rang:Right() * wrender.rope.r.y) + (rang:Up() * wrender.rope.r.z), 0.7, 0, 5, RopeCol)
		end
	end)

	local HeadBone = "ValveBiped.Bip01_Head1"
	local RenderPos = {
		Blind = {Vector(3.5,3,2.6), Vector(3.8,4.8,0), Vector(3.5,3,-2.8), Vector(2.4,-2,-3.8), Vector(1.5,-4.5,0), Vector(2.4,-2,3.8)},
		Gag = {Vector(1.0,4.2,2), Vector(1.0,5.5,-0.1), Vector(1.0,4.5,-2), Vector(0,0,-3.4), Vector(-0.8,-3,0), Vector(0,0,3.4)},
	}

	hook.Add( "PostPlayerDraw", "Cuffs DrawGag", function( ply )
		if not IsValid(ply) then return end

		local cuffed, cuff = ply:IsHandcuffed()

		if not (cuffed and IsValid(cuff)) then return end

		render.SetMaterial( DefaultRope )

		if cuff:GetIsBlind() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )

			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end

			if pos and ang then
				local firstpos = pos + (ang:Forward() * RenderPos.Blind[1].x) + (ang:Right() * RenderPos.Blind[1].y) + (ang:Up() * RenderPos.Blind[1].z)
				local lastpos = firstpos

				for i = 2,#RenderPos.Blind do
					local newPos = pos + (ang:Forward() * RenderPos.Blind[i].x) + (ang:Right() * RenderPos.Blind[i].y) + (ang:Up() * RenderPos.Blind[i].z)

					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end

				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end

		if cuff:GetIsGagged() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )

			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end

			if pos and ang then
				local firstpos = pos + (ang:Forward() * RenderPos.Gag[1].x) + (ang:Right() * RenderPos.Gag[1].y) + (ang:Up() * RenderPos.Gag[1].z)
				local lastpos = firstpos

				for i = 2,#RenderPos.Gag do
					local newPos = pos + (ang:Forward() * RenderPos.Gag[i].x) + (ang:Right() * RenderPos.Gag[i].y) + (ang:Up() * RenderPos.Gag[i].z)

					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end

				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end
	end)
end
--addons/fusioncutter/lua/fusioncutter/cl_fusioncutter.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | CL         --
---------------------------------------

-- Closes the Medicsystem menu.
--
function Fusioncutter:CloseMenu()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Select an fusioncutter mode
--
-- @return? Function callback
function Fusioncutter:SelectMode()
	local activeWeapon = LocalPlayer():GetActiveWeapon()
	if not IsValid(activeWeapon) then return end
	if not activeWeapon.IsFusioncutter then return end

	self:CloseMenu()
	self.SelectedMode = nil

	local w, h = ScrW() * 0.4, ScrH() * 0.45
	self.Frame = vgui.Create("DFrame")
	self.Frame:SetPos((ScrW() - w) / 2, (ScrH() - h) / 2)
	self.Frame:SetSize(w, h)
	self.Frame:SetTitle("")
	self.Frame:ShowCloseButton(false)
	function self.Frame:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, GetColor("darkgray"))
		self:DrawOutlinedRect()
	end

	self.Title = vgui.Create("DPanel", self.Frame)
	self.Title:SetPos(w * 0.1, h * 0.01)
	self.Title:SetSize(w * 0.8, h * 0.12)
	function self.Title:Paint(width, height)
		draw.RoundedBox(0, w * 0.05, 0, width - w * 0.05 * 2, height, UI.BackgroundColor2)

		surface.SetDrawColor(UI.BackgroundColor2)
		draw.NoTexture()

		surface.DrawPoly({
			{x = 0, y = 0},
			{x = w * 0.051, y = 0},
			{x = w * 0.051, y = height}
		})
		surface.DrawPoly({
			{x = width - w * 0.051, y = 0},
			{x = width, y = 0},
			{x = width - w * 0.051, y = height}
		})

		draw.DrawText("Wähle einen Modus", "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
	end

	self.Close = vgui.Create("EGMCloseButton", self.Frame)
	self.Close:SetPanel(self.Frame)
	self.Close:SetPos(w * 0.95, h * 0.01)
	self.Close:SetSize(h * 0.07, h * 0.07)

	self.ModeList = vgui.Create("EGMListView", self.Frame)
	self.ModeList:SetSize(w * 0.5, h * 0.6)
	self.ModeList:SetPos(w * 0.005, h * 0.2)
	self.ModeList:SetMultiSelect(false)
	self.ModeList:SetSortable(false)
	self.ModeList:SetHeaderHeight(h * 0.1)
	self.ModeList:SetDataHeight(h * 0.075)
	self.ModeList:AddCustomColumn("Modi")
	function self.ModeList:OnRowSelected(index, line)
		local infoPanel = Fusioncutter.ModeInfo
		local mode = line.mode

		infoPanel:SetText("")

		infoPanel:InsertColorChange(GetColor2("blue"))
		infoPanel:AppendText(Fusioncutter.Modes[mode].displayName .. "\n")
		infoPanel:InsertColorChange(GetColor2("white"))
		infoPanel:AppendText(Fusioncutter.Modes[mode].description)

		Fusioncutter.SelectedMode = mode
	end
	function self.ModeList:OnRowRightClick(index, line)
		local contextMenu = DermaMenu(line)
		local optionPanel = contextMenu:AddOption("Auswählen", function()
			net.Start("Fusioncutter.SelectMode")
				net.WriteString(line.mode)
			net.SendToServer()

			Fusioncutter.Frame:Close()
		end)
		optionPanel:SetColor(GetColor("white"))
		optionPanel:SetFont("EGMText6")
		function contextMenu:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, GetColor("gray"))
			surface.SetDrawColor(GetColor("blue"))
			self:DrawOutlinedRect()
		end

		contextMenu:Open()
	end
	function self.ModeList:Refresh(searchValue)
		if not searchValue then searchValue = "" end

		self:Clear()

		for mode, modeData in SortedPairsByMemberValue(Fusioncutter.Modes, "displayName") do
			if not activeWeapon.Modes[mode] then continue end

			if string.find(string.lower(modeData.displayName), string.lower(searchValue)) then
				local line = self:AddCustomLine(modeData.displayName)
				line.mode = mode
			end
		end
	end
	self.ModeList:Refresh()

	self.ModeFilter = vgui.Create("DTextEntry", self.Frame)
	self.ModeFilter:SetPos(w * 0.005, h * 0.91)
	self.ModeFilter:SetSize(w * 0.5, h * 0.08)
	self.ModeFilter:SetUpdateOnType(false)
	self.ModeFilter:SetPlaceholderText("Modus suchen...")
	function self.ModeFilter:OnValueChange(newFilter)
		Fusioncutter.ModeList:Refresh(newFilter)
	end

	self.ModeInfo = vgui.Create("RichText", self.Frame)
	self.ModeInfo:SetSize(w * 0.5, h * 0.7)
	self.ModeInfo:SetPos(w * 0.51, h * 0.2)
	self.ModeInfo:SetVerticalScrollbarEnabled(false)
	self.ModeInfo:SetText("")
	function self.ModeInfo:PerformLayout()
		self:SetFontInternal("EGMText10")
	end

	self.Frame:MakePopup()
end

-- Draws the health of a mine
--
-- @param? String mode
-- @param? Entity target
hook.Add("Fusioncutter.DrawInfo", "Fusioncutter.DrawMine", function(mode, target)
	if mode == "mines" and target.IsMine then
		draw.RoundedBox(0, ScrW() / 2- 80, ScrH() / 2 + 5, 160, 60, UI.BackgroundColor)
		draw.SimpleText("Zustand", "EGMText8", ScrW() / 2, ScrH() / 2 + 13, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(target:Health() , "EGMText8", ScrW() / 2, ScrH() / 2 + 30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end)

-- Draws the armor of a player
--
-- @param? String mode
-- @param? Player target
hook.Add("Fusioncutter.DrawInfo", "Fusioncutter.DrawArmor", function(mode, target)
	if mode == "repairkit" and target:IsPlayer() then
		draw.RoundedBox(0, ScrW() / 2- 80, ScrH() / 2 + 5, 160, 60, UI.BackgroundColor)
		draw.SimpleText("Rüstung", "EGMText8", ScrW() / 2, ScrH() / 2 + 13, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(target:Armor() , "EGMText8", ScrW() / 2, ScrH() / 2 + 30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end)

-- Draws the health of droids
--
-- @param? String mode
-- @param? Player target
hook.Add("Fusioncutter.DrawInfo", "Fusioncutter.DrawDroidHealth", function(mode, target)
	if mode == "droidkit" and target:IsPlayer() and Realism.Droids[target:GetModel()] then
		draw.RoundedBox(0, ScrW() / 2- 80, ScrH() / 2 + 5, 160, 60, UI.BackgroundColor)
		draw.SimpleText("Lebenspunkte", "EGMText8", ScrW() / 2, ScrH() / 2 + 13, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(target:Health() , "EGMText8", ScrW() / 2, ScrH() / 2 + 30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end)


--lua/autorun/sh_legs.lua:
--[[
	   ______                    __   __                   
	  / ____/___ ___  ____  ____/ /  / /   ___  ____ ______
	 / / __/ __ `__ \/ __ \/ __  /  / /   / _ \/ __ `/ ___/
	/ /_/ / / / / / / /_/ / /_/ /  / /___/  __/ /_/ (__  ) 
	\____/_/ /_/ /_/\____/\__,_/  /_____/\___/\__, /____/  
	                                         /____/        
	@Valkyrie, @blackops7799
]]--
    
g_LegsLog =
[[
	[ADD] New VAddons Menu	
	[ADD] Support for Outfitter
	[ADD] Compat Support for VWallrun, Mantle thanks to SpiffyJUNIOR
	[FIX] Models now always rely on gmod's GetModel() due to gmod updates being more reliable now for older models
	[CHANGE] cl_vehlegs is off by default
]]

g_LegsVer = "3.10"

local PLAYER 			= FindMetaTable("Player")
local ENTITY 			= FindMetaTable("Entity")

local bHasShownNotice = false
do
	function PLAYER:GetLegModel()
        if (CLIENT) then
            if (LocalPlayer().enforce_model) then
                return LocalPlayer().enforce_model
            end
        end
		return self:GetModel()
	end
end


if (SERVER) then
    AddCSLuaFile("sh_legs.lua")
end

if (CLIENT) then
	local LegsBool      	= CreateConVar("cl_legs", "1", {FCVAR_ARCHIVE}, "Enable/Disable the rendering of the legs")
	local VLegsBool     	= CreateConVar("cl_vehlegs", "0", {FCVAR_ARCHIVE}, "Enable/Disable the rendering of the legs in vehicles")

    local Legs = {}
    Legs.LegEnt = nil

	local g_maxseqgroundspeed = 0
	local g_velocity = 0

    function Legs:CheckDrawVehicle()
        if (LocalPlayer():InVehicle()) then
			if LegsBool:GetBool() && !VLegsBool:GetBool() then
				return true
			end
			return false
        end
    end

    function ShouldDrawLegs()
        if (hook.Run("ShouldDisableLegs") == true) then 
            return false 
        end
        if LegsBool:GetBool() then
            return  IsValid(Legs.LegEnt)                                                                        &&
                    (LocalPlayer():Alive() || (LocalPlayer().IsGhosted && LocalPlayer():IsGhosted()))           &&
                    !Legs:CheckDrawVehicle()                                                                    &&
                    GetViewEntity() == LocalPlayer()                                                            &&
                    !LocalPlayer():ShouldDrawLocalPlayer()                                                      &&
                    !IsValid(LocalPlayer():GetObserverTarget())                                                 &&
                    !LocalPlayer().ShouldDisableLegs
        else
            return false
        end
    end

    function GetPlayerLegs(ply)
        return ply && ply != LocalPlayer() && ply || (ShouldDrawLegs() && Legs.LegEnt || LocalPlayer())
    end

    function Legs:SetUp()

		if (!IsValid(self.LegEnt)) then
			self.LegEnt = ClientsideModel(LocalPlayer():GetLegModel(), RENDER_GROUP_OPAQUE_ENTITY)	
		else
			self.LegEnt:SetModel(LocalPlayer():GetLegModel())
		end

        self.LegEnt:SetNoDraw(true)

		for k, v in pairs(LocalPlayer():GetBodyGroups()) do
			local current = LocalPlayer():GetBodygroup(v.id)
			self.LegEnt:SetBodygroup(v.id,  current)
		end

		for k, v in ipairs(LocalPlayer():GetMaterials()) do
			self.LegEnt:SetSubMaterial(k - 1, LocalPlayer():GetSubMaterial(k - 1))
		end

        self.LegEnt:SetSkin(LocalPlayer():GetSkin())
        self.LegEnt:SetMaterial(LocalPlayer():GetMaterial())
        self.LegEnt:SetColor(LocalPlayer():GetColor())
        self.LegEnt.GetPlayerColor = function()
            return LocalPlayer():GetPlayerColor()
        end

		self.LegEnt.Anim = nil
	   	self.PlaybackRate = 1
		self.Sequence = nil
		self.Velocity = 0
		self.OldWeapon = nil
		self.HoldType = nil

		self.BonesToRemove = {}

		self.BoneMatrix = nil

        self.LegEnt.LastTick = 0

		self:Update(g_maxseqgroundspeed)
    end

    Legs.PlaybackRate = 1
    Legs.Sequence = nil
    Legs.Velocity = 0
    Legs.OldWeapon = nil
    Legs.HoldType = nil

    Legs.BonesToRemove = {}

    Legs.BoneMatrix = nil

    function Legs:WeaponChanged(weap)
        if IsValid(self.LegEnt) then
            for i = 0, self.LegEnt:GetBoneCount() do
                self.LegEnt:ManipulateBoneScale(i, Vector(1,1,1))
                self.LegEnt:ManipulateBonePosition(i, vector_origin)
            end

            self.BonesToRemove =
            {
                "ValveBiped.Bip01_Head1",
                "ValveBiped.Bip01_L_Hand",
                "ValveBiped.Bip01_L_Forearm",
                "ValveBiped.Bip01_L_Upperarm",
                "ValveBiped.Bip01_L_Clavicle",
                "ValveBiped.Bip01_R_Hand",
                "ValveBiped.Bip01_R_Forearm",
                "ValveBiped.Bip01_R_Upperarm",
                "ValveBiped.Bip01_R_Clavicle",
                "ValveBiped.Bip01_L_Finger4",
                "ValveBiped.Bip01_L_Finger41",
                "ValveBiped.Bip01_L_Finger42",
                "ValveBiped.Bip01_L_Finger3",
                "ValveBiped.Bip01_L_Finger31",
                "ValveBiped.Bip01_L_Finger32",
                "ValveBiped.Bip01_L_Finger2",
                "ValveBiped.Bip01_L_Finger21",
                "ValveBiped.Bip01_L_Finger22",
                "ValveBiped.Bip01_L_Finger1",
                "ValveBiped.Bip01_L_Finger11",
                "ValveBiped.Bip01_L_Finger12",
                "ValveBiped.Bip01_L_Finger0",
                "ValveBiped.Bip01_L_Finger01",
                "ValveBiped.Bip01_L_Finger02",
                "ValveBiped.Bip01_R_Finger4",
                "ValveBiped.Bip01_R_Finger41",
                "ValveBiped.Bip01_R_Finger42",
                "ValveBiped.Bip01_R_Finger3",
                "ValveBiped.Bip01_R_Finger31",
                "ValveBiped.Bip01_R_Finger32",
                "ValveBiped.Bip01_R_Finger2",
                "ValveBiped.Bip01_R_Finger21",
                "ValveBiped.Bip01_R_Finger22",
                "ValveBiped.Bip01_R_Finger1",
                "ValveBiped.Bip01_R_Finger11",
                "ValveBiped.Bip01_R_Finger12",
                "ValveBiped.Bip01_R_Finger0",
                "ValveBiped.Bip01_R_Finger01",
                "ValveBiped.Bip01_R_Finger02",
                "ValveBiped.Bip01_Spine4",
                "ValveBiped.Bip01_Spine2",
            }

			if ( LocalPlayer():InVehicle() ) then
				self.BonesToRemove =
          	  	{
               		"ValveBiped.Bip01_Head1",
				}
			end

            for k, v in pairs(self.BonesToRemove) do
                local bone = self.LegEnt:LookupBone(v)
                if (bone) then
                    self.LegEnt:ManipulateBoneScale(bone, Vector(0,0,0))
                   	if ( !LocalPlayer():InVehicle() ) then
						self.LegEnt:ManipulateBonePosition(bone, Vector(0,-100,0))
						self.LegEnt:ManipulateBoneAngles(bone, Angle(0,0,0))
					end
                end
            end
        end
    end

    Legs.BreathScale = 0.5
    Legs.NextBreath = 0

    function Legs:Think(maxseqgroundspeed)
        if not LocalPlayer():Alive() then
            Legs:SetUp()
            return
        end

		self:Update(maxseqgroundspeed)
    end

	function Legs:Update(maxseqgroundspeed)
        if IsValid(self.LegEnt) then
            self:WeaponChanged(LocalPlayer():GetActiveWeapon())

            self.Velocity = LocalPlayer():GetVelocity():Length2D()

            self.PlaybackRate = 1

            if self.Velocity > 0.5 then
                if maxseqgroundspeed < 0.001 then
                    self.PlaybackRate = 0.01
                else
                    self.PlaybackRate = self.Velocity / maxseqgroundspeed
                    self.PlaybackRate = math.Clamp(self.PlaybackRate, 0.01, 10)
                end
            end

            self.LegEnt:SetPlaybackRate(self.PlaybackRate)

            self.Sequence = LocalPlayer():GetSequence()

            if (self.LegEnt.Anim != self.Sequence) then
                self.LegEnt.Anim = self.Sequence
                self.LegEnt:ResetSequence(self.Sequence)
            end

            self.LegEnt:FrameAdvance(CurTime() - self.LegEnt.LastTick)
            self.LegEnt.LastTick = CurTime()

            Legs.BreathScale = sharpeye && sharpeye.GetStamina && math.Clamp(math.floor(sharpeye.GetStamina() * 5 * 10) / 10, 0.5, 5) || 0.5

            if Legs.NextBreath <= CurTime() then
                Legs.NextBreath = CurTime() + 1.95 / Legs.BreathScale
                self.LegEnt:SetPoseParameter("breathing", Legs.BreathScale)
            end

            self.LegEnt:SetPoseParameter("move_x", (LocalPlayer():GetPoseParameter("move_x") * 2) - 1) -- Translate the walk x direction
            self.LegEnt:SetPoseParameter("move_y", (LocalPlayer():GetPoseParameter("move_y") * 2) - 1) -- Translate the walk y direction
            self.LegEnt:SetPoseParameter("move_yaw", (LocalPlayer():GetPoseParameter("move_yaw") * 360) - 180) -- Translate the walk direction
            self.LegEnt:SetPoseParameter("body_yaw", (LocalPlayer():GetPoseParameter("body_yaw") * 180) - 90) -- Translate the body yaw
            self.LegEnt:SetPoseParameter("spine_yaw",(LocalPlayer():GetPoseParameter("spine_yaw") * 180) - 90) -- Translate the spine yaw

            if LocalPlayer():InVehicle() then
                self.LegEnt:SetPoseParameter("vehicle_steer", (LocalPlayer():GetVehicle():GetPoseParameter("vehicle_steer") * 2) - 1) -- Translate the vehicle steering
            end
        end
	end

    hook.Add("UpdateAnimation", "GML:UpdateAnimation", function(ply, velocity, maxseqgroundspeed)
        if ply == LocalPlayer() then
            if IsValid(Legs.LegEnt) then
                Legs:Think(maxseqgroundspeed)
				if (string.lower(LocalPlayer():GetLegModel()) != string.lower(Legs.LegEnt:GetModel())) then
                    Legs:SetUp()
				end
            else
				Legs:SetUp()
			end
        end
    end)

    Legs.RenderAngle = nil
    Legs.BiaisAngle = nil
    Legs.RadAngle = nil
    Legs.RenderPos = nil
    Legs.RenderColor = {}
    Legs.ClipVector = vector_up * -1
    Legs.ForwardOffset = -24

	function Legs:DoFinalRender()
	   cam.Start3D(EyePos(), EyeAngles())
            if ShouldDrawLegs() then

                if (LocalPlayer():Crouching() || LocalPlayer():InVehicle()) then
                    self.RenderPos = LocalPlayer():GetPos()
                else
                    self.RenderPos = LocalPlayer():GetPos() + Vector(0,0,5)
                end

                if LocalPlayer():InVehicle() then
                    self.RenderAngle = LocalPlayer():GetVehicle():GetAngles()
                    self.RenderAngle:RotateAroundAxis(self.RenderAngle:Up(), 90)
                else
                    self.BiaisAngles = sharpeye_focus && sharpeye_focus.GetBiaisViewAngles && sharpeye_focus:GetBiaisViewAngles() || LocalPlayer():EyeAngles()
                    self.RenderAngle = Angle(0, self.BiaisAngles.y, 0)
                    self.RadAngle = math.rad(self.BiaisAngles.y)
                    self.ForwardOffset = -22
                    self.RenderPos.x = self.RenderPos.x + math.cos(self.RadAngle) * self.ForwardOffset
                    self.RenderPos.y = self.RenderPos.y + math.sin(self.RadAngle) * self.ForwardOffset

                    if LocalPlayer():GetGroundEntity() == NULL then
                        self.RenderPos.z = self.RenderPos.z + 8
                        if LocalPlayer():KeyDown(IN_DUCK) then
                            self.RenderPos.z = self.RenderPos.z - 28
                        end
                    end
                end

                self.RenderColor = LocalPlayer():GetColor()

                local bEnabled = render.EnableClipping(true)
                    render.PushCustomClipPlane(self.ClipVector, self.ClipVector:Dot(EyePos()))
                        render.SetColorModulation(self.RenderColor.r / 255, self.RenderColor.g / 255, self.RenderColor.b / 255)
                            render.SetBlend(self.RenderColor.a / 255)
                                    self.LegEnt:SetRenderOrigin(self.RenderPos)
                                    self.LegEnt:SetRenderAngles(self.RenderAngle)
                                    self.LegEnt:SetupBones()
                                    self.LegEnt:DrawModel()
									self.LegEnt:SetRenderOrigin()
                                    self.LegEnt:SetRenderAngles()
                            render.SetBlend(1)
                        render.SetColorModulation(1, 1, 1)
                    render.PopCustomClipPlane()
                render.EnableClipping(bEnabled)
            end
        cam.End3D()
	end

	hook.Add("PostDrawTranslucentRenderables", "GML:Render::Foot", function()
		 if (LocalPlayer() && !LocalPlayer():InVehicle()) then
			Legs:DoFinalRender()
        end
    end)

	hook.Add("RenderScreenspaceEffects", "GML:Render::Vehicle", function()
		 if (LocalPlayer():InVehicle()) then
			Legs:DoFinalRender()
        end
    end)

    concommand.Add("cl_togglelegs", function()
        if LegsBool:GetBool() then
            RunConsoleCommand("cl_legs", "0")
        else
            RunConsoleCommand("cl_legs", "1")
        end
    end)

	concommand.Add("cl_togglevlegs", function()
        if VLegsBool:GetBool() then
            RunConsoleCommand("cl_vehlegs", "0")
        else
            RunConsoleCommand("cl_vehlegs", "1")
        end
    end)

	concommand.Add("cl_refreshlegs", function()
		Legs:SetUp()
    end)

    g_Legs = Legs

    function SetupLegs()
        g_Legs:SetUp()
    end
end
--lua/autorun/sh_starwarsfusioncutter_convars.lua:
local convarFlags = {FCVAR_NOTIFY}
local convarPrefix = "sv_starwarsfusioncutter_"

CreateConVar(convarPrefix .. "enable_door_unlocking", 1, convarFlags) -- Allow door unlocking
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_button.lua:
local adraw = include("libs/advanceddraw.lua")
local PANEL = {}

function PANEL:Init()
    self.Text = ""
    self:SetCursor("hand")
end

function PANEL:SetText(t)
    self.Text = t
end

function PANEL:SetCentered(c)
    self.Centered = c
end

function PANEL:Paint(w,h)
    if (self:IsHovered()) then
        draw.RoundedBox(0,0,0,w,h,Color(10,10,10,200))
    end

    local ah = TEXT_ALIGN_LEFT
    local leftMargin = self:GetWide() * 0.02

    if (self.Centered) then
        ah = TEXT_ALIGN_CENTER
        leftMargin = self:GetWide() * 0.5
    end

    draw.SimpleText(self.Text, "SwuRowText", leftMargin, self:GetTall() * 0.5, Color(255,255,255), ah, TEXT_ALIGN_CENTER)
end

function PANEL:OnMouseReleased(keyCode)
    if (keyCode ~= MOUSE_LEFT) then return end

    self:OnClick()
end

function PANEL:OnClick() end

vgui.Register("swu_button", PANEL, "DPanel")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_planetinfo_panel.lua:
local PANEL = {}

local swuIconMaterial = Material("the-coding-ducks/swu/icons/swu-icon.png", "smooth")

function PANEL:Init()
    self:SetBackgroundColor(Color(50,50,50,100))

    local p = self:GetWide() * 0.2
    self:DockPadding(p,p,p,p)

    self.GotoButton = self:Add("swu_button")
    self.GotoButton:SetText("GOTO")
    self.GotoButton:SetCentered(true)
    self.GotoButton:Dock(BOTTOM)
    self.GotoButton:SetSize(0, ScrH() * 0.03)
    self.GotoButton.OnClick = function ()
        if (not istable(self.Planet)) then return end

        net.Start("swu_setShipPos")
        net.WriteVector(self.Planet.pos - Vector(1,0,0))
        net.WriteAngle(Angle())
        net.SendToServer()
    end

    self.logo = self:Add("DPanel")
    self.logo:Dock(TOP)
    function self.logo:Paint(w,h)
        if not self.ratioSet then
            self:SetSize(w,w)
            self.ratioSet = true
        end

        surface.SetDrawColor(Color(255,255,255))
        surface.SetMaterial(swuIconMaterial)
        surface.DrawTexturedRect(w * 0.1,w * 0.1,w * 0.8,w * 0.8)
    end

    self.topExtraBar = self:CreateLine()

    self.planetName = self:Add("DLabel")
    self.planetName:Dock(TOP)
    self.planetName:SetContentAlignment(5)
    self.planetName:SetFont("SwuHeader")
    self.planetName:SetText("No Planet Selected")
    self.planetName:SetColor(SWU.Colors.Default.accent)
    self.planetName:DockMargin(0,self:GetTall() * 0.5,0,self:GetTall() * 0.5)

    self.bottomExtraBar = self:CreateLine()


    self.planetPositionContainer = self:Add("DPanel")
    self.planetPositionContainer:Dock(TOP)
    self.planetPositionContainer.Paint = function () end

    self.planetPositionTitle = self.planetPositionContainer:Add("DLabel")
    self.planetPositionTitle:Dock(LEFT)
    self.planetPositionTitle:SetContentAlignment(4)
    self.planetPositionTitle:SetFont("SwuRowText")
    self.planetPositionTitle:SetText("Position")
    self.planetPositionTitle:SetColor(SWU.Colors.Default.accent)

    self.planetPosition = self.planetPositionContainer:Add("DLabel")
    self.planetPosition:Dock(RIGHT)
    self.planetPosition:SetContentAlignment(6)
    self.planetPosition:SetFont("SwuRowText")
    self.planetPosition:SetText("[0 : 0]")
    self.planetPosition:SetColor(SWU.Colors.Default.passive)

    self.planetPosition:SizeToContents()
    self.planetPositionTitle:SizeToContents()

    self.planetPositionContainer:SizeToContents()
    self.planetPositionContainer:DockMargin(0,self:GetTall() * 0.5,0,self:GetTall() * 0.5)

end

function PANEL:LoadPlanet(p)
    self.Planet = p
    self.planetName:SetText(p.name)
    self.planetPosition:SetText("[" .. math.Round(p.pos.x, 2) .. " : " .. math.Round(p.pos.y, 2) .. "]")


    self.planetPosition:SizeToContents()
    self.planetPositionTitle:SizeToContents()
    self.planetPositionContainer:SizeToContents()
end

function PANEL:CreateLine()
    local line = self:Add("DPanel")
    line:Dock(TOP)
    line:SetSize(0, ScrH() * 0.004)
    function line:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(255,255,255,255))
    end
end


vgui.Register("swu_planetinfo_panel", PANEL, "swu_basepanel")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_searchframe.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize(ScrW(), ScrH())
    self:SetTitle("")
    self:ShowCloseButton(false)
    self:SetDraggable(false)
    self:DockPadding(0,0,0,0)

    self:MakePopup()

    self.SearchField = self:Add("swu_inputfield")
    local searchField = self.SearchField
    searchField:SetSize(ScrW() * 0.4, ScrH() * 0.1)
    searchField:SetIconRight("the-coding-ducks/swu/icons/search-icon.png", nil, function ()
        self:Search()
    end, SWU.Colors.Default.primary, SWU.Colors.Default.accent)
    searchField:SetOnEnter(function () self:Search() end)
    searchField:Center()
    searchField:RequestFocus()
end

function PANEL:SetEntity(ent)
    self.ent = ent
end

function PANEL:GetEntity()
    return self.ent
end

function PANEL:Search()
    if (not IsValid(self:GetEntity())) then self:Remove() return end

    self:GetEntity():UpdatePlanetList(self.SearchField:GetValue())
    SWU.Util.IgnoreEnter = CurTime()
    self:Remove()
end

function PANEL:OnMouseReleased(keyCode)
    if (keyCode ~= MOUSE_LEFT) then return end

    -- Workaround that the frame doesn't open again, thanks IMGUI
    timer.Simple(0, function ()
        self:Remove()
    end)
end

function PANEL:Think()
    if (input.IsKeyDown(KEY_ESCAPE)) then
        self:Remove()
        gui.HideGameUI()
    end
end

function PANEL:Paint()

end

vgui.Register("swu_searchframe", PANEL, "DFrame")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/tabs/cl_swu_clientconfig.lua:
local PANEL = {}

function PANEL:Init()
    self.GeneralConfig = self:Add("swu_header")
    local generalConfig = self.GeneralConfig
    generalConfig:SetText("General Config")

    local toggleChangelogRow = self:Add("swu_row")
    toggleChangelogRow:SetText("Enable Changelog")

    local toggleChangelogSwitch = toggleChangelogRow:AddContent("swu_switch")
    toggleChangelogSwitch:SetSize(self:GetWide() * 0.08, toggleChangelogRow:GetTall())
    toggleChangelogSwitch:SetHeightMultiplier(0.8)
    toggleChangelogSwitch:SetConVar("swu_enable_changelog")
    toggleChangelogSwitch.OnChange = function (_, newValue)
        LocalPlayer():ConCommand("swu_enable_changelog " .. (newValue and "1" or "0"))
    end

    local toggleInteractableRow = self:Add("swu_row")
    toggleInteractableRow:SetText("Enable Keyboard Interaction")

    local toggleInteractableSwitch = toggleInteractableRow:AddContent("swu_switch")
    toggleInteractableSwitch:SetSize(self:GetWide() * 0.08, toggleInteractableRow:GetTall())
    toggleInteractableSwitch:SetHeightMultiplier(0.8)
    toggleInteractableSwitch:SetConVar("swu_enable_interaction")
    toggleInteractableSwitch.OnChange = function (_, newValue)
        LocalPlayer():ConCommand("swu_enable_interaction " .. (newValue and "1" or "0"))

        net.Start("swu_sendInteractionConfiguration")
        net.WriteBool(newValue)
        net.SendToServer()
    end

end

vgui.Register("swu_clientconfig", PANEL, "swu_basetab")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/tabs/cl_swu_credits.lua:
local PANEL = {}

local steamIcon = Material("the-coding-ducks/swu/icons/steam-icon.png", "smooth")

local credits = {
    {
        title = "Programming",
        users = {
            {
                name = "DolUnity",
                steam = "https://steamcommunity.com/id/dolunity/"
            },
            {
                name = "Luiggi33",
                steam = "https://steamcommunity.com/id/Luiggi33/"
            },
        }
    },
    {
        title = "Modelling",
        users = {
            {
                name = "Mig",
                steam = "https://steamcommunity.com/id/mig4/"
            }
        }
    },
    {
        title = "Special Thanks",
        users = {
            {
                name = "Letha",
                steam = "https://steamcommunity.com/profiles/76561198874598078/"
            },
            {
                name = "Rufiinix",
                steam = "https://steamcommunity.com/profiles/76561198076909400"
            }
        }
    },
}

function PANEL:Init()
    for _, category in pairs(credits) do
        local header = self:Add("swu_header")
        header:SetText(category.title)

        for _, user in ipairs(category.users) do
            local row = self:Add("swu_row")
            row:SetText(user.name)

            local steamLink = row:AddContent("swu_icon")
            steamLink:SetPaintBackground(false)
            steamLink:SetMaterial(steamIcon)
            steamLink:SetColor(Color(255,255,255))
            steamLink:SetOnClick(function () gui.OpenURL(user.steam) end, Color(24,32,53), Color(46,62,102))
            steamLink:SetPadding(row:GetTall() * 0.1)
            steamLink:SetSize(row:GetTall(),row:GetTall() * 0.8)
        end
    end

end

vgui.Register("swu_credits", PANEL, "swu_basetab")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/tabs/cl_swu_serverconfig.lua:
local PANEL = {}

function PANEL:Init()
    self.GeneralConfig = self:Add("swu_header")
    local generalConfig = self.GeneralConfig
    generalConfig:SetText("General Config")

    local togglePlanetCollisionRow = self:Add("swu_row")
    togglePlanetCollisionRow:SetText("Enable planet destruction")

    local planetCollisionSwitch = togglePlanetCollisionRow:AddContent("swu_switch")
    planetCollisionSwitch:SetSize(self:GetWide() * 0.08, togglePlanetCollisionRow:GetTall())
    planetCollisionSwitch:SetHeightMultiplier(0.8)
    planetCollisionSwitch:SetConVar("swu_enable_planet_collision")
    planetCollisionSwitch.OnChange = function (_, newValue)
        net.Start("swu_modify_server_settings")
        net.WriteString("swu_enable_planet_collision")
        net.WriteString(newValue and "1" or "0")
        net.SendToServer()
    end


    local hyperspaceSpeedModifierRow = self:Add("swu_row")
    hyperspaceSpeedModifierRow:SetText("Hyperspace speed")

    local hyperspaceSpeedModifier = hyperspaceSpeedModifierRow:AddContent("swu_multiselector")
    hyperspaceSpeedModifier:SetOptions({
        {
            value = 0.25,
            text = "0.25x"
        },
        {
            value = 0.5,
            text = "0.5"
        },
        {
            value = 1,
            text = "1x"
        },
        {
            value = 2,
            text = "2x"
        },
        {
            value = 4,
            text = "4x"
        },
    })
    hyperspaceSpeedModifier:SetConVar("swu_hyperspace_speed_modifier")
    hyperspaceSpeedModifier.OnChange = function (_, newValue)
        net.Start("swu_modify_server_settings")
        net.WriteString("swu_hyperspace_speed_modifier")
        net.WriteString(tostring(newValue))
        net.SendToServer()
    end

    local toggleDeathStar = self:Add("swu_row")
    toggleDeathStar:SetText("Let the Death Star spawn on the Map (requires admin cleanup/restart)")

    local toggleDeathStarSwitch = toggleDeathStar:AddContent("swu_switch")
    toggleDeathStarSwitch:SetSize(self:GetWide() * 0.08, toggleDeathStar:GetTall())
    toggleDeathStarSwitch:SetHeightMultiplier(0.8)
    toggleDeathStarSwitch:SetConVar("swu_enable_deathstar")
    toggleDeathStarSwitch.OnChange = function (_, newValue)
        net.Start("swu_modify_server_settings")
        net.WriteString("swu_enable_deathstar")
        net.WriteString(newValue and "1" or "0")
        net.SendToServer()
    end

end

vgui.Register("swu_serverconfig", PANEL, "swu_basetab")

--lua/autorun/sh_zladder.lua:
if (SERVER) then
	function SaveLadders()
		file.CreateDir("ladders");
		file.CreateDir("ladders/ladders");
		file.CreateDir("ladders/dismounts");
		local ladders = ents.FindByClass("func_useableladder");
		local buffer = {};

		for _, v in pairs(ladders) do
			if (v:GetName():lower():find("zladder") and v:GetNWBool("saved", false)) then
				local index = #buffer + 1;

				buffer[index] = {
					origin = v:GetPos(),
					angles = v:GetAngles(),
					point0 = v:GetSaveTable().point0,
					point1 = v:GetSaveTable().point1,
					propTable = v.propTable,
					model = v.model,
					normal = v.normal
				};
			end;
		end;

		if (buffer and table.Count(buffer) > 0) then
			local JSONData = util.TableToJSON(buffer);

			file.Write("ladders/ladders/" .. game.GetMap() .. ".txt", JSONData);
		else
			file.Delete("ladders/ladders/" .. game.GetMap() .. ".txt");
		end;
	end;

	function SaveDismounts()
		file.CreateDir("ladders");
		file.CreateDir("ladders/ladders");
		file.CreateDir("ladders/dismounts");
		local buffer = {};

		for k, v in pairs(ents.FindByClass("func_useableladder")) do
			if (v:GetNWBool("saved", false) and v:GetName():lower():find("zladder")) then
				for _, dismount in pairs(ents.FindInSphere(v:GetPos() + v:GetSaveTable().point0, 200)) do
					if (IsValid(dismount) and dismount:GetClass() == "info_ladder_dismount" and dismount:GetName():lower():find("zdismount") and !dismount.saved) then
						buffer[#buffer + 1] = dismount:GetPos();
						dismount.saved = true;
					end;
				end;

				for _, dismount in pairs(ents.FindInSphere(v:GetPos() + v:GetSaveTable().point1, 200)) do
					if (IsValid(dismount) and dismount:GetClass() == "info_ladder_dismount" and dismount:GetName():lower():find("zdismount") and !dismount.saved) then
						buffer[#buffer + 1] = dismount:GetPos();
						dismount.saved = true;
					end;
				end;
			end;
		end;

		for k, v in pairs(ents.FindByClass("info_ladder_dismount")) do
			v.saved = nil;
		end;

		if (buffer and table.Count(buffer) > 0) then
			local JSONData = util.TableToJSON(buffer);

			file.Write("ladders/dismounts/" .. game.GetMap() .. ".txt", JSONData);
		else
			file.Delete("ladders/dismounts/" .. game.GetMap() .. ".txt");
		end;
	end;

	function LoadLadders()
		if (!file.Exists("ladders/ladders/" .. game.GetMap() .. ".txt", "DATA")) then return; end;

		local buffer = file.Read("ladders/ladders/" .. game.GetMap() .. ".txt", false);

		if (buffer:len() > 1) then
			buffer = util.JSONToTable(buffer);

			if (!buffer) then return; end;

			for _, data in pairs(buffer) do
				if (!data.propTable) then continue; end;

				local ladder = ents.Create("func_useableladder");
				ladder:SetPos(data.origin);
				ladder:SetAngles(data.angles);
				ladder:SetKeyValue("point0", tostring(data.origin + data.point0));
				ladder:SetKeyValue("point1", tostring(data.origin + data.point1));
				ladder:SetKeyValue("targetname", "zladder_" .. ladder:EntIndex());
				ladder:Spawn();
				ladder:SetNWBool("saved", true);
				ladder.model = data.model;
				ladder.props = {};
				ladder.propTable = {};

				for _, info in pairs(data.propTable) do
					local ladderProp = ents.Create("prop_physics");
					ladderProp:SetPos(info.origin);
					ladderProp:SetAngles(info.angles);
					ladderProp:SetModel(data.model);
					ladderProp:Spawn();
					ladderProp:DeleteOnRemove(ladder);
					ladderProp:GetPhysicsObject():EnableMotion(false);
					ladderProp:PhysicsDestroy();
					ladderProp.ladder = ladder;
					ladderProp:SetNWEntity("ladder", ladder);
					ladderProp:DrawShadow(false);
					ladderProp:SetCollisionGroup(COLLISION_GROUP_WORLD);

					table.insert(ladder.propTable, {
						origin = info.origin,
						angles = info.angles
					});

					table.insert(ladder.props, ladderProp);
				end;

				ladder:CallOnRemove("cleanup", function(ladder)
					if (!ladder.props) then return; end;

					for k, v in pairs(ladder.props) do
						SafeRemoveEntity(v);
					end;
				end);

				if (!ladder.model or !ladder.propTable or !ladder.props) then
					SafeRemoveEntity(ladder);
				end;
			end;
		end;
	end;

	function LoadDismounts()
		if (!file.Exists("ladders/dismounts/" .. game.GetMap() .. ".txt", "DATA")) then return; end;

		local buffer = file.Read("ladders/dismounts/" .. game.GetMap() .. ".txt", false);

		if (buffer:len() > 1) then
			buffer = util.JSONToTable(buffer);

			if (!buffer) then return; end;

			for _, pos in pairs(buffer) do
				local dismount = ents.Create("info_ladder_dismount");

				if (!IsValid(dismount)) then continue; end;

				dismount:SetPos(pos);
				dismount:Spawn();
				dismount:SetName("zdismount_" .. dismount:EntIndex());
			end;

			for k, v in pairs(ents.FindByClass("func_useableladder")) do
				if (IsValid(v) and v:GetName():lower():find("zladder_")) then
					-- CFuncLadder::Activate, so dismount points for ladders are updated.
					v:Activate();

					for _, dismount in pairs(ents.FindInSphere(v:GetPos() + v:GetSaveTable().point0, 120)) do
						if (IsValid(dismount) and dismount:GetClass() == "info_ladder_dismount" and dismount:GetName():lower():find("zdismount") and !IsValid(dismount:GetParent())) then
							dismount:SetParent(v);
						end;
					end;

					for _, dismount in pairs(ents.FindInSphere(v:GetPos() + v:GetSaveTable().point1, 120)) do
						if (IsValid(dismount) and dismount:GetClass() == "info_ladder_dismount" and dismount:GetName():lower():find("zdismount") and !IsValid(dismount:GetParent())) then
							dismount:SetParent(v);
						end;
					end;
				end;
			end;
		end;
	end;

	timer.Create("ladder_SaveData", 180, 0, function()
		file.CreateDir("ladders");
		file.CreateDir("ladders/ladders");
		file.CreateDir("ladders/dismounts");

		SaveLadders();
		SaveDismounts();
	end);

	hook.Add("InitPostEntity", "zladder_SaveLadders", function()
		timer.Simple(5, function()
			local win, msg = pcall(LoadLadders);
			if (!win) then
				ErrorNoHalt("[LADDER TOOL] Something happened while loading ladders!")
				print(msg);
			end;

			local win, msg = pcall(LoadDismounts);
			if (!win) then
				ErrorNoHalt("[LADDER TOOL] Something happened while loading dismounts!")
				print(msg);
			end;
		end);
	end);
end;

hook.Add("FindUseEntity", "zladder", function(player, ent)
	if (IsValid(ent) and IsValid(ent.ladder)) then
		return false;
	end;
end);

properties.Add("ladder_persist", {
	MenuLabel = "Save Ladder",
	MenuIcon = "icon16/disk.png",
	Order = 1,

	Filter = function(self, ent, player)
		if (!IsValid(ent)) then return false; end;
		if (!player:IsSuperAdmin()) then return false; end;
		if (ent:GetClass() != "prop_physics") then return false; end;
		if (!IsValid(ent:GetNWEntity("ladder", nil))) then return false; end;

		return !ent:GetNWEntity("ladder", nil):GetNWBool("saved", false);
	end,

	Action = function(self, ent)
		self:MsgStart();
		net.WriteEntity(ent);
		self:MsgEnd();
	end,

	Receive = function(self, length, player)
		local ent = net.ReadEntity();

		if (!self:Filter(ent, player)) then return; end;

		ent.ladder:SetNWBool("saved", true);
		SaveLadders();
		SaveDismounts();
	end,
});

properties.Add("ladder_persist_end", {
	MenuLabel = "Un-Save Ladder",
	MenuIcon = "icon16/arrow_undo.png",
	Order = 1,

	Filter = function(self, ent, player)
		if (!IsValid(ent)) then return false; end;
		if (!player:IsSuperAdmin()) then return false; end;
		if (ent:GetClass() != "prop_physics") then return false; end;
		if (!IsValid(ent:GetNWEntity("ladder", nil))) then return false; end;

		return ent:GetNWEntity("ladder", nil):GetNWBool("saved", false);
	end,

	Action = function(self, ent)
		self:MsgStart();
		net.WriteEntity(ent);
		self:MsgEnd();
	end,

	Receive = function(self, length, player)
		local ent = net.ReadEntity();

		if (!self:Filter(ent, player)) then return; end;

		ent.ladder:SetNWBool("saved", false);
		SaveLadders();
		SaveDismounts();
	end,
});
--addons/shieldgenerator/lua/autorun/shield2.lua:
if SERVER then return end

CDRAW1 = CDRAW1 or {}

local circle_cache = {}

function CDRAW1.DrawCircle(x,y,radius,seg)
	local segstr = x..y..radius..seg
	if circle_cache[segstr] then
		surface.DrawPoly(circle_cache[segstr])
	else
		local cir = {}
		cir[#cir+1] = {x=x,y=y,u=0.5,v=0.5}
		for i = 0, seg do
			local a = math.rad((i/seg)*-360)
			cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		end
		local a = math.rad(0)
		cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		circle_cache[segstr] = cir
		surface.DrawPoly(cir)
	end
end

function CDRAW1.DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

function CDRAW1.GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

function CDRAW1.DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	aye[2], aye[3] = math.Round(aye[2]), math.Round(aye[3])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i].r,aye[i].g,aye[i].b,aye[i].a)
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(aye[i])
			local _ox, _oy = surface.GetTextSize(aye[i])
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

function CDRAW1.DrawNiceText(Col,Off,Font,Text)
	local sw, sh = CDRAW1.GetTextSize(Font,Text)
	CDRAW1.DrawText(Font..'_blur',-sw/2,-sh/2-Off,Col,Text)
	CDRAW1.DrawText(Font,-sw/2,-sh/2-Off,Col,Text)
end

return CDRAW1
--lua/sitanywhere/ground_sit.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.GroundSit = true
local TAG = "SitAnyG_"

hook.Add("SetupMove", TAG .. "SetupMove", function(ply, mv)
	local butts = mv:GetButtons()

	if not ply:GetNWBool(TAG) then
		return
	end

	local getUp = bit.band(butts, IN_JUMP) == IN_JUMP or ply:GetMoveType() ~= MOVETYPE_WALK or ply:InVehicle() or not ply:Alive()

	if getUp then
		ply:SetNWBool(TAG, false)
	end

	local move = bit.band(butts, IN_DUCK) == IN_DUCK

	butts = bit.bxor(bit.bor(butts, bit.bor(IN_JUMP, IN_DUCK)), IN_JUMP)

	if move then
		butts =  bit.bxor(bit.bor(bit.bor(butts, IN_WALK), IN_SPEED), IN_SPEED)

		mv:SetButtons(butts)
		return
	end

	mv:SetButtons(butts)
	mv:SetSideSpeed(0)
	mv:SetForwardSpeed(0)
	mv:SetUpSpeed(0)
end)

hook.Add("CalcMainActivity", TAG .. "CalcMainActivity", function(ply, vel)
	local seq = ply:LookupSequence("pose_ducking_02")
	if ply:GetNWBool(TAG) and seq and vel:Length2DSqr() < 1 then
		return ACT_MP_SWIM, seq
	else
		return
	end
end)


if SERVER then
	local AllowGroundSit = CreateConVar("sitting_allow_ground_sit", "1", {FCVAR_ARCHIVE}, "Allows people to sit on the ground on your server", 0, 1)
	hook.Add("HandleSit", "GroundSit", function(ply, dists, EyeTrace)
		if #dists == 0 and ply:GetInfoNum("sitting_ground_sit", 1) == 1 and AllowGroundSit:GetBool() and ply:EyeAngles().p > 80 then
			local t = hook.Run("OnGroundSit", ply, EyeTrace)
			if t == false then
				return
			end

			if not ply:GetNWBool(TAG) then
				ply:SetNWBool(TAG, true)
				ply.LastSit = CurTime() + 1
				return true
			end
		end
	end)

	concommand.Add("ground_sit", function(ply)
		if AllowGroundSit:GetBool() and (not ply.LastSit or ply.LastSit < CurTime()) then
			ply:SetNWBool(TAG, not ply:GetNWBool(TAG))
			ply.LastSit = CurTime() + 1
		end
	end)
else
	CreateClientConVar("sitting_ground_sit", "1.00", true, true, "Toggles the ability for you to sit on the ground", 0, 1)
end

--lua/skins/devinity.lua:


print("Einfach-Gaming Yellow Derma Skin von Summe geladen.")

local surface = surface
local Color = Color

SKIN = {}

SKIN.PrintName		= "EGM Yellow Derma Skin"
SKIN.Author			= "Summe"
SKIN.DermaVersion	= 1
SKIN.GwenTexture	= Material( "summe/summe.png" )

SKIN.bg_color					= Color( 101, 100, 105, 255 )
SKIN.bg_color_sleep				= Color( 70, 70, 70, 255 )
SKIN.bg_color_dark				= Color( 55, 57, 61, 255 )
SKIN.bg_color_bright			= Color( 220, 220, 220, 255 )
SKIN.frame_border				= Color( 50, 50, 50, 255 )


SKIN.control_color				= Color( 120, 120, 120, 255 )
SKIN.control_color_highlight	= Color( 150, 150, 150, 255 )
SKIN.control_color_active		= Color( 110, 150, 250, 255 )
SKIN.control_color_bright		= Color( 255, 200, 100, 255 )
SKIN.control_color_dark			= Color( 100, 100, 100, 255 )

SKIN.bg_alt1					= Color( 50, 50, 50, 255 )
SKIN.bg_alt2					= Color( 55, 55, 55, 255 )

SKIN.listview_hover				= Color( 70, 70, 70, 255 )
SKIN.listview_selected			= Color( 100, 170, 220, 255 )

SKIN.text_bright				= Color( 255, 255, 255, 255 )
SKIN.text_normal				= Color( 180, 180, 180, 255 )
SKIN.text_dark					= Color( 20, 20, 20, 255 )
SKIN.text_highlight				= Color( 255, 20, 20, 255 )

SKIN.texGradientUp				= Material( "gui/gradient_up" )
SKIN.texGradientDown			= Material( "gui/gradient_down" )

SKIN.combobox_selected			= SKIN.listview_selected

SKIN.panel_transback			= Color( 255, 255, 255, 50 )
SKIN.tooltip					= Color( 255, 245, 175, 255 )

SKIN.colPropertySheet			= Color( 170, 170, 170, 255 )
SKIN.colTab						= SKIN.colPropertySheet
SKIN.colTabInactive				= Color( 140, 140, 140, 255 )
SKIN.colTabShadow				= Color( 0, 0, 0, 170 )
SKIN.colTabText					= Color( 255, 255, 255, 255 )
SKIN.colTabTextInactive			= Color( 0, 0, 0, 200 )

SKIN.colCollapsibleCategory		= Color( 255, 255, 255, 20 )

SKIN.colCategoryText			= Color( 255, 255, 255, 255 )
SKIN.colCategoryTextInactive	= Color( 200, 200, 200, 255 )

SKIN.colNumberWangBG			= Color( 255, 240, 150, 255 )
SKIN.colTextEntryBG				= Color( 240, 240, 240, 255 )
SKIN.colTextEntryBorder			= Color( 20, 20, 20, 255 )
SKIN.colTextEntryText			= Color( 20, 20, 20, 255 )
SKIN.colTextEntryTextHighlight	= Color( 20, 200, 250, 255 )
SKIN.colTextEntryTextCursor		= Color( 0, 0, 100, 255 )
SKIN.colTextEntryTextPlaceholder= Color( 128, 128, 128, 255 )

SKIN.colMenuBG					= Color( 255, 255, 255, 200 )
SKIN.colMenuBorder				= Color( 0, 0, 0, 200 )

SKIN.colButtonText				= Color( 255, 255, 255, 255 )
SKIN.colButtonTextDisabled		= Color( 255, 255, 255, 55 )
SKIN.colButtonBorder			= Color( 20, 20, 20, 255 )
SKIN.colButtonBorderHighlight	= Color( 255, 255, 255, 50 )
SKIN.colButtonBorderShadow		= Color( 0, 0, 0, 100 )

SKIN.tex = {}

SKIN.tex.Selection					= GWEN.CreateTextureBorder( 384, 32, 31, 31, 4, 4, 4, 4 )

SKIN.tex.Panels = {}
SKIN.tex.Panels.Normal				= GWEN.CreateTextureBorder( 256,	0, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Bright				= GWEN.CreateTextureBorder( 256+64, 0, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Dark				= GWEN.CreateTextureBorder( 256,	64, 63, 63, 16, 16, 16, 16 )
SKIN.tex.Panels.Highlight			= GWEN.CreateTextureBorder( 256+64, 64, 63, 63, 16, 16, 16, 16 )

SKIN.tex.Button						= GWEN.CreateTextureBorder( 480, 0, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Hovered				= GWEN.CreateTextureBorder( 480, 32, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Dead				= GWEN.CreateTextureBorder( 480, 64, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Button_Down				= GWEN.CreateTextureBorder( 480, 96, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Shadow						= GWEN.CreateTextureBorder( 448, 0, 31, 31, 8, 8, 8, 8 )

SKIN.tex.Tree						= GWEN.CreateTextureBorder( 256, 128, 127, 127, 16, 16, 16, 16 )
SKIN.tex.Checkbox_Checked			= GWEN.CreateTextureNormal( 448, 32, 15, 15 )
SKIN.tex.Checkbox					= GWEN.CreateTextureNormal( 464, 32, 15, 15 )
SKIN.tex.CheckboxD_Checked			= GWEN.CreateTextureNormal( 448, 48, 15, 15 )
SKIN.tex.CheckboxD					= GWEN.CreateTextureNormal( 464, 48, 15, 15 )
SKIN.tex.RadioButton_Checked		= GWEN.CreateTextureNormal( 448, 64, 15, 15 )
SKIN.tex.RadioButton				= GWEN.CreateTextureNormal( 464, 64, 15, 15 )
SKIN.tex.RadioButtonD_Checked		= GWEN.CreateTextureNormal( 448, 80, 15, 15 )
SKIN.tex.RadioButtonD				= GWEN.CreateTextureNormal( 464, 80, 15, 15 )
SKIN.tex.TreePlus					= GWEN.CreateTextureNormal( 448, 96, 15, 15 )
SKIN.tex.TreeMinus					= GWEN.CreateTextureNormal( 464, 96, 15, 15 )
SKIN.tex.TextBox					= GWEN.CreateTextureBorder( 0, 150, 127, 21, 4, 4, 4, 4 )
SKIN.tex.TextBox_Focus				= GWEN.CreateTextureBorder( 0, 172, 127, 21, 4, 4, 4, 4 )
SKIN.tex.TextBox_Disabled			= GWEN.CreateTextureBorder( 0, 194, 127, 21, 4, 4, 4, 4 )
SKIN.tex.MenuBG_Column				= GWEN.CreateTextureBorder( 128, 128, 127, 63, 24, 8, 8, 8 )
SKIN.tex.MenuBG						= GWEN.CreateTextureBorder( 128, 192, 127, 63, 8, 8, 8, 8 )
SKIN.tex.MenuBG_Hover				= GWEN.CreateTextureBorder( 128, 256, 127, 31, 8, 8, 8, 8 )
SKIN.tex.MenuBG_Spacer				= GWEN.CreateTextureNormal( 128, 288, 127, 3 )
SKIN.tex.Menu_Strip					= GWEN.CreateTextureBorder( 0, 128, 127, 21, 8, 8, 8, 8 )
SKIN.tex.Menu_Check					= GWEN.CreateTextureNormal( 448, 112, 15, 15 )
SKIN.tex.Tab_Control				= GWEN.CreateTextureBorder( 0, 256, 127, 127, 8, 8, 8, 8 )
SKIN.tex.TabB_Active				= GWEN.CreateTextureBorder( 0,		416, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabB_Inactive				= GWEN.CreateTextureBorder( 128,	416, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabT_Active				= GWEN.CreateTextureBorder( 0,		384, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabT_Inactive				= GWEN.CreateTextureBorder( 128,	384, 63, 31, 8, 8, 8, 8 )
SKIN.tex.TabL_Active				= GWEN.CreateTextureBorder( 64,		384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabL_Inactive				= GWEN.CreateTextureBorder( 64+128, 384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabR_Active				= GWEN.CreateTextureBorder( 96,		384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.TabR_Inactive				= GWEN.CreateTextureBorder( 96+128, 384, 31, 63, 8, 8, 8, 8 )
SKIN.tex.Tab_Bar					= GWEN.CreateTextureBorder( 128, 352, 127, 31, 4, 4, 4, 4 )

SKIN.tex.Window = {}

SKIN.tex.Window.Normal			= GWEN.CreateTextureBorder( 0, 0, 127, 127, 8, 24, 8, 8 )
SKIN.tex.Window.Inactive		= GWEN.CreateTextureBorder( 128, 0, 127, 127, 8, 24, 8, 8 )

SKIN.tex.Window.Close			= GWEN.CreateTextureNormal( 32, 448, 31, 24 )
SKIN.tex.Window.Close_Hover		= GWEN.CreateTextureNormal( 64, 448, 31, 24 )
SKIN.tex.Window.Close_Down		= GWEN.CreateTextureNormal( 96, 448, 31, 24 )

SKIN.tex.Window.Maxi			= GWEN.CreateTextureNormal( 32 + 96 * 2, 448, 31, 24 )
SKIN.tex.Window.Maxi_Hover		= GWEN.CreateTextureNormal( 64 + 96 * 2, 448, 31, 24 )
SKIN.tex.Window.Maxi_Down		= GWEN.CreateTextureNormal( 96 + 96 * 2, 448, 31, 24 )

SKIN.tex.Window.Restore			= GWEN.CreateTextureNormal( 32 + 96 * 2, 448 + 32, 31, 24 )
SKIN.tex.Window.Restore_Hover	= GWEN.CreateTextureNormal( 64 + 96 * 2, 448 + 32, 31, 24 )
SKIN.tex.Window.Restore_Down	= GWEN.CreateTextureNormal( 96 + 96 * 2, 448 + 32, 31, 24 )

SKIN.tex.Window.Mini			= GWEN.CreateTextureNormal( 32 + 96, 448, 31, 24 )
SKIN.tex.Window.Mini_Hover		= GWEN.CreateTextureNormal( 64 + 96, 448, 31, 24 )
SKIN.tex.Window.Mini_Down		= GWEN.CreateTextureNormal( 96 + 96, 448, 31, 24 )

SKIN.tex.Scroller = {}
SKIN.tex.Scroller.TrackV				= GWEN.CreateTextureBorder( 384,		208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Normal		= GWEN.CreateTextureBorder( 384 + 16,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Hover			= GWEN.CreateTextureBorder( 384 + 32,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Down			= GWEN.CreateTextureBorder( 384 + 48,	208, 15, 127, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonV_Disabled		= GWEN.CreateTextureBorder( 384 + 64,	208, 15, 127, 4, 4, 4, 4 )

SKIN.tex.Scroller.TrackH				= GWEN.CreateTextureBorder( 384, 128,		127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Normal		= GWEN.CreateTextureBorder( 384, 128 + 16,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Hover			= GWEN.CreateTextureBorder( 384, 128 + 32,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Down			= GWEN.CreateTextureBorder( 384, 128 + 48,	127, 15, 4, 4, 4, 4 )
SKIN.tex.Scroller.ButtonH_Disabled		= GWEN.CreateTextureBorder( 384, 128 + 64,	127, 15, 4, 4, 4, 4 )

SKIN.tex.Scroller.LeftButton_Normal		= GWEN.CreateTextureBorder( 464,		208, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Hover		= GWEN.CreateTextureBorder( 480,		208, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Down		= GWEN.CreateTextureBorder( 464,		272, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.LeftButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.UpButton_Normal		= GWEN.CreateTextureBorder( 464,		208 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Down			= GWEN.CreateTextureBorder( 464,		272 + 16, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.UpButton_Disabled		= GWEN.CreateTextureBorder( 480 + 48,	272 + 16, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.RightButton_Normal	= GWEN.CreateTextureBorder( 464,		208 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Down		= GWEN.CreateTextureBorder( 464,		272 + 32, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.RightButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272 + 32, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Scroller.DownButton_Normal		= GWEN.CreateTextureBorder( 464,		208 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Hover		= GWEN.CreateTextureBorder( 480,		208 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Down		= GWEN.CreateTextureBorder( 464,		272 + 48, 15, 15, 2, 2, 2, 2 )
SKIN.tex.Scroller.DownButton_Disabled	= GWEN.CreateTextureBorder( 480 + 48,	272 + 48, 15, 15, 2, 2, 2, 2 )

SKIN.tex.Menu = {}
SKIN.tex.Menu.RightArrow = GWEN.CreateTextureNormal( 464, 112, 15, 15 )

SKIN.tex.Input = {}

SKIN.tex.Input.ComboBox = {}
SKIN.tex.Input.ComboBox.Normal		= GWEN.CreateTextureBorder( 384, 336,	127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Hover		= GWEN.CreateTextureBorder( 384, 336+32, 127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Down		= GWEN.CreateTextureBorder( 384, 336+64, 127, 31, 8, 8, 32, 8 )
SKIN.tex.Input.ComboBox.Disabled	= GWEN.CreateTextureBorder( 384, 336+96, 127, 31, 8, 8, 32, 8 )

SKIN.tex.Input.ComboBox.Button = {}
SKIN.tex.Input.ComboBox.Button.Normal	= GWEN.CreateTextureNormal( 496, 272, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Hover	= GWEN.CreateTextureNormal( 496, 272+16, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Down		= GWEN.CreateTextureNormal( 496, 272+32, 15, 15 )
SKIN.tex.Input.ComboBox.Button.Disabled	= GWEN.CreateTextureNormal( 496, 272+48, 15, 15 )

SKIN.tex.Input.UpDown = {}
SKIN.tex.Input.UpDown.Up = {}
SKIN.tex.Input.UpDown.Up.Normal		= GWEN.CreateTextureCentered( 384,		112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Hover		= GWEN.CreateTextureCentered( 384+8,	112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Down		= GWEN.CreateTextureCentered( 384+16,	112, 7, 7 )
SKIN.tex.Input.UpDown.Up.Disabled	= GWEN.CreateTextureCentered( 384+24,	112, 7, 7 )

SKIN.tex.Input.UpDown.Down = {}
SKIN.tex.Input.UpDown.Down.Normal	= GWEN.CreateTextureCentered( 384,		120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Hover	= GWEN.CreateTextureCentered( 384+8,	120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Down		= GWEN.CreateTextureCentered( 384+16,	120, 7, 7 )
SKIN.tex.Input.UpDown.Down.Disabled	= GWEN.CreateTextureCentered( 384+24,	120, 7, 7 )

SKIN.tex.Input.Slider = {}
SKIN.tex.Input.Slider.H = {}
SKIN.tex.Input.Slider.H.Normal		= GWEN.CreateTextureNormal( 416, 32,	15, 15 )
SKIN.tex.Input.Slider.H.Hover		= GWEN.CreateTextureNormal( 416, 32+16, 15, 15 )
SKIN.tex.Input.Slider.H.Down		= GWEN.CreateTextureNormal( 416, 32+32, 15, 15 )
SKIN.tex.Input.Slider.H.Disabled	= GWEN.CreateTextureNormal( 416, 32+48, 15, 15 )

SKIN.tex.Input.Slider.V = {}
SKIN.tex.Input.Slider.V.Normal		= GWEN.CreateTextureNormal( 416+16, 32, 15, 15 )
SKIN.tex.Input.Slider.V.Hover		= GWEN.CreateTextureNormal( 416+16, 32+16, 15, 15 )
SKIN.tex.Input.Slider.V.Down		= GWEN.CreateTextureNormal( 416+16, 32+32, 15, 15 )
SKIN.tex.Input.Slider.V.Disabled	= GWEN.CreateTextureNormal( 416+16, 32+48, 15, 15 )

SKIN.tex.Input.ListBox = {}
SKIN.tex.Input.ListBox.Background		= GWEN.CreateTextureBorder( 256, 256, 63, 127, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.Hovered			= GWEN.CreateTextureBorder( 320, 320, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.EvenLine			= GWEN.CreateTextureBorder( 352, 256, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.OddLine			= GWEN.CreateTextureBorder( 352, 288, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.EvenLineSelected	= GWEN.CreateTextureBorder( 320, 256, 31, 31, 8, 8, 8, 8 )
SKIN.tex.Input.ListBox.OddLineSelected	= GWEN.CreateTextureBorder( 320, 288, 31, 31, 8, 8, 8, 8 )

SKIN.tex.ProgressBar = {}
SKIN.tex.ProgressBar.Back	= GWEN.CreateTextureBorder( 384,	0, 31, 31, 8, 8, 8, 8 )
SKIN.tex.ProgressBar.Front	= GWEN.CreateTextureBorder( 384+32, 0, 31, 31, 8, 8, 8, 8 )

SKIN.tex.CategoryList = {}
SKIN.tex.CategoryList.Outer		= GWEN.CreateTextureBorder( 256, 384, 63, 63, 8, 8, 8, 8 )
SKIN.tex.CategoryList.Inner		= GWEN.CreateTextureBorder( 320, 384, 63, 63, 8, 21, 8, 8 )
SKIN.tex.CategoryList.Header	= GWEN.CreateTextureBorder( 320, 352, 63, 31, 8, 8, 8, 8 )

SKIN.tex.Tooltip = GWEN.CreateTextureBorder( 384, 64, 31, 31, 8, 8, 8, 8 )

SKIN.Colours = {}

SKIN.Colours.Window = {}
SKIN.Colours.Window.TitleActive		= GWEN.TextureColor( 4 + 8 * 0, 508 )
SKIN.Colours.Window.TitleInactive	= GWEN.TextureColor( 4 + 8 * 1, 508 )

SKIN.Colours.Button = {}
SKIN.Colours.Button.Normal			= GWEN.TextureColor( 4 + 8 * 2, 508 )
SKIN.Colours.Button.Hover			= GWEN.TextureColor( 4 + 8 * 3, 508 )
SKIN.Colours.Button.Down			= GWEN.TextureColor( 4 + 8 * 2, 500 )
SKIN.Colours.Button.Disabled		= GWEN.TextureColor( 4 + 8 * 3, 500 )

SKIN.Colours.Tab = {}
SKIN.Colours.Tab.Active = {}
SKIN.Colours.Tab.Active.Normal		= GWEN.TextureColor( 4 + 8 * 4, 508 )
SKIN.Colours.Tab.Active.Hover		= GWEN.TextureColor( 4 + 8 * 5, 508 )
SKIN.Colours.Tab.Active.Down		= GWEN.TextureColor( 4 + 8 * 4, 500 )
SKIN.Colours.Tab.Active.Disabled	= GWEN.TextureColor( 4 + 8 * 5, 500 )

SKIN.Colours.Tab.Inactive = {}
SKIN.Colours.Tab.Inactive.Normal	= GWEN.TextureColor( 4 + 8 * 6, 508 )
SKIN.Colours.Tab.Inactive.Hover		= GWEN.TextureColor( 4 + 8 * 7, 508 )
SKIN.Colours.Tab.Inactive.Down		= GWEN.TextureColor( 4 + 8 * 6, 500 )
SKIN.Colours.Tab.Inactive.Disabled	= GWEN.TextureColor( 4 + 8 * 7, 500 )

SKIN.Colours.Label = {}
SKIN.Colours.Label.Default			= GWEN.TextureColor( 4 + 8 * 8, 508 )
SKIN.Colours.Label.Bright			= GWEN.TextureColor( 4 + 8 * 9, 508 )
SKIN.Colours.Label.Dark				= GWEN.TextureColor( 4 + 8 * 8, 500 )
SKIN.Colours.Label.Highlight		= GWEN.TextureColor( 4 + 8 * 9, 500 )

SKIN.Colours.Tree = {}
SKIN.Colours.Tree.Lines				= GWEN.TextureColor( 4 + 8 * 10, 508 ) ---- !!!
SKIN.Colours.Tree.Normal			= GWEN.TextureColor( 4 + 8 * 11, 508 )
SKIN.Colours.Tree.Hover				= GWEN.TextureColor( 4 + 8 * 10, 500 )
SKIN.Colours.Tree.Selected			= GWEN.TextureColor( 4 + 8 * 11, 500 )

SKIN.Colours.Properties = {}
SKIN.Colours.Properties.Line_Normal			= GWEN.TextureColor( 4 + 8 * 12, 508 )
SKIN.Colours.Properties.Line_Selected		= GWEN.TextureColor( 4 + 8 * 13, 508 )
SKIN.Colours.Properties.Line_Hover			= GWEN.TextureColor( 4 + 8 * 12, 500 )
SKIN.Colours.Properties.Title				= GWEN.TextureColor( 4 + 8 * 13, 500 )
SKIN.Colours.Properties.Column_Normal		= GWEN.TextureColor( 4 + 8 * 14, 508 )
SKIN.Colours.Properties.Column_Selected		= GWEN.TextureColor( 4 + 8 * 15, 508 )
SKIN.Colours.Properties.Column_Hover		= GWEN.TextureColor( 4 + 8 * 14, 500 )
SKIN.Colours.Properties.Border				= GWEN.TextureColor( 4 + 8 * 15, 500 )
SKIN.Colours.Properties.Label_Normal		= GWEN.TextureColor( 4 + 8 * 16, 508 )
SKIN.Colours.Properties.Label_Selected		= GWEN.TextureColor( 4 + 8 * 17, 508 )
SKIN.Colours.Properties.Label_Hover			= GWEN.TextureColor( 4 + 8 * 16, 500 )

SKIN.Colours.Category = {}
SKIN.Colours.Category.Header				= GWEN.TextureColor( 4 + 8 * 18, 500 )
SKIN.Colours.Category.Header_Closed			= GWEN.TextureColor( 4 + 8 * 19, 500 )
SKIN.Colours.Category.Line = {}
SKIN.Colours.Category.Line.Text				= GWEN.TextureColor( 4 + 8 * 20, 508 )
SKIN.Colours.Category.Line.Text_Hover		= GWEN.TextureColor( 4 + 8 * 21, 508 )
SKIN.Colours.Category.Line.Text_Selected	= GWEN.TextureColor( 4 + 8 * 20, 500 )
SKIN.Colours.Category.Line.Button			= GWEN.TextureColor( 4 + 8 * 21, 500 )
SKIN.Colours.Category.Line.Button_Hover		= GWEN.TextureColor( 4 + 8 * 22, 508 )
SKIN.Colours.Category.Line.Button_Selected	= GWEN.TextureColor( 4 + 8 * 23, 508 )
SKIN.Colours.Category.LineAlt = {}
SKIN.Colours.Category.LineAlt.Text				= GWEN.TextureColor( 4 + 8 * 22, 500 )
SKIN.Colours.Category.LineAlt.Text_Hover		= GWEN.TextureColor( 4 + 8 * 23, 500 )
SKIN.Colours.Category.LineAlt.Text_Selected		= GWEN.TextureColor( 4 + 8 * 24, 508 )
SKIN.Colours.Category.LineAlt.Button			= GWEN.TextureColor( 4 + 8 * 25, 508 )
SKIN.Colours.Category.LineAlt.Button_Hover		= GWEN.TextureColor( 4 + 8 * 24, 500 )
SKIN.Colours.Category.LineAlt.Button_Selected	= GWEN.TextureColor( 4 + 8 * 25, 500 )

SKIN.Colours.TooltipText = GWEN.TextureColor( 4 + 8 * 26, 500 )

--[[---------------------------------------------------------
	Panel
-----------------------------------------------------------]]
function SKIN:PaintPanel( panel, w, h )

	if ( !panel.m_bBackground ) then return end
	self.tex.Panels.Normal( 0, 0, w, h, panel.m_bgColor )

end

--[[---------------------------------------------------------
	Panel
-----------------------------------------------------------]]
function SKIN:PaintShadow( panel, w, h )

	SKIN.tex.Shadow( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Frame
-----------------------------------------------------------]]
function SKIN:PaintFrame( panel, w, h )

	if ( panel.m_bPaintShadow ) then

		DisableClipping( true )
		SKIN.tex.Shadow( -4, -4, w+10, h+10 )
		DisableClipping( false )

	end

	if ( panel:HasHierarchicalFocus() ) then

		self.tex.Window.Normal( 0, 0, w, h )

	else

		self.tex.Window.Inactive( 0, 0, w, h )

	end

end

--[[---------------------------------------------------------
	Button
-----------------------------------------------------------]]
function SKIN:PaintButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() || panel:GetToggle() ) then
		return self.tex.Button_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Button_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Button_Hovered( 0, 0, w, h )
	end

	self.tex.Button( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Tree
-----------------------------------------------------------]]
function SKIN:PaintTree( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	self.tex.Tree( 0, 0, w, h, panel.m_bgColor )

end

--[[---------------------------------------------------------
	CheckBox
-----------------------------------------------------------]]
function SKIN:PaintCheckBox( panel, w, h )

	if ( panel:GetChecked() ) then

		if ( panel:GetDisabled() ) then
			self.tex.CheckboxD_Checked( 0, 0, w, h )
		else
			self.tex.Checkbox_Checked( 0, 0, w, h )
		end

	else

		if ( panel:GetDisabled() ) then
			self.tex.CheckboxD( 0, 0, w, h )
		else
			self.tex.Checkbox( 0, 0, w, h )
		end

	end

end

--[[---------------------------------------------------------
	ExpandButton
-----------------------------------------------------------]]
function SKIN:PaintExpandButton( panel, w, h )

	if ( !panel:GetExpanded() ) then
		self.tex.TreePlus( 0, 0, w, h )
	else
		self.tex.TreeMinus( 0, 0, w, h )
	end

end

--[[---------------------------------------------------------
	TextEntry
-----------------------------------------------------------]]
function SKIN:PaintTextEntry( panel, w, h )

	if ( panel.m_bBackground ) then

		if ( panel:GetDisabled() ) then
			self.tex.TextBox_Disabled( 0, 0, w, h )
		elseif ( panel:HasFocus() ) then
			self.tex.TextBox_Focus( 0, 0, w, h )
		else
			self.tex.TextBox( 0, 0, w, h )
		end

	end

	-- Hack on a hack, but this produces the most close appearance to what it will actually look if text was actually there
	if ( panel.GetPlaceholderText && panel.GetPlaceholderColor && panel:GetPlaceholderText() && panel:GetPlaceholderText():Trim() != "" && panel:GetPlaceholderColor() && ( !panel:GetText() || panel:GetText() == "" ) ) then

		local oldText = panel:GetText()

		local str = panel:GetPlaceholderText()
		if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
		str = language.GetPhrase( str )

		panel:SetText( str )
		panel:DrawTextEntryText( panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
		panel:SetText( oldText )

		return
	end

	panel:DrawTextEntryText( panel:GetTextColor(), panel:GetHighlightColor(), panel:GetCursorColor() )

end

--[[---------------------------------------------------------
	Menu
-----------------------------------------------------------]]
function SKIN:PaintMenu( panel, w, h )

	if ( panel:GetDrawColumn() ) then
		self.tex.MenuBG_Column( 0, 0, w, h )
	else
		self.tex.MenuBG( 0, 0, w, h )
	end

end

--[[---------------------------------------------------------
	Menu
-----------------------------------------------------------]]
function SKIN:PaintMenuSpacer( panel, w, h )

	surface.SetDrawColor( Color( 0, 0, 0, 100 ) )
	surface.DrawRect( 0, 0, w, h )

end

--[[---------------------------------------------------------
	MenuOption
-----------------------------------------------------------]]
function SKIN:PaintMenuOption( panel, w, h )

	if ( panel.m_bBackground && (panel.Hovered || panel.Highlight) ) then
		self.tex.MenuBG_Hover( 0, 0, w, h )
	end

	if ( panel:GetChecked() ) then
		self.tex.Menu_Check( 5, h/2-7, 15, 15 )
	end

end

--[[---------------------------------------------------------
	MenuRightArrow
-----------------------------------------------------------]]
function SKIN:PaintMenuRightArrow( panel, w, h )

	self.tex.Menu.RightArrow( 0, 0, w, h )

end

--[[---------------------------------------------------------
	PropertySheet
-----------------------------------------------------------]]
function SKIN:PaintPropertySheet( panel, w, h )

	-- TODO: Tabs at bottom, left, right

	local ActiveTab = panel:GetActiveTab()
	local Offset = 0
	if ( ActiveTab ) then Offset = ActiveTab:GetTall() - 8 end

	self.tex.Tab_Control( 0, Offset, w, h-Offset )

end

--[[---------------------------------------------------------
	Tab
-----------------------------------------------------------]]
function SKIN:PaintTab( panel, w, h )

	if ( panel:IsActive() ) then
		return self:PaintActiveTab( panel, w, h )
	end

	self.tex.TabT_Inactive( 0, 0, w, h )

end

function SKIN:PaintActiveTab( panel, w, h )

	self.tex.TabT_Active( 0, 0, w, h )

end

--[[---------------------------------------------------------
	Button
-----------------------------------------------------------]]
function SKIN:PaintWindowCloseButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Close( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Close_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Close_Hover( 0, 0, w, h )
	end

	self.tex.Window.Close( 0, 0, w, h )

end

function SKIN:PaintWindowMinimizeButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Mini( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Mini_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Mini_Hover( 0, 0, w, h )
	end

	self.tex.Window.Mini( 0, 0, w, h )

end

function SKIN:PaintWindowMaximizeButton( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel:GetDisabled() ) then
		return self.tex.Window.Maxi( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
	end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Window.Maxi_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Window.Maxi_Hover( 0, 0, w, h )
	end

	self.tex.Window.Maxi( 0, 0, w, h )

end

--[[---------------------------------------------------------
	VScrollBar
-----------------------------------------------------------]]
function SKIN:PaintVScrollBar( panel, w, h )

	self.tex.Scroller.TrackV( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ScrollBarGrip
-----------------------------------------------------------]]
function SKIN:PaintScrollBarGrip( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.ButtonV_Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Scroller.ButtonV_Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.ButtonV_Hover( 0, 0, w, h )
	end

	return self.tex.Scroller.ButtonV_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonDown
-----------------------------------------------------------]]
function SKIN:PaintButtonDown( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.DownButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.DownButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.DownButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.DownButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonUp
-----------------------------------------------------------]]
function SKIN:PaintButtonUp( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.UpButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.UpButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.UpButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.UpButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonLeft
-----------------------------------------------------------]]
function SKIN:PaintButtonLeft( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.LeftButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.LeftButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.LeftButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.LeftButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ButtonRight
-----------------------------------------------------------]]
function SKIN:PaintButtonRight( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	if ( panel.Depressed || panel:IsSelected() ) then
		return self.tex.Scroller.RightButton_Down( 0, 0, w, h )
	end

	if ( panel:GetDisabled() ) then
		return self.tex.Scroller.RightButton_Dead( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Scroller.RightButton_Hover( 0, 0, w, h )
	end

	self.tex.Scroller.RightButton_Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboDownArrow
-----------------------------------------------------------]]
function SKIN:PaintComboDownArrow( panel, w, h )

	if ( panel.ComboBox:GetDisabled() ) then
		return self.tex.Input.ComboBox.Button.Disabled( 0, 0, w, h )
	end

	if ( panel.ComboBox.Depressed || panel.ComboBox:IsMenuOpen() ) then
		return self.tex.Input.ComboBox.Button.Down( 0, 0, w, h )
	end

	if ( panel.ComboBox.Hovered ) then
		return self.tex.Input.ComboBox.Button.Hover( 0, 0, w, h )
	end

	self.tex.Input.ComboBox.Button.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboBox
-----------------------------------------------------------]]
function SKIN:PaintComboBox( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.ComboBox.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed || panel:IsMenuOpen() ) then
		return self.tex.Input.ComboBox.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.ComboBox.Hover( 0, 0, w, h )
	end

	self.tex.Input.ComboBox.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	ComboBox
-----------------------------------------------------------]]
function SKIN:PaintListBox( panel, w, h )

	self.tex.Input.ListBox.Background( 0, 0, w, h )

end

--[[---------------------------------------------------------
	NumberUp
-----------------------------------------------------------]]
function SKIN:PaintNumberUp( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.UpDown.Up.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Input.UpDown.Up.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.UpDown.Up.Hover( 0, 0, w, h )
	end

	self.tex.Input.UpDown.Up.Normal( 0, 0, w, h )

end

--[[---------------------------------------------------------
	NumberDown
-----------------------------------------------------------]]
function SKIN:PaintNumberDown( panel, w, h )

	if ( panel:GetDisabled() ) then
		return self.tex.Input.UpDown.Down.Disabled( 0, 0, w, h )
	end

	if ( panel.Depressed ) then
		return self.tex.Input.UpDown.Down.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.UpDown.Down.Hover( 0, 0, w, h )
	end

	self.tex.Input.UpDown.Down.Normal( 0, 0, w, h )

end

function SKIN:PaintTreeNode( panel, w, h )

	if ( !panel.m_bDrawLines ) then return end

	surface.SetDrawColor( self.Colours.Tree.Lines )

	if ( panel.m_bLastChild ) then

		surface.DrawRect( 9, 0, 1, 7 )
		surface.DrawRect( 9, 7, 9, 1 )

	else
		surface.DrawRect( 9, 0, 1, h )
		surface.DrawRect( 9, 7, 9, 1 )
	end

end

function SKIN:PaintTreeNodeButton( panel, w, h )

	if ( !panel.m_bSelected ) then return end

	-- Don't worry this isn't working out the size every render
	-- it just gets the cached value from inside the Label
	local w, _ = panel:GetTextSize()

	self.tex.Selection( 38, 0, w + 6, h )

end

function SKIN:PaintSelection( panel, w, h )

	self.tex.Selection( 0, 0, w, h )

end

function SKIN:PaintSliderKnob( panel, w, h )

	if ( panel:GetDisabled() ) then	return self.tex.Input.Slider.H.Disabled( 0, 0, w, h ) end

	if ( panel.Depressed ) then
		return self.tex.Input.Slider.H.Down( 0, 0, w, h )
	end

	if ( panel.Hovered ) then
		return self.tex.Input.Slider.H.Hover( 0, 0, w, h )
	end

	self.tex.Input.Slider.H.Normal( 0, 0, w, h )

end

local function PaintNotches( x, y, w, h, num )

	if ( !num ) then return end

	local space = w / num

	for i=0, num do

		surface.DrawRect( x + i * space, y + 4, 1, 5 )

	end

end

function SKIN:PaintNumSlider( panel, w, h )

	surface.SetDrawColor( Color( 0, 0, 0, 100 ) )
	surface.DrawRect( 8, h / 2 - 1, w - 15, 1 )

	PaintNotches( 8, h / 2 - 1, w - 16, 1, panel.m_iNotches )

end

function SKIN:PaintProgress( panel, w, h )

	self.tex.ProgressBar.Back( 0, 0, w, h )
	self.tex.ProgressBar.Front( 0, 0, w * panel:GetFraction(), h )

end

function SKIN:PaintCollapsibleCategory( panel, w, h )

	if ( h < 21 ) then
		return self.tex.CategoryList.Header( 0, 0, w, h )
	end

	self.tex.CategoryList.Inner( 0, 0, w, 63 )

end

function SKIN:PaintCategoryList( panel, w, h )

	self.tex.CategoryList.Outer( 0, 0, w, h )

end

function SKIN:PaintCategoryButton( panel, w, h )

	if ( panel.AltLine ) then

		if ( panel.Depressed || panel.m_bSelected ) then surface.SetDrawColor( self.Colours.Category.LineAlt.Button_Selected )
		elseif ( panel.Hovered ) then surface.SetDrawColor( self.Colours.Category.LineAlt.Button_Hover )
		else surface.SetDrawColor( self.Colours.Category.LineAlt.Button ) end

	else

		if ( panel.Depressed || panel.m_bSelected ) then surface.SetDrawColor( self.Colours.Category.Line.Button_Selected )
		elseif ( panel.Hovered ) then surface.SetDrawColor( self.Colours.Category.Line.Button_Hover )
		else surface.SetDrawColor( self.Colours.Category.Line.Button ) end

	end

	surface.DrawRect( 0, 0, w, h )

end

function SKIN:PaintListViewLine( panel, w, h )

	if ( panel:IsSelected() ) then

		self.tex.Input.ListBox.EvenLineSelected( 0, 0, w, h )

	elseif ( panel.Hovered ) then

		self.tex.Input.ListBox.Hovered( 0, 0, w, h )

	elseif ( panel.m_bAlt ) then

		self.tex.Input.ListBox.EvenLine( 0, 0, w, h )

	end

end

function SKIN:PaintListView( panel, w, h )

	if ( !panel.m_bBackground ) then return end

	self.tex.Input.ListBox.Background( 0, 0, w, h )

end

function SKIN:PaintTooltip( panel, w, h )

	self.tex.Tooltip( 0, 0, w, h )

end

function SKIN:PaintMenuBar( panel, w, h )

	self.tex.Menu_Strip( 0, 0, w, h )

end

derma.DefineSkin( "devinity", "Devinity epic skin", SKIN )

derma.RefreshSkins()

--lua/autorun/sw_imperial_seats.lua:

-- Don't try to edit this file if you're trying to add new vehicles
-- Just make a new file and copy the format below.

local function AddVehicle( t, class )
	list.Set( "Vehicles", class, t )
end

local Category = "Star Wars Seats"

AddVehicle( {
	-- Required information
	Name = "Emperors Throne",
	Model = "models/KingPommes/starwars/misc/seats/palp_chair_full.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Emperors Throne",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "emperors_throne" )

AddVehicle( {
	-- Required information
	Name = "Imperial Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chaira.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Imperial Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "imperial_conference_chair" )

AddVehicle( {
	-- Required information
	Name = "Tarkins Conferencechair",
	Model = "models/KingPommes/starwars/misc/seats/imp_chairb.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Tarkins Covfefe-chair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "tarkins_conference_chair" )


AddVehicle( {
	-- Required information
	Name = "Senat Armchair",
	Model = "models/KingPommes/starwars/misc/seats/imp_armchair.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "KingPommes",
	Information = "Senat Armchair",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "senat_armchair" )

AddVehicle( {
	-- Required information
	Name = "Bridgecrew Seat",
	Model = "models/lordtrilobite/starwars/props/imp_chair01.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	-- Optional information
	Author = "Lord Trilobite",
	Information = "Bridgecrew Seat",

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt"
	}
}, "bridgecrew_seat" )

--lua/autorun/tenarshaddaaarmourpack.lua:
player_manager.AddValidModel( "archaelogymaster", "models/gonzo/tenarshaddaaarmourpack/archaelogymaster/archaelogymaster.mdl" ) 
list.Set( "PlayerOptionsModel",  "archaelogymaster", "models/gonzo/tenarshaddaaarmourpack/archaelogymaster/archaelogymaster.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Armourtechmaster", "models/gonzo/tenarshaddaaarmourpack/armourtechmaster/armourtechmaster.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Armourtechmaster", "models/gonzo/tenarshaddaaarmourpack/armourtechmaster/armourtechmaster.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Armstechmaster", "models/gonzo/tenarshaddaaarmourpack/armstechmaster/armstechmaster.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Armstechmaster", "models/gonzo/tenarshaddaaarmourpack/armstechmaster/armstechmaster.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Heavycrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/heavycrusaderarmour/heavycrusaderarmour.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Heavycrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/heavycrusaderarmour/heavycrusaderarmour.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Lightcrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/lightcrusaderarmour/lightcrusaderarmour.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Lightcrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/lightcrusaderarmour/lightcrusaderarmour.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Mediumcrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/mediumcrusaderarmour/mediumcrusaderarmour.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Mediumcrusaderarmour", "models/gonzo/tenarshaddaaarmourpack/mediumcrusaderarmour/mediumcrusaderarmour.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Scraparmour", "models/gonzo/tenarshaddaaarmourpack/scraparmour/scraparmour.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Scraparmour", "models/gonzo/tenarshaddaaarmourpack/scraparmour/scraparmour.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Droid1", "models/gonzo/narshaddaacharacters/droid1/droid1.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Droid1", "models/gonzo/narshaddaacharacters/droid1/droid1.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Droid2", "models/gonzo/narshaddaacharacters/droid2/droid2.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Droid2", "models/gonzo/narshaddaacharacters/droid2/droid2.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Droiddealer", "models/gonzo/narshaddaacharacters/droiddealer/droiddealer.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Droiddealer", "models/gonzo/narshaddaacharacters/droiddealer/droiddealer.mdl" )

player_manager.AddValidModel( "EGM Custom Civilian Kaleesh", "models/gonzo/narshaddaacharacters/xaameqessh/xaameqessh.mdl" ) 
list.Set( "PlayerOptionsModel",  "EGM Custom Civilian Kaleesh", "models/gonzo/narshaddaacharacters/xaameqessh/xaameqessh.mdl" )



--addons/tfa_base/lua/tfa/enums/idle.lua:
--IDLE TYPE ENUM
TFA.Enum.IDLE_DISABLED = 0
TFA.Enum.IDLE_LUA = 1
TFA.Enum.IDLE_ANI = 2
TFA.Enum.IDLE_BOTH = 3
--addons/tfa_base/lua/tfa/modules/cl_tfa_commands.lua:
if GetConVar("cl_tfa_inspection_bokeh") == nil then
	CreateClientConVar("cl_tfa_inspection_bokeh", 0, true, false, "Enable inspection bokeh DOF")
end

if GetConVar("cl_tfa_inspection_bokeh_radius") == nil then
	CreateClientConVar("cl_tfa_inspection_bokeh_radius", 0.1, true, false, "Inspection bokeh DOF radius", 0.01, 1)
end

if GetConVar("cl_tfa_inspect_hide_in_screenshots") == nil then
	CreateClientConVar("cl_tfa_inspect_hide_in_screenshots", 0, true, false, "Hide inspection panel in screenshots")
end

if GetConVar("cl_tfa_inspect_hide") == nil then
	CreateClientConVar("cl_tfa_inspect_hide", 0, false, false, "Hide inspection panel")
end

if GetConVar("cl_tfa_inspect_hide_hud") == nil then
	CreateClientConVar("cl_tfa_inspect_hide_hud", 0, true, false, "Hide HUD when inspecting weapon (DLib required)")
end

if GetConVar("cl_tfa_inspect_newbars") == nil then
	CreateClientConVar("cl_tfa_inspect_newbars", 0, true, false, "Use new stat bars in inspection screen")
end

if GetConVar("cl_tfa_inspect_spreadinmoa") == nil then
	CreateClientConVar("cl_tfa_inspect_spreadinmoa", 0, true, false, "Show accuracy in MOA instead of degrees on inspection screen")
end

if GetConVar("cl_tfa_viewbob_intensity") == nil then
	CreateClientConVar("cl_tfa_viewbob_intensity", 1, true, false, "View bob intensity multiplier", 0, 10)
end

if GetConVar("cl_tfa_gunbob_intensity") == nil then
	CreateClientConVar("cl_tfa_gunbob_intensity", 1, true, false, "Gun bob intensity multiplier", 0, 10)
end

if GetConVar("cl_tfa_gunbob_custom") == nil then
	CreateClientConVar("cl_tfa_gunbob_custom", 1, true, false, "Use custom gun bob")
end

if GetConVar("cl_tfa_gunbob_invertsway") == nil then
	CreateClientConVar("cl_tfa_gunbob_invertsway", 0, true, false, "Invert gun sway direction")
end

if GetConVar("cl_tfa_3dscope_quality") == nil then
	CreateClientConVar("cl_tfa_3dscope_quality", 0, true, true, "3D scope quality (0 - Full quality, 1 - Half, 2 - Quarter, 3 - Eighth)", 0, 3)
end

if GetConVar("cl_tfa_3dscope") == nil then
	CreateClientConVar("cl_tfa_3dscope", 1, true, true, "[IGNORED] Enable 3D scopes?")
end

if GetConVar("cl_tfa_scope_sensitivity_3d") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity_3d", 2, true, true, "3D scope sensitivity (0 - No compensation, 1 - Standard compensation, 2 - 3D compensation, 3 - 3D + FOV compensation)", 0, 3)
end

if GetConVar("cl_tfa_3dscope_overlay") == nil then
	CreateClientConVar("cl_tfa_3dscope_overlay", 0, true, true, "Enable 3D scope shadows?")
end

if GetConVar("cl_tfa_scope_sensitivity_autoscale") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity_autoscale", 1, true, true, "Compensate sensitivity for FOV?")
end

if GetConVar("cl_tfa_scope_sensitivity") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity", 100, true, true, "3D scope sensitivity percentage", 0.01, 100)
end

if GetConVar("cl_tfa_ironsights_toggle") == nil then
	CreateClientConVar("cl_tfa_ironsights_toggle", 1, true, true, "Toggle ironsights?")
end

if GetConVar("cl_tfa_ironsights_resight") == nil then
	CreateClientConVar("cl_tfa_ironsights_resight", 1, true, true, "Keep ironsights after reload or sprint?")
end

if GetConVar("cl_tfa_ironsights_responsive") == nil then
	CreateClientConVar("cl_tfa_ironsights_responsive", 0, true, true, "Allow both toggle and held down iron sights")
end

if GetConVar("cl_tfa_ironsights_responsive_timer") == nil then
	CreateClientConVar("cl_tfa_ironsights_responsive_timer", 0.175, true, true, "Time in seconds to determine responsivness time", 0.01, 2)
end

if GetConVar("cl_tfa_laser_trails") == nil then
	CreateClientConVar("cl_tfa_laser_trails", 1, true, true, "Enable laser dot trails?")
end

--Crosshair Params
if GetConVar("cl_tfa_hud_crosshair_length") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_length", 1, true, false, "Crosshair length")
end

if GetConVar("cl_tfa_hud_crosshair_length_use_pixels") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_length_use_pixels", 0, true, false, "Should crosshair length use pixels?")
end

if GetConVar("cl_tfa_hud_crosshair_width") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_width", 1, true, false, "Crosshair width")
end

if GetConVar("cl_tfa_hud_crosshair_enable_custom") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_enable_custom", 1, true, false, "Enable custom crosshair?")
end

if GetConVar("cl_tfa_hud_crosshair_gap_scale") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_gap_scale", 1, true, false, "Crosshair gap scale")
end

if GetConVar("cl_tfa_hud_crosshair_dot") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_dot", 0, true, false, "Enable crosshair dot?")
end

--Crosshair Color
if GetConVar("cl_tfa_hud_crosshair_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_r", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_g", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_b", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_color_team") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_team", 1, true, false, "Should crosshair use team color of entity being aimed at?")
end

-- Crosshair Team Color: Friendly
if GetConVar("cl_tfa_hud_crosshair_color_friendly_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_r", 0, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_friendly_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_g", 255, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_friendly_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_b", 0, true, false, nil, 0, 255)
end

-- Crosshair Team Color: Enemy
if GetConVar("cl_tfa_hud_crosshair_color_enemy_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_r", 255, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_enemy_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_g", 0, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_enemy_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_b", 0, true, false, nil, 0, 255)
end

--Crosshair Outline
if GetConVar("cl_tfa_hud_crosshair_outline_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_r", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_g", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_b", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_width") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_width", 1, true, false, "Crosshair outline width")
end

if GetConVar("cl_tfa_hud_crosshair_outline_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_enabled", 1, true, false, "Enable crosshair outline?")
end

if GetConVar("cl_tfa_hud_crosshair_triangular") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_triangular", 0, true, false, "Enable triangular Crysis-like crosshair?")
end

if GetConVar("cl_tfa_hud_crosshair_pump") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_pump", 0, true, false, "Enable pump feedback on crosshair?")
end

if GetConVar("cl_tfa_hud_hitmarker_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_enabled", 1, true, false, "Enable hit marker?")
end

if GetConVar("cl_tfa_hud_hitmarker_fadetime") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_fadetime", 0.3, true, false, "Hit marker fade time (in seconds)", 0, 3)
end

if GetConVar("cl_tfa_hud_hitmarker_solidtime") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_solidtime", 0.1, true, false, nil, 0, 3)
end

if GetConVar("cl_tfa_hud_hitmarker_scale") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_scale", 1, true, false, "Hit marker scale", 0, 5)
end

-- Hitmarker Color
if GetConVar("cl_tfa_hud_hitmarker_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_r", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_g", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_b", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_hitmarker_3d_all") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_3d_all", 0, true, true)
end

if GetConVar("cl_tfa_hud_hitmarker_3d_shotguns") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_3d_shotguns", 1, true, true)
end

--Other stuff
if GetConVar("cl_tfa_hud_ammodata_fadein") == nil then
	CreateClientConVar("cl_tfa_hud_ammodata_fadein", 0.2, true, false)
end

if GetConVar("cl_tfa_hud_hangtime") == nil then
	CreateClientConVar("cl_tfa_hud_hangtime", 1, true, true)
end

if GetConVar("cl_tfa_hud_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_enabled", 1, true, false, "Enable 3D2D hud?")
end

if GetConVar("cl_tfa_hud_fallback_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_fallback_enabled", 1, true, false, "Enable basic fallback hud?")
end

if GetConVar("cl_tfa_hud_scale") == nil then
	CreateClientConVar("cl_tfa_hud_scale", 1, true, false, "Size multiplier of HUD elements", .25, 4)
end

if GetConVar("cl_tfa_fx_gasblur") == nil then
	CreateClientConVar("cl_tfa_fx_gasblur", 0, true, true, "Enable muzzle gas blur?")
end

if GetConVar("cl_tfa_fx_muzzlesmoke") == nil then
	CreateClientConVar("cl_tfa_fx_muzzlesmoke", 1, true, true, "Enable muzzle smoke trail?")
end

if GetConVar("cl_tfa_fx_muzzlesmoke_limited") == nil then
	CreateClientConVar("cl_tfa_fx_muzzlesmoke_limited", 1, true, true, "Limit muzzle smoke trails?")
end

if GetConVar("cl_tfa_fx_muzzleflashsmoke") == nil then
	CreateClientConVar("cl_tfa_fx_muzzleflashsmoke", 1, true, true, "Enable muzzleflash smoke?")
end

if GetConVar("cl_tfa_legacy_shells") == nil then
	CreateClientConVar("cl_tfa_legacy_shells", 0, true, true, "Use legacy shells?")
end

if GetConVar("cl_tfa_fx_ejectionsmoke") == nil then
	CreateClientConVar("cl_tfa_fx_ejectionsmoke", 1, true, true, "Enable shell ejection smoke?")
end

if GetConVar("cl_tfa_fx_ejectionlife") == nil then
	CreateClientConVar("cl_tfa_fx_ejectionlife", 15, true, true, "How long shells exist in the world")
end

if GetConVar("cl_tfa_fx_impact_enabled") == nil then
	CreateClientConVar("cl_tfa_fx_impact_enabled", 1, true, true, "Enable custom bullet impact effects?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_enabled") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_enabled", 1, true, true, "Enable bullet ricochet effect?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_sparks") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_sparks", 6, true, true, "Enable bullet ricochet sparks?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_sparklife") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_sparklife", 2, true, true)
end

if GetConVar("cl_tfa_fx_ads_dof") == nil then
	CreateClientConVar("cl_tfa_fx_ads_dof", 0, true, true, "Enable iron sights DoF (Depth of Field)")
end

if GetConVar("cl_tfa_fx_ads_dof_hd") == nil then
	CreateClientConVar("cl_tfa_fx_ads_dof_hd", 0, true, true, "Enable better quality for DoF")
end

--viewbob

if GetConVar("cl_tfa_viewbob_animated") == nil then
	CreateClientConVar("cl_tfa_viewbob_animated", 1, true, false, "Use animated viewbob?")
end

--Viewmodel Mods
if GetConVar("cl_tfa_viewmodel_offset_x") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_x", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_y") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_y", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_z") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_z", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_fov") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_fov", 0, true, false, nil, -5, 5)
end

if GetConVar("cl_tfa_viewmodel_multiplier_fov") == nil then
	CreateClientConVar("cl_tfa_viewmodel_multiplier_fov", 1, true, false, nil, 0.75, 2)
end

if GetConVar("cl_tfa_viewmodel_flip") == nil then
	CreateClientConVar("cl_tfa_viewmodel_flip", 0, true, false)
end

if GetConVar("cl_tfa_viewmodel_centered") == nil then
	CreateClientConVar("cl_tfa_viewmodel_centered", 0, true, false)
end

if GetConVar("cl_tfa_viewmodel_nearwall") == nil then
	CreateClientConVar("cl_tfa_viewmodel_nearwall", 1, true, false)
end

if GetConVar("cl_tfa_viewmodel_vp_enabled") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_enabled", 1, true, false)
end

if GetConVar("cl_tfa_viewmodel_vp_pitch") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_pitch", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_pitch_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_pitch_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_vertical") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_vertical", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_vertical_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_vertical_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_max_vertical") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_max_vertical", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_max_vertical_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_max_vertical_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_yaw") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_yaw", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_yaw_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_yaw_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_debug_crosshair") == nil then
	CreateClientConVar("cl_tfa_debug_crosshair", 0, false, false, "Debug crosshair (Admin only)")
end

if GetConVar("cl_tfa_debug_animations") == nil then
	CreateClientConVar("cl_tfa_debug_animations", 0, false, false, "Debug animations (Admin only)")
end

if GetConVar("cl_tfa_debug_rt") == nil then
	CreateClientConVar("cl_tfa_debug_rt", 0, false, false, "Debug RT scopes (Admin only)")
end

if GetConVar("cl_tfa_debug_cache") == nil then
	CreateClientConVar("cl_tfa_debug_cache", 0, false, false, "Disable stat caching (may cause heavy performance impact!)")
end

local function UpdateColorCVars()
	timer.Create("tfa_apply_player_color", 0.5, 1, function()
		RunConsoleCommand("sv_tfa_apply_player_colors")
	end)
end

--Reticule Color
if GetConVar("cl_tfa_reticule_color_r") == nil then
	CreateClientConVar("cl_tfa_reticule_color_r", 255, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_r", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_reticule_color_g") == nil then
	CreateClientConVar("cl_tfa_reticule_color_g", 100, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_g", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_reticule_color_b") == nil then
	CreateClientConVar("cl_tfa_reticule_color_b", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_b", UpdateColorCVars, "TFANetworkPlayerColors")
end

--Laser Color
if GetConVar("cl_tfa_laser_color_r") == nil then
	CreateClientConVar("cl_tfa_laser_color_r", 255, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_r", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_laser_color_g") == nil then
	CreateClientConVar("cl_tfa_laser_color_g", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_g", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_laser_color_b") == nil then
	CreateClientConVar("cl_tfa_laser_color_b", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_b", UpdateColorCVars, "TFANetworkPlayerColors")
end

if GetConVar("cl_tfa_attachments_persist_enabled") == nil then
	CreateClientConVar("cl_tfa_attachments_persist_enabled", 1, true, true, "Should attachments selection persist across different weapons/lives/sessions?")
end

if GetConVar("cl_tfa_hud_keybindhints_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_enabled", "1", true, false, "Enable keybind hints?")
end

if GetConVar("cl_tfa_hud_keybindhints_solidtime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_solidtime", 3, true, false, "How long keybind hint will stay on screen (in seconds)", 0)
end

if GetConVar("cl_tfa_hud_keybindhints_fadeintime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_fadeintime", 1, true, false, "Keybind hint fade-in time (in seconds)", 0.01)
end

if GetConVar("cl_tfa_hud_keybindhints_fadeouttime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_fadeouttime", 4, true, false, "Keybind hint fade-out time (in seconds)", 0.01)
end

--addons/tfa_base/lua/tfa/modules/tfa_ammo.lua:
--[[Bow Ammo]]
--
game.AddAmmoType({
	name = "tfbow_arrow",
	dmgtype = DMG_CLUB,
	tracer = 0,
	minsplash = 5,
	maxsplash = 5
})

game.AddAmmoType({
	name = "tfbow_bolt",
	dmgtype = DMG_CLUB,
	tracer = 0,
	minsplash = 5,
	maxsplash = 5
})

--addons/tfa_base/lua/tfa/modules/tfa_particles.lua:
TFA.Particles = TFA.Particles or {}
TFA.Particles.FlareParts = {}
TFA.Particles.VMAttachments = {}

TFA.Particles.PCFParticles = TFA.Particles.PCFParticles or {}

TFA.Particles.PCFParticles["tfa_muzzle_rifle"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_sniper"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_energy"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_energy"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_gauss"] = "tfa_muzzleflashes"

-- TFA.Particles.PCFParticles["weapon_muzzle_smoke_long"] = "csgo_fx"
-- TFA.Particles.PCFParticles["weapon_muzzle_smoke"] = "csgo_fx"

TFA.Particles.PCFParticles["tfa_ins2_weapon_muzzle_smoke"] = "tfa_ins2_muzzlesmoke"
TFA.Particles.PCFParticles["tfa_ins2_weapon_shell_smoke"] = "tfa_ins2_shellsmoke"
TFA.Particles.PCFParticles["tfa_bullet_smoke_tracer"] = "tfa_ballistics"
TFA.Particles.PCFParticles["tfa_bullet_fire_tracer"] = "tfa_ballistics"
TFA.Particles.PCFParticles["tfa_ins2_shell_eject"] = "tfa_ins2_ejectionsmoke"

--legacy
TFA.Particles.PCFParticles["smoke_trail_tfa"] = "tfa_smoke"
TFA.Particles.PCFParticles["smoke_trail_controlled"] = "tfa_smoke"

TFA.Particles.SmokeLightingMin = Vector(0.15, 0.15, 0.15)
TFA.Particles.SmokeLightingMax = Vector(0.75, 0.75, 0.75)
TFA.Particles.SmokeLightingClamp = 1

local addedparts = {}
local cachedparts = {}

function TFA.Particles.Initialize()
	for k, v in pairs(TFA.Particles.PCFParticles) do
		if not addedparts[v] then
			game.AddParticles("particles/" .. v .. ".pcf")
			addedparts[v] = true
		end

		if not cachedparts[k] and not string.find(k, "DUMMY") then
			PrecacheParticleSystem(k)
			cachedparts[k] = true
		end
	end
end

hook.Add("InitPostEntity", "TFA.Particles.Initialize", TFA.Particles.Initialize)
TFA.Particles.Initialize()

--addons/tfa_base/lua/tfa/modules/cl_tfa_changelog.lua:
local changes = TFA_BASE_VERSION_CHANGES or ""
local cvar_changelog = GetConVar("sv_tfa_changelog")

local sp = game.SinglePlayer()
local pdatavar = "tfa_base_version_" .. util.CRC(game.GetIPAddress())

local function CheckAndDisplayChangeLog(ply)
	if not IsValid(ply) then return end

	if not cvar_changelog:GetBool() then return end

	if not sp or not ply:IsAdmin() then return end

	local version = tonumber(ply:GetPData(pdatavar))

	if not version or version < TFA_BASE_VERSION then
		chat.AddText("Updated to TFA Base Version: " .. TFA_BASE_VERSION_STRING)

		if changes ~= "" then
			chat.AddText(changes)
		end
	end

	ply:SetPData(pdatavar, TFA_BASE_VERSION)
end

hook.Add("HUDPaint", "TFA_DISPLAY_CHANGELOG", function()
	if not LocalPlayer():IsValid() then return end

	CheckAndDisplayChangeLog(LocalPlayer())

	hook.Remove("HUDPaint", "TFA_DISPLAY_CHANGELOG")
end)

--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1		end
	
--addons/tfa_base/lua/tfa/modules/cl_tfa_rendertarget.lua:
TFA.DrawingRenderTarget = false

local props = {
	["$translucent"] = 1
}

local TFA_RTMat = CreateMaterial("tfa_rtmaterial", "UnLitGeneric", props) --Material("models/weapons/TFA/shared/optic")
local TFA_RTScreen, TFA_RTScreenO = {}, {}
local tgt
local old_bt
local ply, vm, wep
local w, h
local qualitySizes

local function callFunc()
	if wep.RTCode then
		wep:RTCode(TFA_RTMat, w, h)
	end

	if wep:GetStatL("RTDrawEnabled") then
		wep:CallAttFunc("RTCode", TFA_RTMat, w, h)
	end
end

hook.Add("OnScreenSizeChanged", "TFA_rendertargets", function()
	qualitySizes = nil
	TFA_RTScreen, TFA_RTScreenO = {}, {}
end)

local function TFARenderScreen()
	ply = GetViewEntity()

	if not IsValid(ply) or not ply:IsPlayer() then
		ply = LocalPlayer()

		return
	end

	wep = ply:GetActiveWeapon()
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	if not IsValid(vm) then
		if not wep:VMIV() then return end

		vm = wep.OwnerViewModel
	end

	if not wep.MaterialCached then
		wep.MaterialCached = true
		wep.MaterialCached_V = nil
		wep.MaterialCached_W = nil
	end

	local skinStat = wep:GetStatL("Skin")
	if isnumber(skinStat) then
		if vm:GetSkin() ~= skinStat then
			vm:SetSkin(skinStat)
		end
	end

	if wep:GetStatL("MaterialTable_V") and not wep.MaterialCached_V then
		wep.MaterialCached_V = {}
		vm:SetSubMaterial()
		local collectedKeys = table.GetKeys(wep:GetStatL("MaterialTable_V"))
		table.Merge(collectedKeys, table.GetKeys(wep:GetStatL("MaterialTable")))

		for _, k in pairs(collectedKeys) do
			if k ~= "BaseClass" then
				local v = wep:GetStatL("MaterialTable_V")[k]

				if not wep.MaterialCached_V[k] then
					vm:SetSubMaterial(k - 1, v)
					wep.MaterialCached_V[k] = true
				end
			end
		end
	end

	if not (wep:GetStatL("RTDrawEnabled") or wep.RTCode ~= nil) then return end
	w, h = ScrW(), ScrH()

	if not qualitySizes then
		qualitySizes = {
			[0] = h,
			[1] = math.Round(h * 0.5),
			[2] = math.Round(h * 0.25),
			[3] = math.Round(h * 0.125),
		}
	end

	local quality = TFA.RTQuality()

	if wep:GetStatL("RTOpaque") then
		tgt = TFA_RTScreenO[quality]

		if not tgt then
			local size = qualitySizes[quality] or qualitySizes[0]
			tgt = GetRenderTargetEx("TFA_RT_ScreenO_" .. size, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_SHARED, 0, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGB888)
			TFA_RTScreenO[quality] = tgt
		end
	else
		tgt = TFA_RTScreen[quality]

		if not tgt then
			local size = qualitySizes[quality] or qualitySizes[0]
			tgt = GetRenderTargetEx("TFA_RT_Screen_" .. size, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_SHARED, 0, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888)
			TFA_RTScreen[quality] = tgt
		end
	end

	TFA.LastRTUpdate = CurTime() + 0.01

	render.PushRenderTarget(tgt)
	render.Clear(0, 0, 0, 255, true, true)

	TFA.DrawingRenderTarget = true
	render.CullMode(MATERIAL_CULLMODE_CCW)
	ProtectedCall(callFunc)
	TFA.DrawingRenderTarget = false

	render.SetScissorRect(0, 0, 0, 0, false)
	render.PopRenderTarget()

	if old_bt ~= tgt then
		TFA_RTMat:SetTexture("$basetexture", tgt)
		old_bt = tgt
	end

	if wep:GetStatL("RTMaterialOverride", -1) >= 0 then
		vm:SetSubMaterial(wep:GetStatL("RTMaterialOverride"), "!tfa_rtmaterial")
	end
end

hook.Remove("PostRender", "TFASCREENS")

hook.Add("PreRender", "TFASCREENS", function()
	if not TFA.RT_DRAWING then
		TFA.RT_DRAWING = true
		TFARenderScreen()
		TFA.RT_DRAWING = false
	end
end)

TFA.RT_DRAWING = false

--addons/tfa_base/lua/tfa/modules/cl_tfa_vgui.lua:
local DLIB_IS_PRESENT = DLib ~= nil

local function AddColorMixer(panel, label, cvar_r, cvar_g, cvar_b, cvar_a)
	local colorMixer = vgui.Create(DLIB_IS_PRESENT and "DLibColorMixer" or "DColorMixer")

	if DLIB_IS_PRESENT and colorMixer.EnableTallLayout then
		colorMixer:EnableTallLayout()
	end

	if label then
		if colorMixer.SetLabel then
			colorMixer:SetLabel(label)
		else
			panel:Help(label)
		end
	end

	colorMixer:SetConVarR(cvar_r)
	colorMixer:SetConVarG(cvar_g)
	colorMixer:SetConVarB(cvar_b)
	if cvar_a then
		colorMixer:SetConVarA(cvar_a)
	else
		colorMixer:SetAlphaBar(false)
	end

	panel:AddItem(colorMixer)

	return colorMixer
end
TFA.AddColorMixer = AddColorMixer

local function AddFoldedColorMixer(panel, label, cvar_r, cvar_g, cvar_b, cvar_a)
	local form = vgui.Create("DForm", panel)
	form:SetName(label)
	panel:AddItem(form)

	return AddColorMixer(form, "", cvar_r, cvar_g, cvar_b, cvar_a), form
end
TFA.AddFoldedColorMixer = AddFoldedColorMixer

local function tfaOptionServer(panel)
	--Here are whatever default categories you want.
	local tfaOptionSV = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_server"
	}

	tfaOptionSV.Options["#preset.default"] = {
		sv_tfa_ironsights_enabled = "1",
		sv_tfa_sprint_enabled = "1",
		sv_tfa_weapon_strip = "0",
		sv_tfa_allow_dryfire = "1",
		sv_tfa_damage_multiplier = "1",
		sv_tfa_damage_multiplier_npc = "1",
		sv_tfa_damage_mult_min = "0.95",
		sv_tfa_damage_mult_max = "1.05",
		sv_tfa_default_clip = "-1",
		sv_tfa_arrow_lifetime = "30",
		sv_tfa_force_multiplier = "1",
		sv_tfa_bullet_penetration_power_mul = "1",
		sv_tfa_dynamicaccuracy = "1",
		sv_tfa_range_modifier = "0.5",
		sv_tfa_spread_multiplier = "1",
		sv_tfa_bullet_penetration = "1",
		sv_tfa_bullet_ricochet = "0",
		sv_tfa_bullet_doordestruction = "1",
		sv_tfa_melee_doordestruction = "1",
		sv_tfa_bullet_randomseed = "0",
		sv_tfa_reloads_legacy = "0",
		sv_tfa_fixed_crosshair = "0",
		sv_tfa_crosshair_showplayer = "1",
		sv_tfa_crosshair_showplayerteam = engine.ActiveGamemode() == "terrortown" and "0" or "1",
		sv_tfa_reloads_enabled = "1",
		sv_tfa_cmenu = "1",
		sv_tfa_penetration_hardlimit = "100",
		sv_tfa_jamming = "1",
		sv_tfa_jamming_mult = "1",
		sv_tfa_jamming_factor = "1",
		sv_tfa_jamming_factor_inc = "1",
		sv_tfa_door_respawn = "-1",
		sv_tfa_attachments_enabled = "1",
		sv_tfa_npc_randomize_atts = "1"
	}

	tfaOptionSV.CVars = table.GetKeys(tfaOptionSV.Options["#preset.default"])

	panel:AddControl("ComboBox", tfaOptionSV)

	--These are the panel controls.  Adding these means that you don't have to go into the console.
	TFA.CheckBoxNet(panel, "#tfa.svsettings.dryfire", "sv_tfa_allow_dryfire")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.dynaccuracy", "sv_tfa_dynamicaccuracy")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.stripempty", "sv_tfa_weapon_strip")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.ironsight", "sv_tfa_ironsights_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.sprint", "sv_tfa_sprint_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.attachments", "sv_tfa_attachments_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.randomizenpcatts", "sv_tfa_npc_randomize_atts")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.cmenu", "sv_tfa_cmenu")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.penetration", "sv_tfa_bullet_penetration")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.ricochet", "sv_tfa_bullet_ricochet")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.doorbust", "sv_tfa_bullet_doordestruction")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.doorbash", "sv_tfa_melee_doordestruction")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.reloads", "sv_tfa_reloads_enabled")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.jamming", "sv_tfa_jamming")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.nearlyempty", "sv_tfa_nearlyempty")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.legacyreloads", "sv_tfa_reloads_legacy")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.fixedcrosshair", "sv_tfa_fixed_crosshair")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.crosshairshowplayer", "sv_tfa_crosshair_showplayer")
	TFA.CheckBoxNet(panel, "#tfa.svsettings.crosshairshowplayerteam", "sv_tfa_crosshair_showplayerteam")

	TFA.CheckBoxNet(panel, "#tfa.svsettings.randomseed", "sv_tfa_bullet_randomseed")
	panel:Help("#tfa.svsettings.randomseed_tip")

	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemult", "sv_tfa_damage_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultnpc", "sv_tfa_damage_multiplier_npc", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultrand_min", "sv_tfa_damage_mult_min", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.damagemultrand_max", "sv_tfa_damage_mult_max", 0, 10, 2)
	panel:Help("#tfa.svsettings.damagemultrand_tip")

	TFA.NumSliderNet(panel, "#tfa.svsettings.doorrespawntime", "sv_tfa_door_respawn", -1, 120, 0)

	TFA.NumSliderNet(panel, "#tfa.svsettings.jamchance", "sv_tfa_jamming_mult", 0.01, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.jamfactormult", "sv_tfa_jamming_factor", 0.01, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.jamfactorinc", "sv_tfa_jamming_factor_inc", 0.01, 10, 2)

	TFA.NumSliderNet(panel, "#tfa.svsettings.forcemult", "sv_tfa_force_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.penpowermul", "sv_tfa_bullet_penetration_power_mul", 0, 40, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.spreadmult", "sv_tfa_spread_multiplier", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.svsettings.penetrationlimit", "sv_tfa_penetration_hardlimit", 0, 200)
	TFA.NumSliderNet(panel, "#tfa.svsettings.defaultclip", "sv_tfa_default_clip", -1, 10, 0)
	TFA.NumSliderNet(panel, "#tfa.svsettings.rangemod", "sv_tfa_range_modifier", 0, 1, 3)
end

local function tfaOptionSights(panel)
	--Here are whatever default categories you want.
	local tfaOptionCL = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_sights"
	}

	tfaOptionCL.Options["#preset.default"] = {
		cl_tfa_3dscope_overlay = "1",
		cl_tfa_3dscope_quality = "0",
		cl_tfa_fx_rtscopeblur_passes = "3",
		cl_tfa_fx_rtscopeblur_intensity = "4",
		cl_tfa_fx_rtscopeblur_mode = "1",
		cl_tfa_scope_sensitivity_3d = "2",
		cl_tfa_scope_sensitivity_autoscale = "1",
		cl_tfa_scope_sensitivity = "100",
		cl_tfa_ironsights_toggle = "0",
		cl_tfa_ironsights_resight = "1",
		cl_tfa_ironsights_responsive = "0",
		cl_tfa_ironsights_responsive_timer = "0.175",
	}

	tfaOptionCL.CVars = table.GetKeys(tfaOptionCL.Options["#preset.default"])

	panel:AddControl("ComboBox", tfaOptionCL)

	panel:CheckBox("#tfa.sightsettings.3dscopeshadows", "cl_tfa_3dscope_overlay")

	local tfaOption3DSM = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsm",
		MenuButton = "0",
		Folder = "TFA 3D Scope Sens."
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.nc"] = {
		cl_tfa_scope_sensitivity_3d = "0"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.sc"] = {
		cl_tfa_scope_sensitivity_3d = "1"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.3d"] = {
		cl_tfa_scope_sensitivity_3d = "2"
	}

	tfaOption3DSM.Options["#tfa.sightsettings.3dsm.rt"] = {
		cl_tfa_scope_sensitivity_3d = "3"
	}

	tfaOption3DSM.CVars = table.GetKeys(tfaOption3DSM.Options["#tfa.sightsettings.3dsm.3d"])
	panel:AddControl("ComboBox", tfaOption3DSM)

	local tfaOption3DSQ = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsq",
		MenuButton = "0",
		Folder = "TFA 3D Scope Sens."
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.ul"] = {
		cl_tfa_3dscope_quality = "0"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.hq"] = {
		cl_tfa_3dscope_quality = "1"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.mq"] = {
		cl_tfa_3dscope_quality = "2"
	}

	tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.lq"] = {
		cl_tfa_3dscope_quality = "3"
	}

	tfaOption3DSQ.CVars = table.GetKeys(tfaOption3DSQ.Options["#tfa.sightsettings.3dsq.ul"])
	panel:AddControl("ComboBox", tfaOption3DSQ)

	local tfaOption3DSB = {
		Options = {},
		CVars = {},
		Label = "#tfa.sightsettings.3dsb",
		MenuButton = "0",
		Folder = "TFA 3D Scope Blur."
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.nb"] = {
		cl_tfa_fx_rtscopeblur_mode = "0"
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.sb"] = {
		cl_tfa_fx_rtscopeblur_mode = "1"
	}

	tfaOption3DSB.Options["#tfa.sightsettings.3dsb.bb"] = {
		cl_tfa_fx_rtscopeblur_mode = "2"
	}

	tfaOption3DSB.CVars = table.GetKeys(tfaOption3DSB.Options["#tfa.sightsettings.3dsb.bb"])
	panel:AddControl("ComboBox", tfaOption3DSB)

	panel:NumSlider("#tfa.sightsettings.rtbgblurpasses", "cl_tfa_fx_rtscopeblur_passes", 1, 5, 0)
	panel:NumSlider("#tfa.sightsettings.rtbgblurintensity", "cl_tfa_fx_rtscopeblur_intensity", 0.01, 10, 2)
	panel:CheckBox("#tfa.sightsettings.adstoggle", "cl_tfa_ironsights_toggle")
	panel:CheckBox("#tfa.sightsettings.adsresight", "cl_tfa_ironsights_resight")
	panel:CheckBox("#tfa.sightsettings.responsive", "cl_tfa_ironsights_responsive")
	panel:NumSlider("#tfa.sightsettings.responsive_timer", "cl_tfa_ironsights_responsive_timer", 0.01, 2, 3)
	panel:CheckBox("#tfa.sightsettings.scopesensscale", "cl_tfa_scope_sensitivity_autoscale")
	panel:NumSlider("#tfa.sightsettings.scopesenspct", "cl_tfa_scope_sensitivity", 0.01, 100, 2)
end

local function tfaOptionVM(panel)
	--Here are whatever default categories you want.
	local tfaOptionCL = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_viewmodel"
	}

	tfaOptionCL.Options["#preset.default"] = {
		cl_tfa_viewbob_animated = "0",
		cl_tfa_viewbob_intensity = "1",
		cl_tfa_gunbob_intensity = "1",
		cl_tfa_gunbob_custom = "1",
		cl_tfa_gunbob_invertsway = "0",
		cl_tfa_viewmodel_offset_x = "0",
		cl_tfa_viewmodel_offset_y = "0",
		cl_tfa_viewmodel_offset_z = "0",
		cl_tfa_viewmodel_offset_fov = "0",
		cl_tfa_viewmodel_multiplier_fov = "1",
		cl_tfa_viewmodel_flip = "0",
		cl_tfa_viewmodel_centered = "0",
		cl_tfa_viewmodel_nearwall = "1",
		cl_tfa_laser_trails = "1"
	}

	tfaOptionCL.CVars = table.GetKeys(tfaOptionCL.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionCL)

	panel:CheckBox("#tfa.vmsettings.viewbobanim", "cl_tfa_viewbob_animated")
	panel:NumSlider("#tfa.vmsettings.viewbobmult", "cl_tfa_viewbob_intensity", 0, 2, 2)
	panel:CheckBox("#tfa.vmsettings.gunbobcustom", "cl_tfa_gunbob_custom")
	panel:CheckBox("#tfa.vmsettings.gunswayinvert", "cl_tfa_gunbob_invertsway")
	panel:NumSlider("#tfa.vmsettings.gunbobmult", "cl_tfa_gunbob_intensity", 0, 2, 2)

	panel:NumSlider("#tfa.vmsettings.offset.x", "cl_tfa_viewmodel_offset_x", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.y", "cl_tfa_viewmodel_offset_y", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.z", "cl_tfa_viewmodel_offset_z", -2, 2, 2)
	panel:NumSlider("#tfa.vmsettings.offset.fov", "cl_tfa_viewmodel_offset_fov", -5, 5, 2)
	panel:NumSlider("#tfa.vmsettings.fovmult", "cl_tfa_viewmodel_multiplier_fov", 0.75, 2, 2)

	panel:CheckBox("#tfa.vmsettings.centered", "cl_tfa_viewmodel_centered")
	panel:CheckBox("#tfa.vmsettings.flip", "cl_tfa_viewmodel_flip")

	panel:CheckBox("#tfa.vmsettings.laserdottrail", "cl_tfa_laser_trails")
	panel:CheckBox("#tfa.vmsettings.nearwall", "cl_tfa_viewmodel_nearwall")
end

local function tfaOptionPerformance(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_performance"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		sv_tfa_fx_penetration_decal = "1",
		cl_tfa_fx_impact_enabled = "1",
		cl_tfa_fx_impact_ricochet_enabled = "1",
		cl_tfa_fx_impact_ricochet_sparks = "20",
		cl_tfa_fx_impact_ricochet_sparklife = "2",
		cl_tfa_fx_gasblur = "1",
		cl_tfa_fx_muzzlesmoke = "1",
		cl_tfa_fx_muzzlesmoke_limited = "1",
		cl_tfa_fx_muzzleflashsmoke = "1",
		cl_tfa_fx_ejectionlife = "15",
		cl_tfa_legacy_shells = "0",
		cl_tfa_fx_ads_dof = "0",
		cl_tfa_fx_ads_dof_hd = "0"
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.settings.client")
	panel:CheckBox("#tfa.perfsettings.gasblur", "cl_tfa_fx_gasblur")
	panel:CheckBox("#tfa.perfsettings.mzsmoke", "cl_tfa_fx_muzzleflashsmoke")
	panel:CheckBox("#tfa.perfsettings.mztrail", "cl_tfa_fx_muzzlesmoke")
	panel:CheckBox("#tfa.perfsettings.mztrail.limit", "cl_tfa_fx_muzzlesmoke_limited")
	panel:CheckBox("#tfa.perfsettings.ejsmoke", "cl_tfa_fx_ejectionsmoke")
	panel:CheckBox("#tfa.perfsettings.impactfx", "cl_tfa_fx_impact_enabled")
	panel:CheckBox("#tfa.perfsettings.ricochetfx", "cl_tfa_fx_impact_ricochet_enabled")

	panel:CheckBox("#tfa.perfsettings.oldshells", "cl_tfa_legacy_shells")

	panel:CheckBox("#tfa.perfsettings.adsdof", "cl_tfa_fx_ads_dof")
	panel:CheckBox("#tfa.perfsettings.adsdof.hd", "cl_tfa_fx_ads_dof_hd")

	panel:NumSlider("#tfa.perfsettings.ejlife", "cl_tfa_fx_ejectionlife", 0, 60, 0)

	panel:NumSlider("#tfa.perfsettings.ricochetspark.amount", "cl_tfa_fx_impact_ricochet_sparks", 0, 50, 0)
	panel:AddControl("Slider", {
		Label = "Ricochet Spark Amount",
		Command = "cl_tfa_fx_impact_ricochet_sparks",
		Type = "Integer",
		Min = "0",
		Max = "50"
	})

	panel:NumSlider("#tfa.perfsettings.ricochetspark.life", "cl_tfa_fx_impact_ricochet_sparklife", 0, 5, 2)

	panel:Help("#tfa.settings.server")
	TFA.CheckBoxNet(panel, "#tfa.perfsettings.penetrationdecal", "sv_tfa_fx_penetration_decal")
end

local function tfaOptionHUD(panel)
	--Here are whatever default categories you want.
	local tfaTBLOptionHUD = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_hud"
	}

	tfaTBLOptionHUD.Options["#preset.default"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "225",
		cl_tfa_hud_crosshair_color_g = "225",
		cl_tfa_hud_crosshair_color_b = "225",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "1",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "225",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.cross"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "200",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0.75",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "154",
		cl_tfa_hud_crosshair_outline_color_g = "152",
		cl_tfa_hud_crosshair_outline_color_b = "175",
		cl_tfa_hud_crosshair_outline_color_a = "255",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.dot"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "72",
		cl_tfa_hud_crosshair_color_g = "72",
		cl_tfa_hud_crosshair_color_b = "72",
		cl_tfa_hud_crosshair_color_a = "85",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.1",
		cl_tfa_hud_hangtime = "0.5",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "225",
		cl_tfa_hud_crosshair_outline_color_g = "225",
		cl_tfa_hud_crosshair_outline_color_b = "225",
		cl_tfa_hud_crosshair_outline_color_a = "85",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "0",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.rockstar"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "225",
		cl_tfa_hud_crosshair_color_g = "225",
		cl_tfa_hud_crosshair_color_b = "225",
		cl_tfa_hud_crosshair_color_a = "85",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.1",
		cl_tfa_hud_hangtime = "0.5",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "0",
		cl_tfa_hud_crosshair_width = "2",
		cl_tfa_hud_crosshair_gap_scale = "0",
		cl_tfa_hud_crosshair_outline_enabled = "1",
		cl_tfa_hud_crosshair_outline_width = "1",
		cl_tfa_hud_crosshair_outline_color_r = "30",
		cl_tfa_hud_crosshair_outline_color_g = "30",
		cl_tfa_hud_crosshair_outline_color_b = "30",
		cl_tfa_hud_crosshair_outline_color_a = "85",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "8",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.hl2"] = {
		cl_tfa_hud_crosshair_enable_custom = "0",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "0",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.01",
		cl_tfa_hud_hangtime = "0",
		cl_tfa_hud_crosshair_length_use_pixels = "1",
		cl_tfa_hud_crosshair_length = "0.5",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "1",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "0",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "0",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.hl2plus"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "255",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "225",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "255",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "0",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "0",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "1",
		cl_tfa_hud_crosshair_length = "0.5",
		cl_tfa_hud_crosshair_width = "1",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "5",
		cl_tfa_hud_crosshair_outline_color_g = "5",
		cl_tfa_hud_crosshair_outline_color_b = "5",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "1",
		cl_tfa_hud_crosshair_triangular = "0",
		cl_tfa_hud_crosshair_pump = "0",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1",
		cl_tfa_hud_hitmarker_color_r = "225",
		cl_tfa_hud_hitmarker_color_g = "225",
		cl_tfa_hud_hitmarker_color_b = "225",
		cl_tfa_hud_hitmarker_color_a = "225",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.Options["#tfa.hudpreset.crysis2"] = {
		cl_tfa_hud_crosshair_enable_custom = "1",
		cl_tfa_hud_crosshair_color_r = "231",
		cl_tfa_hud_crosshair_color_g = "255",
		cl_tfa_hud_crosshair_color_b = "255",
		cl_tfa_hud_crosshair_color_a = "255",
		cl_tfa_hud_crosshair_color_team = "1",
		cl_tfa_hud_crosshair_color_enemy_r = "204",
		cl_tfa_hud_crosshair_color_enemy_g = "0",
		cl_tfa_hud_crosshair_color_enemy_b = "0",
		cl_tfa_hud_crosshair_color_friendly_r = "38",
		cl_tfa_hud_crosshair_color_friendly_g = "255",
		cl_tfa_hud_crosshair_color_friendly_b = "38",
		cl_tfa_hud_enabled = "1",
		cl_tfa_hud_fallback_enabled = "1",
		cl_tfa_hud_ammodata_fadein = "0.2",
		cl_tfa_hud_hangtime = "1",
		cl_tfa_hud_crosshair_length_use_pixels = "0",
		cl_tfa_hud_crosshair_length = "1",
		cl_tfa_hud_crosshair_width = "2",
		cl_tfa_hud_crosshair_gap_scale = "1",
		cl_tfa_hud_crosshair_outline_enabled = "0",
		cl_tfa_hud_crosshair_outline_width = "0",
		cl_tfa_hud_crosshair_outline_color_r = "0",
		cl_tfa_hud_crosshair_outline_color_g = "0",
		cl_tfa_hud_crosshair_outline_color_b = "0",
		cl_tfa_hud_crosshair_outline_color_a = "0",
		cl_tfa_hud_crosshair_dot = "0",
		cl_tfa_hud_crosshair_triangular = "1",
		cl_tfa_hud_crosshair_pump = "1",
		cl_tfa_hud_hitmarker_enabled = "1",
		cl_tfa_hud_hitmarker_3d_all = "0",
		cl_tfa_hud_hitmarker_3d_shotguns = "1",
		cl_tfa_hud_hitmarker_solidtime = "0.1",
		cl_tfa_hud_hitmarker_fadetime = "0.3",
		cl_tfa_hud_hitmarker_scale = "1.5",
		cl_tfa_hud_hitmarker_color_r = "231",
		cl_tfa_hud_hitmarker_color_g = "255",
		cl_tfa_hud_hitmarker_color_b = "255",
		cl_tfa_hud_hitmarker_color_a = "255",
		cl_tfa_hud_scale = "1",
		cl_tfa_hud_keybindhints_enabled = "1",
		cl_tfa_hud_keybindhints_solidtime = "3",
		cl_tfa_hud_keybindhints_fadeintime = "1",
		cl_tfa_hud_keybindhints_fadeouttime = "4",
	}

	tfaTBLOptionHUD.CVars = table.GetKeys(tfaTBLOptionHUD.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaTBLOptionHUD)

	panel:NumSlider("#tfa.hudsettings.scalemul", "cl_tfa_hud_scale", 0.25, 4, 3)

	local hudpnl = vgui.Create("DForm", panel)
	hudpnl:SetName("#tfa.hudsettings.label")
	panel:AddItem(hudpnl)

	hudpnl:CheckBox("#tfa.hudsettings.enabled", "cl_tfa_hud_enabled")
	hudpnl:NumSlider("#tfa.hudsettings.fadein", "cl_tfa_hud_ammodata_fadein", 0.01, 1, 2)
	hudpnl:NumSlider("#tfa.hudsettings.hangtime", "cl_tfa_hud_hangtime", 0, 5, 2)

	hudpnl:Help("")
	hudpnl:CheckBox("#tfa.hudsettings.fallback", "cl_tfa_hud_fallback_enabled")
	hudpnl:Help("#tfa.hudsettings.fallback.desc")

	local xhairpnl = vgui.Create("DForm", panel)
	xhairpnl:SetName("#tfa.hudsettings.crosshair.label")
	panel:AddItem(xhairpnl)

	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.enabled", "cl_tfa_hud_crosshair_enable_custom")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.dot", "cl_tfa_hud_crosshair_dot")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.triangular", "cl_tfa_hud_crosshair_triangular")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.pump", "cl_tfa_hud_crosshair_pump")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.length", "cl_tfa_hud_crosshair_length", 0, 10, 2)
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.length.usepixels", "cl_tfa_hud_crosshair_length_use_pixels")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.gapscale", "cl_tfa_hud_crosshair_gap_scale", 0, 2, 2)
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.width", "cl_tfa_hud_crosshair_width", 0, 3, 0)
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.color", "cl_tfa_hud_crosshair_color_r", "cl_tfa_hud_crosshair_color_g", "cl_tfa_hud_crosshair_color_b", "cl_tfa_hud_crosshair_color_a")
	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.teamcolor", "cl_tfa_hud_crosshair_color_team")
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.teamcolor.enemy", "cl_tfa_hud_crosshair_color_enemy_r", "cl_tfa_hud_crosshair_color_enemy_g", "cl_tfa_hud_crosshair_color_enemy_b")
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.teamcolor.friendly", "cl_tfa_hud_crosshair_color_friendly_r", "cl_tfa_hud_crosshair_color_friendly_g", "cl_tfa_hud_crosshair_color_friendly_b")

	xhairpnl:CheckBox("#tfa.hudsettings.crosshair.outline.enabled", "cl_tfa_hud_crosshair_outline_enabled")
	xhairpnl:NumSlider("#tfa.hudsettings.crosshair.outline.width", "cl_tfa_hud_crosshair_outline_width", 0, 3, 0)
	AddFoldedColorMixer(xhairpnl, "#tfa.hudsettings.crosshair.outline.color", "cl_tfa_hud_crosshair_outline_color_r", "cl_tfa_hud_crosshair_outline_color_g", "cl_tfa_hud_crosshair_outline_color_b", "cl_tfa_hud_crosshair_outline_color_a")

	local hmpnl = vgui.Create("DForm", panel)
	hmpnl:SetName("#tfa.hudsettings.hitmarker.label")
	panel:AddItem(hmpnl)

	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.enabled", "cl_tfa_hud_hitmarker_enabled")
	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.3d.shotguns", "cl_tfa_hud_hitmarker_3d_shotguns")
	hmpnl:CheckBox("#tfa.hudsettings.hitmarker.3d.all", "cl_tfa_hud_hitmarker_3d_all")
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.solidtime", "cl_tfa_hud_hitmarker_solidtime", 0, 3, 3)
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.fadetime", "cl_tfa_hud_hitmarker_fadetime", 0, 3, 3)
	hmpnl:NumSlider("#tfa.hudsettings.hitmarker.scale", "cl_tfa_hud_hitmarker_scale", 0, 5, 2)
	AddFoldedColorMixer(hmpnl, "#tfa.hudsettings.hitmarker.color", "cl_tfa_hud_hitmarker_color_r", "cl_tfa_hud_hitmarker_color_g", "cl_tfa_hud_hitmarker_color_b", "cl_tfa_hud_hitmarker_color_a")

	local kbhpnl = vgui.Create("DForm", panel)
	kbhpnl:SetName("#tfa.hudsettings.keybindhints.label")
	panel:AddItem(kbhpnl)

	kbhpnl:CheckBox("#tfa.hudsettings.keybindhints.enabled", "cl_tfa_hud_keybindhints_enabled")
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.solidtime", "cl_tfa_hud_keybindhints_solidtime", 0, 15, 3)
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.fadeintime", "cl_tfa_hud_keybindhints_fadeintime", 0.01, 10, 3)
	kbhpnl:NumSlider("#tfa.hudsettings.keybindhints.fadeouttime", "cl_tfa_hud_keybindhints_fadeouttime", 0.01, 10, 3)
end

local function tfaOptionDeveloper(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_debug"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		["cl_tfa_debug_crosshair"] = 0,
		["cl_tfa_debug_animations"] = 0,
		["cl_tfa_debug_rt"] = 0,
		["cl_tfa_debug_cache"] = 0
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.devsettings.adminonly")

	panel:CheckBox("#tfa.devsettings.debug.crosshair", "cl_tfa_debug_crosshair")
	panel:CheckBox("#tfa.devsettings.debug.animations", "cl_tfa_debug_animations")
	panel:CheckBox("#tfa.devsettings.debug.rtshadow", "cl_tfa_debug_rt")
	panel:CheckBox("#tfa.devsettings.debug.cache", "cl_tfa_debug_cache")

	panel:Help("")

	panel:Help("#tfa.devsettings.documentation.label")
	local btnDocumentation = panel:Button("#tfa.devsettings.documentation.btn.github")
	btnDocumentation.DoClick = function()
		gui.OpenURL("https://github.com/YuRaNnNzZZ/TFA-SWEP-Base-Documentation")
	end

	local sdpnl = vgui.Create("DForm", panel)
	sdpnl:SetName("#tfa.devsettings.statmigrator.label")
	panel:AddItem(sdpnl)

	sdpnl:Help("#tfa.devsettings.statmigrator.help")
	sdpnl:Help(language.GetPhrase("tfa.devsettings.statmigrator.dataversion"):format("TFADataVersion", TFA.LatestDataVersion))

	local stat_old = sdpnl:TextEntry("#tfa.devsettings.statmigrator.old_name")

	local stat_new = sdpnl:TextEntry("#tfa.devsettings.statmigrator.new_name")
	stat_new:SetEditable(false)

	local copy_new = sdpnl:Button("#tfa.devsettings.statmigrator.copy_btn.label")
	copy_new.DoClick = function(self)
		SetClipboardText(stat_new:GetValue())
	end

	stat_old.OnChange = function(self)
		local stat = self:GetValue()

		if string.StartsWith(stat, "SWEP.") or string.StartsWith(stat, "self.") then
			stat = string.sub(stat, 6)
		end

		local _, path, _ = TFA.GetStatPath(stat, 0, TFA.LatestDataVersion)

		stat_new:SetValue(path)
	end
end

local function tfaOptionColors(panel)
	local tfaOptionCO = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_colors"
	}

	tfaOptionCO.Options["#preset.default"] = {
		cl_tfa_laser_color_r = "255",
		cl_tfa_laser_color_g = "0",
		cl_tfa_laser_color_b = "0",
		cl_tfa_reticule_color_r = "255",
		cl_tfa_reticule_color_g = "100",
		cl_tfa_reticule_color_b = "0"
	}

	tfaOptionCO.CVars = table.GetKeys(tfaOptionCO.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionCO)

	AddFoldedColorMixer(panel, "#tfa.colorsettings.laser", "cl_tfa_laser_color_r", "cl_tfa_laser_color_g", "cl_tfa_laser_color_b")
	AddFoldedColorMixer(panel, "#tfa.colorsettings.reticule", "cl_tfa_reticule_color_r", "cl_tfa_reticule_color_g", "cl_tfa_reticule_color_b")
end

local function tfaOptionBallistics(panel)
	--Here are whatever default categories you want.
	local tfaOptionPerf = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_ballistics"
	}

	tfaOptionPerf.Options["#preset.default"] = {
		["sv_tfa_ballistics_enabled"] = nil,
		["sv_tfa_ballistics_mindist"] = -1,
		["sv_tfa_ballistics_bullet_life"] = 10,
		["sv_tfa_ballistics_bullet_damping_air"] = 1,
		["sv_tfa_ballistics_bullet_damping_water"] = 3,
		["sv_tfa_ballistics_bullet_velocity"] = 1,
		["sv_tfa_ballistics_bullet_substeps"] = 3,
		["sv_tfa_ballistics_custom_gravity"] = 0,
		["sv_tfa_ballistics_custom_gravity_value"] = 0,
		["cl_tfa_ballistics_mp"] = 1,
		["cl_tfa_ballistics_fx_bullet"] = 1,
		["cl_tfa_ballistics_fx_tracers_style"] = 1,
		["cl_tfa_ballistics_fx_tracers_mp"] = 1,
		["cl_tfa_ballistics_fx_tracers_adv"] = 1
	}

	tfaOptionPerf.CVars = table.GetKeys(tfaOptionPerf.Options["#preset.default"])
	panel:AddControl("ComboBox", tfaOptionPerf)

	panel:Help("#tfa.settings.server")
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.enabled", "sv_tfa_ballistics_enabled")
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.mindist", "sv_tfa_ballistics_mindist", -1, 100, 0)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.life", "sv_tfa_ballistics_bullet_life", 0, 20, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.damping.air", "sv_tfa_ballistics_bullet_damping_air", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.damping.water", "sv_tfa_ballistics_bullet_damping_water", 0, 10, 2)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.bullet.velocity", "sv_tfa_ballistics_bullet_velocity", 0, 2, 3)
	TFA.NumSliderNet(panel, "#tfa.ballisticsettings.substeps", "sv_tfa_ballistics_substeps", 1, 5, 0)
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.customgravity", "sv_tfa_ballistics_custom_gravity")
	TFA.CheckBoxNet(panel, "#tfa.ballisticsettings.customgravityvalue", "sv_tfa_ballistics_custom_gravity_value")

	panel:Help("#tfa.settings.client")

	panel:CheckBox("#tfa.ballisticsettings.fx.bullet", "cl_tfa_ballistics_fx_bullet")
	panel:CheckBox("#tfa.ballisticsettings.fx.hq", "cl_tfa_ballistics_fx_tracers_adv")
	panel:CheckBox("#tfa.ballisticsettings.fx.mp", "cl_tfa_ballistics_mp")
	panel:CheckBox("#tfa.ballisticsettings.fx.mptracer", "cl_tfa_ballistics_fx_tracers_mp")

	local tfaOptionTracerStyle = {
		Options = {},
		CVars = {"cl_tfa_ballistics_fx_tracers_style"},
		Label = "#tfa.ballisticsettings.tracer",
		MenuButton = "1",
		Folder = "TFASSBallTracerStyle"
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.di"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 0
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.sm"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 1
	}

	tfaOptionTracerStyle.Options["#tfa.ballisticsettings.tracer.re"] = {
		["cl_tfa_ballistics_fx_tracers_style"] = 2
	}

	panel:AddControl("ComboBox", tfaOptionTracerStyle)
end

local contributors = {
	"INCONCEIVABLE!",
	"Generic Default",
	"Clavus",
	"Nemole/Scotch",
	"Daniel Stevens",
	"code_gs",
	"Juckey",
	"RalphORama",
	"Iamgoofball",
	"Alexander Grist-Hucker",
	"Zombine",
	"FlorianLeChat",
	"Global",
	"TheAsian EggrollMaker",
	"Kris",
	"DaNike_"
}

local function tfaOptionAbout(panel)
	panel:Help("TFA Base")
	panel:Help(language.GetPhrase("tfa.about.version"):format(TFA_BASE_VERSION_STRING or TFA_BASE_VERSION))
	panel:Help(language.GetPhrase("tfa.about.author"):format("The Forgotten Architect"))
	panel:Help(language.GetPhrase("tfa.about.maintain"):format("YuRaNnNzZZ", "DBotThePony"))
	panel:Help(language.GetPhrase("tfa.about.contributors"):format(table.concat(contributors, ", ")))

	panel:Help("")

	panel:Help("#tfa.about.font")
	panel:Help("Inter by The Inter Project Authors")
	local fontBtn = panel:Button("https://github.com/rsms/inter")
	fontBtn.DoClick = function()
		gui.OpenURL("https://github.com/rsms/inter")
	end

	panel:Help("")

	panel:Help("#tfa.about.changelog.label")
	panel:Help(TFA_BASE_VERSION_CHANGES)
	local btnChangelog = panel:Button("#tfa.about.changelog.btn.github")
	btnChangelog.DoClick = function()
		gui.OpenURL("https://github.com/YuRaNnNzZZ/TFA-SWEP-Base-Documentation/blob/master/CHANGELOG.md")
	end
	local btnSteamChangeNotes = panel:Button("#tfa.about.changelog.btn.steam")
	btnSteamChangeNotes.DoClick = function()
		gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/changelog/2840031720")
	end
end

local function tfaOptionInspect(panel)
	local presetTable = {
		Options = {},
		CVars = {},
		MenuButton = "1",
		Folder = "tfa_base_inspect"
	}

	presetTable.Options["#preset.default"] = {
		cl_tfa_inspection_bokeh = "0",
		cl_tfa_inspection_bokeh_radius = "0.1",
		cl_tfa_inspect_hide = "0",
		cl_tfa_inspect_hide_hud = "0",
		cl_tfa_inspect_hide_in_screenshots = "0",
		cl_tfa_inspect_newbars = "0",
		cl_tfa_inspect_spreadinmoa = "0",
		cl_tfa_attachments_persist_enabled = "1"
	}

	presetTable.CVars = table.GetKeys(presetTable.Options["#preset.default"])
	panel:AddControl("ComboBox", presetTable)

	panel:CheckBox("#tfa.inspectsettings.inspectdof.enabled", "cl_tfa_inspection_bokeh")
	panel:NumSlider("#tfa.inspectsettings.inspectdof.radius", "cl_tfa_inspection_bokeh_radius", 0.01, 1, 3)

	panel:CheckBox("#tfa.inspectsettings.hide", "cl_tfa_inspect_hide")
	if DLib then
		panel:CheckBox("#tfa.inspectsettings.hidehud", "cl_tfa_inspect_hide_hud")
	end
	panel:CheckBox("#tfa.inspectsettings.hideinscreenshots", "cl_tfa_inspect_hide_in_screenshots")
	panel:CheckBox("#tfa.inspectsettings.newbars", "cl_tfa_inspect_newbars")
	panel:CheckBox("#tfa.inspectsettings.spreadinmoa", "cl_tfa_inspect_spreadinmoa")

	panel:Help("")
	panel:CheckBox("#tfa.attsettings.persist", "cl_tfa_attachments_persist_enabled")

	-- these two are not concommands by design
	local btnResetWep = panel:Button("#tfa.attsettings.resetsaved.current.btn")
	btnResetWep.DoClick = function()
		local ply = LocalPlayer()
		if not IsValid(ply) or not ply:Alive() then return end

		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		local class = wep:GetClass()
		Derma_Query("#tfa.attsettings.resetsaved.current.text", string.format(language.GetPhrase("tfa.attsettings.resetsaved.current.title"), wep:GetPrintName()), "#GameUI_Yes", function()
			sql.Query(string.format([[DELETE FROM tfa_savedattachments WHERE class = '%s']], sql.SQLStr(class, true)))
		end, "#GameUI_No", function() end)
	end

	local btnResetAll = panel:Button("#tfa.attsettings.resetsaved.all.btn")
	btnResetAll.DoClick = function()
		Derma_Query("#tfa.attsettings.resetsaved.all.text", "#tfa.attsettings.resetsaved.all.title", "#GameUI_Yes", function()
			sql.Query([[DELETE FROM tfa_savedattachments]])
		end, "#GameUI_No", function() end)
	end
end

local function tfaAddOption()
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionVM", "#tfa.smsettings.viewmodel", "", "", tfaOptionVM)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionSights", "#tfa.smsettings.sights", "", "", tfaOptionSights)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "tfaOptionPerformance", "#tfa.smsettings.perf", "", "", tfaOptionPerformance)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseCrosshair", "#tfa.smsettings.hud", "", "", tfaOptionHUD)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseDeveloper", "#tfa.smsettings.dev", "", "", tfaOptionDeveloper)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseColor", "#tfa.smsettings.color", "", "", tfaOptionColors)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseBallistics", "#tfa.smsettings.ballistics", "", "", tfaOptionBallistics)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseServer", "#tfa.smsettings.server", "", "", tfaOptionServer)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseAbout", "#tfa.smsettings.about", "", "", tfaOptionAbout)
	spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseInspect", "#tfa.smsettings.inspect", "", "", tfaOptionInspect)
end

hook.Add("PopulateToolMenu", "tfaAddOption", tfaAddOption)

--addons/tfa_base/lua/tfa/modules/cl_tfa_stencilsights.lua:
-- stencil functions
local useStencils = render.SupportsPixelShaders_2_0() and render.SupportsVertexShaders_2_0()

local function defineCanvas(ref)
	render.UpdateScreenEffectTexture()
	render.ClearStencil()
	render.SetStencilEnable(true)
	render.SetStencilCompareFunction(STENCIL_ALWAYS)
	render.SetStencilPassOperation(STENCIL_REPLACE)
	render.SetStencilFailOperation(STENCIL_KEEP)
	render.SetStencilZFailOperation(STENCIL_REPLACE)
	render.SetStencilWriteMask(255)
	render.SetStencilTestMask(255)
	render.SetStencilReferenceValue(ref or 54)
end

local function drawOn()
	render.SetStencilCompareFunction(STENCIL_EQUAL)
end

local function stopCanvas()
	render.SetStencilEnable(false)
end

-- main draw functions
local CachedMaterials = {}

local DrawFunctions = {}

do -- Flat reticle, stays at center or moves with recoil
	local function ScreenScaleH(num)
		return num * (ScrH() / 480)
	end

	DrawFunctions[TFA.Enum.RETICLE_FLAT] = function(vm, ply, wep, SightElementTable)
		local ReticleMaterial = wep:GetStat("StencilSight_ReticleMaterial")
		if not ReticleMaterial then return end

		if type(ReticleMaterial) == "string" then
			CachedMaterials[ReticleMaterial] = CachedMaterials[ReticleMaterial] or Material(ReticleMaterial, "noclamp nocull smooth")
			ReticleMaterial = CachedMaterials[ReticleMaterial]
		end

		local ReticleSize = wep:GetStat("StencilSight_ReticleSize")
		if not ReticleSize then return end

		if wep:GetStat("StencilSight_ScaleReticleByScreenHeight", true) then
			ReticleSize = ScreenScaleH(ReticleSize)
		end

		if wep:GetStat("StencilSight_ScaleReticleByProgress", true) then
			ReticleSize = ReticleSize * wep.IronSightsProgress
		end

		local w, h = ScrW(), ScrH()

		local x, y = w * .5, h * .5
		if wep:GetStat("StencilSight_FollowRecoil", true) then
			x, y = TFA.LastCrosshairPosX or x, TFA.LastCrosshairPosY or y
		end

		local TargetColor = wep:GetStat("StencilSight_ReticleTint", color_white)

		if wep:GetStat("StencilSight_ReticleTintBySightColor", false) and IsValid(wep:GetOwner()) then
			local Owner = wep:GetOwner()

			local _GetNWVector = Owner.GetNW2Vector or Owner.GetNWVector

			local ColorVec = _GetNWVector(Owner, "TFAReticuleColor")

			if ColorVec then
				TargetColor = Color(ColorVec.x, ColorVec.y, ColorVec.z)
			end
		end

		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			TargetColor = ColorAlpha(TargetColor, wep.IronSightsProgress * 255)
		end

		render.DepthRange(0.0, 0.1)
		cam.Start2D(0, 0, w, h)
			surface.SetMaterial(ReticleMaterial)
			surface.SetDrawColor(TargetColor)
			surface.DrawTexturedRect(x - ReticleSize * .5, y - ReticleSize * .5, ReticleSize, ReticleSize)
		cam.End2D()
		if not wep.UseHands then
			render.DepthRange(0.0, 1.0)
		end
	end
end

do -- Model reticle, for when you don't have an attach point
	if IsValid(TFA.SightReticleEnt) then
		TFA.SightReticleEnt:Remove()
		TFA.SightReticleEnt = nil
	end

	TFA.SightReticleEnt = ClientsideModel("models/error.mdl", RENDERGROUP_VIEWMODEL)
	TFA.SightReticleEnt:SetNoDraw(true)

	local SightReticleEnt = TFA.SightReticleEnt

	DrawFunctions[TFA.Enum.RETICLE_MODEL] = function(vm, ply, wep, SightElementTable)
		if not SightElementTable.reticle then return end

		local SightElementModel = SightElementTable.curmodel

		SightReticleEnt:SetModel(SightElementTable.reticle)
		if SightReticleEnt:GetModel() == "models/error.mdl" then return end

		local matrix = Matrix()
		matrix:Scale(SightElementTable.size)
		SightReticleEnt:EnableMatrix("RenderMultiply", matrix)

		if SightReticleEnt:GetParent() ~= SightElementModel then
			SightReticleEnt:SetParent(SightElementModel)
			SightReticleEnt:SetPos(SightElementModel:GetPos())
			SightReticleEnt:SetAngles(SightElementModel:GetAngles())

			if not SightReticleEnt:IsEffectActive(EF_BONEMERGE) then
				SightReticleEnt:AddEffects(EF_BONEMERGE)
				SightReticleEnt:AddEffects(EF_BONEMERGE_FASTCULL)
			end
		end

		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CW) end
		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			local oldBlend = render.GetBlend()

			render.SetBlend(wep.IronSightsProgress)
			SightReticleEnt:DrawModel()
			render.SetBlend(oldBlend)
		else
			SightReticleEnt:DrawModel()
		end
		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CCW) end

		if wep:GetStat("StencilSight_EnableQuad") and bit.band(wep:GetStat("StencilSight_ReticleType")) ~= TFA.Enum.RETICLE_QUAD then
			DrawFunctions[TFA.Enum.RETICLE_QUAD](vm, ply, wep, SightElementTable)
		end
	end
end

do -- Quad/Attach reticle, TFA INS2 method
	local function GetTargetPosition(wep, SightElementTable)
		local TargetEntity = SightElementTable.curmodel
		if not IsValid(TargetEntity) then return end

		local Type = wep:GetStat("StencilSight_PositionType", TFA.Enum.SIGHTSPOS_ATTACH)

		local pos, ang

		if Type == TFA.Enum.SIGHTSPOS_ATTACH then
			local AttachmentID = wep:GetStat("StencilSight_ReticleAttachment")
			if not AttachmentID then return end

			if type(AttachmentID) == "string" then
				AttachmentID = TargetEntity:LookupAttachment(AttachmentID)
			end

			if not AttachmentID or AttachmentID <= 0 then return end

			local Attachment = TargetEntity:GetAttachment(AttachmentID)
			if not Attachment.Pos or not Attachment.Ang then return end

			pos, ang = Attachment.Pos, Attachment.Ang
		elseif Type == TFA.Enum.SIGHTSPOS_BONE then
			local BoneID = wep:GetStat("StencilSight_ReticleBone")

			if type(BoneID) == "string" then
				BoneID = TargetEntity:LookupBone(BoneID)
			end

			if not BoneID or BoneID < 0 then return end

			pos, ang = TargetEntity:GetBonePosition(BoneID)

			if pos == TargetEntity:GetPos() then
				pos = TargetEntity:GetBoneMatrix(BoneID):GetTranslation()
				ang = TargetEntity:GetBoneMatrix(BoneID):GetAngles()
			end
		else
			return
		end

		local OffsetPos = wep:GetStat("StencilSight_ReticleOffsetPos")
		if OffsetPos then
			pos = pos + ang:Right() * OffsetPos.x + ang:Forward() * OffsetPos.y + ang:Up() * OffsetPos.z
		end

		local OffsetAng = wep:GetStat("StencilSight_ReticleOffsetAng")
		if OffsetAng then
			ang:RotateAroundAxis(ang:Right(), OffsetAng.p)
			ang:RotateAroundAxis(ang:Up(), OffsetAng.y)
			ang:RotateAroundAxis(ang:Forward(), OffsetAng.r)
		end

		return pos, ang
	end

	DrawFunctions[TFA.Enum.RETICLE_QUAD] = function(vm, ply, wep, SightElementTable)
		local ReticleMaterial = wep:GetStat("StencilSight_ReticleMaterial")
		if not ReticleMaterial then return end

		if type(ReticleMaterial) == "string" then
			CachedMaterials[ReticleMaterial] = CachedMaterials[ReticleMaterial] or Material(ReticleMaterial, "noclamp nocull smooth")
			ReticleMaterial = CachedMaterials[ReticleMaterial]
		end

		local ReticleSize = wep:GetStat("StencilSight_ReticleSize")
		if not ReticleSize then return end

		if wep:GetStat("StencilSight_ScaleReticleByProgress", false) then
			ReticleSize = ReticleSize * wep.IronSightsProgress
		end

		local TargetColor = wep:GetStat("StencilSight_ReticleTint", color_white)

		if wep:GetStat("StencilSight_ReticleTintBySightColor", false) and IsValid(wep:GetOwner()) then
			local Owner = wep:GetOwner()

			local _GetNWVector = Owner.GetNW2Vector or Owner.GetNWVector

			local ColorVec = _GetNWVector(Owner, "TFAReticuleColor")

			if ColorVec then
				TargetColor = Color(ColorVec.x, ColorVec.y, ColorVec.z)
			end
		end

		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			TargetColor = ColorAlpha(TargetColor, wep.IronSightsProgress * 255)
		end

		local p, a = GetTargetPosition(wep, SightElementTable)
		if not p or not a then return end

		render.OverrideDepthEnable(true, true)

		render.SetMaterial(ReticleMaterial)
		render.DrawQuadEasy(p, a:Forward() * -1, ReticleSize, ReticleSize, TargetColor, 180 + a.r * (wep.ViewModelFlip and 1 or -1))

		render.OverrideDepthEnable(false, false)
	end
end

-- hook logic
if IsValid(TFA.SightMaskEnt) then
	TFA.SightMaskEnt:Remove()
	TFA.SightMaskEnt = nil
end

TFA.SightMaskEnt = ClientsideModel("models/error.mdl", RENDERGROUP_VIEWMODEL)
TFA.SightMaskEnt:SetNoDraw(true)

local SightMaskEnt = TFA.SightMaskEnt

local function DrawSight(vm, ply, wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	local shouldDraw = hook.Run("TFA_ShouldDrawStencilSight", wep)
	if shouldDraw == false then return end

	local wep2 = wep:GetTable()

	if wep2.TFA_IsDrawingStencilSights then return end
	wep2.TFA_IsDrawingStencilSights = true

	if not wep2.GetStat(wep, "StencilSight") then wep2.TFA_IsDrawingStencilSights = false return end
	if wep2.IronSightsProgress < wep2.GetStat(wep, "StencilSight_MinPercent", 0.05) then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementName = wep2.GetStat(wep, "StencilSight_VElement")
	if not SightElementName or not wep2.GetStat(wep, "VElements." .. SightElementName .. ".active") then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementTable = wep2.VElements[SightElementName]
	if not SightElementTable then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementModel = SightElementTable.curmodel
	if not IsValid(SightElementModel) then wep2.TFA_IsDrawingStencilSights = false return end

	if useStencils then
		defineCanvas()

		local SightMaskModel = SightElementModel

		if wep2.GetStat(wep, "StencilSight_UseMask", false) and SightElementTable.mask then
			SightMaskEnt:SetModel(SightElementTable.mask)

			if SightMaskEnt:GetModel() ~= "models/error.mdl" then
				SightMaskModel = SightMaskEnt

				local matrix = Matrix()
				matrix:Scale(SightElementTable.size)
				SightMaskEnt:EnableMatrix("RenderMultiply", matrix)

				if SightMaskEnt:GetParent() ~= SightElementModel then
					SightMaskEnt:SetParent(SightElementModel)
					SightMaskEnt:SetPos(SightElementModel:GetPos())
					SightMaskEnt:SetAngles(SightElementModel:GetAngles())

					if not SightMaskEnt:IsEffectActive(EF_BONEMERGE) then
						SightMaskEnt:AddEffects(EF_BONEMERGE)
						SightMaskEnt:AddEffects(EF_BONEMERGE_FASTCULL)
					end
				end
			end
		end

		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CW) end
		local oldBlend = render.GetBlend()
		render.SetBlend(0)
			SightMaskModel:DrawModel()
		render.SetBlend(oldBlend)
		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CCW) end

		drawOn()
	end

	local retValPre = wep2.CallAttFunc(wep, "PreDrawStencilSight", vm, ply, SightElementTable)
	if retValPre ~= true then
		retValPre = wep2.PreDrawStencilSight(wep, vm, ply, SightElementTable) or retValPre
	end

	if retValPre ~= false then
		local funcType = wep2.GetStat(wep, "StencilSight_ReticleType", TFA.Enum.RETICLE_FLAT)

		for _, retType in ipairs(TFA.Enum.RETICLE_DRAW_ORDER) do
			if bit.band(funcType, retType) == retType and DrawFunctions[retType] then
				ProtectedCall(function()
					DrawFunctions[retType](vm, ply, wep, SightElementTable)
				end)
			end
		end

		local retValPost = wep2.CallAttFunc(wep, "PostDrawStencilSight", vm, ply, SightElementTable)
		if retValPost ~= true then
			wep2.PostDrawStencilSight(wep, vm, ply, SightElementTable)
		end
	end

	if useStencils then
		stopCanvas()
	end

	wep2.TFA_IsDrawingStencilSights = false
end

hook.Add("PostDrawViewModel", "TFA_DrawStencilSight", DrawSight)
--addons/tfa_base/lua/tfa/att/base.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

-- ATTACHMENT.TFADataVersion = 1 -- Uncomment this in your attachment file
-- If it is undefined, if fallback to 0 and WeaponTable gets migrated like SWEPs do

ATTACHMENT.Name = "Base Attachment"
ATTACHMENT.ShortName = nil --Abbreviation, 5 chars or less please
ATTACHMENT.Description = {} --TFA.Attachments.Colors["+"], "Does something good", TFA.Attachments.Colors["-"], "Does something bad" }
ATTACHMENT.Icon = nil --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"
ATTACHMENT.WeaponTable = {} --put replacements for your SWEP talbe in here e.g. ["Primary"] = {}

ATTACHMENT.DInv2_GridSizeX = nil -- DInventory/2 Specific. Determines attachment's width in grid.
ATTACHMENT.DInv2_GridSizeY = nil -- DInventory/2 Specific. Determines attachment's height in grid.
ATTACHMENT.DInv2_Volume = nil -- DInventory/2 Specific. Determines attachment's volume in liters.
ATTACHMENT.DInv2_Mass = nil -- DInventory/2 Specific. Determines attachment's mass in kilograms.
ATTACHMENT.DInv2_StackSize = nil -- DInventory/2 Specific. Determines attachment's maximal stack size.

ATTACHMENT.TFADataVersion = nil -- TFA.LatestDataVersion, specifies version of TFA Weapon Data this attachment utilize in `WeaponTable`
-- 0 is original, M9K-like data, and is the fallback if `TFADataVersion` is undefined

function ATTACHMENT:CanAttach(wep)
	return true --can be overridden per-attachment
end

function ATTACHMENT:Attach(wep)
end

function ATTACHMENT:Detach(wep)
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--addons/egm_tfa_weapons/lua/tfa/att/rocket_mod_tracking.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Verfolgungsmodus"
ATTACHMENT.ShortName = "V.M"
ATTACHMENT.Icon = "entities/atts/rctm_traget.png"
ATTACHMENT.Description = {
	TFA.AttachmentColors["="], "Die Rakete wird das Ziel verfolgen.",
	TFA.AttachmentColors["="], "10 Sekunden Lebensdauer.",
	TFA.AttachmentColors["="], "Geschwindigkeit von 157 m/s.",
}

ATTACHMENT.WeaponTable = {
	["VElements"] = {},
	["WElements"] = {
		["laser_beam"] = {["active"] = false},
		["laser_beam_tracking"] = {["active"] = true},
	},
	["Primary"] = {},
}

function ATTACHMENT:Attach(wep)
	wep:Unload()
end

function ATTACHMENT:Detach(wep)
	wep:Unload()
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--lua/autorun/tikkes.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Tikkes",		"models/player/tiki/tikkes.mdl" )

--lua/autorun/tuskenraider.lua:
player_manager.AddValidModel( "Tusken Raider HD", 		"models/zyan7259/zusken_raider_player/zusken_raider_player.mdl" );
list.Set( "PlayerOptionsModel", "Tusken Raider HD", 	"models/zyan7259/zusken_raider_player/zusken_raider_player.mdl" );

--lua/autorun/venator_bacta.lua:
-- Created by Oninoni
-- Based on Code by Syphadias
-- Huge thanks to them!

-- This has to match the map Name
if not (game.GetMap() == "rp_venator_extensive_v1_4") then return end

-- The Ammount of Bacta Tanks that are used
local bactaCount = 2

-- The Name of the prop_vehicle_prisoner_pod without its suffix (e.g. bacta1, bacta2, ... -> bacta)
local entityName = "bacta"

-- Bacta Seat Don't fricking touch anything below this line!
local Category = "Map Utilities"
local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_GMOD_NOCLIP_LAYER )
end
local V = {
    Name = "Bacta Tank Seat",
	Model = "models/lordtrilobite/starwars/props/bactatankb.mdl",
    Class = "prop_vehicle_prisoner_pod",
    Category = Category,
 
    Author = "Syphadias, Oninoni",
    Information = "Seat with custom animation",
    Offset = 16,
 
    KeyValues = {
        vehiclescript = "scripts/vehicles/prisoner_pod.txt",
        limitview = "0"
    },
    Members = {
        HandleAnimation = StandAnimation
    }
}
list.Set( "Vehicles", "bacta_seat", V )
 
if SERVER then
    local seatCache = {}
    local function IsValidSeat(seat)
        local seat = seatCache[seat]
     
        if seat and IsValid(seat) then
			return true
        end
     
        return false
    end
	
	hook.Add("Think", "UpdateseatPosBacta", function()
		for i = 1, bactaCount, 1 do
			if !IsValidSeat(i) then
				seatCache[i] = ents.FindByName(entityName .. i)[1]

				if !IsValidSeat(i) then
					continue
				end
			end

			seatCache[i]:SetVehicleClass("bacta_seat")
		end
	end)
end
--lua/autorun/venator_turbolasers.lua:
-- Based on code provided for gm_eperors_tower by P4sca1
-- Adapted by KingPommes for Venator and ISD
-- Oni was here too.


if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end
 
local masterCount = 2
local cannonCount = 8 + masterCount --plus two master seats
local cannonCache = {} --caching the cannons instead of finding them every tick safes much performance
local turretCache = {}
local exitOffset = Vector(-32, 32, 8)

local cannonX = "TLXAxis"
local cannonY = "TLYAxis"
local cannonTrack = "TLTrack"
local cannonSeat = "TLSeat"

local viewOffsetForward = 128
local viewOffsetUp = 0

local function IsValidCannon(cannon)
	local cannon = cannonCache[cannon]

	if cannon and IsValid(cannon.x) and IsValid(cannon.y) and IsValid(cannon.track) and IsValid(cannon.seat) then
		return true
    end

    return false
end

if CLIENT then
    local inCannon = false
	local turret
 
    net.Receive("DSEnterCannon", function(len, pl)
        inCannon = true
		turret = net.ReadEntity()
    end)
 
    net.Receive("DSLeaveCannon", function(len, pl)
        inCannon = false
		turret = nil
    end)
	

	hook.Add("CalcVehicleView", "UpdateCannonView", function(vehicle, ply, view)
		if inCannon then
			local newView = {}
			if (turret:GetModel() == "models/lordtrilobite/starwars/props/imp_chair01_cis.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -1000 + vehicle:GetUp() * -15000
				newView.angles = newView.angles
			elseif (turret:GetModel() == "models/kingpommes/starwars/venator/turbolaser_seat_venator.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -2500 + vehicle:GetUp() * -2600
				newView.angles = newView.angles
			else
				newView.origin = turret:GetPos() + turret:GetForward() * viewOffsetForward + turret:GetUp() * viewOffsetUp
				newView.angles = newView.angles
			end
			return newView
		end
	end)
end
 
if SERVER then
	hook.Add("Think", "UpdateCannonPos", function()
		for i = 1, cannonCount , 1 do
			
				-- create cache if it does not already exist or update it, if it is not valid anymore			
				if !IsValidCannon(i) then
				
					cannonCache[i] = {}
					if (i <= cannonCount - masterCount) then
						cannonCache[i]["x"] = ents.FindByName(cannonX .. i)[1]
						cannonCache[i]["y"] = ents.FindByName(cannonY .. i)[1]
						cannonCache[i]["track"] = ents.FindByName(cannonTrack .. i)[1]
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
					else
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
						cannonCache[i]["x"] = cannonCache[i]["seat"]
						cannonCache[i]["y"] = cannonCache[i]["seat"]
						cannonCache[i]["track"] = cannonCache[i]["seat"]
						continue
					end
					
					if IsValid(cannonCache[i]["seat"]) then
						cannonCache[i]["seat"]:SetVehicleClass("phx_seat2")
					end
				
					-- if the cannon is still not valid after searching it, then skip it, because it does not exist
					if !IsValidCannon(i) then
						continue
					end
				end
				cannonCache[i]["x"]:SetAngles(Angle(cannonCache[i]["x"]:GetAngles().pitch, cannonCache[i]["track"]:GetAngles().yaw, cannonCache[i]["x"]:GetAngles().roll))
				cannonCache[i]["y"]:SetAngles(Angle(cannonCache[i]["track"]:GetAngles().pitch, cannonCache[i]["y"]:GetAngles().yaw, cannonCache[i]["y"]:GetAngles().roll))
			
		end
	end)

    util.AddNetworkString("DSEnterCannon")
 
    hook.Add("PlayerEnteredVehicle", "EnterCannon", function(ply, veh, role)
        if string.StartWith(veh:GetName(), cannonSeat) then
            net.Start("DSEnterCannon")
			local turret
			for i = 1, cannonCount, 1 do
				if (cannonCache[i]["seat"] == veh) then
					turret = cannonCache[i]["y"]
					break
				end
			end
			net.WriteEntity(turret)
            net.Send(ply)
			ply:CrosshairEnable()
		end
		
		if (!IsValid(veh.applied)) then
			if (veh:GetKeyValues()["hammerid"] ~= 0) then
				if (veh:GetModel() == "models/kingpommes/starwars/misc/seats/turbolaser_seat.mdl") then
					veh:SetVehicleClass("phx_seat2")
					veh.applied = true
				end
			end
		end
    end)
 
    util.AddNetworkString("DSLeaveCannon")
 
    hook.Add("PlayerLeaveVehicle", "LeaveCannon", function(ply, veh)
		if (string.StartWith(veh:GetName(), cannonSeat)) then
			net.Start("DSLeaveCannon")
			net.Send(ply)
	
			ply:SetPos(veh:GetPos() + veh:GetForward() * exitOffset.x + veh:GetRight() * exitOffset.y + veh:GetUp() * exitOffset.z)
			return
		end
		if (veh:GetKeyValues()["hammerid"] ~= 0) then
			ply:SetPos(veh:GetPos() + veh:GetRight() * -32)
		end
    end)
end
--lua/autorun/venator_visual_alarm.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

-- Set default values (thats why it also resists a lua refresh)
local nextTick = 0

local materialWallLamp = Material("kingpommes/starwars/venator/corridor_wall_lamps")
local materialCorridorLamp = Material("kingpommes/starwars/venator/corridor_lights")
local materialCorridorLampb = Material("kingpommes/starwars/venator/corridor_lightsb")
local materialLightDecal = Material("kingpommes/starwars/venator/lights_decal")

local defaultTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps"
local defaultTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights"
local defaultTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb"
local defaultTextureLightDecal = "kingpommes/starwars/venator/lights_decal"

local redAlarmTextureWallLamp = "kingpommes/starwars/venator/corridor_wall_lamps_red"
local redAlarmTextureCorridorLamp = "kingpommes/starwars/venator/corridor_lights_red"
local redAlarmTextureCorridorLampb = "kingpommes/starwars/venator/corridor_lightsb_red"
local redAlarmTextureLightDecal = "kingpommes/starwars/venator/lights_decal_red"

local alarmOn = false
local networkSend = false

materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)

if SERVER then
	util.AddNetworkString("Venator_Ext_AlarmNet")

	-- Networks current alarm state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_AlarmConnectSync", function(ply)
		net.Start("Venator_Ext_AlarmNet")
			net.WriteBool(alarmOn)
		net.Send(ply)
	end)
end

function EnableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(true)
	net.Broadcast()
	
	alarmOn = true
	networkSend = true
end

function DisableVisualAlarm()
	net.Start("Venator_Ext_AlarmNet")
	net.WriteBool(false)
	net.Broadcast()
	networkSend = false
	alarmOn = false
end

hook.Add("Think", "Venator_Ext_AlarmThink", function()
	if CurTime() > nextTick then
		nextTick = CurTime() + 0.56
		
		-- Checks if alarm is on.
		if CLIENT and alarmOn then
			-- Changes between textured.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == defaultTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", redAlarmTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", redAlarmTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", redAlarmTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", redAlarmTextureLightDecal)
				
			elseif materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		elseif CLIENT and not alarmOn then
			-- If the alarm is off and texture is not resetted, reset it.
			if materialWallLamp:GetTexture("$basetexture"):GetName() == redAlarmTextureWallLamp then
				materialWallLamp:SetTexture("$basetexture", defaultTextureWallLamp)
				materialCorridorLamp:SetTexture("$basetexture", defaultTextureCorridorLamp)
				materialCorridorLampb:SetTexture("$basetexture", defaultTextureCorridorLampb) 
				materialLightDecal:SetTexture("$basetexture", defaultTextureLightDecal)
			end
		end
	end
end)

hook.Add("PostCleanupMap", "Venator_Ext_AlarmCleanup", function()
	alarmOn = false
end)

if CLIENT then
	-- Receives current alarm state.
	net.Receive("Venator_Ext_AlarmNet", function(len)
		alarmOn = net.ReadBool()
	end)
end
--addons/vyhub-gmod/lua/vyhub/lib/json.lua:
VyHub.Lib.json = VyHub.Lib.json or {}

--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end

VyHub.Lib.json = json
--addons/vyhub-gmod/lua/vyhub/shared/sh_lang.lua:
local f = string.format
local json = VyHub.Lib.json

VyHub.Lang = VyHub.Lang or {}
VyHub.lang = VyHub.lang or nil

if SERVER then
    util.AddNetworkString("vyhub_lang")

    VyHub.Lang.compressed = VyHub.Lang.compressed or nil 

    function VyHub.Lang:load()
        local f_en = file.Open("vyhub/lang/en.json", "r", "LUA")

        if f_en == nil then
            VyHub:msg("Missing language file en.json!!! PLEASE MAKE SURE TO DOWNLOAD VYHUB-GMOD ON THE GITHUB RELESES PAGE! https://github.com/matbyte-com/vyhub-gmod/releases", "error")
            return
        end

        local en = json.decode(f_en:Read())
        f_en:Close()

        if not istable(en) then
            VyHub:msg("Could not load language file en.json!", "error")
            return
        end

        VyHub.lang = en

        VyHub:msg("Loaded language en.")

        if VyHub.Config.lang != 'en' then
            local f_custom = file.Open(f("vyhub/lang/%s.json", VyHub.Config.lang), "r", "LUA")

            if f_custom != nil then 
                local custom = json.decode(f_custom:Read())
                f_custom:Close()

                if istable(custom) then
                    table.Merge(VyHub.lang, custom)
                    VyHub:msg(f("Loaded language %s.", VyHub.Config.lang))
                else
                    VyHub:msg(f("Could not load language file %s.json!", VyHub.Config.lang), "warning")
                end
            else
                VyHub:msg(f("Missing language file %s.json.", VyHub.Config.lang), "warning")
            end
        end     
        
        VyHub.Lang.compressed = util.Compress(json.encode(VyHub.lang))
    end

    if VyHub.lang == nil then
        VyHub.Lang:load()
    end

    net.Receive("vyhub_lang", function(_, ply)
        if not IsValid(ply) then return end
        if not VyHub.Lang.compressed then return end

        local len = #VyHub.Lang.compressed

        net.Start("vyhub_lang")
            net.WriteUInt(len, 16)
            net.WriteData(VyHub.Lang.compressed, len)
        net.Send(ply)
    end)
end

if CLIENT then
    function VyHub.Lang:load()
        net.Start("vyhub_lang")
        net.SendToServer()
    end

    net.Receive("vyhub_lang", function()
        timer.Remove("vyhub_lang_load")

        local len = net.ReadUInt(16)
        local lang_compr = net.ReadData(len)

        VyHub.lang = json.decode(util.Decompress(lang_compr))

        VyHub:msg("Loaded language.")
        
        hook.Run("vyhub_lang_loaded")
    end)

    hook.Add("Initialize", "vyhub_lang_Initialize", function ()
        VyHub.Lang:load()

        timer.Create("vyhub_lang_load", 5, 5, function ()
            if VyHub.lang == nil then
                VyHub.Lang:load()
            else
                timer.Remove("vyhub_lang_load")
            end
        end)
    end)
end

--addons/vyhub-gmod/lua/vyhub/client/cl_ply.lua:
local meta_ply = FindMetaTable("Player")

VyHub.user_id = VyHub.user_id or nil

function meta_ply:VyHubID()
    if IsValid(self) then
        if self == LocalPlayer() then        
            return VyHub.user_id
        else
            MsgN("ERROR: Cannot get VyHubID of other users on the client side.")
        end
    end
end

net.Receive("vyhub_user_id", function ()
    VyHub.user_id = net.ReadString()
end)

--addons/wiltos_animation_base/lua/wos/anim_extension/core/sh_metatable.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Meta Tables:
		Creating functions for your Hold Types since 2017
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension.HoldTypeMeta = wOS.AnimExtension.HoldTypeMeta or {}

local HOLDTYPE = {}

HOLDTYPE.GetName = function( self ) 
	return self.Name or nil
end

HOLDTYPE.GetID = function( self )
	return self.HoldType or "wos-custom"
end

HOLDTYPE.GetActivityList = function( self )
	local index = wOS.AnimExtension.ActIndex[ self:GetBaseHoldType() ]
	return {
		[ACT_MP_STAND_IDLE] 				= index,
	    [ACT_MP_WALK] 						= index+1,
		[ACT_MP_RUN] 						= index+2,
		[ACT_MP_CROUCH_IDLE] 				= index+3,
		[ACT_MP_CROUCHWALK] 				= index+4,
		[ACT_MP_ATTACK_STAND_PRIMARYFIRE] 	= index+5,
		[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index+5,
		[ACT_MP_RELOAD_STAND]		 		= index+6,
		[ACT_MP_RELOAD_CROUCH]		 		= index+6,
		[ACT_MP_JUMP] 						= index+7,
		[ACT_RANGE_ATTACK1] 				= index+8,
		[ACT_MP_SWIM] 						= index+9,	
	}
end

HOLDTYPE.GetBaseHoldType = function( self )
	return self.BaseHoldType or "normal"
end

HOLDTYPE.SetBaseHoldType = function( self, newtype )
	self.BaseHoldType = newtype
end

//This is a god damn mess mostly because of legacy support, I need to redo this part for sure.
//OR at least make the old hold-types switch over to the new one
HOLDTYPE.GetActData = function( self, act ) 

	local base = self.Translations[ act ]
	local tbl
	
	if base then
		tbl = {}
		if istable( base ) then
			if base.Sequence then
				tbl.Sequence = base.Sequence
				tbl.Weight = base.Weight or 1
			else
				local key = math.Round( util.SharedRandom( "wOS.AnimExtension." .. self:GetName() .. "[" .. act .. "]", 1, #base ) )
				local innerbase = base[key]
				if istable( innerbase ) then
					tbl = innerbase
				elseif isstring( innerbase ) then
					tbl.Sequence = innerbase
					tbl.Weight = 1
				end
			end
		elseif isstring( base ) then
			tbl.Sequence = base
		end
	end

	return tbl
	
end

HOLDTYPE.__index = HOLDTYPE

function wOS.AnimExtension.HoldTypeMeta:CreateMetaType( tbl )
	setmetatable( tbl, HOLDTYPE )
end
--addons/wiltos_animation_base/lua/wos/anim_extension/core/sh_holdtypes.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Register:
		The core files needed to make your own hold types
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}
wOS.AnimExtension.TranslateHoldType = wOS.AnimExtension.TranslateHoldType or {}

wOS.AnimExtension.ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

function wOS.AnimExtension:RegisterHoldtype( data )

	self.TranslateHoldType[ data.HoldType ] = data
    self.HoldTypeMeta:CreateMetaType( self.TranslateHoldType[ data.HoldType ] )
	
	if data.BaseHoldType then
		if prone then
			if prone.animations then
				if prone.animations.WeaponAnims then
					prone.animations.WeaponAnims.moving[ data.HoldType ] = prone.animations.WeaponAnims.moving[ data.BaseHoldType ]
					prone.animations.WeaponAnims.idle[ data.HoldType ] = prone.animations.WeaponAnims.idle[ data.BaseHoldType ]
				end
			end
		end
	end

	print( "[wOS] Registered new Hold Type: " .. data.Name )
	
end

local meta = FindMetaTable( "Player" )
local ENTITY = FindMetaTable( "Entity" )

local AttackTable = {
[ ACT_MP_ATTACK_STAND_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_STAND_SECONDARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_SECONDARYFIRE  ] = true,
}

local _TranslateWeaponActivity = meta.TranslateWeaponActivity
function meta:TranslateWeaponActivity( act )

	if AttackTable[ act ] then
		local wep = self:GetActiveWeapon()
		if IsValid( wep ) then  
			local holdtype = wep:GetHoldType()
			if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
				local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
				if ATTACK_DATA then
					local anim = self:LookupSequence( ATTACK_DATA.Sequence )
					self:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
					self:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )
				end
			end
		end
	end
	
	return _TranslateWeaponActivity( self, act )

end


-- local _DoAnimationEvent = meta.DoAnimationEvent
-- function meta:DoAnimationEvent( ply, event, data )

-- 	local act = _DoAnimationEvent( self, ply, event, data )
-- 	print( act )
-- 	local wep = self:GetActiveWeapon()
-- 	if IsValid( wep ) then  
-- 		local holdtype = wep:GetHoldType()
-- 		if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
-- 			local result = wOS.AnimExtension.TranslateHoldType[ holdtype ][ act ]
-- 			if result then
-- 				if istable( result ) then
-- 					result = table.Random( result )
-- 				end
-- 				if isstring( result ) then
-- 					local anim = ply:LookupSequence( result )	
-- 					ply.ActOverrider = act
-- 					ply.SequenceTime = CurTime() + ply:SequenceDuration( anim )
-- 				end
-- 			end
-- 		end
-- 	end
	
-- 	return act
-- end

hook.Add( "DoAnimationEvent", "wOS.AnimExtension.CustomTriggers", function( ply, event, data ) 

	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) then return end
	local holdtype = wep:GetHoldType()
	if !wOS.AnimExtension.TranslateHoldType[ holdtype ] then return end

	local act = 9999
	local crouch = ply:Crouching()
	if event == PLAYERANIMEVENT_RELOAD then
		act = ( crouch and ACT_MP_RELOAD_CROUCH ) or ACT_MP_RELOAD_STAND
	elseif event == PLAYERANIMEVENT_ATTACK_SECONDARY then
		act = ( crouch and ACT_MP_ATTACK_CROUCH_SECONDARYFIRE ) or ACT_MP_ATTACK_STAND_SECONDARYFIRE
	end

	local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
	if !ATTACK_DATA then return end

	local anim = ply:LookupSequence( ATTACK_DATA.Sequence )
	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
	ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )

	return ACT_INVALID
end )

hook.Add( "Initialize", "wOS.AnimExtension.CustomSequenceHoldtypes", function()

	local _CalcMainActivity = GAMEMODE.CalcMainActivity
	function GAMEMODE:CalcMainActivity( ply, vel )
		
		local act, seq = _CalcMainActivity( self, ply, vel )
		local prone = ( prone and ply:IsProne() ) or false

		if not prone then
			local wep = ply:GetActiveWeapon()
			if IsValid( wep ) then  
				local holdtype = wep:GetHoldType()
				if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
					local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
					if act == ACT_MP_RUN and ply:KeyDown( IN_SPEED ) then
						ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( ACT_MP_SPRINT ) or ATTACK_DATA
					end
					if ATTACK_DATA then
						seq = ply:LookupSequence( ATTACK_DATA.Sequence )
					end
				end
			end

			
			if act != ply.LastAct then
				ply:SetCycle( 0 )
			end
		end
		
		ply.LastAct = act
		
		return act, seq
		
	end
	
end )

if SERVER then return end

concommand.Add( "wos_base_help", function( ply, cmd, args )
	MsgC( Color( 255, 255, 255 ), "------------------ ", Color( 133, 173, 219 ), "wiltOS HELP PRINT", Color( 255, 255, 255 ), " ----------------------\n" )
	MsgC( Color( 255, 255, 255 ), "Addon Path Check: " )
	LocalPlayer():ConCommand( "whereis models/m_anm.mdl" )
	timer.Simple( 0.01, function()
	
		MsgC( color_white, "\nPlease ensure the addon path above points to ", Color( 0, 255, 0 ), "'[wOS] Animation Extension - Base'\n")
		MsgC( color_white, "If it does not, unsubscribe to the addon it does point to and get the Animation Base\n")
		print("\n")

		local seq = LocalPlayer():LookupSequence( "_base_wiltos_enabled_" )
		local resp = ( seq >= 0 and Color( 0, 255, 0 ) ) or Color( 255, 0, 0 )
		MsgC( color_white, "Sequence Check: ", resp, "\t", seq, "\n" )
		MsgC( color_white, "If the above sequence check is ", Color( 255, 0, 0 ), -1, color_white, " and the addon above points to the correct location,\nensure your model is a ", Color( 0, 255, 0 ), "PLAYER MODEL", color_white, " and not an ", Color( 255, 0, 0 ), "NPC MODEL\n" )
		MsgC( color_white, "Run this commmand again as a default GMod player model. If it still prints ", Color( 255, 0, 0 ), -1, color_white, " your Animation Base may be outdated\n" )

		print( "\n" )
		MsgC( color_white, "You can find the link here: https://steamcommunity.com/sharedfiles/filedetails/?id=757604550\n")
		MsgC( Color( 255, 255, 255 ), "-----------------------------------------------------------\n" )
	end )
end )
--addons/wiltos_animation_base/lua/wos/anim_extension/core/sh_prone_support.lua:
--[[-------------------------------------------------------------------
	wiltOS Prone Compatability:
		Fixes hold types for Prone Mod
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}

hook.Add("prone.Initialized", "wOS.AnimExtension.AddProneTypes", function()
	for holdtype, data in pairs( wOS.AnimExtension.HoldTypes ) do
		local iseq = prone.GetIdleAnimation( data.BaseHoldType ) 
		local mseq = prone.GetMovingAnimation( data.BaseHoldType ) 
		prone.AddNewHoldTypeAnimation( holdtype, mseq, iseq )
	end
end )


--addons/wos-grandmaster-einf/lua/autorun/wos_rb655_hookcleaner.lua:

--Thank you based robotboy

hook.Add( "InitPostEntity", "wOS.ALCS.UnfuckRubat", function()
	hook.Remove( "PlayerBindPress", "rb655_sabers_force" )
	hook.Remove("EntityTakeDamage", "rb655_lightsaber_kill_snd" )
	hook.Remove( "PlayerDeath", "rb655_lightsaber_kill_snd_ply" )
	hook.Remove( "OnNPCKilled", "rb655_lightsaber_kill_snd_npc" )
	hook.Remove("PostPlayerDraw", "rb655_lightsaber")
	hook.Remove( "Think", "rb655_lightsaber_ugly_fixes")
	hook.Remove( "GetFallDamage", "rb655_lightsaber_no_fall_damage")
	hook.Remove( "CreateMove", "rb655_lightsaber_no_fall_damage" )
	hook.Remove( "EntityTakeDamage", "rb655_sabers_armor" )
	hook.Remove( "PlayerSpawnedNPC", "rb655_lightsaber_npc_sync" )
	hook.Remove( "PlayerSpawnedSWEP", "rb655_lightsaber_swep_sync")
	hook.Remove( "CalcView", "111!!!_rb655_lightsaber_3rdperson" )
	hook.Remove( "PlayerBindPress", "rb655_sabers_force" )
	function rb655_IsLightsaber() return false end
end )

function rb655_IsLightsaber() return false end
--lua/autorun/client/abortion_is_murder.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include( "advdupe2/file_browser.lua" )
include( "advdupe2/sh_codec.lua" )
include( "advdupe2/cl_file.lua" )
include( "advdupe2/cl_ghost.lua" )

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

net.Receive("AdvDupe2Notify", function()
	AdvDupe2.Notify(net.ReadString(), net.ReadUInt(8), net.ReadFloat())
end)

--lua/advdupe2/sh_codec_legacy.lua:
--[[
	Title: Adv. Dupe 2 Codec Legacy Support

	Desc: Facilitates opening of dupes from AD1 and earlier AD2 versions.

	Author: emspike

	Version: 2.0
]]

local pairs = pairs
local type = type
local tonumber = tonumber
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local AD2FF = "AD2F%s\n%s\n%s"

local decode_types_v1, decode_types_v2
local tables = 0
local str,pos
local a,b,c,m,n,w,tblref

local function read_v2()
	local t = byte(str, pos+1)
	if t then
		local dt = decode_types_v2[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v2 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t = {}
		tables[w] = t
		
		while true do
			if byte(str, pos+1) == 1 then
				pos = pos + 1
				return t
			else
				t[read_v2()] = read_v2()
			end
		end
	end,
	[3	] = function() -- array
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t, i = {}, 1
		
		tables[w] = t
		
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v2()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str, "\1", pos)
		if m then
			a = tonumber(sub(str, pos+1, m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str, ".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str, "^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end,
	[10	] = function() -- Table Reference
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		tblref = tables[w]
		
		if tblref then
			return tblref
		else
			error(format("table identifier %s points to nil\n", w))
		end
		
	end
}



local function read_v1()
	local t = byte(str,pos+1)
	if t then
		local dt = decode_types_v1[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v1 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		local t = {}
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[read_v1()] = read_v1()
			end
		end
	end,
	[3	] = function() -- array
		local t, i = {}, 1
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v1()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str,"\1",pos)
		if m then
			a = tonumber(sub(str,pos+1,m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end
}

local function deserialize_v1(data)
	str = data
	pos = 0
	tables = {}
	return read_v1()
end

local function deserialize_v2(data)
	str = data
	pos = 0
	tables = {}
	return read_v2()
end

local function lzwDecode(encoded)
	local dictionary_length = 256
	local dictionary = {}
	for i = 0, 255 do
		dictionary[i] = char(i)
	end
	
	local pos = 2
	local decompressed = {}
	local decompressed_length = 1
	
	local index = byte(encoded)
	local word = dictionary[index]
	
	decompressed[decompressed_length] = dictionary[index]
	
	local entry
	local encoded_length = #encoded
	local firstbyte --of an index
	while pos <= encoded_length do
		firstbyte = byte(encoded,pos)
		if firstbyte > 252 then --now we know it's a length indicator for a multibyte index
			index = 0
			firstbyte = 256 - firstbyte
			
			--[[if pos+firstbyte > encoded_length then	--will test for performance impact
				error("expected index got EOF")
			end]]
			
			for i = pos+firstbyte, pos+1, -1 do
				index = bit.bor(bit.lshift(index, 8), byte(encoded,i))
			end
			pos = pos + firstbyte + 1
		else
			index = firstbyte
			pos = pos + 1
		end
		entry = dictionary[index] or (word..sub(word,1,1))
		decompressed_length = decompressed_length + 1
		decompressed[decompressed_length] = entry
		dictionary[dictionary_length] = word..sub(entry,1,1)
		dictionary_length = dictionary_length + 1
		word = entry
	end
	return concat(decompressed)
end

--http://en.wikipedia.org/wiki/Huffman_coding#Decompression

local invcodes = {[2]={[0]="\254"},[5]={[22]="\1",[11]="\2"},[6]={[13]="\7",[35]="\6",[37]="\5",[58]="\3",[31]="\8",[9]="\13",[51]="\9",[55]="\10",[57]="\4",[59]="\15"},[7]={[1]="\14",[15]="\16",[87]="\31",[89]="\30",[62]="\26",[17]="\27",[97]="\19",[19]="\43",[10]="\12",[39]="\33",[41]="\24",[82]="\40",[3]="\32",[46]="\41",[47]="\38",[94]="\25",[65]="\23",[50]="\39",[26]="\11",[7]="\28",[33]="\18",[61]="\17",[25]="\42"},[8]={[111]="\101",[162]="\29",[2]="\34",[133]="\21",[142]="\36",[5]="\20",[21]="\37",[170]="\44",[130]="\22",[66]="\35"},[9]={[241]="\121",[361]="\104",[365]="\184",[125]="\227",[373]="\198",[253]="\117",[381]="\57",[270]="\49",[413]="\80",[290]="\47",[294]="\115",[38]="\112",[429]="\74",[433]="\0",[437]="\48",[158]="\183",[453]="\107",[166]="\111",[469]="\182",[477]="\241",[45]="\86",[489]="\69",[366]="\100",[497]="\61",[509]="\76",[49]="\53",[390]="\78",[279]="\196",[283]="\70",[414]="\98",[53]="\55",[422]="\109",[233]="\79",[349]="\89",[369]="\52",[14]="\105",[238]="\56",[319]="\162",[323]="\83",[327]="\63",[458]="\65",[335]="\231",[339]="\225",[337]="\114",[347]="\193",[493]="\139",[23]="\209",[359]="\250",[490]="\68",[42]="\54",[63]="\91",[286]="\97",[254]="\50",[510]="\108",[109]="\73",[67]="\103",[255]="\122",[69]="\170",[70]="\110",[407]="\176",[411]="\119",[110]="\120",[83]="\146",[149]="\163",[151]="\224",[85]="\51",[155]="\177",[79]="\251",[27]="\118",[447]="\159",[451]="\228",[455]="\175",[383]="\174",[463]="\243",[467]="\157",[173]="\210",[475]="\167",[177]="\84",[90]="\45",[487]="\206",[93]="\226",[495]="\245",[207]="\64",[127]="\147",[191]="\155",[511]="\153",[195]="\208",[197]="\85",[199]="\178",[181]="\82",[102]="\116",[103]="\71",[285]="\144",[105]="\102",[211]="\199",[213]="\123",[301]="\66",[305]="\46",[219]="\137",[81]="\67",[91]="\88",[157]="\130",[325]="\95",[29]="\58",[231]="\201",[117]="\99",[341]="\222",[237]="\77",[239]="\211",[71]="\223"},[10]={[710]="\149",[245]="\60",[742]="\172",[774]="\81",[134]="\151",[917]="\145",[274]="\216",[405]="\242",[146]="\194",[838]="\246",[298]="\248",[870]="\189",[1013]="\150",[894]="\190",[326]="\244",[330]="\166",[334]="\217",[465]="\179",[346]="\59",[354]="\180",[966]="\212",[974]="\143",[370]="\148",[998]="\154",[625]="\138",[382]="\161",[194]="\141",[198]="\126",[402]="\96",[206]="\185",[586]="\129",[721]="\187",[610]="\135",[618]="\181",[626]="\72",[226]="\62",[454]="\127",[658]="\113",[462]="\164",[234]="\214",[474]="\140",[242]="\106",[714]="\188",[730]="\87",[498]="\237",[746]="\125",[754]="\229",[786]="\128",[202]="\93",[18]="\255",[810]="\173",[846]="\131",[74]="\192",[842]="\142",[977]="\252",[858]="\235",[78]="\134",[874]="\234",[882]="\90",[646]="\92",[1006]="\160",[126]="\165",[914]="\221",[718]="\94",[738]="\238",[638]="\197",[482]="\230",[34]="\220",[962]="\133",[6]="\213",[706]="\219",[986]="\171",[994]="\233",[866]="\200",[1010]="\247",[98]="\169",[518]="\236",[494]="\207",[230]="\205",[542]="\191",[501]="\202",[530]="\203",[450]="\204",[209]="\158",[106]="\186",[590]="\136",[218]="\232",[733]="\124",[309]="\168",[221]="\152",[757]="\240",[113]="\215",[114]="\156",[362]="\239",[486]="\132",[358]="\249",[262]="\75",[30]="\218",[821]="\195",[546]="\253"}}

local function huffmanDecode(encoded)
	
	local h1,h2,h3 = byte(encoded, 1, 3)
	
	if (not h3) or (#encoded < 4) then
		error("invalid input")
	end
	
	local original_length = bit.bor(bit.lshift(h3,16), bit.lshift(h2,8), h1)
	local encoded_length = #encoded+1
	local decoded = {}
	local decoded_length = 0
	local buffer = 0
	local buffer_length = 0
	local code
	local code_len = 2
	local temp
	local pos = 4
	
	while decoded_length < original_length do
		if code_len <= buffer_length then
			temp = invcodes[code_len]
			code = bit.band(buffer, bit.lshift(1, code_len)-1)
			if temp and temp[code] then --most of the time temp is nil
				decoded_length = decoded_length + 1
				decoded[decoded_length] = temp[code]
				buffer = bit.rshift(buffer, code_len)
				buffer_length = buffer_length - code_len
				code_len = 2
			else
				code_len = code_len + 1
				if code_len > 10 then
					error("malformed code")
				end
			end
		else
			buffer = bit.bor(buffer, bit.lshift(byte(encoded, pos), buffer_length))
			buffer_length = buffer_length + 8
			pos = pos + 1
			if pos > encoded_length then
				error("malformed code")
			end
		end
	end
	
	return concat(decoded)
end

local function invEscapeSub(str)
	local escseq,body = match(str,"^(.-)\n(.-)$")
	
	if not escseq then error("invalid input") end
	
	return gsub(body,escseq,"\26")
end

local dictionary
local subtables

local function deserializeChunk(chunk)
	
	local ctype,val = byte(chunk),sub(chunk,3)
	
	if     ctype == 89 then return dictionary[ val ]
	elseif ctype == 86 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Vector( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 65 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Angle( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 84 then 
		local t = {}
		local tv = subtables[val]
		if not tv then
			tv = {}
			subtables[ val ] = tv
		end
		tv[#tv+1] = t
		return t
	elseif ctype == 78 then return tonumber(val)
	elseif ctype == 83 then return gsub(sub(val,2,-2),"",";")
	elseif ctype == 66 then return val == "t"
	elseif ctype == 80 then return 1
	end
	
	error(format("AD1 deserialization failed: invalid chunk (%u:%s)",ctype,val))
	
end

local function deserializeAD1(dupestring)
	
	dupestring = dupestring:Replace("\r\n", "\n")
	local header, extraHeader, dupeBlock, dictBlock = dupestring:match("%[Info%]\n(.+)\n%[More Information%]\n(.+)\n%[Save%]\n(.+)\n%[Dict%]\n(.+)")
	
	if not header then
		error("unknown duplication format")
	end
	
	local info = {}
	for k,v in header:gmatch("([^\n:]+):([^\n]+)") do
		info[k] = v
	end
		
	local moreinfo = {}
	for k,v in extraHeader:gmatch("([^\n:]+):([^\n]+)") do
		moreinfo[k] = v
	end
	
	dictionary = {}
	for k,v in dictBlock:gmatch("(.-):\"(.-)\"\n") do
		dictionary[k] = v
	end

	local dupe = {}
	for key,block in dupeBlock:gmatch("([^\n:]+):([^\n]+)") do
		
		local tables = {}
		subtables = {}
		local head
		
		for id,chunk in block:gmatch('(%w+){(.-)}') do
			
			--check if this table is the trunk
			if byte(id) == 72 then
				id = sub(id,2)
				head = id
			end
			
			tables[id] = {}
			
			for kv in gmatch(chunk,'[^;]+') do
				
				local k,v = match(kv,'(.-)=(.+)')
				
				if k then
					k = deserializeChunk( k )
					v = deserializeChunk( v )
					
					tables[id][k] = v
				else
					v = deserializeChunk( kv )
					local tid = tables[id]
					tid[#tid+1]=v
				end
				
			end
		end
		
		--Restore table references
		for id,tbls in pairs( subtables ) do
			for _,tbl in pairs( tbls ) do
				if not tables[id] then error("attempt to reference a nonexistent table") end
				for k,v in pairs(tables[id]) do
					tbl[k] = v
				end
			end
		end
		
		dupe[key] = tables[ head ]
		
	end
	
	return dupe, info, moreinfo
	
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("attempt to read AD2 file with malformed info block error 1")
	end
	local info = {}
	local ss = str:sub(1,last-1)
	for k,v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end
	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)")
		else
			error("attempt to read AD2 file with malformed info block error 2")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[2] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v2(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[1] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v1(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[0] = deserializeAD1

AdvDupe2.LegacyDecoders = versions
--addons/prop_list/lua/autorun/client/behaelter.lua:
hook.Add("PopulatePropMenu", "Behaelter", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Behaelter"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_barrel_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_barrel_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_cover.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_cover.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif1_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif2a_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif2c_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/crate_yavin01_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/fueltank_scarif1_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_canister_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_crate_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_crate_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/3rd_cargo_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_box_1_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_box_2_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_box_2_open1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_box_2_open2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/small_cargo_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/st_cargo_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/st_cargo_7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/dumpster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/garbagecan.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/hvywepcrate01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/hvywepcrate02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/watercooler.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/container03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/crate01_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/crate01_m.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/crate01_s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/crate_explosive01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/cratenor01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/crateweak01_s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/fooddispenser02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/tank02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/tank03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/cargo_container_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/cart01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/crate_xlarge_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/crate_xlarge_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/crate_xlarge_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/crateshipping01_c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/mobile_med_unit_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/cratecargo01_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/cratecargo01_xl.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/crateshipping01_a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/box_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/dm_container.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/dm_container_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/light_spotlight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/light_spotlight_rigged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/repairkit.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/sbd_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/bd_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/cis_command.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/refinery.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/crate_tor_v1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/crate_tor_v2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/crate_tor_v3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/crate_tor_v4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/generator_pipe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/tank01.mdl"
	} )

	-- Gargantuan Prop Pack

	table.insert( contents, {
		type = "model",
		model = "models/props/starwars_crate_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars_crate_medium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars_crate_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/alliance/alliance_bin_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/alliance/alliance_bin_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/alliance/alliance_box_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/alliance/alliance_box_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/camp/camp_adrenal_vat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/gormak_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/construction/construction_storage_compactor_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/construction/construction_dumpster_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_04_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_04_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05_top.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_cylinder_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_open_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_open_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_shipping02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_shipping02_destroyed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_neu_pickup_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_neu_pickup_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_rectangle_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_semicircle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_stack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_two.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_open02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_storage_skid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_tank_toxic_damaged_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_tank_zakuul_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_toxicwaste_barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_treasure_chest_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_treasure_chest_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_01_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/mand_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/pvp_loot_container_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_left.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_right.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_top.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/creatures/creature_rancor_egg_incubator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/debris/debris_droid_parts_astromech_body.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/factory/factory_cauldron.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/factory/factory_cauldron_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_storage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_toolstand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_cut_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_cut_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_wall_greeble.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/cover_gormak_barricade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/construction/construction_storage_compactor_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/construction/construction_dumpster_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_box_crate_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_04_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_04_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05_top.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_05_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_cylinder_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_open_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_crystal_open_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_shipping02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_crate_shipping02_destroyed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_neu_pickup_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_rectangle_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_semicircle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_stack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_small_container_pipes_two.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate02_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_broken_no_debris.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_square_crate_open02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_storage_skid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_tank_toxic_damaged_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_tank_zakuul_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_toxicwaste_barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_treasure_chest_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/con_treasure_chest_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_01_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/crate_weapon_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/mand_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/pvp_loot_container_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_left.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_right.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_crate_top.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/crates/kat_crate_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/creatures/creature_rancor_egg_incubator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/debris/debris_droid_parts_astromech_body.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/factory/factory_cauldron.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/factory/factory_cauldron_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_storage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_toolstand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_02_x12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_broken.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_cut_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_cut_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_crate_open.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_shelving_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_wall_greeble.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/cover_gormak_barricade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/gormak_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/de_nuke/storagetank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/gb4/mortar_cache.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/gb4/mortar_tube.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/models/thedoctor/photon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/antimatter_canister.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/darkmatter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/davy_propellant.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/en.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/ex.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/gadget.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/tritium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/vx.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/icbm/capsule.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/mutagenbomb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/radbarrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/redmatter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cw_furnitures12/cw_furnitures12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cw_furnitures13/cw_furnitures13.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/large_boxes/box_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/large_boxes/box_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/large_boxes/box_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/medium_boxes/box_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/medium_boxes/box_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/medium_boxes/box_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/small_boxes/box_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/small_boxes/box_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dev/small_boxes/box_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cw_furnitures11/cw_furnitures11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_container_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/container_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/container_rigged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif1_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif2a_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif2b_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/barrel_scarif2c_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/crate_yavin01_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/fueltank_scarif1_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/fueltank_scarif1_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_canister_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_crate_phys.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/kyber_crate_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/ammo_pickup.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/weapons/repairkit.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/naboo_cargo_box_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/st_cargo_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/st_cargo_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/bandit/tiny_cargo_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/blue_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/canister.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/medium_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/tough_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/tower_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/metal_capsule.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/metal_container01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/metal_container02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/metal_crate01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/metal_support01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/rogue_one/kyber_crate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_barrel_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_barrel_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_cover.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_cover.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/crate01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/crate02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/crate03.mdl"
	} )
	
	spawnmenu.AddPropCategory( "12", "Behaelter", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/beleuchtung.lua:
hook.Add("PopulatePropMenu", "Beleuchtung", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Beleuchtung"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_hanging_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_light_head.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_wall_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_lamp.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_lamp_dmg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_lamp_dmg_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_lamp_off.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_lamp_tall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_pole.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_street_sign_pole.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_streetlamp_lamp.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_streetlamp_post.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_wall_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/streetlamp_lamp_solo.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/factory/factory_incinerator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_chandelier.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_hot_tub_lamp_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_celing_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_space_bridge_ceil_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_ceiling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_inset.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_outsidewall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_security.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_shop.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/light_shop_on.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/gale/swlight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_lampa_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stolb-lampa.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_mainhanger_ceilinglight_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/coruscant_sign_1/coruscant_sign_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_holo_banner_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_holo_banner_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_holo_banner_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_13.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_14.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_16.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_18.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_19.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_20.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_21.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_22.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_23.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_01_24.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_13.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_14.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_16.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_18.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_19.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_02_20.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_03_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_03_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_03_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_03_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_05_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_05_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_05_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_13.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_14.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_16.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_17.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_18.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_19.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_20.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_21.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/nar_shadda/nar_signage_red_martini.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/effects/vol_light128x128.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/effects/vol_light128x256.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/effects/vol_light64x128.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/lamp_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/lamp_largefix.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/lamp_small_white.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_doorlight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/ceilinglight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/floorlight.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/imp_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/palp_lamp.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/lamp_ceiling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/lamp_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/lamp_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/oil_lamp.mdl"
	} )

	spawnmenu.AddPropCategory( "24", "Beleuchtung", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/betten_und_stuehle.lua:
hook.Add("PopulatePropMenu", "Betten und Stuehle", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Betten und Stuehle"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/crew_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/crew_bedb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/bedcot01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/bedbunk01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/chairtorture01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/chairreclining03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/chairoffice01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/recliningchair02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/couch01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/couch02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/couch03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/chair_bar_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/equipmentlab09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/desk_officer.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/bed_bunk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_armchair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_chaira.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_chaira.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_chairb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/palp_chair_full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_chair01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/meditation_seat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/chairs/chair01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/chairs/couch01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_bar_stool.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_furn_bench_metal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_furn_bench_metal01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_furn_bench_metal_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/chair_office.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/chairs_airport.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/mace_windu_council_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/plo_koon_council_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/yoda_council_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/d_sidious_chair/d_sidious_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/barrack_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/bench.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/meditation_seat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/turbolaser_seat_dummy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_armchair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_chaira.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/imp_chairb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/seats/palp_chair_full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_chair01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_chair01_cis.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_chair01_holo.mdl"
	} )
	
	spawnmenu.AddPropCategory( "11", "Betten und Stuehle", contents, "icon16/brick.png" )
end )
--lua/autorun/client/cl_paynus.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--lua/autorun/client/cl_yeeted.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--lua/autorun/client/communism_is_evil.lua:
 
-- This file is part of Adware Blocker.
--
--addons/lvs_base/lua/autorun/client/lvs_vehicle_tab.lua:

hook.Add( "PopulateVehicles", "!!!add_lvs_to_vehicles", function( pnlContent, tree, node )
	local CategoryNameTranslate = {}
	local Categorised = {}
	local SubCategorised = {}

	local SpawnableEntities = table.Copy( list.Get( "SpawnableEntities" ) )
	local Variants = {
		[1] = "[LVS] - ",
		[2] = "[LVS] -",
		[3] = "[LVS]- ",
		[4] = "[LVS]-",
		[5] = "[LVS] ",
	}

	for _, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not v.t.ClassName or not v.t.VehicleCategory then continue end

		if not isstring( v.t.ClassName ) or v.t.ClassName == "" or not SpawnableEntities[ v.t.ClassName ] then continue end

		SpawnableEntities[ v.t.ClassName ].Category = "[LVS] - "..v.t.VehicleCategory

		if not v.t.VehicleSubCategory then continue end

		SpawnableEntities[ v.t.ClassName ].SubCategory = v.t.VehicleSubCategory
	end

	if SpawnableEntities then
		for k, v in pairs( SpawnableEntities ) do

			local Category = v.Category

			if not isstring( Category ) then continue end

			if not Category:StartWith( "[LVS]" ) and not v.LVS then continue end

			v.SpawnName = k

			for _, start in pairs( Variants ) do
				if Category:StartWith( start ) then
					local NewName = string.Replace(Category, start, "")
					CategoryNameTranslate[ NewName ] = Category
					Category = NewName

					break
				end
			end

			if v.SubCategory then
				SubCategorised[ Category ] = SubCategorised[ Category ] or {}
				SubCategorised[ Category ][ v.SubCategory ] = SubCategorised[ Category ][ v.SubCategory ] or {}

				table.insert( SubCategorised[ Category ][ v.SubCategory ], v )
			end

			Categorised[ Category ] = Categorised[ Category ] or {}

			table.insert( Categorised[ Category ], v )
		end
	end

	local lvsNode = tree:AddNode( "[LVS]", "icon16/lvs.png" )

	if Categorised["[LVS]"] then
		local v = Categorised["[LVS]"]

		lvsNode.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end

		lvsNode.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end
	end

	local IconList = list.Get( "ContentCategoryIcons" )

	for CategoryName, v in SortedPairs( Categorised ) do
		if CategoryName:StartWith( "[LVS]" ) then continue end

		local Icon = "icon16/lvs_noicon.png"

		if IconList and IconList[ CategoryNameTranslate[ CategoryName ] ] then
			Icon = IconList[ CategoryNameTranslate[ CategoryName ] ]
		end

		local node = lvsNode:AddNode( CategoryName, Icon )

		node.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				if ent.SubCategory then
					continue
				end

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end
		node.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end

		local SubCat = SubCategorised[ CategoryName ]

		if not SubCat then continue end

		for SubName, data in SortedPairs( SubCat ) do

			local SubIcon = "icon16/lvs_noicon.png"

			if IconList then
				if IconList[ "[LVS] - "..CategoryName.." - "..SubName ] then
					SubIcon = IconList[ "[LVS] - "..CategoryName.." - "..SubName ]
				else
					if IconList[ "[LVS] - "..SubName ] then
						SubIcon = IconList[ "[LVS] - "..SubName ]
					end
				end
			end

			local subnode = node:AddNode( SubName, SubIcon )

			subnode.DoPopulate = function( self )
				if self.PropPanel then return end

				self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
				self.PropPanel:SetVisible( false )
				self.PropPanel:SetTriggerSpawnlistChange( false )

				for k, ent in SortedPairsByMemberValue( data, "PrintName" ) do
					spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.SpawnName,
						material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
						admin		= ent.AdminOnly
					} )
				end
			end
			subnode.DoClick = function( self )
				self:DoPopulate()
				pnlContent:SwitchPanel( self.PropPanel )
			end
		end
	end

	-- User Stuff
	hook.Run( "LVS.PopulateVehicles", lvsNode, pnlContent, tree )

	-- CONTROLS
	local node = lvsNode:AddNode( "Controls", "icon16/keyboard.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientControls()
	end

	-- CLIENT SETTINGS
	local node = lvsNode:AddNode( "Client Settings", "icon16/wrench.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientSettings()
	end

	-- SERVER SETTINGS
	local node = lvsNode:AddNode( "Server Settings", "icon16/wrench_orange.png" )
	node.DoClick = function( self )
		if LocalPlayer():IsSuperAdmin() then
			LVS:OpenMenu()
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
end )

list.Set( "ContentCategoryIcons", "[LVS]", "icon16/lvs.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Artillery", "icon16/lvs_artillery.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Cars", "icon16/lvs_cars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Armored", "icon16/lvs_armor.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Civilian", "icon16/lvs_civilian.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Military", "icon16/lvs_military.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Pack", "icon16/lvs_cars_pack.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Helicopters", "icon16/lvs_helicopters.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Combine", "icon16/lvs_combine.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Resistance", "icon16/lvs_resistance.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Planes", "icon16/lvs_planes.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Bombers", "icon16/lvs_bomb.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Fighters", "icon16/lvs_fighter.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Civilian", "icon16/lvs_civilian.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Tanks", "icon16/lvs_tanks.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Light", "icon16/lvs_light.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Medium", "icon16/lvs_medium.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Heavy", "icon16/lvs_heavy.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - RP", "icon16/lvs_rp.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Star Wars", "icon16/lvs_starwars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Gunships", "icon16/lvs_sw_gunship.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Hover Tanks", "icon16/lvs_sw_hover.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Walkers", "icon16/lvs_sw_walker.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Starfighters", "icon16/lvs_sw_starfighter.png" )

--addons/prop_list/lua/autorun/client/natur.lua:
hook.Add("PopulatePropMenu", "Natur", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Natur"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/arid_valley_v2/arid_rock_01_test_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/arid_valley_v2/arid_rock_01_test_01_big.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/arid_valley_v2/arid_rock_01_test_01_bigger.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/arid_valley_v2/arid_rock_01_test_01_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree_small1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree_small2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree_small3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree_small4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lanix/trees/tree_small5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_gib1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_gib3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cs_militia/fern01lg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/moroes/pine_tree_med.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/pretmodels/halloween_pumpkinroots.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_biotec/lobby_plants.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_unique/firepit_campground.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster02c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rock_coast02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rock_coast02b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/icefuse_networks/ep2/icefuse_tree_dead01/icefuse_tree_dead03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/icefuse_networks/ep2/icefuse_tree_pine04/icefuse_tree_pine05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/icefuse_networks/icefuse_elm_tree/icefuse_elm_tree03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/icefuse_networks/icefuse_tree_pine_dark/icefuse_tree_pine_dark02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/icefuse_networks/icefuse_tree_pine_dark/icefuse_tree_pine_dark07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/trees/good_trees/jn_falltree_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ac_appletree01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ac_appletree02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_apple_tree_single001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree_cluster1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree_lg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree_med.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_ash_tree_small001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_dead_trunk001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_dead_trunk002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_dead_trunk003.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_dead_trunk004.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_domestic_hedge128.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_domestic_hedge128_mid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_domestic_hedge256.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_domestic_hedge256_mid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_domestic_shrub001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_fern_single001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_fern_single002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_1024x512_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_128x64_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_256x256_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_256x256_001_flowers.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_256x512_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_256x64_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_512x1024_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_512x512_001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_grass_512x512_001_flowers.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hawthorn_512_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hawthorn_sm_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hay_stubble_256x512.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_skybox_close.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_skybox_far.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_skybox_mid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_static_sky_16.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_1024_static_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_2048_skybox_far.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_2048_skybox_near.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_2048_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_2048_tall_mix.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_2048_tall_mix_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_512_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_hedge_512_static_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_large_pine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_medium_pine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_medium_pine_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_skybox_bill_forest.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_small_pine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_super_large_pine002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_super_pine001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_wheat_field_512x128.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_wheat_field_512x512.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ah_wheat_field_skybox_square.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/appleorchard01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/appleorchard02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/appleorchard03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/appleorchard_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/appletree01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash02_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/ash03_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/bramble001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/cabbage_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/haytuffs01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/haytuffs01_high.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/haytuffs01_mix.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/haytuffs01_short.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/haytuffs02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_large-bushy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_large-endpiece.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_large-full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_large-thick.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_medium-bushy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_medium-bushy_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_medium-endpiece.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_medium-full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_medium-thick.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_small-bushy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_small-endpiece.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_small-full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_small-thick.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow01_small-thick.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_large-skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium-skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_ash01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_ash01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_exlong_ash01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_exlong_poplar01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_exlong_poplar01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_exlong_poplar01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_exlong_poplar01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long-skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long_poplar01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long_poplar01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long_poplar01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_medium_long_poplar01a_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_small-skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow02_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/hedgerow_08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/low_bush01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/lowgrass01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/lowgrass02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/lowgrass03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/poplar01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/poplar01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/poplar02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/poplar02_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_corn1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_detailprop1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_detailprop2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_detailprop3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_m.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_m_exlong.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_m_exlong_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_m_long.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_m_long_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge4_s.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge_trees1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge_trees1_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge_trees2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge_trees3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedge_trees3_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow1_long.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow1_long_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow3_long.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow_bush1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow_bush2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_hedgerow_bush3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_maple1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_plant7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_shapedhedge1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_shapedhedge1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_shrub1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_shrub2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_smallbush1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge1_exlong.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge1_exlong_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge1_short.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge1_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/r_wildhedge2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_appletree01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_ash01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_bush04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_hedgerow01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_mediumbush01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_rock_group01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_rock_group02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_tree01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rd_willow.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/rnl_ash01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/shapedhedges_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/shrub_01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/small-tree01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/small-tree01_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/stump01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/stump02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_cliff_01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_cliff_02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_deciduous_01a-lod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_deciduous_01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_deciduous_02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_deciduous_03a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/tree_deciduous_03b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/waterlily01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_foliage/grasses/shrub_m_bg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff01c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff01f.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff01j.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff05a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff05b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff07e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster02b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster03a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster03b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/rockcliff_cluster03c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/end_prop_foliage1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/end_prop_foliage2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/end_prop_foliage3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/end_prop_foliage4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/fel_foliage1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/fel_foliage2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/fel_foliage3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/fel_foliage4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/loglarge_all_long.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/treelarge01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/treelarge03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/foliage/treemedium01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/opee_sea_killer/opee_sea_killer.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/lothal/tallgrass_group1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/lothal/tallgrass_group2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/lothal/tallgrass_group3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_1_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_2_skybox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/destroyed_tree_3_skybox.mdl"
	} )

	spawnmenu.AddPropCategory( "18", "Natur", contents, "icon16/brick.png" )
end )
--addons/wos-alcs-custom/lua/wos/advswl/config/skills/sh_skillwos.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.Skills = wOS.ALCS.Config.Skills or {}

/* 
	What skill tree schema do you want to use?
	Options:
		WOS_ALCS.SKILLMENU.NEWAGE		--The UI introduced by the Dark Ascension update, 3D and with all the new features
		WOS_ALCS.SKILLMENU.CLASSIC	--The UI everyone has come to know and love, and in 2D. May not work with newer features
*/
wOS.ALCS.Config.Skills.MenuSchema = WOS_ALCS.SKILLMENU.NEWAGE

--How much experience is required for the first level?
--This is an assumption based on my default quadratic increase, but it may have no purpose to you.
wOS.ALCS.Config.Skills.MinimumExperience = 200

--Create your own leveling formula with this. The default property is a quadratic increase
--( level^2 )*wOS.ALCS.Config.Skills.MinimumExperience*0.5 + level*wOS.ALCS.Config.Skills.MinimumExperience + wOS.ALCS.Config.Skills.MinimumExperience
--This amounts to the ( ax^2 + bx + c ) format of increase
--You can use this to create set amounts per level by returning a table
--If you need help setting this up you'll probably want to ask, but it's just simple math so there's probably tutorials everywhere
wOS.ALCS.Config.Skills.XPScaleFormula = function( level )
	local required_experience = ( level^2 ) * wOS.ALCS.Config.Skills.MinimumExperience * 0.5 + level * wOS.ALCS.Config.Skills.MinimumExperience + wOS.ALCS.Config.Skills.MinimumExperience

	return required_experience
end

--What is the max level for the Skill Leveling? Set this to FALSE if you want it to go infinitely
wOS.ALCS.Config.Skills.SkillMaxLevel = 200

--Should we be able to see the Combat Level and XP on the HUD?
wOS.ALCS.Config.Skills.MountLevelToHUD = false

--Should we be able to see the combat level of other players above their head?
wOS.ALCS.Config.Skills.MountLevelToPlayer = false
--addons/wos-alcs-custom/lua/wos/advswl/config/trade/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.GTN = wOS.ALCS.Config.GTN or {}

/*
	What amount of money should we take from the poster when they make a listing?
	If you want no tax, set it to 0!
*/
wOS.ALCS.Config.GTN.PostingTax = 1500

/*
	What amount of money should we take from the poster when they want to remove a listing?
	If you want no tax, set it to 0!
*/
wOS.ALCS.Config.GTN.CancelTax = 500

/*
	How many days should a listing be made available for bidding?
	CAN HAVE DECIMALS! EX: 6.5 ( Six and a half days )
	CAN EVEN BE A DECIMAL! EX: 0.5 ( half a day )
*/
wOS.ALCS.Config.GTN.PostingDays = 3

/*
	What is the minimum amount of credits that can be placed as the starting bid when making an auction?
	This will also be the minimum for BUY IT NOW prices
*/
wOS.ALCS.Config.GTN.MinimumStart = 200

/*
	What is the minimum amount of credits that can be placed as the starting bid when making an auction?
*/
wOS.ALCS.Config.GTN.MaximumStart = 500

/*
	What is the maximum amount of credits that can be placed as the BUY IT NOW price when making an auction?
*/
wOS.ALCS.Config.GTN.MaximumBuyNow = 250000
--addons/wos-grandmaster-einf/lua/wos/advswl/robot-boy/cl_rb655_lightsaber.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































function rb655_DrawHit_wos( pos, dir )
	local effectdata = EffectData()
	effectdata:SetOrigin( pos )
	effectdata:SetNormal( dir )
	util.Effect( "StunstickImpact", effectdata, true, true )

	--util.Decal( "LSScorch", pos + dir, pos - dir )
	util.Decal( "FadingScorch", pos + dir, pos - dir )
end

-- --------------------------------------------------------- Lightsaber blade rendering --------------------------------------------------------- --

local HardLaserTrail = Material( "lightsaber/hard_light_trail" )
local HardLaserTrailInner = Material( "lightsaber/hard_light_trail_inner" )

local HardLaserTrailEnd = Material( "lightsaber/hard_light_trail_end" )
local HardLaserTrailEndInner = Material( "lightsaber/hard_light_trail_end_inner" )

local CorruptedLaser = Material( "effects/stunstick" )
local CorruptedLaserInner = Material( "models/effects/splodearc_sheet" )

--[[local HardLaserTrailEnd = Material( "lightsaber/hard_light_trail" )
local HardLaserTrailEndInner = Material( "lightsaber/hard_light_trail_inner" )]]

local gOldBladePositions_wos = {}
local gOldBladePositions_dual_wos = {}
local gTrailLength = 3

function rb655_RenderBlade_wos( pos, dir, len, maxlen, width, color, black_inner, inner_color, eid, underwater, quillon, bladeNum, settings, dual )
	--render.DrawLine( pos + dir * len*-2, pos + dir * len*2, color, true )
	settings = settings or {}
	quillon = quillon or false
	bladeNum = bladeNum or 1

	if ( quillon ) then
		len = rb655_CalculateQuillonLength_wos( len, maxlen )
		maxlen = rb655_SaberClean_wos( maxlen )
	end

	if ( len <= 0 ) then rb655_SaberClean_wos( eid, bladeNum ) return end

	if ( underwater ) then
		local ed = EffectData()
		ed:SetOrigin( pos )
		ed:SetNormal( dir )
		ed:SetRadius( len )
		util.Effect( "rb655_saber_underwater", ed )
	end
	
	settings.Blade = settings.Blade or "Standard"
	local data = wOS.ALCS.LightsaberBase.Blades[ settings.Blade ]
	
	if settings.Rainbow then
		color = HSVToColor( CurTime() % 6 * 60, 1, 1 )
	end
	
	inner_color = inner_color or color_white
	if ( black_inner ) then inner_color = Color( 0, 0, 0 ) end
	
	if settings.RainbowInner then
		inner_color = HSVToColor( CurTime() % 7.5 * 60, 1, 1 )
	end
	
	if quillon and data.QuillonParticle then
		local ed = EffectData()
		ed:SetOrigin( pos )
		ed:SetNormal( dir )
		ed:SetRadius( len )
		ed:SetAngles( Angle( color.r, color.g, color.b ) )
		util.Effect( data.QuillonParticle, ed )
	else
		if data.UseParticle then
			local ed = EffectData()
			ed:SetOrigin( pos )
			ed:SetNormal( dir )
			ed:SetRadius( len )
			ed:SetAngles( Angle( color.r, color.g, color.b ) )
			util.Effect( data.UseParticle, ed )	
		end
	end

    if quillon and #data.QuillonEnvelopeMaterial > 0 then
        render.SetMaterial( data.QuillonLaser )
        render.DrawBeam( pos, pos + dir * len, width * 2, 1, 0.01, color )
    else
        if #data.EnvelopeMaterial > 0 then
            render.SetMaterial( data.Laser )
            render.DrawBeam( pos, pos + dir * len, width * 2, 1, 0.01, color )
        end
    end
    
    if quillon and #data.QuillonInnerMaterial > 0 then
        render.SetMaterial( data.QuillonLaserInner )
        render.DrawBeam( pos, pos + dir * len, width, 1, 0.01, inner_color )
    else
        if #data.InnerMaterial > 0 then
            render.SetMaterial( data.LaserInner )
            render.DrawBeam( pos, pos + dir * len, width, 1, 0.01, inner_color )
        end
    end

	if wOS.ShouldDrawLightsaberLight:GetBool() then
		if ( !quillon ) then
			local SaberLight = DynamicLight( eid + 1000 * bladeNum )
			if ( SaberLight ) then
				SaberLight.Pos = pos + dir * ( len / 2 )
				SaberLight.r = color.r
				SaberLight.g = color.g
				SaberLight.b = color.b
				SaberLight.Brightness = 4
				SaberLight.Size = 176 * ( len / maxlen )
				SaberLight.Decay = 0
				SaberLight.DieTime = CurTime() + 0.1
			end
		end
	end

	if not data.DrawTrail or settings.CraftingSaber then return end
	
	local prevB = pos
	local prevT = pos + dir * len
	
	if !dual then
	
		if ( !gOldBladePositions_wos[ eid ] ) then gOldBladePositions_wos[ eid ] = {} end
		if ( !gOldBladePositions_wos[ eid ][ bladeNum ] ) then gOldBladePositions_wos[ eid ][ bladeNum ] = {} end
		for id, prevpos in ipairs( gOldBladePositions_wos[ eid ][ bladeNum ] ) do
			local posB = prevpos.pos
			local posT = prevpos.pos + prevpos.dir * prevpos.len
			--local posB = prevB
			--local posT = prevB + prevpos.dir * prevpos.len

			if ( id == gTrailLength ) then
				HardLaserTrailEnd:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
				render.SetMaterial( HardLaserTrailEnd )
			else
				HardLaserTrail:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
				render.SetMaterial( HardLaserTrail )
			end
			render.DrawQuad( posB, prevB, prevT, posT )

			if ( id == gTrailLength ) then
				HardLaserTrailEndInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
				render.SetMaterial( HardLaserTrailEndInner )
			else
				HardLaserTrailInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
				render.SetMaterial( HardLaserTrailInner )
			end
			render.DrawQuad( posB, prevB, prevT, posT )

			prevB = prevpos.pos
			prevT = prevpos.pos + prevpos.dir * prevpos.len
			--prevT = prevB + prevpos.dir * prevpos.len
		end
	
	else
	
		if ( !gOldBladePositions_dual_wos[ eid ] ) then gOldBladePositions_dual_wos[ eid ] = {} end
		if ( !gOldBladePositions_dual_wos[ eid ][ bladeNum ] ) then gOldBladePositions_dual_wos[ eid ][ bladeNum ] = {} end
		for id, prevpos in ipairs( gOldBladePositions_dual_wos[ eid ][ bladeNum ] ) do
			local posB = prevpos.pos
			local posT = prevpos.pos + prevpos.dir * prevpos.len
			--local posB = prevB
			--local posT = prevB + prevpos.dir * prevpos.len

			if ( id == gTrailLength ) then
				HardLaserTrailEnd:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
				render.SetMaterial( HardLaserTrailEnd )
			else
				HardLaserTrail:SetVector( "$color", Vector( color.r / 255, color.g / 255, color.b / 255 ) )
				render.SetMaterial( HardLaserTrail )
			end
			render.DrawQuad( posB, prevB, prevT, posT )

			if ( id == gTrailLength ) then
				HardLaserTrailEndInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
				render.SetMaterial( HardLaserTrailEndInner )
			else
				HardLaserTrailInner:SetVector( "$color", Vector( inner_color.r / 255, inner_color.g / 255, inner_color.b / 255 ) )
				render.SetMaterial( HardLaserTrailInner )
			end
			render.DrawQuad( posB, prevB, prevT, posT )

			prevB = prevpos.pos
			prevT = prevpos.pos + prevpos.dir * prevpos.len
			--prevT = prevB + prevpos.dir * prevpos.len
		end
	
	end
	
end

function rb655_SaberClean_wos( eid, bladeNum )
	if ( !bladeNum ) then 
		gOldBladePositions_dual_wos[ eid ] = nil
		gOldBladePositions_wos[ eid ] = nil 
		return 
	end
	if ( gOldBladePositions_wos[ eid ] ) then
		gOldBladePositions_wos[ eid ][ bladeNum ] = nil
	end
	if ( gOldBladePositions_dual_wos[ eid ] ) then
		gOldBladePositions_dual_wos[ eid ][ bladeNum ] = nil
	end
end

-- Extremely ugly hack workaround :(
function rb655_ProcessBlade_wos( eid, pos, dir, len, bladeNum, dual )
	
	if !dual then
		if ( !gOldBladePositions_wos[ eid ] ) then gOldBladePositions_wos[ eid ] = {} end
		if ( !gOldBladePositions_wos[ eid ][ bladeNum ] ) then gOldBladePositions_wos[ eid ][ bladeNum ] = {} end
		local hax = gOldBladePositions_wos[ eid ][ bladeNum ]
		for i = 0, gTrailLength - 1 do
			hax[ gTrailLength - i ] = hax[ gTrailLength - i - 1 ]
			if ( gTrailLength - i == 1 ) then
				hax[ 1 ] = { dir = dir, len = len, pos = pos }
			end
		end
	else
		if ( !gOldBladePositions_dual_wos[ eid ] ) then gOldBladePositions_dual_wos[ eid ] = {} end
		if ( !gOldBladePositions_dual_wos[ eid ][ bladeNum ] ) then gOldBladePositions_dual_wos[ eid ][ bladeNum ] = {} end
		local hax = gOldBladePositions_dual_wos[ eid ][ bladeNum ]
		for i = 0, gTrailLength - 1 do
			hax[ gTrailLength - i ] = hax[ gTrailLength - i - 1 ]
			if ( gTrailLength - i == 1 ) then
				hax[ 1 ] = { dir = dir, len = len, pos = pos }
			end
		end	
	end
end

function rb655_CalculateQuillonLength_wos( length, maxLength )
	local len = maxLength/7
	local maxLen = maxLength/7
	return math.Clamp( maxLen - ( maxLength - length ), 0, len )
end

function rb655_ProcessLightsaberEntity_wos( ent )
	
	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0
	for id, t in pairs( ent:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && ent:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( bladeNum )
			rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, ent:GetBladeLength(), blades )
			bladesFound = true
		end

		if ( quillonNum && ent:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( quillonNum, true )
			rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, rb655_CalculateQuillonLength_wos( ent:GetBladeLength(), ent:GetMaxLength() ), blades )
		end
	end

	if ( !bladesFound ) then
		local pos, ang = ent:GetSaberPosAng()
		rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, ent:GetBladeLength(), 1 )
	end
	
end

function rb655_ProcessLightsaberEntity_dual_wos( ent )

	if not IsValid( ent.LeftHilt ) then return end
	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0
	for id, t in pairs( ent.LeftHilt:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && ent.LeftHilt:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( bladeNum, false, ent.LeftHilt )
			rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, ent:GetSecBladeLength(), blades, true )
			bladesFound = true
		end

		if ( quillonNum && ent.LeftHilt:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, ang = ent:GetSaberPosAng( quillonNum, true, ent.LeftHilt )
			rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, rb655_CalculateQuillonLength_wos( ent:GetSecBladeLength(), ent:GetSecMaxLength() ), blades, true )
		end
	end

	if ( !bladesFound ) then
		local pos, ang = ent:GetSaberPosAng( nil, nil, ent.LeftHilt )
		if not ent:GetAnimEnabled() then
			ang = ang*-1
			pos = pos + ang*12 - ang:Angle():Right()*0.8 - ang:Angle():Up()*1.5
		end
		rb655_ProcessBlade_wos( ent:EntIndex(), pos, ang, ent:GetSecBladeLength(), 1, true )
	end
	
end

hook.Add( "Think", "rb655_lightsaber_ugly_fixes_wOS", function()

	if not wOS.Lightsabers then return end
	if not wOS.Lightsabers.General then return end

	for class, _ in pairs( wOS.Lightsabers.General ) do
		for id, ent in pairs( ents.FindByClass( class ) ) do
			if ( !IsValid( ent:GetOwner() ) || ent:GetOwner():GetActiveWeapon() != ent || !ent.GetBladeLength || ent:GetBladeLength() <= 0 ) then continue end

			rb655_ProcessLightsaberEntity_wos( ent )
			if ent:GetDualMode() then
				rb655_ProcessLightsaberEntity_dual_wos( ent )
			end
		end
	end

	for id, ent in pairs( ents.FindByClass( "ent_lightsaber*" ) ) do
		if ( !ent.GetBladeLength || ent:GetBladeLength() <= 0 ) then continue end
		rb655_ProcessLightsaberEntity_wos( ent, ent.LeftHilt )
	end
	
end )

hook.Add( "InitPostEntity", "wOS.RemoveRobotBoyHolster!", function()
	hook.Remove( "PostPlayerDraw", "rb655_lightsaber" )
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

local w,h = ScrW(), ScrH()																																																																																																																													

surface.CreateFont( "wOS.TitleFont", {
	font = "Roboto Cn",
	extended = false,
	size = 24*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DescriptionFont",{
	font = "Roboto Cn",
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

concommand.Add( "wos_togglefirstperson", function( ply, cmd, args )
	if ( !IsValid( ply:GetActiveWeapon() ) || !ply:GetActiveWeapon().IsLightsaber ) then return end
	local wep = ply:GetActiveWeapon()
	if not wep.FirstPerson then 
		wep.FirstPerson = true 
		return 
	else
		wep.FirstPerson = false
	end
end )					

wOS.ShouldDrawLightsaberLight = CreateConVar( "wos_alcs_drawsaberlight", "1", FCVAR_ARCHIVE )

function wOS.ALCS:OpenForceMenu()

	if self.ForceMenu then return end	
	
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	local powers = wep:GetActiveForcePowers()
	if table.Count( powers ) < 1 then return end
	
	gui.EnableScreenClicker( true )
	self.ForceMenu = vgui.Create( "DPanel" )
	self.ForceMenu:SetSize( w*0.33, h*0.5 )
	self.ForceMenu:SetPos( w*0.5 - w*0.33/2, h*0.25 )
	self.ForceMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		draw.SimpleText( "Force Select Menu", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
	end 
	
	local fw, fh = self.ForceMenu:GetSize()
	
	local mw, mh = fw*0.9, fh*0.8
	
	local formlist = vgui.Create("DScrollPanel", self.ForceMenu )
	formlist:SetPos( fw*0.05, fh*0.1 )
	formlist:SetSize( mw, mh )
	formlist.Paint = function( pan, ww, hh ) 
	end
	formlist.VBar.Paint = function() end
	formlist.VBar.btnUp.Paint = function() end
	formlist.VBar.btnDown.Paint = function() end
	formlist.VBar.btnGrip.Paint = function() end
	
	local offsety = 0
	local pady = mh*0.01
	
	local button = vgui.Create( "DButton", self.ForceMenu )
	button:SetSize( fw*0.05, fw*0.05 )
	button:SetPos( fw*0.94, fw*0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.ForceMenu:Remove()
		self.ForceMenu = nil
		gui.EnableScreenClicker( false )
	end	
	
	local button1 = vgui.Create( "DButton", self.ForceMenu )
	button1:SetSize( fw, fh*0.1 )
	button1:SetPos( 0, fh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "www.wiltostech.com" )
	end	
	
	for key, data in pairs( powers ) do
		local button = vgui.Create( "DButton", formlist )
		button:SetSize( mw, mh*0.1 )
		button:SetPos( 0, offsety )
		button:SetText( "" )
		button.Data = data
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.Data.name, "wOS.TitleFont", hh, hh*0.025, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( button.Data.description, "wOS.DescriptionFont", hh, hh*0.65, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			local image = wOS.ForceIcons[ button.Data.name ]
			if image then
				surface.SetMaterial( image )
				surface.SetDrawColor( Color(255, 255, 255, 255) );
				surface.DrawTexturedRect( hh*0.025, hh*0.025, hh*0.95, hh*0.95 )
			end
		end
		button.DoClick = function()
			self.ForceMenu:Remove()
			self.ForceMenu = nil
			net.Start( "wOS.ALCS.SendForceSelect" )
			net.WriteInt( key, 32 )
			net.SendToServer()
			gui.EnableScreenClicker( false )
		end
		
		offsety = offsety + mh*0.1 + pady
		
	end
	
end

function wOS:OpenDevestatorMenu()

	if self.DevestatorMenu then return end	
	
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	local powers = wep:GetActiveDevestators()
	if table.Count( powers ) < 1 then return end
	
	gui.EnableScreenClicker( true )
	self.DevestatorMenu = vgui.Create( "DPanel" )
	self.DevestatorMenu:SetSize( w*0.33, h*0.5 )
	self.DevestatorMenu:SetPos( w*0.5 - w*0.33/2, h*0.25 )
	self.DevestatorMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		draw.SimpleText( "Devestators Menu", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
	end 
	
	local fw, fh = self.DevestatorMenu:GetSize()
	
	local mw, mh = fw*0.9, fh*0.8
	
	local formlist = vgui.Create("DScrollPanel", self.DevestatorMenu )
	formlist:SetPos( fw*0.05, fh*0.1 )
	formlist:SetSize( mw, mh )
	formlist.Paint = function( pan, ww, hh ) 
	end
	formlist.VBar.Paint = function() end
	formlist.VBar.btnUp.Paint = function() end
	formlist.VBar.btnDown.Paint = function() end
	formlist.VBar.btnGrip.Paint = function() end
	
	local offsety = 0
	local pady = mh*0.01
	
	local button = vgui.Create( "DButton", self.DevestatorMenu )
	button:SetSize( fw*0.05, fw*0.05 )
	button:SetPos( fw*0.94, fw*0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.DevestatorMenu:Remove()
		self.DevestatorMenu = nil
		gui.EnableScreenClicker( false )
	end	
	
	local button1 = vgui.Create( "DButton", self.DevestatorMenu )
	button1:SetSize( fw, fh*0.1 )
	button1:SetPos( 0, fh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "www.wiltostech.com" )
	end	
	
	for key, data in pairs( powers ) do
		local button = vgui.Create( "DButton", formlist )
		button:SetSize( mw, mh*0.1 )
		button:SetPos( 0, offsety )
		button:SetText( "" )
		button.Data = data
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.Data.name, "wOS.TitleFont", hh, hh*0.025, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( button.Data.description, "wOS.DescriptionFont", hh, hh*0.65, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			local image = wOS.DevestatorIcons[ button.Data.name ]
			if image then
				surface.SetMaterial( image )
				surface.SetDrawColor( Color(255, 255, 255, 255) );
				surface.DrawTexturedRect( hh*0.025, hh*0.025, hh*0.95, hh*0.95 )
			end
		end
		button.DoClick = function()
			self.DevestatorMenu:Remove()
			self.DevestatorMenu = nil
			net.Start( "wOS.ALCS.SendDevestatorSelect" )
			net.WriteInt( key, 32 )
			net.SendToServer()
			gui.EnableScreenClicker( false )
		end
		
		offsety = offsety + mh*0.1 + pady
		
	end
	
end

function wOS.ALCS:OpenDraggableForceMenu()

	if self.ForceMenu then return end	
	
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	
	local powers = {}
	for _, force in pairs( wep.ForcePowerList ) do
		if not wep.AvailablePowers[ force ] then continue end
		powers[ #powers + 1 ] = wep.AvailablePowers[ force ]
	end
	if table.Count( powers ) < 1 then return end
	local slots = {}
	gui.EnableScreenClicker( true )
	self.ForceMenu = vgui.Create( "DPanel" )
	self.ForceMenu:SetSize( w*0.33, h*0.5 )
	self.ForceMenu:SetPos( w*0.5 - w*0.33/2, h*0.25 )
	self.ForceMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		draw.SimpleText( "Force Select Menu", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
	end 
	
	local fw, fh = self.ForceMenu:GetSize()
	
	local mw, mh = fw*0.9, fh*0.8
	
	local formlist = vgui.Create("DScrollPanel", self.ForceMenu )
	formlist:SetPos( fw*0.05, fh*0.1 )
	formlist:SetSize( mw, mh )
	formlist.Paint = function( pan, ww, hh ) 
	end
	formlist.VBar.Paint = function() end
	formlist.VBar.btnUp.Paint = function() end
	formlist.VBar.btnDown.Paint = function() end
	formlist.VBar.btnGrip.Paint = function() end
	
	local offsety = 0
	local pady = mh*0.01
	
	local button = vgui.Create( "DButton", self.ForceMenu )
	button:SetSize( fw*0.05, fw*0.05 )
	button:SetPos( fw*0.94, fw*0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.ForceMenu:Remove()
		self.ForceMenu = nil
		self.ForceSlots:Remove()
		self.ForceSlots = nil
		gui.EnableScreenClicker( false )
		
		net.Start( "wOS.ALCS.HybridForceSelect" )
			for i=1, wOS.ALCS.Config.MaximumForceSlots do
				net.WriteUInt( i, 10 )
				net.WriteString( slots[i].Selected or "" )
			end
		net.SendToServer()
	end	
	
	local button1 = vgui.Create( "DButton", self.ForceMenu )
	button1:SetSize( fw, fh*0.1 )
	button1:SetPos( 0, fh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "www.wiltostech.com" )
	end	
	
	local function dragdropfunc( pan, panels, dropped, _, _ )
		if not dropped then return end
		pan.Selected = panels[1].Data.name
	end
	
	for key, data in pairs( powers ) do
		local button = vgui.Create( "DButton", formlist )
		button:SetSize( mw, mh*0.1 )
		button:SetPos( 0, offsety )
		button:SetText( "" )
		button.Data = data
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.Data.name, "wOS.TitleFont", hh, hh*0.025, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( button.Data.description, "wOS.DescriptionFont", hh, hh*0.65, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			local image = wOS.ForceIcons[ button.Data.name ]
			if image then
				surface.SetMaterial( image )
				surface.SetDrawColor( Color(255, 255, 255, 255) );
				surface.DrawTexturedRect( hh*0.025, hh*0.025, hh*0.95, hh*0.95 )
			end
		end
		
		button:Droppable( "wOS.ALCS.ForcePowerSlot" )
		offsety = offsety + mh*0.1 + pady
	end
	
	self.ForceSlots = vgui.Create( "DPanel" )
	self.ForceSlots:SetSize( w*0.5, h*0.1 )
	self.ForceSlots:SetPos( w*0.25, h*0.9 )
	self.ForceSlots.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 35, 35, 35, 155 ) )
		surface.DrawRect( 0, 0, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
	end

	local width = self.ForceSlots:GetWide()/wOS.ALCS.Config.MaximumForceSlots

	for i=1, wOS.ALCS.Config.MaximumForceSlots do
		local forceslot = vgui.Create( "DPanel", self.ForceSlots )
		forceslot:SetSize( width, self.ForceSlots:GetTall() )
		forceslot:Dock( LEFT )
		forceslot.Slot = i
		forceslot.Paint = function( pan, ww, hh )
			surface.SetDrawColor( color_white )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			draw.SimpleText( "Slot " .. i, "wOS.SkillTreeMain", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			if pan.Selected then
				local image = wOS.ForceIcons[ pan.Selected ]
				if image then
					local box = hh*0.75
					surface.SetMaterial( image )
					surface.SetDrawColor( Color(255, 255, 255, 255) );
					surface.DrawTexturedRect( ww/2 - box/2, hh/2 - box/2, box, box )
				end
			end
		end
		forceslot.OnMousePressed = function( pan, key ) 
			if key == MOUSE_RIGHT then
				pan.Selected = nil
			end
		end
		if wep.ForcePowers[ i ] then
			local dat = wep.ForcePowers[ i ]
			forceslot.Selected = dat.name
		end
		forceslot:Receiver( "wOS.ALCS.ForcePowerSlot", dragdropfunc, {} )
		slots[i] = forceslot
	end

end

function wOS.ALCS:CutCircle( x, y, radius )

			if not sw then sw = 0 end
			if not sh then sh = 0 end
			radius = radius*0.93
			local seg = 25
			local cir = {}

			table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
			for i = 0, seg do
				local a = math.rad( ( i / seg ) * -360 )
				table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
			end

			local a = math.rad( 0 ) -- This is need for non absolute segment counts
			table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

			
			render.ClearStencil() --Clear stencil
			render.SetStencilEnable( true ) --Enable stencil
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)
			render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER);
			render.SetStencilFailOperation(STENCILOPERATION_DECR);
			render.SetStencilZFailOperation(STENCILOPERATION_DECR );
			render.SetStencilPassOperation( STENCILOPERATION_DECR ) 
			render.SetStencilReferenceValue( 1 )
			render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
			surface.SetDrawColor( Color( 255, 255, 255, 255 ) )
			surface.DrawPoly( cir )

end

function wOS.ALCS:DrawCircle( x, y, radius )

	if not sw then sw = 0 end
	if not sh then sh = 0 end
	local seg = 360
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
	end

	local a = math.rad( 0 ) -- This is need for non absolute segment counts
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	surface.DrawPoly( cir )
			
end

function wOS.ALCS:ShouldDisableCam()

	local call = hook.Call( "wOS.ALCS.ShouldDisableCam" )
	if call then return true end

	if wOS.CraftingMenu then
		if wOS.CraftingMenu:IsVisible() then return true end
	end
	
	return false

end

hook.Add( "InputMouseApply", "wOS.ALCS.StopMeditateTurn", function( cmd )
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	if wep:GetMeditateMode() < 1 then return end
	
	cmd:SetMouseX( 0 )
	cmd:SetMouseY( 0 )
	cmd:SetMouseWheel( 0 )

	return true
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--







































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

net.Receive( "wOS.ALCS.SyncForm", function( len, ply )

	local wep = net.ReadEntity()
	if not wep.IsLightsaber then return end
	
	wep.CurForm = net.ReadString( 32 )

end )

net.Receive( "wOS.ALCS.SyncRegistration", function( len, ply )

	wOS = wOS or {}
	wOS.Lightsabers = net.ReadTable()

end )

net.Receive( "wOS.ALCS.OpenFormMenu", function( len, ply )
	local dual = net.ReadBool()
	wOS.ALCS:OpenFormMenu( dual )
end )

net.Receive( "wOS.Lightsaber.SlamTime", function( len, ply )

	local wep = net.ReadEntity()
	if not wep.IsLightsaber then return end
	
	local time = net.ReadInt( 32 )
	
	wep.DevestatorTime = CurTime() + time

end )

net.Receive( "wOS.ALCS.RecievePlayerSeq", function()

	local ply = net.ReadEntity()
	local seq = net.ReadString()


	if not IsValid( ply ) and seq == "-1" then 
		wOS.ALCS.PortalCache[ ply ] = true
		return 
	end

	wOS.ALCS.PortalCache[ ply ] = nil
	
	seq = ply:LookupSequence( seq )
	
	local rate = net.ReadFloat()
	local start = net.ReadFloat()
	if start < 0 || start > 1 then 
		start = 0
	end
	ply:SetCycle( start ) 

	ply.SeqOverride = seq or -1
	if ply.SeqOverride < 0 then
		ply.SeqOverrideRate = nil
	else
		ply.SeqOverrideRate = rate or 1.0
	end
			
end )

net.Receive( "wOS.ALCS.HybridForceSelect", function()

	local wep = LocalPlayer():GetActiveWeapon() 
	if not IsValid( wep ) then return end
	if not wep then return end
	if not wep.IsLightsaber then return end
	
	local tbl = net.ReadTable()
	
	wep.ForcePowers = {}
	for _, power in pairs( tbl ) do
		local data = wep.AvailablePowers[ power ]
		if not data then continue end
		wep.ForcePowers[ #wep.ForcePowers + 1 ] = data
	end

end )

net.Receive( "wOS.ALCS.SendGrips", function()

	local tbl = net.ReadTable()
	wOS.ALCS.LightsaberBase.Grips = wOS.ALCS.LightsaberBase.Grips or {}
	table.Add( wOS.ALCS.LightsaberBase.Grips, tbl )
	
end )

net.Receive( "wOS.ALCS.SendBlades", function()

	local tbl = net.ReadTable()
	wOS.ALCS.LightsaberBase.Blades = wOS.ALCS.LightsaberBase.Blades or {}
	for name, data in pairs( tbl ) do
		wOS.ALCS.LightsaberBase.Blades[ name ] = table.Copy( data )
		if data.EnvelopeMaterial and #data.EnvelopeMaterial > 0 then
			wOS.ALCS.LightsaberBase.Blades[ name ].Laser = Material( data.EnvelopeMaterial )
		end
		if data.InnerMaterial and #data.InnerMaterial > 0 then
			wOS.ALCS.LightsaberBase.Blades[ name ].LaserInner = Material( data.InnerMaterial )
		end
		if data.QuillonEnvelopeMaterial and #data.QuillonEnvelopeMaterial > 0 then
			wOS.ALCS.LightsaberBase.Blades[ name ].QuillonLaser = Material( data.QuillonEnvelopeMaterial )
		end
		if data.QuillonInnerMaterial and #data.QuillonInnerMaterial > 0 then
			wOS.ALCS.LightsaberBase.Blades[ name ].QuillonLaserInner = Material( data.QuillonInnerMaterial )
		end
	end
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/lightsaber/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.LightsaberBase = wOS.ALCS.LightsaberBase or {}

local dir = "wos/advswl/lightsaber"

include( dir .. "/core/cl_create_register.lua" )
include( dir .. "/core/cl_hud.lua" )
include( dir .. "/core/cl_core.lua" )

--addons/wos-grandmaster-einf/lua/wos/advswl/character/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}

local w,h = ScrW(), ScrH()
local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local CombatBlock = Material( "wos/advswl/combat_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.Camera["Combat-Overview"] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary["Combat-Overview"] = function()
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY

		local x = 0 - ww / 2
		local y = 10
		local bh = hh / 7

		pan:Text( "Kampfholocron", "wOS.CraftDescriptions", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )

		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ZURÜCK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end
		lst = lst + 1

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "USE THE RUNES TO PERFECT YOUR FIGHTING STYLE", "wOS.CraftDescriptions", 0, y + bh*2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, CombatBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	
	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = 20
		local y = -hh*0.3
		local bh = hh/7
		
		pan:Line( x/2, y - hh*0.15, x, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "a" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Combat-Preferences" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "MANAGE PREFERENCES", "wOS.TitleFont", x + ww*1.4*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025
	
	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
	
end

wOS.ALCS.Skills.Camera[ "Combat-SelectExec" ] = { origin = centerpoint - Vector( 65, -45, -30 ), angles = Angle( 0, 180, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Combat-SelectExec" ] = function()

	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.TestSkills = {}
	
	for name, data in pairs( wOS.ALCS.ExecSys.Executions ) do
		if !wOS.ALCS.ExecSys:CanUseExecution( name ) then continue end
		local model = ClientsideModel( LocalPlayer():GetModel(), RENDERGROUP_OPAQUE )
		model:SetSequence( data.PreviewSequence or "wos_hatred_start" )
		model:SetCycle( data.PreviewFrame or 0.5 )
		model.EData = data
		table.insert( wOS.ALCS.Skills.CubeModels, model )
		table.insert( frontpane.TestSkills, name )
	end
	
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7

		local execution = pan.TestSkills[ pan.Selected ] or ""
		if wOS.ALCS.ExecSys.Executions[ execution ] then
			local data = wOS.ALCS.ExecSys.Executions[ execution ]
			pan:Text( execution, "wOS.CraftTitles", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Text( data.Description, "wOS.CraftDescriptions", 0, -hh*0.85, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
			pan:Text( data.RarityName or "Common", "wOS.TitleFont", 0, -hh*0.75, data.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )			
		end
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y + bh*2.5, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y + bh*2.5, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Combat-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y + bh*2.5, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh*2.5 + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.55/2, -hh*0.65, hh*0.55, hh*1.05, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _jp then
			if !wOS.ALCS.ExecSys.Executions[ execution ] then return end
			net.Start( "wOS.ALCS.ExecSys.SelectExecution" )
				net.WriteString( execution )
			net.SendToServer()
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "SELECT THE EXECUTION TO USE IT", "wOS.CraftDescriptions", 0, y + bh*2*( 2.25 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		pan:Mat( leftButton, x - ww*2, y + bh*1.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*2, y + bh*1.2, ww, bh, color_white, color_white )
		if _jp then
			//Keep incrementing it who am I to stop you
			//Your PC will regret it, not me
			pan.ScrollSlot = pan.ScrollSlot - 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
	    elseif _hov then
			local speed = 0.1
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		pan:Mat( rightButton, x + ww*2, y + bh*1.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + ww*2, y + bh*1.2, ww, bh, color_white, color_white )
		if _jp then
			//Keep incrementing it who am I to stop you
			//Your PC will regret it, not me
			pan.ScrollSlot = pan.ScrollSlot + 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
	    elseif _hov then
			local speed = 0.1
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		local radius = 7.7
		pan.LastScrollSlot = math.Approach( pan.LastScrollSlot, pan.ScrollSlot, 0.01 )
		local offset = pi*5/10 + pi*2/#pan.TestSkills*pan.LastScrollSlot
		local basesize = 1.3 * ( 1 - 0.04*(#pan.TestSkills/15) )
		for i = 1, #pan.TestSkills do
			local j = i - 1
			local x, y = math.sin( offset - pi*j*2/#pan.TestSkills ), math.cos( offset - pi*j*2/#pan.TestSkills )
			local setpos = pan.CamPos - Vector( 8, 0, 0 ) + Vector( radius*x, radius*y, -3 )
			local size = 40/setpos:DistToSqr( wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin )	//Clinically proven to be the number
			if not wOS.ALCS.Skills.CubeModels[i] then continue end
			wOS.ALCS.Skills.CubeModels[i]:SetPos( setpos )
			wOS.ALCS.Skills.CubeModels[i]:SetModelScale( basesize*size )
			if wOS.ALCS.LightsaberPreferences.Execution and wOS.ALCS.Skills.CubeModels[i].EData.Name == wOS.ALCS.LightsaberPreferences.Execution then
				halo.Add( { wOS.ALCS.Skills.CubeModels[i] }, Color( 255, 255, 255, 5 ), 5, 5, 1 )
			end
		end
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( -20, 0, 0 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
end

wOS.ALCS.Skills.Camera[ "Combat-Preferences" ] = { origin = centerpoint - Vector( 45, 10, -30 ), angles = Angle( 0, 270, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Combat-Preferences" ] = function()
	wOS.ALCS.Dueling.Results = nil

	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()

	local backbutt = tduiw.Create()
	backbutt.SizeX = 50
	backbutt.SizeY = 25
	backbutt.ShouldAcceptInputs = true

	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.Offset = 0
	frontpane.SelectMode = 0
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local bh = hh/7
		local pady = bh*0.05
		local x = 25
		local y = -22
		local lst = 0

		y = -18

		local image = wOS.ALCS.Runes[ "h" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			frontpane.SelectMode = 1
	    elseif _hov then
			if frontpane.SelectMode != 1 then
				local speed = 0.1
				if not pan.SlideTimes then 
					pan.SlideTimes = CurTime() + speed
					surface.PlaySound( "wos/alcs/ui_slideout.wav" )
				end
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
				pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
				pan:Text( "GRIFFAUSWAHL", "wOS.TitleFont", x + ww*1.6*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				pan.LastHover = CurTime() + 0.01
			end
	    end

		pan:Line( x, y + bh/2, x - ww*1.2, y + bh/2 )
		pan:Line( x - ww*1.2, y + bh/2, x - ww*2, y + bh*2.5 )

		if frontpane.SelectMode == 1 then
			pan:Rect( x + ww, y, ww*3, bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GRIFFAUSWAHL", "wOS.TitleFont", x + ww*1.6, y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			lst = lst + 1
			y = y + bh + pady
			for _, data in pairs( wOS.ALCS.LightsaberBase.Grips ) do
				pan:Rect( x, y, ww*4, bh, Color( 10, 10, 10, 255 ), color_white )
				local _jp, _pr, _hov = pan:Button( data.Name, "wOS.TitleFont", x, y, ww*4, bh, ( wOS.ALCS.LightsaberPreferences.Grip == data.Name and Color( 255, 0, 0 ) ) or color_white, ( wOS.ALCS.LightsaberPreferences.Grip == data.Name and Color( 255, 0, 0 ) ) or color_white )
				if _jp then
					net.Start( "wOS.ALCS.SelectGrip" )
						net.WriteString( data.Name )
					net.SendToServer()
				elseif _hov then
					if pan.LastButt != lst then
						surface.PlaySound( "wos/alcs/ui_rollover.wav" )
						pan.LastButt = lst
					end
				end
				y = y + bh + pady
				lst = lst + 1
			end
		end

		y = -18 + bh * 7 + pady * 9
		x = 20
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Combat-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end
		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	end

	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025

	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*21
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -27, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )

	wOS.ALCS.Skills.CubeModels[1] = ClientsideModel( LocalPlayer():GetModel() )
	wOS.ALCS.Skills.CubeModels[1]:SetPos( frontpane.CamPos + forward*75 - up*30 - right*10 )
	wOS.ALCS.Skills.CubeModels[1]:SetAngles( Angle( 0, 180, 0 ) )
	wOS.ALCS.Skills.CubeModels[1]:SetSequence( "vanguard_f_idle" )
	wOS.ALCS.Skills.CubeModels[1]:SetNoDraw( true )

	local bone = wOS.ALCS.Skills.CubeModels[1]:LookupBone( "ValveBiped.Bip01_R_Hand" )
	local rpos, rang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
	if bone then
		rpos, rang = wOS.ALCS.Skills.CubeModels[1]:GetBonePosition( bone )
		rang:RotateAroundAxis( rang:Right(), 90 )
		rpos = rpos - rang:Forward()*6 - rang:Up()*1.8 + rang:Right()*0.5
	end

	bone = wOS.ALCS.Skills.CubeModels[1]:LookupBone( "ValveBiped.Bip01_L_Hand" )
	local lpos, lang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
	if bone then
		lpos, lang = wOS.ALCS.Skills.CubeModels[1]:GetBonePosition( bone )
		lang:RotateAroundAxis( lang:Right(), -90 )
		lpos = lpos - lang:Forward()*6 + lang:Up()*3 + lang:Right()*0.5
	end

	wOS.ALCS.Skills.CubeModels[2] = ClientsideModel( wOS.PersonalSaber.UseHilt )
	wOS.ALCS.Skills.CubeModels[2]:SetPos( rpos )
	wOS.ALCS.Skills.CubeModels[2]:SetAngles( rang )

	wOS.ALCS.Skills.CubeModels[3] = ClientsideModel( wOS.SecPersonalSaber.UseHilt )
	wOS.ALCS.Skills.CubeModels[3]:SetPos( lpos )
	wOS.ALCS.Skills.CubeModels[3]:SetAngles( lang )

	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 10
		local y = -50

		y = y + hh * 0.23

		y = y + hh * 0.06

		y = y + hh * 0.06

		pan:BlockUseBind()
	end
	backbutt:SetUIScale(20)
	backbutt.Scaling = 0.05

	local spos = wOS.ALCS.Skills.CubeModels[1]:GetPos()
	backbutt.CamPos = spos - wOS.ALCS.Skills.CubeModels[1]:GetRight()*30 + wOS.ALCS.Skills.CubeModels[1]:GetForward() * 20 
	backbutt.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, -90 )
	table.insert(wOS.ALCS.Skills.Menu.VGUI, backbutt )

end
--addons/wos-grandmaster-einf/lua/wos/advswl/storage/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Storage = wOS.ALCS.Storage or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}


wOS.ALCS.Storage.HoverInfo = { Slot = 0, Active = nil }
wOS.ALCS.Storage.LastPosI = 0
wOS.ALCS.Storage.LastPosS = 0

local w,h = ScrW(), ScrH()
local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local DuelBlock = Material( "wos/advswl/storage_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.Camera[ "Storage-Overview" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Storage-Overview" ] = function()
	
	wOS.ALCS.Storage.LastPosI = 0
	wOS.ALCS.Storage.LastPosS = 0
	
	local leftpane = tduiw.Create()
	leftpane.SizeX = 8
	leftpane.SizeY = 35
	leftpane.ShouldAcceptInputs = true
	leftpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = -30
		local y = -hh*0.4
		local bh = hh/7
		
		pan:Line( 0, -hh/2, x + ww, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "m" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x, y, ww*-3*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ENTER STORAGE DECK", "wOS.TitleFont", x + ww*-2.7*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
	    end							
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Storage-ViewDeck" )
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	leftpane:SetUIScale( 10 )
	leftpane.Scaling = 0.025
	
	leftpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	leftpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, leftpane )
	
	local store_count = 0
	for i = 1, wOS.ALCS.Storage.Data.MaxSlots do
		local dat = wOS.ALCS.Storage.Data.Backpack[ i ]
		if not dat then continue end
		if dat.Name == "Empty" then continue end
		store_count = store_count + 1 
	end
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7
		
		local col = color_white
		if store_count >= wOS.ALCS.Storage.Data.MaxSlots*0.9 then
			col = Color( 255, 0, 0 )
		end

		pan:Text( "OCCUPIED SLOTS", "wOS.CraftDescriptions", 0, -hh*1.1, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		pan:Text( store_count .. " / " .. wOS.ALCS.Storage.Data.MaxSlots, "wOS.TitleFont", 0, -hh*0.95, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		
		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "PROTECT YOUR BELONGINGS FROM HARM", "wOS.CraftDescriptions", 0, y + bh*2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, DuelBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	
	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = 20
		local y = -hh*0.6
		local bh = hh/7
		

		
		local lst = 0
		
		y = y + hh*0.4
		pan:Line( x/2, y - hh*0.05, x, y + bh/2 )
		image = wOS.ALCS.Runes[ "b" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.ALCS.Storage.PurchaseStorage" ) 
			net.SendToServer() 
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "PURCHASE STORAGE SPACE", "wOS.TitleFont", x + ww*1.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan:Text( "THIS WILL DEDUCT CREDITS", "wOS.DescriptionFont", x, y + bh*( 1 + rat ), Color( 255, 0, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025
	
	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
	
end

wOS.ALCS.Skills.Camera[ "Storage-ViewDeck" ] = { origin = centerpoint - Vector( 45, 10, -30 ), angles = Angle( 0, 270, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Storage-ViewDeck" ] = function()
	
	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()
	
	local backpane = tduiw.Create()
	backpane.SizeX = 8
	backpane.SizeY = 35
	backpane.ShouldAcceptInputs = true
	backpane.Selected = -1
	backpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Storage-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	backpane:SetUIScale( 10 )
	backpane.Scaling = 0.025
	
	backpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*15 - up*3.3
	backpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, backpane )
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5	
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.Offset = wOS.ALCS.Storage.LastPosS

	frontpane.Inventory = {}

	for slot = 1, wOS.ALCS.Storage.Data.MaxSlots do
		local name = wOS.ALCS.Storage.Data.Backpack[ slot ]
		local data = wOS.ALCS.Storage.Data.Backpack[ slot ]
		if not name then
			table.insert( frontpane.Inventory, { name = "Empty", amount = 0, slot = slot } )
			continue
		end
		local amount = 1
		if istable( data ) then
			name = data.Name
			amount = data.Amount or 1
		end
		if name != "Empty" then
			if not wOS.ItemList[ name ] then 
				table.insert( frontpane.Inventory, { name = "CORRUPTED ITEM", amount = 0, slot = slot } )
				continue 
			end
		end
		table.insert( frontpane.Inventory, { name = name, amount = amount, slot = slot } )
	end
	
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local bh = hh/7
		local pady = bh*0.05
		local x = 40 - ww*4
		local y = -26
		local lst = 0
		pan.Selected = 0
		if pan.Offset != wOS.ALCS.Storage.LastPosS then
			wOS.ALCS.Storage.LastPosS = pan.Offset
		end
		ww = ww/2
		if #pan.Inventory > 10 then
			pan:Mat( upButton, x - ww*1.1, y, ww, hh*0.35 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y, ww, hh*0.35, color_white, color_white )
			if _jp then
				if pan.Offset <= 0 then return end
				pan.Offset = pan.Offset - 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end					
			pan:Mat( bufferBar, x - ww*1.1, y + hh*0.4, ww, hh*0.69 )	
			pan:Rect( x - ww*1.1, y + hh*0.4, ww, hh*0.69, Color( 0, 0, 0, 0 ), color_white )			
			pan:Mat( downButton, x - ww*1.1, y + hh*1.14, ww, hh*0.35 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y + hh*1.14, ww, hh*0.35, color_white, color_white )			
			if _jp then
				if pan.Offset + 10 >= #pan.Inventory then return end
				pan.Offset = pan.Offset + 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end							
		end
		ww = ww*2	
		
		pan:Text( "STORAGE", "wOS.CraftTitles", x + ww*1.4, y + hh*1.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	
		for i = 1, 10 do
			local slot = i + pan.Offset
			if slot > #pan.Inventory then break end
			local dat = pan.Inventory[slot]
			local col = color_white
			if wOS.ALCS.Storage.HoverInfo.Slot == slot and !wOS.ALCS.Storage.HoverInfo.Inventory then
				col = Color( 255, 0, 0 )
			end
			
			pan:Text( slot, "wOS.TitleFont", x + ww*0.4, y + bh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Line( x + ww*0.8, y, x + ww*0.8, y + bh )
			
			pan:Text( dat.name, "wOS.TitleFont", x + ww, y + bh/2, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if dat.amount > 1 then
				pan:Text( "x" .. dat.amount, "wOS.TitleFont", x + ww*4.1, y + bh/2, col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			end
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww*4.2, bh, col, Color( 175, 0, 0 ) )
			if _jp then
				if wOS.ALCS.Storage.HoverInfo.Slot > 0 then
					if !wOS.ALCS.Storage.HoverInfo.Inventory then
						if wOS.ALCS.Storage.HoverInfo.Slot != slot then
							net.Start( "wOS.ALCS.Storage.MoveStorageSlot" )
								net.WriteInt( wOS.ALCS.Storage.HoverInfo.Slot, 32 )
								net.WriteInt( slot, 32 )
							net.SendToServer()
						end
					else
						net.Start( "wOS.ALCS.Storage.TransferInventorySlot" )
							net.WriteInt( wOS.ALCS.Storage.HoverInfo.Slot, 32 )
							net.WriteInt( slot, 32 )
						net.SendToServer()
						wOS.SaberInventory[ wOS.ALCS.Storage.HoverInfo.Slot ] = wOS.ALCS.Storage.Data.Backpack[ slot ]
					end
					wOS.ALCS.Storage.HoverInfo.Inventory = nil
					wOS.ALCS.Storage.HoverInfo.Slot = 0
				else
					wOS.ALCS.Storage.HoverInfo.Slot = slot
					wOS.ALCS.Storage.HoverInfo.Inventory = nil
				end
			elseif _hov then
				pan.Selected = slot
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end	
			lst = lst + 1
			y = y + bh + pady			
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.018
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*15 + up*1.5 + right*5.3
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	local invpane = tduiw.Create()
	invpane.SizeX = 8
	invpane.SizeY = 35
	invpane.LeftCount = 1
	invpane.RightCount = 5	
	invpane.ShouldAcceptInputs = true
	invpane.LastScrollSlot = 0
	invpane.ScrollSlot = 0
	invpane.Selected = 1
	invpane.Offset = wOS.ALCS.Storage.LastPosI
	
	invpane.Inventory = {}
	
	for slot = 1, wOS.ALCS.Config.Crafting.MaxInventorySlots do
		local name = wOS.SaberInventory[ slot ]
		local data = wOS.SaberInventory[ slot ]
		if not name then
			table.insert( invpane.Inventory, { name = "Empty", amount = 1, slot = slot } )
			continue
		end
		local amount = 1
		if istable( data ) then
			name = data.Name
			amount = data.Amount or 1
		end
		if name != "Empty" then
			if not wOS.ItemList[ name ] then 
				table.insert( invpane.Inventory, { name = "Empty", amount = 1, slot = slot } )
				continue 
			end
		end
		table.insert( invpane.Inventory, { name = name, amount = amount, slot = slot } )
	end

	invpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local bh = hh/7
		local pady = bh*0.05
		local x = 40 - ww*4
		local y = -26
		local lst = 0
		pan.Selected = 0
		if pan.Offset != wOS.ALCS.Storage.LastPosI then
			wOS.ALCS.Storage.LastPosI = pan.Offset
		end
		ww = ww/2
		if #pan.Inventory > 10 then
			pan:Mat( upButton, x - ww*1.1, y, ww, hh*0.35 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y, ww, hh*0.35, color_white, color_white )
			if _jp then
				if pan.Offset <= 0 then return end
				pan.Offset = pan.Offset - 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end					
			pan:Mat( bufferBar, x - ww*1.1, y + hh*0.4, ww, hh*0.69 )	
			pan:Rect( x - ww*1.1, y + hh*0.4, ww, hh*0.69, Color( 0, 0, 0, 0 ), color_white )			
			pan:Mat( downButton, x - ww*1.1, y + hh*1.14, ww, hh*0.35 )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww*1.1, y + hh*1.14, ww, hh*0.35, color_white, color_white )			
			if _jp then
				if pan.Offset + 10 >= #pan.Inventory then return end
				pan.Offset = pan.Offset + 1
				surface.PlaySound( "buttons/lightswitch2.wav" )
			elseif _hov then
				pan.Selected = slot
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end							
		end
		ww = ww*2	
		
		pan:Text( "INVENTORY", "wOS.CraftTitles", x + ww*1.85, y + hh*1.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	
		for i = 1, 10 do
			local slot = i + pan.Offset
			if slot > #pan.Inventory then break end
			local dat = pan.Inventory[slot]
			local col = color_white

			if wOS.ALCS.Storage.HoverInfo.Slot == slot and wOS.ALCS.Storage.HoverInfo.Inventory then
				col = Color( 255, 0, 0 )
			end
			
			pan:Text( slot, "wOS.TitleFont", x + ww*0.4, y + bh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Line( x + ww*0.8, y, x + ww*0.8, y + bh )
			
			pan:Text( dat.name, "wOS.TitleFont", x + ww, y + bh/2, col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if dat.amount > 1 then
				pan:Text( "x" .. dat.amount, "wOS.TitleFont", x + ww*4.1, y + bh/2, col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			end
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww*4.2, bh, col, Color( 175, 0, 0 ) )
			if _jp then
				if wOS.ALCS.Storage.HoverInfo.Slot > 0 then
					if wOS.ALCS.Storage.HoverInfo.Inventory then
						if wOS.ALCS.Storage.HoverInfo.Slot != slot then
							net.Start( "wOS.ALCS.Storage.MoveInventorySlot" )
								net.WriteInt( wOS.ALCS.Storage.HoverInfo.Slot, 32 )
								net.WriteInt( slot, 32 )
							net.SendToServer()
							local dat = wOS.SaberInventory[ slot ]
							wOS.SaberInventory[ slot ] = wOS.SaberInventory[ wOS.ALCS.Storage.HoverInfo.Slot ]
							wOS.SaberInventory[ wOS.ALCS.Storage.HoverInfo.Slot ] = dat 
						end
					else
						net.Start( "wOS.ALCS.Storage.TransferInventorySlot" )
							net.WriteInt( slot, 32 )
							net.WriteInt( wOS.ALCS.Storage.HoverInfo.Slot, 32 )
						net.SendToServer()
						wOS.SaberInventory[ slot ] = wOS.ALCS.Storage.Data.Backpack[ wOS.ALCS.Storage.HoverInfo.Slot ]
					end
					wOS.ALCS.Storage.HoverInfo.Inventory = nil
					wOS.ALCS.Storage.HoverInfo.Slot = 0
				else
					wOS.ALCS.Storage.HoverInfo.Slot = slot
					wOS.ALCS.Storage.HoverInfo.Inventory = true
				end
			elseif _hov then
				pan.Selected = slot
				local speed = 0.1
				if pan.LastButt != lst then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = lst
				end
				pan.LastHover = CurTime() + 0.01
			end	
			lst = lst + 1
			y = y + bh + pady			
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	invpane:SetUIScale( 10 )
	invpane.Scaling = 0.018
	
	invpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward*15 + up*1.5 - right*13.5
	invpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, invpane )
	
	wOS.ALCS.Skills.CubeModels[1] = ClientsideModel( "models/props_lab/huladoll.mdl" )
	wOS.ALCS.Skills.CubeModels[1]:SetPos( frontpane.CamPos + forward*110 - up*5 + right*20 )
	
	wOS.ALCS.Skills.CubeModels[2] = ClientsideModel( "models/props_lab/huladoll.mdl" )
	wOS.ALCS.Skills.CubeModels[2]:SetPos( frontpane.CamPos + forward*110 - up*5 - right*30 )
	
	frontpane.PostRenders = function( pan )
		local model = "models/props_lab/huladoll.mdl"
		local sel = pan.Selected
		if !wOS.ALCS.Storage.HoverInfo.Inventory and wOS.ALCS.Storage.HoverInfo.Slot > 0 then
			sel = wOS.ALCS.Storage.HoverInfo.Slot
		end
		if pan.Inventory[ sel ] then
			local name = pan.Inventory[ sel ].name
			if name then
				local item = wOS.ItemList[ name ]
				if item then
					if item.Model then
						model = item.Model
					end
				end
			end
		end
		
		local display = wOS.ALCS.Skills.CubeModels[1]
		if IsValid( display ) then 
			if display:GetModel() != model then
				display:SetModel( model )
			end
			local ang = display:GetAngles()
			ang:RotateAroundAxis( ang:Up(), FrameTime()*-100 )
			display:SetAngles( ang )
		end
	end
	
	invpane.PostRenders = function( pan )
		local model = "models/props_lab/huladoll.mdl"
		local sel = pan.Selected
		if wOS.ALCS.Storage.HoverInfo.Inventory and wOS.ALCS.Storage.HoverInfo.Slot > 0 then
			sel = wOS.ALCS.Storage.HoverInfo.Slot
		end
		if pan.Inventory[ sel ] then
			local name = pan.Inventory[ sel ].name
			if name then
				local item = wOS.ItemList[ name ]
				if item then
					if item.Model then
						model = item.Model
					end
				end
			end
		end
		
		local display = wOS.ALCS.Skills.CubeModels[2]
		if IsValid( display ) then 
			if display:GetModel() != model then
				display:SetModel( model )
			end
			local ang = display:GetAngles()
			ang:RotateAroundAxis( ang:Up(), FrameTime()*-100 )
			display:SetAngles( ang )
		end
		
	end
	
end


--addons/wos-grandmaster-einf/lua/wos/advswl/prestige/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}

include( "wos/advswl/prestige/core/sh_core.lua" )
include( "wos/advswl/prestige/core/cl_core.lua" )
include( "wos/advswl/prestige/core/cl_net.lua" )
include( "wos/advswl/prestige/core/cl_menu_library.lua" )	

--addons/wos-grandmaster-einf/lua/wos/advswl/prestige/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Prestige = wOS.ALCS.Prestige or {}

function wOS.ALCS.Prestige:CanEquipPrestige( mastery )
	if not mastery then return end
	local dat = wOS.ALCS.Prestige.MapData.Paths[ mastery ]
	if not dat then return end
	if dat.RequiredMastery and #dat.RequiredMastery  > 0 then
		for _, mast in ipairs( dat.RequiredMastery ) do
			if wOS.ALCS.Prestige.Data.Mastery[ mast ] then
				return true
			end
		end
	else
		return true
	end
	return false
end
--addons/wos-grandmaster-einf/lua/wos/advswl/trade/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}

include( "wos/advswl/trade/core/sh_core.lua" )
include( "wos/advswl/trade/core/cl_core.lua" )
include( "wos/advswl/trade/core/cl_net.lua" )
include( "wos/advswl/trade/core/cl_menu_library.lua" ) 

--addons/wos-grandmaster-einf/lua/wos/advswl/trade/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Prestige = wOS.ALCS.Prestige or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}

local w,h = ScrW(), ScrH()
local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local DuelBlock = Material( "wos/advswl/trade_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.Camera[ "Trade-Overview" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Trade-Overview" ] = function()
	wOS.ALCS.Skills.Menu.ModEnabled = false
	local leftpane = tduiw.Create()
	leftpane.SizeX = 8
	leftpane.SizeY = 35
	leftpane.ShouldAcceptInputs = true
	leftpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = -30
		local y = -hh*0.4
		local bh = hh/7
		
		//pan:Line( x/2, y + hh*0.15, x, y + bh/2 )
		//y = y + hh*0.4
		//pan:Line( x/2, y - hh*0.05, x, y + bh/2 )
		pan:Line( 0, -hh/2 + hh*0.05, x + ww, y - hh*0.2 + bh/2 )
		pan:Line( 0, -hh/2 + hh*0.1, x + ww, y + hh*0.2 + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "a" ]
		pan:Mat( image, x, y + hh*0.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y + hh*0.2, ww, bh, color_white, color_white )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x, y + hh*0.2, ww*-3*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "VIEW AUCTIONS", "wOS.TitleFont", x + ww*-2.7*( 1 - rat  ), y + hh*0.2 + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
	    end							
		if _jp then
			wOS.ALCS.GTN:CreateGTNPanel( wOS.ALCS.GTN.Modes.AUCTIONS )
			wOS.ALCS.Skills.Menu:SetVisible( false )	
		end	
		lst = lst + 1
		
		local lst = 0
		image = wOS.ALCS.Runes[ "t" ]
		pan:Mat( image, x, y - hh*0.2, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y - hh*0.2, ww, bh, color_white, color_white )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x, y - hh*0.2, ww*-3*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "VIEW TRADES", "wOS.TitleFont", x + ww*-2.7*( 1 - rat  ), y - hh*0.2 + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
	    end							
		if _jp then
			wOS.ALCS.GTN:CreateGTNPanel( wOS.ALCS.GTN.Modes.TRADES )
			wOS.ALCS.Skills.Menu:SetVisible( false )	
		end			
		
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	leftpane:SetUIScale( 10 )
	leftpane.Scaling = 0.025
	
	leftpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	leftpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, leftpane )
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7
		
		local number = math.random( 0, 9 ) .. "" ..  math.random( 0, 9 )

		pan:Text( "GALACTIC TRADE NETWORK", "wOS.CraftDescriptions", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		pan:Text( "OPEN " .. number .. " HOURS A DAY", "wOS.DescriptionFont", 0, -hh*0.95, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

		
		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "SEIZE OPPORTUNITY ON THE MARKET", "wOS.CraftDescriptions", 0, y + bh*2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, DuelBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	
	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = 20
		local y = -hh*0.6
		local bh = hh/7
		

		
		pan:Line( x/2, y + hh*0.15, x, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "v" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.GTN:CreateGTNPanel( wOS.ALCS.GTN.Modes.MYLISTINGS )
			wOS.ALCS.Skills.Menu:SetVisible( false )	
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "MANAGE LISTINGS", "wOS.TitleFont", x + ww*1.55*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		y = y + hh*0.4
		pan:Line( x/2, y - hh*0.05, x, y + bh/2 )
		image = wOS.ALCS.Runes[ "r" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.ALCS.GTN.RequestStock" ) 
			net.SendToServer() 
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "CHECK REWARD STOCK", "wOS.TitleFont", x + ww*1.33*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan:Text( "MAKE SURE YOU HAVE ENOUGH INVENTORY SPACE!", "wOS.DescriptionFont", x, y + bh*( 1 + rat ), Color( 255, 0, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025
	
	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/addon-loader/legacy_crafting_bench_loader.lua:
wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Legacy = wOS.ALCS.Legacy or {}

if SERVER then
	AddCSLuaFile( "wos/advswl/legacy-crafting/wos_craft.lua" )
else
	include( "wos/advswl/legacy-crafting/wos_craft.lua" )
end
--addons/bkeypads/lua/vgui/bkeypads_wrap_label.lua:
-- (\S+?):Help\((.+?)\)
-- bKeypads:AddHelp($1, $2)

local PANEL = {}

function PANEL:Init()
	self:SetContentAlignment(5)
	self.m_bOptimizing = true
end

function PANEL:GenerateMarkupObject(w)
	local w = w or self:GetWide()
	local markupStr = "<color=" .. bKeypads.markup.Color(self:GetTextColor() or self:GetTextStyleColor()) .. "><font=" .. bKeypads.markup.Escape(self:GetFont()) .. ">" .. bKeypads.markup.Escape(self.m_Text or self:GetText()) .. "</font></color>"
	if not self.m_MarkupObj or self.m_MarkupObj:GetMaxWidth() ~= w or markupStr ~= self.m_MarkupStr then
		self.m_MarkupStr = markupStr
		self.m_MarkupObj = bKeypads.markup.Parse(self.m_MarkupStr, w)
	end
end

function PANEL:SetText(text)
	self.m_Text = text
	DLabel.SetText(self, text)
	self:GenerateMarkupObject()
end

function PANEL:PerformLayout(w, h)
	self:GenerateMarkupObject(w)

	if self.m_iWrapCheck ~= nil then
		if self.m_bWrapCheckNextFrame then
			if self.m_iWrapCheck == h then
				self:SetWrap(false)
			end
			self.m_iWrapCheck = nil
			self.m_bWrapCheckNextFrame = nil
		else
			self.m_bWrapCheckNextFrame = true
		end
		self:InvalidateLayout()
	end
end

function PANEL:Paint(w, h)
	if bKeypads.Performance:Optimizing() then
		if not self.m_bOptimizing then
			self:SetWrap(false)
			self:SetAutoStretchVertical(false)
			DLabel.SetText(self, "X")
			self:SizeToContentsY()
			self.m_iWrapCheck = self:GetTall()

			self:SetWrap(true)
			self:SetAutoStretchVertical(true)
			DLabel.SetText(self, self.m_Text or self:GetText())

			self:InvalidateLayout(true)

			self.m_bOptimizing = true
		end
	else
		self.m_iWrapCheck = nil
		self.m_bWrapCheckNextFrame = nil

		if self.m_bOptimizing then
			DLabel.SetText(self, "")
			self:SetWrap(false)
			self:SetAutoStretchVertical(false)

			self:InvalidateLayout()

			self.m_bOptimizing = nil
		end

		if not self.m_MarkupObj then
			self:GenerateMarkupObject()
		end

		self.m_MarkupObj:Draw(0, 0, TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, self:GetAlpha(), TEXT_ALIGN_CENTER)
		self:SetTall(self.m_MarkupObj:GetHeight())
	end
end

derma.DefineControl("bKeypads.WrapLabel", nil, PANEL, "DLabel")
--addons/openpermissions/lua/vgui/openpermissions_addon.lua:
local function markup_Escape(str)
	return (tostring(str):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"))
end

local PANEL = {}

function PANEL:Init()
	self:SetText("")
end

function PANEL:GenerateMarkup(text, maxwidth)
	self.Addon.Markup = markup.Parse("<color=255,255,255>" .. markup_Escape(text) .. "</color>", maxwidth)
end

function PANEL:Setup(id, options)
	self.Addon = {}

	self.Addon.Name = options.Name or id
	self.Addon.Color = options.Color or OpenPermissions.COLOR_BLACK

	if (options.Logo and options.Logo.Path and options.Logo.Width and options.Logo.Height) then
		self.Addon.Logo = {
			Material = Material(options.Logo.Path),
			Width = options.Logo.Width / 2,
			Height = options.Logo.Height / 2
		}
	end
end

function PANEL:Paint(w,h)
	derma.SkinHook("Paint", "Button", self, w, h)

	if (not self.Addon) then return end

	surface.SetDrawColor(self.Addon.Color)
	surface.DrawRect(5, 5, w - 10, h - 10)

	if (self.Addon.Logo) then
		local x,y = w / 2 - self.Addon.Logo.Width / 2, h / 2 - self.Addon.Logo.Height / 2
		surface.SetDrawColor(255,255,255)
		surface.SetMaterial(self.Addon.Logo.Material)
		surface.DrawTexturedRect(x, y, self.Addon.Logo.Width, self.Addon.Logo.Height)
	elseif (self.Addon.Markup) then
		self.Addon.Markup:Draw(w / 2, h / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		self:GenerateMarkup(self.Addon.Name, w - 20)
	end
end

derma.DefineControl("OpenPermissions.Addon", nil, PANEL, "DButton")
--addons/openpermissions/lua/vgui/openpermissions_combobox.lua:

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )

end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val, spacer = self.Spacers[ k ] } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( v.spacer ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:AddChoice( "Some Choice" )
	ctrl:AddChoice( "Another Choice", "myData" )
	ctrl:AddChoice( "Default Choice", "myData2", true )
	ctrl:AddChoice( "Icon Choice", "myData3", false, "icon16/star.png" )
	ctrl:SetWide( 150 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "OpenPermissions.ComboBox", nil, PANEL, "DButton" )

--addons/openpermissions/lua/vgui/openpermissions_tree.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bShowIcons", "ShowIcons" )
AccessorFunc( PANEL, "m_iIndentSize", "IndentSize" )
AccessorFunc( PANEL, "m_iLineHeight", "LineHeight" )
AccessorFunc( PANEL, "m_pSelectedItem", "SelectedItem" )
AccessorFunc( PANEL, "m_bClickOnDragHover", "ClickOnDragHover" )

function PANEL:Init()

	self:SetShowIcons( true )
	self:SetIndentSize( 14 )
	self:SetLineHeight( 17 )

	self.RootNode = self:GetCanvas():Add( "DTree_Node" )
	self.RootNode:SetRoot( self )
	self.RootNode:SetParentNode( self )
	self.RootNode:Dock( TOP )
	self.RootNode:SetText( "" )
	self.RootNode:SetExpanded( true, true )
	self.RootNode:DockMargin( 0, 4, 0, 0 )

	self:SetPaintBackground( true )

end

function PANEL:Root()
	return self.RootNode
end

function PANEL:AddNode( strName, strIcon )

	return self.RootNode:AddNode( strName, strIcon )

end

function PANEL:ChildExpanded( bExpand )

	self:InvalidateLayout()

end

function PANEL:ShowIcons()

	return self.m_bShowIcons

end

function PANEL:ExpandTo( bExpand )
end

function PANEL:SetExpanded( bExpand )
end

function PANEL:Clear()
	self:Root():Clear()
end

function PANEL:Paint( w, h )

	derma.SkinHook( "Paint", "Tree", self, w, h )
	return true

end

function PANEL:DoClick( node )
	return false
end

function PANEL:DoRightClick( node )
	return false
end

function PANEL:SetSelectedItem( node )

	if ( IsValid( self.m_pSelectedItem ) ) then
		self.m_pSelectedItem:SetSelected( false )
	end

	self.m_pSelectedItem = node

	if ( node ) then
		node:SetSelected( true )
		node:OnNodeSelected( node )
	end

end

function PANEL:OnNodeSelected( node )
end

function PANEL:MoveChildTo( child, pos )

	self:InsertAtTop( child )

end

function PANEL:LayoutTree()

	self:InvalidateChildren( true )

end

derma.DefineControl("OpenPermissions.Tree", nil, PANEL, "OpenPermissions.ScrollPanel")
--gamemodes/egmrp/gamemode/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Initialization      --
---------------------------------------

DeriveGamemode("sandbox")

-- Gamemode variables
GM.Name = "EGM:RP"
GM.Author = "P4sca1, Oninoni, Mattzi, Konsti"
GM.Email = "admin@einfach-gaming.de"
GM.TeamBased = false
GM.IsSandboxDerived = true
GM.Website = "www.egm-development.com"
GM.Version = "2.0.11"
GM.LoadedModules = {}

-- Enter your License Key here.
GM.LicenseKey = "a08df7c7-3ba3-4ff3-b1ca-51966f1b494d"

-- Load required files
if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_utils.lua")

    include("eula.lua")
	include("sh_config.lua")
	include("sh_utils.lua")
	include("sv_content.lua")

	LogInfo("Loading DRM System ...")
	require("egmrp_drm")
	LogInfo("DRM System Loaded!")

    require("mysqloo")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_utils.lua")
end

-------------------------------------------------------------------------------------------------------------------------------
-- Important notice for using the GM and GAMEMODE table inside egmrp:
--
-- 1) The GM table only exists when a gamemode is currently being loaded (also on file refresh).
--    It contains the gamemode table of the gamemode that is currently being loaded.
-- 2) The GAMEMODE table does only exist after the active gamemode is loaded (PostGamemodeLoaded).
--    It always contains the gamemode table of the active gamemode.
-- 3) When calling a gamemode function, the one of the active gamemode is always used (not the one of any deriving gamemode),
--    BUT when loading a derived gamemode, all it's gamemode functions are pushed to the active gamemode.
--    So when refreshing a file in egmrp, all GM functions are pushed to GAMEMODE.
--    Therefore we need to use GM for gamemode functions when a file got changed.
--    The problem is that we can't use GM on initialize because it does not exist, because we are loading egmrp
--    after the deriving gamemode (because the deriving gamemode contains info about which configs / modules to use).
--    We have to use GAMEMODE for gamemode functions on initialize. That is the reason why we have to use
--    `GM or GAMEMODE` when writing gamemode functions in egmrp.
--
--    => When GM exists, use this table because changes are pushed to GAMEMODE.
--       Otherwise use GAMEMODE, because changes are not overwritten.
--------------------------------------------------------------------------------------------------------------------------------

GM.DRMLoadingTries = 0

-- Load the gamemode including all core modules and activated modules.
-- Called after the deriving gamemode was loaded (PostGamemodeLoaded) or
-- when there was a file refresh.
local function LoadGamemode()
	// This loads the DRM. The DRM Contains vital Functions so if it is not successfull the Gamemode cannot run and loading is aborted.
	if SERVER then
		local success, e = InitDRM()

		if not success then
			// Override Check Password to prevent Joining while loading Gamemode.
			GAMEMODE.OldCheckPassword = GAMEMODE.CheckPassword
			GAMEMODE.CheckPassword = function()
				return false, "Server startet noch!"
			end

			// If there are more than 10 tries sth is really going wrong.
			if GAMEMODE.DRMLoadingTries > 10 then
				LogWarning("DRM could not be Initialized. Please Contact our Support.")
				LogError(e)
			end

			GAMEMODE.DRMLoadingTries = GAMEMODE.DRMLoadingTries +1
			timer.Simple(1, LoadGamemode)

			return
		end

		// Reset to old Function
		if isfunction(GAMEMODE.OldCheckPassword) then
			GAMEMODE.CheckPassword = GAMEMODE.OldCheckPassword
		end
	end

    local folderName = GAMEMODE.FolderName
    local configPath = folderName .. "/gamemode/config/"

    -- Load gamemode config.
    if SERVER then
        AddCSLuaFile(configPath .. "gamemode.lua")
        include(configPath .. "gamemode.lua")
    else
        include(configPath .. "gamemode.lua")
    end

    -- Load Localization first.
    LoadModule("localization", true)

    -- Load DRM core modules.
    LoadModule("sql", true)
    LoadModule("propertymodel", true)
    LoadModule("loading", true)

    -- Load core modules.
    LoadModule("util", true)
    LoadModule("ui", true)

    LoadModule("keybinds", true)
    LoadModule("settings", true)
    LoadModule("notify", true)
    LoadModule("scoreboard", true)
    LoadModule("permission", true)

    LoadModule("eventlog", true)
    LoadModule("chat", true)
    LoadModule("voicechat", true)
    LoadModule("performance", true)
    LoadModule("joinmanager", true)

    -- Load Core propertymodel modules.
    LoadModule("manager", true)

    LoadModule("player", true)
    LoadModule("faction", true)
    LoadModule("rank", true)
    LoadModule("equipment", true)
    LoadModule("character", true)

    LoadModule("deathsystem", true)

    -- Load activated modules.
    for module, activated in pairs(Config.Modules) do
        if activated then
            LoadModule(module)
        end
    end

    -- Overwrite module configs.
    local files = file.Find(configPath .. "*.lua", "LUA")

    for k, fileName in pairs(files) do
        local split = string.Split(string.StripExtension(fileName), "_")
        local realm = table.remove(split, 1)
        local module = string.Implode("_", split)

        if module and IsModuleLoaded(module) then
            if realm == "sv" then
                if SERVER then
                    include(configPath .. fileName)
                end
            elseif realm == "sh" then
                if SERVER then
                    AddCSLuaFile(configPath .. fileName)
                end

                include(configPath .. fileName)
            elseif realm == "cl" then
                if SERVER then
                    AddCSLuaFile(configPath .. fileName)
                end

                if CLIENT then
                    include(configPath .. fileName)
                end
            end
        end
    end

    if SERVER then
        -- Load workshop content file.
        if file.Exists("gamemodes/" .. GAMEMODE.BaseClass.FolderName .. "/gamemode/sv_content.lua", "GAME") then
            include(GAMEMODE.BaseClass.FolderName .. "/gamemode/sv_content.lua")
        end

        if file.Exists("gamemodes/" .. GAMEMODE.FolderName .. "/gamemode/sv_content.lua", "GAME") then
            include(GAMEMODE.FolderName .. "/gamemode/sv_content.lua")
        end
    end

    hook.Run("EGMRP.Loaded")
end

-- Initialize the deriving gamemode after it finished loading.
hook.Add("PostGamemodeLoaded", "EGMRP.Load", function()
    LoadGamemode()
end)

-- Support file system refresh.
-- Detect whether this is a file refresh or the first initialize (GAMEMODE will not be set on first initialize).
if GAMEMODE then
    -- Set LoadedModules to an empty table, to force a refresh of all
    -- modules when reinitializing the derived gamemode.
    GAMEMODE.LoadedModules = {}
    LoadGamemode()
end
--gamemodes/egmrp/gamemode/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Gamemode config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

Config = {}

-- Servername, used to display servername in frame.
Config.Servername = "Einfach Gaming Roleplay"

-- Gamemode prefix, used for chat and log messages.
Config.Prefix = "EGM:RP"

-- The color used when displaying the gamemode prefix (e.g in chat).
Config.PrefixColor = Color(255, 0, 0)

-- Language set for localization.
-- Current values: "en" English | "de" German | "fr" French
Config.Language = "en"

-- Specifies the log level.
-- 0 = debug - Log everything
-- 1 = info - Log information, warnings and errors to console.
-- 2 = warning - Only log warnings and errors to console.
-- 3 = error - Only log errors
Config.LogLevel = 0

-- Enabled Modules Table.
Config.Modules = {}

-- Background Modules
Config.Modules["developer"] = false
Config.Modules["familyshare"] = false
Config.Modules["hostname"] = false

-- Util Modules
Config.Modules["afk"] = false -- TODO: Recheck motion detection in vehicles.
Config.Modules["compass"] = false -- TODO: Add Waypoints
Config.Modules["donator"] = false
Config.Modules["escapescreen"] = false
Config.Modules["instructor"] = false
Config.Modules["interact"] = false -- TODO
Config.Modules["realism"] = false -- TODO
Config.Modules["thirdperson"] = false -- TODO

Config.Modules["permaprops"] = false -- TODO
Config.Modules["signs"] = false

-- Multiserver Support
Config.Modules["socket"] = false -- TODO
Config.Modules["multiserver"] = false -- TODO

-- Character Modules
Config.Modules["bodygroups"] = false
Config.Modules["spawnpoints"] = false

Config.Modules["course"] = false
Config.Modules["special_character"] = false
Config.Modules["extrarank"] = false

Config.Modules["bonemerge"] = false
Config.Modules["species"] = false

Config.Modules["activity"] = false -- TODO: Merge with Reports / Track 30 Days + Statistics
Config.Modules["reports"] = false -- TODO: Character Renaming

Config.Modules["inventory"] = false
Config.Modules["inventory_storage"] = false
Config.Modules["inventory_private"] = false
Config.Modules["inventory_faction"] = false
Config.Modules["inventory_loadout"] = false
Config.Modules["inventory_weight"] = false
Config.Modules["inventory_container"] = false
Config.Modules["inventory_money"] = false
Config.Modules["inventory_shop"] = false

Config.Modules["event"] = false
Config.Modules["comlink"] = false

Config.Modules["cloneid"] = false
Config.Modules["experience"] = false -- TODO

Config.Modules["unarmed"] = false
Config.Modules["morgue"] = false
--addons/bkeypads/lua/weapons/bkeypads_access_logs/shared.lua:
SWEP.PrintName    = "#bKeypads_KeypadAccessLogs"
SWEP.Category     = "Billy's Keypads"
SWEP.Author       = "Billy"
SWEP.Purpose      = "View the access logs of a keypad"
SWEP.Instructions = "Left click a keypad"

SWEP.Slot           = 5
SWEP.SlotPos        = 2
SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = true
SWEP.Weight         = 5
SWEP.AutoSwitchTo   = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModel  = "models/weapons/v_emptool.mdl"
SWEP.WorldModel = "models/weapons/w_emptool.mdl"
SWEP.Spawnable  = true
SWEP.AdminOnly  = true

SWEP.ShowViewModel  = true
SWEP.ShowWorldModel = false

SWEP.Primary.ClipSize    = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = false
SWEP.Primary.Ammo        = "none"

SWEP.Secondary.ClipSize    = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic   = false
SWEP.Secondary.Ammo        = "none"

SWEP.HolsterSound       = Sound("npc/turret_floor/retract.wav")
SWEP.DeploySound        = Sound("npc/turret_floor/deploy.wav")
SWEP.ErrorSound         = Sound("npc/roller/code2.wav")
SWEP.ViewLogsSound      = Sound("AlyxEMP.Discharge")

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("bkeypads/access_logs_selection")
	SWEP.BounceWeaponIcon = true
end

function SWEP:SecondaryAttack() return false end

function SWEP:SetupDataTables()
	self:NetworkVar("Entity", 0, "ScanningKeypad")
end

local warranted = {}
local function isWarranted(ply)
	if SERVER then
		return ply.warranted == true
	else
		return warranted[ply] or false
	end
end
function SWEP:PrimaryAttack()
	local tr = self:GetOwner():GetEyeTrace()
	if tr.Hit and tr.StartPos:DistToSqr(tr.HitPos) <= 2025 and IsValid(tr.Entity) and tr.Entity.bKeypad then
		if DarkRP and bKeypads.Config.AccessLogs.PoliceNeedWarrant and self:GetOwner():isCP() then
			local ply = (CLIENT and tr.Entity:GetKeypadOwner()) or (SERVER and tr.Entity:GetCreator()) or nil
			if IsValid(ply) and ply ~= self:GetOwner() and not isWarranted(ply) and not ply:isWanted() and not ply:isArrested() then
				if CLIENT and IsFirstTimePredicted() then
					self:EmitSound("npc/roller/mine/rmine_predetonate.wav", 75, 100, 1, CHAN_WEAPON)
					notification.AddLegacy(bKeypads.L"AccessLogsWarrant", NOTIFY_ERROR, 3)
				end
				return false
			end
		end

		self:SendWeaponAnim(ACT_VM_FIDGET)
		self:EmitSound(self.ViewLogsSound, 75, 100, 1, CHAN_WEAPON)

		if SERVER then
			if self:GetScanningKeypad() ~= tr.Entity then
				self:SetScanningKeypad(tr.Entity)
				hook.Run("bKeypads.AccessLogs.Checked", self:GetOwner(), tr.Entity)
			end
			bKeypads.AccessLogs:OpenUI(self:GetOwner(), tr.Entity, self)
		end

		return true
	end

	if CLIENT and IsFirstTimePredicted() then
		self:EmitSound("npc/roller/code2.wav", 75, 100, 1, CHAN_WEAPON)
	end

	return false
end

-- retarded networking because darkrp does not have a shared function to check warrants for some reason
if SERVER then
	bKeypads:GMInitialize(function()
		if not DarkRP then return end

		util.AddNetworkString("bKeypads.Warrant")
		
		hook.Add("playerWarranted", "bKeypads.AccessLogs", function(ply)
			if not bKeypads.Config.AccessLogs.PoliceNeedWarrant then return end
			net.Start("bKeypads.Warrant")
				net.WriteEntity(ply)
				net.WriteBool(true)
			net.Broadcast()
		end)

		hook.Add("playerUnWarranted", "bKeypads.AccessLogs", function(ply)
			if not bKeypads.Config.AccessLogs.PoliceNeedWarrant then return end
			net.Start("bKeypads.Warrant")
				net.WriteEntity(ply)
				net.WriteBool(false)
			net.Broadcast()
		end)
	end)
else
	net.Receive("bKeypads.Warrant", function()
		warranted[net.ReadEntity()] = net.ReadBool() or nil
	end)
end

function SWEP:Deploy()
	self:SetScanningKeypad(NULL)

	self:SetHoldType("slam")
	self:SendWeaponAnim(ACT_VM_DRAW)

	self:EmitSound(self.DeploySound, 75, 100, 1, CHAN_WEAPON)
end

function SWEP:Holster()
	self:SetScanningKeypad(NULL)

	self:EmitSound(self.HolsterSound, 75, 100, 1, CHAN_WEAPON)

	return true
end

function SWEP:Think()
	local scanningKeypad = self:GetScanningKeypad()
	if IsValid(scanningKeypad) then
		local tr = self:GetOwner():GetEyeTrace()
		if not tr.Hit or not IsValid(tr.Entity) or not tr.Entity.bKeypad or tr.StartPos:DistToSqr(tr.HitPos) > 2025 then
			if SERVER then
				self:SetScanningKeypad(NULL)
			end
		else
			self:SetHoldType("pistol")
			return
		end
	end

	self:SetHoldType("slam")
end

if SERVER then
	util.AddNetworkString("bKeypads.AccessLogs.Closed")
	net.Receive("bKeypads.AccessLogs.Closed", function(_, ply)
		local scanningKeypad = net.ReadEntity()
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() == "bkeypads_access_logs" and wep:GetScanningKeypad() == scanningKeypad then
			wep:SetScanningKeypad(NULL)
		end
	end)
else
	SWEP.RenderGroup = RENDERGROUP_TRANSLUCENT

	local renderKeypadOutlines = {}
	function SWEP:DrawKeypadOutline(keypad)
		renderKeypadOutlines[keypad] = true
	end

	local keypadOutlineModelsGarbage = {}
	local keypadOutlineModels

	bKeypads_AccessLogs_Garbage = bKeypads_AccessLogs_Garbage or {}
	for garbage in pairs(bKeypads_AccessLogs_Garbage) do garbage:Remove() end

	local keypadOutlineMat = Material("models/props_combine/portalball001_sheet")
	hook.Add("PreDrawEffects", "bKeypads.AccessLogs.Effect", function()
		local context3D = false
		for keypad in pairs(renderKeypadOutlines) do
			if not context3D then
				context3D = true
				cam.Start3D()
			end

			if not keypadOutlineModels then
				keypadOutlineModels = {}
			end
			
			if keypadOutlineModelsGarbage and IsValid(keypadOutlineModelsGarbage[keypad]) then
				keypadOutlineModels[keypad] = keypadOutlineModelsGarbage[keypad]
				keypadOutlineModelsGarbage[keypad] = nil
			elseif not IsValid(keypadOutlineModels[keypad]) then
				keypadOutlineModels[keypad] = ClientsideModel(keypad:GetModel(), RENDERGROUP_TRANSLUCENT)
				keypadOutlineModels[keypad]:SetNoDraw(true)
				keypadOutlineModels[keypad]:SetPos(keypad:GetPos())
				keypadOutlineModels[keypad]:SetAngles(keypad:GetAngles())
				keypadOutlineModels[keypad]:SetParent(keypad)
				keypadOutlineModels[keypad]:SetModelScale(1.05)

				bKeypads_AccessLogs_Garbage[keypadOutlineModels[keypad]] = true
			end
			
			render.ModelMaterialOverride(keypadOutlineMat)
				keypadOutlineModels[keypad]:DrawModel()
			render.ModelMaterialOverride(nil)

			renderKeypadOutlines[keypad] = nil
		end
		if context3D then cam.End3D() end
	end)
	hook.Add("PostRender", "bKeypads.AccessLogs.CollectGarbage", function()
		if keypadOutlineModelsGarbage then
			for _, ent in pairs(keypadOutlineModelsGarbage) do ent:Remove() end
		end
		keypadOutlineModelsGarbage = keypadOutlineModels
		keypadOutlineModels = nil
	end)

	local scanningBeamMat = Material("cable/physbeam")
	function SWEP:DrawBeam(origin, target)
		local dist = origin:Distance(target)
		local clamp = math.max(math.floor(dist / 10), 4)

		render.SetMaterial(scanningBeamMat)
		render.DrawBeam(target, origin, 3, SysTime() + clamp, SysTime(), bKeypads.COLOR.WHITE)
	end

	local EMP_TOOL_MUZZLE = Vector(-3.335912, -2.608896, -0.468449)
	function SWEP:DrawWorldModelTranslucent(flags)
		local scanningKeypad = self:GetScanningKeypad()
		if IsValid(scanningKeypad) then
			local target = scanningKeypad:_LocalToWorld(scanningKeypad:OBBCenter())

			self:DrawKeypadOutline(scanningKeypad)

			local worldEnt = self.WElements["scanner"].modelEnt
			if IsValid(worldEnt) then
				self:DrawBeam(worldEnt:LocalToWorld(EMP_TOOL_MUZZLE), target)
			end
		end

		self:DrawWorldModel(flags)
	end

	local EMP_TOOL_BONE_POS = Vector(18.193024, -4.947582, -8.859428)
	local EMP_TOOL_MUZZLE = Vector(21.075607, -4.780647, -4.641513)
	local EMP_TOOL_MUZZLE_BONE = EMP_TOOL_MUZZLE - EMP_TOOL_BONE_POS
	local bone = "EMP_TOOL.base"
	function SWEP:PreDrawViewModel(vm)
		local scanningKeypad = self:GetScanningKeypad()
		if not IsValid(scanningKeypad) then return end

		local boneID = vm:LookupBone(bone)

		local origin
		if boneID then
			origin = vm:LocalToWorld(vm:WorldToLocal(vm:GetBonePosition(boneID)) + EMP_TOOL_MUZZLE_BONE)
		else
			origin = vm:LocalToWorld(EMP_TOOL_MUZZLE)
		end

		local target = bKeypads:TranslateViewModelPosition(self.ViewModelFOV or 62, scanningKeypad:_LocalToWorld(scanningKeypad:OBBCenter()))
		self:DrawKeypadOutline(scanningKeypad)
		self:DrawBeam(origin, target)
	end
	
	function SWEP:Initialize()
		self:CreateModels(self.WElements)
	end
end

if SERVER then
	function SWEP:OnDrop()
		if not bKeypads.Config.AccessLogs.CanDrop then
			self:Remove()
		end
	end

	hook.Add("canDropWeapon", "bKeypads.AccessLogs.canDropWeapon", function(ply, wep)
		if not bKeypads.Config.AccessLogs.CanDrop and IsValid(wep) and wep:GetClass() == "bkeypads_access_logs" then
			return false
		end
	end)
end

if CLIENT then
	SWEP.WElements = {
		["scanner"] = {
			type = "Model",
			model = "models/weapons/w_emptool.mdl",
			bone = "ValveBiped.Anim_Attachment_RH",
			rel = "",
			pos = Vector(-1, -1.636, 5.752),
			angle = Angle(38.57, -180, 12.857),
			size = Vector(1, 1, 1),
			color = Color(255, 255, 255, 255),
			material = "",
			skin = 0,
			bodygroup = {}
		}
	}
	
	-- CREDIT: SWEP Construction Kit
	-- https://github.com/Clavus/SWEP_Construction_Kit

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if not IsValid(self:GetOwner()) or self.ShowWorldModel == nil or self.ShowWorldModel then
			self:DrawModel()
			return
		end

		if self.GetBoneOrientation == nil then return end

		if not self.wRenderOrder then
			self.wRenderOrder = {}
			for k, v in pairs(self.WElements) do
				if v.type == "Model" then
					table.insert(self.wRenderOrder, 1, k)
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		if IsValid(self:GetOwner()) then
			bone_ent = self:GetOwner()
		else
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]
			if not v then
				self.wRenderOrder = nil
				break
			end
			if v.hide then continue end

			local pos, ang

			if v.bone then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if not pos then continue end

			local model = v.modelEnt

			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix("RenderMultiply", matrix)

			if v.material == "" then
				model:SetMaterial("")
			elseif model:GetMaterial() ~= v.material then
				model:SetMaterial(v.material)
			end

			if v.skin and v.skin ~= model:GetSkin() then
				model:SetSkin(v.skin)
			end

			if v.bodygroup then
				for k, v in pairs(v.bodygroup) do
					if model:GetBodygroup(k) ~= v then
						model:SetBodygroup(k, v)
					end
				end
			end

			render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
			render.SetBlend(v.color.a / 255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)
		end
	end

	function SWEP:CreateModels(tab)
		for k, v in pairs(tab) do
			if
				(v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and
					string.find(v.model, ".mdl") and
					file.Exists(v.model, "GAME"))
			 then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if IsValid(v.modelEnt) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif
				(v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and
					file.Exists("materials/" .. v.sprite .. ".vmt", "GAME"))
			 then
				local name = v.sprite .. "-"
				local params = {["$basetexture"] = v.sprite}
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}
				for i, j in pairs(tocheck) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			
			local v = basetab[tab.rel]
			
			if not v then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if not pos then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if not bone then return end
			
			pos, ang = vector_origin, angle_zero
			local m = ent:GetBoneMatrix(bone)
			if m then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
		
		end
		
		return pos, ang
	end
end

--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/weapons/deployable_shield_dooms/shared.lua:
SWEP.Base = "deployable_shield"
SWEP.PrintName = "Aufstellbares Schild (DU)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Schild aufstellen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild.mdl", skin = 0, bodygroup = {} }
}

SWEP.shieldEnt = "bs_dshield_dooms"
SWEP.deployShieldEnt = "bs_shield_dooms"
--addons/ballistic_shields/lua/weapons/deployable_shield_senat/shared.lua:
SWEP.Base = "deployable_shield"
SWEP.PrintName = "Aufstellbares Schild (Senat)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Schild aufstellen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild.mdl", skin = 2, bodygroup = {} }
}

SWEP.shieldEnt = "bs_dshield_senat"
SWEP.deployShieldEnt = "bs_shield_senat"
--lua/weapons/dual_base/shared.lua:
SWEP.HoldType = "duel"
SWEP.ViewModelFOV = 72.160804020101
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/v_dc17.mdl"
SWEP.WorldModel = "models/weapons/w_DC17.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.Akimbo = true
SWEP.ViewModelBoneMods = {
	["v_weapon.Hands_parent"] = { scale = Vector(0.961, 1.001, 0.961), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.elite_right"] = { scale = Vector(0.018, 0.018, 0.018), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Left_Hand"] = { scale = Vector(1.016, 1.016, 1.016), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Right_Arm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.149, -1.297, 0.185), angle = Angle(0, 0, 0) },
	["v_weapon.elite_left"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "v_weapon.elite_left", rel = "", pos = Vector(-0.519, -1.558, 4.675), angle = Angle(90, -99.351, 15.194), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc17+"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "v_weapon.elite_right", rel = "", pos = Vector(-0.519, -1.558, 4.675), angle = Angle(90, -99.351, 15.194), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/weapons/w_DC17.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(9.362, 1.738, 3.665), angle = Angle(0, 0, 0), size = Vector(0.827, 0.827, 0.827), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.MuzzleAttachment			= "1" --Where the muzzleflash AND bullet should come out of on the weapon. Most models have this as 1.
SWEP.ShellAttachment			= "2" --Where the bullet casing should come out of on the weapon. Most models have this as 2.
SWEP.MuzzleEffect    			= "MuzzleEffect" --Which effect to use as the muzzleflash.
SWEP.ShellEffect				= "ShellEject" --Which effect to use as the bullet casing.
SWEP.Tracer						= "Tracer" --Which effect to use as the bullet tracer.
SWEP.TracerX					= 1 --For every X bullets, show the tracer effect.
SWEP.Primary.Spread		= 0.0125
SWEP.Damage						= 1 --How much damage each bullet should do. Rule of thumb is somewhere around 4-8 for small caliber weapons like pistols, 8-12 for rifles, and 15+ for large caliber weapons.
SWEP.Force						= 0 --How much force each bullet should do. Rule of thumb is set this the same as damage, unless goes outside this range (5, 15). You usually don't want this to be outside that range.
SWEP.Spread						= Vector(0, 0, 0) --How inaccurate the weapon should be. Only the first 2 values are needed. Examples: AWP - Vector(0.003, 0.003, 0), M4A1 - Vector(0.030, 0.030, 0), MAC10 - Vector(0.060, 0.060, 0)
SWEP.SpreadMPenalty				= 1 --How much should we multiply the spread if the NPC is moving? Higher values mean the weapon is more inaccurate while moving. Rule of thumb is 1.2 for rifles, 1.1 for pistols, 1 for SMGs, 1.3-1.5 for MGs, and 5+ for sniper rifles.
SWEP.BurstCount					= 0 --How many EXTRA bullets should we fire every time the NPC shoots? A value of 0 means fire 1 bullet (pistols, sniper rifles), 2 means fire 3 bullets (assault rifles, some smgs). This allows burst-fire weapons like the FAMAS and Glock.
SWEP.BurstDelay					= 0 --How much time should there be between shots in the same burst? Higher values make the delay between shots in the same burst longer.
SWEP.Primary.NumShots			= 1 --How many bullets should there be for each shot? Most weapons would have this as 1, but shotguns would have a different value, like 8 or 9.
SWEP.Primary.ClipSize			= 1 --How many shots should we get per reload?
SWEP.Primary.DefaultClip		= 1 --How many shots should the weapon spawn with in the magazine? Usually you want this the same as ClipSize.
SWEP.Primary.Delay				= 0 --How much time should there be between pulls of the trigger? For weapons with a BurstCount of 0 this is essentially firerate, and for weapons with a nonzero BurstCount this is the delay between bursts.
SWEP.FireDelay 					= 0 --This value is used to store the current server time in order to handle delays between firing. Don't change this value.
SWEP.Primary.Ammo				= "pistol" --Since NPCs have infinite ammo, this value is not important and should just be left alone.
SWEP.Primary.Sound				= "weapons/pistol/pistol_fire2.wav"

SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.IronSightsPos = Vector(-1.16, 0, 1.09)
SWEP.IronSightsAng = Vector(-0.101, 1, -1.407)


function SWEP:PrimaryAttack()
	
	if not self:CanPrimaryAttack() then
		self:AIReload()
		return
	end
	
	local curtime = CurTime()
	
	if self.FireDelay > curtime then
		return
	end
	
	if self.Owner:IsNPC() and IsValid(self.Owner:GetEnemy()) then
		
		self.FireDelay = curtime + self.Primary.Delay
		
		for i=0, self.BurstCount do
		
			timer.Simple(i * self.BurstDelay, function()
			
				if not IsValid(self) or not IsValid(self.Owner) then
					return
				end
				
				if not self.Owner:GetEnemy() or not self:CanPrimaryAttack() then
					return
				end
				
				self:Shoot()
			
			end)
		
		end
		
	end
	
end

function SWEP:Proficiency()
timer.Simple(0.5, function()
if !self:IsValid() or !self.Owner:IsValid() then return; end
	local Proficiency = GetConVar( "NPC_Proficiency" )
  if GetConVar( "new_acc_system" ):GetInt() == 1 then
	if Proficiency:GetInt() == 0 then
	self.Owner:SetCurrentWeaponProficiency(0)
	end

	if Proficiency:GetInt() == 1 then
	self.Owner:SetCurrentWeaponProficiency(1)
	end
	
	if Proficiency:GetInt() == 2 then
	self.Owner:SetCurrentWeaponProficiency(2)
	end
	
	if Proficiency:GetInt() == 3 then
	self.Owner:SetCurrentWeaponProficiency(3)
	end

	if Proficiency:GetInt() == 4 then
	self.Owner:SetCurrentWeaponProficiency(4)
	end
	else
		self.Owner:SetCurrentWeaponProficiency(3)
end
	end)
end

function SWEP:Shoot()

	local owner = self.Owner
	local enemy = owner:GetEnemy()
	local enemycl = enemy:GetClass()
	local targetPos = nil
	
	if enemy:IsPlayer() or enemycl == "npc_combine_s" or enemycl == "npc_citizen" or enemycl == "npc_metropolice" then
	
		if enemy:LookupBone("ValveBiped.Bip01_Head1") == nil then
		
			targetPos = enemy:EyePos()
		
		else
		
			targetPos = enemy:GetBonePosition(enemy:LookupBone("ValveBiped.Bip01_Head1"))
			
		end
		
	elseif enemycl == "npc_fastzombie" or enemycl == "npc_poisonzombie" or enemycl == "npc_zombie_torso" or enemycl == "npc_fastzombie_torso" or enemycl == "npc_headcrab" or enemycl == "npc_headcrab_black" or enemycl == "npc_headcrab_fast" then
	
		targetPos = enemy:WorldSpaceCenter()
		
	else
	
		targetPos = enemy:EyePos()
		
	end
	
	local muzzlePos = self.Weapon:GetAttachment(self.MuzzleAttachment).Pos
	local direction = self.Owner:GetAimVector()	
	local spread = Vector( cone, cone, 0 )
	
	local bulletInfo = {}
	bulletInfo.Attacker = owner
	bulletInfo.Damage = self.Damage
	bulletInfo.Force  = self.Force
	bulletInfo.Num = self.Primary.NumShots
	bulletInfo.Tracer = self.TracerX
	bulletInfo.TracerName = self.Tracer
	bulletInfo.AmmoType = self.Primary.Ammo
	bulletInfo.Dir = direction
	bulletInfo.Spread = spread
	bulletInfo.Src = muzzlePos
	
	owner:FireBullets(bulletInfo)
	self:ShootEffects()
	
	self:TakePrimaryAmmo(1)
	
end

function SWEP:ShootEffects()

	local shootSound = Sound(self.Primary.Sound)
	self.Weapon:EmitSound(shootSound, SNDLVL_GUNFIRE, 100, 1, CHAN_WEAPON)
	
	local muzzleEffect = EffectData()
	local muzzleAttach = self.Weapon:GetAttachment(self.MuzzleAttachment)
	muzzleEffect:SetEntity(self.Weapon)
	muzzleEffect:SetOrigin(muzzleAttach.Pos)
	muzzleEffect:SetAngles(muzzleAttach.Ang)
	muzzleEffect:SetScale(1)
	muzzleEffect:SetMagnitude(1)
	muzzleEffect:SetRadius(1)
	util.Effect(self.MuzzleEffect, muzzleEffect)

	local shellEffect = EffectData()
	local shellAttach = self.Weapon:GetAttachment(self.ShellAttachment)
	shellEffect:SetEntity(self.Weapon)
	shellEffect:SetOrigin(shellAttach.Pos)
	shellEffect:SetAngles(shellAttach.Ang)
	shellEffect:SetScale(1)
	shellEffect:SetMagnitude(1)
	shellEffect:SetRadius(1)
	util.Effect(self.ShellEffect, shellEffect)
	
	self.Owner:MuzzleFlash()

end

function SWEP:AIReload()

	if not IsValid(self) or not IsValid(self.Owner) then
		return
	end
	
	local owner = self.Owner

	if owner:IsNPC() and not owner:IsCurrentSchedule(SCHED_HIDE_AND_RELOAD) and not owner:IsCurrentSchedule(SCHED_RELOAD) and not owner:GetActivity() == ACT_RELOAD then
		owner:SetSchedule(SCHED_RELOAD)
	end
	
end

function SWEP:SecondaryAttack()

end

function SWEP:Think()
	
	timer.Simple(engine.TickInterval() * 5, function()
	
		if IsValid(self) then
			self:Think()
		end
	
	end)
	
	if not IsValid(self.Owner) then
		self:Remove()
		return
	end
	
	if IsValid(self.Owner) and IsValid(self.Owner:GetEnemy()) then
		
		local owner = self.Owner
		local enemy = owner:GetEnemy()
		
		if self:CanPrimaryAttack() and owner:GetActivity() ~= ACT_RELOAD and enemy:Health() > 0 then
			
			if enemy:Visible(owner) then
			
				self:PrimaryAttack()
			
			end
		
		end
		
	end

end

function SWEP:CanPrimaryAttack()

	if self.Weapon:Clip1() <= 0 then
	
		return false
	
	end
	
	return true

end

function SWEP:Initialize()

	--// other initialize code goes here

	if CLIENT then
	
		--// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		--// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if self.Akimbo then
		self.AutoDetectMuzzleAttachment = true
		self.MuzzleAttachmentRaw = 2-self.AnimCycle
	end	
				
				--// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					--// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					--// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					--// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Deploy()

	return true
	
end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Initialize()

	--// other initialize code goes here

	if CLIENT then
	
		--// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) --// create viewmodels
		self:CreateModels(self.WElements) --// create worldmodels
		
		--// init view model bone build function
		if IsValid(self.Owner) then
			--local vm = self.Owner:GetViewModel()
			--if IsValid(vm) then
				--self:ResetBonePositions(vm)
				
				--// Init viewmodel visibility
				--if (self.ShowViewModel == nil or self.ShowViewModel) then
				--	vm:SetColor(Color(255,255,255,255))
				--else
					--// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
				--	vm:SetColor(Color(255,255,255,1))
					--// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					--// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
				--	vm:SetMaterial("Debug/hsv")			
				--end
			--end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		--local vm = self.Owner:GetViewModel()
		--if IsValid(vm) then
		--	self:ResetBonePositions(vm)
		--end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			--// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			--// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			--// Technically, if there exists an element with the same name as a bone
			--// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		--// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				--// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			--// !! WORKAROUND !! //
			--// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			--// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				--// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				--// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	--/**************************
	--	Global utility code
	--**************************/

	--// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	--// Does not copy entities of course, only copies their reference.
	--// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

function SWEP:FireAnimationEvent(pos,ang,event)
return (event==20)
end

function SWEP:CanClip2Attack()
	if clip2 <= 0 and self.Primary.ClipSize > -1 then
		self.Weapon:SetNextSecondaryFire(CurTime() + 0.5)
		self.Weapon:EmitSound("weapons/DC17_fire.wav")
		clip2 = 0
		return false
	end

	return true
end



--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads.lua:
cleanup.Register("_bkeypads")

TOOL.Category = "Billy's Keypads"
TOOL.Name = "#bKeypads_SpawnMenuKeypad"

bKeypads_STOOL_CONVARS = {
	["name"] = "",
	
	["weld"] = 1,
	["freeze"] = 1,
	["wiremod"] = 0,
	["uncrackable"] = 0,

	["granted_hold_time"] = 5,
	["granted_initial_delay"] = 0,
	["granted_repeats"] = 0,
	["granted_repeat_delay"] = 0,

	["denied_hold_time"] = 1,
	["denied_initial_delay"] = 0,
	["denied_repeats"] = 0,
	["denied_repeat_delay"] = 0,

	["granted_key"] = 0,
	["denied_key"] = 0,
	["auth_mode"] = 1,

	["charge_unauthorized"] = 0,

	["background_color"] = 0x0096FF,
	["rainbow_background_color"] = 0,
	["image_url"] = "",

	["pin"] = "",

	["granted_notification"] = 1,
	["denied_notification"] = 0,

	["auto_fading_door"] = 1,
	["mirror"] = 0,
	["nocollide"] = 1,

	["indestructible"] = 0,
	["destructible"] = 0,
	["max_health"] = 200,
	["shield"] = 0,
}
for i, v in pairs(bKeypads_STOOL_CONVARS) do TOOL.ClientConVar[i] = v end

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "create_update", icon = "gui/lmb.png", op = 0 },
		{ name = "copy", icon = "gui/rmb.png", op = 0 },
		{ name = "switch_linker", icon = "gui/r.png", op = 0 },
	}
end

function TOOL:LeftClick(tr)
	return bKeypads.STOOL.LeftClick(self, tr)
end

function TOOL:RightClick(tr)
	return bKeypads.STOOL.RightClick(self, tr)
end

function TOOL:Reload(tr)
	if CLIENT and IsFirstTimePredicted() then
		RunConsoleCommand("gmod_tool", "bkeypads_linker")
		surface.PlaySound("npc/combine_soldier/gear5.wav")
	end
	return false
end

function TOOL:AutoFadingDoor()
	if bKeypads.Config.KeypadOnlyFadingDoors and not bKeypads.Permissions:Cached(self:GetOwner(), "keypads/bypass_keypad_only_fading_doors") then
		return true, true
	end
	return self:GetClientNumber("auto_fading_door") == 1, false
end

local fadingDoorHalo
if CLIENT then
	hook.Remove("PreDrawHalos", "bKeypads.STOOL.AutoFadingDoor")

	fadingDoorHalo = {}
	local function AutoFadingDoorHalo()
		if not fadingDoorHalo then return end
		halo.Add(fadingDoorHalo, bKeypads.COLOR.GREEN, 1, 1, 1, true)
	end

	function TOOL:DrawHUD()
		if self.m_bBlockGhostEntity then return end
		local auto_fading_door, inform = self:AutoFadingDoor()
		if auto_fading_door then
			surface.SetFont("BudgetLabel")

			local tr = LocalPlayer():GetEyeTrace()
			if bKeypads.FadingDoors:CanFadingDoor(tr.Entity) then
				local txt = bKeypads.L"AutoFadingDoor"
				
				local colorFlash = math.Remap(math.cos(SysTime() * math.pi), -1, 1, 0, 1) * 255
				surface.SetTextColor(colorFlash, 255, colorFlash)

				local w = surface.GetTextSize(txt)
				surface.SetTextPos((ScrW() - w) / 2, (ScrH() / 2) + 20)
				surface.DrawText(txt)

				if fadingDoorHalo == nil or fadingDoorHalo[1] ~= tr.Entity then
					fadingDoorHalo = fadingDoorHalo or {}
					fadingDoorHalo[1] = tr.Entity
					hook.Add("PreDrawHalos", "bKeypads.STOOL.AutoFadingDoor", AutoFadingDoorHalo)
				end
				return
			elseif inform and (not IsValid(tr.Entity) or not tr.Entity.bKeypad) then
				local txt = bKeypads.L"KeypadOnlyFadingDoors"

				local colorFlash = math.Remap(math.cos(SysTime() * math.pi), -1, 1, 0, 1) * 255
				surface.SetTextColor(255, colorFlash, colorFlash)

				local w = surface.GetTextSize(txt)
				surface.SetTextPos((ScrW() - w) / 2, (ScrH() / 2) + 20)
				surface.DrawText(txt)
			end
		end
		if fadingDoorHalo ~= nil then
			fadingDoorHalo = nil
			hook.Remove("PreDrawHalos", "bKeypads.STOOL.AutoFadingDoor")
		end
	end
end

function TOOL:Deploy()
	self.m_bBlockGhostEntity = nil

	self:SetStage(0)
	self:SetOperation(0)
end

function TOOL:Holster()
	self.m_bBlockGhostEntity = true

	self:SetStage(0)
	self:SetOperation(0)
end

function TOOL:Deployed()
	self.m_bBlockGhostEntity = nil

	if CLIENT then
		fadingDoorHalo = nil
		hook.Add("PostDrawTranslucentRenderables", "bKeypads.Create.DrawProperties", self.DrawProperties)
	end
end

function TOOL:Holstered()
	if CLIENT then
		bKeypads.STOOL.BlockSpawnmenuClose = false

		fadingDoorHalo = nil
		hook.Remove("PostDrawTranslucentRenderables", "bKeypads.Create.DrawProperties")
		hook.Remove("PreDrawHalos", "bKeypads.STOOL.AutoFadingDoor")
	end
	
	self.m_bBlockGhostEntity = true
	self:ReleaseGhostEntity()
end
bKeypads_Prediction(TOOL)

local keypadThickness = Vector(0.4813505, 0.4813505, 0.4813505)
function TOOL:CalculateKeypadPos(tr)
	local tr = tr or self:GetOwner():GetEyeTrace()

	if not IsValid(tr.Entity) or tr.Entity:IsWorld() then

		local normAng = tr.HitNormal:Angle()
		local isWall = normAng:Up().z == 1

		local Pos, Angles = tr.HitPos, normAng

		if not isWall then
			local EyePosNoZ = self:GetOwner():EyePos()
			local PosNoZ = Vector(Pos)
			EyePosNoZ.z = 0
			PosNoZ.z = 0
			
			local eyeDelta = (math.floor(Angles:Forward().z) == -1 and (PosNoZ - EyePosNoZ) or (EyePosNoZ - PosNoZ)):Angle()
			Angles:RotateAroundAxis(Angles:Forward(), math.NormalizeAngle(math.Round(((eyeDelta.y - Angles.y) * math.Round(Angles:Forward().z)) / 90) * 90))
		end

		Pos = Pos + (tr.HitNormal:Angle():Forward() * keypadThickness)

		return Pos, Angles

	else

		local Pos, Angles = tr.HitPos, tr.HitNormal:Angle()
		Pos = Pos + (tr.HitNormal:Angle():Forward() * keypadThickness)

		return Pos, Angles

	end
end

do
	local developer = GetConVar("developer")
	local _debug = { render = { DrawLine = function(...)
		if CLIENT and developer:GetInt() > 1 then
			render.SetColorMaterialIgnoreZ()
			return render.DrawLine(...)
		end
	end, DrawBox = function(...)
		if CLIENT and developer:GetInt() > 1 then
			render.SetColorMaterialIgnoreZ()
			return render.DrawBox(...)
		end
	end } }

	local trInverseFilterEnt
	local trInverseFilter = function(ent) return ent == trInverseFilterEnt end

	local mirrorTrResult = {}
	local mirrorBounceTrResult = {}
	local mirrorTr = {
		ignoreworld = true,
		filter = trInverseFilter,
		mins = Vector(), maxs = Vector()
	}

	local function tryMirrorTrace(tool, keypad, tr, modelLength, _ang, _dn)
		mirrorTr.output = mirrorBounceTrResult

		local tr = mirrorTrResult

		local symmetryDir = tr.Entity:GetUp()
		local dn = _dn or mirrorTrResult.Normal:Dot(symmetryDir)
		local dnAbs = math.abs(dn)
		if dnAbs + 0.01 < 1 - 0.01 or dnAbs - 0.01 > 1 + 0.01 then
			local reflectionLength = (mirrorTr.endpos - mirrorTrResult.HitPos):Length() * .5
			local symmetryPoint = mirrorTr.endpos - (mirrorTrResult.Normal * reflectionLength)
			local R = (mirrorTrResult.Normal - 2 * dn * symmetryDir)

			_debug.render.DrawLine(mirrorTr.endpos, symmetryPoint, Color(0,255,0,255), false)
			_debug.render.DrawLine(symmetryPoint, symmetryPoint + (5 * symmetryDir), Color(0,255,255,255), false)
			_debug.render.DrawLine(symmetryPoint, symmetryPoint - (5 * symmetryDir), Color(0,255,255,255), false)

			local reflectedPos = symmetryPoint - (R * reflectionLength)
			_debug.render.DrawLine(symmetryPoint, reflectedPos, Color(0,255,255,255), false)
			
			mirrorTr.endpos = symmetryPoint
			mirrorTr.start = mirrorTr.endpos - (R * (reflectionLength + keypadThickness[1] + keypadThickness[1]))

			_debug.render.DrawLine(mirrorTr.endpos, mirrorTr.start, Color(255,0,255,255), false)
			
			util.TraceLine(mirrorTr)

			tr = mirrorBounceTrResult
		else
			local Pos = tool:CalculateKeypadPos(tr)

			local mins, maxs = keypad:GetCollisionBounds()

			local trPos = Vector(Pos)
			local thicc = maxs.x - mins.x
			thicc = Vector(thicc, thicc, thicc) * _ang:Forward()
			trPos:Add(thicc)

			mirrorTr.start, mirrorTr.endpos = trPos, trPos
			mirrorTr.mins:SetUnpacked(mins.x, mins.x, mins.x)
			mirrorTr.maxs:SetUnpacked(maxs.x, maxs.x, maxs.x)
			util.TraceHull(mirrorTr)

			_debug.render.DrawBox(trPos, angle_zero, mirrorTr.mins, mirrorTr.maxs, Color(255,0,0,25), false)

			if mirrorBounceTrResult.Entity == tr.Entity then return end

			return Pos, _ang
		end

		local Pos, Ang = tool:CalculateKeypadPos(tr)

		local __ang = Angle(_ang)
		__ang:SnapTo("p", 10) __ang:SnapTo("y", 10) __ang:SnapTo("r", 10)
		local _Ang = Angle(Ang)
		_Ang:SnapTo("p", 10) _Ang:SnapTo("y", 10) _Ang:SnapTo("r", 10)

		local delta = (__ang - _Ang)
		delta:Normalize()

		if delta.p < 90 and delta.p > -90 then
			return Pos, Ang
		elseif _dn == nil then
			return tryMirrorTrace(tool, keypad, tr, modelLength, _ang, -dn)
		end
	end

	function TOOL:CalculateMirroredKeypadPos(keypad, tr)
		local tr = tr or self:GetOwner():GetEyeTrace()

		mirrorTr.output = mirrorTrResult

		local ang = keypad:GetAngles()
		local _ang = Angle(ang)
		_ang:RotateAroundAxis(_ang:Up(), 180)

		local mins, maxs = tr.Entity:GetCollisionBounds()
		local modelLength = (mins - maxs):Length()

		trInverseFilterEnt = tr.Entity

		mirrorTr.endpos = keypad:WorldSpaceCenter()
		mirrorTr.start = mirrorTr.endpos - (keypad:GetForward() * modelLength)

		util.TraceLine(mirrorTr)

		if mirrorTrResult.Hit then
			return tryMirrorTrace(self, keypad, tr, modelLength, _ang)
		end
	end
end

if CLIENT then
	function TOOL.BuildCPanel(CPanel)
		return bKeypads.STOOL.BuildCPanel(CPanel)
	end

	local logoWhitePNG = Material("bkeypads/logo_tall_white.png", "noclamp smooth")
	local logoBlackPNG = Material("bkeypads/logo_tall_black.png", "noclamp smooth")

	local logoWhite, logoBlack

	function TOOL:DrawToolScreen(w,h)
		if not logoWhite or not logoBlack then
			logoWhite = CreateMaterial("bKeypads.LogoWhite", "UnlitGeneric", {
				["$ignorez"] = 1,
				["$translucent"] = 1
			})
			logoWhite:SetTexture("$basetexture", logoWhitePNG:GetName())
			logoWhite:Recompute()

			logoBlack = CreateMaterial("bKeypads.LogoBlack", "UnlitGeneric", {
				["$ignorez"] = 1,
				["$translucent"] = 1
			})
			logoBlack:SetTexture("$basetexture", logoBlackPNG:GetName())
			logoBlack:Recompute()
		end

		local backgroundColor = bKeypads:IntToColor(tonumber(self:GetClientNumber("background_color")) or 38655)
		
		surface.SetDrawColor(backgroundColor)
		surface.DrawRect(0,0,w,h)

		if not self.MatrixRain then
			self.MatrixRain = bKeypads_Matrix("STOOL_Screen_CustomBackgroundColor", w, h)
		end
		self.MatrixRain:ContrastRainColor(backgroundColor)
		self.MatrixRain:Draw(w,h)

		surface.SetDrawColor(255,255,255,255)
		bKeypads:DrawSubpixelClippedMaterial(
			bKeypads:GetLuminance(backgroundColor) >= 0.65 and logoBlack or logoWhite,
			(w - (w * .75)) / 2, (h - (h * .75)) / 2, w * .75, h * .75
		)

		if not bKeypads.Permissions:Cached(LocalPlayer(), "create_keypads") then
			bKeypads:ToolScreenNoPermission(w, h)
		elseif not bKeypads.STOOL:CheckLimit(LocalPlayer(), bKeypads.STOOL.LIMIT_KEYPADS) then
			bKeypads:ToolScreenWarning(bKeypads.L("SBoxLimit_bKeypads"), w, h)
		end
	end

	local propertiesW, propertiesPadding, propertiesScale = 300, 25, 0.05
	
	local gmod_toolmode
	local originAnim, sizeChanges, prevDirectionID, fadeAnimStart, slideAnimStart, slideAnimFrom
	local function KeypadPropertiesPerformLayout(self, w, h)
		DProperties.PerformLayout(self, w, h)

		if self:GetCanvas():GetVBar():IsVisible() then
			self:GetCanvas():SizeToChildren(false, true)
			self:SizeToChildren(false, true)
		end

		if sizeChanges == nil then
			sizeChanges = true
		end
	end
	function TOOL.DrawProperties(bDrawingDepth, bDrawingSkybox)
		if bDrawingSkybox then return end
		if not bKeypads.Settings:Get("draw_properties") then return end

		local self = LocalPlayer():GetTool("bkeypads")
		if not self then return end
		
		gmod_toolmode = gmod_toolmode or GetConVar("gmod_toolmode")

		local wep = LocalPlayer():GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" or gmod_toolmode:GetString() ~= "bkeypads" then return end

		local keypad = self.GhostEntity
		if not IsValid(keypad) or keypad:GetNoDraw() then
			slideAnimFrom = nil
			originAnim = nil
			return
		end

		local ConVarProperties = bKeypads.Properties:Update(nil, true)
		ConVarProperties.PerformLayout = KeypadPropertiesPerformLayout

		local ang = keypad:GetAngles()
		ang:RotateAroundAxis(keypad:GetUp(), 90)
		ang:RotateAroundAxis(keypad:GetRight(), -90)

		local center = keypad:LocalToWorld(keypad:OBBCenter())

		--render.SetColorMaterialIgnoreZ()
		--render.DrawBox(keypad:GetPos(), keypad:GetAngles(), keypad:OBBMins(), keypad:OBBMaxs(), Color(0,255,0,10), false)

		--render.DrawLine(keypad:GetPos(), keypad:GetPos() + (10 * keypad:GetUp()), Color(255,0,0), false)

		local propertiesH = ConVarProperties:GetTall()

		local origin, directionID = center

		local viewDelta = (keypad:GetAngles() - LocalPlayer():GetAngles()):Forward()
		if viewDelta.y >= -.33 and viewDelta.y <= .33 then

			local keypadH = keypad:OBBMaxs().z - keypad:OBBMins().z
			if viewDelta.z >= .66 then
				--print("top")
				origin = origin - (ang:Forward() * propertiesW * .5 * propertiesScale)
				origin = origin - (ang:Right() * ((keypadH * .5) + (propertiesH + propertiesPadding) * propertiesScale))
				directionID = 1
			else
				--print("bottom")
				--origin.z = keypad:LocalToWorld(keypad:OBBMaxs()).z
				origin = origin - (ang:Forward() * propertiesW * .5 * propertiesScale)
				origin = origin + (ang:Right() * ((keypadH * .5) + (propertiesPadding * propertiesScale)))
				directionID = 2
			end

		else
			origin = origin - (ang:Right() * propertiesH * .5 * propertiesScale)

			if viewDelta.y > 0 then
				--print("left")
				origin = origin + (ang:Forward() * (keypad:OBBMaxs().y + (propertiesPadding * propertiesScale)))
				directionID = 3
			else
				--print("right")
				origin = origin - (ang:Forward() * (keypad:OBBMaxs().y + ((propertiesPadding + propertiesW) * propertiesScale)))
				directionID = 4
			end
		end

		if bKeypads.Performance:Optimizing() then
			ConVarProperties:SetAlpha(255)

			originAnim = origin

			bKeypads.cam.IgnoreZ(true)
				cam.Start3D2D(origin, ang, propertiesScale)
					ConVarProperties:PaintManual()
				cam.End3D2D()
			bKeypads.cam.IgnoreZ(false)
		else

			fadeAnimStart = fadeAnimStart or SysTime()
			local fadeAnimFrac = bKeypads.ease.OutQuint(math.min(math.TimeFraction(fadeAnimStart, fadeAnimStart + 1, SysTime()), 1))
			ConVarProperties:SetAlpha(255 * fadeAnimFrac)

			if directionID ~= prevDirectionID or not slideAnimFrom then
				slideAnimStart = SysTime()
				slideAnimFrom = originAnim or origin
			end

			local slideAnimFrac = bKeypads.ease.OutQuint(math.min(math.TimeFraction(slideAnimStart, slideAnimStart + 1, SysTime()), 1))
			if sizeChanges then
				if keypad == prevKeypad then
					slideAnimFrom = origin
					sizeChanges = nil
				else
					sizeChanges = false
				end
			end

			originAnim = LerpVector(slideAnimFrac, slideAnimFrom, origin)

			bKeypads.cam.IgnoreZ(true)
				cam.Start3D2D(originAnim, ang, propertiesScale)
					ConVarProperties:PaintManual()
				cam.End3D2D()
			bKeypads.cam.IgnoreZ(false)
		end

		prevDirectionID = directionID
	end
	if hook.GetTable()["PostDrawTranslucentRenderables"] and hook.GetTable()["PostDrawTranslucentRenderables"]["bKeypads.Create.DrawProperties"] then
		hook.Remove("PostDrawTranslucentRenderables", "bKeypads.Create.DrawProperties")
		hook.Add("PostDrawTranslucentRenderables", "bKeypads.Create.DrawProperties", TOOL.DrawProperties)
	end
end

if CLIENT then
	function TOOL:UpdateGhostKeypad(ent, ply)
		if not IsValid(ent) or not IsValid(ply) then return end

		local tr = bKeypads:GetToolTrace(ply)
		if not tr.Hit or (bKeypads.Config.KeypadOnlyFadingDoors and not bKeypads.Permissions:Cached(ply, "keypads/bypass_keypad_only_fading_doors") and not bKeypads.FadingDoors:CanFadingDoor(tr.Entity)) or (IsValid(tr.Entity) and (tr.Entity:IsPlayer() or tr.Entity.bKeypad)) then
			ent:SetNoDraw(true)
			return
		end

		local Pos, Ang = self:CalculateKeypadPos(tr)
		ent:SetPos(Pos)
		ent:SetAngles(Ang)
		ent:SetNoDraw(false)
		ent.TraceResult = tr

		local authMode = self:GetClientNumber("auth_mode")
		ent:SetBodygroup(bKeypads.BODYGROUP.CAMERA, authMode == bKeypads.AUTH_MODE.FACEID and 1 or 0)
		ent:SetBodygroup(bKeypads.BODYGROUP.KEYCARD_SLOT, authMode == bKeypads.AUTH_MODE.KEYCARD and 1 or 0)
	end

	local function GhostEntityRenderOverride(self)
		render.SuppressEngineLighting(true)
			if bKeypads.Config.KeypadMirroring and self.TOOL and self.TOOL:GetClientNumber("mirror") == 1 and bKeypads.Permissions:Cached(LocalPlayer(), "mirror_keypads") and self.TraceResult and IsValid(self.TraceResult.Entity) then
				local pos, ang = self:GetPos(), self:GetAngles()
				local mirrorPos, mirrorAng = self.TOOL:CalculateMirroredKeypadPos(self, self.TraceResult)
				if mirrorPos and mirrorAng then
					bKeypads.cam.IgnoreZ(true)
						self:SetPos(mirrorPos)
						self:SetAngles(mirrorAng)
						self:SetupBones()
						self:DrawModel()
					bKeypads.cam.IgnoreZ(false)

					self:SetPos(pos)
					self:SetAngles(ang)
					self:SetupBones()
				end
			end
			self:DrawModel()
		render.SuppressEngineLighting(false)
	end
	function TOOL:Think()
		if not self.m_bBlockGhostEntity then
			if not IsValid(self.GhostEntity) then
				local Pos, Ang = self:CalculateKeypadPos()
				self:MakeGhostEntity(bKeypads.MODEL.KEYPAD, Pos, Ang)

				if IsValid(self.GhostEntity) then
					self.GhostEntity.bKeypadOff = true
					self.GhostEntity.RenderOverride = GhostEntityRenderOverride
					self.GhostEntity:SetSubMaterial(4, "models/bkeypads/keypad_screen")
					self.GhostEntity.TOOL = self
				end
			end
			self:UpdateGhostKeypad(self.GhostEntity, self:GetOwner())
		end
	end
end
--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads_breaker.lua:
TOOL.Category = "Billy's Keypads"
TOOL.Name = "#tool.bkeypads_breaker.name"
TOOL.AddToMenu = false

TOOL.ClientConVar["slant"] = 1

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "break_keypad", icon = "gui/lmb.png", op = 0 },
		{ name = "repair_keypad", icon = "gui/rmb.png", op = 0 }
	}
end

-- TODO show keypad owner in logs

function TOOL:LeftClick(tr)
	if not IsValid(self:GetOwner()) or not bKeypads.Permissions:Check(self:GetOwner(), "tools/keypad_breaker") then return false end

	if IsValid(tr.Entity) and tr.Entity.bKeypad and not tr.Entity:GetBroken() and not tr.Entity:GetHacked() then
		if SERVER then
			tr.Entity:SetHealth(0)
			tr.Entity:Break(tobool(self:GetClientNumber("slant")))
		elseif CLIENT and IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L"KeypadBroken", NOTIFY_UNDO, 2)
		end
		return true
	end

	return false
end

function TOOL:RightClick(tr)
	if not IsValid(self:GetOwner()) or not bKeypads.Permissions:Check(self:GetOwner(), "tools/keypad_breaker") then return false end

	if IsValid(tr.Entity) and tr.Entity.bKeypad and tr.Entity:GetBroken() and not tr.Entity:GetHacked() then
		if SERVER then
			tr.Entity:SetHealth(tr.Entity:GetMaxHealth())
			tr.Entity:Repair()
		elseif CLIENT and IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L"KeypadRepaired", NOTIFY_GENERIC, 2)
		end
		return true
	end

	return false
end

function TOOL:Reload(tr)
	return false
end

function TOOL.BuildCPanel(CPanel)
	local L = bKeypads.L

	bKeypads:InjectSmoothScroll(CPanel)
	bKeypads:STOOLMatrix(CPanel)
	
	local Video = vgui.Create("bKeypads.DockedImage", CPanel)
	Video:SetMaterial(Material("bkeypads/keypad_breaker"))
	Video:SetAspectRatio(416 / 736)
	CPanel:AddItem(Video)

	local Help = vgui.Create("DForm", CPanel)
		Help:SetExpanded(true)
		Help:SetLabel(L"Help")
		local label = Help:Help("#tool.bkeypads_breaker.help")
		label:GetParent():DockMargin(0, 0, 0, 8)
		label:DockMargin(0, 0, 0, 0)
	CPanel:AddItem(Help)

	local Config = vgui.Create("DForm", CPanel)
		Config:SetExpanded(true)
		Config:SetLabel(L"Configuration")
		
		Config:CheckBox(L"Slant", "bkeypads_breaker_slant")
		Config:Help(L"SlantTip"):DockMargin(0, 0, 0, 0)

	CPanel:AddItem(Config)

	hook.Run("bKeypads.BuildCPanel", CPanel)
end
bKeypads_KeypadBreaker_BuildCPanel = TOOL.BuildCPanel

function TOOL:Deploy()
	self.m_Deployed = true
	if CLIENT then bKeypads.ESP:Activate() end

	self:SetStage(0)
	self:SetOperation(0)
end

function TOOL:Holster()
	self.m_Deployed = nil
	if CLIENT then bKeypads.ESP:Deactivate() end

	self:SetStage(0)
	self:SetOperation(0)
end

if CLIENT then
	function TOOL:Deployed()
		self:Deploy()
	end
	function TOOL:Holstered()
		self:Holster()
	end
end
bKeypads_Prediction(TOOL)

if CLIENT then
	local matKeypadBreaker = CreateMaterial("bkeypads_breaker", "UnlitGeneric", {
		["$basetexture"] = "bkeypads/face_id_sad",
		["$vertexcolor"] = 1,
		["$translucent"] = 1,
		["$ignorez"] = 1
	})

	function TOOL:DrawToolScreen(w,h)
		surface.SetDrawColor(bKeypads.Config.Appearance.ScreenColors.Hacked)
		surface.DrawRect(0,0,w,h)

		if not self.Matrix then
			self.Matrix = bKeypads_Matrix("STOOL_Screen", w, h)
		end
		self.Matrix:Draw(w,h)

		surface.SetDrawColor(bKeypads:DarkenForeground(bKeypads.Config.Appearance.ScreenColors.Hacked) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE)
		surface.SetMaterial(matKeypadBreaker)
		surface.DrawTexturedRect((w - (w * .75)) / 2, (h - (h * .75)) / 2, w * .75, h * .75)

		if not bKeypads.Permissions:Cached(LocalPlayer(), "tools/keypad_breaker") then
			bKeypads:ToolScreenNoPermission(w,h)
		end
	end
end
--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads_linker.lua:
TOOL.Category = "Billy's Keypads"
TOOL.Name = "#bKeypads_Linker"

TOOL.CanLinkDoors = true
TOOL.CanLinkDarkRPDoors = true
TOOL.CanLinkButtons = true
TOOL.CanLinkFadingDoors = true

TOOL.ClientConVar["map_disable"] = 1
TOOL.ClientConVar["map_hide"] = 1
TOOL.ClientConVar["map_hold"] = 0
TOOL.ClientConVar["map_toggle"] = 0
TOOL.ClientConVar["map_double_toggle"] = 0
TOOL.ClientConVar["map_redirect_use"] = 1
TOOL.ClientConVar["map_nolockpick"] = 0
TOOL.ClientConVar["map_pseudolink"] = 0
TOOL.ClientConVar["map_door_toggle"] = 0
TOOL.ClientConVar["map_door_lock"] = 1

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "select", icon = "gui/lmb.png", op = 0 },
		{ name = "switch_keypads", icon = "gui/r.png", op = 0 },

		{ name = "link_map_obj_info", icon = "gui/info", op = 1, stage = 2 },
		{ name = "link_map_obj_info", icon = "gui/info", op = 2, stage = 2 },

		{ name = "on_access_granted", icon = "gui/info", op = 1 },
		{ name = "on_access_denied", icon = "gui/info", op = 2 },

		{ name = "switch_access", icon = "gui/rmb.png", op = 1 },
		{ name = "switch_access", icon = "gui/rmb.png", op = 2 },

		{ name = "link_all", icon = "gui/lmb.png", op = 1, stage = 0 },
		{ name = "link_fading_door", icon = "gui/lmb.png", op = 1, stage = 1 },
		{ name = "link_map_obj", icon = "gui/lmb.png", op = 1, stage = 2 },

		{ name = "link_all", icon = "gui/lmb.png", op = 2, stage = 0 },
		{ name = "link_fading_door", icon = "gui/lmb.png", op = 2, stage = 1 },
		{ name = "link_map_obj", icon = "gui/lmb.png", op = 2, stage = 2 },

		{ name = "unlink_fading_door", icon = "gui/lmb.png", op = 3, stage = 0 },
		{ name = "unlink_map_obj", icon = "gui/lmb.png", op = 3, stage = 1 },
		{ name = "unlink_keypad", icon = "gui/lmb.png", op = 3, stage = 2 },
		
		{ name = "link_keypad", icon = "gui/lmb.png", op = 4 },

		{ name = "finished", icon = "gui/r.png", op = 1 },
		{ name = "finished", icon = "gui/r.png", op = 2 },
		{ name = "finished", icon = "gui/r.png", op = 3 },
		{ name = "finished", icon = "gui/r.png", op = 4 },
	}
end

function TOOL:LeftClick(tr)
	local L = bKeypads.L
	
	local FirstTimePredicted = SERVER or IsFirstTimePredicted()

	self:Think()

	local ply = self:GetOwner()
	if not IsValid(ply) then return false end

	local ent = self:GetTraceEnt()
	if bKeypads.Config.LinkingDistance > 0 and IsValid(ent) and not bKeypads.Permissions:Check(ply, "linking/max_distance") and ent:WorldSpaceCenter():DistToSqr(ply:GetPos()) > bKeypads.Config.LinkingDistance then return false end

	local op = self:GetOperation()
	local stage = self:GetStage()

	if op == 0 then

		if IsValid(ent) and ent.bKeypad then
			if FirstTimePredicted then
				self.LinkingKeypad = ent
				self:SetOperation(1)

				if CLIENT then
					bKeypads.ESP:Refresh()
					surface.PlaySound("buttons/button3.wav")
				end
			end

			return true
		end

	elseif op == 1 or op == 2 then

		-- Link
		-- 1 = Access Granted
		-- 2 = Access Denied
		if stage ~= 0 then
			if FirstTimePredicted then
				if not self:PermissionCheck(true) then return false end

				if SERVER then
					if stage == 1 then
						bKeypads.FadingDoors:Link(
							self.LinkingKeypad, self.TargetEnt,
							op == 1,
							ply
						)
					elseif stage == 2 then
						bKeypads.MapLinking:Link(
							self.LinkingKeypad, ent,
							self.AccessMode,
							tobool(self:GetClientNumber("map_pseudolink")),
							tobool(self:GetClientNumber("map_disable")),
							tobool(self:GetClientNumber("map_redirect_use")),
							tobool(self:GetClientNumber("map_hold")),
							tobool(self:GetClientNumber("map_toggle")),
							tobool(self:GetClientNumber("map_double_toggle")),
							tobool(self:GetClientNumber("map_hide")),
							tobool(self:GetClientNumber("map_nolockpick")),
							tobool(self:GetClientNumber("map_door_toggle")),
							tobool(self:GetClientNumber("map_door_lock")),
							ply
						)
					end

					if bKeypads.Persistence:IsPersisting(self.LinkingKeypad) then
						bKeypads.Persistence:CommitKeypad(self.LinkingKeypad)
					end
				end
				
				if CLIENT then
					notification.AddLegacy(L"LinkedSuccessfully", NOTIFY_GENERIC, 2)
					surface.PlaySound("buttons/button5.wav")
				end
			end

			return true
		end

	elseif op == 3 then

		-- Unlink
		if FirstTimePredicted then
			if not self:PermissionCheck(true) then return false end

			if SERVER then
				if stage == 2 then
					bKeypads.KeypadLinking:Unlink(self.LinkingKeypad, self.TargetEnt, ply)
					
					if bKeypads.Persistence:IsPersisting(self.TargetEnt) then
						bKeypads.Persistence:CommitKeypad(self.TargetEnt)
					end
				elseif stage == 0 then
					bKeypads.FadingDoors:Unlink(self.LinkingKeypad, self.TargetEnt, ply)
				elseif stage == 1 then
					bKeypads.MapLinking:Unlink(self.LinkingKeypad, self.TargetEnt, ply)
				end
				
				if bKeypads.Persistence:IsPersisting(self.LinkingKeypad) then
					bKeypads.Persistence:CommitKeypad(self.LinkingKeypad)
				end
			end
			
			if CLIENT then
				notification.AddLegacy(L"UnlinkedSuccessfully", NOTIFY_UNDO, 2)
				surface.PlaySound("buttons/button6.wav")
			end
		end

		return true

	elseif op == 4 then

		-- Link keypads
		if FirstTimePredicted then
			if not self:PermissionCheck(true) then return false end

			local canLink, source, target = bKeypads.KeypadLinking:TranslatePair(self.LinkingKeypad, self.TargetEnt)
			if not canLink then return false end

			if SERVER then
				bKeypads.KeypadLinking:Link(source, target, ply)

				if bKeypads.Persistence:IsPersisting(self.LinkingKeypad) then
					bKeypads.Persistence:CommitKeypad(self.LinkingKeypad)
				end
				if bKeypads.Persistence:IsPersisting(self.TargetEnt) then
					bKeypads.Persistence:CommitKeypad(self.TargetEnt)
				end
			end
			
			if CLIENT then
				notification.AddLegacy(L"LinkedSuccessfully", NOTIFY_GENERIC, 2)
				surface.PlaySound("buttons/button5.wav")
			end
		end

		return true

	end

	return false
end

function TOOL:RightClick(tr)
	if SERVER or IsFirstTimePredicted() then
		if self:GetOperation() == 1 then
			self:SetOperation(2)
			self.AccessMode = false
		elseif self:GetOperation() == 2 then
			self:SetOperation(1)
			self.AccessMode = true
		else
			return false
		end

		if CLIENT then
			bKeypads.ESP:Refresh()
			surface.PlaySound("weapons/pistol/pistol_empty.wav")
		end
	end

	return false
end

function TOOL:Reload(tr)
	if self:GetOperation() ~= 0 then
		if SERVER or IsFirstTimePredicted() then
			self:SetStage(0)
			self:SetOperation(0)
			self.LinkingKeypad = nil
			self.TargetEnt = nil
			self.AccessMode = true
			self.SnapToEnt = true
			self.DisableTargetESP = false

			if CLIENT then
				bKeypads.ESP:Refresh()
				surface.PlaySound("buttons/combine_button1.wav")
			end
		end
	elseif CLIENT and IsFirstTimePredicted() then
		RunConsoleCommand("gmod_tool", "bkeypads")
		surface.PlaySound("npc/combine_soldier/gear5.wav")
	end
	return false
end

local ExampleImg, Linker_CPanel = {}
do
	local frameCounts = {}
	local materials = {}
	hook.Add("DrawOverlay", "bKeypads.Linker.DrawOverlay", function()
		if not IsValid(Linker_CPanel) or not Linker_CPanel:IsVisible() or not ExampleImg.m_Material then return end

		local mat = materials[ExampleImg.m_Material]
		if not mat then
			if ExampleImg.m_Material:match("%..-$") then

				if not file.Exists("materials/" .. ExampleImg.m_Material, "GAME") then return end

				materials[ExampleImg.m_Material] = Material(ExampleImg.m_Material, "smooth")

			else

				if not file.Exists("materials/" .. ExampleImg.m_Material .. ".vtf", "GAME") then return end

				materials[ExampleImg.m_Material] = Material(ExampleImg.m_Material)

				local f = file.Open("materials/" .. ExampleImg.m_Material .. ".vtf", "rb", "GAME")
				f:Skip(24)
				frameCounts[ExampleImg.m_Material] = { f:ReadUShort(), f:ReadUShort() }
				f:Close()

			end

			mat = materials[ExampleImg.m_Material]
		end

		if frameCounts[ExampleImg.m_Material] then
			mat:SetInt("$frame", (math.floor(SysTime() - ExampleImg.m_AnimStart) + frameCounts[ExampleImg.m_Material][2]) % frameCounts[ExampleImg.m_Material][1])
		end

		local w, h = mat:Width(), mat:Height()

		local _ScrW, _ScrH = ScrW(), ScrH()
		render.SetViewPort(math.min((Linker_CPanel:LocalToScreen(-w + 10, 0)), ScrW() - w), math.min(gui.MouseY() - (181 / 2), ScrH() - 181), w, 181)
			cam.Start2D()
				surface.SetDrawColor(255, 255, 255)
				surface.SetMaterial(mat)
				surface.DrawTexturedRect((ScrW() - w) / 2, 0, w, h)
			cam.End2D()
		render.SetViewPort(0, 0, _ScrW, _ScrH)
	end)
end

function TOOL.BuildCPanel(CPanel)
	Linker_CPanel = CPanel
	
	local L = bKeypads.L

	bKeypads:InjectSmoothScroll(CPanel)
	bKeypads:STOOLMatrix(CPanel)

	CPanel.HelpCategory = vgui.Create("DForm", CPanel)
	CPanel.HelpCategory:SetLabel(L"Help")
	CPanel.HelpCategory:SetExpanded(cookie.GetNumber("bkeypads_linking_help_viewed", 0) == 0)
	CPanel.HelpCategory.OnToggle = function(self)
		if not self:GetExpanded() then
			cookie.Set("bkeypads_linking_help_viewed", 1)
		end
	end

		CPanel.HelpCategory:Help(L"LinkerHelp"):DockMargin(0, 0, 0, 0)

		CPanel.Tutorial = vgui.Create("DButton", CPanel)
		CPanel.Tutorial:SetText(L"Tutorial")
		CPanel.Tutorial:SetIcon("icon16/emoticon_grin.png")
		CPanel.Tutorial:SetTall(25)
		CPanel.Tutorial.DoClick = function()
			bKeypads.Tutorial:OpenMenu()
		end

		CPanel.HelpCategory:AddItem(CPanel.Tutorial)
	
	CPanel:AddItem(CPanel.HelpCategory)
	
	CPanel.MapLinkingCategory = vgui.Create("DForm", CPanel)
	CPanel.MapLinkingCategory:SetExpanded(false)
	CPanel.MapLinkingCategory:SetLabel(L"MapLinking")
		
		CPanel.MapLinkingCategory.General = vgui.Create("DForm", CPanel)
		CPanel.MapLinkingCategory.General:SetLabel(L"General")
		
		CPanel.MapLinkingCategory.Doors = vgui.Create("DForm", CPanel)
		CPanel.MapLinkingCategory.Doors:SetLabel(L"Doors")
		
		CPanel.MapLinkingCategory.Buttons = vgui.Create("DForm", CPanel)
		CPanel.MapLinkingCategory.Buttons:SetLabel(L"Buttons")

		do
			local PseudoMapLink = CPanel.MapLinkingCategory.General:CheckBox(L"PseudoMapLink", "bkeypads_linker_map_pseudolink")
			PseudoMapLink.ExampleImg = "bkeypads/map_linking/pseudo"
			PseudoMapLink.Tip = CPanel.MapLinkingCategory.General:Help(L"PseudoMapLinkTip")
			bKeypads:AddShieldIcon(PseudoMapLink)

			local DisableMapObj = CPanel.MapLinkingCategory.General:CheckBox(L"DisableMapObj", "bkeypads_linker_map_disable")
			DisableMapObj.ExampleImg = "bkeypads/map_linking/disable.png"
			DisableMapObj.Tip = CPanel.MapLinkingCategory.General:Help(L"DisableMapObjTip")
			bKeypads:AddShieldIcon(DisableMapObj)

			local MapRedirectUse = CPanel.MapLinkingCategory.General:CheckBox(L"MapRedirectUse", "bkeypads_linker_map_redirect_use")
			MapRedirectUse.ExampleImg = "bkeypads/map_linking/redirect_use"
			MapRedirectUse.Tip = CPanel.MapLinkingCategory.General:Help(L"MapRedirectUseTip")
			bKeypads:AddShieldIcon(MapRedirectUse)

			local HideMapObj = CPanel.MapLinkingCategory.Buttons:CheckBox(L"HideMapObj", "bkeypads_linker_map_hide")
			HideMapObj.ExampleImg = "bkeypads/map_linking/hide"
			HideMapObj.Tip = CPanel.MapLinkingCategory.Buttons:Help(L"HideMapObjTip")
			bKeypads:AddShieldIcon(HideMapObj)

			local MapHold = CPanel.MapLinkingCategory.Buttons:CheckBox(L"MapHold", "bkeypads_linker_map_hold")
			MapHold.ExampleImg = "bkeypads/map_linking/hold"
			MapHold.Tip = CPanel.MapLinkingCategory.Buttons:Help(L"MapHoldTip")

			local MapToggle = CPanel.MapLinkingCategory.Buttons:CheckBox(L"MapToggle", "bkeypads_linker_map_toggle")
			MapToggle.ExampleImg = "bkeypads/map_linking/toggle"
			MapToggle.Tip = CPanel.MapLinkingCategory.Buttons:Help(L"MapToggleTip")

			local MapDoubleToggle = CPanel.MapLinkingCategory.Buttons:CheckBox(L"MapDoubleToggle", "bkeypads_linker_map_double_toggle")
			MapDoubleToggle.ExampleImg = "bkeypads/map_linking/double_toggle"
			MapDoubleToggle.Tip = CPanel.MapLinkingCategory.Buttons:Help(L"MapDoubleToggleTip")

			local MapDoorLock = CPanel.MapLinkingCategory.Doors:CheckBox(L"DoorLock", "bkeypads_linker_map_door_lock")
			MapDoorLock.Tip = CPanel.MapLinkingCategory.Doors:Help(L"DoorLockTip")

			local MapDoorToggle = CPanel.MapLinkingCategory.Doors:CheckBox(L"MapToggle", "bkeypads_linker_map_door_toggle")
			MapDoorToggle.Tip = CPanel.MapLinkingCategory.Doors:Help(L"MapDoorToggleTip")

			local MapPreventLockpick = CPanel.MapLinkingCategory.Doors:CheckBox(L"MapPreventLockpick", "bkeypads_linker_map_nolockpick")
			MapPreventLockpick.Tip = CPanel.MapLinkingCategory.Doors:Help(L"MapPreventLockpickTip")
			bKeypads:AddShieldIcon(MapPreventLockpick)

			local checkboxes = { DisableMapObj, HideMapObj, MapRedirectUse, PseudoMapLink, MapHold, MapToggle, MapDoubleToggle, MapPreventLockpick, MapDoorToggle, MapDoorLock }

			local rules = {
				[PseudoMapLink] = { MapHold, MapToggle, MapDoubleToggle, MapDoorToggle },
				[MapHold] = { MapToggle, MapDoubleToggle },
				[MapToggle] = { MapHold, MapDoubleToggle },
				[MapDoubleToggle] = { MapHold, MapToggle },
				[DisableMapObj] = { MapPreventLockpick },
			}
			local permissions = {
				[MapPreventLockpick] = "linking/darkrp_prevent_lockpick",
				[PseudoMapLink] = "linking/pseudolink",
				[DisableMapObj] = "linking/disable_map_objects",
				[MapRedirectUse] = "linking/redirect_use",
				[HideMapObj] = "linking/hide_map_object",
			}

			local function ExampleTipImgHover(self)
				ExampleImg.m_Material = self.ExampleImg
				ExampleImg.m_AnimStart = SysTime()
			end
			local function ExampleTipImgRemove(self)
				ExampleImg.m_Material = nil
			end

			for _, control in ipairs(checkboxes) do
				control.Tip:GetParent():DockMargin(0, 0, 0, 8)
				control.Tip:DockMargin(0, 0, 0, 0)

				control.OnChange = bKeypads.ESP.Refresh

				control.Tip.ExampleImg = control.ExampleImg
				control.Label.ExampleImg = control.ExampleImg
				control.Button.ExampleImg = control.ExampleImg
				control:GetParent().ExampleImg = control.ExampleImg

				control:GetParent().OnCursorEntered = ExampleTipImgHover
				control:GetParent().OnCursorExited = ExampleTipImgRemove

				control.Tip:GetParent().OnCursorEntered = ExampleTipImgHover
				control.Tip:GetParent().OnCursorExited = ExampleTipImgRemove
				control.Tip:GetParent().ExampleImg = control.ExampleImg

				control.Tip.OnCursorEntered = ExampleTipImgHover
				control.Tip.OnCursorExited = ExampleTipImgRemove

				control.OnCursorEntered = ExampleTipImgHover
				control.OnCursorExited = ExampleTipImgRemove

				control.Label.OnCursorEntered = ExampleTipImgHover
				control.Label.OnCursorExited = ExampleTipImgRemove

				control.Button.OnCursorEntered = ExampleTipImgHover
				control.Button.OnCursorExited = ExampleTipImgRemove
			end

			local disabledText = Color(0,0,0,100)
			local enabledText  = Color(0,0,0,255)
			CPanel.bKeypads_Think = CPanel.bKeypads_Think or CPanel.Think
			CPanel.Think = function()
				if CPanel.bKeypads_Think then CPanel:bKeypads_Think() end

				local disabled = {}
				for _, checkbox in ipairs(checkboxes) do
					local permission = permissions[checkbox]
					if permission and not bKeypads.Permissions:Cached(LocalPlayer(), permission) then
						disabled[checkbox] = true
						continue
					end

					local rule = rules[checkbox]
					if checkbox:GetChecked() and rule then
						for _, checkbox in ipairs(rule) do
							disabled[checkbox] = true
						end
						continue
					end
				end
				for _, checkbox in ipairs(checkboxes) do
					local disabled = disabled[checkbox] == true
					checkbox:SetDisabled(disabled)
					checkbox.Tip:SetTextColor(disabled and disabledText or enabledText)
					if disabled and checkbox:GetChecked() then
						checkbox:SetChecked(false)
					end
				end
			end
		end

		CPanel.MapLinkingCategory:AddItem(CPanel.MapLinkingCategory.General)
		CPanel.MapLinkingCategory:AddItem(CPanel.MapLinkingCategory.Doors)
		CPanel.MapLinkingCategory:AddItem(CPanel.MapLinkingCategory.Buttons)

		local padding = vgui.Create("DPanel", CPanel.MapLinkingCategory)
		padding:Dock(TOP)
		padding:SetTall(0)
		padding.Paint = nil
		CPanel.MapLinkingCategory:AddItem(padding)
	
	CPanel:AddItem(CPanel.MapLinkingCategory)
	
	hook.Run("bKeypads.BuildCPanel", CPanel)
end

function TOOL:Deploy()
	self:SetStage(0)
	self:SetOperation(0)

	self.LinkingKeypad = nil
	self.TargetEnt = nil
	self.AccessMode = true
	self.SnapToEnt = true
	self.DisableTargetESP = false
end

if CLIENT then
	function TOOL:Deployed()
		self:Deploy()
		bKeypads.ESP:Activate()
	end

	function TOOL:Holstered()
		bKeypads.ESP:Deactivate()
	end
end
bKeypads_Prediction(TOOL)

function TOOL:PermissionCheck(skipCache)
	if skipCache then
		if not bKeypads.Permissions:Check(self:GetOwner(), "create_keypads") then return false end

		if IsValid(self.TargetEnt) then
			if self.FadingDoorLinking then
				return bKeypads.Permissions:Check(self:GetOwner(), "fading_doors/create")
			elseif self.KeypadLinking then
				return self.CanLinkKeypads
			elseif self.MapLinking then
				if bKeypads.MapLinking:IsDoor(self.TargetEnt) then
					if (
						bKeypads.Permissions:Check(self:GetOwner(), "linking/doors") or
						(DarkRP and bKeypads.Permissions:Check(self:GetOwner(), "linking/darkrp_doors") and self.TargetEnt.isKeysOwnedBy and self.TargetEnt:isKeysOwnedBy(self:GetOwner()))
					) then
						return true
					end
					return false
				elseif bKeypads.MapLinking:IsSandboxButton(self.TargetEnt) then
					return bKeypads.Permissions:Check(self:GetOwner(), "linking/gmod_button")
				elseif bKeypads.MapLinking:IsMapButton(self.TargetEnt) then
					return bKeypads.Permissions:Check(self:GetOwner(), "linking/buttons")
				end
			end
		end
	else
		if not self.CanLink then return false end
		
		if IsValid(self.TargetEnt) then
			if self.FadingDoorLinking then
				return self.CanLinkFadingDoors
			elseif self.KeypadLinking then
				return self.CanLinkKeypads
			elseif self.MapLinking then
				if bKeypads.MapLinking:IsDoor(self.TargetEnt) then
					if (
						self.CanLinkDoors or
						(self.CanLinkDarkRPDoors and self.TargetEnt.isKeysOwnedBy and self.TargetEnt:isKeysOwnedBy(self:GetOwner()))
					) then
						return true
					end
					return false
				elseif bKeypads.MapLinking:IsSandboxButton(self.TargetEnt) then
					return self.CanLinkSandboxButtons
				elseif bKeypads.MapLinking:IsMapButton(self.TargetEnt) then
					return self.CanLinkButtons
				end
			end
		end
	end
	
	return true
end

local LINKABLE_FADING_DOOR = 0
local LINKABLE_MAP_LINK    = 1
local LINKABLE_KEYPAD      = 2
local function GetLinkableEntType(ent)
	if not IsValid(ent) then return end
	if ent.bKeypad then
		return ent, LINKABLE_KEYPAD
	elseif bKeypads.FadingDoors:IsFadingDoor(ent) then
		return ent, LINKABLE_FADING_DOOR
	elseif bKeypads.MapLinking:IsLinkEntity(ent) then
		return ent, LINKABLE_MAP_LINK
	end
end

if SERVER then
	util.AddNetworkString("bKeypads.Linker.TraceEnt")
else
	net.Receive("bKeypads.Linker.TraceEnt", function()
		local tool = LocalPlayer():GetTool("bkeypads_linker")
		if tool then
			tool.m_eServerTraceEnt = net.ReadBool() and net.ReadEntity() or NULL
		end
	end)
end
function TOOL:ResolveTraceEnt()
	local ply = self:GetOwner()
	local tr = ply:GetEyeTrace()

	if SERVER then
		local linkEnt = (IsValid(tr.Entity) and tr.Entity) or (self.m_iFindUseEntityTick ~= nil and self.m_iFindUseEntityTick == engine.TickCount() and IsValid(self.m_eFindUseEntity) and self.m_eFindUseEntity) or (IsValid(ply:GetUseEntity()) and ply:GetUseEntity()) or nil
		if self.m_eServerTraceEnt ~= linkEnt then
			net.Start("bKeypads.Linker.TraceEnt")
				if IsValid(linkEnt) then
					self.m_eServerTraceEnt = linkEnt
					net.WriteBool(true)
					net.WriteEntity(linkEnt)
				else
					self.m_eServerTraceEnt = nil
					net.WriteBool(false)
					net.WriteEntity(linkEnt)
				end
			net.Send(ply)
		end
	elseif IsValid(tr.Entity) then
		return tr.Entity
	end
	
	return self.m_eServerTraceEnt
end
function TOOL:GetTraceEnt()
	return GetLinkableEntType(self:ResolveTraceEnt())
end

function TOOL:Think()
	self.CanLink = bKeypads.Permissions:Cached(self:GetOwner(), "create_keypads")
	if self.CanLink then
		self.CanLinkDoors = bKeypads.Permissions:Cached(self:GetOwner(), "linking/doors")
		self.CanLinkDarkRPDoors = DarkRP and bKeypads.Permissions:Cached(self:GetOwner(), "linking/darkrp_doors")
		self.CanLinkButtons = bKeypads.Permissions:Cached(self:GetOwner(), "linking/buttons")
		self.CanLinkSandboxButtons = bKeypads.Permissions:Cached(self:GetOwner(), "linking/gmod_button")
		self.CanLinkFadingDoors = bKeypads.Permissions:Cached(self:GetOwner(), "fading_doors/create")
		self.CanLinkKeypads = bKeypads.Permissions:Cached(self:GetOwner(), "linking/link_keypads")
		self.CanLink = self.CanLinkDoors or self.CanLinkDarkRPDoors or self.CanLinkButtons or self.CanLinkFadingDoors or self.CanLinkSandboxButtons
	end

	if
		self.LinkingKeypad ~= nil and (not IsValid(self.LinkingKeypad) or (bKeypads.Config.LinkingDistance > 0 and not bKeypads.Permissions:Cached(self:GetOwner(), "linking/max_distance") and self.LinkingKeypad:WorldSpaceCenter():DistToSqr(self:GetOwner():GetPos()) > bKeypads.Config.LinkingDistance)) or
		self.TargetEnt ~= nil and (not IsValid(self.TargetEnt) or (bKeypads.Config.LinkingDistance > 0 and not bKeypads.Permissions:Cached(self:GetOwner(), "linking/max_distance") and self.TargetEnt:WorldSpaceCenter():DistToSqr(self:GetOwner():GetPos()) > bKeypads.Config.LinkingDistance))
	then
		self.LinkingKeypad = nil
		self:SetOperation(0)
		self:SetStage(0)
		self.TargetEnt = nil
		self.SnapToEnt = true
		self.DisableTargetESP = false
		self.MapLinking = false
		self.FadingDoorLinking = false
		self.KeypadLinking = false
	end
	
	local op = self:GetOperation()
	if op == 1 or op == 2 or op == 3 or op == 4 then
		local ent, entType = self:GetTraceEnt()
		if ent and ent ~= self.LinkingKeypad then
			if entType == LINKABLE_FADING_DOOR then
				if bKeypads.FadingDoors:IsLinked(ent, self.LinkingKeypad) then
					self:SetOperation(3)
					self:SetStage(0)
					self.TargetEnt = ent
					self.SnapToEnt = true
					self.DisableTargetESP = true
				else
					self:SetOperation(self.AccessMode and 1 or 2)
					self:SetStage(1)
					self.TargetEnt = ent
					self.SnapToEnt = false
					self.DisableTargetESP = false
				end
				self.MapLinking = false
				self.FadingDoorLinking = true
				self.KeypadLinking = false
				return
			elseif not bKeypads.Config.KeypadOnlyFadingDoors or bKeypads.Permissions:Cached(self:GetOwner(), "keypads/bypass_keypad_only_fading_doors") then
				if entType == LINKABLE_MAP_LINK then
					local unlink = bKeypads.MapLinking:IsLinked(self.LinkingKeypad, ent)
					self:SetOperation(unlink and 3 or (self.AccessMode and 1 or 2))
					self:SetStage(unlink and 1 or 2)
					self.TargetEnt = ent
					self.SnapToEnt = true
					self.DisableTargetESP = unlink
					self.MapLinking = true
					self.FadingDoorLinking = false
					self.KeypadLinking = false
					return
				elseif entType == LINKABLE_KEYPAD then
					local canLink = bKeypads.KeypadLinking:TranslatePair(self.LinkingKeypad, ent)
					if canLink then
						local unlink = self.LinkingKeypad:LinkProxy() == ent:LinkProxy()
						self:SetOperation(unlink and 3 or 4)
						self:SetStage(unlink and 2 or 0)
						self.TargetEnt = ent
						self.SnapToEnt = true
						self.DisableTargetESP = false
						self.MapLinking = false
						self.FadingDoorLinking = false
						self.KeypadLinking = true
						return
					end
				end
			end
		end

		self:SetOperation(self.AccessMode and 1 or 2)
		self:SetStage(0)
		self.TargetEnt = nil
		self.SnapToEnt = true
		self.DisableTargetESP = false
		self.MapLinking = false
		self.FadingDoorLinking = false
		self.KeypadLinking = false
	end
end

if CLIENT then
	local matKeypadLinker = Material("bkeypads/linker")
	function TOOL:DrawToolScreen(w,h)
		surface.SetDrawColor(0,150,255)
		surface.DrawRect(0,0,w,h)

		if not self.Matrix then
			self.Matrix = bKeypads_Matrix("STOOL_Screen", w, h)
		end
		self.Matrix:Draw(w,h)

		surface.SetMaterial(matKeypadLinker)
		surface.DrawTexturedRect(0, 0, w, h)

		if self.CanLinkDoors == false and self.CanLinkFadingDoors == false and self.CanLinkButtons == false and self.CanLinkDarkRPDoors == false then
			bKeypads:ToolScreenNoPermission(w,h)
		elseif IsValid(self.TargetEnt) and not self:PermissionCheck() then
			bKeypads:ToolScreenNoPermissionEnt(w,h)
		end
	end

	local matLink = Material("bkeypads/link.png", "noclamp smooth")
	local matUnlink = Material("bkeypads/unlink.png", "noclamp smooth")
	function TOOL:DrawHUD()
		local op, stage, mapLinks = self:GetOperation(), self:GetStage()
		if (op == 4 or op == 3 or ((op == 1 or op == 2) and stage > 0)) then
			local L = bKeypads.L

			local y = (ScrH() / 2) + 20

			local colorFlash = math.Remap(math.cos(SysTime() * math.pi), -1, 1, 0, 1) * 255

			if op == 3 then
				surface.SetTextColor(255, colorFlash, colorFlash)
				surface.SetDrawColor(255, colorFlash, colorFlash)
			else
				surface.SetDrawColor(colorFlash, 255, colorFlash)
				surface.SetTextColor(colorFlash, 255, colorFlash)
			end
			bKeypads:DrawSubpixelClippedMaterial(
				op == 3 and matUnlink or matLink,
				(ScrW() - 24) / 2, y, 24, 24
			)

			y = y + 24

			surface.SetFont("BudgetLabel")

			local txt = 
				(
					op == 4 and L"LinkTypeKeypad"
				) or
				(
					(op == 1 or op == 2) and
					(
						(stage == 1 and L"LinkTypeFadingDoor") or
						(
							stage == 2 and IsValid(self.TargetEnt) and (
								(bKeypads.MapLinking:IsDoor(self.TargetEnt) and L"LinkTypeDoor") or
								(bKeypads.MapLinking:IsButton(self.TargetEnt) and L"LinkTypeButton") or
								L"LinkTypeMap"
							)
						)
					)
				) or
				(
					op == 3 and (
						(stage == 0 and L"LinkTypeFadingDoor") or
						(
							stage == 1 and IsValid(self.TargetEnt) and (
								(bKeypads.MapLinking:IsDoor(self.TargetEnt) and L"LinkTypeDoor") or
								(bKeypads.MapLinking:IsButton(self.TargetEnt) and L"LinkTypeButton")
								or L"LinkTypeMap"
							)
						)
					) or
					(stage == 2 and L"LinkTypeKeypad")
				)
			if txt then
				local w, h = surface.GetTextSize(txt)
				y = y + 10
				surface.SetTextPos((ScrW() - w) / 2, y)
				surface.DrawText(txt)
				y = y + h
			end

			local accessType
			if op == 1 or op == 2 then
				accessType = op == 1
			elseif op == 3 and IsValid(self.TargetEnt) then
				if stage ~= 0 then mapLinks = mapLinks or bKeypads.MapLinking:GetLinks(self.LinkingKeypad) end
				local links = stage == 0 and bKeypads.FadingDoors:GetLinks(self.LinkingKeypad) or mapLinks
				if links and links[self.TargetEnt] then
					local link = select(2, next(links[self.TargetEnt]))
					if IsValid(link) then
						accessType = link:GetAccessType()
					end
				end
			end
			if accessType ~= nil then
				if accessType then
					surface.SetTextColor(colorFlash, 255, colorFlash)
				else
					surface.SetTextColor(255, colorFlash, colorFlash)
				end
				local txt = accessType and L"AccessGranted" or L"AccessDenied"
				local w, h = surface.GetTextSize(txt)
				surface.SetTextPos((ScrW() - w) / 2, y)
				surface.DrawText(txt)
				y = y + h
			end

			if self.MapLinking then
				local pseudolink = false

				if op == 1 or op == 2 then
					pseudolink = self:GetClientNumber("map_pseudolink") == 1
				else
					mapLinks = mapLinks or bKeypads.MapLinking:GetLinks(self.LinkingKeypad)
					if mapLinks and mapLinks[self.TargetEnt] then
						local link = select(2, next(mapLinks[self.TargetEnt]))
						if IsValid(link) and link:HasGeneralFlag(bKeypads.MapLinking.F_PSEUDOLINK) then
							pseudolink = true
						end
					end
				end

				if pseudolink then
					local txt = L"PseudoMapLink"
					local w = surface.GetTextSize(txt)
					surface.SetTextColor(255, 0, 255)
					surface.SetTextPos((ScrW() - w) / 2, y)
					surface.DrawText(txt)
				end
			end
		end
	end
	
	local matUnlinkBox = Material("bkeypads/diagonal")
	local matUnlinkBoxColor = Color(255, 255, 255)
	hook.Add("PreDrawTranslucentRenderables", "bKeypads.Linker.DrawUnlinkBox", function(_, skybox)
		if skybox then return end
		if bKeypads.Performance:Optimizing() then return end
		
		local tool = LocalPlayer():GetTool()
		if tool and tool.Mode == "bkeypads_linker" and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gmod_tool" and tool:GetOperation() == 3 and IsValid(tool.TargetEnt) then

			bKeypads.cam.IgnoreZ(true)

				local alpha = math.Remap(math.sin(SysTime() * 5), -1, 1, 0, .25)
				render.SetBlend(alpha)

				render.ModelMaterialOverride(matUnlinkBox)

					if tool:GetStage() == 2 then
						local source, target = select(2, bKeypads.KeypadLinking:TranslatePair(tool.LinkingKeypad, tool.TargetEnt))

						source.m_ForceSupressEngineLighting = true
						target.m_ForceSupressEngineLighting = true

							target:SetupBones()
							target:DrawModel()

							source:SetupBones()
							source:DrawModel()

						source.m_ForceSupressEngineLighting = false
						target.m_ForceSupressEngineLighting = false
					else
						tool.TargetEnt.m_ForceSupressEngineLighting = true
						tool.LinkingKeypad.m_ForceSupressEngineLighting = true
							
							if bKeypads.FadingDoors:IsFadingDoor(tool.TargetEnt) then
								tool.TargetEnt:SetupBones()
								tool.TargetEnt:DrawModel()
							else
								matUnlinkBoxColor.a = 255 * alpha
								render.SetMaterial(matUnlinkBox)
								render.DrawBox(tool.TargetEnt:GetPos(), tool.TargetEnt:GetAngles(), tool.TargetEnt:OBBMins(), tool.TargetEnt:OBBMaxs(), matUnlinkBoxColor, true)
							end

							tool.LinkingKeypad:SetupBones()
							tool.LinkingKeypad:DrawModel()

						tool.TargetEnt.m_ForceSupressEngineLighting = false
						tool.LinkingKeypad.m_ForceSupressEngineLighting = false
					end

				render.ModelMaterialOverride(nil)

			bKeypads.cam.IgnoreZ(false)

		end
	end)
end

-- Small hack to allow client to modify operation and stage
function TOOL:SetOperation(i)
	if CLIENT then
		self.m_Operation = i
	end
	self:GetWeapon():SetNWInt("Op", i, true)
end
function TOOL:GetOperation()
	if CLIENT and self.m_Operation then
		return self.m_Operation
	end
	return self:GetWeapon():GetNWInt("Op", 0)
end
function TOOL:SetStage(i)
	if CLIENT then
		self.m_Stage = i
	end
	self:GetWeapon():SetNWInt("Stage", i, true)
end
function TOOL:GetStage()
	if CLIENT and self.m_Stage then
		return self.m_Stage
	end
	return self:GetWeapon():GetNWInt("Stage", 0)
end
--addons/npc_droppod_tool/lua/weapons/gmod_tool/stools/dispenser_tool.lua:
TOOL.Category = "CW:RP"
TOOL.Name = "Drop Pod - Spawner"

if CLIENT then
	language.Add("Tool.dispenser_tool.name", "Drop Pod - Spawner")
	language.Add("Tool.dispenser_tool.desc", "Fülle die Felder aus und klicke mit der linken Maustaste auf die Stelle, an welcher der Pot spawnen soll!")
	language.Add("Tool.dispenser_tool.0", "")
end

local AllVars = {
	MinSpawnTime = "3",
	MaxSpawnTime = "8",
	NPCHealth = "1000",
	DispenserHealth = "1000",
	NPCAmount = "5",
	NPCType = "B1 Droide",
	Precision = 0.5
}

table.Merge(TOOL.ClientConVar, AllVars)

function TOOL:LeftClick(tr)
	if not tr.HitPos then return end

	if SERVER then
		local BringPod = ents.Create("toods_dispenser")
		self:AssignVars(BringPod)
		BringPod:SetModel("models/niksacokica/tech/tech_droid_pod_main.mdl")
		BringPod:PhysicsInit(SOLID_VPHYSICS) -- Need to do physics here because it doesn't recognize the physics in the init.lua -_-
		BringPod:SetMoveType(MOVETYPE_VPHYSICS)
		BringPod:SetSolid(SOLID_VPHYSICS)
		BringPod:SetPos(tr.HitPos + Vector(0, 0, 2000))
		BringPod:Spawn()
		BringPod:Activate()

		undo.Create("Dispenser")
			undo.AddEntity(BringPod)
			undo.SetPlayer(self:GetOwner())
			undo.SetCustomUndoText("Drop Pod Removed!")
		undo.Finish()
	end

	return true
end

function TOOL:AssignVars(Pod)
	for k, v in pairs(AllVars) do
		Pod:SetKeyValue(k, self:GetClientInfo(k))
	end
end

local FindCVars = TOOL:BuildConVarList()

function TOOL.BuildCPanel(pnl)
	pnl:SetName("Drop Pod - Spawner")

	-------------------------------------------------------------------------------------------------------
	pnl:AddControl("Header", {
		Text = "Drop Pod - Spawner",
		Description = "Fülle die Felder aus und klicke mit der linken Maustaste auf die Stelle, an welcher der Pot spawnen soll!"
	})

	-------------------------------------------------------------------------------------------------------
	pnl:AddControl("ComboBox", {
		MenuButton = 1,
		Folder = "dispenser_tool",
		Options = {
			["#preset.default"] = FindCVars
		},
		CVars = table.GetKeys(FindCVars)
	})

	-------------------------------------------------------------------------------------------------------
	pnl:NumSlider("Min Spawn Time", "dispenser_tool_MinSpawnTime", 1, 5, 0)
	pnl:ControlHelp("Wie lange dauert es, bis die NPCs auftauchen.")
	-------------------------------------------------------------------------------------------------------
	pnl:NumSlider("Max Spawn Time", "dispenser_tool_MaxSpawnTime", 6, 15, 0)
	pnl:ControlHelp("Wie lange es dauert, bis der letzte NPC erscheint.")
	-------------------------------------------------------------------------------------------------------
	pnl:NumSlider("NPC Health", "dispenser_tool_NPCHealth", 1, 1000, 0)
	pnl:ControlHelp("Wie viele HP die NPCs haben sollen.")
	-------------------------------------------------------------------------------------------------------
	pnl:NumSlider("Drop Pod Health", "dispenser_tool_DispenserHealth", 1000, 10000, 0)
	pnl:ControlHelp("Wie viele HP das Pod haben soll.")
	-------------------------------------------------------------------------------------------------------
	-- if you increase the max value of 20 then you need to add more vectors inside the init.lua file of the entity.
	pnl:NumSlider("NPC Amount", "dispenser_tool_NPCAmount", 1, 10, 0)
	pnl:ControlHelp("Wie viele NPCs aus dem Pod erscheinen sollen.")
	-------------------------------------------------------------------------------------------------------
	local NPCType = pnl:ComboBox("NPC Type", "dispenser_tool_NPCType")
	NPCType:AddChoice("B1 Droide")
	NPCType:AddChoice("B1 Droide (Granaten)")
	NPCType:AddChoice("B1 Droide Heavy")
	NPCType:AddChoice("B2 Superkampfdroide")
	NPCType:AddChoice("Kommando Droide")
	-------------------------------------------------------------------------------------------------------
	pnl:NumSlider("Precision", "dispenser_tool_Precision", 0.1, 1, 2)
	pnl:ControlHelp("Wie hoch die Präzision der Droiden sein soll.")
end
--lua/weapons/gmod_tool/stools/elevator.lua:
AddCSLuaFile();

TOOL.Category = "Construction"
TOOL.Name = "Elevators"
TOOL.ClientConVar["up"] = "100";
TOOL.ClientConVar["right"] = "0";
TOOL.ClientConVar["forward"] = "0";
TOOL.ClientConVar["speed"] = "70";
TOOL.ClientConVar["local"] = "1";
TOOL.ClientConVar["movesound"] = "Elevators.HeavyMetal";
TOOL.ClientConVar["stopsound"] = "Elevators.Stop.HeavyMetal";
TOOL.ClientConVar["keystart"] = "0";
TOOL.ClientConVar["keyreturn"] = "0";
TOOL.ClientConVar["blockdamage"] = "0";
TOOL.ClientConVar["allowuse"] = "0";
TOOL.ClientConVar["shake"] = "1";

TOOL.Information = {
	{name = "left", stage = 0},
	{name = "right", stage = 0},
};

cleanup.Register("elevators");

if (SERVER) then
	if (!ConVarExists("sbox_maxelevators")) then
		CreateConVar("sbox_maxelevators", 5, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Maximum number of elevators which can be created by users.");
	end;

	numpad.Register("ElevatorStart", function(player, elevator)
		if (!IsValid(elevator)) then return false; end;

		elevator:Fire("Open");
	end);

	numpad.Register("ElevatorReturn", function(player, elevator)
		if (!IsValid(elevator)) then return false; end;

		elevator:Fire("Close");
	end);
end;

/*
	Elevator Creation
*/

function TOOL:LeftClick(trace)
	if (self:GetStage() == 1) then return self:RightClick(trace); end;
	if (!IsValid(trace.Entity)) then return false; end;
	if (trace.Entity:IsPlayer()) then return false; end;
	if (CLIENT) then return true; end;

	if (trace.Entity:GetClass() == "prop_physics") then
		if (!self:GetOwner():CheckLimit("elevators")) then return false; end;
		local bUseLocalAng = tobool(self:GetClientInfo("local"));
		local baseAng = trace.Entity:GetAngles();

		if (!bUseLocalAng) then
			baseAng = angle_zero;
		end;

		local ent = trace.Entity;

		local elevator = ents.Create("elevator");
		elevator:SetPos(ent:GetPos());
		elevator:SetAngles(ent:GetAngles());
		elevator.Model = ent:GetModel();
		elevator:Spawn();

		elevator:SetMoveSound(self:GetClientInfo("movesound"));
		elevator:SetStopSound(self:GetClientInfo("stopsound"));

		elevator:SetMoveSpeed(math.Clamp(tonumber(self:GetClientInfo("speed")), 1, 500));

		elevator:SetBlockDamage(math.Clamp(tonumber(self:GetClientInfo("blockdamage")), 0, 100));

		elevator:SetAllowUse(tobool(self:GetClientInfo("allowuse")));

		elevator:SetShake(tobool(self:GetClientInfo("shake")));

		elevator:GetDoor():SetMaterial(ent:GetMaterial());
		elevator:GetDoor():SetColor(ent:GetColor());

		elevator:SetStart(ent:GetPos());
		elevator:SetEnd(ent:GetPos() + baseAng:Right() * tonumber(self:GetClientInfo("right")) + baseAng:Up() * tonumber(self:GetClientInfo("up")) + baseAng:Forward() * tonumber(self:GetClientInfo("forward")));

		elevator:GetDoor().StartButton = numpad.OnDown(self:GetOwner(), tonumber(self:GetClientInfo("keystart")), "ElevatorStart", elevator:GetDoor());
		elevator:GetDoor().ReturnButton = numpad.OnDown(self:GetOwner(), tonumber(self:GetClientInfo("keyreturn")), "ElevatorReturn", elevator:GetDoor());
		elevator:GetDoor().b1 = tonumber(self:GetClientInfo("keystart"));
		elevator:GetDoor().b2 = tonumber(self:GetClientInfo("keyreturn"));

		elevator:GetDoor().parts = {};

		for k, v in pairs(constraint.GetAllConstrainedEntities(ent)) do
			if (IsValid(v) and v != ent and constraint.Find(ent, v, "Weld", 0, 0)) then
				if (v:GetClass() == "prop_physics") then
					local prop = ents.Create("prop_physics");
					prop:SetPos(v:GetPos());
					prop:SetAngles(v:GetAngles());
					prop:SetMaterial(v:GetMaterial());
					prop:SetRenderMode(v:GetRenderMode());
					prop:SetColor(v:GetColor());
					prop:SetModel(v:GetModel());
					SafeRemoveEntity(v);
					prop:Spawn();
					prop:SetParent(elevator:GetDoor());
					prop:GetPhysicsObject():EnableMotion(false);

					table.insert(elevator:GetDoor().parts, {
						origin = elevator:GetDoor():WorldToLocal(v:GetPos()),
						angles = elevator:GetDoor():WorldToLocalAngles(v:GetAngles()),
						material = v:GetMaterial(),
						model = v:GetModel(),
						rendermode = v:GetRenderMode(),
						color = v:GetColor()
					});
				else
					v:SetParent(elevator:GetDoor());
				end;
			end;
		end;

		SafeRemoveEntity(ent);

		undo.Create("Elevator");
		undo.AddEntity(elevator);
		undo.SetPlayer(self:GetOwner());
		undo.SetCustomUndoText("Undone Elevator");
		undo.Finish();

		self:GetOwner():AddCount("elevators", elevator);
		self:GetOwner():AddCleanup("elevators", elevator);

		return true;
	elseif (trace.Entity:GetClass() == "func_movelinear" and IsValid(trace.Entity.parent)) then
		local parent = trace.Entity.parent;

		parent:SetMoveSound(self:GetClientInfo("movesound"));
		parent:SetStopSound(self:GetClientInfo("stopsound"));

		parent:SetMoveSpeed(math.Clamp(tonumber(self:GetClientInfo("speed")), 1, 500));

		parent:SetBlockDamage(math.Clamp(tonumber(self:GetClientInfo("blockdamage")), 0, 100));

		parent:SetAllowUse(tobool(self:GetClientInfo("allowuse")));

		parent:SetShake(tobool(self:GetClientInfo("shake")));

		return true;
	end;
end;

/*
	Manual Placement
*/

function TOOL:RightClick(trace)
	if (!IsValid(trace.Entity)) then return false; end;
	if (trace.Entity:IsPlayer()) then return false; end;
	if (CLIENT) then return true; end;

	if (trace.Entity:GetClass() == "prop_physics") then
		if (!self:GetOwner():CheckLimit("elevators")) then return false; end;
		local ent = trace.Entity;

		local wallTrace = util.TraceEntity({
			start = ent:GetPos(),
			endpos = ent:GetPos() + trace.HitNormal * 14000,
			filter = function(hit) if (hit == ent or hit:IsPlayer()) then return false; else return true; end; end
		}, ent);

		local elevator = ents.Create("elevator");
		elevator:SetPos(ent:GetPos());
		elevator:SetAngles(ent:GetAngles());
		elevator.Model = ent:GetModel();
		elevator:Spawn();

		elevator:SetMoveSound(self:GetClientInfo("movesound"));
		elevator:SetStopSound(self:GetClientInfo("stopsound"));

		elevator:SetMoveSpeed(math.Clamp(tonumber(self:GetClientInfo("speed")), 1, 500));

		elevator:SetBlockDamage(math.Clamp(tonumber(self:GetClientInfo("blockdamage")), 0, 100));

		elevator:SetAllowUse(tobool(self:GetClientInfo("allowuse")));

		elevator:SetShake(tobool(self:GetClientInfo("shake")));

		elevator:GetDoor():SetMaterial(ent:GetMaterial());
		elevator:GetDoor():SetColor(ent:GetColor());

		elevator:SetStart(ent:GetPos());
		elevator:SetEnd(wallTrace.HitPos);

		elevator:GetDoor().StartButton = numpad.OnDown(self:GetOwner(), tonumber(self:GetClientInfo("keystart")), "ElevatorStart", elevator:GetDoor());
		elevator:GetDoor().ReturnButton = numpad.OnDown(self:GetOwner(), tonumber(self:GetClientInfo("keyreturn")), "ElevatorReturn", elevator:GetDoor());
		elevator:GetDoor().b1 = tonumber(self:GetClientInfo("keystart"));
		elevator:GetDoor().b2 = tonumber(self:GetClientInfo("keyreturn"));

		elevator:GetDoor().parts = {};

		for k, v in pairs(constraint.GetAllConstrainedEntities(ent)) do
			if (IsValid(v) and v != ent and constraint.Find(ent, v, "Weld", 0, 0)) then
				if (v:GetClass() == "prop_physics") then
					local prop = ents.Create("prop_physics");
					prop:SetPos(v:GetPos());
					prop:SetAngles(v:GetAngles());
					prop:SetMaterial(v:GetMaterial());
					prop:SetRenderMode(v:GetRenderMode());
					prop:SetColor(v:GetColor());
					prop:SetModel(v:GetModel());
					SafeRemoveEntity(v);
					prop:Spawn();
					prop:SetParent(elevator:GetDoor());
					prop:GetPhysicsObject():EnableMotion(false);

					table.insert(elevator:GetDoor().parts, {
						origin = elevator:GetDoor():WorldToLocal(v:GetPos()),
						angles = elevator:GetDoor():WorldToLocalAngles(v:GetAngles()),
						material = v:GetMaterial(),
						model = v:GetModel(),
						rendermode = v:GetRenderMode(),
						color = v:GetColor()
					});
				else
					v:SetParent(elevator:GetDoor());
				end;
			end;
		end;

		SafeRemoveEntity(ent);

		undo.Create("Elevator");
		undo.AddEntity(elevator);
		undo.SetPlayer(self:GetOwner());
		undo.SetCustomUndoText("Undone Elevator");
		undo.Finish();

		self:GetOwner():AddCount("elevators", elevator);
		self:GetOwner():AddCleanup("elevators", elevator);

		return true;
	elseif (trace.Entity:GetClass() == "func_movelinear" and IsValid(trace.Entity.parent)) then
		local parent = trace.Entity.parent;

		parent:SetMoveSound(self:GetClientInfo("movesound"));
		parent:SetStopSound(self:GetClientInfo("stopsound"));

		parent:SetMoveSpeed(math.Clamp(tonumber(self:GetClientInfo("speed")), 1, 500));

		parent:SetBlockDamage(math.Clamp(tonumber(self:GetClientInfo("blockdamage")), 0, 100));

		parent:SetAllowUse(tobool(self:GetClientInfo("allowuse")));

		parent:SetShake(tobool(self:GetClientInfo("shake")));

		return true;
	end;
end;

if (SERVER) then
	function TOOL:Think()
	end
end

/*
	Holster
	Clear stored objects and reset state
*/

function TOOL:Holster()
	self:ClearObjects();
	self:SetStage(0);
end;

function TOOL:UpdateGhostElevator(player, ent)
	if (!IsValid(ent)) then return; end;
	local trace = player:GetEyeTrace();

	if (!IsValid(trace.Entity) or trace.Entity:GetClass() != "prop_physics") then ent:SetNoDraw(true); return; end;

	ent:SetModel(trace.Entity:GetModel());
	ent:SetAngles(trace.Entity:GetAngles());

	local bUseLocalAng = tobool(self:GetClientInfo("local"));
	local baseAng = trace.Entity:GetAngles();

	if (!bUseLocalAng) then
		baseAng = angle_zero;
	end;

	ent:SetPos(trace.Entity:GetPos() + baseAng:Right() * tonumber(self:GetClientInfo("right")) + baseAng:Up() * tonumber(self:GetClientInfo("up")) + baseAng:Forward() * tonumber(self:GetClientInfo("forward")));
	ent:SetNoDraw(false);
end;

function TOOL:Think()
	local trace = self:GetOwner():GetEyeTrace();

	if (!IsValid(self.GhostEntity)) then
		self:MakeGhostEntity(trace.Entity:GetModel(), Vector(0, 0, 0), Angle(0, 0, 0));
	end;

	self:UpdateGhostElevator(self:GetOwner(), self.GhostEntity);
end;

/*
	Control Panel
*/

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Numpad", {
		Label = "#tool.elevator.keystart",
		Command = "elevator_keystart",
		Label2 = "#tool.elevator.keyreturn",
		Command2 = "elevator_keyreturn"
	});

	CPanel:AddControl("ComboBox", {
		Label = "#tool.elevator.movesound",
		Options = list.Get("elevator.MoveSounds")
	});

	CPanel:AddControl("ComboBox", {
		Label = "#tool.elevator.stopsound",
		Options = list.Get("elevator.StopSounds")
	});

	CPanel:AddControl("Slider", {
		Label = "#tool.elevator.blockdamage",
		Command = "elevator_blockdamage",
		Type = "Float",
		Min = 0,
		Max = 100
	});

	CPanel:AddControl("Slider", {
		Label = "#tool.elevator.speed",
		Command = "elevator_speed",
		Type = "Float",
		Min = 1,
		Max = 200
	});

	CPanel:AddControl("ComboBox", {
		Label = "#tool.elevator.relative",
		Options = list.Get("elevator.Relative")
	});

	CPanel:Button("Reset Offsets", "elevator_resetoffsets");

	CPanel:AddControl("Slider", {
		Label = "#tool.elevator.up",
		Command = "elevator_up",
		Type = "Float",
		Min = -2500,
		Max = 2500
	});

	CPanel:AddControl("Slider", {
		Label = "#tool.elevator.lright",
		Command = "elevator_right",
		Type = "Float",
		Min = -2500,
		Max = 2500
	});

	CPanel:AddControl("Slider", {
		Label = "#tool.elevator.forward",
		Command = "elevator_forward",
		Type = "Float",
		Min = -2500,
		Max = 2500
	});

	CPanel:AddControl("CheckBox", {
		Label = "#tool.elevator.allowuse",
		Command = "elevator_allowuse",
	});

	CPanel:AddControl("CheckBox", {
		Label = "#tool.elevator.shake",
		Command = "elevator_shake",
	});
end;

/*
	Language strings
*/

local moveSounds = {
	["Heavy Metal"] = "plats/skylift_move.wav",
	["Squeaky"] = "plats/elevator_loop1.wav",
	["Tram"] = "plats/tram_move.wav",
	["Rusty"] = "plats/hall_elev_move.wav",
	["Old 1"] = "plats/elevator_move_loop1.wav",
};

local stopSounds = {
	["Heavy Metal"] = "plats/skylift_stop.wav",
	["Squeaky"] = "plats/elevator_stop.wav",
	["Rusty"] = "plats/hall_elev_stop.wav",
	["Old 1"] = "plats/elevator_stop1.wav",
	["Old 2"] = "plats/elevator_stop2.wav",
	["Industrial"] = "plats/elevator_large_stop1.wav"
};

for k, v in pairs(moveSounds) do
	local name = k:gsub(" ", "");

	sound.Add({
		name = "Elevators." .. name,
		sound = v,
		volume = 1,
		pitch = 100,
		level = 75,
		channel = CHAN_STATIC
	});

	if (CLIENT) then
		list.Set("elevator.MoveSounds", "#tool.elevator.movesounds." .. name:lower(), {elevator_movesound = "Elevators." .. name});
		language.Add("tool.elevator.movesounds." .. name:lower(), k);
	end;
end;

for k, v in pairs(stopSounds) do
	local name = k:gsub(" ", "");

	sound.Add({
		name = "Elevators.Stop." .. name,
		sound = v,
		volume = 1,
		pitch = 100,
		level = 75,
		channel = CHAN_STATIC
	});

	if (CLIENT) then
		list.Set("elevator.StopSounds", "#tool.elevator.stopsounds." .. name:lower(), {elevator_stopsound = "Elevators.Stop." .. name});
		language.Add("tool.elevator.stopsounds." .. name:lower(), k);
	end;
end;

if (CLIENT) then
	language.Add("tool.elevator.name", "Elevators");
	language.Add("tool.elevator.left", "Transform a prop and everything welded directly to it into an elevator.");
	language.Add("tool.elevator.right", "Same as left click, but sets the endpoint perpendicular to the hit surface.");
	language.Add("tool.elevator.desc", "Create elevators.");

	language.Add("tool.elevator.keystart", "Start");
	language.Add("tool.elevator.keyreturn", "Return");

	language.Add("tool.elevator.movesound", "Moving Sound");
	language.Add("tool.elevator.stopsound", "Arrival Sound");

	language.Add("tool.elevator.speed", "Speed");

	language.Add("tool.elevator.up", "Up/Down Distance");
	language.Add("tool.elevator.lright", "Right/Left Distance");
	language.Add("tool.elevator.forward", "Forward/Back Distance");

	language.Add("tool.elevator.relative", "Relative to: ");
	language.Add("tool.elevator.relative.prop", "Prop");
	language.Add("tool.elevator.relative.world", "World");

	language.Add("tool.elevator.blockdamage", "Crush Damage");

	language.Add("tool.elevator.allowuse", "Allow USE");

	language.Add("tool.elevator.shake", "Shake Screen");

	language.Add("Cleaned_elevators", "Cleaned up all Elevators");
	language.Add("Cleanup_elevators", "Elevators");

	language.Add("tool.elevator.movesounds.none", "None");
	language.Add("tool.elevator.stopsounds.none", "None");

	language.Add("SBoxLimit_elevators", "You've hit the limit of elevators!");

	list.Set("elevator.MoveSounds", "#tool.elevator.movesounds.none", {elevator_movesound = ""});

	list.Set("elevator.StopSounds", "#tool.elevator.stopsounds.none", {elevator_stopsound = ""});

	list.Set("elevator.Relative", "#tool.elevator.relative.prop", {elevator_local = "1"});
	list.Set("elevator.Relative", "#tool.elevator.relative.world", {elevator_local = "0"});

	concommand.Add("elevator_resetoffsets", function()
		LocalPlayer():ConCommand("elevator_up 0");
		LocalPlayer():ConCommand("elevator_right 0");
		LocalPlayer():ConCommand("elevator_forward 0");
	end);

	halo.oldAdd = halo.oldAdd or halo.Add;

	function halo.Add(entities, color, blurX, blurY, passes, additive, ignoreZ)
		for k, v in pairs(entities) do
			if (IsValid(v) and v:GetClass():find("func_")) then
				entities[k] = nil;
			end;
		end;

		halo.oldAdd(entities, color, blurX, blurY, passes, additive, ignoreZ);
	end;
end;
--lua/weapons/gmod_tool/stools/elevator_button.lua:
AddCSLuaFile();

TOOL.Category = "Construction"
TOOL.Name = "Elevator Buttons"
TOOL.ClientConVar["send"] = "1";
TOOL.ClientConVar["model"] = "models/props_combine/combinebutton.mdl";

TOOL.Information = {
	{name = "left", stage = 0},
	{name = "right", stage = 0},
};

cleanup.Register("elevatorbuttons");

if (SERVER) then
	if (!ConVarExists("sbox_maxelevatorbuttons")) then
		CreateConVar("sbox_maxelevatorbuttons", 10, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Maximum number of elevator buttons which can be created by users.");
	end;
end;

/*
	Elevator Creation
*/

function TOOL:LeftClick(trace)
	if (IsValid(trace.Entity) and trace.Entity:IsPlayer()) then return false; end;
	if (!IsValid(self:GetEnt(0))) then return false; end;
	if (CLIENT) then return true; end;
	if (!self:GetOwner():CheckLimit("elevatorbuttons")) then return false; end;

	local ang = trace.HitNormal:Angle();
	ang:RotateAroundAxis(ang:Right(), -90);

	local button = ents.Create("elevator_button");
	button.Model = self:GetClientInfo("model");
	button:SetPos(trace.HitPos);
	button:SetAngles(ang);
	button:Spawn();
	button:SetSender(tobool(self:GetClientInfo("send")));
	button:SetElevator(self:GetEnt(0));
	button:GetPhysicsObject():EnableMotion(false);

	undo.Create("Elevator Button");
	undo.AddEntity(button);
	undo.SetPlayer(self:GetOwner());
	undo.SetCustomUndoText("Undone Elevator Button");
	undo.Finish();

	self:GetOwner():AddCount("elevatorbuttons", button);
	self:GetOwner():AddCleanup("elevatorbuttons", button);

	return true;
end;

/*
	Selection
*/

function TOOL:RightClick(trace)
	if (!IsValid(trace.Entity)) then return false; end;
	if (trace.Entity:IsPlayer()) then return false; end;
	if (trace.Entity:GetClass() != "func_movelinear") then return false; end;
	if (CLIENT) then return true; end;

	self:GetOwner():SendLua("surface.PlaySound('buttons/button24.wav'); notification.AddLegacy('Elevator selected', NOTIFY_GENERIC, 2);");

	local ent = trace.Entity;

	self:SetObject(0, ent, vector_origin, nil, 0, vector_origin);

	return true;
end;

/*
	Holster
	Reset state
*/

function TOOL:Holster()
	self:SetStage(0);
	self:ReleaseGhostEntity();
end;

function TOOL:UpdateGhostButton(player, ent)
	if (!IsValid(ent)) then return; end;
	local trace = player:GetEyeTrace();

	if (!trace.Hit) then
		ent:SetNoDraw(true);
		return;
	end;

	if (IsValid(trace.Entity) and trace.Entity:IsPlayer()) then
		ent:SetNoDraw(true);
		return;
	end;

	local ang = trace.HitNormal:Angle();
	ang:RotateAroundAxis(ang:Right(), -90);

	ent:SetAngles(ang);

	ent:SetPos(trace.HitPos);
	ent:SetNoDraw(false);
end;

function TOOL:Think()
	local mdl = self:GetClientInfo("model"):lower();

	if (!IsValid(self.GhostEntity) or self.GhostEntity:GetModel():lower() != mdl) then
		self:MakeGhostEntity(mdl, Vector(0, 0, 0), Angle(0, 0, 0));
	end;

	self:UpdateGhostButton(self:GetOwner(), self.GhostEntity);
end;

/*
	Control Panel
*/

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("PropSelect", {
		Label = "#tool.elevator_button.model",
		ConVar = "elevator_button_model",
		Height = 4,
		Models = list.Get("ButtonModels");
	});

	CPanel:AddControl("ComboBox", {
		Label = "#tool.elevator_button.send",
		Options = list.Get("elevatorbuttons.SendOptions")
	});
end;

/*
	Language strings
*/

if (CLIENT) then
	language.Add("tool.elevator_button.name", "Elevator Buttons");
	language.Add("tool.elevator_button.left", "Place a button to call or send an elevator.");
	language.Add("tool.elevator_button.right", "Select the elevator to add buttons for.");
	language.Add("tool.elevator_button.desc", "Create elevator buttons.");

	language.Add("tool.elevator_button.model", "Model");
	language.Add("tool.elevator_button.send", "This button will");
	language.Add("tool.elevator_button.send.call", "Call elevator to bottom");
	language.Add("tool.elevator_button.send.send", "Send elevator to top");

	language.Add("Cleaned_elevatorbuttons", "Cleaned up all Elevator Buttons");
	language.Add("Cleanup_elevatorbuttons", "Elevator Buttons");

	language.Add("SBoxLimit_elevatorbuttons", "You've hit the limit of elevator buttons!");

	list.Set("elevatorbuttons.SendOptions", "#tool.elevator_button.send.call", {elevator_button_send = "0"});
	list.Set("elevatorbuttons.SendOptions", "#tool.elevator_button.send.send", {elevator_button_send = "1"});
end;
--addons/vanilla-tools/lua/weapons/gmod_tool/stools/hyperspace.lua:
TOOL.Category = "CW:RP"

TOOL.Name = "Hyperraum-Tool"

if CLIENT then
    language.Add("Tool.hyperspace.name", "Hyperraum-Tool")
    language.Add("Tool.hyperspace.desc", "Lasse ein beliebiges Entity oder Prop auftauchen oder in den Hyperraum springen.")
    language.Add("Tool.hyperspace.left", "Wähle einen Ort, wo das Entity/Prop auftauchen soll.")
    language.Add("Tool.hyperspace.right", "Wähle ein Entity/Prop aus, welches in den Hyperraum springt.")
end

TOOL.ClientConVar[ "height" ] = "0"
TOOL.ClientConVar[ "angle" ] = "0"
TOOL.ClientConVar[ "ship" ] = ""
TOOL.ClientConVar[ "ai" ] = "0"
TOOL.ClientConVar[ "freeze" ] = "0"
TOOL.ClientConVar[ "flip" ] = "0"
TOOL.ClientConVar[ "shake" ] = "0"
TOOL.ClientConVar[ "sound" ] = "0"
TOOL.ClientConVar[ "delay" ] = "0"
TOOL.ClientConVar[ "model" ] = ""
TOOL.ClientConVar[ "spawnmodel" ] = "0"

TOOL.Information = {
    { name = "left" },
    { name = "right" }
}

function TOOL:LeftClick( trace )
    if not trace.HitPos then return false end

    local Delay = self:GetClientInfo("delay")
    local Height = self:GetClientNumber("height")
    local vAngle = self:GetClientNumber("angle")
    local Ship = self:GetClientInfo("ship")
    local AI = self:GetClientInfo("ai")
    local Freeze = self:GetClientInfo("freeze")
    local Flip = self:GetClientInfo("flip")
    local Shake = self:GetClientInfo("shake")
    local vSound = self:GetClientInfo("sound")
    local vModel = self:GetClientInfo("model")
    local SpawnModel = self:GetClientInfo("spawnmodel")

    local Valid = false

    for k, v in pairs(scripted_ents.GetList()) do
        if Ship == v.t.ClassName then
            Valid = true
        end
    end

    if list.HasEntry("NPC",Ship) then
        Valid = true
    end

    if SpawnModel == "1" then
        Valid = true
    end

    if Valid == true && SERVER then
        timer.Simple(Delay, function()
            local ent = ents.Create("hyperspace_ship")
            if not IsValid(ent) then return end
            ent:SetKeyValue("AI", AI)
            ent:SetKeyValue("Freeze", Freeze)
            ent:SetKeyValue("Flip", Flip)
            ent:SetKeyValue("Shake", Shake)
            ent:SetKeyValue("Sound", vSound)
            ent:SetKeyValue("SpawnModel", SpawnModel)
            ent:SetKeyValue("ActualModel", vModel)
            ent:SetKeyValue("Entity", Ship)
            ent:SetOwner(self:GetOwner())
            ent:SetPos(trace.HitPos + Vector(0,0,Height))
            ent:SetAngles(Angle(0,0,0) + Angle(0,vAngle,0))
            ent:Spawn()
            ent:SetMoveType(MOVETYPE_NONE)

            undo.Create( "Ship" )
                undo.AddEntity( ent )
                undo.SetPlayer( self:GetOwner() )
                undo.SetCustomUndoText("Undone Ship")
            undo.Finish()
            return false
        end)
    end
end


local timerName = tostring(SysTime())

function TOOL:RightClick( trace )
    local ent = trace.Entity

    if not IsValid(ent) then return end

    if not SERVER then return end
    local sound = ents.Create("hyperspace_highwake")
    if not IsValid(sound) then return end
    sound:SetPos(ent:GetPos())
    sound:Spawn()
    sound:SetNoDraw(true)

    if IsValid(ent) then
        timer.Simple(3,function()
            if not IsValid(ent) then return end
            timer.Create(timerName,0,0.2,function()
                if not ent:IsValid() then return end
                if self:GetClientInfo("flip") == "0" then
                    ent:SetPos(ent:GetPos() + ent:GetForward() * 700)
                else
                    ent:SetPos(ent:GetPos() - ent:GetForward() * 700)
                end
            end)
        end)
        timer.Create(timerName .. "Ender",5 + 1,1,function()
            timer.Remove(timerName)
            if not IsValid(ent) then return end
            ent:Remove()
        end)
    end
end

function TOOL:Think()
    if not ( IsValid( self.GhostEntity ) ) then
        self:MakeGhostEntity( "models/xqm/jetbody3_s5.mdl", Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
    end
    self:UpdateGhost( self.GhostEntity, self:GetOwner() )

    if not timer.Exists(timerName .. "Ender") then return end
    if timer.RepsLeft(timerName .. "Ender") == 0 then
        timer.Remove(timerName .. "Ender")
    end
end

function TOOL:UpdateGhost( ent, pl )
    if not ( IsValid( ent ) ) then return end
    local trace = pl:GetEyeTrace()
    if not trace.Hit then
        ent:SetNoDraw( true )
        return
    end
    ent:SetPos( trace.HitPos + Vector(0,0,self:GetClientNumber("height")) )
    if self:GetClientNumber("flip") == 0 then
        ent:SetAngles( (Angle(0,0,0) + Angle(0,90,0)) + Angle(0,self:GetClientNumber("angle"),0) )
    else
        ent:SetAngles( Angle(0,0,0) + Angle(0,270,0) + Angle(0,self:GetClientNumber("angle"),0))
    end
ent:SetNoDraw( false )
    ent:SetMaterial("phoenix_storms/dome",true)
    ent:SetColor(Color(0,255,0,125))
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )
    if not CLIENT then return end

    CPanel:SetName( "Hyperraum-Tool" )

    CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "hyperspace", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

    CPanel:NumSlider("Height", "hyperspace_height", 0, 10000)
    CPanel:ControlHelp("Sets the height of the spawned ship.")

    CPanel:NumSlider("Angle", "hyperspace_angle", 0, 360)
    CPanel:ControlHelp("Sets the angle of the spawned ship.")

    CPanel:NumSlider("Delay", "hyperspace_delay", 0, 10, 1)
    CPanel:ControlHelp("Sets the delay (in seconds) of the spawned ship.")

    CPanel:TextEntry("Entity Name", "hyperspace_Ship")
    CPanel:ControlHelp("The entity name of the desired ship.")

    CPanel:CheckBox("Model Ship", "hyperspace_spawnmodel")
    CPanel:ControlHelp("Tick this if you would like to spawn in a model instead of an entity.")

    CPanel:TextEntry("Model Name", "hyperspace_model")
    CPanel:ControlHelp("Only use if you would like to spawn in a model that is not an entity.")

    CPanel:CheckBox("Enable AI","hyperspace_ai")
    CPanel:ControlHelp("Enables AI for the spawned ship. (LFS ONLY)")

    CPanel:CheckBox("Freeze","hyperspace_freeze")
    CPanel:ControlHelp("Freezes the spawned ship.")

    CPanel:CheckBox("Flip","hyperspace_flip")
    CPanel:ControlHelp("Flips the spawned ship. (For ships with models that are backwards.) Effects the direction the ship will jump to aswell.")

    CPanel:CheckBox("Enable Screenshake","hyperspace_shake")
    CPanel:ControlHelp("Enables screenshake for people near the ship.")

    CPanel:CheckBox("Enable Sound","hyperspace_sound")
    CPanel:ControlHelp("Plays sound of the ship jumping in to all players.")

end

--addons/lvs_base/lua/weapons/gmod_tool/stools/lvsaienabler.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#AI Enabler"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "team" ] = "-1"

if CLIENT then
	language.Add( "tool.lvsaienabler.name", "AI Enabler" )
	language.Add( "tool.lvsaienabler.desc", "A tool used to enable/disable AI on LVS-Vehicles" )
	language.Add( "tool.lvsaienabler.0", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
	language.Add( "tool.lvsaienabler.1", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( true )
	end

	if SERVER then
		local Team = self:GetClientNumber( "team" )

		if Team ~= -1 then
			ent:SetAITEAM( math.Clamp( Team, 0, 3 ) )
		end
	end

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( false )
	end

	return true
end

function TOOL:Reload( trace )
	return false
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "Header", { Text = "#tool.lvsaienabler.name", Description	= "#tool.lvsaienabler.desc" }  )

	CPanel:AddControl( "Slider", { Label = "TeamOverride", Type = "Int", Min = -1, Max = 3, Command = "lvsaienabler_team" } )
end

--addons/lvs_base/lua/weapons/gmod_tool/stools/lvsturret.lua:
TOOL.Category		= "LVS"
TOOL.Name		= "#tool.lvsturret.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

cleanup.Register( "lvsturret" )
CreateConVar("sbox_maxlvsturret", 1, "FCVAR_NOTIFY")

TOOL.ClientConVar[ "delay" ] 		= "0.05"
TOOL.ClientConVar[ "damage" ] 		= "15"
TOOL.ClientConVar[ "speed" ] 		= "30000"
TOOL.ClientConVar[ "size" ] 		= "1"
TOOL.ClientConVar[ "spread" ] 		= "0"
TOOL.ClientConVar[ "penetration" ] 	= "10"
TOOL.ClientConVar[ "splashdamage" ] = "0"
TOOL.ClientConVar[ "splashradius" ] 	= "0"
TOOL.ClientConVar[ "tracer" ] 		= "lvs_tracer_orange"
TOOL.ClientConVar[ "splasheffect" ] 	= "lvs_bullet_impact"

if CLIENT then
	language.Add( "tool.lvsturret.name", "Projectile Turret" )
	language.Add( "tool.lvsturret.desc", "A Tool used to spawn Turrets" )
	language.Add( "tool.lvsturret.0", "Left click to spawn or update a turret" )
	language.Add( "tool.lvsturret.1", "Left click to spawn or update a turret" )
	
	language.Add( "Cleanup_lvsturret", "[LVS] Projectile Turret" )
	language.Add( "Cleaned_lvsturret", "Cleaned up all [LVS] Projectile Turrets" )

	language.Add( "SBoxLimit_lvsturret", "You've reached the Projectile Turret limit!" )
end

function TOOL:LeftClick( trace )

	if CLIENT then return true end
	
	local ply = self:GetOwner()

	if not istable( WireLib ) then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS]: WIREMOD REQUIRED" )
		ply:SendLua( "gui.OpenURL( 'https://steamcommunity.com/sharedfiles/filedetails/?id=160250458' )") 
	end
	
	if IsValid( trace.Entity ) and trace.Entity:GetClass():lower() == "lvs_turret" then 
		self:UpdateTurret( trace.Entity )
	else
		local turret = self:MakeTurret( ply, trace.HitPos + trace.HitNormal * 5 )
		
		undo.Create("Turret")
			undo.AddEntity( turret )
			undo.SetPlayer( ply )
		undo.Finish()
	end
	
	return true
end

function TOOL:RightClick( trace )
	return false
end

if SERVER then
	function TOOL:UpdateTurret( ent )
		if not IsValid( ent ) then return end

		ent:SetShootDelay( self:GetClientNumber( "delay" ) )
		ent:SetDamage( math.Clamp( self:GetClientNumber( "damage" ), 0, 1000 ) )
		ent:SetSpeed( math.Clamp( self:GetClientNumber( "speed" ), 10000, 100000 ) )
		ent:SetSize( math.Clamp( self:GetClientNumber( "size" ), 0, 50 ) )
		ent:SetSpread( math.Clamp( self:GetClientNumber( "spread" ), 0, 1 ) )
		ent:SetPenetration( math.Clamp( self:GetClientNumber( "penetration" ), 0, 500 ) )
		ent:SetSplashDamage( math.Clamp( self:GetClientNumber( "splashdamage" ), 0, 1000 ) )
		ent:SetSplashDamageRadius( math.Clamp( self:GetClientNumber( "splashradius" ), 0, 750 ) )
		ent:SetTracer( self:GetClientInfo( "tracer" ) )
		ent:SetSplashDamageType( self:GetClientInfo( "splasheffect" ) )
	end

	function TOOL:MakeTurret( ply, Pos, Ang )

		if not ply:CheckLimit( "lvsturret" ) then return NULL end

		local turret = ents.Create( "lvs_turret" )
		
		if not IsValid( turret )  then return NULL end

		turret:SetPos( Pos )
		turret:SetAngles( Angle(0,0,0) )
		turret:Spawn()

		turret.Attacker = ply

		self:UpdateTurret( turret )

		ply:AddCount( "lvsturret", turret )
		ply:AddCleanup( "lvsturret", turret )

		return turret
	end
end

local ConVarsDefault = TOOL:BuildConVarList()
function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "lvs_turrets", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Header", { Text = "#tool.lvsturret.name", Description	= "#tool.lvsturret.desc" }  )

	local TracerEffect = {Label = "Tracer Effect", MenuButton = 0, Options={}, CVars = {}}
	local TracerOptions = {
		["LaserBlue"] = "lvs_laser_blue",
		["LaserRed"] = "lvs_laser_red",
		["LaserGreen"] = "lvs_laser_green",
		["TracerGreen"] = "lvs_tracer_green",
		["TracerOrange"] = "lvs_tracer_orange",
		["TracerWhite"] = "lvs_tracer_white",
		["TracerYellow"] = "lvs_tracer_yellow",
		["AutoCannon"] = "lvs_tracer_autocannon",
		["Cannon"] = "lvs_tracer_cannon",
	}
	for id, name in pairs( TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end
		TracerEffect["Options"][id]	= { lvsturret_tracer = name }
	end
	CPanel:AddControl("ComboBox", TracerEffect )

	CPanel:AddControl( "Slider", { Label = "Shoot Delay", Type = "Float", Min = 0, Max = 2.0, Command = "lvsturret_delay" } )

	CPanel:AddControl( "Slider", { Label = "Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_damage" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Speed", Type = "Float", Min = 10000, Max = 100000, Command = "lvsturret_speed" } )

	CPanel:AddControl( "Slider", { Label = "Bullet Spread", Type = "Float", Min = 0, Max = 1, Command = "lvsturret_spread" } )

	CPanel:AddControl( "Slider", { Label = "Hull Size", Type = "Float", Min = 0, Max = 50, Command = "lvsturret_size" } )

	CPanel:AddControl( "Slider", { Label = "Armor Penetration (mm)", Type = "Float", Min = 0, Max = 500, Command = "lvsturret_penetration" } )

	CPanel:AddControl( "Slider", { Label = "Splash Damage", Type = "Float", Min = 0, Max = 1000, Command = "lvsturret_splashdamage" } )

	CPanel:AddControl( "Slider", { Label = "Splash Radius", Type = "Float", Min = 0, Max = 750, Command = "lvsturret_splashradius" } )

	local SplashType = {Label = "Splash Type", MenuButton = 0, Options={}, CVars = {}}
	SplashType["Options"][ "Shrapnel" ] = { lvsturret_splasheffect = "lvs_bullet_impact" }
	SplashType["Options"][ "Explosive" ] = { lvsturret_splasheffect =  "lvs_bullet_impact_explosive" }
	CPanel:AddControl("ComboBox", SplashType )
end

--lua/weapons/gmod_tool/stools/npctool_health.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Health"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	TOOL.ClientConVar["health"] = "100"
	TOOL.ClientConVar["invincible"] = 0
	
	language.Add("tool.npctool_health.name","NPC Health")
	language.Add("tool.npctool_health.desc","Change a NPC's health")
	language.Add("tool.npctool_health.0","Left-Click to change the health of a NPC to the set value.")
   
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Health",Description = [[Left-Click to change the health of a NPC to the set value.
		]]})
		pnl:AddControl("CheckBox",{Label = "Invincible",Command = "npctool_health_invincible"})
		pnl:AddControl("Slider",{Label = "Health: ",min = 1,max = 5000,Command = "npctool_health_health"})
	end
	
	net.Receive("npctool_health_set",function(len)
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local cvHealth = GetConVar("npctool_health_health")
		local cvInvincible = GetConVar("npctool_health_invincible")
		local bWasInvincible = net.ReadUInt(1) != 0
		local hp = cvHealth:GetInt()
		local bInvincible = cvInvincible:GetBool()
		local name = language.GetPhrase("#" .. ent:GetClass())
		if(bInvincible) then if(!bWasInvincible) then notification.AddLegacy(name .. " is now invincible.",0,8) end
		else
			if(bWasInvincible) then notification.AddLegacy(name .. " is not invincible anymore.",0,8) end
			notification.AddLegacy("Set health of " .. name .. " to " .. hp,0,8)
		end
		surface.PlaySound("buttons/button14.wav")
	end)
	function TOOL:LeftClick(tr) return true end
else
	util.AddNetworkString("npctool_health_set")
	local tbEntsInvincible = {}
	function TOOL:LeftClick(tr)
		if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
			tr.Entity:SetHealth(self:GetClientNumber("health"))
			net.Start("npctool_health_set")
			net.WriteEntity(tr.Entity)
				if(self:GetClientNumber("invincible") != 0) then
					if(tr.Entity.bScripted) then
						local bInvincible = tr.Entity:IsInvincible()
						if(!bInvincible) then tr.Entity:SetInvincible(true) end
						net.WriteUInt(bInvincible && 1 || 0,1)
					elseif(!table.HasValue(tbEntsInvincible,tr.Entity)) then
						table.insert(tbEntsInvincible,tr.Entity)
						local idx = tr.Entity:EntIndex()
						local hk = "npctool_health_invincible" .. idx
						hook.Add("EntityTakeDamage",hk,function(npc,dmginfo)
							if(!tr.Entity:IsValid()) then hook.Remove("EntityTakeDamage",hk)
							elseif(npc == tr.Entity) then dmginfo:SetDamage(0) end
						end)
						net.WriteUInt(0,1)
					else net.WriteUInt(1,1) end
				else
					if(tr.Entity.bScripted) then
						net.WriteUInt(tr.Entity:IsInvincible() && 1 || 0,1)
						tr.Entity:SetInvincible(false)
					elseif(table.HasValue(tbEntsInvincible,tr.Entity)) then
						net.WriteUInt(1,1)
						for _,ent in ipairs(tbEntsInvincible) do
							if(ent == tr.Entity) then
								table.remove(tbEntsInvincible,_)
								break
							end
						end
						hook.Remove("EntityTakeDamage","npctool_health_invincible" .. tr.Entity:EntIndex())
					else net.WriteUInt(0,1) end
				end
			net.Send(self:GetOwner())
			return true
		end
	end
end
--addons/npc_tools/lua/weapons/gmod_tool/stools/npctool_spawner.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Spawn Creator"
TOOL.Command = nil
TOOL.ConfigName = ""

local WEAPON_PROFICIENCY_RANDOM = 5
local WEAPON_PROFICIENCY_DEFAULT = 6
if(CLIENT) then
	local D_HT = 1
	local D_FR = 2
	local D_LI = 3
	local D_NU = 4
	local function NumSlider(self,strLabel,strConVar,numMin,numMax,numDecimals)
		local left = vgui.Create("DNumSliderLegacy",self)
		left:SetText(strLabel)
		left:SetMinMax(numMin,numMax)
		left:SetDark(true)

		if(numDecimals != nil) then left:SetDecimals(numDecimals) end
		left:SetConVar(strConVar)
		left:SizeToContents()
		self:AddItem(left,nil)
		return left
	end
	require("json")
	local tbCvars = {
		["class"] = "npc_zombie",
		["squad"] = "",
		["spawnflags"] = "0",
		["equipment"] = "",
		--["soundtrack"] = "",
		["delay"] = "4",
		["max"] = "4",
		["total"] = "0",
		["turnon"] = "",
		["turnoff"] = "",
		["starton"] = "1",
		["startburrowed"] = "1",
		["deleteonremove"] = "1",
		["patroltype"] = "1",
		["patrolwalk"] = "0",
		["patrolshow"] = "1",
		["patrolstrict"] = "0",
		["showeffects"] = "1",
		["proficiency"] = WEAPON_PROFICIENCY_DEFAULT
	}
	for cv,def in pairs(tbCvars) do
		TOOL.ClientConVar[cv] = def
	end
	local tbPatrolPoints = {}
	local tbPPEffects = {}
	local function CreatePatrolPointEffect(pos)
		local tbEnts = ents.GetAll()
		util.Effect("effect_cube",EffectData())
		local e = ents.GetAll()[#tbEnts +1]
		if(!e) then return end
		e:SetOrigin(pos)
		return e
	end
	local function CreatePatrolPoint(pos)
		if(GetConVarNumber("npctool_spawner_patrolshow") != 0) then
			local e = CreatePatrolPointEffect(pos)
			if(e) then e:SetID(table.insert(tbPPEffects,e)) end
		end
		table.insert(tbPatrolPoints,pos)
		net.Start("sv_npctool_spawner_ppoint")
		net.SendToServer()
	end
	local function GetTraceEffect()
		local pl = LocalPlayer()
		local pos = pl:GetShootPos()
		local dir = pl:GetAimVector()
		local eClosest
		local distClosest = math.huge
		for _,e in ipairs(tbPPEffects) do
			local hit,norm = util.IntersectRayWithOBB(pos,dir *32768,e:GetPos(),Angle(0,0,0),e:GetRenderBounds())
			if(hit) then
				local d = e:GetPos():Distance(pos)
				if(d < distClosest) then
					distClosest = d
					eClosest = _
				end
			end
		end
		return tbPPEffects[eClosest],eClosest
	end
	local mat = Material("trails/laser")
	local function ShowPatrolPoints(b)
		hook.Remove("RenderScreenspaceEffects","npctool_spawner_renderppoints")
		for _,ent in ipairs(tbPPEffects) do ent.m_bRemove = true end
		table.Empty(tbPPEffects)
		if(!b) then return end
		for _,pos in ipairs(tbPatrolPoints) do
			tbPPEffects[_] = CreatePatrolPointEffect(pos)
			tbPPEffects[_]:SetID(_)
		end
		local offset = Vector(0,0,6)
		local col = Color(255,255,255,255)
		local cv = GetConVar("npctool_spawner_patroltype")
		local colDefault = Color(255,255,255,255)
		local colSelected = Color(255,0,0,255)
		hook.Add("RenderScreenspaceEffects","npctool_spawner_renderppoints",function()
			cam.Start3D(EyePos(),EyeAngles())
			render.SetMaterial(mat)
			local num = #tbPPEffects
			for i = 2,num do
				local p = tbPPEffects[i]
				local pPrev = tbPPEffects[i -1]
				render.DrawBeam(pPrev:GetPos() +offset,p:GetPos() +offset,5,0,0,col)
			end
			if(num > 2 && cv:GetInt() == 3) then
				local last = tbPPEffects[num]
				local first = tbPPEffects[1]
				render.DrawBeam(last:GetPos() +offset,first:GetPos() +offset,5,0,0,col)
			end
			cam.End3D()
			local eTrace = GetTraceEffect()
			for _,e in ipairs(tbPPEffects) do
				if(e == eTrace) then e:SetColor(colSelected)
				else e:SetColor(colDefault) end
			end
		end)
	end
	cvars.AddChangeCallback("npctool_spawner_patrolshow",function(cvar,old,new)
		ShowPatrolPoints(tobool(new))
	end)
	local cvPPointSelected = CreateClientConVar("npctool_spawner_ppoints_select",0,true)
	concommand.Add("npctool_spawner_ppoints_add",function(pl,cmd,args)
		local tr = util.TraceLine(util.GetPlayerTrace(pl))
		CreatePatrolPoint(tr.HitPos)
	end)
	local function RemovePatrolPoint(ID)
		if(!tbPatrolPoints[ID]) then return end
		table.remove(tbPatrolPoints,ID)
		local ent = tbPPEffects[ID]
		if(ent && ent:IsValid()) then
			ent.m_bRemove = true
			table.remove(tbPPEffects,ID)
		end
		for i = ID,#tbPatrolPoints do
			local e = tbPPEffects[i]
			e:SetID(i)
		end
	end
	local function ClearPatrolPoints()
		for _,ent in ipairs(tbPPEffects) do
			if(ent:IsValid()) then ent.m_bRemove = true end
		end
		table.Empty(tbPatrolPoints)
		table.Empty(tbPPEffects)
	end
	net.Receive("npctool_spawner_ppoint_remove",function(len) RemovePatrolPoint(#tbPatrolPoints) end)
	concommand.Add("npctool_spawner_ppoints_remove",function(pl,cmd,args) RemovePatrolPoint(cvPPointSelected:GetInt()) end)
	concommand.Add("npctool_spawner_ppoints_clear",ClearPatrolPoints)
	local tbKeyValues = {}
	local tbRelationships = {}
	CreateClientConVar("npctool_spawner_keyvalues_select","",true)
	CreateClientConVar("npctool_spawner_relationships_select","",true)
	local function CreateSaveDialog(title,fcSave)
		local w, h = 220,110
		local x,y = ScrW() *0.5 -w *0.5,ScrH() *0.5 -h *0.5
		local p = vgui.Create("DFrame")
		p:SetSize(w,h)
		p:SetPos(x,y)
		p:MakePopup()
		p:ShowCloseButton(true)
		p:SetTitle(title)

		local l = vgui.Create("DLabel", p)
		l:SetText("Name:")
		l:SetPos(20,40)

		local teName = vgui.Create("DTextEntry", p)
		teName:SetSize(146,16)
		teName:SetPos(55,42)

		local bSave = vgui.Create("DButton", p)
		bSave:SetText("Save")
		bSave:SetSize(80,21)
		bSave:SetPos(20,70)
		bSave.DoClick = function(bSave)
			p:Close()
			if(teName:GetValue() != "") then fcSave(teName:GetValue()) end
		end

		local bCancel = vgui.Create("DButton", p)
		bCancel:SetText("Cancel")
		bCancel:SetSize(80,21)
		bCancel:SetPos(120,70)
		bCancel.DoClick = function()
			p:Close()
		end
	end
	local preset
	local function MainMenu(pnl)
		pnl:ClearControls()
		pnl:AddControl("Header",{Text = "Spawner",Description = [[Left-Click to create the spawner.
		Right-Click to create or remove a patrol point.
		]]})
		local p = vgui.Create("DPanel",pnl)
		p.Paint = function() end
		pnl:AddItem(p)
		local pCBox = vgui.Create("DComboBox",p)
		pCBox:AddChoice("Default",true)
		local IDSelected
		if(preset == "Default") then IDSelected = 1 end
		for _,f in ipairs(file.Find("npcspawner/*.txt","DATA")) do
			local n = string.sub(f,1,-5)
			local i = pCBox:AddChoice(n)
			if(n == preset) then IDSelected = i end
		end
		if(IDSelected) then pCBox:ChooseOptionID(IDSelected) end
		pCBox.OnSelect = function(pCBox,idx,val,data)
			net.Start("npctool_spawner_clearundo")
			net.SendToServer()
			preset = val
			ClearPatrolPoints()
			table.Empty(tbKeyValues)
			table.Empty(tbRelationships)
			if(val == "Default") then
				if(tbCvars.class) then RunConsoleCommand("npctool_spawner_class",tbCvars.class) end
				if(tbCvars.proficiency) then RunConsoleCommand("npctool_spawner_proficiency",tbCvars.proficiency) end
				timer.Simple(0.05,function()
					MainMenu(controlpanel.Get("npctool_spawner"))
					timer.Simple(0,function()
						for cv,def in pairs(tbCvars) do
							if(cv != "class" && cv != "proficiency") then RunConsoleCommand("npctool_spawner_" .. cv,def) end
						end
					end)
				end)
				return
			end
			local content = file.Read("npcspawner/" .. val .. ".txt","DATA")
			if(!content) then return end
			local data = util.JSONToTable(content)
			if(data.keyvalues) then tbKeyValues = data.keyvalues end
			if(data.relationships) then tbRelationships = data.relationships end
			if(data.patrolpoints) then
				for _,pos in ipairs(data.patrolpoints) do
					CreatePatrolPoint(pos)
				end
			end
			if(data.cvars) then
				if(data.cvars.class) then RunConsoleCommand("npctool_spawner_class",data.cvars.class); data.cvars.class = nil end // Need to set the class before reloading the menu
				if(data.cvars.proficiency) then RunConsoleCommand("npctool_spawner_proficiency",data.cvars.proficiency); data.cvars.proficiency = nil end
				if(data.cvars.delay) then RunConsoleCommand("npctool_spawner_delay",data.cvars.delay); data.cvars.delay = nil end
				if(data.cvars.max) then RunConsoleCommand("npctool_spawner_max",data.cvars.max); data.cvars.max = nil end
				if(data.cvars.total) then RunConsoleCommand("npctool_spawner_total",data.cvars.total); data.cvars.total = nil end
			end
			timer.Simple(0.05,function()
				MainMenu(controlpanel.Get("npctool_spawner"))
				if(data.cvars) then
					timer.Simple(0,function()
						for cv,val in pairs(data.cvars) do
							if(cv != "class" && cv != "proficiency") then RunConsoleCommand("npctool_spawner_" .. cv,val) end
						end
					end)
				end
			end)
		end
		pCBox:SetWide(194)
		p:SetTall(pCBox:GetTall())

		local b = vgui.Create("DImageButton",p)
		b:SetImage("gui/silkicons/disk.vmt")
		b:SetSize(16,16)
		b:SetPos(pCBox:GetWide() +4,pCBox:GetTall() *0.5 -8)
		b:SizeToContents()
		b.OnMousePressed = function(b)
			CreateSaveDialog("NPC Spawner Settings",function(name)
				if(string.Right(name,4) != ".txt") then name = name .. ".txt" end
				local data = {}
				data.cvars = {}
				for cv in pairs(tbCvars) do
					data.cvars[cv] = GetConVarString("npctool_spawner_" .. cv)
				end
				data.keyvalues = tbKeyValues
				data.patrolpoints = tbPatrolPoints
				data.relationships = tbRelationships
				file.CreateDir("npcspawner")
				file.Write("npcspawner/" .. name,util.TableToJSON(data))
				MainMenu(controlpanel.Get("npctool_spawner"))
			end)
		end
		local options = {}
		for _,npc in pairs(list.Get("NPC")) do
			options[npc.Name .. " [" .. npc.Class .. "]"] = {npctool_spawner_class = _}
		end
		pnl:AddControl("ListBox",{Label = "NPC",MenuButton = 0,Height = 150,Options = options})
		pnl:AddControl("TextBox",{Label = "Squadname",MaxLength = 20,WaitForEnter = false,Type = "Float",Command = "npctool_spawner_squad"})
		pnl:AddControl("TextBox",{Label = "Spawnflags",MaxLength = 20,WaitForEnter = false,Type = "Integer",Command = "npctool_spawner_spawnflags"})
		//pnl:AddControl("TextBox",{Label = "Soundtrack",MaxLength = 60,WaitForEnter = false,Type = "String",Command = "npctool_spawner_soundtrack"})
		//pnl:AddControl("Label",{Text = "                                  (This track will play as long as                                   this spawner is active. Only one soundtrack can                                   play at a time.)"})
		local options = {}
		local tbWeps = {}
		for class,data in pairs(list.Get("Weapon")) do
			if(data.Spawnable || (data.AdminSpawnable && LocalPlayer():IsAdmin())) then
				options[data.PrintName] = {npctool_spawner_equipment = class}
			end
		end
		options["No Weapon"] = {npctool_spawner_equipment = ""}
		pnl:AddControl("ComboBox",{Label = "Equipment",Options = options})

		local values = {
			[WEAPON_PROFICIENCY_POOR] = "Poor",
			[WEAPON_PROFICIENCY_AVERAGE] = "Average",
			[WEAPON_PROFICIENCY_GOOD] = "Good",
			[WEAPON_PROFICIENCY_VERY_GOOD] = "Very Good",
			[WEAPON_PROFICIENCY_PERFECT] = "Perfect",
			[WEAPON_PROFICIENCY_RANDOM] = "Random",
			[WEAPON_PROFICIENCY_DEFAULT] = "Default"
		}
		local pSl = NumSlider(pnl,"Weapon Proficiency:",nil,1,7,0)
		local prof = values[GetConVarNumber("npctool_spawner_proficiency")] || "Poor"
		pSl.Wang:SetText(prof)
		local i
		for _,val in ipairs(values) do if(val == prof) then i = _ +1; break end end
		if(i) then pSl.Slider:SetSlideX((i -1) /6) end
		pSl.TranslateSliderValues = function(...)
			local x,y = select(2,...)
			local num = tonumber(x *6 +1) || 0
			num = math.Round(num)
			local val = math.Clamp(num,1,7)
			pSl.Wang:SetText(values[val -1] || "Poor")
			RunConsoleCommand("npctool_spawner_proficiency",val -1)
			return ((num -1) /6),y
		end

		pnl:AddControl("Slider",{Label = "Spawn delay",min = 1,max = 30,Type = "Float",Command = "npctool_spawner_delay"})
		pnl:AddControl("Slider",{Label = "Max alive NPCs",min = 1,max = 25,Type = "Integer",Command = "npctool_spawner_max"})
		pnl:AddControl("Slider",{Label = "Total NPC amount",min = 0,max = 250,Command = "npctool_spawner_total"})
		pnl:AddControl("Label",{Text = "                                  (0 = infinite)"})
		pnl:AddControl("Numpad",{Label = "#Turn On",Label2 = "#Turn Off",Command = "npctool_spawner_turnon",Command2 = "npctool_spawner_turnoff",ButtonSize = 22})

		pnl:AddControl("CheckBox",{Label = "Show Effects",Command = "npctool_spawner_showeffects"})
		pnl:AddControl("CheckBox",{Label = "Start On",Command = "npctool_spawner_starton"})
		pnl:AddControl("CheckBox",{Label = "Start burrowed (Antlions and headcrabs)",Command = "npctool_spawner_startburrowed"})
		pnl:AddControl("CheckBox",{Label = "Remove spawned NPCs on removal",Command = "npctool_spawner_deleteonremove"})

		if(GetConVarNumber("npctool_spawner_patrolshow") != 0) then ShowPatrolPoints(true) end
		pnl:AddControl("Label",{Label = "",Text = ""})
		pnl:AddControl("Label",{Label = "Patrol",Text = "Patrol"})
		pnl:AddControl("CheckBox",{Label = "Show patrol points",Command = "npctool_spawner_patrolshow"})
		pnl:AddControl("CheckBox",{Label = "Walk",Command = "npctool_spawner_patrolwalk"})
		pnl:AddControl("CheckBox",{Label = "Strict (NPC may not move to attack)",Command = "npctool_spawner_patrolstrict"})
		pnl:AddControl("ComboBox",{Label = "Patrol Type",Options = {
			["Just forth"] = {npctool_spawner_patroltype = "1"},
			["Back and forth"] = {npctool_spawner_patroltype = "2"},
			["Circles"] = {npctool_spawner_patroltype = "3"}
		}})
		pnl:AddControl("Button",{Label = "Clear Patrol Points",Text = "Clear Patrol Points",Command = "npctool_spawner_ppoints_clear"})

		pnl:AddControl("Label",{Label = "",Text = ""})
		local options = {}
		for key,val in pairs(tbKeyValues) do
			options[key .. " = " .. val] = {npctool_spawner_keyvalues_select = key}
		end
		pnl:AddControl("ListBox",{Label = "Keyvalues",MenuButton = 0,Height = 150,Options = options})
		pnl:AddControl("Button",{Label = "Add Keyvalue",Text = "Add Keyvalue",Command = "npctool_spawner_keyvalues_add"})
		pnl:AddControl("Button",{Label = "Remove Keyvalue",Text = "Remove Keyvalue",Command = "npctool_spawner_keyvalues_remove"})
		pnl:AddControl("Button",{Label = "Clear Keyvalues",Text = "Clear Keyvalues",Command = "npctool_spawner_keyvalues_clear"})

		local options = {}
		for tgt,disp in pairs(tbRelationships) do
			local str
			if(disp == D_HT) then str = "Hates"
			elseif(disp == D_FR) then str = "Fears"
			elseif(disp == D_LI) then str = "Likes"
			else str = "Is neutral to" end
			local name = language.GetPhrase("#" .. tgt)
			if(name[1] == "#") then name = tgt end
			str = str .. " '" .. name .. "'"
			options[str] = {npctool_spawner_relationships_select = tgt}
		end
		pnl:AddControl("ListBox",{Label = "Relationships",MenuButton = 0,Height = 150,Options = options})
		pnl:AddControl("Button",{Label = "Add Relationship",Text = "Add Relationship",Command = "npctool_spawner_relationships_add"})
		pnl:AddControl("Button",{Label = "Remove Relationship",Text = "Remove Relationship",Command = "npctool_spawner_relationships_remove"})
		pnl:AddControl("Button",{Label = "Clear Relationships",Text = "Clear Relationships",Command = "npctool_spawner_relationships_clear"})
	end
	concommand.Add("npctool_spawner_submenu_main",function(pl,cmd,args)
		MainMenu(controlpanel.Get("npctool_spawner"))
	end)
	language.Add("tool.npctool_spawner.name","NPC Spawn Creator")
	language.Add("tool.npctool_spawner.desc","Create an automatic NPC spawner")
	language.Add("tool.npctool_spawner.0","Left-Click to create the spawner, Right-Click to create or remove a patrol point.")

	function TOOL.BuildCPanel(pnl)
		MainMenu(pnl)
	end

	concommand.Add("npctool_spawner_relationships_remove",function(pl,cmd,args)
		local sel = GetConVarString("npctool_spawner_relationships_select")
		tbRelationships[sel] = nil
		MainMenu(controlpanel.Get("npctool_spawner"))
	end)
	concommand.Add("npctool_spawner_relationships_clear",function(pl,cmd,args)
		tbRelationships = {}
		MainMenu(controlpanel.Get("npctool_spawner"))
	end)
	concommand.Add("npctool_spawner_relationships_add",function(pl,cmd,args)
		local tgt = args[1]
		local disp = args[2]
		if(tgt && disp) then
			tbRelationships[tgt] = tonumber(disp) || D_NU
			MainMenu(controlpanel.Get("npctool_spawner"))
			return
		end
		local w,h = 205,145
		local x,y = gui.MousePos()
		local p = vgui.Create("DFrame")
		p:SetSize(w,h)
		p:SetPos(x -w *0.5,y -h *0.5)
		p:MakePopup()
		p:ShowCloseButton(true)
		p:SetTitle("Add Relationship")
		local col = Color(56,56,56,240)
		p.Paint = function(p)
			draw.RoundedBox(8,0,0,w,h,col)
			surface.SetDrawColor(75,75,75,200)
			surface.DrawLine(0,20,w,20)
		end
		local l = vgui.Create("DLabel",p)
		l:SetText("Target:")
		l:SetPos(12,35)
		l:SizeToContents()

		local class
		local teKey = vgui.Create("DComboBox",p)
		teKey:SetSize(100,16)
		teKey:SetPos(80,35)
		teKey.OnSelect = function(teKey,idx,val,data)
			class = data
		end
		local choices = {{name = "Player",class = "player"}}
		for _,npc in pairs(list.Get("NPC")) do
			table.insert(choices,{
				name = npc.Name,
				class = npc.Class
			})
		end
		table.sort(choices,function(a,b) return a.name < b.name end)
		for _,choice in ipairs(choices) do
			teKey:AddChoice(choice.name,choice.class)
		end

		local l = vgui.Create("DLabel",p)
		l:SetText("Disposition:")
		l:SetPos(12,60)
		l:SizeToContents()

		local disp
		local teVal = vgui.Create("DComboBox",p)
		teVal:SetSize(100,16)
		teVal:SetPos(80,60)
		teVal.OnSelect = function(teKey,idx,val,data)
			disp = data
		end
		teVal:AddChoice("Hate",D_HT)
		teVal:AddChoice("Fear",D_FR)
		teVal:AddChoice("Like",D_LI)
		teVal:AddChoice("Neutral",D_NU)

		local b = vgui.Create("DButton",p)
		b:SetText("OK")
		b:SetSize(40,21)
		b:SetPos(30,100)
		b.DoClick = function(b)
			p:Close()
			if(class && disp) then
				RunConsoleCommand("npctool_spawner_relationships_add",class,disp)
			end
		end

		local b = vgui.Create("DButton",p)
		b:SetText("Cancel")
		b:SetSize(50,21)
		b:SetPos(100,100)
		b.DoClick = function(b)
			p:Close()
		end
	end)

	concommand.Add("npctool_spawner_keyvalues_remove",function(pl,cmd,args)
		local sel = GetConVarString("npctool_spawner_keyvalues_select")
		tbKeyValues[sel] = nil
		MainMenu(controlpanel.Get("npctool_spawner"))
	end)
	concommand.Add("npctool_spawner_keyvalues_clear",function(pl,cmd,args)
		tbKeyValues = {}
		MainMenu(controlpanel.Get("npctool_spawner"))
	end)
	concommand.Add("npctool_spawner_keyvalues_add",function(pl,cmd,args)
		local key = args[1]
		local val = args[2]
		if(key && val) then
			tbKeyValues[key] = val
			MainMenu(controlpanel.Get("npctool_spawner"))
			return
		end
		local w,h = 175,145
		local x,y = gui.MousePos()
		local p = vgui.Create("DFrame")
		p:SetSize(w,h)
		p:SetPos(x -w *0.5,y -h *0.5)
		p:MakePopup()
		p:ShowCloseButton(true)
		p:SetTitle("Add Keyvalue")
		local col = Color(56,56,56,240)
		p.Paint = function(p)
			draw.RoundedBox(8,0,0,w,h,col)
			surface.SetDrawColor(75,75,75,200)
			surface.DrawLine(0,20,w,20)
		end
		local l = vgui.Create("DLabel",p)
		l:SetText("Key:")
		l:SetPos(12,35)
		l:SizeToContents()

		local teKey = vgui.Create("DTextEntry",p)
		teKey:SetSize(100,16)
		teKey:SetPos(50,35)

		local l = vgui.Create("DLabel",p)
		l:SetText("Value:")
		l:SetPos(12,60)
		l:SizeToContents()

		local teVal = vgui.Create("DTextEntry",p)
		teVal:SetSize(100,16)
		teVal:SetPos(50,60)

		local b = vgui.Create("DButton",p)
		b:SetText("OK")
		b:SetSize(40,21)
		b:SetPos(30,100)
		b.DoClick = function(b)
			p:Close()
			local key = teKey:GetValue()
			local val = teVal:GetValue()
			if(key != "" && val != "") then
				RunConsoleCommand("npctool_spawner_keyvalues_add",key,val)
			end
		end

		local b = vgui.Create("DButton",p)
		b:SetText("Cancel")
		b:SetSize(50,21)
		b:SetPos(100,100)
		b.DoClick = function(b)
			p:Close()
		end
	end)
	net.Receive("cl_npctool_spawner_ppoint",function(len)
		local e,eID = GetTraceEffect()
		if(e) then RemovePatrolPoint(eID); return end
		local pos = net.ReadVector()
		CreatePatrolPoint(pos)
	end)
	net.Receive("cl_npctool_spawner_spawn",function(len)
		local yaw = net.ReadFloat()
		local pos = net.ReadVector()
		net.Start("sv_npctool_spawner_spawn")
			net.WriteVector(pos)
			net.WriteFloat(yaw)
			net.WriteString(GetConVarString("npctool_spawner_class"))
			net.WriteString(GetConVarString("npctool_spawner_squad"))
			net.WriteUInt(GetConVarNumber("npctool_spawner_spawnflags"),25)
			net.WriteString(GetConVarString("npctool_spawner_equipment"))
			//net.WriteString(GetConVarString("npctool_spawner_soundtrack"))
			net.WriteUInt(GetConVarNumber("npctool_spawner_proficiency"),4)
			net.WriteFloat(GetConVarNumber("npctool_spawner_delay"))
			net.WriteUInt(GetConVarNumber("npctool_spawner_max"),6)
			net.WriteUInt(GetConVarNumber("npctool_spawner_total"),14)
			net.WriteUInt(GetConVarNumber("npctool_spawner_turnon"),13)
			net.WriteUInt(GetConVarNumber("npctool_spawner_turnoff"),13)
			net.WriteUInt(GetConVarNumber("npctool_spawner_showeffects"),1)
			net.WriteUInt(GetConVarNumber("npctool_spawner_starton"),1)
			net.WriteUInt(GetConVarNumber("npctool_spawner_startburrowed"),1)
			net.WriteUInt(GetConVarNumber("npctool_spawner_deleteonremove"),1)
			net.WriteUInt(GetConVarNumber("npctool_spawner_patrolwalk"),1)
			net.WriteUInt(GetConVarNumber("npctool_spawner_patroltype"),2)
			net.WriteUInt(GetConVarNumber("npctool_spawner_patrolstrict"),1)
			net.WriteUInt(table.Count(tbKeyValues),8)
			for key,val in pairs(tbKeyValues) do
				net.WriteString(key)
				net.WriteString(val)
			end
			local numPPoints = #tbPatrolPoints
			net.WriteUInt(numPPoints,12)
			for i = 1,numPPoints do
				net.WriteVector(tbPatrolPoints[i])
			end
			net.WriteUInt(table.Count(tbRelationships),8)
			for class,disp in pairs(tbRelationships) do
				net.WriteString(class)
				net.WriteUInt(disp,3)
			end
		net.SendToServer()
	end)
	net.Receive("npctool_spawner_deploy",function(len)
		if(GetConVarNumber("npctool_spawner_patrolshow") != 0) then ShowPatrolPoints(true) end
	end)
	net.Receive("npctool_spawner_holster",function(len)
		local wep = LocalPlayer():GetActiveWeapon()
		if(wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "npctool_spawner") then // False alarm
			if(GetConVarNumber("npctool_spawner_patrolshow") != 0) then ShowPatrolPoints(true) end
			return
		end
		ShowPatrolPoints(false)
	end)
else
	util.AddNetworkString("cl_npctool_spawner_spawn")
	util.AddNetworkString("sv_npctool_spawner_spawn")
	util.AddNetworkString("cl_npctool_spawner_ppoint")
	util.AddNetworkString("sv_npctool_spawner_ppoint")
	util.AddNetworkString("npctool_spawner_ppoint_remove")
	util.AddNetworkString("npctool_spawner_clearundo")
	util.AddNetworkString("npctool_spawner_holster")
	util.AddNetworkString("npctool_spawner_deploy")
	function TOOL:Deploy()
		net.Start("npctool_spawner_deploy")
		net.Send(self:GetOwner())
	end
	net.Receive("npctool_spawner_clearundo",function(len,pl)
		for _,undo in pairs(undo.GetTable()) do
			for i = #undo,1,-1 do
				local data = undo[i]
				if(data.Name == "PatrolPoint" && data.Owner == pl) then
					table.remove(undo,i)
				end
			end
		end
	end)
	net.Receive("sv_npctool_spawner_ppoint",function(len,pl)
		undo.Create("PatrolPoint")
			undo.AddFunction(function()
				net.Start("npctool_spawner_ppoint_remove")
				net.Send(pl)
			end)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone Patrol Point")
		undo.Finish("Patrol Point")
	end)
	net.Receive("sv_npctool_spawner_spawn",function(len,pl)
		if not hook.Run("CanTool", ply, nil, "npctool_spawner") then return false end

		local pos = net.ReadVector()
		local yaw = net.ReadFloat()
		local type = net.ReadString()
		local npcData = list.Get("NPC")[type]
		if(!npcData) then ErrorNoHalt("Warning: Trying to use invalid NPC Type '" .. type .. "' for NPC Spawner! Ignoring..."); return end
		local class = npcData.Class
		if(!class) then ErrorNoHalt("Warning: NPC Type '" .. type .. "' does not have an assigned class for NPC Spawner! Ignoring..."); return end
		local squad = net.ReadString()
		local spawnflags = net.ReadUInt(25)
		local equipment = net.ReadString()
		local weps = list.Get("Weapon")
		local data = weps[equipment]
		if(!data || (!data.Spawnable && (!data.AdminSpawnable || !pl:IsAdmin()))) then equipment = "" end
		//local soundtrack = net.ReadString()
		local proficiency = net.ReadUInt(4)
		local delay = net.ReadFloat()
		local max = net.ReadUInt(6)
		local total = net.ReadUInt(14)
		local turnon = net.ReadUInt(13)
		local turnoff = net.ReadUInt(13)
		local effects = net.ReadUInt(1)
		local starton = net.ReadUInt(1)
		local startburrowed = net.ReadUInt(1)
		local deleteonremove = net.ReadUInt(1)
		local patrolwalk = net.ReadUInt(1)
		local patroltype = net.ReadUInt(2)
		local patrolstrict = net.ReadUInt(1)
		local numKeyValues = net.ReadUInt(8)
		local tbKeyValues = {}
		for i = 1,numKeyValues do
			local key = net.ReadString()
			local val = net.ReadString()
			tbKeyValues[key] = val
		end
		local numPPoints = net.ReadUInt(12)
		local tbPatrolPoints = {}
		for i = 1,numPPoints do
			local pos = net.ReadVector()
			table.insert(tbPatrolPoints,pos)
		end
		local numRelationships = net.ReadUInt(8)
		local tbRelationships = {}
		for i = 1,numRelationships do
			local class = net.ReadString()
			local disp = net.ReadUInt(3)
			tbRelationships[class] = disp
		end
		/*
		print("Creating NPC Spawner:")
		MsgN("Class: ",class)
		MsgN("Squad: ",squad)
		MsgN("Spawnflags: ",spawnflags)
		MsgN("Equipment: ",equipment)
		MsgN("Soundtrack: ",soundtrack)
		MsgN("Proficiency: ",proficiency)
		MsgN("Delay: ",delay)
		MsgN("Max: ",max)
		MsgN("Total: ",total)
		MsgN("Turn On: ",turnon)
		MsgN("Turn Off: ",turnoff)
		MsgN("Start On: ",starton)
		MsgN("Start Burrowed: ",startburrowed)
		MsgN("Delete On Remove: ",deleteonremove)
		MsgN("Patrol Walk: ",patrolwalk)
		MsgN("Patrol Type: ",patroltype)
		MsgN("Patrol Strict: ",patrolstrict)
		MsgN("Key Values:")
		PrintTable(tbKeyValues)
		MsgN("Patrol Points:")
		PrintTable(tbPatrolPoints)
		MsgN("Relationships:")
		PrintTable(tbRelationships)
		*/
		local ent = ents.Create("obj_npcspawner")
		ent:SetPos(pos)
		ent:SetAngles(Angle(0,yaw,0))
		ent:SetNPCClass(class)
		ent:SetNPCData(npcData)
		ent:SetNPCBurrowed(tobool(startburrowed))
		ent:SetNPCKeyValues(tbKeyValues)
		if(equipment != "") then ent:SetNPCEquipment(equipment) end
		if(spawnflags > 0) then ent:SetNPCSpawnflags(spawnflags) end
		ent:SetNPCProficiency(proficiency)
		ent:SetEntityOwner(pl)
		ent:SetKeyTurnOn(turnon)
		ent:SetKeyTurnOff(turnoff)
		ent:SetSpawnDelay(delay)
		ent:SetMaxNPCs(max)
		ent:SetTotalNPCs(total)
		//ent:SetSoundtrack(soundtrack)
		ent:SetStartOn(tobool(starton))
		ent:SetPatrolWalk(tobool(patrolwalk))
		ent:SetPatrolType(patroltype)
		ent:SetStrictMovement(tobool(patrolstrict))
		ent:SetDeleteOnRemove(tobool(deleteonremove))
		if(squad != "") then ent:SetSquad(squad) end
		for _,p in ipairs(tbPatrolPoints) do
			ent:AddPatrolPoint(p)
		end
		for class,disp in pairs(tbRelationships) do
			ent:SetDisposition(class,disp)
		end
		ent:Spawn()
		ent:Activate()
		ent:ShowEffects(effects == 1)
		cleanup.Add(pl,"npcs",ent)
		undo.Create("SENT")
			undo.AddEntity(ent)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone NPC Spawner")
		undo.Finish("Scripted Entity (NPC Spawner)")
	end)
end

function TOOL:LeftClick(tr)
	if(CLIENT) then return true end
	net.Start("cl_npctool_spawner_spawn")
		net.WriteFloat(self:GetOwner():GetAimVector():Angle().y)
		net.WriteVector(tr.HitPos)
	net.Send(self:GetOwner())
	return true
end

function TOOL:RightClick(tr)
	if(CLIENT) then return true end
	net.Start("cl_npctool_spawner_ppoint")
		net.WriteVector(tr.HitPos)
	net.Send(self:GetOwner())
	return true
end

function TOOL:Holster()
	if(CLIENT) then return end
	net.Start("npctool_spawner_holster")
	net.Send(self:GetOwner())
end
--lua/weapons/gmod_tool/stools/particlecontrol_proj.lua:
TOOL.Category = "Particle Controller"
TOOL.Name = "ParCtrl - Projectiles"
TOOL.Command = nil
TOOL.ConfigName = ""

TOOL.HighlightedEnt = nil

TOOL.ClientConVar[ "projfx_enabled" ] = "1"
TOOL.ClientConVar[ "projfx_effectname" ] = "Rocket_Smoke"
TOOL.ClientConVar[ "projfx_utileffect_scale" ] = "1"
TOOL.ClientConVar[ "projfx_utileffect_magnitude" ] = "1"
TOOL.ClientConVar[ "projfx_utileffect_radius" ] = "10"
TOOL.ClientConVar[ "projfx_color_enabled" ] = "0"
TOOL.ClientConVar[ "projfx_color_r" ] = "255"
TOOL.ClientConVar[ "projfx_color_g" ] = "20"
TOOL.ClientConVar[ "projfx_color_b" ] = "0"
TOOL.ClientConVar[ "projfx_color_outofone" ] = "0"

TOOL.ClientConVar[ "impactfx_enabled" ] = "1"
TOOL.ClientConVar[ "impactfx_effectname" ] = "!UTILEFFECT!Explosion!FLAG4!"
TOOL.ClientConVar[ "impactfx_utileffect_scale" ] = "1"
TOOL.ClientConVar[ "impactfx_utileffect_magnitude" ] = "1"
TOOL.ClientConVar[ "impactfx_utileffect_radius" ] = "10"
TOOL.ClientConVar[ "impactfx_color_enabled" ] = "0"
TOOL.ClientConVar[ "impactfx_color_r" ] = "255"
TOOL.ClientConVar[ "impactfx_color_g" ] = "20"
TOOL.ClientConVar[ "impactfx_color_b" ] = "0"
TOOL.ClientConVar[ "impactfx_color_outofone" ] = "0"

//TOOL.ClientConVar[ "attachnum" ] = "1"   //we're using the standard tool's attachnum var instead so that the selected attachment stays consistent when swapping between tools
TOOL.ClientConVar[ "repeatrate" ] = "0.80"
TOOL.ClientConVar[ "projmodel" ] = "models/weapons/w_missile.mdl"
TOOL.ClientConVar[ "projmodel_skin" ] = "0"
TOOL.ClientConVar[ "projmodel_attachnum" ] = "1"
TOOL.ClientConVar[ "projmodel_material" ] = ""
TOOL.ClientConVar[ "projmodel_invis" ] = "0"
TOOL.ClientConVar[ "impactfx_effectlifetime" ] = "1.0"

TOOL.ClientConVar[ "projent_spread" ] = "0.04"
TOOL.ClientConVar[ "projent_velocity" ] = "1000"
TOOL.ClientConVar[ "projent_gravity" ] = "0"
TOOL.ClientConVar[ "projent_angle" ] = "0"
TOOL.ClientConVar[ "projent_spin" ] = "0"
TOOL.ClientConVar[ "projent_demomanfix" ] = "0"
TOOL.ClientConVar[ "projent_lifetime_prehit" ] = "10"
TOOL.ClientConVar[ "projent_lifetime_posthit" ] = "0"
TOOL.ClientConVar[ "projent_serverside" ] = "0"

TOOL.ClientConVar[ "propmodel" ] = "models/weapons/w_smg1.mdl"
TOOL.ClientConVar[ "propangle" ] = "2"
TOOL.ClientConVar[ "propinvis" ] = "0"

TOOL.ClientConVar[ "numpadkey" ] = "52"
TOOL.ClientConVar[ "toggle" ] = "1"
TOOL.ClientConVar[ "starton" ] = "1"

TOOL.Information = {
	{ name = "left0", stage = 0, icon = "gui/lmb.png" },
	{ name = "middle0", stage = 0, icon = "gui/mmb.png" },
	{ name = "right0", stage = 0, icon = "gui/rmb.png" },
	{ name = "reload0", stage = 0, icon = "gui/r.png" },
}

if ( CLIENT ) then
	language.Add( "tool.particlecontrol_proj.name", "Adv. Particle Controller - Projectiles" )
	language.Add( "tool.particlecontrol_proj.desc", "Attach projectile effects to things" )
	language.Add( "tool.particlecontrol_proj.help", "Projectile effects launch props that have one particle attached to them, and another particle that plays once they expire, either on impact or on a timer." )

	language.Add( "tool.particlecontrol_proj.left0", "Add a projectile effect to an object" )
	language.Add( "tool.particlecontrol_proj.middle0", "Scroll through an object's attachments" )
	language.Add( "tool.particlecontrol_proj.right0", "Attach a new prop with the projectile effect on it" )
	language.Add( "tool.particlecontrol_proj.reload0", "Remove all projectile effects from an object" )
end

util.PrecacheSound("weapons/pistol/pistol_empty.wav")




function TOOL:LeftClick( trace )

	local projinfo = nil
	if self:GetClientNumber( "projfx_enabled", 0 ) == 1 then
		projinfo = {
			effectname = self:GetClientInfo( "projfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "projfx_utileffect_scale", 0 ), self:GetClientNumber( "projfx_utileffect_magnitude", 0 ), self:GetClientNumber( "projfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "projfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "projfx_color_outofone", 0 ) == 1 then
				projinfo.colorinfo = Color( self:GetClientNumber( "projfx_color_r", 0 ), self:GetClientNumber( "projfx_color_g", 0 ), self:GetClientNumber( "projfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				projinfo.colorinfo = Color( self:GetClientNumber( "projfx_color_r", 0 ), self:GetClientNumber( "projfx_color_g", 0 ), self:GetClientNumber( "projfx_color_b", 0 ), 0 )
			end
		end
	end

	local impactinfo = nil
	if self:GetClientNumber( "impactfx_enabled", 0 ) == 1 then
		impactinfo = {
			effectname = self:GetClientInfo( "impactfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "impactfx_utileffect_scale", 0 ), self:GetClientNumber( "impactfx_utileffect_magnitude", 0 ), self:GetClientNumber( "impactfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "impactfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "impactfx_color_outofone", 0 ) == 1 then
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 0 )
			end
		end
	end

	local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var
	local repeatrate = self:GetClientNumber( "repeatrate", 0 )
	local projmodel = self:GetClientInfo( "projmodel", 0 )
	local projmodel_skin = self:GetClientNumber( "projmodel_skin", 0 )
	local projmodel_attachnum = self:GetClientNumber( "projmodel_attachnum", 0 )
	local projmodel_material = self:GetClientInfo( "projmodel_material", 0 )
	local projmodel_invis = self:GetClientNumber( "projmodel_invis", 0 )
	local impactfx_effectlifetime = self:GetClientNumber( "impactfx_effectlifetime", 0 )

	local projent_spread = self:GetClientNumber( "projent_spread", 0 )
	local projent_velocity = self:GetClientNumber( "projent_velocity", 0 )
	local projent_gravity = self:GetClientNumber( "projent_gravity", 0 )
	local projent_angle = self:GetClientNumber( "projent_angle", 0 )
	local projent_spin = self:GetClientNumber( "projent_spin", 0 )
	local projent_demomanfix = self:GetClientNumber( "projent_demomanfix", 0 )
	local projent_lifetime_prehit = self:GetClientNumber( "projent_lifetime_prehit", 0 )
	local projent_lifetime_posthit = self:GetClientNumber( "projent_lifetime_posthit", 0 )
	local projent_serverside = self:GetClientNumber( "projent_serverside", 0 )

	local numpadkey = self:GetClientNumber( "numpadkey", 0 )
	local toggle = self:GetClientNumber( "toggle", 0 )
	local starton = self:GetClientNumber( "starton", 0 )

	local ply = self:GetOwner()



	if ( trace.Entity:IsValid() ) then
		if CLIENT then return true end
		if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end
		AttachParticleControllerProj( ply, trace.Entity, { NewTable = { 
			ProjFXInfo = projinfo, 
			ImpactFXInfo = impactinfo, 

			AttachNum = attachnum,
			RepeatRate = repeatrate,
			ProjModel = projmodel,
			ProjModel_Skin = projmodel_skin,
			ProjModel_AttachNum = projmodel_attachnum,
			ProjModel_Material = projmodel_material,
			ProjModel_Invis = projmodel_invis,
			ImpactFX_EffectLifetime = impactfx_effectlifetime,

			ProjEnt_Spread = projent_spread,
			ProjEnt_Velocity = projent_velocity,
			ProjEnt_Gravity = projent_gravity,
			ProjEnt_Angle = projent_angle,
			ProjEnt_Spin = projent_spin,
			ProjEnt_DemomanFix = projent_demomanfix,
			ProjEnt_Lifetime_PreHit = projent_lifetime_prehit,
			ProjEnt_Lifetime_PostHit = projent_lifetime_posthit,
			ProjEnt_Serverside = projent_serverside,

			NumpadKey = numpadkey, 
			Toggle = toggle, 
			StartOn = starton, 
		} } )
		return true
	end

end




function TOOL:RightClick( trace )

	local projinfo = nil
	if self:GetClientNumber( "projfx_enabled", 0 ) == 1 then
		projinfo = {
			effectname = self:GetClientInfo( "projfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "projfx_utileffect_scale", 0 ), self:GetClientNumber( "projfx_utileffect_magnitude", 0 ), self:GetClientNumber( "projfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "projfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "projfx_color_outofone", 0 ) == 1 then
				projinfo.colorinfo = Color( self:GetClientNumber( "projfx_color_r", 0 ), self:GetClientNumber( "projfx_color_g", 0 ), self:GetClientNumber( "projfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				projinfo.colorinfo = Color( self:GetClientNumber( "projfx_color_r", 0 ), self:GetClientNumber( "projfx_color_g", 0 ), self:GetClientNumber( "projfx_color_b", 0 ), 0 )
			end
		end
	end

	local impactinfo = nil
	if self:GetClientNumber( "impactfx_enabled", 0 ) == 1 then
		impactinfo = {
			effectname = self:GetClientInfo( "impactfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "impactfx_utileffect_scale", 0 ), self:GetClientNumber( "impactfx_utileffect_magnitude", 0 ), self:GetClientNumber( "impactfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "impactfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "impactfx_color_outofone", 0 ) == 1 then
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 0 )
			end
		end
	end

	local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var
	local repeatrate = self:GetClientNumber( "repeatrate", 0 )
	local projmodel = self:GetClientInfo( "projmodel", 0 )
	local projmodel_skin = self:GetClientNumber( "projmodel_skin", 0 )
	local projmodel_attachnum = self:GetClientNumber( "projmodel_attachnum", 0 )
	local projmodel_material = self:GetClientInfo( "projmodel_material", 0 )
	local projmodel_invis = self:GetClientNumber( "projmodel_invis", 0 )
	local impactfx_effectlifetime = self:GetClientNumber( "impactfx_effectlifetime", 0 )

	local projent_spread = self:GetClientNumber( "projent_spread", 0 )
	local projent_velocity = self:GetClientNumber( "projent_velocity", 0 )
	local projent_gravity = self:GetClientNumber( "projent_gravity", 0 )
	local projent_angle = self:GetClientNumber( "projent_angle", 0 )
	local projent_spin = self:GetClientNumber( "projent_spin", 0 )
	local projent_demomanfix = self:GetClientNumber( "projent_demomanfix", 0 )
	local projent_lifetime_prehit = self:GetClientNumber( "projent_lifetime_prehit", 0 )
	local projent_lifetime_posthit = self:GetClientNumber( "projent_lifetime_posthit", 0 )
	local projent_serverside = self:GetClientNumber( "projent_serverside", 0 )

	local numpadkey = self:GetClientNumber( "numpadkey", 0 )
	local toggle = self:GetClientNumber( "toggle", 0 )
	local starton = self:GetClientNumber( "starton", 0 )

	local ply = self:GetOwner()



	local propmodel = self:GetClientInfo( "propmodel", 0 )
	local propangle = self:GetClientNumber( "propangle", 0 )
	//propangle 1: spawn upright
	//propangle 2: spawn at surface angle

	if !util.IsValidModel(propmodel) then return false end
	if !util.IsValidProp(propmodel) then return false end
	if CLIENT then return true end

	prop = ents.Create( "prop_physics" )
		prop:SetModel( propmodel )
		prop:SetPos( trace.HitPos - trace.HitNormal * prop:OBBMins().z )
		if propangle == 1 then prop:SetAngles(Angle(0,trace.HitNormal:Angle().y,0)) else prop:SetAngles(trace.HitNormal:Angle()) end
		prop:SetCollisionGroup(COLLISION_GROUP_NONE)
	prop:Spawn()

	local shouldweweld = true									    //don't weld if...
	if ( !util.IsValidPhysicsObject(prop, 0) ) then shouldweweld = false end			    //the prop doesn't have a phys object
	if ( !trace.Entity:IsValid() ) then shouldweweld = false end					    //the thing we clicked on doesn't exist/is the world
	if ( trace.Entity && trace.Entity:IsPlayer() ) then shouldweweld = false end			    //the thing we clicked on is a player
	if ( !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then shouldweweld = false end  //the thing we clicked on doesn't have a phys object
	if shouldweweld == true then
		local const = constraint.Weld( prop, trace.Entity, 0, trace.PhysicsBone, 0, true, true )
	else
		if util.IsValidPhysicsObject(prop, 0) then prop:GetPhysicsObject():EnableMotion(false) end
	end

	if self:GetClientNumber( "propinvis", 0 ) == 1 then
		prop:SetRenderMode(1)  //we need to change the render mode so the transparency actually shows up
		prop:SetColor( Color(255,255,255,0) )
		duplicator.StoreEntityModifier( prop, "colour", { Color = Color(255,255,255,0), RenderMode = 1, RenderFX = 0 } )
	end

	undo.Create( "prop" )
		undo.AddEntity( prop )
		undo.SetPlayer( ply )
	undo.Finish( "Prop ("..tostring(propmodel)..")" )



	if ( prop:IsValid() ) then
		AttachParticleControllerProj( ply, prop, { NewTable = { 
			ProjFXInfo = projinfo, 
			ImpactFXInfo = impactinfo, 

			AttachNum = attachnum,
			RepeatRate = repeatrate,
			ProjModel = projmodel,
			ProjModel_Skin = projmodel_skin,
			ProjModel_AttachNum = projmodel_attachnum,
			ProjModel_Material = projmodel_material,
			ProjModel_Invis = projmodel_invis,
			ImpactFX_EffectLifetime = impactfx_effectlifetime,

			ProjEnt_Spread = projent_spread,
			ProjEnt_Velocity = projent_velocity,
			ProjEnt_Gravity = projent_gravity,
			ProjEnt_Angle = projent_angle,
			ProjEnt_Spin = projent_spin,
			ProjEnt_DemomanFix = projent_demomanfix,
			ProjEnt_Lifetime_PreHit = projent_lifetime_prehit,
			ProjEnt_Lifetime_PostHit = projent_lifetime_posthit,
			ProjEnt_Serverside = projent_serverside,

			NumpadKey = numpadkey, 
			Toggle = toggle, 
			StartOn = starton, 
		} } )
		return true
	end

end




function TOOL:Reload( trace )

	if ( trace.Entity:IsValid() ) then
		local fx = false

		if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end

		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_proj" and asdf:GetParent() == trace.Entity then
				if SERVER then asdf:Remove() end
				fx = true
			end
		end
		if SERVER then
			duplicator.ClearEntityModifier( trace.Entity, "DupeParticleControllerProj" )
		end

		return fx
	end
	
end




if CLIENT then

	local colorborder   = Color(0,0,0,255)
	local colorselect   = Color(0,255,0,255)
	local colorunselect = Color(255,255,255,255)

	function TOOL:DrawHUD()
		local pl = LocalPlayer()
		local tr = pl:GetEyeTrace()
		local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var

		local function DrawHighlightAttachments(ent)

			//If there aren't any attachments, then draw the model origin as selected and stop here:
			if !ent:GetAttachments() or !ent:GetAttachments()[1] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)

				return
			end


			//Draw the unselected model origin, if applicable:
			if ent:GetAttachments()[attachnum] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
			end

			//Draw the unselected attachment points:
			for _, table in pairs(ent:GetAttachments()) do
				local _pos,_ang = ent:GetAttachment(table.id).Pos,ent:GetAttachment(table.id).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				if table.id != attachnum then
					draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
					draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
					draw.SimpleTextOutlined(table.id ..": ".. table.name,"Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
				end
			end
			
			//Draw the selected attachment point or model origin last, so it renders above all the others:
			if !ent:GetAttachments()[attachnum] then
				//Model origin
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			else
				//Attachment
				local _pos,_ang = ent:GetAttachment(attachnum).Pos,ent:GetAttachment(attachnum).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined(attachnum ..": ".. ent:GetAttachments()[attachnum].name,"Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			end
		end

		if IsValid(tr.Entity) and tr.Entity == self.HighlightedEnt then
			DrawHighlightAttachments(self.HighlightedEnt) 
		return end

		if IsValid(tr.Entity) and tr.Entity != self.HighlightedEnt then
			//unhighlight the old ent if it exists
			if self.HighlightedEnt != nil then
				self.HighlightedEnt = nil
			end

			//highlight the new ent
			self.HighlightedEnt = tr.Entity
		end

		if !IsValid(tr.Entity) and self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end

	function TOOL:Holster()
		if self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end




	//All credit for the toolgun scroll wheel code goes to the Wiremod devs. You guys are the best.
		local function get_active_tool(ply, tool)
			-- find toolgun
			local activeWep = ply:GetActiveWeapon()
			if not IsValid(activeWep) or activeWep:GetClass() ~= "gmod_tool" or activeWep.Mode ~= tool then return end

			return activeWep:GetToolObject(tool)
		end

		local function hookfunc( ply, bind, pressed )
			if not pressed then return end
			if bind == "invnext" then
				local self = get_active_tool(ply, "particlecontrol_proj")
				if not self then return end
			
				return self:ScrollDown(ply:GetEyeTraceNoCursor())
			elseif bind == "invprev" then
				local self = get_active_tool(ply, "particlecontrol_proj")
				if not self then return end

				return self:ScrollUp(ply:GetEyeTraceNoCursor())
			end
		end
	
		if game.SinglePlayer() then -- wtfgarry (have to have a delay in single player or the hook won't get added)
			timer.Simple(5,function() hook.Add( "PlayerBindPress", "particlecontrol_proj_playerbindpress", hookfunc ) end)
		else
			hook.Add( "PlayerBindPress", "particlecontrol_proj_playerbindpress", hookfunc )
		end
	//End shamefully copied code here.

	function TOOL:Scroll(trace,dir)
		if !IsValid(self.HighlightedEnt) then return end

		local attachcount = 0
		if self.HighlightedEnt:GetAttachments() then attachcount = table.Count(self.HighlightedEnt:GetAttachments()) end
		local oldattachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var
		if oldattachnum > attachcount then oldattachnum = 0 end
		local attachnum = oldattachnum + dir

		if attachnum < 0 then attachnum = attachcount end
		if attachnum > attachcount then attachnum = 0 end
		RunConsoleCommand("particlecontrol_attachnum", tostring(attachnum))   //use the standard tool's attachnum var
		self:GetOwner():EmitSound("weapons/pistol/pistol_empty.wav")
		return true
	end
	function TOOL:ScrollUp(trace) return self:Scroll(trace,-1) end
	function TOOL:ScrollDown(trace) return self:Scroll(trace,1) end

end




if SERVER then

	local function SpawnParticleControllerProj(ply, ent, DataTable)

		if DataTable == nil or DataTable == {} or DataTable.ProjModel == nil or ent == nil or !IsValid(ent) then return end


		local ParticleControlProj = ents.Create( "particlecontroller_proj" )
		ParticleControlProj:SetPos(ent:GetPos())
		ParticleControlProj:SetAngles(ent:GetAngles())
		ParticleControlProj:SetParent(ent)
		ent:DeleteOnRemove(ParticleControlProj)

		ParticleControlProj:SetTargetEnt(ent)


		if DataTable.ProjFXInfo != nil then
			ParticleControlProj:SetProjFX_EffectName(DataTable.ProjFXInfo.effectname)
			ParticleControlProj:SetProjFX_UtilEffectInfo(DataTable.ProjFXInfo.utileffectinfo)
			if DataTable.ProjFXInfo.colorinfo != nil then
				local projfxcolor = Vector(DataTable.ProjFXInfo.colorinfo.r, DataTable.ProjFXInfo.colorinfo.g, DataTable.ProjFXInfo.colorinfo.b)
				if DataTable.ProjFXInfo.colorinfo.a then
					projfxcolor = projfxcolor / 255
				end
				ParticleControlProj:SetProjFX_ColorInfo( projfxcolor )
			else
				ParticleControlProj:SetProjFX_ColorInfo( Vector(0,0,0) )
			end
		else
			ParticleControlProj:SetProjFX_EffectName("")
		end

		if DataTable.ImpactFXInfo != nil then
			ParticleControlProj:SetImpactFX_EffectName(DataTable.ImpactFXInfo.effectname)
			ParticleControlProj:SetImpactFX_UtilEffectInfo(DataTable.ImpactFXInfo.utileffectinfo)
			if DataTable.ImpactFXInfo.colorinfo != nil then
				local impactfxcolor = Vector(DataTable.ImpactFXInfo.colorinfo.r, DataTable.ImpactFXInfo.colorinfo.g, DataTable.ImpactFXInfo.colorinfo.b)
				if DataTable.ImpactFXInfo.colorinfo.a then
					impactfxcolor = impactfxcolor / 255
				end
				ParticleControlProj:SetImpactFX_ColorInfo( impactfxcolor )
			else
				ParticleControlProj:SetImpactFX_ColorInfo( Vector(0,0,0) )
			end
		else
			ParticleControlProj:SetImpactFX_EffectName("")
		end

		ParticleControlProj:SetAttachNum(DataTable.AttachNum)
		ParticleControlProj:SetRepeatRate(DataTable.RepeatRate)

		ParticleControlProj:SetProjModel(DataTable.ProjModel)
		ParticleControlProj:SetSkin(DataTable.ProjModel_Skin)		//also use the controller ent to store the skin
		ParticleControlProj:SetProjModel_AttachNum(DataTable.ProjModel_AttachNum)
		ParticleControlProj:SetMaterial(DataTable.ProjModel_Material)	//and the material
		ParticleControlProj:SetProjModel_Invis( tobool(DataTable.ProjModel_Invis) )
		ParticleControlProj:SetImpactFX_EffectLifetime(DataTable.ImpactFX_EffectLifetime)

		ParticleControlProj:SetProjEnt_Spread(DataTable.ProjEnt_Spread)
		ParticleControlProj:SetProjEnt_Velocity(DataTable.ProjEnt_Velocity)
		ParticleControlProj:SetProjEnt_Gravity( tobool(DataTable.ProjEnt_Gravity) )
		ParticleControlProj:SetProjEnt_Angle(DataTable.ProjEnt_Angle)
		ParticleControlProj:SetProjEnt_Spin(DataTable.ProjEnt_Spin)
		ParticleControlProj:SetProjEnt_DemomanFix( tobool(DataTable.ProjEnt_DemomanFix) )
		ParticleControlProj:SetProjEnt_Lifetime_PreHit(DataTable.ProjEnt_Lifetime_PreHit)
		ParticleControlProj:SetProjEnt_Lifetime_PostHit(DataTable.ProjEnt_Lifetime_PostHit)
		ParticleControlProj:SetProjEnt_Serverside( tobool(DataTable.ProjEnt_Serverside) )


		ParticleControlProj:SetActive( tobool(DataTable.StartOn) )
		ParticleControlProj:SetToggle( tobool(DataTable.Toggle) )
		ParticleControlProj:SetNumpadKey(DataTable.NumpadKey)

		numpad.OnDown( 	 ply, 	DataTable.NumpadKey, 	"Particle_Press", 	ParticleControlProj )
		numpad.OnUp( 	 ply, 	DataTable.NumpadKey, 	"Particle_Release", 	ParticleControlProj )
		ParticleControlProj:SetNumpadState("")


		ParticleControlProj:Spawn()
		ParticleControlProj:Activate()

	end


	function AttachParticleControllerProj( ply, ent, Data )

		if Data.NewTable then
			SpawnParticleControllerProj(ply, ent, Data.NewTable)

			local dupetable = {}
			if ent.EntityMods and ent.EntityMods.DupeParticleControllerProj then dupetable = ent.EntityMods.DupeParticleControllerProj end
			table.insert(dupetable, Data.NewTable)
			duplicator.StoreEntityModifier( ent, "DupeParticleControllerProj", dupetable )
		return end

	end


	function DupeParticleControllerProj( ply, ent, Data )

		//due to a problem with the easy bonemerge tool that causes entity modifiers to be applied TWICE, we need to remove the effects that were added the first time
		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_proj" and asdf:GetParent() == ent then
				asdf:Remove()
			end
		end

		for _, DataTable in pairs (Data) do
			SpawnParticleControllerProj(ply, ent, DataTable)
		end

	end
	duplicator.RegisterEntityModifier( "DupeParticleControllerProj", DupeParticleControllerProj )

end




//we're still testing out a lot of stuff with the cpanel, so let's add a way to refresh it by reselecting the tool
--[[
TOOL.ClientConVar[ "refresh" ] = 1
function TOOL:Think()
	if SERVER then return end
	if self:GetClientNumber("refresh") == 1 then
		RunConsoleCommand("particlecontrol_proj_refresh", "0");
		//refresh the cpanel
		local panel = controlpanel.Get( "particlecontrol_proj" )
		if ( !panel ) then return end
		panel:ClearControls()
		self.BuildCPanel(panel)
	end
end
function TOOL:Deploy()
	RunConsoleCommand("particlecontrol_proj_refresh", "1");
end
]]

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(panel)

	panel:AddControl( "Header", { Description = "#tool.particlecontrol_proj.help" } )

	//Presets
	panel:AddControl( "ComboBox", { 
		MenuButton = 1, 
		Folder = "particlecontrol_proj", 
		Options = { 
			//[ "#preset.default" ] = ConVarsDefault
			[ "Example: Generic Rockets" ] = ConVarsDefault,
			[ "Example: TF2 Rockets" ] = { particlecontrol_proj_impactfx_color_b = "0", particlecontrol_proj_impactfx_color_enabled = "0", particlecontrol_proj_impactfx_color_g = "20", particlecontrol_proj_impactfx_color_outofone = "0", particlecontrol_proj_impactfx_color_r = "255", particlecontrol_proj_impactfx_effectlifetime = "1.000000", particlecontrol_proj_impactfx_effectname = "ExplosionCore_Wall", particlecontrol_proj_impactfx_enabled = "1", particlecontrol_proj_impactfx_utileffect_magnitude = "1", particlecontrol_proj_impactfx_utileffect_radius = "10", particlecontrol_proj_impactfx_utileffect_scale = "1", particlecontrol_proj_numpadkey = "52", particlecontrol_proj_projent_angle = "0", particlecontrol_proj_projent_demomanfix = "0", particlecontrol_proj_projent_gravity = "0", particlecontrol_proj_projent_lifetime_posthit = "0.000000", particlecontrol_proj_projent_lifetime_prehit = "10.000000", particlecontrol_proj_projent_serverside = "0", particlecontrol_proj_projent_spin = "0", 
							particlecontrol_proj_projent_spread = "0", particlecontrol_proj_projent_velocity = "1100.000000", particlecontrol_proj_projfx_color_b = "0", particlecontrol_proj_projfx_color_enabled = "0", particlecontrol_proj_projfx_color_g = "20", particlecontrol_proj_projfx_color_outofone = "0", particlecontrol_proj_projfx_color_r = "255", particlecontrol_proj_projfx_effectname = "rockettrail", particlecontrol_proj_projfx_enabled = "1", particlecontrol_proj_projfx_utileffect_magnitude = "1", particlecontrol_proj_projfx_utileffect_radius = "10", particlecontrol_proj_projfx_utileffect_scale = "1", particlecontrol_proj_projmodel = "models/weapons/w_models/w_rocket.mdl", particlecontrol_proj_projmodel_attachnum = "1", particlecontrol_proj_projmodel_invis = "0", particlecontrol_proj_projmodel_skin = "0", particlecontrol_proj_propangle = "2", particlecontrol_proj_propinvis = "0", particlecontrol_proj_propmodel = "models/weapons/w_smg1.mdl", particlecontrol_proj_repeatrate = "0.800000", 
							particlecontrol_proj_starton = "1", particlecontrol_proj_toggle = "1" },
			[ "Example: TF2 Grenades, red" ] = { particlecontrol_proj_impactfx_color_b = "0", particlecontrol_proj_impactfx_color_enabled = "0", particlecontrol_proj_impactfx_color_g = "20", particlecontrol_proj_impactfx_color_outofone = "0", particlecontrol_proj_impactfx_color_r = "255", particlecontrol_proj_impactfx_effectlifetime = "1.000000", particlecontrol_proj_impactfx_effectname = "ExplosionCore_MidAir", particlecontrol_proj_impactfx_enabled = "1", particlecontrol_proj_impactfx_utileffect_magnitude = "1", particlecontrol_proj_impactfx_utileffect_radius = "10", particlecontrol_proj_impactfx_utileffect_scale = "1", particlecontrol_proj_numpadkey = "52", particlecontrol_proj_projent_angle = "0", particlecontrol_proj_projent_demomanfix = "0", particlecontrol_proj_projent_gravity = "1", particlecontrol_proj_projent_lifetime_posthit = "2.300000", particlecontrol_proj_projent_lifetime_prehit = "2.300000", particlecontrol_proj_projent_serverside = "0", particlecontrol_proj_projent_spin = "4", 
							particlecontrol_proj_projent_spread = "0", particlecontrol_proj_projent_velocity = "1217.000000", particlecontrol_proj_projfx_color_b = "0", particlecontrol_proj_projfx_color_enabled = "0", particlecontrol_proj_projfx_color_g = "20", particlecontrol_proj_projfx_color_outofone = "0", particlecontrol_proj_projfx_color_r = "255", particlecontrol_proj_projfx_effectname = "pipebombtrail_red", particlecontrol_proj_projfx_enabled = "1", particlecontrol_proj_projfx_utileffect_magnitude = "1", particlecontrol_proj_projfx_utileffect_radius = "10", particlecontrol_proj_projfx_utileffect_scale = "1", particlecontrol_proj_projmodel = "models/weapons/w_models/w_grenade_grenadelauncher.mdl", particlecontrol_proj_projmodel_attachnum = "0", particlecontrol_proj_projmodel_invis = "0", particlecontrol_proj_projmodel_skin = "0", particlecontrol_proj_propangle = "2", particlecontrol_proj_propinvis = "0", particlecontrol_proj_propmodel = "models/weapons/w_smg1.mdl", particlecontrol_proj_repeatrate = "0.600000", 
							particlecontrol_proj_starton = "1", particlecontrol_proj_toggle = "1" },
			[ "Example: TF2 Grenades, blue" ] = { particlecontrol_proj_impactfx_color_b = "0", particlecontrol_proj_impactfx_color_enabled = "0", particlecontrol_proj_impactfx_color_g = "20", particlecontrol_proj_impactfx_color_outofone = "0", particlecontrol_proj_impactfx_color_r = "255", particlecontrol_proj_impactfx_effectlifetime = "1.000000", particlecontrol_proj_impactfx_effectname = "ExplosionCore_MidAir", particlecontrol_proj_impactfx_enabled = "1", particlecontrol_proj_impactfx_utileffect_magnitude = "1", particlecontrol_proj_impactfx_utileffect_radius = "10", particlecontrol_proj_impactfx_utileffect_scale = "1", particlecontrol_proj_numpadkey = "52", particlecontrol_proj_projent_angle = "0", particlecontrol_proj_projent_demomanfix = "0", particlecontrol_proj_projent_gravity = "1", particlecontrol_proj_projent_lifetime_posthit = "2.300000", particlecontrol_proj_projent_lifetime_prehit = "2.300000", particlecontrol_proj_projent_serverside = "0", particlecontrol_proj_projent_spin = "4", 
							particlecontrol_proj_projent_spread = "0", particlecontrol_proj_projent_velocity = "1217.000000", particlecontrol_proj_projfx_color_b = "0", particlecontrol_proj_projfx_color_enabled = "0", particlecontrol_proj_projfx_color_g = "20", particlecontrol_proj_projfx_color_outofone = "0", particlecontrol_proj_projfx_color_r = "255", particlecontrol_proj_projfx_effectname = "pipebombtrail_blue", particlecontrol_proj_projfx_enabled = "1", particlecontrol_proj_projfx_utileffect_magnitude = "1", particlecontrol_proj_projfx_utileffect_radius = "10", particlecontrol_proj_projfx_utileffect_scale = "1", particlecontrol_proj_projmodel = "models/weapons/w_models/w_grenade_grenadelauncher.mdl", particlecontrol_proj_projmodel_attachnum = "0", particlecontrol_proj_projmodel_invis = "0", particlecontrol_proj_projmodel_skin = "1", particlecontrol_proj_propangle = "2", particlecontrol_proj_propinvis = "0", particlecontrol_proj_propmodel = "models/weapons/w_smg1.mdl", particlecontrol_proj_repeatrate = "0.600000", 
							particlecontrol_proj_starton = "1", particlecontrol_proj_toggle = "1" },
		}, 
		CVars = table.GetKeys( ConVarsDefault ) 
	} )



	panel:AddControl( "Checkbox", { Label = "Enable projectile effects?", Command = "particlecontrol_proj_projfx_enabled" } )

	AddParticleBrowser(panel, { 
		name = "Projectile Effect", 
		commands = { 
			effectname = "particlecontrol_proj_projfx_effectname", 
			color = "particlecontrol_proj_projfx_color",
			utileffect = "particlecontrol_proj_projfx_utileffect",

			enabled = "particlecontrol_proj_projfx_enabled",
		}, 
	})

	panel:AddControl( "Checkbox", { Label = "Enable impact/expire effects?", Command = "particlecontrol_proj_impactfx_enabled" } )

	AddParticleBrowser(panel, { 
		name = "Impact/Expire Effect", 
		commands = { 
			effectname = "particlecontrol_proj_impactfx_effectname", 
			color = "particlecontrol_proj_impactfx_color",
			utileffect = "particlecontrol_proj_impactfx_utileffect",

			enabled = "particlecontrol_proj_impactfx_enabled",
		}, 
	})



	//panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl("Slider", {
		Label = "Attachment",
	 	Type = "Integer",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_attachnum",   //use the standard tool's attachnum var
	})
	panel:ControlHelp( "Attachment point on the model to fire projectiles from. Set to 0 to fire from the model origin." )

	panel:AddControl("Slider", {
		Label = "Repeat Rate",
	 	Type = "Float",
		Min = "0",
		Max = "1",
		Command = "particlecontrol_proj_repeatrate"
	})
	panel:ControlHelp( "How often the projectile fires. Set to 0 to not repeat." )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	local projmodellist = { Label = "Projectile Model:", ConVar = "particlecontrol_proj_projmodel", Category = "Projectile Model", Height = 1, Models = {} }
	projmodellist.Models["models/hunter/plates/plate.mdl"] = {}
	projmodellist.Models["models/weapons/w_missile.mdl"] = {}
	projmodellist.Models["models/weapons/w_models/w_rocket.mdl"] = {}
	projmodellist.Models["models/weapons/w_models/w_grenade_grenadelauncher.mdl"] = {}

	panel:AddControl( "PropSelect", projmodellist )

	local projmodelentry = vgui.Create( "DTextEntry", panel )
	projmodelentry:SetConVar( "particlecontrol_proj_projmodel" )
	panel:AddItem(projmodelentry)

	panel:AddControl("Slider", {
		Label = "Projectile Skin",
	 	Type = "Integer",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_proj_projmodel_skin",
	})

	panel:AddControl("Slider", {
		Label = "Projectile Attachment",
	 	Type = "Integer",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_proj_projmodel_attachnum",
	})
	panel:ControlHelp( "Attachment point on the projectile to attach the effect to. Set to 0 to attach to model origin." )

	panel:AddControl("TextBox", {
		Label = "Projectile Material", 
		Description = "", 
		MaxLength = 255, 
		Text = "", 
		Command = "particlecontrol_proj_projmodel_material", 
	})

	panel:AddControl( "Checkbox", { Label = "Invisible projectiles (particles only)", Command = "particlecontrol_proj_projmodel_invis" } )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl("Slider", {
		Label = "Projectile Spread",
	 	Type = "Float",
		Min = "0",
		Max = "1",
		Command = "particlecontrol_proj_projent_spread"
	})
	panel:ControlHelp( "Each unit is 90 degrees of spread - you can type in 2 for 180 degrees or even 4 for 360 degrees." )

	panel:AddControl("Slider", {
		Label = "Projectile Velocity",
	 	Type = "Float",
		Min = "0",
		Max = "3000",
		Command = "particlecontrol_proj_projent_velocity"
	})
	//panel:ControlHelp( "" )

	panel:AddControl( "Checkbox", { Label = "Projectile Gravity", Command = "particlecontrol_proj_projent_gravity" } )

	panel:AddControl( "ComboBox",  {
		Label = "Projectile Angle", 
		MenuButton = "0", 
		Options = {
			["Forward"] = { particlecontrol_proj_projent_angle = 0 },
			["Left"] = { particlecontrol_proj_projent_angle = 1 },
			["Right"] = { particlecontrol_proj_projent_angle = 2 },
			["Up"] = { particlecontrol_proj_projent_angle = 3 },
			["Down"] = { particlecontrol_proj_projent_angle = 4 },
			["Back"] = { particlecontrol_proj_projent_angle = 5 },
		}
	})

	panel:AddControl( "ComboBox",  {
		Label = "Projectile Spin", 
		MenuButton = "0", 
		Options = {
			["Don't spin"] = { particlecontrol_proj_projent_spin = 0 },
			["Spin pitch"] = { particlecontrol_proj_projent_spin = 1 },
			["Spin yaw"] = { particlecontrol_proj_projent_spin = 2 },
			["Spin roll"] = { particlecontrol_proj_projent_spin = 3 },
			["Spin random"] = { particlecontrol_proj_projent_spin = 4 },
		}
	})

	panel:AddControl( "Checkbox", { Label = "Demoman Weapon Fix", Command = "particlecontrol_proj_projent_demomanfix" } )
	panel:ControlHelp( "Demoman weapon props have their muzzle attachment at an angle for some reason. Use this to fix it." )

	panel:AddControl("Slider", {
		Label = "Lifetime",
	 	Type = "Float",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_proj_projent_lifetime_prehit"
	})
	panel:ControlHelp( "How long projectiles last after being launched." )

	panel:AddControl("Slider", {
		Label = "Lifetime (after impact)",
	 	Type = "Float",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_proj_projent_lifetime_posthit"
	})
	panel:ControlHelp( "How long projectiles last after hitting something. Set to 0 to expire on impact." )  //TODO: how to explain that lifetime before hit and lifetime after hit are separate timers?

	panel:AddControl( "Checkbox", { Label = "Serverside projectiles?", Command = "particlecontrol_proj_projent_serverside" } )
	panel:ControlHelp( "Use serverside props for projectiles. These will collide properly with everything instead of passing through, but they'll also put a lot more stress on the game (meaning more lag), and they'll show up in the wrong spot if bonemerged. Only turn this on if you need it." )

	panel:AddControl("Slider", {
		Label = "Impact Effect Lifetime",
	 	Type = "Float",
		Min = "0.5",
		Max = "5",
		Command = "particlecontrol_proj_impactfx_effectlifetime"
	})
	//panel:ControlHelp( "Number of seconds before impact effects are removed." )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	local modellist = { Label = "Prop:", ConVar = "particlecontrol_proj_propmodel", Category = "Prop", Height = 1, Models = {} }
	modellist.Models["models/hunter/plates/plate025x025.mdl"] = {}
	modellist.Models["models/hunter/plates/plate.mdl"] = {}
	modellist.Models["models/weapons/w_smg1.mdl"] = {}
	modellist.Models["models/weapons/w_models/w_rocketlauncher.mdl"] = {}

	panel:AddControl( "PropSelect", modellist )

	panel:AddControl( "ComboBox",  {
		Label = "Prop Angle", 
		MenuButton = "0", 
		Options = {
			["Spawn upright"] = { particlecontrol_proj_propangle = "1" },
			["Spawn at surface angle"] = { particlecontrol_proj_propangle = "2" }
		}
	})

	panel:AddControl( "Checkbox", { Label = "Invisible prop (particles only)", Command = "particlecontrol_proj_propinvis" } )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl( "Numpad", {
		Label = "Effect Key",
		Command = "particlecontrol_proj_numpadkey",
		ButtonSize = 22 
	})

	panel:AddControl( "Checkbox", { Label = "Toggle", Command = "particlecontrol_proj_toggle" } )

	panel:AddControl( "Checkbox", { Label = "Start on?", Command = "particlecontrol_proj_starton" } )

end
--lua/weapons/gmod_tool/stools/phys_unparent.lua:
TOOL.Category = "Constraints"
TOOL.Name = "Physical Unparent"

local function OwnershipTest(Player, Entity)
	if Entity.OnDieFunctions ~= nil and Entity.OnDieFunctions.GetCountUpdate ~= nil and Entity.OnDieFunctions.GetCountUpdate.Args ~= nil then
		if Entity.OnDieFunctions.GetCountUpdate.Args[1] == Player then return true else return false end
	end
	if g_SBoxObjects[Player:UniqueID()] == nil then return false end
	for k, v in pairs(g_SBoxObjects[Player:UniqueID()]) do
		for k2, v2 in pairs(v) do
			if v2 == Entity then return true end
		end
	end
	return false
end
local function Selected(ply,ent)
	for k,v in pairs(ply.phys_unparent_selected) do if v.ent == ent then return k end end
	return false
end
local function Select(ply,entity)
	if isentity(entity) and IsValid(entity) and not entity:IsPlayer() and OwnershipTest(ply,entity) and not Selected(ply,entity) and IsValid(entity:GetParent()) then
		ply.phys_unparent_selected[#ply.phys_unparent_selected+1] = {ent = entity, color = entity:GetColor(), material = entity:GetMaterial()}
		entity:SetColor(Color(255,0,0,128))
		entity:SetMaterial("models/debug/debugwhite")
		entity:SetRenderMode(RENDERMODE_TRANSALPHA)
	end
end
local function Deselect(ply,ent)
	local i = Selected(ply,ent)
	if i then
		if IsValid(ent) then
			ent:SetColor(ply.phys_unparent_selected[i].color)
			ent:SetMaterial(ply.phys_unparent_selected[i].material)
		end
		table.remove(ply.phys_unparent_selected,i)
	end
end
	
if CLIENT then
	language.Add("tool.phys_unparent.name", "Physical Unparent")
	language.Add("tool.phys_unparent.desc", "Unparents objects")
	language.Add("tool.phys_unparent.0", "Primary: select (hold use for area). Secondary: unparent. Reload: clear")
	CreateClientConVar("phys_unparent_radius", "300", true, true)
	net.Receive("phys_unparent_clientselect",function(len, ply)
		local selection = {}
		local tr = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		if LocalPlayer():KeyDown(IN_USE) then
			selection = ents.FindInSphere(tr.HitPos, GetConVar("phys_unparent_radius"):GetInt())
		else
			if IsValid(tr.Entity) then selection[1] = tr.Entity end
		end
		if #selection > 0 then
			net.Start("phys_unparent_serverselect")
			net.WriteTable(selection)
			net.WriteBool(LocalPlayer():KeyDown(IN_USE))
			net.SendToServer()
		end
	end)
	
else
	util.AddNetworkString("phys_unparent_clientselect")
	util.AddNetworkString("phys_unparent_serverselect")
	net.Receive("phys_unparent_serverselect",function(len, ply)
		if ply.phys_unparent_selected == nil then ply.phys_unparent_selected = {} end
		local clientselection = net.ReadTable()
		local areaselect = net.ReadBool()
		if not areaselect then
			local pid = clientselection[1]:EntIndex()
			if PhysParentTable ~= nil and PhysParentTable[pid] ~= nil and PhysParentTable[pid][2] ~= nil and PhysParentTable[pid].obbmins ~= nil then --LEFT OFF
				if Selected(ply,Entity(PhysParentTable[pid][2])) then
					for i = 2,#PhysParentTable[pid] do Deselect(ply,Entity(PhysParentTable[pid][i])) end
				else
					for i = 2,#PhysParentTable[pid] do Select(ply,Entity(PhysParentTable[pid][i])) end
				end
			else
				if Selected(ply,clientselection[1]) then Deselect(ply,clientselection[1]) else Select(ply,clientselection[1]) end
			end
		else
			for i = 1,#clientselection do Select(ply,clientselection[i]) end
		end
	end)
end

function TOOL:LeftClick(trace)
	if CLIENT then return true end
	net.Start("phys_unparent_clientselect") net.Send(self:GetOwner())
	return true
end

function TOOL:RightClick(trace) 
	if CLIENT then return true end
	local ply = self:GetOwner()
	while #ply.phys_unparent_selected > 0 do
		local ent = ply.phys_unparent_selected[1].ent
		if IsValid(ent) then
			if IsValid(ent:GetParent()) and IsValid(ent:GetParent():GetPhysicsObject()) then ent:GetParent():GetPhysicsObject():EnableMotion(false) end
			ent:SetParent(nil)
			ent:PhysicsInit(SOLID_VPHYSICS)
			if IsValid(ent:GetPhysicsObject()) then ent:GetPhysicsObject():EnableMotion(false) end
			ent:SetPos(ent:GetPos())
			duplicator.ClearEntityModifier(ent,"physparent")
		end
		Deselect(ply,ent)
	end
	return true
end

function TOOL:Reload(trace) 
	if CLIENT then return true end
	local ply = self:GetOwner()
	while #ply.phys_unparent_selected > 0 do
		Deselect(ply,ply.phys_unparent_selected[1].ent)
	end
	return true
end

function TOOL.BuildCPanel(CPanel)
	local Slider = vgui.Create("DNumSlider")
	Slider:SetDark(true)
	Slider:SetText("Area selection radius")
	Slider:SetMin(1)
	Slider:SetMax(1000)
	Slider:SetDecimals(0)
	Slider:SetValue(GetConVar("phys_unparent_radius"):GetInt())
	Slider.OnValueChanged = function()  GetConVar("phys_unparent_radius"):SetInt(Slider:GetValue())  end
	CPanel:SetName("Physical Unparent V1.03")
	CPanel:AddItem(Slider)
end
--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/prop_door.lua:
TOOL.Category = "EGM:RP Util"
TOOL.Name = "#tool.prop_door"

TOOL.ClientConVar[ "model" ] = "models/props_c17/door01_left.mdl"
TOOL.ClientConVar[ "type" ] = "1"
TOOL.ClientConVar[ "key_open" ] = "38"
TOOL.ClientConVar[ "key_close" ] = "39"
TOOL.ClientConVar[ "key_lock" ] = "40"
TOOL.ClientConVar[ "key_unlock" ] = "41"

TOOL.ClientConVar[ "auto_close" ] = "1"
TOOL.ClientConVar[ "auto_close_delay" ] = "4"

TOOL.ClientConVar[ "skin" ] = "1"

TOOL.ClientConVar[ "r_double" ] = "0"
TOOL.ClientConVar[ "r_hardware" ] = "1"
TOOL.ClientConVar[ "r_distance" ] = "90"
TOOL.ClientConVar[ "r_speed" ] = "100"

local gDoorUniqueID = 0

cleanup.Register( "prop_doors" )

function TOOL:FixPos( ent )
	if ( !IsValid( ent ) ) then return end

	local e = ent
	if ( ent.door ) then e = ent.door end

	local min = ent:OBBMins()
	local max = ent:OBBMaxs()
	local pos = ent:GetPos()
	local mdl = ent:GetModel()
	local ang = ent:GetAngles()

	local typ = self:GetClientNumber( "type" )
	local doubl = self:GetClientNumber( "r_double" ) + 1

	if ( typ == 1 or typ == 3 ) then pos = pos + ent:GetRight() * ( max.y / 2.01 ) * doubl end
	if ( typ == 2 ) then pos = pos + ent:GetRight() * ( max.y / 3.1 ) * doubl end

	if ( mdl == "models/props_mining/elevator01_cagedoor.mdl" ) then
		pos = pos - ent:GetForward() * 43
		ang:RotateAroundAxis( Vector( 0, 0, 1 ), -90 )
	else
		pos = pos - Vector( 0, 0, min.z )
	end

	if ( mdl == "models/props_combine/combine_door01.mdl" ) then ang:RotateAroundAxis( Vector( 0, 0, 1 ), -90 ) end
	if ( mdl == "models/props_mining/techgate01.mdl" ) then
		ang:RotateAroundAxis( Vector( 0, 0, 1 ), -90 )
		pos = pos - ent:GetRight() * 80
	end

	if ( mdl == "models/props/portal_door_combined.mdl" ) then
		pos = pos - ent:GetUp() * 21
		ang:RotateAroundAxis( Vector( 0, 0, 1 ), -180 )
	end

	e:SetPos( pos )
	e:SetAngles( ang )
	e:Activate()
end

if ( SERVER ) then
	CreateConVar( "sbox_maxprop_doors", 10 )

	numpad.Register( "prop_door_open", function( ply, prop_door ) if ( !IsValid( prop_door ) ) then return false end prop_door:Fire( "Open" ) end )
	numpad.Register( "prop_door_close", function( ply, prop_door ) if ( !IsValid( prop_door ) ) then return false end prop_door:Fire( "Close" ) end )
	numpad.Register( "prop_door_lock", function( ply, prop_door ) if ( !IsValid( prop_door ) ) then return false end prop_door:Fire( "Lock" ) end )
	numpad.Register( "prop_door_unlock", function( ply, prop_door ) if ( !IsValid( prop_door ) ) then return false end prop_door:Fire( "Unlock" ) end )

	function MakeDoorRotating( ply, model, pos, ang, _oSkin, keyOpen, keyClose, keyLock, keyUnlock, _oHardware, _oDistance, _oSpeed, _oReturnDelay, _oTargetName, data )
		if ( IsValid( ply ) && !ply:CheckLimit( "prop_doors" ) ) then return nil end

		local prop_door_rotating = ents.Create( "prop_door_rotating" )
		if ( !IsValid( prop_door_rotating ) ) then return false end

		prop_door_rotating:SetModel( model )
		prop_door_rotating:SetPos( pos )
		if ( data && data.initialAngles ) then ang = data.initialAngles end
		prop_door_rotating:SetAngles( ang )

		keyOpen = keyOpen or -1
		keyClose = keyClose or -1
		keyLock = keyLock or -1
		keyUnlock = keyUnlock or -1

		local targetname = _oTargetName or ""
		if ( data && data.targetname ) then targetname = data.targetname end
		local hardware = _oHardware or 1
		if ( data && data.hardware ) then hardware = data.hardware end
		local distance = _oDistance or 90
		if ( data && data.distance ) then distance = data.distance end
		local speed = _oSpeed or 100
		if ( data && data.speed ) then speed = data.speed end
		local returndelay = _oReturnDelay or 4
		if ( data && data.returndelay ) then returndelay = data.returndelay end
		local skin = _oSkin or 0
		if ( data && data.skin ) then skin = data.skin end

		local spawnflags = 8192
		//if ( data && data.spawnflags ) then spawnflags = data.spawnflags end
		local ajarangles
		if ( data && data.ajarangles ) then ajarangles = data.ajarangles end
		local axis
		if ( data && data.axis ) then axis = data.axis end
		local spawnpos
		if ( data && data.spawnpos ) then spawnpos = data.spawnpos end

		prop_door_rotating:SetKeyValue( "targetname", targetname )
		prop_door_rotating:SetKeyValue( "hardware", hardware )
		prop_door_rotating:SetKeyValue( "distance", distance )
		prop_door_rotating:SetKeyValue( "speed", speed )
		prop_door_rotating:SetKeyValue( "returndelay", returndelay )
		prop_door_rotating:SetKeyValue( "spawnflags", spawnflags )
		if ( ajarangles ) then prop_door_rotating:SetKeyValue( "ajarangles", ajarangles ) end
		if ( axis ) then prop_door_rotating:SetKeyValue( "axis", axis ) end
		if ( spawnpos ) then prop_door_rotating:SetKeyValue( "spawnpos", spawnpos ) end

		prop_door_rotating:Spawn()
		prop_door_rotating:Activate()

		prop_door_rotating:SetSkin( skin )

		numpad.OnDown( ply, keyOpen, "prop_door_open", prop_door_rotating )
		numpad.OnDown( ply, keyClose, "prop_door_close", prop_door_rotating )
		numpad.OnDown( ply, keyLock, "prop_door_lock", prop_door_rotating )
		numpad.OnDown( ply, keyUnlock, "prop_door_unlock", prop_door_rotating )

		table.Merge( prop_door_rotating:GetTable(), {
			ply = ply,
			keyOpen = keyOpen,
			keyClose = keyClose,
			keyLock = keyLock,
			keyUnlock = keyUnlock,

			rb655_dupe_data = {
				spawnflags = spawnflags,
				ajarangles = ajarangles,
				skin = skin,
				axis = axis,
				initialAngles = ang,
				spawnpos = spawnpos,
				hardware = hardware,
				distance = distance,
				speed = speed,
				returndelay = returndelay,
				targetname = targetname,

				/*slavename = slavename,
				state = 0,
				opendir = opendir,
				forceclosed = forceclosed,

				soundopenoverride = soundopenoverride,
				soundcloseoverride = soundcloseoverride,
				soundmoveoverride = soundmoveoverride,
				soundlockedoverride = soundlockedoverride,
				soundunlockedoverride = soundunlockedoverride,*/

			}
		} )

		if ( IsValid( ply ) ) then
			ply:AddCount( "prop_doors", prop_door_rotating )
			ply:AddCleanup( "prop_doors", prop_door_rotating )
		end

		DoPropSpawnedEffect( prop_door_rotating )

		return prop_door_rotating
	end
	duplicator.RegisterEntityClass( "prop_door_rotating", MakeDoorRotating, "model", "pos", "ang", "skin", "keyOpen", "keyClose", "keyLock", "keyUnlock", "rHardware", "rDistance", "rSpeed", "auto_close_delay", "targetname", "rb655_dupe_data" )

	function MakeDoorDynamic( ply, model, pos, ang, keyOpen, keyClose, keyLock, keyUnlock, auto_close_delay, skin )
		if ( IsValid( ply ) && !ply:CheckLimit( "prop_doors" ) ) then return false end

		local prop_door_dynamic = ents.Create( "prop_door_dynamic" )
		if ( !IsValid( prop_door_dynamic ) ) then return false end

		prop_door_dynamic:SetModel( model )
		prop_door_dynamic:SetPos( pos )
		prop_door_dynamic:SetAngles( ang )

		prop_door_dynamic:Spawn()
		prop_door_dynamic:Activate()

		prop_door_dynamic:SetSkin( skin or 0 )
		prop_door_dynamic:SetCloseDelay( auto_close_delay )

		numpad.OnDown( ply, keyOpen, "prop_door_open", prop_door_dynamic )
		numpad.OnDown( ply, keyClose, "prop_door_close", prop_door_dynamic )
		numpad.OnDown( ply, keyLock, "prop_door_lock", prop_door_dynamic )
		numpad.OnDown( ply, keyUnlock, "prop_door_unlock", prop_door_dynamic )

		/*table.Merge( prop_door_dynamic:GetTable(), {
			ply = ply,
			keyOpen = keyOpen,
			keyClose = keyClose,
			keyLock = keyLock,
			keyUnlock = keyUnlock,
			auto_close_delay = auto_close_delay,
			skin = skin
		} )*/

		// This shit is needed because we are using a proxy entity for dynamic doors
		table.Merge( prop_door_dynamic.door:GetTable(), {
			ply = ply,
			keyOpen = keyOpen,
			keyClose = keyClose,
			keyLock = keyLock,
			keyUnlock = keyUnlock,
			auto_close_delay = auto_close_delay,
			skin = skin
		} )

		if ( IsValid( ply ) ) then
			ply:AddCount( "prop_doors", prop_door_dynamic )
			ply:AddCleanup( "prop_doors", prop_door_dynamic )
		end

		DoPropSpawnedEffect( prop_door_dynamic )

		return prop_door_dynamic
	end
	duplicator.RegisterEntityClass( "prop_door_dynamic", MakeDoorDynamic, "model", "pos", "ang", "keyOpen", "keyClose", "keyLock", "keyUnlock", "auto_close_delay", "skin" )

end

function TOOL:LeftClick( trace )
	if ( trace.HitSky or !trace.HitPos ) then return false end
	if ( IsValid( trace.Entity ) ) then return false end
	if ( CLIENT ) then return true end

	local ply = self:GetOwner()

	local ang = Angle( 0, ply:GetAngles().y, 0 )

	local auto_close_delay = self:GetClientNumber( "auto_close_delay" )
	if ( self:GetClientNumber( "auto_close" ) <= 0 ) then auto_close_delay = -1 end

	local mdl = self:GetClientInfo( "model" )
	local kO = self:GetClientNumber( "key_open" )
	local kC = self:GetClientNumber( "key_close" )
	local kL = self:GetClientNumber( "key_lock" )
	local kU = self:GetClientNumber( "key_unlock" )

	local skin = self:GetClientNumber( "skin" ) - 1

	local rH = math.Clamp( self:GetClientNumber( "r_hardware" ), 1, 3 )
	local rD = self:GetClientNumber( "r_distance" )
	local rS = self:GetClientNumber( "r_speed" )

	local prop_door
	local prop_door2
	if ( self:GetClientNumber( "type" ) == 0 ) then
		prop_door = MakeDoorDynamic( ply, mdl, trace.HitPos, ang, kO, kC, kL, kU, auto_close_delay, skin )
		self:FixPos( prop_door )
	else
		prop_door = MakeDoorRotating( ply, mdl, trace.HitPos, ang, skin, kO, kC, kL, kU, rH, rD, rS, auto_close_delay, "rb655_door_" .. gDoorUniqueID )
		self:FixPos( prop_door )

		if ( self:GetClientNumber( "r_double" ) == 1 ) then
			local max = prop_door:OBBMaxs()
			ang:RotateAroundAxis( Vector( 0, 0, 1 ), 180 )

			prop_door2 = MakeDoorRotating( ply, mdl, trace.HitPos, ang, skin, kO, kC, kL, kU, rH, rD, rS, auto_close_delay, "rb655_door_" .. gDoorUniqueID )
			self:FixPos( prop_door2 )
		end

		gDoorUniqueID = gDoorUniqueID + 1
	end

	undo.Create( "prop_door" )
		undo.AddEntity( prop_door )
		undo.AddEntity( prop_door2 )
		undo.SetPlayer( ply )
	undo.Finish()

	return true
end

function TOOL:UpdateGhostEntity( ent, ply )
	if ( !IsValid( ent ) or !IsValid( ply ) ) then return end

	local trace = ply:GetEyeTrace()

	if ( IsValid( trace.Entity ) || !trace.Hit ) then ent:SetNoDraw( true ) return end

	ent:SetPos( trace.HitPos )
	ent:SetAngles( Angle( 0, ply:GetAngles().y, 0 ) )
	ent:SetSkin( self:GetClientNumber( "skin" ) - 1 )

	ent:SetBodygroup( 1, self:GetClientNumber( "r_hardware" ) )

	self:FixPos( ent )

	ent:SetNoDraw( false )
end

function TOOL:MakeGhostEntity( model, pos, angle )
	util.PrecacheModel( model )

	if ( SERVER && !game.SinglePlayer() ) then return end -- We do ghosting serverside in single player
	if ( CLIENT && game.SinglePlayer() ) then return end -- It's done clientside in multiplayer

	self:ReleaseGhostEntity() -- Release the old ghost entity

	--if ( !util.IsValidProp( model ) ) then return end -- Don't allow ragdolls/effects to be ghosts

	if ( CLIENT ) then self.GhostEntity = ents.CreateClientProp( model )
	else self.GhostEntity = ents.Create( "prop_dynamic" ) end

	if ( !IsValid( self.GhostEntity ) ) then self.GhostEntity = nil return end -- If there's too many entities we might not spawn..

	self.GhostEntity:SetModel( model )
	self.GhostEntity:SetPos( pos )
	self.GhostEntity:SetAngles( angle )
	self.GhostEntity:Spawn()

	self.GhostEntity:SetSolid( SOLID_VPHYSICS )
	self.GhostEntity:SetMoveType( MOVETYPE_NONE )
	self.GhostEntity:SetNotSolid( true )
	self.GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )
	self.GhostEntity:SetColor( Color( 255, 255, 255, 150 ) )
end

local OldMDL = GetConVarString( "prop_door_model" )
function TOOL:Think()
	if ( CLIENT && OldMDL != GetConVarString( "prop_door_model" ) ) then
		OldMDL = GetConVarString( "prop_door_model" )
		if ( LocalPlayer():GetTool() && LocalPlayer():GetTool( "prop_door" ) ) then LocalPlayer():GetTool():UpdateControlPanel() end
	end

	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != self:GetClientInfo( "model" ) ) then
		self:MakeGhostEntity( self:GetClientInfo( "model" ), Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
	end
	self:UpdateGhostEntity( self.GhostEntity, self:GetOwner() )
end

--[[
	Types
	0 - Dynamic door
	1 - Normal door
	2 - Normal slim door
	3 - ???
]]

list.Set( "DoorModels", "models/props_c17/door01_left.mdl", { prop_door_type = 1 } )
list.Set( "DoorModels", "models/props_c17/door02_double.mdl", { prop_door_type = 2 } )
list.Set( "DoorModels", "models/props_doors/door03_slotted_left.mdl", { prop_door_type = 1 } )

list.Set( "DoorModels", "models/props_combine/combine_door01.mdl", { prop_door_type = 0 } )
list.Set( "DoorModels", "models/combine_gate_vehicle.mdl", { prop_door_type = 0 } )
list.Set( "DoorModels", "models/combine_gate_citizen.mdl", { prop_door_type = 0 } )

list.Set( "DoorModels", "models/props_lab/elevatordoor.mdl", { prop_door_type = 0 } )
list.Set( "DoorModels", "models/props_doors/doorklab01.mdl", { prop_door_type = 0 } )

if ( IsMounted( "episodic" ) ) then list.Set( "DoorModels", "models/props_c17/door03_left.mdl", { prop_door_type = 3 } ) end
if ( IsMounted( "zps" ) ) then list.Set( "DoorModels", "models/props_corpsington/doors/swingdoor01.mdl", { prop_door_type = 1 } ) end
--if ( IsMounted( "portal" ) ) then list.Set( "DoorModels", "models/props/round_elevator_doors.mdl", { prop_door_type = 0 } ) end -- Fucked up angles & collisions

if ( IsMounted( "portal2" ) ) then
	list.Set( "DoorModels", "models/props/portal_door_combined.mdl", { prop_door_type = 0 } )
end

if ( IsMounted( "ep2" ) ) then
	list.Set( "DoorModels", "models/props_mining/elevator01_cagedoor.mdl", { prop_door_type = 0 } )
	list.Set( "DoorModels", "models/props_mining/techgate01.mdl", { prop_door_type = 0 } )
	--list.Set( "DoorModels", "models/props_silo/silo_elevator_door.mdl", { prop_door_type = 0 } ) -- No collisions
end

if ( SERVER ) then return end

TOOL.Information = { { name = "left" } }

language.Add( "tool.prop_door", "Doors" )
language.Add( "tool.prop_door.name", "Door Tool" )
language.Add( "tool.prop_door.desc", "Spawn a variety of doors" )
language.Add( "tool.prop_door.left", "Spawn a door" )

language.Add( "tool.prop_door.model", "Door Model:" )
language.Add( "tool.prop_door.key_open", "Open door" )
language.Add( "tool.prop_door.key_close", "Close Door" )
language.Add( "tool.prop_door.key_lock", "Lock Door" )
language.Add( "tool.prop_door.key_unlock", "Unlock Door" )
language.Add( "tool.prop_door.auto_close", "Auto Close" )
language.Add( "tool.prop_door.auto_close_delay", "Auto close delay:" )
language.Add( "tool.prop_door.skin", "Door skin:" )

language.Add( "tool.prop_door.specific", "Door specific options" )

language.Add( "tool.prop_door.r_double", "Make Double Doors" )
language.Add( "tool.prop_door.r_hardware", "Hardware Type" )
language.Add( "tool.prop_door.r_distance", "Rotation distance:" )
language.Add( "tool.prop_door.r_speed", "Open speed:" )

language.Add( "tool.prop_door.lever", "Lever" )
language.Add( "tool.prop_door.pushbar", "Push Bar" )
language.Add( "tool.prop_door.keypad", "Lever with Keypad" )

language.Add( "Cleanup_prop_doors", "Doors" )
language.Add( "Cleaned_prop_doors", "Cleaned up all Doors" )
language.Add( "SBoxLimit_prop_doors", "You've hit the Door limit!" )
language.Add( "Undone_prop_door", "Door undone" )

language.Add( "max_prop_doors", "Max Doors:" )

function TOOL:UpdateControlPanel( index )
	local panel = controlpanel.Get( "prop_door" )
	if ( !panel ) then Msg( "Couldn't find prop_door panel!" ) return end

	panel:ClearControls()
	self.BuildCPanel( panel )
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( panel )
	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "prop_door", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	panel:AddControl( "PropSelect", { Label = "#tool.prop_door.model", Height = 3, ConVar = "prop_door_model", Models = list.Get( "DoorModels" ) } )
	panel:AddControl( "Numpad", { Label = "#tool.prop_door.key_open", Label2 = "#tool.prop_door.key_close", Command = "prop_door_key_open", Command2 = "prop_door_key_close" } )
	panel:AddControl( "Numpad", { Label = "#tool.prop_door.key_lock", Label2 = "#tool.prop_door.key_unlock", Command = "prop_door_key_lock", Command2 = "prop_door_key_unlock" } )

	panel:AddControl( "Checkbox", { Label = "#tool.prop_door.auto_close", Command = "prop_door_auto_close" } )
	panel:AddControl( "Slider", { Label = "#tool.prop_door.auto_close_delay", Type = "Float", Min = 0, Max = 32, Command = "prop_door_auto_close_delay" } )

	local typ = GetConVarNumber( "prop_door_type" )
	local numSkins = NumModelSkins( GetConVarString( "prop_door_model" ) )

	if ( typ == 0 && numSkins <= 1 ) then return end

	panel:Help( "#tool.prop_door.specific" )

	if ( numSkins > 1 ) then
		panel:AddControl( "Slider", { Label = "#tool.prop_door.skin", Min = 1, Max = numSkins, Command = "prop_door_skin" } )
	end

	if ( typ == 0 ) then return end

	panel:AddControl( "Checkbox", { Label = "#tool.prop_door.r_double", Command = "prop_door_r_double" } )

	local r_hard = GetConVarNumber( "prop_door_r_hardware" )
	if ( ( typ != 3 && r_hard == 3 ) or ( typ == 2 && r_hard != 1 ) ) then LocalPlayer():ConCommand( "prop_door_r_hardware 1" ) end

	local r_hardware = {
		["#tool.prop_door.lever"] = { prop_door_r_hardware = "1" },
		["#tool.prop_door.pushbar"] = { prop_door_r_hardware = "2" }
	}

	if ( typ == 3 ) then r_hardware["#tool.prop_door.keypad"] = { prop_door_r_hardware = "3" } end

	if ( typ != 2 ) then
		panel:AddControl( "ListBox", { Label = "#tool.prop_door.r_hardware", Height = 68, Options = r_hardware } )
	end

	panel:AddControl( "Slider", { Label = "#tool.prop_door.r_distance", Type = "Float", Min = 72, Max = 128, Command = "prop_door_r_distance" } )
	panel:AddControl( "Slider", { Label = "#tool.prop_door.r_speed", Type = "Float", Min = 48, Max = 256, Command = "prop_door_r_speed" } )
end

--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/selfcolour.lua:

TOOL.Category = "CW:RP"
TOOL.Name = "Selbstfärben"

TOOL.ClientConVar[ "r" ] = 255
TOOL.ClientConVar[ "g" ] = 255
TOOL.ClientConVar[ "b" ] = 255
TOOL.ClientConVar[ "a" ] = 255
TOOL.ClientConVar[ "mode" ] = "0"
TOOL.ClientConVar[ "fx" ] = "0"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
}

if (CLIENT) then
	language.Add("tool.selfcolour.name", "Selbstfärben")
	language.Add("tool.selfcolour.desc", "Färbe dich selbst ein")
	language.Add("tool.selfcolour.left", "Färbe dich selbst ein")
	language.Add("tool.selfcolour.right", "Setze deine eigene Färbung zurück")
	language.Add("tool.selfcolour.mode", "Render-Modus")
	language.Add("tool.selfcolour.fx", "Render-FX")
	language.Add("tool.selfcolour.color", "Farbe")
end

local function SetColour( ply, ent, data )

	--
	-- If we're trying to make them transparent them make the render mode
	-- a transparent type. This used to fix in the engine - but made HL:S props invisible(!)
	--
	if ( data.Color && data.Color.a < 255 && data.RenderMode == RENDERMODE_NORMAL ) then
		data.RenderMode = RENDERMODE_TRANSCOLOR
	end

	if ( data.Color ) then ent:SetColor( Color( data.Color.r, data.Color.g, data.Color.b, data.Color.a ) ) end
	if ( data.RenderMode ) then ent:SetRenderMode( data.RenderMode ) end
	if ( data.RenderFX ) then ent:SetKeyValue( "renderfx", data.RenderFX ) end

	if ( SERVER ) then
		duplicator.StoreEntityModifier( ent, "colour", data )
	end

end
if ( SERVER ) then
	duplicator.RegisterEntityModifier( "colour", SetColour )
end

function TOOL:LeftClick( trace )

	local ent = self:GetOwner()
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	local r = self:GetClientNumber( "r", 0 )
	local g = self:GetClientNumber( "g", 0 )
	local b = self:GetClientNumber( "b", 0 )
	local a = self:GetClientNumber( "a", 0 )
	local fx = self:GetClientNumber( "fx", 0 )
	local mode = self:GetClientNumber( "mode", 0 )

	SetColour( self:GetOwner(), ent, { Color = Color( r, g, b, a ), RenderMode = mode, RenderFX = fx } )
	return true

end

function TOOL:RightClick( trace )

	local ent = self:GetOwner()
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end

	if ( !IsValid( ent ) ) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	SetColour( self:GetOwner(), ent, { Color = Color( 255, 255, 255, 255 ), RenderMode = 0, RenderFX = 0 } )
	return true

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.selfcolour.desc" } )

	CPanel:ToolPresets( "colour", ConVarsDefault )

	CPanel:ColorPicker( "#tool.selfcolour.color", "selfcolour_r", "selfcolour_g", "selfcolour_b", "selfcolour_a" )

	CPanel:AddControl( "ListBox", { Label = "#tool.selfcolour.mode", Options = list.Get( "RenderModes" ) } )
	CPanel:AddControl( "ListBox", { Label = "#tool.selfcolour.fx", Options = list.Get( "RenderFX" ) } )

end

list.Set( "RenderModes", "#rendermode.normal", { colour_mode = 0 } )
list.Set( "RenderModes", "#rendermode.transcolor", { colour_mode = 1 } )
list.Set( "RenderModes", "#rendermode.transtexture", { colour_mode = 2 } )
list.Set( "RenderModes", "#rendermode.glow", { colour_mode = 3 } )
list.Set( "RenderModes", "#rendermode.transalpha", { colour_mode = 4 } )
list.Set( "RenderModes", "#rendermode.transadd", { colour_mode = 5 } )
list.Set( "RenderModes", "#rendermode.transalphaadd", { colour_mode = 8 } )
list.Set( "RenderModes", "#rendermode.worldglow", { colour_mode = 9 } )

list.Set( "RenderFX", "#renderfx.none", { colour_fx = 0 } )
list.Set( "RenderFX", "#renderfx.pulseslow", { colour_fx = 1 } )
list.Set( "RenderFX", "#renderfx.pulsefast", { colour_fx = 2 } )
list.Set( "RenderFX", "#renderfx.pulseslowwide", { colour_fx = 3 } )
list.Set( "RenderFX", "#renderfx.pulsefastwide", { colour_fx = 4 } )
list.Set( "RenderFX", "#renderfx.fadeslow", { colour_fx = 5 } )
list.Set( "RenderFX", "#renderfx.fadefast", { colour_fx = 6 } )
list.Set( "RenderFX", "#renderfx.solidslow", { colour_fx = 7 } )
list.Set( "RenderFX", "#renderfx.solidfast", { colour_fx = 8 } )
list.Set( "RenderFX", "#renderfx.strobeslow", { colour_fx = 9 } )
list.Set( "RenderFX", "#renderfx.strobefast", { colour_fx = 10 } )
list.Set( "RenderFX", "#renderfx.strobefaster", { colour_fx = 11 } )
list.Set( "RenderFX", "#renderfx.flickerslow", { colour_fx = 12 } )
list.Set( "RenderFX", "#renderfx.flickerfast", { colour_fx = 13 } )
list.Set( "RenderFX", "#renderfx.distort", { colour_fx = 15 } )
list.Set( "RenderFX", "#renderfx.hologram", { colour_fx = 16 } )
list.Set( "RenderFX", "#renderfx.pulsefastwider", { colour_fx = 24 } )

--lua/improvedstacker/localify.lua:
--[[--------------------------------------------------------------------------
	Localify Module
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (MIT)

		Copyright (c) 2015 Mista-Tea

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
			
	Changelog:
----------------------------------------------------------------------------]]

--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

module( "localify", package.seeall )

languages = {
	bg        = "Bulgarian",
	cs        = "Czech",
	da        = "Danish",
	de        = "German",
	el        = "Greek",
	["en-pt"] = "Pirate",
	en        = "English",
	es        = "Spanish",
	et        = "Estonian",
	fi        = "Finnish",
	fr        = "French",
	he        = "Hebrew",
	hr        = "Croatian",
	hu        = "Hungarian",
	it        = "Italian",
	ja        = "Japanese",
	ko        = "Korean",
	lt        = "Lithuanian",
	nl        = "Dutch",
	no        = "Norwegian",
	pl        = "Polish",
	["pt-br"] = "Brazilian Portuguese",
	["pt-pt"] = "Portuguese",
	ru        = "Russian",
	sk        = "Slovak",
	["sv-se"] = "Swedish",
	th        = "Thai",
	tr        = "Turkish",
	uk        = "Ukranian",
	vi        = "Vietnamese",
	["zh-cn"] = "Simplified Chinese",
	["zh-tw"] = "Traditional Chinese",
}

localizations = localizations or {
	bg        = {},
	cs        = {},
	da        = {},
	de        = {},
	el        = {},
	["en-pt"] = {},
	en        = {},
	es        = {},
	et        = {},
	fi        = {},
	fr        = {},
	he        = {},
	hr        = {},
	hu        = {},
	it        = {},
	ja        = {},
	ko        = {},
	lt        = {},
	nl        = {},
	no        = {},
	pl        = {},
	["pt-br"] = {},
	["pt-pt"] = {},
	ru        = {},
	sk        = {},
	["sv-se"] = {},
	th        = {},
	tr        = {},
	uk        = {},
	vi        = {},
	["zh-cn"] = {},
	["zh-tw"] = {},
}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local error = error
local include = include
local tostring = tostring
local GetConVar = GetConVar
local AddCSLuaFile = AddCSLuaFile

FALLBACK = FALLBACK or "en"

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	localify.Bind( string, string, string )
--
--	Binds the token <key> and localized phrase <value> to the given language <lang>.
--
--	Example: localify.Bind( "en", "#Hello", "Hello" )
--	Example: localify.Bind( "es", "#Hello", "Hola" )
--	Example: localify.Bind( "fr", "#Hello", "Bonjour" )
--]]--
function Bind( lang, key, value )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	localizations[ lang:lower() ][ key ] = value
end

--[[--------------------------------------------------------------------------
-- 	localify.Localize( string, string, boolean [optional] )
--
--	Returns the localized phrase associated with the token <key>.
--
--	If a language <lang> is provided, the phrase bound to that language will be returned.
--	If no language is provided, the language will default to the client or server's locale.
--	If a localized phrase is not found and (returnKey) is truthsy, the key will be returned.
--	If a localized phrase is not found and (returnKey) is falsey, the phrase associated with the fallback language (en' by default) will be returned, if any.
--	Otherwise, nil will be returned if no binding exists.
--
--	Example: local str = localify.Localize( "#Hello" )             -- Returns either the locale's binding or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "es" )       -- Returns either a Spanish binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "fr" )       -- Returns either a French  binding, the locale's binding, or the default binding (if any)
--	Example: local str = localify.Localize( "#Hello", "de", true ) -- Returns either a German  binding, the locale's binding, or the key
--	Example: local str = localify.Localize( "#Hello",  nil, true ) -- Returns either the locale's binding or the key
--]]--
function Localize( key, lang, returnKey )
	-- If for some reason the given language isn't valid (e.g. user set it themselves), show an
	-- error in console letting them know and try to use the fallback language.
	if ( lang and not IsValidLanguage( lang ) ) then
		ErrorNoHalt( "Invalid localify_language provided ('"..tostring(lang).."')\n" )
		lang = FALLBACK
	end
	
	local tbl = localizations[ (lang and lang:lower()) or GetLocale() ]

	return ( tbl and tbl[ key ] )                                             -- If there is a bind, return it
		or ( returnKey and key )                                              -- If there is no bind and we want to return the key on failure, return the key
		or ( localizations[ FALLBACK ] and localizations[ FALLBACK ][ key ] ) -- If there is a bind in the fallback language, return it
		or nil                                                                -- Otherwise return nil
end



--[[--------------------------------------------------------------------------
-- 	localify.AddLanguage( string, string )
--
--	Adds a non-GMod language <lang> with the given <name> to the table of valid languages.
--
--	Example: localify.AddLanguage( "zom", "Zombie" )
--	Example: localify.AddLanguage( "fil", "Filipino" )
--]]--
function AddLanguage( lang, name )
	if ( IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = name
	localizations[ lang:lower() ] = {}
end

--[[--------------------------------------------------------------------------
-- 	localify.RemoveLanguage( string )
--
--	Removes a language <lang> from the table of valid languages.
--	If the removed language was the fallback language, "en" (English) will be
--	set as the new fallback language automatically.
--
--	Example: localify.RemoveLanguage( "zom" )
--	Example: localify.RemoveLanguage( "fil" )
--]]--
function RemoveLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then return end
	
	    languages[ lang:lower() ] = nil
	localizations[ lang:lower() ] = nil
	
	if ( lang:lower() == FALLBACK ) then FALLBACK = "en" end
end

--[[--------------------------------------------------------------------------
-- 	localify.IsValidLanguage( string )
--
--	Checks if the language <lang> has been added to Localify.
--	Returns true if valid, false if invalid.
--
--	Example: localify.IsValidLanguage( "vi" ) -- Vietnamese is supported by default, so this is true
--	Example: localify.IsValidLanguage( "zz" ) -- false by default, unless manually added
--]]--
function IsValidLanguage( lang )
	return lang and languages[ lang:lower() ]
end

--[[--------------------------------------------------------------------------
-- 	localify.SetFallbackLanguage( string )
--
--	Sets the fallback language <lang> to use when a localized phrase is unavailable.
--	This is set to "en" (English) by default.
--
--	Example: localify.SetFallbackLanguage( "de" ) -- fallback language is now German
--]]--
function SetFallbackLanguage( lang )
	if ( not IsValidLanguage( lang ) ) then error( "Invalid language provided ('"..tostring(lang).."')" ) return end
	
	FALLBACK = lang:lower()
end



--[[--------------------------------------------------------------------------
-- 	localify.GetLocale( player [optional] )
--
--	If used clientside, this will return the passed player's <ply> Localify language setting.
--	If used serverside, this will return the client's Localify language setting.
--
--	Returns the fallback language if the cvar is empty.
--	The cvar holding this value is "gmod_language".
--]]--
function GetLocale( ply )
	return ( SERVER and ply and ply:GetInfo( "localify_language" ):lower() )
	    or ( GetConVarString( "localify_language" ) == "" and FALLBACK or GetConVarString( "localify_language" ):lower() )
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLanguages()
--
--	Returns the table of valid languages and their associated names.
--]]--
function GetLanguages()
	return languages
end

--[[--------------------------------------------------------------------------
-- 	localify.GetLocalizations( string )
--
--	Gets the table of all phrases that have been bound to the passed language <lang>.
--
--	Returns the table of ALL phrases (indexed by language token) if no language <lang> is passed.
--  Returns an empty table if the language is valid but doesn't contain any bound phrases.
--	Returns nil if the language has not been added to Localify.
--
--	Example: localify.GetLocalizations()       -- returns bindings for every language
--	Example: localify.GetLocalizations( "en" ) -- returns all English bindings
--	Example: localify.GetLocalizations( "zz" ) -- returns nil by default
--]]--
function GetLocalizations( lang )
	return ( not lang and localizations ) or ( lang and localizations[ lang:lower() ] ) or nil
end

--[[--------------------------------------------------------------------------
-- 	localify.GetFallbackLanguage()
--
--	Returns the current fallback language ("en" by default).
--]]--
function GetFallbackLanguage()
	return FALLBACK
end



--[[--------------------------------------------------------------------------
-- 	localify.LoadSharedFile( string )
--
--	Loads a file <path> containing localization phrases onto the server and for connecting clients.
--]]--
function LoadSharedFile( path )
	include( path )
	if ( SERVER ) then AddCSLuaFile( path ) end
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadServerFile( string )
--
--	Loads a file <path> containing localization phrases onto the server.
--]]--
function LoadServerFile( path )
	if ( CLIENT ) then return end
	include( path )
end

--[[--------------------------------------------------------------------------
-- 	localify.LoadClientFile( string )
--
--	Loads a file <path> containing localization phrases onto connecting clients.
--]]--
function LoadClientFile( path )
	if ( SERVER ) then AddCSLuaFile( path ) return end
	include( path )
end



if ( CLIENT ) then

	-- Create a client cvar that copies the gmod_language cvar so that we can retrieve it from
	-- the server with ply:GetInfo( "localify_language" )
	CreateClientConVar( "localify_language", GetConVarString( "gmod_language" ), false, true )

	-- Check for changes to the gmod_language cvar and replicate them to localify_language
	cvars.AddChangeCallback( "gmod_language", function( name, old, new )
		if ( not IsValidLanguage( new ) ) then return end
		
		RunConsoleCommand( "localify_language", new )
	end, "localify" )

end

--lua/improvedstacker/localization.lua:
--local prefix = "#tool."..debug.getinfo( 1, "S" ).source:match(".+[/?\\?](.+)%.lua").."."

local prefix = "#tool.stacker_improved."

localify.Bind( "en",    prefix.."language_en",    "English" )
localify.Bind( "bg",    prefix.."language_bg",    "Български" )
localify.Bind( "fr",    prefix.."language_fr",    "Français" )
localify.Bind( "pl",    prefix.."language_pl",    "Polski" )
localify.Bind( "ru",    prefix.."language_ru",    "Русский" )
localify.Bind( "zh-cn", prefix.."language_zh-cn", "简体中文" )
localify.Bind( "de",    prefix.."language_de",    "Deutsch" )
localify.Bind( "tr",    prefix.."language_tr",    "Türkçe" )

--[[--------------------------------------------------------------------------
-- English Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "en", prefix.."name",                     "Stacker - Improved" )
localify.Bind( "en", prefix.."desc",                     "Easily stack duplicated props in any direction" )
localify.Bind( "en", prefix.."left",                     "Create a stack" )
localify.Bind( "en", prefix.."shift_left",               "Increase stack size" )
localify.Bind( "en", prefix.."right",                    "Create a single prop" )
localify.Bind( "en", prefix.."shift_right",              "Decrease stack size" )
localify.Bind( "en", prefix.."reload",                   "Change stack direction" )
localify.Bind( "en", "Undone_stacker_improved",          "Undone stacked prop(s)" )
-- Errors
localify.Bind( "en", prefix.."error_blocked_by_server",  "The server has blocked you from changing this console variable" )
localify.Bind( "en", prefix.."error_not_admin",          "You must be in the 'admin' usergroup to change this console variable" )
localify.Bind( "en", prefix.."error_invalid_argument",   "You must enter a valid number value" )
localify.Bind( "en", prefix.."error_max_per_stack",      "The max props that can be stacked at once is limited to " )
localify.Bind( "en", prefix.."error_too_quick",          "You are using stacker too quickly" )
localify.Bind( "en", prefix.."error_max_per_player",     "Stacker prop limit reached" )
localify.Bind( "en", prefix.."error_not_in_world",       "Stacked props must be spawned within the world" )
localify.Bind( "en", prefix.."error_max_constraints",    "Failed to create constraint, most likely ran out of entity slots" )
-- Labels
localify.Bind( "en", prefix.."label_presets",            "Stacker Presets: " )
localify.Bind( "en", prefix.."label_relative",           "Stack relative to: " )
localify.Bind( "en", prefix.."label_direction",          "Stack direction: " )
localify.Bind( "en", prefix.."label_count",              "Stack size" )
localify.Bind( "en", prefix.."label_reset_offsets",      "Reset offsets" )
localify.Bind( "en", prefix.."label_reset_angles",       "Reset angles" )
localify.Bind( "en", prefix.."label_show_settings",      "Click to show settings" )
localify.Bind( "en", prefix.."label_hide_settings",      "Click to hide settings" )
localify.Bind( "en", prefix.."label_x",                  "X  (-back, +front)" )
localify.Bind( "en", prefix.."label_y",                  "Y  (-left, +right)" )
localify.Bind( "en", prefix.."label_z",                  "Z  (-down, +up)" )
localify.Bind( "en", prefix.."label_pitch",              "Pitch  (-down, +up)" )
localify.Bind( "en", prefix.."label_yaw",                "Yaw   (-left, +right)" )
localify.Bind( "en", prefix.."label_roll",               "Roll    (-left, +right)" )
localify.Bind( "en", prefix.."label_language",           "Language: " )
localify.Bind( "en", prefix.."label_credits",            "" )
localify.Bind( "en", prefix.."label_max_per_stack",      "Stack size" )
localify.Bind( "en", prefix.."label_max_per_player",     "Props per player" )
localify.Bind( "en", prefix.."label_max_offsetx",        "Maximum X offset" )
localify.Bind( "en", prefix.."label_max_offsety",        "Maximum Y offset" )
localify.Bind( "en", prefix.."label_max_offsetz",        "Maximum Z offset" )
localify.Bind( "en", prefix.."label_delay",              "Delay" )
localify.Bind( "en", prefix.."label_opacity",            "Opacity" )
-- Checkboxes
localify.Bind( "en", prefix.."checkbox_freeze",          "Freeze stacked props" )
localify.Bind( "en", prefix.."checkbox_weld",            "Weld stacked props" )
localify.Bind( "en", prefix.."checkbox_nocollide",       "No-Collide stacked props with each other" )
localify.Bind( "en", prefix.."checkbox_nocollide_all",   "No-Collide stacked props with EVERYTHING" )
localify.Bind( "en", prefix.."checkbox_use_shift_key",   "Change stack size with SHIFT + left/right-click" )
localify.Bind( "en", prefix.."checkbox_relative",        "Stack relative to new rotation" )
localify.Bind( "en", prefix.."checkbox_material",        "Apply material" )
localify.Bind( "en", prefix.."checkbox_color",           "Apply color" )
localify.Bind( "en", prefix.."checkbox_physprop",        "Apply physical properties" )
localify.Bind( "en", prefix.."checkbox_ghost",           "Ghost all props in the stack" )
localify.Bind( "en", prefix.."checkbox_halo",            "Add halos to ghosted props" )
localify.Bind( "en", prefix.."checkbox_halo_color",      "Halo color" )
localify.Bind( "en", prefix.."checkbox_axis",            "Draw XYZ axis" )
localify.Bind( "en", prefix.."checkbox_axis_labels",     "Draw XYZ axis labels" )
localify.Bind( "en", prefix.."checkbox_axis_angles",     "Draw XYZ axis angles" )
localify.Bind( "en", prefix.."checkbox_stayinworld",     "Stay in world" )
-- Comboboxes
localify.Bind( "en", prefix.."combobox_world",           "World" )
localify.Bind( "en", prefix.."combobox_prop",            "Prop" )
localify.Bind( "en", prefix.."combobox_direction_up",    "Up" )
localify.Bind( "en", prefix.."combobox_direction_down",  "Down" )
localify.Bind( "en", prefix.."combobox_direction_front", "Front" )
localify.Bind( "en", prefix.."combobox_direction_back",  "Back" )
localify.Bind( "en", prefix.."combobox_direction_right", "Right" )
localify.Bind( "en", prefix.."combobox_direction_left",  "Left" )
localify.Bind( "en", prefix.."combobox_default",         "Default" )
localify.Bind( "en", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "en", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "en", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "en", prefix.."hud_front",                "Front" )
localify.Bind( "en", prefix.."hud_right",                "Right" )
localify.Bind( "en", prefix.."hud_up",                   "Up" )
-- Help
localify.Bind( "en", prefix.."help_max_per_player",      "Maximum stacked props each player is limited to." )
localify.Bind( "en", prefix.."help_max_per_stack",       "Maximum props per stack (left-click)." )
localify.Bind( "en", prefix.."help_delay",               "Delay (in seconds) between each Stacker use (left/right-click)" )
localify.Bind( "en", prefix.."help_max_offsetx",         "Maximum distance between stacked props (X-axis)." )
localify.Bind( "en", prefix.."help_max_offsety",         "Maximum distance between stacked props (Y-axis)." )
localify.Bind( "en", prefix.."help_max_offsetz",         "Maximum distance between stacked props (Z-axis)." )
localify.Bind( "en", prefix.."help_freeze",              "Stacked props are frozen when spawned." )
localify.Bind( "en", prefix.."help_weld",                "Stacked props are welded to each other when spawned." )
localify.Bind( "en", prefix.."help_nocollide",           "Stacked props won't collide with other stacked props." )
localify.Bind( "en", prefix.."help_nocollide_all",       "Stacked props won't collide with anything except players, NPCs, vehicles, and the world." )
localify.Bind( "en", prefix.."help_stayinworld",         "Prevents stacked props from being created outside of the map." )
-- Warnings
localify.Bind( "en", prefix.."warning_max_per_player",   "Primarily for Roleplay gamemodes. For Sandbox gamemodes, this should generally be unlimited (-1)." )
localify.Bind( "en", prefix.."warning_max_offsetx",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsety",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsetz",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_freeze",           "For DarkRP." )
localify.Bind( "en", prefix.."warning_weld",             "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide",        "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide_all",    "DO NOT CHANGE WHILE THE SERVER IS RUNNING. This uses the GM.ShouldCollide hook and is experimental. It works and is guaranteed to stop crashes from Stacker, but needs more testing." )

--[[--------------------------------------------------------------------------
-- Bulgarian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "bg", prefix.."name",                     "Натрупвач - Подобрен" )
localify.Bind( "bg", prefix.."desc",                     "Лесно натрупва еднакви предмети във всяка посока" )
localify.Bind( "bg", prefix.."left",                     "Създай натрупване" )
localify.Bind( "bg", prefix.."shift_left",               "Увеличи размера на натрупването" )
localify.Bind( "bg", prefix.."right",                    "Създай единичен обект" )
localify.Bind( "bg", prefix.."shift_right",              "Намали размера на натрупването" )
localify.Bind( "bg", prefix.."reload",                   "Смени направлението на натрупване" )
localify.Bind( "bg", "Undone_stacker_improved",          "Премахва натрупването на предмет(и)" )
-- Errors
localify.Bind( "bg", prefix.."error_blocked_by_server",  "Сървърът ви е блокирал да променяте тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_not_admin",          "Трябва да бъдете в групата 'admin' за да промените тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_invalid_argument",   "Трябва да въведете валидно число за тази стойност" )
localify.Bind( "bg", prefix.."error_max_per_stack",      "Максималния брой предмети които могат да бъдат натрупани на един път е ограничен до " )
localify.Bind( "bg", prefix.."error_too_quick",          "Използвате натрупвача твърде бързо" )
localify.Bind( "bg", prefix.."error_max_per_player",     "Ограничението за натрупани предмети е достигнато" )
localify.Bind( "bg", prefix.."error_not_in_world",       "Натрупваните предмети трябва да се създават вътре в света" )
localify.Bind( "bg", prefix.."error_max_constraints",    "Не можа да се създаде връзка, най вероятно са свършили слотовете за обекти" )
-- Labels
localify.Bind( "bg", prefix.."label_presets",            "Шаблон на натрупвача: " )
localify.Bind( "bg", prefix.."label_relative",           "Натрупвай спрямо: " )
localify.Bind( "bg", prefix.."label_direction",          "Направление на натрупване: " )
localify.Bind( "bg", prefix.."label_count",              "Размер на натрупване" )
localify.Bind( "bg", prefix.."label_reset_offsets",      "Нулиране на отместването" )
localify.Bind( "bg", prefix.."label_reset_angles",       "Нулиране на ъглите" )
localify.Bind( "bg", prefix.."label_show_settings",      "Цъкнете за показване на настройки" )
localify.Bind( "bg", prefix.."label_hide_settings",      "Цъкнете за скриване на настройки" )
localify.Bind( "bg", prefix.."label_x",                  "Абсциса  (-назад, +напред)" )
localify.Bind( "bg", prefix.."label_y",                  "Ордината  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_z",                  "Апликата  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_pitch",              "Тангаж  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_yaw",                "Азимут  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_roll",               "Крен    (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_language",           "Език: " )
localify.Bind( "bg", prefix.."label_credits",            "Преведено от: [BG][Sk&Bh]Trick or treat KID!" )
localify.Bind( "bg", prefix.."label_max_per_stack",      "Брой на натрупване" )
localify.Bind( "bg", prefix.."label_max_per_player",     "Брой предмети на играч" )
localify.Bind( "bg", prefix.."label_max_offsetx",        "Максимално отместване по абсциса" )
localify.Bind( "bg", prefix.."label_max_offsety",        "Максимално отместване по ордината" )
localify.Bind( "bg", prefix.."label_max_offsetz",        "Максимално отместване по апликата" )
localify.Bind( "bg", prefix.."label_delay",              "Закъснение" )
localify.Bind( "bg", prefix.."label_opacity",            "Тъмнота" )
-- Checkboxes
localify.Bind( "bg", prefix.."checkbox_freeze",          "Замрази натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_weld",            "Завари натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_nocollide",       "Не-сблъсък на натрупаните предмети един към друг" )
localify.Bind( "bg", prefix.."checkbox_nocollide_all",   "Не-сблъсък на натрупаните предмети с ВСИЧКО" )
//localify.Bind( "bg", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "bg", prefix.."checkbox_relative",        "Натрупвай спрямо новата ориентация" )
localify.Bind( "bg", prefix.."checkbox_material",        "Приложи текстура" )
localify.Bind( "bg", prefix.."checkbox_color",           "Приложи цвят" )
localify.Bind( "bg", prefix.."checkbox_physprop",        "Приложи физически свойства" )
localify.Bind( "bg", prefix.."checkbox_ghost",           "Сенки за всички предмети в стека" )
localify.Bind( "bg", prefix.."checkbox_halo",            "Добави ореоли към предметите сенки" )
localify.Bind( "bg", prefix.."checkbox_halo_color",      "Цвят на ореола" )
localify.Bind( "bg", prefix.."checkbox_axis",            "Чертай осите XYZ" )
localify.Bind( "bg", prefix.."checkbox_axis_labels",     "Чертай етикети на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_axis_angles",     "Чертай ъглите на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_stayinworld",     "Натрупвай в рамките на света" )
-- Comboboxes
localify.Bind( "bg", prefix.."combobox_world",           "Свят" )
localify.Bind( "bg", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "bg", prefix.."combobox_direction_up",    "Горе" )
localify.Bind( "bg", prefix.."combobox_direction_down",  "Долу" )
localify.Bind( "bg", prefix.."combobox_direction_front", "Отпред" )
localify.Bind( "bg", prefix.."combobox_direction_back",  "Отзад" )
localify.Bind( "bg", prefix.."combobox_direction_right", "Дясно" )
localify.Bind( "bg", prefix.."combobox_direction_left",  "Ляво" )
localify.Bind( "bg", prefix.."combobox_default",         "По подразбиране" )
localify.Bind( "bg", prefix.."combobox_sandbox",         "Пясъчник" )
localify.Bind( "bg", prefix.."combobox_darkrp",          "Ролева игра" )
localify.Bind( "bg", prefix.."combobox_singleplayer",    "Самостоятелна игра" )
-- HUD
localify.Bind( "bg", prefix.."hud_front",                "Отпред" )
localify.Bind( "bg", prefix.."hud_right",                "Дясно" )
localify.Bind( "bg", prefix.."hud_up",                   "Горе" )
-- Help
localify.Bind( "bg", prefix.."help_max_per_player",      "Максимален брой натрупвани предмети до които е ограничен всеки играч" )
localify.Bind( "bg", prefix.."help_max_per_stack",       "Максимален брой предмети при всяко натрупване (ляв клик)." )
localify.Bind( "bg", prefix.."help_delay",               "Закъснение (в секунди) между всяко използване на натрупвача (ляв/десен клик)" )
localify.Bind( "bg", prefix.."help_max_offsetx",         "Максимално разстояние между натрупаните предмети (абсциса)." )
localify.Bind( "bg", prefix.."help_max_offsety",         "Максимално разстояние между натрупаните предмети (ордината)." )
localify.Bind( "bg", prefix.."help_max_offsetz",         "Максимално разстояние между натрупаните предмети (апликата)." )
localify.Bind( "bg", prefix.."help_freeze",              "Натрупваните предмети са замразени при създаване." )
localify.Bind( "bg", prefix.."help_weld",                "Натрупваните предмети са заварени по между си при създаване." )
localify.Bind( "bg", prefix.."help_nocollide",           "Натрупваните предмети няма да се сблъскват с други такива." )
localify.Bind( "bg", prefix.."help_nocollide_all",       "Натрупваните предмети няма да се сблъскват с всичко освен играчи, NPC, превозни средства, и света." )
localify.Bind( "bg", prefix.."help_stayinworld",         "Предотвратява натрупваните обекти да бъдат създавани извън света." )
-- Warnings
localify.Bind( "bg", prefix.."warning_max_per_player",   "Преди всичко за режими на Ролева игра. За режим Пясъчник, това трябва генерално да бъде неограничено (-1)." )
localify.Bind( "bg", prefix.."warning_max_offsetx",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsety",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsetz",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_freeze",           "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_weld",             "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide",        "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide_all",    "НЕ ПРОМЕНЯЙТЕ ДОКАТО СЪРВЪРА РАБОТИ. Това използва кука /GM.ShouldCollide/ и е експериментално. Работи и с гаранция ще спре крашовете, но се нуждае от още тестване." )

--[[--------------------------------------------------------------------------
-- French Localization
--------------------------------------------------------------------------]]--

-- Paramètres de l'outil
localify.Bind( "fr", prefix.."name",                     "Stacker - Amélioré" )
localify.Bind( "fr", prefix.."desc",                     "Empilez facilement les props dupliqués dans n'importe quelle direction" )
localify.Bind( "fr", prefix.."left",                     "Créer une pile" )
localify.Bind( "fr", prefix.."shift_left",               "Augmenter la taille des piles" )
localify.Bind( "fr", prefix.."right",                    "Créer un seul prop" )
localify.Bind( "fr", prefix.."shift_right",              "Diminuer la taille de la pile" )
localify.Bind( "fr", prefix.."reload",                   "Changer la direction de la pile" )
localify.Bind( "fr", "Undone_stacker_improved",          "Annuler le(s) prop(s) empilé(s)" )
-- Erreurs
localify.Bind( "fr", prefix.."error_blocked_by_server",  "Le serveur vous a empêché de modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_not_admin",          "Vous devez être dans le groupe d'utilisateurs 'admin' pour modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_invalid_argument",   "Vous devez entrer une valeur numérique valide" )
localify.Bind( "fr", prefix.."error_max_per_stack",      "Les props maximum qui peuvent être empilés à la fois sont limités à " )
localify.Bind( "fr", prefix.."error_too_quick",          "Vous utilisez l'empileur trop rapidement" )
localify.Bind( "fr", prefix.."error_max_per_player",     "Limite de l'empileur atteinte" )
localify.Bind( "fr", prefix.."error_not_in_world",       "Les props empilés doivent être engendrés dans le monde" )
localify.Bind( "fr", prefix.."error_max_constraints",    "Échec de la création de la contrainte, très probablement à court d'emplacements d'entité" )
-- Etiquettes
localify.Bind( "fr", prefix.."label_presets",            "Préréglages de l'empileur " )
localify.Bind( "fr", prefix.."label_relative",           "Pile relatif au: " )
localify.Bind( "fr", prefix.."label_direction",          "Direction: " )
localify.Bind( "fr", prefix.."label_count",              "Taille" )
localify.Bind( "fr", prefix.."label_reset_offsets",      "Effacer les décalages" )
localify.Bind( "fr", prefix.."label_reset_angles",       "Effacer les angles" )
localify.Bind( "fr", prefix.."label_show_settings",      "Afficher les paramètres" )
localify.Bind( "fr", prefix.."label_hide_settings",      "Masquer les paramètres" )
localify.Bind( "fr", prefix.."label_x",                  "X  (-derrière, +devant)" )
localify.Bind( "fr", prefix.."label_y",                  "Y  (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_z",                  "Z  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_pitch",              "Pitch  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_yaw",                "Yaw   (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_roll",               "Roll    (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_language",           "Langue: " )
localify.Bind( "fr", prefix.."label_credits",            "" )
localify.Bind( "fr", prefix.."label_max_per_stack",      "Taille" )
localify.Bind( "fr", prefix.."label_max_per_player",     "Props par joueur(s)" )
localify.Bind( "fr", prefix.."label_max_offsetx",        "Décalage X maximal" )
localify.Bind( "fr", prefix.."label_max_offsety",        "Décalage Y maximal" )
localify.Bind( "fr", prefix.."label_max_offsetz",        "Décalage Z maximal" )
localify.Bind( "fr", prefix.."label_delay",              "Délai" )
localify.Bind( "fr", prefix.."label_opacity",            "Opacité" )
-- Checkboxes
localify.Bind( "fr", prefix.."checkbox_freeze",          "Geler les props empilés" )
localify.Bind( "fr", prefix.."checkbox_weld",            "Souder les props empilés" )
localify.Bind( "fr", prefix.."checkbox_nocollide",       "No-Collide les props empilés avec les autres" )
localify.Bind( "fr", prefix.."checkbox_nocollide_all",   "No-Collide les props empilés avec TOUT" )
localify.Bind( "fr", prefix.."checkbox_use_shift_key",   "Changer la taille d'empilement avec SHIFT + clic gauche/droite" )
localify.Bind( "fr", prefix.."checkbox_relative",        "Pile par rapport à la nouvelle rotation" )
localify.Bind( "fr", prefix.."checkbox_material",        "Appliquer un matériaux" )
localify.Bind( "fr", prefix.."checkbox_color",           "Appliquer une couleur" )
localify.Bind( "fr", prefix.."checkbox_physprop",        "Appliquer une propriété physique" )
localify.Bind( "fr", prefix.."checkbox_ghost",           "Traverser tout les props dans l'empilement" )
localify.Bind( "fr", prefix.."checkbox_halo",            "Ajouter des halos aux props fantômes" )
localify.Bind( "fr", prefix.."checkbox_halo_color",      "Couleur du halo" )
localify.Bind( "fr", prefix.."checkbox_axis",            "Dessiner l'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_labels",     "Dessiner des étiquettes d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_angles",     "Dessiner des angles d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_stayinworld",     "Rester dans le monde" )
-- Comboboxes
localify.Bind( "fr", prefix.."combobox_world",           "Monde" )
localify.Bind( "fr", prefix.."combobox_prop",            "Prop" )
localify.Bind( "fr", prefix.."combobox_direction_up",    "Haut" )
localify.Bind( "fr", prefix.."combobox_direction_down",  "Bas" )
localify.Bind( "fr", prefix.."combobox_direction_front", "Devant" )
localify.Bind( "fr", prefix.."combobox_direction_back",  "Derrière" )
localify.Bind( "fr", prefix.."combobox_direction_right", "Droite" )
localify.Bind( "fr", prefix.."combobox_direction_left",  "Gauche" )
localify.Bind( "fr", prefix.."combobox_default",         "Défaut" )
localify.Bind( "fr", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "fr", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "fr", prefix.."combobox_singleplayer",    "Solo" )
-- HUD
localify.Bind( "fr", prefix.."hud_front",                "Devant" )
localify.Bind( "fr", prefix.."hud_right",                "Droite" )
localify.Bind( "fr", prefix.."hud_up",                   "Haut" )
-- Aide
localify.Bind( "fr", prefix.."help_max_per_player",      "Les props empilés sont limités à chaque joueur." )
localify.Bind( "fr", prefix.."help_max_per_stack",       "Maximum de props par pile (clic gauche)." )
localify.Bind( "fr", prefix.."help_delay",               "Délai (en secondes) entre chaque utilisation de l'Empileur (clic gauche / droit)" )
localify.Bind( "fr", prefix.."help_max_offsetx",         "Distance maximale entre les props empilés (axe X)." )
localify.Bind( "fr", prefix.."help_max_offsety",         "Distance maximale entre les props empilés (axe Y)." )
localify.Bind( "fr", prefix.."help_max_offsetz",         "Distance maximale entre les props empilés (axe Z)." )
localify.Bind( "fr", prefix.."help_freeze",              "Les props empilés sont congelés lorsqu'ils sont spawn." )
localify.Bind( "fr", prefix.."help_weld",                "Les props empilés sont soudés les uns aux autres lors du spawn." )
localify.Bind( "fr", prefix.."help_nocollide",           "Les props empilés ne vont pas entrer en collision avec d'autres props empilés." )
localify.Bind( "fr", prefix.."help_nocollide_all",       "Les props empilés n'entreront en collision avec rien d'autre que les joueurs, les PNJ, les véhicules et le monde." )
localify.Bind( "fr", prefix.."help_stayinworld",         "Empêche la création de props empilés à l'extérieur de la carte." )
-- Attentions
localify.Bind( "fr", prefix.."warning_max_per_player",   "Principalement pour les modes de jeu Roleplay. Pour les modes de jeu Sandbox, cela devrait généralement être illimité (-1)." )
localify.Bind( "fr", prefix.."warning_max_offsetx",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsety",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsetz",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_freeze",           "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_weld",             "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide",        "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide_all",    "NE PAS CHANGER PENDANT QUE LE SERVEUR FONCTIONNE. Cela utilise le crochet GM.ShouldCollide et est expérimental. Cela fonctionne et est garanti pour arrêter les plantages de Stacker, mais a besoin de plus de tests." )

--[[--------------------------------------------------------------------------
-- Polish Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "pl", prefix.."name",                     "Stacker - Ulepszony" )
localify.Bind( "pl", prefix.."desc",                     "Łatwo kopiuj obiekty w dowolnym kierunku" )
localify.Bind( "pl", prefix.."left",                     "Utwórz kopię" )
localify.Bind( "pl", prefix.."shift_left",               "Zwiększ ilość kopii" )
localify.Bind( "pl", prefix.."right",                    "Utwórz pojedyńczy obiekt" )
localify.Bind( "pl", prefix.."shift_right",              "Zmniejsz ilość kopii" )
localify.Bind( "pl", prefix.."reload",                   "Zmień kierunek kopiowania" )
localify.Bind( "pl", "Undone_stacker_improved",          "Cofnięto skopiowany obiekt" )
-- Errors
localify.Bind( "pl", prefix.."error_blocked_by_server",  "Serwer zablokował twoją możliwość zmieniania wartości serwerowych" )
localify.Bind( "pl", prefix.."error_not_admin",          "Musiz być w grupie 'admin' by zmienić tę wartość konsolową" )
localify.Bind( "pl", prefix.."error_invalid_argument",   "Musisz wprowadzić poprawną wartość liczbową" )
localify.Bind( "pl", prefix.."error_max_per_stack",      "Maksymalna ilość kopii jest ograniczona do " )
localify.Bind( "pl", prefix.."error_too_quick",          "Używasz Stackera za szybko" )
localify.Bind( "pl", prefix.."error_max_per_player",     "Osiągnięto limir obiektów dla Stackera" )
localify.Bind( "pl", prefix.."error_not_in_world",       "Skopiowane obiekty nie mogą wychodzić poza mapę" )
localify.Bind( "pl", prefix.."error_max_constraints",    "Nie udało się utworzyć łaczenia, najprawdopodobniej brakuje miejsc na obiekty" )
-- Labels
localify.Bind( "pl", prefix.."label_presets",            "Ustawienia zapisane: " )
localify.Bind( "pl", prefix.."label_relative",           "Kopiowanie względem: " )
localify.Bind( "pl", prefix.."label_direction",          "Kierunek kopiowania: " )
localify.Bind( "pl", prefix.."label_count",              "Ilość kopii" )
localify.Bind( "pl", prefix.."label_reset_offsets",      "Zresetuj przesunięcia" )
localify.Bind( "pl", prefix.."label_reset_angles",       "Zresetuj kąty" )
localify.Bind( "pl", prefix.."label_show_settings",      "Pokaż ustawienia" )
localify.Bind( "pl", prefix.."label_hide_settings",      "Ukryj ustawienia" )
localify.Bind( "pl", prefix.."label_x",                  "X  (-tył, +przód)" )
localify.Bind( "pl", prefix.."label_y",                  "Y  (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_z",                  "Z  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_pitch",              "Pochylenie  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_yaw",                "Odchylenie   (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_roll",               "Przechylenie    (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_language",           "Język: " )
localify.Bind( "pl", prefix.."label_credits",            "" )
localify.Bind( "pl", prefix.."label_max_per_stack",      "Ilość kopii" )
localify.Bind( "pl", prefix.."label_max_per_player",     "Ilość obiektów na gracza" )
localify.Bind( "pl", prefix.."label_max_offsetx",        "Max przesunięcie X" )
localify.Bind( "pl", prefix.."label_max_offsety",        "Max przesunięcie Y" )
localify.Bind( "pl", prefix.."label_max_offsetz",        "Max przesunięcie Z" )
localify.Bind( "pl", prefix.."label_delay",              "Opóźnienie" )
localify.Bind( "pl", prefix.."label_opacity",            "Przezroczystość" )
-- Checkboxes
localify.Bind( "pl", prefix.."checkbox_freeze",          "Zamrażaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_weld",            "Spawaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_nocollide",       "Wyłącz kolizję pomiędzy skopiowanymi obiektami" )
localify.Bind( "pl", prefix.."checkbox_nocollide_all",   "Wyłącz kolizję skopiowanych obiektamów ze WSZYSTKIM" )
localify.Bind( "pl", prefix.."checkbox_use_shift_key",   "Zmień ilość kopii za pomocą SHIFT + lewy/prawy" )
localify.Bind( "pl", prefix.."checkbox_relative",        "Kopiuj względem nowego obrotu" )
localify.Bind( "pl", prefix.."checkbox_material",        "Zastosuj materiał" )
localify.Bind( "pl", prefix.."checkbox_color",           "Zastosuj kolor" )
localify.Bind( "pl", prefix.."checkbox_physprop",        "Zastosuj właściwości fizyczne" )
localify.Bind( "pl", prefix.."checkbox_ghost",           "Dodaj duchy obiektów wszyschich kopii" )
localify.Bind( "pl", prefix.."checkbox_halo",            "Dodaj poświatę do duchów obiektów" )
localify.Bind( "pl", prefix.."checkbox_halo_color",      "Kolor poświaty" )
localify.Bind( "pl", prefix.."checkbox_axis",            "Rysuj oś XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_labels",     "Rysuj opis osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_angles",     "Rysuj kąty osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_stayinworld",     "Zostań w środku mapy" )
-- Comboboxes
localify.Bind( "pl", prefix.."combobox_world",           "świat" )
localify.Bind( "pl", prefix.."combobox_prop",            "Obiekt" )
localify.Bind( "pl", prefix.."combobox_direction_up",    "Góra" )
localify.Bind( "pl", prefix.."combobox_direction_down",  "Dół" )
localify.Bind( "pl", prefix.."combobox_direction_front", "Przód" )
localify.Bind( "pl", prefix.."combobox_direction_back",  "Tył" )
localify.Bind( "pl", prefix.."combobox_direction_right", "Prawo" )
localify.Bind( "pl", prefix.."combobox_direction_left",  "Lewo" )
localify.Bind( "pl", prefix.."combobox_default",         "Domyślne" )
localify.Bind( "pl", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "pl", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "pl", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "pl", prefix.."hud_front",                "Przód" )
localify.Bind( "pl", prefix.."hud_right",                "Prawo" )
localify.Bind( "pl", prefix.."hud_up",                   "Góra" )
-- Help
localify.Bind( "pl", prefix.."help_max_per_player",      "Maksymalna ilość skopiowanych obiektó na gracza to." )
localify.Bind( "pl", prefix.."help_max_per_stack",       "Maksymalna ilość obiektów na kopię (lewy przycisk myszki)." )
localify.Bind( "pl", prefix.."help_delay",               "Opóźnienie (w sekundach) pomiędzy każdym użyciem Stackera (lewy/prawy przycisk)" )
localify.Bind( "pl", prefix.."help_max_offsetx",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś X)." )
localify.Bind( "pl", prefix.."help_max_offsety",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Y)." )
localify.Bind( "pl", prefix.."help_max_offsetz",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Z)." )
localify.Bind( "pl", prefix.."help_freeze",              "Skopiowane obiekty są zamrożone." )
localify.Bind( "pl", prefix.."help_weld",                "Skopiowane obiekty są zespawane do siebie." )
localify.Bind( "pl", prefix.."help_nocollide",           "Skopiowane obiekty nie będą kolidowały z innymi skopiowanymi obiektami." )
localify.Bind( "pl", prefix.."help_nocollide_all",       "Skopiowane obiekty nie będą kolidowały ze wszystkim oprócz graczy, NPCs, pojazdów, i mapy." )
localify.Bind( "pl", prefix.."help_stayinworld",         "Nie pozwalaj na tworzenie kopii poza mapą." )
-- Warnings
localify.Bind( "pl", prefix.."warning_max_per_player",   "Głównie dla trybu Roleplay. Dla trybów Sandbox, zazwyczaj powinno być nieograniczone (-1)." )
localify.Bind( "pl", prefix.."warning_max_offsetx",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsety",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsetz",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_freeze",           "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_weld",             "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide",        "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide_all",    "NIE ZMIENIAJ JEŚLI SERWER JEST WŁĄCZONY. To używa GM.ShouldCollide i jest eksperymentalne. Działa i zapobiega awarii serwera spowodowanymi Stackerem, ale wymaga dalszych testów." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "ru", prefix.."name",                     "Стакер - Улучшенный" )
localify.Bind( "ru", prefix.."desc",                     "Легко дублируйте предметы в любом направлении" )
localify.Bind( "ru", prefix.."left",                     "Стакать" )
localify.Bind( "ru", prefix.."shift_left",               "Увеличить размер стака" )
localify.Bind( "ru", prefix.."right",                    "Создать одиночный предмет" )
localify.Bind( "ru", prefix.."shift_right",              "Уменьшить размер стака" )
localify.Bind( "ru", prefix.."reload",                   "Изменить напраление стака" )
localify.Bind( "ru", "Undone_stacker_improved",          "Отменить стаканные предметы" )
-- Errors
localify.Bind( "ru", prefix.."error_blocked_by_server",  "Сервер заблокировал вас от изменения этой консольной переменной" )
localify.Bind( "ru", prefix.."error_not_admin",          "Вы должны быть в группе админа, чтобы изменить эту консольную переменную" )
localify.Bind( "ru", prefix.."error_invalid_argument",   "Вы должны ввести правильное числовое значение" )
localify.Bind( "ru", prefix.."error_max_per_stack",      "Максимальное количество предметов, которые могут быть стаканы в один момент, ограничено к " )
localify.Bind( "ru", prefix.."error_too_quick",          "Вы используете стакер слишком быстро" )
localify.Bind( "ru", prefix.."error_max_per_player",     "Достигнуто максимальное количество предметов" )
localify.Bind( "ru", prefix.."error_not_in_world",       "Стаканные предметы должны появляться в мире" )
localify.Bind( "ru", prefix.."error_max_constraints",    "Не удалось создать соединение, скорее всего, закончились слоты сущностей" )
-- Labels
localify.Bind( "ru", prefix.."label_presets",            "Готовые настройки стака: " )
localify.Bind( "ru", prefix.."label_relative",           "Стак относителен к: " )
localify.Bind( "ru", prefix.."label_direction",          "Направление стака: " )
localify.Bind( "ru", prefix.."label_count",              "Размер стака" )
localify.Bind( "ru", prefix.."label_reset_offsets",      "Сбросить отклонения" )
localify.Bind( "ru", prefix.."label_reset_angles",       "Сбросить углы" )
localify.Bind( "ru", prefix.."label_show_settings",      "Показать настройки" )
localify.Bind( "ru", prefix.."label_hide_settings",      "Спрятать настройки" )
localify.Bind( "ru", prefix.."label_x",                  "X  (-сзади, +спереди)" )
localify.Bind( "ru", prefix.."label_y",                  "Y  (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_z",                  "Z  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_pitch",              "Pitch  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_yaw",                "Yaw   (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_roll",               "Roll    (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_language",           "Язык: " )
localify.Bind( "ru", prefix.."label_credits",            "Переведено от SupinePandora43" )
localify.Bind( "ru", prefix.."label_max_per_stack",      "Размер стака" )
localify.Bind( "ru", prefix.."label_max_per_player",     "Количество предметов игрока" )
localify.Bind( "ru", prefix.."label_max_offsetx",        "Максимальное X отклонение" )
localify.Bind( "ru", prefix.."label_max_offsety",        "Максимальное Y отклонение" )
localify.Bind( "ru", prefix.."label_max_offsetz",        "Максимальное Z отклонение" )
localify.Bind( "ru", prefix.."label_delay",              "Задержка" )
localify.Bind( "ru", prefix.."label_opacity",            "Непрозрачность" )
-- Checkboxes
localify.Bind( "ru", prefix.."checkbox_freeze",          "Заморозить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_weld",            "Сварить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_nocollide",       "Отключить столкновения стаканных предметов друг с другом" )
localify.Bind( "ru", prefix.."checkbox_nocollide_all",   "Отключить столкновения стаканных предметов со ВСЕМ" )
localify.Bind( "ru", prefix.."checkbox_use_shift_key",   "Изменить размер стака с SHIFT + ЛКМ/ПКМ" )
localify.Bind( "ru", prefix.."checkbox_relative",        "Стак относителен нового поворота" )
localify.Bind( "ru", prefix.."checkbox_material",        "Применить материал" )
localify.Bind( "ru", prefix.."checkbox_color",           "Применить цвет" )
localify.Bind( "ru", prefix.."checkbox_physprop",        "Применить физические свойства" )
localify.Bind( "ru", prefix.."checkbox_ghost",           "Призрачные все предметы в стаке" )
localify.Bind( "ru", prefix.."checkbox_halo",            "Добавить обводку к призрачным предметам" )
localify.Bind( "ru", prefix.."checkbox_halo_color",      "Цвет обводки" )
localify.Bind( "ru", prefix.."checkbox_axis",            "Отрисовывать XYZ ось" )
localify.Bind( "ru", prefix.."checkbox_axis_labels",     "Отрисовывать XYZ названия осей " )
localify.Bind( "ru", prefix.."checkbox_axis_angles",     "Отрисовывать XYZ углы оси" )
localify.Bind( "ru", prefix.."checkbox_stayinworld",     "Оставаться в мире" )
-- Comboboxes
localify.Bind( "ru", prefix.."combobox_world",           "Мир" )
localify.Bind( "ru", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "ru", prefix.."combobox_direction_up",    "Верх" )
localify.Bind( "ru", prefix.."combobox_direction_down",  "Низ" )
localify.Bind( "ru", prefix.."combobox_direction_front", "Перед" )
localify.Bind( "ru", prefix.."combobox_direction_back",  "Зад" )
localify.Bind( "ru", prefix.."combobox_direction_right", "Право" )
localify.Bind( "ru", prefix.."combobox_direction_left",  "Лево" )
localify.Bind( "ru", prefix.."combobox_default",         "По умолчанию" )
localify.Bind( "ru", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "ru", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "ru", prefix.."combobox_singleplayer",    "Одиночная игра" )
-- HUD
localify.Bind( "ru", prefix.."hud_front",                "Перед" )
localify.Bind( "ru", prefix.."hud_right",                "Право" )
localify.Bind( "ru", prefix.."hud_up",                   "Верх" )
-- Help
localify.Bind( "ru", prefix.."help_max_per_player",      "Максимальное количество предметов, которые могут быть стаканы в один момент." )
localify.Bind( "ru", prefix.."help_max_per_stack",       "Максимальное количество предметов в стаке (ЛКМ)." )
localify.Bind( "ru", prefix.."help_delay",               "Задержка (в секундах) между каждым использыванием стакера (ЛКМ/ПКМ)" )
localify.Bind( "ru", prefix.."help_max_offsetx",         "Максимальная дистанция между стаканными предметами (X-ось)." )
localify.Bind( "ru", prefix.."help_max_offsety",         "Максимальная дистанция между стаканными предметами (Y-ось)." )
localify.Bind( "ru", prefix.."help_max_offsetz",         "Максимальная дистанция между стаканными предметами (Z-ось)." )
localify.Bind( "ru", prefix.."help_freeze",              "Заморозить стаканные предметы при спавне." )
localify.Bind( "ru", prefix.."help_weld",                "Сварить стаканные предметы друг к другу при спавне." )
localify.Bind( "ru", prefix.."help_nocollide",           "Стаканные предметы не будут сталкиваться друг с другом." )
localify.Bind( "ru", prefix.."help_nocollide_all",       "Отключить столкновения для стаканных предметов." )
localify.Bind( "ru", prefix.."help_stayinworld",         "Предотвращает создание стака за пределами мира." )
-- Warnings
localify.Bind( "ru", prefix.."warning_max_per_player",   "В основном для RolePlay игровых режимов. Для SandBox игровых режимов, это должно быть неограничено (-1)." )
localify.Bind( "ru", prefix.."warning_max_offsetx",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsety",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsetz",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_freeze",           "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_weld",             "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide",        "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide_all",    "НЕ ИЗМЕНЯЙТЕ ВО ВРЕМЯ РАБОТЫ СЕРВЕРА. Это использует экспериментальный GM.ShouldCollide. Это работает и гарантированно предотвращает сбои в Stacker, но требует дополнительного тестирования." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "zh-cn", prefix.."name",                     "叠加器 - 改进" )
localify.Bind( "zh-cn", prefix.."desc",                     "轻易在任何方向复制物品" )
localify.Bind( "zh-cn", prefix.."left",                     "进行一次叠加" )
localify.Bind( "zh-cn", prefix.."shift_left",               "增加叠加大小" )
localify.Bind( "zh-cn", prefix.."right",                    "叠加单个物品" )
localify.Bind( "zh-cn", prefix.."shift_right",              "减少叠加大小" )
localify.Bind( "zh-cn", prefix.."reload",                   "改变叠加方向" )
localify.Bind( "zh-cn", "Undone_stacker_improved",          "撤回叠加物品" )
-- Errors
localify.Bind( "zh-cn", prefix.."error_blocked_by_server",  "服务器禁止你修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_not_admin",          "你必须是管理员才能修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_invalid_argument",   "你必须输入一个合法数字" )
localify.Bind( "zh-cn", prefix.."error_max_per_stack",      "单次叠加物品的上限是 " )
localify.Bind( "zh-cn", prefix.."error_too_quick",          "你叠加器使用得太快了" )
localify.Bind( "zh-cn", prefix.."error_max_per_player",     "叠加器达到了物品上限" )
localify.Bind( "zh-cn", prefix.."error_not_in_world",       "叠加的物品必须生成在地图内部" )
localify.Bind( "zh-cn", prefix.."error_max_constraints",    "约束生成失败，很可能是达到了实体上限" )
-- Labels
localify.Bind( "zh-cn", prefix.."label_presets",            "叠加器预设：" )
localify.Bind( "zh-cn", prefix.."label_relative",           "叠加相对方向：" )
localify.Bind( "zh-cn", prefix.."label_direction",          "叠加方向：" )
localify.Bind( "zh-cn", prefix.."label_count",              "叠加大小：" )
localify.Bind( "zh-cn", prefix.."label_reset_offsets",      "重置位差" )
localify.Bind( "zh-cn", prefix.."label_reset_angles",       "重置角度" )
localify.Bind( "zh-cn", prefix.."label_show_settings",      "点击显示设置" )
localify.Bind( "zh-cn", prefix.."label_hide_settings",      "点击隐藏设置" )
localify.Bind( "zh-cn", prefix.."label_x",                  "X  (-后, +前)" )
localify.Bind( "zh-cn", prefix.."label_y",                  "Y  (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_z",                  "Z  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_pitch",              "Pitch  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_yaw",                "Yaw    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_roll",               "Roll    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_language",           "语言: " )
localify.Bind( "zh-cn", prefix.."label_credits",            "翻译： 8Z (STEAM_0:0:33380074)" )
localify.Bind( "zh-cn", prefix.."label_max_per_stack",      "单次叠加上限" )
localify.Bind( "zh-cn", prefix.."label_max_per_player",     "玩家叠加物品上限" )
localify.Bind( "zh-cn", prefix.."label_max_offsetx",        "最大 X 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsety",        "最大 Y 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsetz",        "最大 Z 位差" )
localify.Bind( "zh-cn", prefix.."label_delay",              "冷却" )
localify.Bind( "zh-cn", prefix.."label_opacity",            "透明度" )
-- Checkboxes
localify.Bind( "zh-cn", prefix.."checkbox_freeze",          "固定叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_weld",            "焊接叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide",       "叠加互相无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide_all",   "叠加全部无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_use_shift_key",   "更改叠加大小使用 SHIFT+左键/右键" )
localify.Bind( "zh-cn", prefix.."checkbox_relative",        "叠加使用新物品的相对角度" )
localify.Bind( "zh-cn", prefix.."checkbox_material",        "应用材质" )
localify.Bind( "zh-cn", prefix.."checkbox_color",           "应用颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_physprop",        "应用物理特性" )
localify.Bind( "zh-cn", prefix.."checkbox_ghost",           "所有叠加物品显示预览" )
localify.Bind( "zh-cn", prefix.."checkbox_halo",            "物品预览光环效果" )
localify.Bind( "zh-cn", prefix.."checkbox_halo_color",      "光环颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_axis",            "显示 XYZ 轴" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_labels",     "显示 XYZ 轴标签" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_angles",     "显示 XYZ 轴角度" )
localify.Bind( "zh-cn", prefix.."checkbox_stayinworld",     "叠加限定在地图内部" )
-- Comboboxes
localify.Bind( "zh-cn", prefix.."combobox_world",           "世界" )
localify.Bind( "zh-cn", prefix.."combobox_prop",            "物品" )
localify.Bind( "zh-cn", prefix.."combobox_direction_up",    "上" )
localify.Bind( "zh-cn", prefix.."combobox_direction_down",  "下" )
localify.Bind( "zh-cn", prefix.."combobox_direction_front", "前" )
localify.Bind( "zh-cn", prefix.."combobox_direction_back",  "后" )
localify.Bind( "zh-cn", prefix.."combobox_direction_right", "右" )
localify.Bind( "zh-cn", prefix.."combobox_direction_left",  "左" )
localify.Bind( "zh-cn", prefix.."combobox_default",         "默认" )
localify.Bind( "zh-cn", prefix.."combobox_sandbox",         "沙盘" )
localify.Bind( "zh-cn", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "zh-cn", prefix.."combobox_singleplayer",    "单人" )
-- HUD
localify.Bind( "zh-cn", prefix.."hud_front",                "前" )
localify.Bind( "zh-cn", prefix.."hud_right",                "右" )
localify.Bind( "zh-cn", prefix.."hud_up",                   "上" )
-- Help
localify.Bind( "zh-cn", prefix.."help_max_per_player",      "每个玩家堆叠物品的数量上限。" )
localify.Bind( "zh-cn", prefix.."help_max_per_stack",       "单次堆叠（左键）时的物品上限。" )
localify.Bind( "zh-cn", prefix.."help_delay",               "每次使用堆叠器（左键/右键）后的冷却。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetx",         "叠加物品间的最大位差（X轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsety",         "叠加物品间的最大位差（Y轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetz",         "叠加物品间的最大位差（Z轴）。" )
localify.Bind( "zh-cn", prefix.."help_freeze",              "叠加的物品刷出后固定。" )
localify.Bind( "zh-cn", prefix.."help_weld",                "叠加的物品刷出后互相焊接。" )
localify.Bind( "zh-cn", prefix.."help_nocollide",           "叠加的物品和其他叠加物品无碰撞。" )
localify.Bind( "zh-cn", prefix.."help_nocollide_all",       "叠加的物品只会和玩家，NPC，车辆和世界碰撞。" )
localify.Bind( "zh-cn", prefix.."help_stayinworld",         "避免叠加的物品刷出在地图外部。" )
-- Warnings
localify.Bind( "zh-cn", prefix.."warning_max_per_player",   "主要用于角色扮演模式的设置。沙盘模式下这个应该是无限的（-1）。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetx",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsety",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetz",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_freeze",           "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_weld",             "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide",        "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide_all",    "绝对不要在服务器运作时修改！这个实验性的功能调用 GM.ShouldCollide。这个设置管用且必定能够避免叠加器崩服，但需要更多的测试。" )

--[[--------------------------------------------------------------------------
-- German Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "de", prefix.."name",                     "Stapler - Verbessert" )
localify.Bind( "de", prefix.."desc",                     "Einfaches Stapeln von duplizierten Props in jede Richtung" )
localify.Bind( "de", prefix.."left",                     "Stapel erstellen" )
localify.Bind( "de", prefix.."shift_left",               "Stapelgröße erhöhen" )
localify.Bind( "de", prefix.."right",                    "Einzelnes Prop erstellen" )
localify.Bind( "de", prefix.."shift_right",              "Stapelgröße verkleinern" )
localify.Bind( "de", prefix.."reload",                   "Stapelrichtung ändern" )
localify.Bind( "de", "Undone_stacker_improved",          "Gestapelte Prop(s) rückgängig machen" )
-- Errors
localify.Bind( "de", prefix.."error_blocked_by_server",  "Der Server hat dich daran gehindert, diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_not_admin",          "Du musst dich in der Benutzergruppe 'admin' befinden, um diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_invalid_argument",   "Du musst einen gültigen Zahlenwert eingeben" )
localify.Bind( "de", prefix.."error_max_per_stack",      "Die maximale Anzahl von Props, die auf einmal gestapelt werden können, ist begrenzt auf " )
localify.Bind( "de", prefix.."error_too_quick",          "Du verwendest den Stapler zu schnell" )
localify.Bind( "de", prefix.."error_max_per_player",     "Stapler prop limit erreicht" )
localify.Bind( "de", prefix.."error_not_in_world",       "Gestapelte Props müssen innerhalb der Welt gespawnt werden" )
localify.Bind( "de", prefix.."error_max_constraints",    "Constraint konnte nicht erstellt werden ")
-- Labels
localify.Bind( "de", prefix.."label_presets",            "Stapler-Voreinstellungen: " )
localify.Bind( "de", prefix.."label_relative",           "Stapel relativ zu: " )
localify.Bind( "de", prefix.."label_direction",          "Stapelrichtung: " )
localify.Bind( "de", prefix.."label_count",              "Stapelgröße" )
localify.Bind( "de", prefix.."label_reset_offsets",      "Versätze zurücksetzen" )
localify.Bind( "de", prefix.."label_reset_angles",       "Winkel zurücksetzen" )
localify.Bind( "de", prefix.."label_show_settings",      "Zum Anzeigen der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_hide_settings",      "Zum Verstecken der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_x",                  "X  (-Hinten, +Vorne)" )
localify.Bind( "de", prefix.."label_y",                  "Y  (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_z",                  "Z  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_pitch",              "Nicken  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_yaw",                "Gieren   (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_roll",               "Roll    (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_language",           "Sprache: " )
localify.Bind( "de", prefix.."label_credits",            "" )
localify.Bind( "de", prefix.."label_max_per_stack",      "Stapelgröße" )
localify.Bind( "de", prefix.."label_max_per_player",     "Props je Spieler" )
localify.Bind( "de", prefix.."label_max_offsetx",        "Maximaler X-Offset" )
localify.Bind( "de", prefix.."label_max_offsety",        "Maximaler Y-Offset" )
localify.Bind( "de", prefix.."label_max_offsetz",        "Maximaler Z-Offset" )
localify.Bind( "de", prefix.."label_delay",              "Delay/Verzögerung" )
localify.Bind( "de", prefix.."label_opacity",            "Deckkraft" )
-- Checkboxes
localify.Bind( "de", prefix.."checkbox_freeze",          "Einfrieren gestapelter Props" )
localify.Bind( "de", prefix.."checkbox_weld",            "Verbinde gestapelte Props" )
localify.Bind( "de", prefix.."checkbox_nocollide",       "Keine-Kollision der gestapelte Props mit einander" )
localify.Bind( "de", prefix.."checkbox_nocollide_all",   "Keine-Kollision der gestapelte Props mit ALLEM" )
localify.Bind( "de", prefix.."checkbox_use_shift_key",   "Stapelgröße mit SHIFT + Links-/Rechtsklick ändern" )
localify.Bind( "de", prefix.."checkbox_relative",        "Stapel relativ zur neuen Drehung" )
localify.Bind( "de", prefix.."checkbox_material",        "Material anwenden" )
localify.Bind( "de", prefix.."checkbox_color",           "Farbe anwenden" )
localify.Bind( "de", prefix.."checkbox_physprop",        "Physikalische Eigenschaften anwenden" )
localify.Bind( "de", prefix.."checkbox_ghost",           "Ghoste alle Props im Stapel" )
localify.Bind( "de", prefix.."checkbox_halo",            "Halos zu geghosteten Props hinzufügen" )
localify.Bind( "de", prefix.."checkbox_halo_color",      "Halo-Farbe" )
localify.Bind( "de", prefix.."checkbox_axis",            "XYZ-Achse zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_labels",     "XYZ-Achsenbeschriftungen zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_angles",     "XYZ-Achsenwinkel zeigen" )
localify.Bind( "de", prefix.."checkbox_stayinworld",     "In der Welt bleiben" )
-- Comboboxes
localify.Bind( "de", prefix.."combobox_world",           "Welt" )
localify.Bind( "de", prefix.."combobox_prop",            "Prop" )
localify.Bind( "de", prefix.."combobox_direction_up",    "Hoch" )
localify.Bind( "de", prefix.."combobox_direction_down",  "Runter" )
localify.Bind( "de", prefix.."combobox_direction_front", "Vorne" )
localify.Bind( "de", prefix.."combobox_direction_back",  "Hinten" )
localify.Bind( "de", prefix.."combobox_direction_right", "Rechts" )
localify.Bind( "de", prefix.."combobox_direction_left",  "Links" )
localify.Bind( "de", prefix.."combobox_default",         "Standard" )
localify.Bind( "de", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "de", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "de", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "de", prefix.."hud_front",                "Vorne" )
localify.Bind( "de", prefix.."hud_right",                "Rechts" )
localify.Bind( "de", prefix.."hud_up",                   "Hoch" )
-- Help
localify.Bind( "de", prefix.."help_max_per_player",      "Die maximale Anzahl gestapelter Props pro Spieler ist begrenzt." )
localify.Bind( "de", prefix.."help_max_per_stack",       "Maximale Props pro Stapel (Linksklick)." )
localify.Bind( "de", prefix.."help_delay",               "Verzögerung (in Sekunden) zwischen jeder Stacker-Verwendung (Links-/Rechtsklick)" )
localify.Bind( "de", prefix.."help_max_offsetx",         "Maximaler Abstand zwischen gestapelten Props (X-Achse)." )
localify.Bind( "de", prefix.."help_max_offsety",         "Maximaler Abstand zwischen gestapelten Props (Y-Achse)." )
localify.Bind( "de", prefix.."help_max_offsetz",         "Maximaler Abstand zwischen gestapelten Props (Z-Achse)." )
localify.Bind( "de", prefix.."help_freeze",              "Gestapelte Props werden beim Spawnen eingefroren." )
localify.Bind( "de", prefix.."help_weld",                "Gestapelte Stützen werden beim Spawnen aneinander verbunden." )
localify.Bind( "de", prefix.."help_nocollide",           "Gestapelte Props kollidieren nicht mit anderen gestapelten Props." )
localify.Bind( "de", prefix.."help_nocollide_all",       "Gestapelte Props kollidieren mit nichts außer Spielern, NPCs, Fahrzeugen und der Welt." )
localify.Bind( "de", prefix.."help_stayinworld",         "Verhindert, dass gestapelte Props außerhalb der Map erstellt werden." )
-- Warnings
localify.Bind( "de", prefix.."warning_max_per_player",   "In erster Linie für Rollenspiel-Gamemodi. Für Sandbox-Gamemodes sollte dies generell unbegrenzt sein (-1)." )
localify.Bind( "de", prefix.."warning_max_offsetx",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsety",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsetz",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_freeze",           "Für DarkRP." )
localify.Bind( "de", prefix.."warning_weld",             "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide",        "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide_all",    "ÄNDERE NICHTS, WÄHREND DER SERVER AUSGEFÜHRT WIRD. Dies verwendet den GM.ShouldCollide-Hook und ist experimentell. Es funktioniert und verhindert garantiert Abstürze von Stacker, muss aber noch weiter getestet werden." )

--[[--------------------------------------------------------------------------
-- Turkish Localization
-- Big thanks to Matt (STEAM_0:1:241718138) for these translations!
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "tr", prefix.."name",                     "Geliştirilmiş Yığıcı" )
localify.Bind( "tr", prefix.."desc",                     "Kopyalanan nesneleri herhangi bir yönde kolayca yığın" )
localify.Bind( "tr", prefix.."left",                     "Bir yığın oluştur" )
localify.Bind( "tr", prefix.."shift_left",               "Yığın boyutunu artır" )
localify.Bind( "tr", prefix.."right",                    "Tek bir nesne oluştur" )
localify.Bind( "tr", prefix.."shift_right",              "Yığın boyutunu azalt" )
localify.Bind( "tr", prefix.."reload",                   "Yığın yönünü değiştir" )
localify.Bind( "tr", "Undone_stacker_improved",          "Yığınlanmış nesne(ler) geri alındı" )
-- Errors                                              
localify.Bind( "tr", prefix.."error_blocked_by_server",  "Sunucu bu konsol değişkenini değiştirmenizi engelledi" )
localify.Bind( "tr", prefix.."error_not_admin",          "Bu konsol değişkenini değiştirmek için 'admin' kullanıcı grubunda olmanız gerekir" )
localify.Bind( "tr", prefix.."error_invalid_argument",   "Geçerli bir sayı değeri girmelisiniz" )
localify.Bind( "tr", prefix.."error_max_count",          "Bir kerede yığılabilecek maksimum nesne sayısı sınırlıdır" )
localify.Bind( "tr", prefix.."error_too_quick",          "Yığınlayıcıyı çok hızlı kullanıyorsunuz" )
localify.Bind( "tr", prefix.."error_max_total",          "Yığınlayıcı destek sınırına ulaşıldı" )
localify.Bind( "tr", prefix.."error_not_in_world",       "Yığılmış nesneler dünya içinde oluşturulmalıdır" )
localify.Bind( "tr", prefix.."error_max_constraints",    "Kısıtlama oluşturulamadı, büyük olasılıkla varlık yuvaları tükendi" )
-- Labels                                              
localify.Bind( "tr", prefix.."label_presets",            "Yığınlayıcı Ön Ayarları: " )
localify.Bind( "tr", prefix.."label_relative",           "Göreceli yığın: " )
localify.Bind( "tr", prefix.."label_direction",          "Yığın yönü: " )
localify.Bind( "tr", prefix.."label_count",              "Yığın boyutu" )
localify.Bind( "tr", prefix.."label_reset_offsets",      "Ofsetleri sıfırla" )
localify.Bind( "tr", prefix.."label_reset_angles",       "Açıları sıfırla" )
localify.Bind( "tr", prefix.."label_show_settings",      "Ayarları göstermek için tıklayın" )
localify.Bind( "tr", prefix.."label_hide_settings",      "Ayarları gizlemek için tıklayın" )
localify.Bind( "tr", prefix.."label_x",                  "X (-arka, +ön)" )
localify.Bind( "tr", prefix.."label_y",                  "E (-sol, +sağ)" )
localify.Bind( "tr", prefix.."label_z",                  "Z (-aşağı, +yukarı)" )
localify.Bind( "tr", prefix.."label_pitch",              "Pitch (-aşağı, +yukarı)" )
localify.Bind( "tr", prefix.."label_yaw",                "Yaw (-sol, +sağ)" )
localify.Bind( "tr", prefix.."label_roll",               "Döndür (-sola, +sağa)" )
localify.Bind( "tr", prefix.."label_language",           "Dil: Türkçe" )
localify.Bind( "tr", prefix.."label_credits",            "Türkçeye Matt tarafından çevrilmiştir (STEAM_0:1:241718138)" )
localify.Bind( "tr", prefix.."label_max_per_stack",      "Yığın boyutu" )
localify.Bind( "tr", prefix.."label_max_per_player",     "Oyuncu başına nesne" )
localify.Bind( "tr", prefix.."label_max_offsetx",        "Maksimum X ofseti" ) 
localify.Bind( "tr", prefix.."label_max_offsety",        "Maksimum Y ofseti" )
localify.Bind( "tr", prefix.."label_max_offsetz",        "Maksimum Z ofseti" )
localify.Bind( "tr", prefix.."label_delay",              "Gecikme" )
localify.Bind( "tr", prefix.."label_opacity",            "Opaklık" )
-- Checkboxes                                          
localify.Bind( "tr", prefix.."checkbox_freeze",          "Yığınlanmış nesneleri dondur" )
localify.Bind( "tr", prefix.."checkbox_weld",            "Yığılmış nesneleri yapıştır" )
localify.Bind( "tr", prefix.."checkbox_nocollide",       "Yığılmış nesnelerin birbirine çarpmasını engelle" )
localify.Bind( "tr", prefix.."checkbox_nocollide_all",   "Yığılmış nesnelerin her şey ile çarpışmasını engelle" )
localify.Bind( "tr", prefix.."checkbox_use_shift_key",   "SHIFT + sol/sağ tıklamayla yığın boyutunu değiştir" )
localify.Bind( "tr", prefix.."checkbox_relative",        "Yeni rotasyona göre yığın" )
localify.Bind( "tr", prefix.."checkbox_material",        "Materyali uygula" )
localify.Bind( "tr", prefix.."checkbox_color",           "Renk uygula" )
localify.Bind( "tr", prefix.."checkbox_physprop",        "Fiziksel özellikleri uygula" )
localify.Bind( "tr", prefix.."checkbox_ghost",           "Yığındaki tüm nesneleri gizle" )
localify.Bind( "tr", prefix.."checkbox_halo",            "Gizlenmiş nesnelere ışık halkası ekle" )
localify.Bind( "tr", prefix.."checkbox_halo_color",      "Işık halkası rengi" )
localify.Bind( "tr", prefix.."checkbox_axis",            "XYZ eksenini çiz" )
localify.Bind( "tr", prefix.."checkbox_axis_labels",     "XYZ eksen etiketlerini çizin" )
localify.Bind( "tr", prefix.."checkbox_axis_angles",     "XYZ eksen açılarını çiz" )
localify.Bind( "tr", prefix.."checkbox_stayinworld",     "Dünyada kal" )
-- Comboboxes                                          
localify.Bind( "tr", prefix.."combobox_world",           "Dünya" )
localify.Bind( "tr", prefix.."combobox_prop",            "Nesne" )
localify.Bind( "tr", prefix.."combobox_direction_up",    "Yukarı" )
localify.Bind( "tr", prefix.."combobox_direction_down",  "Aşağı" )
localify.Bind( "tr", prefix.."combobox_direction_front", "Ön" )
localify.Bind( "tr", prefix.."combobox_direction_back",  "Geri" )
localify.Bind( "tr", prefix.."combobox_direction_right", "Sağ" )
localify.Bind( "tr", prefix.."combobox_direction_left",  "Sol" )
localify.Bind( "tr", prefix.."combobox_default",         "Varsayılan" )
localify.Bind( "tr", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "tr", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "tr", prefix.."combobox_singleplayer",    "Tek oyuncu" )
-- HUD                                                 
localify.Bind( "tr", prefix.."hud_front",                "Ön" )
localify.Bind( "tr", prefix.."hud_right",                "Sağ" )
localify.Bind( "tr", prefix.."hud_up",                   "Yukarı" )
-- Help                                                
localify.Bind( "tr", prefix.."help_max_per_player",      "Her oyuncunun maksimum yığılmış nesnesi sınırlıdır." )
localify.Bind( "tr", prefix.."help_max_per_stack",       "Yığın başına maksimum nesne (sol tıklama)." )
localify.Bind( "tr", prefix.."help_delay",               "Her yığınlayıcı kullanımı arasındaki gecikme (saniye cinsinden) (sol/sağ tıklama)" )
localify.Bind( "tr", prefix.."help_max_offsetx",         "Yığılmış nesneler arasındaki maksimum mesafe (X ekseni)." )
localify.Bind( "tr", prefix.."help_max_offsety",         "Yığılmış nesneler arasındaki maksimum mesafe (Y ekseni)." )
localify.Bind( "tr", prefix.."help_max_offsetz",         "Yığılmış nesneler arasındaki maksimum mesafe (Z ekseni)." )
localify.Bind( "tr", prefix.."help_freeze",              "Yığılmış nesneler ortaya çıktığında donar." )
localify.Bind( "tr", prefix.."help_weld",                "Yığılmış nesneler, ortaya çıktıklarında birbirine yapışır." )
localify.Bind( "tr", prefix.."help_nocollide",           "Yığılmış nesneler diğer yığılmış nesnelerle çarpışmaz." )
localify.Bind( "tr", prefix.."help_nocollide_all",       "Yığılmış nesneler oyuncular, NPC'ler, araçlar ve dünya dışında hiçbir şeyle çarpışmaz." )
localify.Bind( "tr", prefix.."help_stayinworld",         "Yığınlanmış nesnelerin harita dışında oluşturulmasını önler." )
-- Warnings                                            
localify.Bind( "tr", prefix.."warning_max_per_player",   "Öncelikle Rol Yapma oyun modları için. Sandbox oyun modları için bu genellikle sınırsız olmalıdır (-1)." )
localify.Bind( "tr", prefix.."warning_max_offsetx",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_max_offsety",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_max_offsetz",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_freeze",           "DarkRP için." )
localify.Bind( "tr", prefix.."warning_weld",             "DarkRP için." )
localify.Bind( "tr", prefix.."warning_nocollide",        "DarkRP için." )
localify.Bind( "tr", prefix.."warning_nocollide_all",    "SUNUCU ÇALIŞIRKEN DEĞİŞTİRMEYİN. Bu, GM.ShouldCollide kancasını kullanır ve deneyseldir. Çalışır ve yığınlayıcıdan kaynaklanan çökmeleri durdurması garanti edilir, ancak daha fazla test yapılması gerekiyor." )

--[[--------------------------------------------------------------------------
-- <Other> Localization
--------------------------------------------------------------------------]]--
--[[
-- Tool Settings
localify.Bind( "", prefix.."name",                     "" )
localify.Bind( "", prefix.."desc",                     "" )
localify.Bind( "", prefix.."left",                     "" )
localify.Bind( "", prefix.."shift_left",               "" )
localify.Bind( "", prefix.."right",                    "" )
localify.Bind( "", prefix.."shift_right",              "" )
localify.Bind( "", prefix.."reload",                   "" )
localify.Bind( "", "Undone_stacker_improved",          "" )
-- Errors
localify.Bind( "", prefix.."error_blocked_by_server",  "" )
localify.Bind( "", prefix.."error_not_admin",          "" )
localify.Bind( "", prefix.."error_invalid_argument",   "" )
localify.Bind( "", prefix.."error_max_count",          "" )
localify.Bind( "", prefix.."error_too_quick",          "" )
localify.Bind( "", prefix.."error_max_total",          "" )
localify.Bind( "", prefix.."error_not_in_world",       "" )
localify.Bind( "", prefix.."error_max_constraints",    "" )
-- Labels
localify.Bind( "", prefix.."label_presets",            "" )
localify.Bind( "", prefix.."label_relative",           "" )
localify.Bind( "", prefix.."label_direction",          "" )
localify.Bind( "", prefix.."label_count",              "" )
localify.Bind( "", prefix.."label_reset_offsets",      "" )
localify.Bind( "", prefix.."label_reset_angles",       "" )
localify.Bind( "", prefix.."label_show_settings",      "" )
localify.Bind( "", prefix.."label_hide_settings",      "" )
localify.Bind( "", prefix.."label_x",                  "" )
localify.Bind( "", prefix.."label_y",                  "" )
localify.Bind( "", prefix.."label_z",                  "" )
localify.Bind( "", prefix.."label_pitch",              "" )
localify.Bind( "", prefix.."label_yaw",                "" )
localify.Bind( "", prefix.."label_roll",               "" )
localify.Bind( "", prefix.."label_language",           "" )
localify.Bind( "", prefix.."label_credits",            "" )
localify.Bind( "", prefix.."label_max_per_stack",      "" )
localify.Bind( "", prefix.."label_max_per_player",     "" )
localify.Bind( "", prefix.."label_max_offsetx",        "" ) 
localify.Bind( "", prefix.."label_max_offsety",        "" )
localify.Bind( "", prefix.."label_max_offsetz",        "" )
localify.Bind( "", prefix.."label_delay",              "" )
localify.Bind( "", prefix.."label_opacity",            "" )
-- Checkboxes
localify.Bind( "", prefix.."checkbox_freeze",          "" )
localify.Bind( "", prefix.."checkbox_weld",            "" )
localify.Bind( "", prefix.."checkbox_nocollide",       "" )
localify.Bind( "", prefix.."checkbox_nocollide_all",   "" )
localify.Bind( "", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "", prefix.."checkbox_relative",        "" )
localify.Bind( "", prefix.."checkbox_material",        "" )
localify.Bind( "", prefix.."checkbox_color",           "" )
localify.Bind( "", prefix.."checkbox_physprop",        "" )
localify.Bind( "", prefix.."checkbox_ghost",           "" )
localify.Bind( "", prefix.."checkbox_halo",            "" )
localify.Bind( "", prefix.."checkbox_halo_color",      "" )
localify.Bind( "", prefix.."checkbox_axis",            "" )
localify.Bind( "", prefix.."checkbox_axis_labels",     "" )
localify.Bind( "", prefix.."checkbox_axis_angles",     "" )
localify.Bind( "", prefix.."checkbox_stayinworld",     "" )
-- Comboboxes
localify.Bind( "", prefix.."combobox_world",           "" )
localify.Bind( "", prefix.."combobox_prop",            "" )
localify.Bind( "", prefix.."combobox_direction_up",    "" )
localify.Bind( "", prefix.."combobox_direction_down",  "" )
localify.Bind( "", prefix.."combobox_direction_front", "" )
localify.Bind( "", prefix.."combobox_direction_back",  "" )
localify.Bind( "", prefix.."combobox_direction_right", "" )
localify.Bind( "", prefix.."combobox_direction_left",  "" )
localify.Bind( "", prefix.."combobox_default",         "" )
localify.Bind( "", prefix.."combobox_sandbox",         "" )
localify.Bind( "", prefix.."combobox_darkrp",          "" )
localify.Bind( "", prefix.."combobox_singleplayer",    "" )
-- HUD
localify.Bind( "", prefix.."hud_front",                "" )
localify.Bind( "", prefix.."hud_right",                "" )
localify.Bind( "", prefix.."hud_up",                   "" )
-- Help
localify.Bind( "", prefix.."help_max_per_player",      "" )
localify.Bind( "", prefix.."help_max_per_stack",       "" )
localify.Bind( "", prefix.."help_delay",               "" )
localify.Bind( "", prefix.."help_max_offsetx",         "" )
localify.Bind( "", prefix.."help_max_offsety",         "" )
localify.Bind( "", prefix.."help_max_offsetz",         "" )
localify.Bind( "", prefix.."help_freeze",              "" )
localify.Bind( "", prefix.."help_weld",                "" )
localify.Bind( "", prefix.."help_nocollide",           "" )
localify.Bind( "", prefix.."help_nocollide_all",       "" )
localify.Bind( "", prefix.."help_stayinworld",         "" )
-- Warnings
localify.Bind( "", prefix.."warning_max_per_player",   "" )
localify.Bind( "", prefix.."warning_max_offsetx",      "" )
localify.Bind( "", prefix.."warning_max_offsety",      "" )
localify.Bind( "", prefix.."warning_max_offsetz",      "" )
localify.Bind( "", prefix.."warning_freeze",           "" )
localify.Bind( "", prefix.."warning_weld",             "" )
localify.Bind( "", prefix.."warning_nocollide",        "" )
localify.Bind( "", prefix.."warning_nocollide_all",    "" )
]]

-- Hopefully will add more with community/crowdsource support.

-- If you are multi/bilingual, please consider helping me translate the phrases above into other languages.
-- Create an issue on the Github page ( https://github.com/Mista-Tea/improved-stacker ) or
-- add me on Steam ( http://steamcommunity.com/profiles/76561198015280374 ). Thanks!

--lua/weapons/gmod_tool/stools/submaterial.lua:

TOOL.Category = "Render"
TOOL.Name = "SubMaterial"--"#tool.material.name"
if CLIENT then
	language.Add( "tool.submaterial.name", "SubMaterial Tool" )
	language.Add( "tool.submaterial.desc", "Allow to override submaterials of model." )
	language.Add( "tool.submaterial.0", "Wheel Up/Down: Select target part, Primary: Apply material, Secondary: Set default material, Reload: Copy material" )
	language.Add( "tool.submaterial.help", "Select material here, type known material string or use HUD to copy materials" )
end
TOOL.ClientConVar[ "override" ] = "debug/env_cubemap_model"
TOOL.ClientConVar[ "index" ] = 0

--
-- Duplicator function
--
local function SetSubMaterial( Player, Entity, Data )
	
	if ( SERVER ) then
		local Mats=Entity:GetMaterials()
		local MatCount=table.Count(Mats)
		for i=0,MatCount-1 do
			local si="SubMaterialOverride_"..tostring(i)
			-- Block exploitable material in multiplayer and remove empty strings
			if Data[si] and ((!game.SinglePlayer() && string.lower(Data[si]) == "pp/copy" ) or Data[si] == "" ) then 
				Data[si]=nil
			end
			Entity:SetSubMaterial( i, Data[si] or "")			
		end
		duplicator.ClearEntityModifier( Entity, "submaterial")
		if (table.Count(Data) > 0) then duplicator.StoreEntityModifier( Entity, "submaterial", Data ) end
	end

	return true

end
duplicator.RegisterEntityModifier( "submaterial", SetSubMaterial )

local function UpdateSubMat(Player, Entity, Index, Material)
	local Mats=Entity:GetMaterials()
	local MatCount=table.Count(Mats)
	if Index < 0 or Index >= MatCount then return end
	local Data={}
	for i=0,MatCount-1 do
		local mat=Entity:GetSubMaterial(i)
		if i==Index then mat=Material end
		if mat and mat ~= "" then Data["SubMaterialOverride_"..tostring(i)]=mat end	
	end
	return SetSubMaterial(Player, Entity, Data)		
end


-- Original set material funct
local function SetMaterial( Player, Entity, Data )
	
	if ( SERVER ) then

		--
		-- Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits
		--
		--if ( !game.SinglePlayer() && !list.Contains( "OverrideMaterials", Data.MaterialOverride ) && Data.MaterialOverride != "" ) then return end
		if not Data.MaterialOverride or (Data.MaterialOverride and (!game.SinglePlayer() && string.lower(Data.MaterialOverride) == "pp/copy" )) then 
			return
		end
		Entity:SetMaterial( Data.MaterialOverride )
		duplicator.StoreEntityModifier( Entity, "material", Data )
	end

	return true

end
--and we will override it because original function eats most of materials even not exploitable! :(
duplicator.RegisterEntityModifier( "material", SetMaterial )


--
-- Left click applies the current material
--
function TOOL:LeftClick( trace )
	if ( !IsValid( trace.Entity ) ) then return end

	if ( CLIENT ) then return true end
	
	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end

	local mat = self:GetClientInfo( "override" )
	local index = self:GetClientNumber( "index" , 0)
	if index < 1 then
		SetMaterial( self:GetOwner(), ent, { MaterialOverride = mat } )
	else
		UpdateSubMat( self:GetOwner(), ent, index-1, mat )
	end	
	return true

end

--
-- Right click reverts the material
--
function TOOL:RightClick( trace )
	
	if ( !IsValid( trace.Entity ) ) then return end

	if ( CLIENT ) then return true end
	
	local ent = trace.Entity
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	local index = self:GetClientNumber( "index" , 0)
	if index < 1 then
		SetMaterial( self:GetOwner(), ent, { MaterialOverride = "" } )
	else
		UpdateSubMat( self:GetOwner(), ent, index-1, "" )
	end
	return true

end


----- Damn Dirty fix... Thx for Wire Advanced tool developer
	
local function get_active_tool(ply, tool)
	-- find toolgun
	local activeWep = ply:GetActiveWeapon()
	if not IsValid(activeWep) or activeWep:GetClass() ~= "gmod_tool" or activeWep.Mode ~= tool then return end

	return activeWep:GetToolObject(tool)
end

if game.SinglePlayer() then -- wtfgarry (these functions don't get called clientside in single player so we need this hack to fix it)
	if SERVER then
		util.AddNetworkString( "submaterial_wtfgarry" )
		local function send( ply, funcname )
			net.Start( "submaterial_wtfgarry" )
				net.WriteString( funcname )
			net.Send( ply )
		end
		
		--function TOOL:LeftClick() send( self:GetOwner(), "LeftClick" ) end
		--function TOOL:RightClick() send( self:GetOwner(), "RightClick" ) end
		function TOOL:Reload() send( self:GetOwner(), "Reload" ) end
	elseif CLIENT then
		net.Receive( "submaterial_wtfgarry", function( len )
			local funcname = net.ReadString()
			local tool = get_active_tool( LocalPlayer(), "submaterial" )
			if not tool then return end
			tool[funcname]( tool, LocalPlayer():GetEyeTrace() )
		end)
	end
end
-----------------------------
if CLIENT then


	TOOL.AimEnt = nil
	TOOL.HudData = {}
	TOOL.SelIndx = 1
	TOOL.ToolMatString = ""

	function TOOL:Reload( trace )
		
		if ( !IsValid( trace.Entity ) ) then return end
	
		--if ( CLIENT ) then return true end
	
			local ent = trace.Entity
			if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
			
			--local index = self:GetClientNumber( "index" , 0)
			local mat=self.HudData.EntCurMatString--""

			if !mat or mat ~= "" then
				RunConsoleCommand("submaterial_override",mat)
			end
			--LocalPlayer():ChatPrint("Material ".. (((self.SelIndx < 1) and "[Global]") or tostring(self.SelIndx)).." copied: "..mat)
			--else LocalPlayer():ChatPrint("Empty material!") end
		--end
		return true
	
	end
	


	function TOOL:Scroll(trace,dir)
		if !IsValid(self.AimEnt) then return end
		local Mats=self.AimEnt:GetMaterials()
		local MatCount=table.Count(Mats)
		self.SelIndx = self.SelIndx + dir
		if(self.SelIndx<0) then self.SelIndx = MatCount end
		if(self.SelIndx>MatCount) then self.SelIndx = 0 end
		RunConsoleCommand("submaterial_index",tostring(self.SelIndx))
		return true
		--self.HudData.EntCurMat=Material(self.AimEnt:GetMaterials()[self.SelIndx])
		
	end
	function TOOL:ScrollUp(trace) return self:Scroll(trace,-1) end
	function TOOL:ScrollDown(trace) return self:Scroll(trace,1) end


	
---- Thx wire_adv dev again...
	local function hookfunc( ply, bind, pressed )
		if not pressed then return end
		if bind == "invnext" then
			local self = get_active_tool(ply, "submaterial")
			if not self then return end
			
			return self:ScrollDown(ply:GetEyeTraceNoCursor())
		elseif bind == "invprev" then
			local self = get_active_tool(ply, "submaterial")
			if not self then return end

			return self:ScrollUp(ply:GetEyeTraceNoCursor())
		end
	end
	
	if game.SinglePlayer() then -- wtfgarry (have to have a delay in single player or the hook won't get added)
		timer.Simple(5,function() hook.Add( "PlayerBindPress", "submat_tool_playerbindpress", hookfunc ) end)
	else
		hook.Add( "PlayerBindPress", "submat_tool_playerbindpress", hookfunc )
	end
--------------------------------------------------


	local function FixVertexLitMaterial(Mat)
		
		--
		-- If it's a vertexlitgeneric material we need to change it to be
		-- UnlitGeneric so it doesn't go dark when we enter a dark room
		-- and flicker all about
		--
		if not Mat then return Mat end
		local strImage = Mat:GetName()
		
		if ( string.find( Mat:GetShader(), "VertexLitGeneric" ) || string.find( Mat:GetShader(), "Cable" ) ) then
		
			local t = Mat:GetString( "$basetexture" )
			
			if ( t ) then
			
				local params = {}
				params[ "$basetexture" ] = t
				params[ "$vertexcolor" ] = 1
				params[ "$vertexalpha" ] = 1
				
				Mat = CreateMaterial( strImage .. "_hud_fx", "UnlitGeneric", params )
			
			end
			
		end
		
		return Mat
		
	end	

	function TOOL:Think( )
		local ent=LocalPlayer():GetEyeTraceNoCursor().Entity
		if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
		if self.AimEnt ~= ent then
			
			self.AimEnt=ent
			if IsValid(self.AimEnt) then
				self.SelIndx=0
				RunConsoleCommand("submaterial_index",tostring(self.SelIndx))
				self.HudData.Mats=self.AimEnt:GetMaterials()

			end
			--print("ThinkUpdate "..tostring(self.AimEnt))
		end

			if IsValid(self.AimEnt) then
				self.HudData.CurMats=table.Copy(self.HudData.Mats)
				self.HudData.OvrMats={}
	
				local MatCount=table.Count(self.HudData.Mats)
				for i=1,MatCount do
					local mat=self.AimEnt:GetSubMaterial(i-1)
					if mat and mat ~= "" then self.HudData.OvrMats[i]=mat end	
				end
				table.Merge(self.HudData.CurMats,self.HudData.OvrMats)
				self.HudData.GlobalMat=self.AimEnt:GetMaterial()
				local EntCurMatString=self.HudData.GlobalMat
				local EntOrigMatString=self.HudData.GlobalMat
				if self.SelIndx > 0 then EntCurMatString=self.HudData.CurMats[self.SelIndx]; EntOrigMatString=self.HudData.Mats[self.SelIndx] end 
				if self.HudData.EntCurMatString~=EntCurMatString then
					self.HudData.EntCurMatString=EntCurMatString
					self.HudData.EntCurMat=FixVertexLitMaterial(Material(EntCurMatString)) 
				end
				if self.HudData.EntOrigMatString~=EntOrigMatString then
					self.HudData.EntOrigMatString=EntOrigMatString
					self.HudData.EntOrigMat=FixVertexLitMaterial(Material(EntOrigMatString)) 
				end
			end
		
		if IsValid(self.AimEnt) and self.ToolMatString~=GetConVarString("submaterial_override") then
			self.ToolMatString=GetConVarString("submaterial_override")
 			self.HudData.ToolMat=FixVertexLitMaterial(Material(self.ToolMatString))
		end
		
	end
	function TOOL:DrawHUD( )
		if IsValid(self.AimEnt) then

			---- List
			local Rg=ScrW()/2-50
			local MaxW = 0
			local TextH = 0
			surface.SetFont("ChatFont")
			local Hdr=tostring(self.AimEnt)..": "..tostring(table.Count(self.HudData.Mats)).." materials"
			MaxW,TextH=surface.GetTextSize(Hdr)
			local HdrH = TextH+5
			for _,s in pairs(self.HudData.CurMats) do
				local ts,_=surface.GetTextSize(s)
				if MaxW<ts then MaxW=ts end
			end
			local LH=4*2+HdrH+TextH*(1+table.Count(self.HudData.Mats))
			local LW=4*2+MaxW
			local LL=Rg-LW
			local LT=ScrH()/2-LH/2
			surface.SetDrawColor(Color(64,64,95,191))
			--surface.SetMaterial(self.HudData.EntCurMat)
			surface.DrawRect(LL, LT, LW, LH)
			surface.SetTextColor(Color(255,255,255,255))
			surface.SetTextPos(LL+4,LT+4)
			surface.DrawText(Hdr)
			surface.SetDrawColor(Color(255,255,255,255))
			surface.DrawLine(LL+3,LT+4+TextH+3,Rg-3,LT+4+TextH+3)

			surface.SetDrawColor(Color(0,127,0,191))
			surface.DrawRect(LL+3, LT+4+HdrH+TextH*self.SelIndx, LW-3-3, TextH)
			
			local s="<none>"
			if not self.HudData.GlobalMat or self.HudData.GlobalMat == "" then 
				surface.SetTextColor(Color(255,255,255,255)) 
			else surface.SetTextColor(Color(0,0,255,255)); s=self.HudData.GlobalMat end
		
			surface.SetTextPos(LL+4,LT+4+HdrH)
			surface.DrawText(s)



			for i,s in pairs(self.HudData.CurMats) do
				if self.HudData.OvrMats[i] then surface.SetTextColor(Color(255,0,0,255)) else surface.SetTextColor(Color(255,255,255,255)) end
				surface.SetTextPos(LL+4,LT+4+HdrH+TextH*i)
				surface.DrawText(s)
			end
			---- Info box
			
			
			--local MaxW = 0
			local StrToolInfo = "Tool material:"
			local StrOrigMatInfo = "Model original material:"
			local StrCurMatInfo = "Model current material:"
			local MaxW,_=surface.GetTextSize(StrToolInfo)
			local ts,_=surface.GetTextSize(StrOrigMatInfo)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(StrCurMatInfo)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.ToolMatString)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.HudData.EntOrigMatString)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.HudData.EntCurMatString)
			if MaxW<ts then MaxW=ts end
		
			local IL=ScrW()/2+50
			local IH=4*4+(64)*3
			local IT=ScrH()/2-IH/2
			surface.SetDrawColor(Color(64,64,95,191))
			surface.DrawRect(IL, IT, 76+MaxW, IH)    -- 4+64+4+MaxW+4

			surface.SetTextColor(Color(255,255,255,255))

			surface.SetDrawColor(Color(255,255,255,255))
			if self.HudData.ToolMat  then
				surface.SetMaterial(self.HudData.ToolMat)
				surface.DrawTexturedRect(IL+4, IT+4, 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8)
			surface.DrawText(StrToolInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+TextH)
			surface.DrawText(self.ToolMatString)
			surface.SetTextPos(IL+4+64+4,IT+8+TextH*2)
			surface.DrawText(self.SelIndx==0 and "[Global]" or "Index: "..self.SelIndx-1)
	
						

			if self.HudData.EntOrigMat  then
				surface.SetMaterial(self.HudData.EntOrigMat)	
				surface.DrawTexturedRect(IL+4, IT+4+(64+4), 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8+64+4)
			surface.DrawText(StrOrigMatInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+64+4+TextH)
			surface.DrawText(self.HudData.EntOrigMatString)

			if self.HudData.EntCurMat  then
				surface.SetMaterial(self.HudData.EntCurMat)
				surface.DrawTexturedRect(IL+4, IT+4+(64+4)*2, 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8+(64+4)*2)
			surface.DrawText(StrCurMatInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+(64+4)*2+TextH)
			surface.DrawText(self.HudData.EntCurMatString)


--			surface.SetMaterial(nil)
			

			--draw.RoundedBox( 2, ScrW()/2-50, ScrH()/2-50, 100, 100, Color(255,255,255,255) ) 
			
		--	print("DrawHUD "..tostring(self.AimEnt))
		end
	end


end

function TOOL.BuildCPanel( CPanel )

	--CPanel:AddControl( "Slider", { Label = "Index", Command = "submaterial_index", Type = "Integer", Min = 0, Max = 15} )
	CPanel:AddControl( "Header", { Description = "#tool.submaterial.help" } )

	CPanel:AddControl( "TextBox", { Label = "Mat:", Command = "submaterial_override", MaxLength = "48"} )
	CPanel:MatSelect( "submaterial_override", list.Get( "OverrideMaterials" ), true, 64, 64 )

end

--lua/weapons/gmod_tool/stools/vfire.lua:

TOOL.Category = "VFire"
TOOL.Name = "VFire Spawner"

-- CreateVFire(parent, pos, normal, newFeed, spreader)
-- CreateVFireBall(life, feedCarry, pos, vel, owner)

TOOL.ClientConVar["numfires"] = 2
TOOL.ClientConVar["life"] = 15
TOOL.ClientConVar["feed"] = 30

TOOL.Information = {
	{name = "left"},
	{name = "right"}
}

function TOOL:LeftClick(tr)
	if (!tr.HitPos || (IsValid(tr.Entity) && tr.Entity:IsPlayer())) then return false end
	if (CLIENT) then return true end

	local ply = self:GetOwner()

	-- Get client's CVars
	local numf = self:GetClientNumber("numfires", 2)
	local life = self:GetClientNumber("life", 15)
	local feed = self:GetClientNumber("feed", 30)

	for i=1,numf do CreateVFireBall(life, feed, tr.HitPos, (VectorRand()*i) + Vector(0,0,i),ply) end

	return true
end
function TOOL:RightClick(tr)
	if (!tr.HitPos || (IsValid(tr.Entity) && tr.Entity:IsPlayer())) then return false end
	if (CLIENT) then return true end

	for k,prop in pairs(ents.FindInSphere(tr.HitPos, 96)) do
		-- if vFireIsVFireEnt(prop) then
			if prop:GetClass() == "vfire" then
				prop:Remove()
			end
		-- end
	end
	return true
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {Description = "Spawns VFire."})

	CPanel:AddControl("Slider", {Label = "#vfire.numf", Command = "vfire_numfires", Type = "Integer", Min = 1, Max = 100, Help = true})
	CPanel:AddControl("Slider", {Label = "#vfire.life", Command = "vfire_life", Type = "Integer", Min = 1, Max = 500, Help = true})
	CPanel:AddControl("Slider", {Label = "#vfire.feed", Command = "vfire_feed", Type = "Integer", Min = 1, Max = 500, Help = true})
end

if CLIENT then
	language.Add("tool.vfire.name", "VFire Spawner")
	language.Add("tool.vfire.desc", "A tool that spawns VFire")
	language.Add("tool.vfire.left", "Spawns VFire")
	language.Add("tool.vfire.right", "Extinguishes VFire")
	
	language.Add("vfire.numf", "Number of fireballs")
	language.Add("vfire.numf.help", "How many fireballs to spawn in that make up the VFire.")
	language.Add("vfire.life", "Life")
	language.Add("vfire.life.help", "How long the fire lasts.")
	language.Add("vfire.feed", "Grow rate")
	language.Add("vfire.feed.help", "How quickly the fire grows.")
end
--addons/mortar/lua/weapons/mortar_range_finder/shared.lua:
AddCSLuaFile()

SWEP.PrintName 			= "Mortar: Rangefinder"
SWEP.Base 				= "tfa_gun_base"
SWEP.Purpose			= "Platziert einen Mörser, der mithilfe eines Rangefinders Ziele aus großer Distanz vernichten kann."
SWEP.Instructions 		= "Platziert einen Mörser, der mithilfe eines Rangefinders Ziele aus großer Distanz vernichten kann."
SWEP.Type				= "Rangefinder"

SWEP.Author 			= "DolUnity"
SWEP.Purpose 			= "Berechnet den Standort der Feinde"
SWEP.Category 			= "SW:RP (Sonstiges)"
SWEP.Spawnable 			= true
SWEP.ViewModel 			= "models/weapons/c_pistol.mdl"
SWEP.WorldModel 		= "models/niksacokica/tech/tech_binoculars.mdl"
SWEP.ShowViewModel 			= false
SWEP.ShowWorldModel 	= false
SWEP.HoldType 			= "camera"
SWEP.UseHands 			= true
SWEP.DrawAmmo 			= false

SWEP.Slot 				= 4

SWEP.Primary.ClipSize 	= 0
SWEP.Primary.DefaultClipSize = 0

SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClipSize = 0


SWEP.WElements = {
    ["element_name"] = {
        type = "Model",
        model = "models/niksacokica/tech/tech_binoculars.mdl",
        bone = "ValveBiped.Bip01_R_Hand",
        rel = "",
        pos = Vector(8, 5, -4),
        angle = Angle(0, 0, 10),
        size = Vector(0.8, 1.21, 0.8),
        color = Color(255, 255, 255, 255),
        surpresslightning = false,
        material = "",
        skin = 0,
        bodygroup = {}
    }
}

if (CLIENT) then
    SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
    SWEP.PreviewModel:SetNoDraw(true)
    SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:PrimaryAttack() end

function SWEP:SecondaryAttack()
    if (not IsFirstTimePredicted()) then return end

    if (self.Zoom) then
        self:GetOwner():SetFOV(self.OldFOV, 0.5)
        self.Zoom = false
    else
        self.Zoom = true
        self.OldFOV = self:GetOwner():GetFOV()
        self:GetOwner():SetFOV(20, 0.5)
    end
end


local laserPointer = Material("Sprites/light_glow02_add_noz")
hook.Add("PostDrawTranslucentRenderables", "swmRangeFinderLaser", function()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        render.SetMaterial(laserPointer)
        render.DrawQuadEasy(trace.HitPos + trace.HitNormal, trace.HitNormal, 32, 32, Color(255,0,0),0)
    end
end)

local rangeTable = Material("models/dolunity/starwars/mortar_scale.png")
hook.Add("HUDPaint", "swmRangeFinderDistanceHUD", function ()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        local dist = LocalPlayer():GetPos():Distance(trace.HitPos)

        surface.SetFont("swmFont")
        surface.SetTextColor(75, 255, 255)
        local mText = math.Round(dist / 40, 1) .. "m"
        local mWidth, mHeight = surface.GetTextSize(mText)
        surface.SetTextPos((ScrW() - mWidth) / 2, ScrH() / 2 + ScrH() * 0.03)
        surface.DrawText(mText)

        local rText = math.Round(math.abs((LocalPlayer():GetAngles().y + 360) % 360 - 360),2)
        local rWidth, rHeight = surface.GetTextSize(rText)
        surface.SetTextPos((ScrW() - rWidth) / 2, ScrH() / 2 + ScrH() * 0.03 + rHeight * 1.1)
        surface.DrawText(rText .. "°")

        surface.SetDrawColor(255,255,255)
        surface.SetMaterial(rangeTable)
        local height = ScrH() * 0.462
        local width = height * 0.6
        surface.DrawTexturedRect(ScrW() * 0.02, (ScrH() - height) / 2, width, height)
    end
end)
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_dioxis.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Releasing dioxis"
SWEP.PrintName					= "Dioxis Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 7
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_poison")
SWEP.Primary.Range 					= 900
SWEP.Velocity = 900
SWEP.Velocity_Underhand = 350
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_dioxis.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.9, 0.2, 1.3), angle = Angle(-10, 90, -25), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_dioxis.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03.2, 02, -0.5), angle = Angle(195, 0, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_stun.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Explode and stun"
SWEP.PrintName					= "Stun Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 10
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_stun")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_shock.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.2, -0.1, 01.5), angle = Angle(-05, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_shock.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03.2, 02, -0.5), angle = Angle(10, -70, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/tfa_base/lua/weapons/tfa_gun_base/common/autodetection.lua:
function SWEP:RunAutoDetection()
	local self2 = self:GetTable()

	self2.PatchAmmoTypeAccessors(self)

	self2.FixRPM(self)
	self2.FixIdles(self)
	self2.FixIS(self)
	self2.FixCone(self)
	self2.FixProjectile(self)
	self2.FixAkimbo(self) -- external: akimbo.lua
	self2.FixSprintAnimBob(self)
	self2.FixWalkAnimBob(self)

	self2.AutoDetectMuzzle(self)
	self2.AutoDetectDamage(self)
	self2.AutoDetectDamageType(self)
	self2.AutoDetectForce(self)
	self2.AutoDetectPenetrationPower(self)
	self2.AutoDetectKnockback(self)
	self2.AutoDetectSpread(self)
	self2.AutoDetectRange(self)
	self2.AutoDetectLowAmmoSound(self)

	self2.CreateFireModes(self)
	self2.IconFix(self)

	self2.RemoveEmptyRTCode(self)
end

function SWEP:FixSprintAnimBob()
	local self2 = self:GetTable()

	if self:GetStatRawL("Sprint_Mode") == TFA.Enum.LOCOMOTION_ANI then
		self:SetStatRawL("SprintBobMult", 0)
	end
end

function SWEP:FixWalkAnimBob()
	local self2 = self:GetTable()
	if self:GetStatRawL("Walk_Mode") == TFA.Enum.LOCOMOTION_ANI then
		self:SetStatRawL("WalkBobMult_Iron", self:GetStatRawL("WalkBobMult"))
		self:SetStatRawL("WalkBobMult", 0)
	end
end

function SWEP:PatchAmmoTypeAccessors()
	local self2 = self:GetTable()
	self:SetStatRawL("GetPrimaryAmmoTypeOld", self:GetStatRawL("GetPrimaryAmmoTypeOld") or self:GetStatRawL("GetPrimaryAmmoType"))
	self:SetStatRawL("GetPrimaryAmmoType", function(myself, ...) return myself.GetPrimaryAmmoTypeC(myself, ...) end)
	self:SetStatRawL("GetSecondaryAmmoTypeOld", self:GetStatRawL("GetSecondaryAmmoTypeOld") or self:GetStatRawL("GetSecondaryAmmoType"))
	self:SetStatRawL("GetSecondaryAmmoType", function(myself, ...) return myself.GetSecondaryAmmoTypeC(myself, ...) end)
end

function SWEP:FixProjectile()
	local self2 = self:GetTable()
	if self:GetStatRawL("ProjectileEntity") and self:GetStatRawL("ProjectileEntity") ~= "" then
		self:SetStatRawL("Primary.Projectile", self:GetStatRawL("ProjectileEntity"))
		self:SetStatRawL("ProjectileEntity", nil)
	end

	if self:GetStatRawL("ProjectileModel") and self:GetStatRawL("ProjectileModel") ~= "" then
		self:SetStatRawL("Primary.ProjectileModel", self:GetStatRawL("ProjectileModel"))
		self:SetStatRawL("ProjectileModel", nil)
	end

	if self:GetStatRawL("ProjectileVelocity") and self:GetStatRawL("ProjectileVelocity") ~= "" then
		self:SetStatRawL("Primary.ProjectileVelocity", self:GetStatRawL("ProjectileVelocity"))
		self:SetStatRawL("ProjectileVelocity", nil)
	end
end

local sv_tfa_range_modifier = GetConVar("sv_tfa_range_modifier")

function SWEP:AutoDetectRange()
	local self2 = self:GetTable()

	if self:GetStatL("Primary.FalloffMetricBased") and not self:GetStatRawL("Primary.RangeFalloffLUT") then
		self:SetStatRawL("Primary.RangeFalloffLUT_IsConverted", true)

		self:SetStatRawL("Primary.RangeFalloffLUT", {
			bezier = false,
			range_func = "linear", -- function to spline range
			units = "meters",
			lut = {
				{range = self:GetStatL("Primary.MinRangeStartFalloff"), damage = 1},
				{range = self:GetStatL("Primary.MinRangeStartFalloff") + self:GetStatL("Primary.MaxFalloff") / self:GetStatL("Primary.FalloffByMeter"),
					damage = (self:GetStatL("Primary.Damage") - self:GetStatL("Primary.MaxFalloff")) / self:GetStatL("Primary.Damage")},
			}
		})

		return
	end

	if self:GetStatL("Primary.FalloffMetricBased") or self:GetStatL("Primary.RangeFalloffLUT") then return end

	if self:GetStatL("Primary.Range") <= 0 then
		self:SetStatRawL("Primary.Range", math.sqrt(self:GetStatL("Primary.Damage") / 32) * self:MetersToUnits(350) * self:AmmoRangeMultiplier())
	end

	if self:GetStatL("Primary.RangeFalloff") <= 0 then
		self:SetStatRawL("Primary.RangeFalloff", 0.5)
	end

	self:SetStatRawL("Primary.RangeFalloffLUT_IsConverted", true)

	self:SetStatRawL("Primary.RangeFalloffLUT", {
		bezier = false,
		range_func = "linear", -- function to spline range
		units = "hammer",
		lut = {
			{range = self:GetStatL("Primary.Range") * self:GetStatL("Primary.RangeFalloff"), damage = 1},
			{range = self:GetStatL("Primary.Range"), damage = 1 - sv_tfa_range_modifier:GetFloat()},
		}
	})
end

function SWEP:FixProceduralReload()
	-- do nothing
end

function SWEP:FixRPM()
	local self2 = self:GetTable()
	if not self:GetStatRawL("Primary.RPM") then
		if self:GetStatRawL("Primary.Delay") then
			self:SetStatRawL("Primary.RPM", 60 / self:GetStatRawL("Primary.Delay"))
		else
			self:SetStatRawL("Primary.RPM", 120)
		end
	end
end

function SWEP:FixCone()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Cone") then
		if (not self:GetStatRawL("Primary.Spread")) or self:GetStatRawL("Primary.Spread") < 0 then
			self:SetStatRawL("Primary.Spread", self:GetStatRawL("Primary.Cone"))
		end

		self:SetStatRawL("Primary.Cone", nil)
	end
end

--legacy compatibility
function SWEP:FixIdles()
	local self2 = self:GetTable()
	if self:GetStatRawL("DisableIdleAnimations") ~= nil and self:GetStatRawL("DisableIdleAnimations") == true then
		self:SetStatRawL("Idle_Mode", TFA.Enum.IDLE_LUA)
	end
end

function SWEP:FixIS()
	local self2 = self:GetTable()
	if self:GetStatRawL("SightsPos") and (not self:GetStatRawL("IronSightsPosition") or (self:GetStatRawL("IronSightsPosition").x ~= self:GetStatRawL("SightsPos").x and self:GetStatRawL("SightsPos").x ~= 0)) then
		self:SetStatRawL("IronSightsPosition", self:GetStatRawL("SightsPos") or Vector())
		self:SetStatRawL("IronSightsAngle", self:GetStatRawL("SightsAng") or Vector())
	end
end

local legacy_spread_cv = GetConVar("sv_tfa_spread_legacy")

function SWEP:AutoDetectSpread()
	local self2 = self:GetTable()
	if legacy_spread_cv and legacy_spread_cv:GetBool() then
		self:SetUpSpreadLegacy()

		return
	end

	if self:GetStatRawL("Primary.SpreadMultiplierMax") == -1 or not self:GetStatRawL("Primary.SpreadMultiplierMax") then
		self:SetStatRawL("Primary.SpreadMultiplierMax", math.Clamp(math.sqrt(math.sqrt(self:GetStatRawL("Primary.Damage") / 35) * 10 / 5) * 5, 0.01 / self:GetStatRawL("Primary.Spread"), 0.1 / self:GetStatRawL("Primary.Spread")))
	end

	if self:GetStatRawL("Primary.SpreadIncrement") == -1 or not self:GetStatRawL("Primary.SpreadIncrement") then
		self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadMultiplierMax") * 60 / self:GetStatRawL("Primary.RPM") * 0.85 * 1.5)
	end

	if self:GetStatRawL("Primary.SpreadRecovery") == -1 or not self:GetStatRawL("Primary.SpreadRecovery") then
		self:SetStatRawL("Primary.SpreadRecovery", math.max(self:GetStatRawL("Primary.SpreadMultiplierMax") * math.pow(self:GetStatRawL("Primary.RPM") / 600, 1 / 3) * 0.75, self:GetStatRawL("Primary.SpreadMultiplierMax") / 1.5))
	end
end

--[[
Function Name:  AutoDetectMuzzle
Syntax: self:AutoDetectMuzzle().  Call only once, or it's redundant.
Returns:  Nothing.
Notes:  Detects the proper muzzle flash effect if you haven't specified one.
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectMuzzle()
	local self2 = self:GetTable()
	if not self:GetStatRawL("MuzzleFlashEffect") then
		local a = string.lower(self:GetStatRawL("Primary.Ammo"))
		local cat = string.lower(self:GetStatRawL("Category") and self:GetStatRawL("Category") or "")

		if self:GetStatRawL("Silenced") or self:GetSilenced() then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_silenced")
		elseif string.find(a, "357") or self:GetStatRawL("Revolver") or string.find(cat, "revolver") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_revolver")
		elseif self:GetStatL("LoopedReload") or a == "buckshot" or a == "slam" or a == "airboatgun" or string.find(cat, "shotgun") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_shotgun")
		elseif string.find(a, "smg") or string.find(cat, "smg") or string.find(cat, "submachine") or string.find(cat, "sub-machine") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_smg")
		elseif string.find(a, "sniper") or string.find(cat, "sniper") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_sniper")
		elseif string.find(a, "pistol") or string.find(cat, "pistol") then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_pistol")
		elseif string.find(a, "ar2") or string.find(a, "rifle") or (string.find(cat, "revolver") and not string.find(cat, "rifle")) then
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_rifle")
		else
			self:SetStatRawL("MuzzleFlashEffect", "tfa_muzzleflash_generic")
		end
	end
end

--[[
Function Name:  AutoDetectDamage
Syntax: self:AutoDetectDamage().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Fixes the damage for GDCW.
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectDamage()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Damage") and self:GetStatRawL("Primary.Damage") ~= -1 then return end

	if self:GetStatRawL("Primary.Round") then
		local rnd = string.lower(self:GetStatRawL("Primary.Round"))

		if string.find(rnd, ".50bmg") then
			self:SetStatRawL("Primary.Damage", 185)
		elseif string.find(rnd, "5.45x39") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "5.56x45") then
			self:SetStatRawL("Primary.Damage", 30)
		elseif string.find(rnd, "338_lapua") then
			self:SetStatRawL("Primary.Damage", 120)
		elseif string.find(rnd, "338") then
			self:SetStatRawL("Primary.Damage", 100)
		elseif string.find(rnd, "7.62x51") then
			self:SetStatRawL("Primary.Damage", 100)
		elseif string.find(rnd, "9x39") then
			self:SetStatRawL("Primary.Damage", 32)
		elseif string.find(rnd, "9mm") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "9x19") then
			self:SetStatRawL("Primary.Damage", 22)
		elseif string.find(rnd, "9x18") then
			self:SetStatRawL("Primary.Damage", 20)
		end

		if string.find(rnd, "ap") then
			self:SetStatRawL("Primary.Damage", self:GetStatRawL("Primary.Damage") * 1.2)
		end
	end

	if (not self:GetStatRawL("Primary.Damage")) or (self:GetStatRawL("Primary.Damage") <= 0.01) and self:GetStatRawL("Velocity") then
		self:SetStatRawL("Primary.Damage", self:GetStatRawL("Velocity") / 5)
	end

	if (not self:GetStatRawL("Primary.Damage")) or (self:GetStatRawL("Primary.Damage") <= 0.01) then
		self:SetStatRawL("Primary.Damage", (self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickUp")) * 10)
	end
end

--[[
Function Name:  AutoDetectDamageType
Syntax: self:AutoDetectDamageType().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Sets a damagetype
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectDamageType()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.DamageType") == -1 or not self:GetStatRawL("Primary.DamageType") then
		if self:GetStatRawL("DamageType") and not self:GetStatRawL("Primary.DamageType") then
			self:SetStatRawL("Primary.DamageType", self:GetStatRawL("DamageType"))
		else
			self:SetStatRawL("Primary.DamageType", DMG_BULLET)
		end
	end
end

--[[
Function Name:  AutoDetectForce
Syntax: self:AutoDetectForce().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Detects force from damage
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectForce()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Force") == -1 or not self:GetStatRawL("Primary.Force") then
		self:SetStatRawL("Primary.Force", self:GetStatRawL("Force") or (math.sqrt(self:GetStatRawL("Primary.Damage") / 16) * 3 / math.sqrt(self:GetStatRawL("Primary.NumShots"))))
	end
end

function SWEP:AutoDetectPenetrationPower()
	local self2 = self:GetTable()

	if self:GetStatRawL("Primary.PenetrationPower") == -1 or not self:GetStatRawL("Primary.PenetrationPower") then
		local am = string.lower(self:GetStatL("Primary.Ammo"))
		local m = 1

		if (am == "pistol") then
			m = 0.4
		elseif (am == "357") then
			m = 1.75
		elseif (am == "smg1") then
			m = 0.34
		elseif (am == "ar2") then
			m = 1.1
		elseif (am == "buckshot") then
			m = 0.3
		elseif (am == "airboatgun") then
			m = 2.25
		elseif (am == "sniperpenetratedround") then
			m = 3
		end

		self:SetStatRawL("Primary.PenetrationPower", self:GetStatRawL("PenetrationPower") or math.sqrt(self:GetStatRawL("Primary.Force") * 200 * m))
	end
end

--[[
Function Name:  AutoDetectKnockback
Syntax: self:AutoDetectKnockback().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Detects knockback from force
Purpose:  Autodetection
]]
--
function SWEP:AutoDetectKnockback()
	local self2 = self:GetTable()
	if self:GetStatRawL("Primary.Knockback") == -1 or not self:GetStatRawL("Primary.Knockback") then
		self:SetStatRawL("Primary.Knockback", self:GetStatRawL("Knockback") or math.max(math.pow(self:GetStatRawL("Primary.Force") - 3.25, 2), 0) * math.pow(self:GetStatRawL("Primary.NumShots"), 1 / 3))
	end
end

--[[
Function Name:  IconFix
Syntax: self:IconFix().  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  Fixes the icon.  Call this if you give it a texture path, or just nothing.
Purpose:  Autodetection
]]
--
local selicon_final = {}

function SWEP:IconFix()
	local self2 = self:GetTable()

	if not surface then return end

	local class = self2.ClassName

	if selicon_final[class] then
		self:SetStatRawL("WepSelectIcon", selicon_final[class])

		return
	end

	if self2.WepSelectIcon and type(self2.WepSelectIcon) == "string" then
		self:SetStatRawL("WepSelectIcon", surface.GetTextureID(self2.WepSelectIcon))
	else
		if file.Exists("materials/vgui/hud/" .. class .. ".png", "GAME") then
			self:SetStatRawL("WepSelectIcon", Material("vgui/hud/" .. class .. ".png", "smooth noclamp")) -- NOTHING should access this variable directly and our DrawWeaponSelection override supports IMaterial.
		elseif file.Exists("materials/vgui/hud/" .. class .. ".vmt", "GAME") then
			self:SetStatRawL("WepSelectIcon", surface.GetTextureID("vgui/hud/" .. class))
		end
	end

	selicon_final[class] = self2.WepSelectIcon
end

--[[
Function Name:  CorrectScopeFOV
Syntax: self:CorrectScopeFOV( fov ).  Call only once.  Hopefully you call this only once on like SWEP:Initialize() or something.
Returns:  Nothing.
Notes:  If you're using scopezoom instead of FOV, this translates it.
Purpose:  Autodetection
]]
--
function SWEP:CorrectScopeFOV(fov)
	local self2 = self:GetTable()
	fov = fov or self:GetStatRawL("DefaultFOV")

	if not self:GetStatRawL("Secondary.OwnerFOV") or self:GetStatRawL("Secondary.OwnerFOV") <= 0 then
		if self:GetStatRawL("Scoped") and self:GetStatL("Secondary.ScopeZoom", -1) >= 1 then
			self:SetStatRawL("Secondary.OwnerFOV", fov / self:GetStatL("Secondary.ScopeZoom"))
		elseif self:GetStatRawL("Scoped_3D") then
			self:SetStatRawL("Secondary.OwnerFOV", 70)
		else
			self:SetStatRawL("Secondary.OwnerFOV", 32)
		end
	end
end

--[[
Function Name:  CreateFireModes
Syntax: self:CreateFireModes( is first draw).  Call as much as you like.  isfirstdraw controls whether the default fire mode is set.
Returns:  Nothing.
Notes:  Autodetects fire modes depending on what params you set up.
Purpose:  Autodetection
]]
--
SWEP.FireModeCache = {}

function SWEP:CreateFireModes(isfirstdraw)
	local self2 = self:GetTable()
	if not self2.FireModes then
		self:SetStatRawL("FireModes", {})
		local burstcnt = self:FindEvenBurstNumber()

		if self2.SelectiveFire then
			if self2.OnlyBurstFire then
				if burstcnt then
					self2.FireModes[1] = burstcnt .. "Burst"
					self2.FireModes[2] = "Single"
				else
					self2.FireModes[1] = "Single"
				end
			else
				self2.FireModes[1] = "Automatic"

				if self2.DisableBurstFire then
					self2.FireModes[2] = "Single"
				else
					if burstcnt then
						self2.FireModes[2] = burstcnt .. "Burst"
						self2.FireModes[3] = "Single"
					else
						self2.FireModes[2] = "Single"
					end
				end
			end
		else
			if self2.Primary_TFA.Automatic then
				self2.FireModes[1] = "Automatic"

				if self2.OnlyBurstFire and burstcnt then
					self2.FireModes[1] = burstcnt .. "Burst"
				end
			else
				self2.FireModes[1] = "Single"
			end
		end
	end

	if self2.FireModes[#self2.FireModes] ~= "Safe" then
		self2.FireModes[#self2.FireModes + 1] = "Safe"
	end

	if not self2.FireModeCache or #self2.FireModeCache <= 0 then
		for k, v in ipairs(self2.FireModes) do
			self2.FireModeCache[v] = k
		end

		if type(self2.DefaultFireMode) == "number" then
			self:SetFireMode(self2.DefaultFireMode or (self2.Primary_TFA.Automatic and 1 or #self2.FireModes - 1))
		else
			self:SetFireMode(self2.FireModeCache[self2.DefaultFireMode] or (self2.Primary_TFA.Automatic and 1 or #self2.FireModes - 1))
		end
	end
end

--[[
Function Name:  CacheAnimations
Syntax: self:CacheAnimations().  Call as much as you like.
Returns:  Nothing.
Notes:  This is what autodetects animations for the SWEP.SequenceEnabled and SWEP.SequenceLength tables.
Purpose:  Autodetection
]]
--
--SWEP.actlist = {ACT_VM_DRAW, ACT_VM_DRAW_EMPTY, ACT_VM_DRAW_SILENCED, ACT_VM_DRAW_DEPLOYED, ACT_VM_HOLSTER, ACT_VM_HOLSTER_EMPTY, ACT_VM_IDLE, ACT_VM_IDLE_EMPTY, ACT_VM_IDLE_SILENCED, ACT_VM_PRIMARYATTACK, ACT_VM_PRIMARYATTACK_1, ACT_VM_PRIMARYATTACK_EMPTY, ACT_VM_PRIMARYATTACK_SILENCED, ACT_VM_SECONDARYATTACK, ACT_VM_RELOAD, ACT_VM_RELOAD_EMPTY, ACT_VM_RELOAD_SILENCED, ACT_VM_ATTACH_SILENCER, ACT_VM_RELEASE, ACT_VM_DETACH_SILENCER, ACT_VM_FIDGET, ACT_VM_FIDGET_EMPTY, ACT_VM_FIDGET_SILENCED, ACT_SHOTGUN_RELOAD_START, ACT_VM_DRYFIRE, ACT_VM_DRYFIRE_SILENCED }
--If you really want, you can remove things from SWEP.actlist and manually enable animations and set their lengths.
SWEP.SequenceEnabled = {}
SWEP.SequenceLength = {}
SWEP.SequenceLengthOverride = {} --Override this if you want to change the length of a sequence but not the next idle
SWEP.ActCache = {}
local vm, seq

function SWEP:CacheAnimations()
	local self2 = self:GetTable()
	table.Empty(self2.ActCache)

	if self:GetStatRawL("CanBeSilenced") and self2.SequenceEnabled[ACT_VM_IDLE_SILENCED] == nil then
		self2.SequenceEnabled[ACT_VM_IDLE_SILENCED] = true
	end

	if not self2.VMIV(self) then return end
	vm = self2.OwnerViewModel

	if IsValid(vm) then
		self:BuildAnimActivities()

		for _, v in ipairs(table.GetKeys(self2.AnimationActivities)) do
			if isnumber(v) then
				seq = vm:SelectWeightedSequence(v)

				if seq ~= -1 and vm:GetSequenceActivity(seq) == v and not self2.ActCache[seq] then
					self2.SequenceEnabled[v] = true
					self2.SequenceLength[v] = vm:SequenceDuration(seq)
					self2.ActCache[seq] = v
				else
					self2.SequenceEnabled[v] = false
					self2.SequenceLength[v] = 0.0
				end
			else
				local s = vm:LookupSequence(v)

				if s and s > 0 then
					self2.SequenceEnabled[v] = true
					self2.SequenceLength[v] = vm:SequenceDuration(s)
					self2.ActCache[s] = v
				else
					self2.SequenceEnabled[v] = false
					self2.SequenceLength[v] = 0.0
				end
			end
		end
	else
		return false
	end

	if self:GetStatRawL("ProceduralHolsterEnabled") == nil then
		if self2.SequenceEnabled[ACT_VM_HOLSTER] then
			self:SetStatRawL("ProceduralHolsterEnabled", false)
		else
			self:SetStatRawL("ProceduralHolsterEnabled", true)
		end
	end

	self:SetStatRawL("HasDetectedValidAnimations", true)

	return true
end

function SWEP:GetType()
	if self:GetStatRawL("Type") then return self:GetStatRawL("Type") end
	local at = string.lower(self:GetStatRawL("Primary.Ammo") or "")
	local ht = string.lower((self:GetStatRawL("DefaultHoldType") or self:GetStatRawL("HoldType")) or "")
	local rpm = self:GetStatRawL("Primary.RPM_Displayed") or self:GetStatRawL("Primary.RPM") or 600

	if self:GetStatRawL("Primary.Projectile") or self:GetStatRawL("ProjectileEntity") then
		if (self:GetStatRawL("Primary.ProjectileVelocity") or self:GetStatRawL("ProjectileVelocity")) > 400 then
			self:SetStatRawL("Type", "Launcher")
		else
			self:SetStatRawL("Type", "Grenade")
		end

		return self:GetType()
	end

	if at == "buckshot" then
		self:SetStatRawL("Type", "Shotgun")

		return self:GetType()
	end

	if self:GetStatRawL("Pistol") or (at == "pistol" and (ht == "pistol" or ht == "revolver")) then
		self:SetStatRawL("Type", "Pistol")

		return self:GetType()
	end

	if self:GetStatRawL("SMG") or (at == "smg1" and (ht == "smg" or ht == "pistol" or ht == "357")) then
		self:SetStatRawL("Type", "Sub-Machine Gun")

		return self:GetType()
	end

	if self:GetStatRawL("Revolver") or (at == "357" and ht == "revolver") then
		self:SetStatRawL("Type", "Revolver")

		return self:GetType()
	end

	--Detect Sniper Type
	if ( (self:GetStatRawL("Scoped") or self:GetStatRawL("Scoped_3D")) and rpm < 600 ) or at == "sniperpenetratedround" then
		if rpm > 180 and (self:GetStatRawL("Primary.Automatic") or self:GetStatRawL("Primary.SelectiveFire")) then
			self:SetStatRawL("Type", "Designated Marksman Rifle")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Sniper Rifle")

			return self:GetType()
		end
	end

	--Detect based on holdtype
	if ht == "pistol" then
		if self:GetStatRawL("Primary.Automatic") then
			self:SetStatRawL("Type", "Machine Pistol")
		else
			self:SetStatRawL("Type", "Pistol")
		end

		return self:GetType()
	end

	if ht == "duel" then
		if at == "pistol" then
			self:SetStatRawL("Type", "Dual Pistols")

			return self:GetType()
		elseif at == "357" then
			self:SetStatRawL("Type", "Dual Revolvers")

			return self:GetType()
		elseif at == "smg1" then
			self:SetStatRawL("Type", "Dual Sub-Machine Guns")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Dual Guns")

			return self:GetType()
		end
	end

	--If it's using rifle ammo, it's a rifle or a carbine
	if at == "ar2" then
		if self:GetStatRawL("Primary.ClipSize") >= 60 then
			self:SetStatRawL("Type", "Light Machine Gun")

			return self:GetType()
		elseif ht == "rpg" or ht == "revolver" then
			self:SetStatRawL("Type", "Carbine")

			return self:GetType()
		else
			self:SetStatRawL("Type", "Rifle")

			return self:GetType()
		end
	end

	--Check SMG one last time
	if ht == "smg" or at == "smg1" then
		self:SetStatRawL("Type", "Sub-Machine Gun")

		return self:GetType()
	end

	if self:GetStatRawL("IsMelee") then
		self:SetStatRawL("Type", "Melee")

		return self:GetType()
	end

	if self:GetStatRawL("IsBow") then
		self:SetStatRawL("Type", "Bow")

		return self:GetType()
	end

	--Fallback to generic
	self:SetStatRawL("Type", "Weapon")

	return self:GetType()
end

function SWEP:SetUpSpreadLegacy()
	local ht = self:GetStatRawL("DefaultHoldType") and self:GetStatRawL("DefaultHoldType") or self:GetStatRawL("HoldType")

	if not self:GetStatRawL("Primary.SpreadMultiplierMax") or self:GetStatRawL("Primary.SpreadMultiplierMax") <= 0 or self:GetStatRawL("AutoDetectSpreadMultiplierMax") then
		self:SetStatRawL("Primary.SpreadMultiplierMax", 2.5 * math.max(self:GetStatRawL("Primary.RPM"), 400) / 600 * math.sqrt(self:GetStatRawL("Primary.Damage") / 30 * self:GetStatRawL("Primary.NumShots"))) --How far the spread can expand when you shoot.

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 0.8)
		end

		if ht == "revolver" then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 2)
		end

		if self:GetStatRawL("Scoped") then
			self:SetStatRawL("Primary.SpreadMultiplierMax", self:GetStatRawL("Primary.SpreadMultiplierMax") * 1.5)
		end

		self:SetStatRawL("AutoDetectSpreadMultiplierMax", true)
	end

	if not self:GetStatRawL("Primary.SpreadIncrement") or self:GetStatRawL("Primary.SpreadIncrement") <= 0 or self:GetStatRawL("AutoDetectSpreadIncrement") then
		self:SetStatRawL("AutoDetectSpreadIncrement", true)
		self:SetStatRawL("Primary.SpreadIncrement", 1 * math.Clamp(math.sqrt(self:GetStatRawL("Primary.RPM")) / 24.5, 0.7, 3) * math.sqrt(self:GetStatRawL("Primary.Damage") / 30 * self:GetStatRawL("Primary.NumShots"))) --What percentage of the modifier is added on, per shot.

		if ht == "revolver" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 2)
		end

		if ht == "pistol" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.35)
		end

		if ht == "ar2" or ht == "rpg" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 0.65)
		end

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.75)
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * (math.Clamp((self:GetStatRawL("Primary.RPM") - 650) / 150, 0, 1) + 1))
		end

		if ht == "pistol" and self:GetStatRawL("Primary.Automatic") == true then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.5)
		end

		if self:GetStatRawL("Scoped") then
			self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * 1.25)
		end

		self:SetStatRawL("Primary.SpreadIncrement", self:GetStatRawL("Primary.SpreadIncrement") * math.sqrt(self:GetStatRawL("Primary.Recoil") * (self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickDown") + self:GetStatRawL("Primary.KickHorizontal"))) * 0.8)
	end

	if not self:GetStatRawL("Primary.SpreadRecovery") or self:GetStatRawL("Primary.SpreadRecovery") <= 0 or self:GetStatRawL("AutoDetectSpreadRecovery") then
		self:SetStatRawL("AutoDetectSpreadRecovery", true)
		self:SetStatRawL("Primary.SpreadRecovery", math.sqrt(math.max(self:GetStatRawL("Primary.RPM"), 300)) / 29 * 4) --How much the spread recovers, per second.

		if ht == "smg" then
			self:SetStatRawL("Primary.SpreadRecovery", self:GetStatRawL("Primary.SpreadRecovery") * (1 - math.Clamp((self:GetStatRawL("Primary.RPM") - 600) / 200, 0, 1) * 0.33))
		end
	end
end

SWEP.LowAmmoSoundTypeBlacklist = {
	["launcher"] = true,
	["grenade"] = true,
}

SWEP.LowAmmoSoundByType = {
	["handgun"] = "TFA.LowAmmo.Handgun",
	["pistol"] = "TFA.LowAmmo.Handgun",
	["dualpistols"] = "TFA.LowAmmo.Handgun",
	["machinepistol"] = "TFA.LowAmmo.Handgun",
	["handcannon"] = "TFA.LowAmmo.Revolver",
	["revolver"] = "TFA.LowAmmo.Revolver",
	["dualrevolvers"] = "TFA.LowAmmo.Revolver",
	["shotgun"] = "TFA.LowAmmo.Shotgun",
	["machinegun"] = "TFA.LowAmmo.MachineGun",
	["lightmachinegun"] = "TFA.LowAmmo.MachineGun",
	["heavymachinegun"] = "TFA.LowAmmo.MachineGun",
	["carbine"] = "TFA.LowAmmo.AssaultRifle",
	["rifle"] = "TFA.LowAmmo.AssaultRifle",
	["assaultrifle"] = "TFA.LowAmmo.AssaultRifle",
	["dmr"] = "TFA.LowAmmo.DMR",
	["designatedmarksmanrifle"] = "TFA.LowAmmo.DMR",
	["sniperrifle"] = "TFA.LowAmmo.Sniper",
	["smg"] = "TFA.LowAmmo.SMG",
	["submachinegun"] = "TFA.LowAmmo.SMG",
}
SWEP.LastAmmoSoundByType = {
	["handgun"] = "TFA.LowAmmo.Handgun_Dry",
	["pistol"] = "TFA.LowAmmo.Handgun_Dry",
	["dualpistols"] = "TFA.LowAmmo.Handgun_Dry",
	["machinepistol"] = "TFA.LowAmmo.Handgun_Dry",
	["handcannon"] = "TFA.LowAmmo.Revolver_Dry",
	["revolver"] = "TFA.LowAmmo.Revolver_Dry",
	["dualrevolvers"] = "TFA.LowAmmo.Revolver_Dry",
	["shotgun"] = "TFA.LowAmmo.Shotgun_Dry",
	["machinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["lightmachinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["heavymachinegun"] = "TFA.LowAmmo.MachineGun_Dry",
	["carbine"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["rifle"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["assaultrifle"] = "TFA.LowAmmo.AssaultRifle_Dry",
	["dmr"] = "TFA.LowAmmo.DMR_Dry",
	["designatedmarksmanrifle"] = "TFA.LowAmmo.DMR_Dry",
	["sniperrifle"] = "TFA.LowAmmo.Sniper_Dry",
	["smg"] = "TFA.LowAmmo.SMG_Dry",
	["submachinegun"] = "TFA.LowAmmo.SMG_Dry",
}

function SWEP:AutoDetectLowAmmoSound()
	if not self.FireSoundAffectedByClipSize then return end

	local t1, t2 = self:GetType():lower():gsub("[^%w]+", ""), (self:GetStatRawL("Type_Displayed") or ""):lower():gsub("[^%w]+", "")

	if self.LowAmmoSoundTypeBlacklist[t2] or self.LowAmmoSoundTypeBlacklist[t1] then return end

	local clip1 = self:GetStatRawL("Primary.ClipSize")
	if (not clip1 or clip1 <= 4) then return end

	if not self.LowAmmoSound then
		local snd = self.LowAmmoSoundByType[t2] or self.LowAmmoSoundByType[t1] or "TFA.LowAmmo"

		if (t2 == "shotgun" or t1 == "shotgun") and not self:GetStatL("LoopedReload") then
			snd = "TFA.LowAmmo.AutoShotgun"
		end

		self:SetStatRawL("LowAmmoSound", snd)
	end

	if not self.LastAmmoSound then
		local snd = self.LastAmmoSoundByType[t2] or self.LastAmmoSoundByType[t1] or "TFA.LowAmmo_Dry"

		if (t2 == "shotgun" or t1 == "shotgun") and not self:GetStatL("LoopedReload") then
			snd = "TFA.LowAmmo.AutoShotgun_Dry"
		end

		self:SetStatRawL("LastAmmoSound", snd)
	end
end

local EmptyFunctions = {
	string.dump(function() end, true),
	string.dump(function(self) end, true),
}
function SWEP:RemoveEmptyRTCode()
	if not self.RTCode or type(self.RTCode) ~= "function" then return end

	local dump = string.dump(self.RTCode, true)
	for _, str in ipairs(EmptyFunctions) do
		if dump == str then
			self.RTCode = nil

			break
		end
	end
end
--addons/tfa_base/lua/weapons/tfa_gun_base/common/nzombies.lua:
SWEP.OldPaP = false
SWEP.OldSpCola = false
SWEP.SpeedColaFactor = 2 --Amount to speed up by when u get dat speed cola
SWEP.SpeedColaActivities = {
	[ACT_VM_DRAW] = true,
	[ACT_VM_DRAW_EMPTY] = true,
	[ACT_VM_DRAW_SILENCED] = true,
	[ACT_VM_DRAW_DEPLOYED or 0] = true,
	[ACT_VM_RELOAD] = true,
	[ACT_VM_RELOAD_EMPTY] = true,
	[ACT_VM_RELOAD_SILENCED] = true,
	[ACT_VM_HOLSTER] = true,
	[ACT_VM_HOLSTER_EMPTY] = true,
	[ACT_VM_HOLSTER_SILENCED] = true,
	[ACT_SHOTGUN_RELOAD_START] = true,
	[ACT_SHOTGUN_RELOAD_FINISH] = true
}
SWEP.DTapActivities = {
	[ACT_VM_PRIMARYATTACK] = true,
	[ACT_VM_PRIMARYATTACK_EMPTY] = true,
	[ACT_VM_PRIMARYATTACK_SILENCED] = true,
	[ACT_VM_PRIMARYATTACK_1] = true,
	[ACT_VM_SECONDARYATTACK] = true,
	[ACT_VM_HITCENTER] = true,
	[ACT_SHOTGUN_PUMP] = true
}
SWEP.DTapSpeed = 1 / 0.8
SWEP.DTap2Speed = 1 / 0.8

local nzombies

local count, upperclamp

function SWEP:NZMaxAmmo()
	if nzombies == nil then
		nzombies = engine.ActiveGamemode() == "nzombies"
	end
	local at = self:GetPrimaryAmmoType()
	local at2 = self.GetSecondaryAmmoType and self:GetSecondaryAmmoType() or self.Secondary_TFA.Ammo

	if IsValid(self:GetOwner()) then
		if self:GetStatL("Primary.ClipSize") <= 0 then
			count = math.Clamp(10, 300 / (self:GetStatL("Primary.Damage") / 30), 10, 300)
			if self.Primary_TFA.NZMaxAmmo and self.Primary_TFA.NZMaxAmmo > 0 then
				count = self.Primary_TFA.NZMaxAmmo
				if self:GetPaP() then
					count = count * 5 / 3
				end
			end
			self:GetOwner():SetAmmo(count, at)
		else
			upperclamp = self:GetPaP() and 600 or 300
			count = math.Clamp(math.abs(self:GetStatL("Primary.ClipSize")) * 10, 10, upperclamp)
			count = count + self:GetStatL("Primary.ClipSize") - self:Clip1()
			if self.Primary_TFA.NZMaxAmmo and self.Primary_TFA.NZMaxAmmo > 0 then
				count = self.Primary_TFA.NZMaxAmmo
				if self:GetPaP() then
					count = count * 5 / 3
				end
			end
			self:GetOwner():SetAmmo(count, at)
		end
		if self:GetStatL("Secondary.ClipSize") > 0 or self:GetSecondaryAmmoType() >= 0 then
			if self:GetStatL("Secondary.ClipSize") <= 0 then
				count = math.ceil( math.Clamp(10, 300 / math.pow( ( self:GetStatL("Secondary.Damage") or 100 ) / 30, 2 ), 10, 300) / 5 ) * 5
				if self.Secondary_TFA.NZMaxAmmo and self.Secondary_TFA.NZMaxAmmo > 0 then
					count = self.Secondary_TFA.NZMaxAmmo
					if self:GetPaP() then
						count = count * 5 / 3
					end
				end
				self:GetOwner():SetAmmo(count, at2)
			else
				upperclamp = self:GetPaP() and 600 or 300
				count = math.Clamp(math.abs(self:GetStatL("Secondary.ClipSize")) * 10, 10, upperclamp)
				count = count + self:GetStatL("Secondary.ClipSize") - self:Clip2()
				if self.Secondary_TFA.NZMaxAmmo and self.Secondary_TFA.NZMaxAmmo > 0 then
					count = self.Secondary_TFA.NZMaxAmmo
					if self:GetPaP() then
						count = count * 5 / 3
					end
				end
				self:GetOwner():SetAmmo(count, at2)
			end
		end
	end
end

function SWEP:GetPaP()
	return ( self.HasNZModifier and self:HasNZModifier("pap") ) or self.pap or false
end

function SWEP:IsPaP()
	return self:GetPaP()
end
--addons/tfa_base/lua/weapons/tfa_gun_base/client/effects.lua:
local vector_up = Vector(0, 0, 1)
local math = math
local render = render
local LerpVector = LerpVector

--[[
Function Name:  ComputeSmokeLighting
Syntax: self:ComputeSmokeLighting(pos, nrm, pcf).
Returns:  Nothing.
Notes:	Used to light the muzzle smoke trail, by setting its PCF Control Point 1
Purpose:  FX
]]--
function SWEP:ComputeSmokeLighting( pos, nrm, pcf )
	if not IsValid(pcf) then return end
	local licht = render.ComputeLighting(pos, nrm)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	pcf:SetControlPoint(1, lichtFinal)
end

--[[
Function Name:  SmokePCFLighting
Syntax: self:SmokePCFLighting().
Returns:  Nothing.
Notes:	Used to loop through all of our SmokePCF tables and call ComputeSmokeLighting on them
Purpose:  FX
]]--
function SWEP:SmokePCFLighting()
	local mzPos = self:GetMuzzlePos()
	if not mzPos or not mzPos.Pos then return end
	local pos = mzPos.Pos
	if self.SmokePCF then
		for _, v in pairs(self.SmokePCF) do
			self:ComputeSmokeLighting(pos, vector_up, v)
		end
	end
	if not self:VMIV() then return end
	local vm = self.OwnerViewModel
	if vm.SmokePCF then
		for _, v in pairs(vm.SmokePCF) do
			self:ComputeSmokeLighting(pos, vector_up, v)
		end
	end
end

--[[
Function Name:  FireAnimationEvent
Syntax: self:FireAnimationEvent( position, angle, event id, options).
Returns:  Nothing.
Notes:	Used to capture and disable viewmodel animation events, unless you disable that feature.
Purpose:  FX
]]--
function SWEP:FireAnimationEvent(pos, ang, event, options)
	if self.CustomMuzzleFlash or not self.MuzzleFlashEnabled then
		-- Disables animation based muzzle event
		if (event == 21) then return true end
		-- Disable thirdperson muzzle flash
		if (event == 5003) then return true end

		-- Disable CS-style muzzle flashes, but chance our muzzle flash attachment if one is given.
		if (event == 5001 or event == 5011 or event == 5021 or event == 5031) then
			if self.AutoDetectMuzzleAttachment then
				self.MuzzleAttachmentRaw = math.Clamp(math.floor((event - 4991) / 10), 1, 4)
				self:ShootEffectsCustom(true)
			end

			return true
		end
	end

	if (self.LuaShellEject and event ~= 5004) then return true end
end

--[[
Function Name:  MakeMuzzleSmoke
Syntax: self:MakeMuzzleSmoke( entity, attachment).
Returns:  Nothing.
Notes:	Deprecated. Used to make the muzzle smoke effect, clientside.
Purpose:  FX
]]--

local limit_particle_cv  = GetConVar("cl_tfa_fx_muzzlesmoke_limited")

function SWEP:MakeMuzzleSmoke(entity, attachment)
	if ( not limit_particle_cv ) or limit_particle_cv:GetBool() then
		self:CleanParticles()
	end
	local ht = self.DefaultHoldType and self.DefaultHoldType or self.HoldType

	if (CLIENT and TFA.GetMZSmokeEnabled() and IsValid(entity) and attachment and attachment ~= 0) then
		ParticleEffectAttach(self.SmokeParticles[ht], PATTACH_POINT_FOLLOW, entity, attachment)
	end
end

--[[
Function Name:  ImpactEffect
Syntax: self:ImpactEffect( position, normal (ang:Up()), materialt ype).
Returns:  Nothing.
Notes:	Used to make the impact effect.  See utilities code for CanDustEffect.
Purpose:  FX
]]--

function SWEP:DoImpactEffect(tr, dmgtype)
	if tr.HitSky then return true end
	local ib = self.BashBase and IsValid(self) and self:GetBashing()
	local dmginfo = DamageInfo()
	dmginfo:SetDamageType(dmgtype)

	if dmginfo:IsDamageType(DMG_SLASH) or (ib and self.Secondary_TFA.BashDamageType == DMG_SLASH and tr.MatType ~= MAT_FLESH and tr.MatType ~= MAT_ALIENFLESH) or (self and self.DamageType and self.DamageType == DMG_SLASH) then
		util.Decal("ManhackCut", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		return true
	end

	if ib and self.Secondary_TFA.BashDamageType == DMG_GENERIC then return true end
	if ib then return end

	if IsValid(self) then
		self:ImpactEffectFunc(tr.HitPos, tr.HitNormal, tr.MatType)
	end

	if self.ImpactDecal and self.ImpactDecal ~= "" then
		util.Decal(self.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		return true
	end
end

local impact_cl_enabled = GetConVar("cl_tfa_fx_impact_enabled")
local impact_sv_enabled = GetConVar("sv_tfa_fx_impact_override")

function SWEP:ImpactEffectFunc(pos, normal, mattype)
	local enabled

	if impact_cl_enabled then
		enabled = impact_cl_enabled:GetBool()
	else
		enabled = true
	end

	if impact_sv_enabled and impact_sv_enabled:GetInt() >= 0 then
		enabled = impact_sv_enabled:GetBool()
	end

	if enabled then
		local fx = EffectData()
		fx:SetOrigin(pos)
		fx:SetNormal(normal)

		if self:CanDustEffect(mattype) then
			TFA.Effects.Create("tfa_dust_impact", fx)
		end

		if self:CanSparkEffect(mattype) then
			TFA.Effects.Create("tfa_metal_impact", fx)
		end

		local scal = math.sqrt(self:GetStatL("Primary.Damage") / 30)
		if mattype == MAT_FLESH then
			scal = scal * 0.25
		end
		fx:SetEntity(self:GetOwner())
		fx:SetMagnitude(mattype or 0)
		fx:SetScale( scal )
		TFA.Effects.Create("tfa_bullet_impact", fx)

		if self.ImpactEffect then
			TFA.Effects.Create(self.ImpactEffect, fx)
		end
	end
end
--addons/egm_tfa_grenades/lua/weapons/tfa_ins2_nade_base/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")
SWEP.Type = "Grenade"
SWEP.MuzzleFlashEffect = ""
SWEP.data = {}
SWEP.data.ironsights = 0
SWEP.Primary.Round = ""
SWEP.UseHands = true

// Velocities
SWEP.Velocity = 1000
SWEP.Velocity_Underhand = 500

// How long the nade should be cooked for before blowing up in hand
SWEP.CookTimer = 5

// Pretty simple
SWEP.UnderhandEnabled = false
SWEP.CookingEnabled = false

//Third person animation and entity throw delay
SWEP.Delay = 0
SWEP.DelayCooked = 0
SWEP.Delay_Underhand = 0

//How long into the animation to delay the start of the cook
SWEP.CookStartDelay = 0

//Angle modifiers for thrown NADE
SWEP.NadeAngleModifier = Angle( 0, 0, 0 )
SWEP.NadeAngleModifierUnderhand = Angle( 0, 0, 0 )

SWEP.IsTFADOINade = true

function SWEP:Initialize()
	self:SetNW2Bool("Cooking", false)
	self:SetNW2Bool("Pulling", false)
	self:SetNW2Bool("Underhand", false)
	self.NextThrowTime = math.huge
	  self.ThrowTime = math.huge
	  self.ThirdPersonThrowAnimTime = math.huge
	  self.ResetTime = math.huge
	  self.ProjectileEntity = self.Primary.Round
	  self.DestructTime = math.huge
	  self.IsTFADOINade = true
	  BaseClass.Initialize(self)
end

function SWEP:Deploy()
	self:SetNW2Bool("Cooking", false)
	self:SetNW2Bool("Pulling", false)
	self:SetNW2Bool("Underhand", false)
	self.NextThrowTime = math.huge
	  self.ThrowTime = math.huge
	  self.ThirdPersonThrowAnimTime = math.huge
	  self.ResetTime = math.huge
	  self.DestructTime = math.huge
	  BaseClass.Deploy(self)
end

function SWEP:ChoosePullAnim()
	if not self:OwnerIsValid() then return end

	local cooking = self:GetNW2Bool( "Cooking", false )

	local tanim = ACT_VM_PULLBACK_HIGH

	if cooking then
		tanim = ACT_VM_PULLBACK_HIGH_BAKE
	end

	self:SendViewModelAnim(tanim)

	return tanim
end

function SWEP:ChooseShootAnim()
	if not self:OwnerIsValid() then return end

	  local cooking = self:GetNW2Bool( "Cooking", false )
	  local underhand = self:GetNW2Bool( "Underhand", false )

	local tanim = ACT_VM_THROW

	  if cooking then
			tanim = ACT_VM_SECONDARYATTACK
			self.ThirdPersonThrowAnimTime = CurTime() + self.DelayCooked
	  elseif underhand then
		tanim = ACT_VM_HAULBACK
		self.ThirdPersonThrowAnimTime = CurTime() + self.Delay
	else
			self.ThirdPersonThrowAnimTime = CurTime() + self.Delay
	  end

	self:SendViewModelAnim(tanim)

	return tanim
end

function SWEP:Throw()

	  local tanim = self:ChooseShootAnim()

	  local cooking = self:GetNW2Bool( "Cooking", false )

	local underhand = self:GetNW2Bool( "Underhand", false )

	  if cooking then
			self.ThrowTime = CurTime() + self.DelayCooked
	  elseif underhand then
		self.ThrowTime = CurTime() + self.Delay_Underhand
	else
			self.ThrowTime = CurTime() + self.Delay
	  end

	  self.ResetTime = CurTime() + self:SequenceDuration( self:SelectWeightedSequence( tanim ) )
	  self.NextThrowTime = math.huge

end

function SWEP:Think2()
	BaseClass.Think2(self)
	  if self.DestructTime <= CurTime() and self:GetNW2Bool( "Cooking", false ) then
			self:SelfDestruct()
			self.ThrowTime = math.huge
	  end
	if self.NextThrowTime <= CurTime() and not self:GetOwner():KeyDown(IN_ATTACK) and not self:GetOwner():KeyDown(IN_ATTACK2) then
		self:Throw()
	end
	  if self.ThrowTime <= CurTime() then
			self:ShootBulletInformation()
			self.ThrowTime = math.huge
	  end
	  if self.ThirdPersonThrowAnimTime <= CurTime() then
			self:GetOwner():SetAnimation(PLAYER_ATTACK1)
			self.ThirdPersonThrowAnimTime = math.huge
	  end

	  if self.ResetTime <= CurTime() and SERVER then
			local ply = self:GetOwner()
			if IsValid(ply) then
				ply:StripWeapon(self:GetClass())
			end
	  end
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if self:Clip1() > 0 and self:OwnerIsValid() and self:CanStartThrow() and self.Owner:KeyDown( IN_USE ) and self.CookingEnabled then
		self:SetNW2Bool( "Pulling", true )
		self:SetNW2Bool( "Cooking", true )
		local tanim = self:ChoosePullAnim()
		self.NextThrowTime = self:SequenceDuration( self:SelectWeightedSequence( tanim ) ) + CurTime()
		self.DestructTime = CurTime() + self.CookTimer + self.CookStartDelay
	elseif self:Clip1() > 0 and self:OwnerIsValid() and self:CanStartThrow() then
		self:SetNW2Bool( "Pulling", true )
		local tanim = self:ChoosePullAnim()
		self.NextThrowTime = self:SequenceDuration( self:SelectWeightedSequence( tanim ) ) + CurTime()
	end
end

function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then return end
	if self:Clip1() > 0 and self:OwnerIsValid() and self:CanStartThrow() and self.UnderhandEnabled then
		self:SetNW2Bool( "Pulling", true )
		self:SetNW2Bool( "Underhand", true )
		local tanim = self:ChoosePullAnim()
		self.NextThrowTime = self:SequenceDuration( self:SelectWeightedSequence( tanim ) ) + CurTime()
	end
end

function SWEP:ChooseIdleAnim( ... )
	if self:GetNW2Bool( "Pulling", false ) then return end
	BaseClass.ChooseIdleAnim( self, ... )
end

function SWEP:CanStartThrow()
	if self:GetNW2Bool( "Pulling", false ) or not self:CanPrimaryAttack() then return false end
	return true
end

function SWEP:SelfDestruct()
	if SERVER then
		local ply = self:GetOwner()
		if not IsValid(ply) then return end

		local ent = ents.Create(self:GetStat("Primary.Projectile"))
		ent:SetPos(ply:GetShootPos())
		ent:SetOwner(ply)
		ent:Spawn()
		ent:Activate()
		ent.Delay = CurTime()
		ent:SetOwner(ply)

		ply:StripWeapon(self:GetClass())
	end
end

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if SERVER then
		local ent = ents.Create(self:GetStat("Primary.Projectile"))
		local dir
		local ang = self:GetOwner():EyeAngles()
		dir = ang:Forward()
		ent:SetPos(self:GetOwner():GetShootPos())
		ent:SetOwner( self:GetOwner() )
		if self:GetNW2Bool( "Underhand", false ) then
			ent:SetAngles( ang + self.NadeAngleModifierUnderhand )
		else
			ent:SetAngles( ang + self.NadeAngleModifier )
		end

		ent:Spawn()
		if self:GetNW2Bool( "Cooking", false ) then
			  ent.Delay = self.DestructTime
		else
			  ent.Delay = CurTime() + self.CookTimer
		end

		local phys = ent:GetPhysicsObject()

		if IsValid(phys) then
			phys:AddAngleVelocity( Vector( 0, 0.66, 0 ) * 1000 )
			if self:GetNW2Bool( "Underhand", false ) then
				phys:SetVelocity( dir * self.Velocity_Underhand )
			else
				phys:SetVelocity( dir * self.Velocity )
			end
		end

		ent:SetOwner(self:GetOwner())
	end

end

--addons/tfa_base/lua/weapons/tfa_knife_base.lua:
if SERVER then
	AddCSLuaFile()
end

DEFINE_BASECLASS("tfa_gun_base")
SWEP.DrawCrosshair = true
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true
SWEP.Primary.RPM = 120 --Primary Slashs per minute
SWEP.Secondary.RPM = 60 --Secondary stabs per minute
SWEP.Primary.Delay = 0.15 --Delay for hull (primary)
SWEP.Secondary.Delay = 0.33 --Delay for hull (secondary)
SWEP.Primary.Length = 32
SWEP.Secondary.Length = 48
SWEP.Primary.Sound = Sound("Weapon_Knife.Slash") --Sounds
SWEP.KnifeShink = "Weapon_Knife.HitWall" --Sounds
SWEP.KnifeSlash = "Weapon_Knife.Hit" --Sounds
SWEP.KnifeStab = "Weapon_Knife.Slash" --Sounds
SWEP.SlashTable = {"midslash1", "midslash2"} --Table of possible hull sequences
SWEP.StabTable = {"stab"} --Table of possible hull sequences
SWEP.StabMissTable = {"stab_miss"} --Table of possible hull sequences
SWEP.DisableIdleAnimations = false --Enable idles
--[[ Don't Edit Below ]]
--
SWEP.DamageType = DMG_SLASH
SWEP.MuzzleFlashEffect = "" --No muzzle
SWEP.DoMuzzleFlash = false --No muzzle
SWEP.WeaponLength = 1 --No nearwall
SWEP.Primary.Ammo = "" -- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
SWEP.Primary.ClipSize = 1 -- Size of a clip
SWEP.Primary.DefaultClip = 1 -- Bullets you start with
SWEP.data = {} --No ironsights
SWEP.Secondary.IronSightsEnabled = false --No ironsights
SWEP.Secondary.DisplaySpread = false
SWEP.IsMelee = true

SWEP.CrosshairConeRecoilOverride = .05

SWEP.HullData = {
	hullMin = Vector(-16, -16, -16),
	hullMax = Vector(16, 16, 16)
}

SWEP.Primary.DisplayFalloff = false

SWEP.SlashCounter = 1
SWEP.StabCounter = 1

function SWEP:Deploy()
	return BaseClass.Deploy(self)
end

local lim_up_vec = Vector(1,1,0.1)

function SWEP:ApplyForce(ent, force, posv, now)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end

	if now then
		if ent.GetRagdollEntity then
			ent = ent:GetRagdollEntity() or ent
		end

		if not IsValid(ent) then return end
		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			if ent:IsPlayer() or ent:IsNPC() then
				ent:SetVelocity( force * 0.1 * lim_up_vec )
				phys:SetVelocity(phys:GetVelocity() + force * 0.1 * lim_up_vec )
			else
				phys:ApplyForceOffset(force, posv)
			end
		end
	else
		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:ApplyForce(ent, force, posv, true)
			end
		end)
	end
end

function SWEP:SlashSound(tr)
	if IsFirstTimePredicted() then
		if tr.Hit then
			if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then
				self:EmitSound(self.KnifeSlash)
			else
				self:EmitSound(self.KnifeShink)
			end
		else
			self:EmitSound(self.Primary_TFA.Sound)
		end
	end
end

local sp = game.SinglePlayer()

function SWEP:GetSlashTrace(tbl, fwd)
	local ow = self:GetOwner()

	if not sp and ow:IsPlayer() then
		ow:LagCompensation(true)
	end

	local traceRes = util.TraceLine(tbl)

	if (not traceRes.Hit) then
		if not self.HullData.Radius then
			self.HullData.Radius = self.HullData.hullMin:Distance(self.HullData.hullMax) / 2
		end

		local hd = self.HullData
		tbl.mins = -hd.hullMin
		tbl.maxs = hd.hullMax
		tbl.endpos = tbl.endpos - fwd * hd.Radius
		traceRes = util.TraceHull(tbl)
	end

	if not sp and ow:IsPlayer() then
		ow:LagCompensation(false)
	end

	return traceRes
end

function SWEP:SmackDamage(tr, fwd, primary)
	if not tr.Entity:IsValid() then return end
	local dmg, force

	if primary then
		dmg = self:GetStatL("Primary.Damage")
	else
		dmg = self:GetStatL("Secondary.Damage")
	end

	force = dmg * 25
	local dmginfo = DamageInfo()
	dmginfo:SetAttacker(self:GetOwner())
	dmginfo:SetInflictor(self)
	dmginfo:SetDamage(dmg)
	dmginfo:SetDamageType(self.DamageType)
	dmginfo:SetDamagePosition(tr.HitPos)
	dmginfo:SetReportedPosition(tr.StartPos)
	dmginfo:SetDamageForce(fwd * force)
	tr.Entity:DispatchTraceAttack(dmginfo, tr, fwd)
	self:ApplyForce( tr.Entity, dmginfo:GetDamageForce(), tr.HitPos )
end

function SWEP:SmackEffect(tr)
	local vSrc = tr.StartPos
	local bFirstTimePredicted = IsFirstTimePredicted()
	local bHitWater = bit.band(util.PointContents(vSrc), MASK_WATER) ~= 0
	local bEndNotWater = bit.band(util.PointContents(tr.HitPos), MASK_WATER) == 0

	local trSplash = bHitWater and bEndNotWater and util.TraceLine({
		start = tr.HitPos,
		endpos = vSrc,
		mask = MASK_WATER
	}) or not (bHitWater or bEndNotWater) and util.TraceLine({
		start = vSrc,
		endpos = tr.HitPos,
		mask = MASK_WATER
	})

	if (trSplash and bFirstTimePredicted) then
		local data = EffectData()
		data:SetOrigin(trSplash.HitPos)
		data:SetScale(1)

		if (bit.band(util.PointContents(trSplash.HitPos), CONTENTS_SLIME) ~= 0) then
			data:SetFlags(1) --FX_WATER_IN_SLIME
		end

		util.Effect("watersplash", data)
	end

	self:DoImpactEffect(tr, self.DamageType)

	if (tr.Hit and bFirstTimePredicted and not trSplash) then
		local data = EffectData()
		data:SetOrigin(tr.HitPos)
		data:SetStart(vSrc)
		data:SetSurfaceProp(tr.SurfaceProps)
		data:SetDamageType(self.DamageType)
		data:SetHitBox(tr.HitBox)
		data:SetEntity(tr.Entity)
		util.Effect("Impact", data)
	end
end

local tracedata = {}

function SWEP:Slash(bPrimary)
	local ow, gsp, ea, fw, tr, rpm, delay

	if bPrimary == nil then
		bPrimary = true
	end

	ow = self:GetOwner()
	gsp = ow:GetShootPos()
	ea = ow:EyeAngles()
	fw = ea:Forward()
	tracedata.start = gsp
	tracedata.endpos = gsp + fw * (bPrimary and self.Primary_TFA.Length or self.Secondary_TFA.Length)
	tracedata.filter = ow

	tr = self:GetSlashTrace(tracedata, fw)
	rpm = self:GetStatL("Primary.RPM")
	delay = self:GetStatL("Primary.Delay")
	self:SlashSound(tr)
	self:SmackDamage(tr, fw, bPrimary)
	self:SmackEffect(tr, fw, bPrimary)
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, 60 / rpm - delay)
end

function SWEP:CanAttack()
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return false end
	if CurTime() < self:GetNextPrimaryFire() then return false end
	return true
end

function SWEP:PrimaryAttack()
	if not self:CanAttack() then return end

	if self:GetNextPrimaryFire() < CurTime() and self:GetOwner():IsPlayer() and not self:GetOwner():KeyDown(IN_RELOAD) then
		self.SlashCounter = self.SlashCounter + 1

		if self.SlashCounter > #self.SlashTable then
			self.SlashCounter = 1
		end

		self:SendViewModelSeq(self.SlashTable[self.SlashCounter])

		self:GetOwner():SetAnimation(PLAYER_ATTACK1)
		self:SetNextPrimaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))
		self:SetNextSecondaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))
		self:ScheduleStatus(TFA.Enum.STATUS_KNIFE_SLASH, self.Primary_TFA.Delay)
	end
end

function SWEP:SecondaryAttack()

	if not self:CanAttack() then return end

	local ow, gsp, ea, fw, tr

	ow = self:GetOwner()
	gsp = ow:GetShootPos()
	ea = ow:EyeAngles()
	fw = ea:Forward()
	tracedata.start = gsp
	tracedata.endpos = gsp + fw * self.Secondary_TFA.Length
	tracedata.filter = ow

	tr = self:GetSlashTrace(tracedata, fw)

	if tr.Hit then
		self.StabIndex = self.StabIndex or 0
		self.StabIndex = self.StabIndex + 1

		if self.StabIndex > #self.StabTable then
			self.StabIndex = 1
		end

		self:SendViewModelSeq(self.StabTable[self.StabIndex])
	else
		self.StabMiss = self.StabMiss or 0
		self.StabMiss = self.StabMiss + 1

		if self.StabMiss > #self.StabMissTable then
			self.StabMiss = 1
		end

		self:SendViewModelSeq(self.StabMissTable[self.StabMiss])
	end

	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetNextPrimaryFire(CurTime() + 60 / self.Secondary_TFA.RPM)
	self:SetNextSecondaryFire(CurTime() + 60 / self.Secondary_TFA.RPM )
	self:ScheduleStatus(TFA.Enum.STATUS_KNIFE_STAB, self.Secondary_TFA.Delay)
end

function SWEP:ThrowKnife()
	if not IsFirstTimePredicted() then return end
	self:EmitSound(self.Primary_TFA.Sound)

	if SERVER then
		local ent = ents.Create("tfa_thrown_blade")

		if ent:IsValid() then
			ent:SetPos(self:GetOwner():GetShootPos())
			ent:SetAngles(self:GetOwner():EyeAngles())
			ent:SetModel(self.Primary_TFA.ProjectileModel or self.WorldModel)
			ent:SetOwner(self:GetOwner())
			ent:SetPhysicsAttacker(self:GetOwner())
			ent:Spawn()
			ent:Activate()
			ent:SetNW2String("ClassName", self:GetClass())
			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then
				phys:SetVelocity(self:GetOwner():GetAimVector() * 1250)
				phys:AddAngleVelocity(Vector(0, 480, 0))
			end

			self:GetOwner():SetAnimation(PLAYER_ATTACK1)
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

function SWEP:Reload()
	if not self:OwnerIsValid() and self:GetOwner():KeyDown(IN_RELOAD) then return end
	self:ThrowKnife()
end

function SWEP:Think2(...)
	if self:GetStatus() == TFA.Enum.STATUS_KNIFE_STAB and CurTime() > self:GetStatusEnd() then
		self:Slash(false)
	elseif self:GetStatus() == TFA.Enum.STATUS_KNIFE_SLASH and CurTime() > self:GetStatusEnd() then
		self:Slash(true)
	end

	BaseClass.Think2(self, ...)
end

SWEP.IsKnife = true
SWEP.WeaponLength = 8

TFA.FillMissingMetaValues(SWEP)

--addons/tfa_base/lua/weapons/tfa_melee_base/shared.lua:
DEFINE_BASECLASS("tfa_bash_base")
SWEP.DrawCrosshair = true
SWEP.SlotPos = 72
SWEP.Slot = 0
SWEP.WeaponLength = 8
SWEP.Secondary.IronSightsEnabled = false
SWEP.Secondary.DisplaySpread = false
SWEP.Primary.Directional = false
SWEP.Primary.Attacks = {}
--[[{
{
["act"] = ACT_VM_HITLEFT, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["len"] = 8 * 4.5, -- Trace distance
["src"] = Vector(20,10,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(-40,30,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(1,-10,0), --viewpunch angle
["end"] = 1, --time before next attack
["hull"] = 10, --Hullsize
["direction"] = "L", --Swing direction
["combotime"] = 0.2 --If you hold attack down, attack this much earlier
},
{
["act"] = ACT_VM_HITRIGHT, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["len"] = 8 * 4.5, -- Trace distance
["src"] = Vector(-10,10,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(40,30,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(1,10,0), --viewpunch angle
["end"] = 1, --time before next attack
["hull"] = 10, --Hullsize
["direction"] = "R", --Swing direction
["combotime"] = 0.2 --If you hold attack down, attack this much earlier
}
}

SWEP.Secondary.Attacks = {
{
["act"] = ACT_VM_MISSCENTER, -- Animation; ACT_VM_THINGY, ideally something unique per-sequence
["src"] = Vector(0,5,0), -- Trace source; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dir"] = Vector(0,50,0), -- Trace direction/length; X ( +right, -left ), Y ( +forward, -back ), Z ( +up, -down )
["dmg"] = 60, --Damage
["dmgtype"] = DMG_SLASH, --DMG_SLASH,DMG_CRUSH, etc.
["delay"] = 0.2, --Delay
["spr"] = true, --Allow attack while sprinting?
["snd"] = "Swing.Sound", -- Sound ID
["viewpunch"] = Angle(5,0,0), --viewpunch angle
["end"] = 1, --time before next attack
["callback"] = function(tbl,wep,tr) end,
["kickback"] = nil--Recoil if u hit something with this activity
}
}
]]
--
SWEP.IsMelee = true
SWEP.Precision = 9 --Traces to use per attack
SWEP.Primary.MaxCombo = 3 --Max amount of times you'll attack by simply holding down the mouse; -1 to unlimit
SWEP.Secondary.MaxCombo = 3 --Max amount of times you'll attack by simply holding down the mouse; -1 to unlimit
SWEP.CanBlock = false

SWEP.BlockAnimation = {
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_DEPLOY, --Number for act, String/Number for sequence
		["transition"] = true
	},
	--Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_IDLE_DEPLOYED, --Number for act, String/Number for sequence
		["is_idle"] = true
	},
	--looping animation
	["hit"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_DEPLOYED, --Number for act, String/Number for sequence
		["is_idle"] = true
	},
	--when you get hit and block it
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_UNDEPLOY, --Number for act, String/Number for sequence
		["transition"] = true
	}
}

--Outward transition
SWEP.BlockDamageTypes = {DMG_SLASH, DMG_CLUB}
SWEP.BlockCone = 135 --Think of the player's view direction as being the middle of a sector, with the sector's angle being this
SWEP.BlockDamageMaximum = 0.1 --Multiply damage by this for a maximumly effective block
SWEP.BlockDamageMinimum = 0.4 --Multiply damage by this for a minimumly effective block
SWEP.BlockTimeWindow = 0.5 --Time to absorb maximum damage
SWEP.BlockTimeFade = 1 --Time for blocking to do minimum damage.  Does not include block window
SWEP.BlockDamageCap = 100
SWEP.BlockSound = ""
SWEP.BlockFadeOut = nil --Override the length of the ["out"] block animation easily
SWEP.BlockFadeOutEnd = 0.2 --In absense of BlockFadeOut, shave this length off of the animation time
SWEP.BlockHoldType = "magic"
SWEP.BlockCanDeflect = true --Can "bounce" bullets off a perfect parry?
SWEP.Secondary.Directional = true
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true
SWEP.ImpactDecal = "ManhackCut"
SWEP.Secondary.CanBash = false
SWEP.Secondary.PrimaryFallback = true
SWEP.DefaultComboTime = 0.2
SWEP.AllowSprintAttack = true
SWEP.Primary.SplitDamage = true
SWEP.Secondary.SplitDamage = true

--[[ START OF BASE CODE ]]
--
SWEP.Primary.ClipSize = -1
SWEP.Primary.Ammo = ""
SWEP.Seed = 0
SWEP.AttackSoundTime = -1
SWEP.VoxSoundTime = -1

SWEP.Primary.DisplayFalloff = false

SWEP.CrosshairConeRecoilOverride = .05

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	self:NetworkVarTFA("Bool", "VP")
	self:NetworkVarTFA("Bool", "BashImpulse")

	self:NetworkVarTFA("Float", "VPTime")
	self:NetworkVarTFA("Float", "VPPitch")
	self:NetworkVarTFA("Float", "VPYaw")
	self:NetworkVarTFA("Float", "VPRoll")

	self:NetworkVarTFA("Int", "ComboCount")
	self:NetworkVarTFA("Int", "MelAttackID")

	self:SetMelAttackID(1)
	self:SetVP(false)
	self:SetVPPitch(0)
	self:SetVPYaw(0)
	self:SetVPRoll(0)
	self:SetVPTime(-1)
	self:SetComboCount(0)
end

function SWEP:Deploy()
	self:SetMelAttackID(1)
	self:SetVP(false)
	self:SetVPPitch(0)
	self:SetVPYaw(0)
	self:SetVPRoll(0)
	self:SetVPTime(-1)
	self.up_hat = false
	self:SetComboCount(0)
	self:AddNZAnimations()

	return BaseClass.Deploy(self)
end

function SWEP:AddNZAnimations()
	if self.Primary.Attacks then
		for _, v in pairs(self.Primary.Attacks) do
			if v.act then
				self.DTapActivities[v.act] = true
			end
		end
	end

	if self.Secondary.Attacks then
		for _, v in pairs(self.Secondary.Attacks) do
			if v.act then
				self.DTapActivities[v.act] = true
			end
		end
	end
end

function SWEP:CanInterruptShooting()
	return false
end

local att = {}
local tr = {}
local traceres = {}
local pos, ang, mdl, ski, prop
local fwd, eang, scl, dirv
local strikedir = Vector()
SWEP.hpf = false
SWEP.hpw = false
local lim_up_vec = Vector(1, 1, 0.05)

function SWEP:ApplyForce(ent, force, posv)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end
	if hook.Run("TFAMeleeApplyForce", ent) ~= false then return end

	if ent.GetRagdollEntity and IsValid(ent:GetRagdollEntity()) and ent ~= ent:GetRagdollEntity() then
		ent = ent:GetRagdollEntity()

		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:ApplyForce(ent, force, posv, false)
			end
		end)

		return
	end

	if not IsValid(ent) then return end

	if ent:IsPlayer() or ent:IsNPC() then
		ent:SetVelocity(force * 0.1 * lim_up_vec)
	end

	if ent:GetPhysicsObjectCount() > 1 then
		for i = 0, ent:GetPhysicsObjectCount() - 1 do
			local phys = ent:GetPhysicsObjectNum(i)

			if IsValid(phys) then
				phys:ApplyForceOffset(force / ent:GetPhysicsObjectCount(), posv)
			end
		end
	else
		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			phys:ApplyForceOffset(force, posv)
		end
	end
end

function SWEP:ApplyDamage(trace, dmginfo, attk)
	local dam, force = dmginfo:GetBaseDamage(), dmginfo:GetDamageForce()
	dmginfo:SetDamagePosition(trace.HitPos)
	dmginfo:SetReportedPosition(trace.StartPos)
	trace.Entity:DispatchTraceAttack(dmginfo, trace, fwd)
	dmginfo:SetDamage(dam)
	dmginfo:SetDamageForce(force)
	-- dmginfo:SetAttacker( self:GetOwner() )
	self:ApplyForce(trace.Entity, dmginfo:GetDamageForce(), trace.HitPos)
	dmginfo:SetDamage(dam)
	dmginfo:SetDamageForce(force)
	-- dmginfo:SetAttacker( self:GetOwner() )
end

function SWEP:SmackEffect(trace, dmg)
	local vSrc = trace.StartPos
	local bFirstTimePredicted = IsFirstTimePredicted()
	local bHitWater = bit.band(util.PointContents(vSrc), MASK_WATER) ~= 0
	local bEndNotWater = bit.band(util.PointContents(trace.HitPos), MASK_WATER) == 0

	local trSplash = bHitWater and bEndNotWater and util.TraceLine({
		start = trace.HitPos,
		endpos = vSrc,
		mask = MASK_WATER
	}) or not (bHitWater or bEndNotWater) and util.TraceLine({
		start = vSrc,
		endpos = trace.HitPos,
		mask = MASK_WATER
	})

	if (trSplash and bFirstTimePredicted) then
		local data = EffectData()
		data:SetOrigin(trSplash.HitPos)
		data:SetScale(1)

		if (bit.band(util.PointContents(trSplash.HitPos), CONTENTS_SLIME) ~= 0) then
			data:SetFlags(1) --FX_WATER_IN_SLIME
		end

		util.Effect("watersplash", data)
	end

	local dam, force, dt = dmg:GetBaseDamage(), dmg:GetDamageForce(), dmg:GetDamageType()

	if (trace.Hit and bFirstTimePredicted and (not trSplash) and self:DoImpactEffect(trace, dt) ~= true) then
		local data = EffectData()
		data:SetOrigin(trace.HitPos)
		data:SetStart(vSrc)
		data:SetSurfaceProp(trace.SurfaceProps)
		data:SetDamageType(dt)
		data:SetHitBox(trace.HitBox)
		data:SetEntity(trace.Entity)
		util.Effect("Impact", data)
	end

	dmg:SetDamage(dam)
	dmg:SetDamageForce(force)
	-- dmg:SetAttacker( self:GetOwner() )
end

local defaultdoorhealth = 250
local cv_doorres = GetConVar("sv_tfa_door_respawn")

function SWEP:MakeDoor(ent, dmginfo)
	pos = ent:GetPos()
	ang = ent:GetAngles()
	mdl = ent:GetModel()
	ski = ent:GetSkin()
	ent:SetNotSolid(true)
	ent:SetNoDraw(true)
	prop = ents.Create("prop_physics")
	prop:SetPos(pos)
	prop:SetAngles(ang)
	prop:SetModel(mdl)
	prop:SetSkin(ski or 0)
	prop:Spawn()
	prop:SetVelocity(dmginfo:GetDamageForce() * 48)
	prop:GetPhysicsObject():ApplyForceOffset(dmginfo:GetDamageForce() * 48, dmginfo:GetDamagePosition())
	if IsValid(dmginfo:GetAttacker()) then
		prop:SetPhysicsAttacker(dmginfo:GetAttacker())
	end
	prop:EmitSound("physics/wood/wood_furniture_break" .. tostring(math.random(1, 2)) .. ".wav", 110, math.random(90, 110))

	if cv_doorres and cv_doorres:GetInt() ~= -1 then
		timer.Create("TFA_DoorRespawner_" .. ent:EntIndex(), cv_doorres:GetFloat(), 1, function()
			if IsValid(prop) then
				prop:Remove()
			end

			if IsValid(ent) then
				ent.TFADoorHealth = defaultdoorhealth
				ent:SetNotSolid(false)
				ent:SetNoDraw(false)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_melee_doordestruction")

function SWEP:BurstDoor(ent, dmginfo)
	if not ents.Create then return end

	if not cv_doordestruction:GetBool() then return end

	if dmginfo:GetDamage() > 60 and (dmginfo:IsDamageType(DMG_CRUSH) or dmginfo:IsDamageType(DMG_CLUB)) and (ent:GetClass() == "func_door_rotating" or ent:GetClass() == "prop_door_rotating") then
		if dmginfo:GetDamage() > 150 then
			local ply = self:GetOwner()
			self:MakeDoor(ent, dmginfo)
			ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))
		else
			local ply = self:GetOwner()
			ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))
			ply.oldname = ply:GetName()
			ply:SetName("bashingpl" .. ply:EntIndex())
			ent:SetKeyValue("Speed", "500")
			ent:SetKeyValue("Open Direction", "Both directions")
			ent:SetKeyValue("opendir", "0")
			ent:Fire("unlock", "", .01)
			ent:Fire("openawayfrom", "bashingpl" .. ply:EntIndex(), .01)

			timer.Simple(0.02, function()
				if IsValid(ply) then
					ply:SetName(ply.oldname)
				end
			end)

			timer.Simple(0.3, function()
				if IsValid(ent) then
					ent:SetKeyValue("Speed", "100")
				end
			end)
		end
	end
end

function SWEP:ThinkNPC()
	local ow = self:GetOwner()
	if ow:IsCurrentSchedule(SCHED_CHASE_ENEMY) then return end
	if ow:IsCurrentSchedule(SCHED_MELEE_ATTACK1) then return end
	if not self.Range then
		local _, t = self:ChoosePrimaryAttack()
		if t and t.range then
			self.Range = t.src:Length() + t.dir:Length()
		else
			self.Range = 80
		end
	end
	local en = ow:GetEnemy()
	if IsValid(en) and en:GetPos():Distance(self:GetPos()) <= self.Range and CurTime() > self:GetNextPrimaryFire() then
		self:PrimaryAttack()
	else
		self:GetOwner():SetSchedule( SCHED_CHASE_ENEMY )
	end
end

function SWEP:Think2(...)
	if not self:VMIV() then return end

	if (not self:GetOwner():KeyDown(IN_ATTACK)) and (not self:GetOwner():KeyDown(IN_ATTACK2)) then
		self:SetComboCount(0)
	end

	if self:GetVP() and CurTime() > self:GetVPTime() then
		self:SetVP(false)
		self:SetVPTime(-1)
		self:GetOwner():ViewPunch(Angle(self:GetVPPitch(), self:GetVPYaw(), self:GetVPRoll()))
	end

	if self.CanBlock then
		local stat = self:GetStatus()

		if self:GetBashImpulse() and TFA.Enum.ReadyStatus[stat] and not self:GetOwner():KeyDown(IN_USE) then
			self:SetStatus(TFA.Enum.STATUS_BLOCKING, math.huge)

			if self.BlockAnimation["in"] then
				self:PlayAnimation(self.BlockAnimation["in"])
			elseif self.BlockAnimation["loop"] then
				self:PlayAnimation(self.BlockAnimation["loop"])
			end

			self.BlockStart = CurTime()
		elseif stat == TFA.Enum.STATUS_BLOCKING and not self:GetBashImpulse() then
			local _, tanim, ttype

			if self.BlockAnimation["out"] then
				_, tanim, ttype = self:PlayAnimation(self.BlockAnimation["out"])
			else
				_, tanim, ttype = self:ChooseIdleAnim()
			end

			self:ScheduleStatus(TFA.Enum.STATUS_BLOCKING_END, self.BlockFadeOut or (self:GetActivityLength(tanim, false, ttype) - self.BlockFadeOutEnd))
		elseif stat == TFA.Enum.STATUS_BLOCKING and CurTime() > self:GetNextIdleAnim() then
			self:ChooseIdleAnim()
		end
	end

	self:StrikeThink()
	BaseClass.Think2(self, ...)
end

function SWEP:ProcessHoldType(...)
	if self:GetStatus() == TFA.Enum.STATUS_BLOCKING then
		self:SetHoldType(self.BlockHoldType or "magic")

		return self.BlockHoldType or "magic"
	else
		return BaseClass.ProcessHoldType(self, ...)
	end
end

function SWEP:GetBlockStart()
	return self.BlockStart or -1
end

function SWEP:ChooseBlockAnimation()
	if self.BlockAnimation["hit"] then
		self:PlayAnimation(self.BlockAnimation["hit"])
	elseif self.BlockAnimation["in"] then
		self:PlayAnimation(self.BlockAnimation["in"])
	end
end

function SWEP:ChooseIdleAnim(...)
	if self.CanBlock and self:GetStatus() == TFA.Enum.STATUS_BLOCKING and self.BlockAnimation["loop"] then
		return self:PlayAnimation(self.BlockAnimation["loop"])
	else
		return BaseClass.ChooseIdleAnim(self, ...)
	end
end

function SWEP:StrikeThink()
	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then
		self:SetComboCount(0)
		--return
	end

	if self:IsSafety() then
		self:SetComboCount(0)

		return
	end

	if not IsFirstTimePredicted() then return end
	if self:GetStatus() ~= TFA.Enum.STATUS_SHOOTING then return end
	if self.up_hat then return end

	local ind = self:GetMelAttackID() or 1
	local srctbl = ind >= 0 and "Primary" or "Secondary"
	local attackstbl = self:GetStatL(srctbl .. ".Attacks")
	local attack = attackstbl[math.abs(ind)]

	if self.AttackSoundTime ~= -1 and CurTime() > self.AttackSoundTime then
		self:EmitSound(attack.snd)

		if self:GetOwner().Vox then
			self:GetOwner():Vox("bash", 4)
		end

		self.AttackSoundTime = -1
	end

	if self:GetOwner().Vox and self.VoxSoundTime ~= -1 and CurTime() > self.VoxSoundTime - self:GetOwner():Ping() * 0.001 then
		if self:GetOwner().Vox then
			self:GetOwner():Vox("bash", 4)
		end

		self.VoxSoundTime = -1
	end

	if CurTime() > self:GetStatusEnd() then
		self.DamageType = attack.dmgtype
		--Just attacked, so don't do it again
		self.up_hat = true
		self:SetStatus(TFA.Enum.STATUS_IDLE, math.huge)

		if self:GetComboCount() > 0 then
			self:SetNextPrimaryFire(self:GetNextPrimaryFire() - (attack.combotime or 0))
			self:SetNextSecondaryFire(self:GetNextSecondaryFire() - (attack.combotime or 0))
		end

		self:Strike(attack, self.Precision)
	end
end

local function TraceHitFlesh(b)
	return b.MatType == MAT_FLESH or b.MatType == MAT_ALIENFLESH or (IsValid(b.Entity) and b.Entity.IsNPC and (b.Entity:IsNPC() or b.Entity:IsPlayer() or b.Entity:IsRagdoll()))
end

local cv_dmg_mult = GetConVar("sv_tfa_damage_multiplier")
local cv_dmg_mult_npc = GetConVar("sv_tfa_damage_multiplier_npc")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")

function SWEP:Strike(attk, precision)
	local hitWorld, hitNonWorld, hitFlesh, needsCB
	local distance, direction, maxhull
	local ow = self:GetOwner()
	if not IsValid(ow) then return end
	distance = attk.len
	direction = attk.dir
	maxhull = attk.hull
	eang = ow:EyeAngles()
	fwd = ow:EyeAngles():Forward()
	tr.start = ow:GetShootPos()
	scl = direction:Length() / precision / 2
	tr.maxs = Vector(scl, scl, scl)
	tr.mins = -tr.maxs
	tr.mask = MASK_SHOT
	tr.filter = {self, ow}

	hitWorld = false
	hitNonWorld = false
	hitFlesh = false

	if attk.callback then
		needsCB = true
	else
		needsCB = false
	end

	if maxhull then
		tr.maxs.x = math.min(tr.maxs.x, maxhull / 2)
		tr.maxs.y = math.min(tr.maxs.y, maxhull / 2)
		tr.maxs.z = math.min(tr.maxs.z, maxhull / 2)
		tr.mins = -tr.maxs
	end

	strikedir:Zero()
	strikedir:Add(direction.x * eang:Right())
	strikedir:Add(direction.y * eang:Forward())
	strikedir:Add(direction.z * eang:Up())
	local strikedirfull = strikedir * 1

	if ow:IsPlayer() and ow:IsAdmin() and GetConVarNumber("developer") > 0 then
		local spos, epos = tr.start + Vector(0, 0, -1) + fwd * distance / 2 - strikedirfull / 2, tr.start + Vector(0, 0, -1) + fwd * distance / 2 + strikedirfull / 2
		debugoverlay.Line(spos, epos, 5, Color(255, 0, 0))
		debugoverlay.Cross(spos, 8, 5, Color(0, 255, 0), true)
		debugoverlay.Cross(epos, 4, 5, Color(0, 255, 255), true)
	end

	if SERVER and not game.SinglePlayer() and ow:IsPlayer() then
		ow:LagCompensation(true)
	end

	local totalResults = {}
	for i = 1, precision do
		dirv = LerpVector((i - 0.5) / precision, -direction / 2, direction / 2)
		strikedir:Zero()
		strikedir:Add(dirv.x * eang:Right())
		strikedir:Add(dirv.y * eang:Forward())
		strikedir:Add(dirv.z * eang:Up())
		tr.endpos = tr.start + distance * fwd + strikedir
		traceres = util.TraceLine(tr)
		table.insert(totalResults, traceres)
	end

	if SERVER and not game.SinglePlayer() and ow:IsPlayer() then
		ow:LagCompensation(false)
	end

	local basedmg = attk.dmg

	local ind = self:GetMelAttackID() or 1
	local srctbl = ind >= 0 and "Primary" or "Secondary"
	if not self:GetStatL(srctbl .. ".SplitDamage") or not basedmg then
		basedmg = self:GetStatL(srctbl .. ".Damage")
	end

	local dmg = basedmg * util.SharedRandom("TFA_Melee_RandomDamageMult" .. CurTime(), cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat(), self:EntIndex())
	if ow:IsNPC() then
		dmg = dmg * cv_dmg_mult_npc:GetFloat()
	else
		dmg = dmg * cv_dmg_mult:GetFloat()
	end

	local forcevec = strikedirfull:GetNormalized() * (attk.force or basedmg / 4) * 128
	local damage = DamageInfo()
	damage:SetAttacker(self:GetOwner())
	damage:SetInflictor(self)
	damage:SetDamage(dmg)
	damage:SetDamageType(attk.dmgtype or DMG_SLASH)
	damage:SetDamageForce(forcevec)
	local fleshHits = 0

	--Handle flesh
	for _, v in ipairs(totalResults) do
		if v.Hit and IsValid(v.Entity) and TraceHitFlesh(v) and (not v.Entity.TFA_HasMeleeHit) then
			self:ApplyDamage(v, damage, attk)
			self:SmackEffect(v, damage)
			v.Entity.TFA_HasMeleeHit = true
			fleshHits = fleshHits + 1
			if fleshHits >= (attk.maxhits or 3) then break end

			if attk.hitflesh and not hitFlesh then
				self:EmitSoundNet(attk.hitflesh)
			end

			if attk.callback and needsCB then
				attk.callback(attk, self, v)
				needsCB = false
			end

			hitFlesh = true
		end
		--debugoverlay.Sphere( v.HitPos, 5, 5, color_white )
	end

	--Handle non-world
	for _, v in ipairs(totalResults) do
		if v.Hit and (not TraceHitFlesh(v)) and (not v.Entity.TFA_HasMeleeHit) then
			self:ApplyDamage(v, damage, attk)
			v.Entity.TFA_HasMeleeHit = true

			if not hitNonWorld then
				self:SmackEffect(v, damage)

				if attk.hitworld and not hitFlesh then
					self:EmitSoundNet(attk.hitworld)
				end

				if attk.callback and needsCB then
					attk.callback(attk, self, v)
					needsCB = false
				end

				self:BurstDoor(v.Entity, damage)
				hitNonWorld = true
			end
		end
	end

	-- Handle world
	if not hitNonWorld and not hitFlesh then
		for _, v in ipairs(totalResults) do
			if v.Hit and v.HitWorld and not hitWorld then
				hitWorld = true

				if attk.hitworld then
					self:EmitSoundNet(attk.hitworld)
				end

				self:SmackEffect(v, damage)

				if attk.callback and needsCB then
					attk.callback(attk, self, v)
					needsCB = false
				end
			end
		end
	end

	--Handle empty + cleanup
	for _, v in ipairs(totalResults) do
		if needsCB then
			attk.callback(attk, self, v)
			needsCB = false
		end

		if IsValid(v.Entity) then
			v.Entity.TFA_HasMeleeHit = false
		end
	end

	if attk.kickback and (hitFlesh or hitNonWorld or hitWorld) then
		self:SendViewModelAnim(attk.kickback)
	end
end

function SWEP:PlaySwing(act)
	self:SendViewModelAnim(act)

	return true, act
end

local lvec = Vector(0, 0, 0)
function SWEP:ChooseAttack(tblName)
	local attacks = self:GetStatL(tblName .. ".Attacks")
	if not attacks or #attacks <= 0 then return -1 end

	local keys = table.GetKeys(attacks)
	table.RemoveByValue(keys, "BaseClass")
	if #keys <= 0 then return -1 end

	local ply = self:GetOwner()
	local isdir = self:GetStatL(tblName .. ".Directional") and IsValid(ply) and ply:IsPlayer()
	local founddir = false
	local foundkeys = {}

	if isdir then
		lvec.x = 0
		lvec.y = 0

		if ply:KeyDown(IN_MOVERIGHT) then
			lvec.y = lvec.y - 1
		end

		if ply:KeyDown(IN_MOVELEFT) then
			lvec.y = lvec.y + 1
		end

		if ply:KeyDown(IN_FORWARD) or ply:KeyDown(IN_JUMP) then
			lvec.x = lvec.x + 1
		end

		if ply:KeyDown(IN_BACK) or ply:KeyDown(IN_DUCK) then
			lvec.x = lvec.x - 1
		end

		local targ = ""
		if lvec.y > 0.3 then
			targ = "L"
		elseif lvec.y < -0.3 then
			targ = "R"
		elseif lvec.x > 0.5 then
			targ = "F"
		elseif lvec.x < -0.1 then
			targ = "B"
		end

		for k, v in pairs(attacks) do
			if (not self:GetSprinting() or v.spr) and v.direction and string.find(v.direction, targ) then
				founddir = true

				table.insert(foundkeys, k)
			end
		end
	end

	if not isdir or #foundkeys <= 0 or not founddir then
		for k, v in pairs(attacks) do
			if (not self:GetSprinting() or v.spr) and v.dmg then
				table.insert(foundkeys, k)
			end
		end
	end

	if #foundkeys <= 0 then return 0 end
	local key = foundkeys[self:SharedRandom(1, #foundkeys, tblName .. "Attack")]
	if not key then return 0 end

	return key, attacks[key]
end

function SWEP:ChoosePrimaryAttack()
	return self:ChooseAttack("Primary")
end

function SWEP:ChooseSecondaryAttack()
	return self:ChooseAttack("Secondary")
end

function SWEP:PrimaryAttack()
	local ow = self:GetOwner()

	if IsValid(ow) and ow:IsNPC() then
		local _, attk = self:ChoosePrimaryAttack()
		if not attk then return end
		local owv = self:GetOwner()

		timer.Simple(0.5, function()
			if IsValid(self) and IsValid(owv) and owv:IsCurrentSchedule(SCHED_MELEE_ATTACK1) then
				self:Strike(attk, 5)
			end
		end)

		self:SetNextPrimaryFire(CurTime() + attk["end"] or 1)

		timer.Simple(self:GetNextPrimaryFire() - CurTime(), function()
			if IsValid(owv) then
				owv:ClearSchedule()
			end
		end)

		self:GetOwner():SetSchedule(SCHED_MELEE_ATTACK1)
		return
	end

	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then return end
	if self:IsSafety() then return end
	if not self:VMIV() then return end
	if CurTime() <= self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	local maxcombo = self:GetStatL("Primary.MaxCombo", 0)
	if maxcombo > 0 and self:GetComboCount() >= maxcombo then return end

	local ind, attack = self:ChoosePrimaryAttack()
	if not attack then return end

	--We have attack isolated, begin attack logic
	self:PlaySwing(attack.act)

	if not attack.snd_delay or attack.snd_delay <= 0 then
		if IsFirstTimePredicted() then
			self:EmitSound(attack.snd)

			if self:GetOwner().Vox then
				self:GetOwner():Vox("bash", 4)
			end
		end

		self:GetOwner():ViewPunch(attack.viewpunch)
	elseif attack.snd_delay then
		if IsFirstTimePredicted() then
			self.AttackSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
			self.VoxSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
		end

		--[[
		timer.Simple(attack.snd_delay, function()
			if IsValid(self) and self:IsValid() and SERVER then
				self:EmitSound(attack.snd)

				if self:OwnerIsValid() and self:GetOwner().Vox then
					self:GetOwner():Vox("bash", 4)
				end
			end
		end)
		]]
		--
		self:SetVP(true)
		self:SetVPPitch(attack.viewpunch.p)
		self:SetVPYaw(attack.viewpunch.y)
		self:SetVPRoll(attack.viewpunch.r)
		self:SetVPTime(CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act))
		self:GetOwner():ViewPunch(-Angle(attack.viewpunch.p / 2, attack.viewpunch.y / 2, attack.viewpunch.r / 2))
	end

	self.up_hat = false
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, attack.delay / self:GetAnimationRate(attack.act))
	self:SetMelAttackID(ind)
	self:SetNextPrimaryFire(CurTime() + attack["end"] / self:GetAnimationRate(attack.act))
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetComboCount(self:GetComboCount() + 1)
end

function SWEP:SecondaryAttack()
	if self:GetSprinting() and not self:GetStatL("AllowSprintAttack", false) then return end
	if self:IsSafety() then return end
	if not self:VMIV() then return end
	if CurTime() <= self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	local maxcombo = self:GetStatL("Secondary.MaxCombo", 0)
	if maxcombo > 0 and self:GetComboCount() >= maxcombo then return end

	local ind, attack = self:ChooseSecondaryAttack()
	if attack then
		ind = -ind
	elseif ind < 0 and self:GetStatL("Secondary.PrimaryFallback") then
		ind, attack = self:ChoosePrimaryAttack()
	end
	if not attack then return end

	--We have attack isolated, begin attack logic
	self:PlaySwing(attack.act)

	if not attack.snd_delay or attack.snd_delay <= 0 then
		if IsFirstTimePredicted() then
			self:EmitSound(attack.snd)

			if self:GetOwner().Vox then
				self:GetOwner():Vox("bash", 4)
			end
		end

		self:GetOwner():ViewPunch(attack.viewpunch)
	elseif attack.snd_delay then
		if IsFirstTimePredicted() then
			self.AttackSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
			self.VoxSoundTime = CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act)
		end

		--[[
		timer.Simple(attack.snd_delay, function()
			if IsValid(self) and self:IsValid() and SERVER then
				self:EmitSound(attack.snd)

				if self:OwnerIsValid() and self:GetOwner().Vox then
					self:GetOwner():Vox("bash", 4)
				end
			end
		end)
		]]
		--
		self:SetVP(true)
		self:SetVPPitch(attack.viewpunch.p)
		self:SetVPYaw(attack.viewpunch.y)
		self:SetVPRoll(attack.viewpunch.r)
		self:SetVPTime(CurTime() + attack.snd_delay / self:GetAnimationRate(attack.act))
		self:GetOwner():ViewPunch(-Angle(attack.viewpunch.p / 2, attack.viewpunch.y / 2, attack.viewpunch.r / 2))
	end

	self.up_hat = false
	self:ScheduleStatus(TFA.Enum.STATUS_SHOOTING, attack.delay / self:GetAnimationRate(attack.act))
	self:SetMelAttackID(ind)
	self:SetNextPrimaryFire(CurTime() + attack["end"] / self:GetAnimationRate(attack.act))
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:SetComboCount(self:GetComboCount() + 1)
end

function SWEP:AltAttack()
	if self.CanBlock then
		if self:GetStatL("Secondary.CanBash") and self.CanBlock and self:GetOwner():KeyDown(IN_USE) then
			BaseClass.AltAttack(self)

			return
		end
	else
		if not self:VMIV() then return end
		if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end
		if not self:GetStatL("Secondary.CanBash") then return end
		if self:IsSafety() then return end

		return BaseClass.AltAttack(self)
	end
end

function SWEP:Reload(released, ovr, ...)
	if not self:VMIV() then return end
	if ovr then return BaseClass.Reload(self, released, ...) end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_inspect", 0) > 0 then
		return
	end

	if (self.SequenceEnabled[ACT_VM_FIDGET] or self.InspectionActions) and self:GetStatus() == TFA.Enum.STATUS_IDLE then
		local _, tanim, ttype = self:ChooseInspectAnim()
		self:ScheduleStatus(TFA.Enum.STATUS_FIDGET, self:GetActivityLength(tanim, false, ttype))
	end
end

function SWEP:CycleSafety()
end

TFA.FillMissingMetaValues(SWEP)

--lua/weapons/tfa_swsft_base_servius/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--lua/weapons/weapon_chemlight_red/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Red"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(255,0,0,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(255, 0, 0, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 255
				dlight.g = 0
				dlight.b = 0
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(255,0,0,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_red"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_red" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_red")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(255,0,0,255)) else
		glow:SetColor(Color(255, 0, 0, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 0 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_red"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 255, 0, 0, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 255, 0, 0, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_red"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_red"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,0,0,255)) else
					ent:SetColor( Color( 255, 0, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_red"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,0,0,255)) else
					ent:SetColor( Color( 255, 0, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(255, 0, 0) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_red"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_red" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--addons/handschellen/lua/weapons/weapon_cuff_base.lua:
---------------------------------------
--   	   Base | Handcuffs          --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Base - Handschellen"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.25

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "slam"

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

-- Handcuff Vars
SWEP.CuffTime = 1.0
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"

SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0

SWEP.CuffReusable = false
SWEP.CuffRecharge = 30 -- Time to re use

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0
SWEP.CuffRegenVariance = 0

-- Network Vars
function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsCuffing" )
	self:NetworkVar( "Entity", 0, "Cuffing" )
	self:NetworkVar( "Float", 0, "CuffTime" )
end

-- Standard SWEP functions
function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:Holster()
	if CLIENT and IsValid(self:GetOwner()) and self:GetOwner() == LocalPlayer() then
		local vm = self:GetOwner():GetViewModel()

		if IsValid(vm) then
			vm:SetMaterial( "" )
		end
	end

	if IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff:Remove()
	end

	if IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff:Remove()
	end

	return true
end

SWEP.OnRemove = SWEP.Holster

function SWEP:PrimaryAttack()
	if self:GetIsCuffing() then return end

	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )

	if CLIENT then return end
	if self:GetCuffTime() > CurTime() then return end

	local tr = self:TargetTrace()

	if not tr then return end

	self:SetCuffTime( CurTime() + self.CuffTime )
	self:SetIsCuffing( true )

	if tr.Entity:IsPlayer() then
		self:SetCuffing( tr.Entity )
	else
		self:SetCuffing( tr.Entity:GetOwner() )
	end

	sound.Play( self.CuffSound, self:GetOwner():GetShootPos(), 75, 100, 1 )
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
	return
end

-- Handcuff
function SWEP:DoHandcuff( target )
	if not (target and IsValid(target)) then return end
	if target:IsHandcuffed() then return end
	if not IsValid(self:GetOwner()) then return end

	if SERVER then
		local wep = target:GetActiveWeapon()

		if IsValid(wep) and wep:GetClass() == "weapon_physcannon" then
			wep:Remove()

			timer.Simple( 0.1, function()
				if IsValid(target) and target:Alive() and not (target.isArrested and target:isArrested()) then
					target:Give("weapon_physcannon")
				end
			end)
		end
	end

	if target:Alive() then
		local cuff = target:Give( "weapon_handcuffed" )
		cuff:SetCuffStrength( self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance)) )
		cuff:SetCuffRegen( self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance)) )

		cuff:SetCuffMaterial( self.CuffMaterial )
		cuff:SetRopeMaterial( self.CuffRope )

		cuff:SetKidnapper( self:GetOwner() )
		cuff:SetRopeLength( self.RopeLength )

		cuff:SetCanBlind( self.CuffBlindfold )
		cuff:SetCanGag( self.CuffGag )

		cuff.CuffType = self:GetClass() or ""

		if self.IsLeash then
			cuff:SetIsLeash( true )

			timer.Simple( 0, function()
				if IsValid(cuff) then
					cuff:SetHoldType( "normal" )
					cuff.HoldType = "normal"
				end
			end)
		end
	else
		target.corpse:SetNWEntity("Cuff.Kidnapper", self:GetOwner())
		target.corpse:SetNWFloat("Cuff.RopeLength", self.RopeLength)
		target.corpse:SetNWString("Cuff.CuffMaterial", self.CuffMaterial)
		target.corpse:SetNWString("Cuff.CuffRope", self.CuffRope)

		local cuff = {}
		cuff.Strength = self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance))
		cuff.Regen = self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance))
		cuff.Material = self.CuffMaterial
		cuff.RopeMaterial = self.CuffRope
		cuff.RopeLength = self.RopeLength
		cuff.CanBlind = self.CuffBlindfold
		cuff.CanGag = self.CuffGag
		cuff.IsLeash = self.IsLeash
		cuff.CuffType = self:GetClass() or ""
		cuff.Kidnapper = self:GetOwner()

		target.cuffed = cuff

		if target.LastDeathStunned and target.LastDeathDuration <= 30 then
			DeathSystem:Revive(target)
		end
	end

	if not self.CuffReusable then
		if IsValid(self:GetOwner()) then self:GetOwner():ConCommand("lastinv") end

		self:Remove()
	end
end

-- Think
function SWEP:Think()
	if SERVER and self:GetIsCuffing() then
		local tr = self:TargetTrace()

		if not tr then return end
		if not tr.Entity or not IsValid(tr.Entity) then return end

		local ent = tr.Entity

		if ent:IsPlayer() then
			if ent ~= self:GetCuffing() then
				self:SetIsCuffing(false)
				self:SetCuffTime( 0 )

				return
			end
		else
			if ent:GetOwner() and IsValid(ent:GetOwner()) and (ent:GetOwner().corpse != ent) then
				self:SetIsCuffing(false)
				self:SetCuffTime( 0 )

				return
			end
		end

		if CurTime() > self:GetCuffTime() then
			self:SetIsCuffing( false )
			self:SetCuffTime( CurTime() + self.CuffRecharge )
			self:DoHandcuff( self:GetCuffing() )
		end
	end
end

-- Get Target
function SWEP:TargetTrace()
	if not IsValid(self:GetOwner()) then return end

	local tr = util.TraceLine({
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + (self:GetOwner():GetAimVector() * 150),
		filter = {self, self:GetOwner()}
	})

	if IsValid(tr.Entity) then
		local ent = tr.Entity

		if ent:IsPlayer() then
			if ent == self:GetOwner() then return end
			if ent:IsHandcuffed() then return end

			if hook.Run( "CuffsCanHandcuff", self:GetOwner(), ent ) == false then return end
		else
			if IsValid(ent:GetOwner()) and ent:GetOwner():IsPlayer() then
				local owner = ent:GetOwner()

				--if not owner.LastDeathStunned then return end
				if not owner.corpse and owner.corpse != ent then return end
			else
				return
			end
		end

		return tr
	end
end

-- HUD
local Col = {
	Text = Color(255,255,255), TextShadow = Color(0,0,0),
	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
}

local matGrad = Material( "gui/gradient" )

function SWEP:DrawHUD()
	if not self:GetIsCuffing() then
		if self:GetCuffTime() <= CurTime() then return end

		local w,h = (ScrW() / 2), (ScrH() / 2)

		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w - 101, h + 54, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, h + 55, 200, 20 )

		local CuffingPercent = math.Clamp( (self:GetCuffTime() - CurTime()) / self.CuffRecharge, 0, 1 )

		render.SetScissorRect( w - 100, h + 55, (w-100) + (CuffingPercent  * 200), h + 75, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w - 100,h + 55, 200,20 )

			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w - 100, h + 55, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )

		return
	end

	local w,h = ScrW() / 2, ScrH() / 2

	draw.SimpleText( "Lege Handschellen an...", "HandcuffsText", w + 1, h + 31, Col.TextShadow, TEXT_ALIGN_CENTER )
	draw.SimpleText( "Lege Handschellen an...", "HandcuffsText", w, h + 30, Col.Text, TEXT_ALIGN_CENTER )

	surface.SetDrawColor( Col.BoxOutline )
	surface.DrawOutlinedRect( w - 101, h + 54, 202, 22 )
	surface.SetDrawColor( Col.BoxBackground )
	surface.DrawRect( w - 100, h + 55, 200, 20 )

	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime() - CurTime()) / self.CuffTime), 0, 1 )

	render.SetScissorRect( w-100, h + 55, (w-100) + (CuffingPercent * 200), h + 75, true )
		surface.SetDrawColor( Col.BoxRight )
		surface.DrawRect( w-100,h + 55, 200,20 )

		surface.SetMaterial( matGrad )
		surface.SetDrawColor( Col.BoxLeft )
		surface.DrawTexturedRect( w-100,h + 55, 200,20 )
	render.SetScissorRect( 0,0,0,0, false )
end

-- Rendering
local renderpos = {
	left = {pos = Vector(0,0,0), vel = Vector(0,0,0), gravity = 1, ang = Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos = Vector(3.2,2.1,0.4), ang = Angle(-2,0,80), scale = Vector(0.045,0.045,0.03)},
	rope = {l = Vector(0,0,2.0), r = Vector(2.3,-1.9,2.7)},
}

local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local RopeCol = Color(255,255,255)

function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end

	vm:SetMaterial( "engine/occlusionproxy" )

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )

		renderpos.left.pos = self:GetOwner():GetPos()
	end

	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end

	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )

	if not (rpos and rang) then return end

	-- Right
	local fixed_rpos = rpos + (rang:Forward() * renderpos.right.pos.x) + (rang:Right() * renderpos.right.pos.y) + (rang:Up() * renderpos.right.pos.z)
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() -- Prevents moving axes

	self.cmdl_RightCuff:SetPos( fixed_rpos )

	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )

	self.cmdl_RightCuff:SetAngles( rang )

	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )

	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()

	-- Left
	if CurTime() > (renderpos.left.NextThink or 0) then
		local dist = renderpos.left.pos:Distance( fixed_rpos )
		if dist > 100 then
			renderpos.left.pos = fixed_rpos
			renderpos.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - renderpos.left.pos) * 0.3
			renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, target.x, 1 )
			renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, target.y, 1 )
			renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, target.z, 3 )
		end

		renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, 0, 0.5 )
		renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, 0, 0.5 )
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, 0, 0.5 )

		local targetZ = ((fixed_rpos.z - 10) - renderpos.left.pos.z) * renderpos.left.gravity
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, targetZ, 3 )

		renderpos.left.pos:Add( renderpos.left.vel )
	end

	self.cmdl_LeftCuff:SetPos( renderpos.left.pos )
	self.cmdl_LeftCuff:SetAngles( renderpos.left.ang )

	if not self.IsLeash then
		local matrix = Matrix()
		matrix:Scale( renderpos.right.scale )

		self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
		self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
		self.cmdl_LeftCuff:DrawModel()
	end

	-- Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam(
		renderpos.left.pos + renderpos.rope.l,
		rpos + (rang:Forward() * renderpos.rope.r.x) + (rang:Right() * renderpos.rope.r.y) + (rang:Up() * renderpos.rope.r.z),
		0.7,
		0,
		5,
		RopeCol
	)
end

SWEP.wrender = {
	left = {pos = Vector(0,0,0), vel = Vector(0,0,0), gravity = 1, ang = Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos = Vector(2.95,2.5,-0.2), ang = Angle(30,0,90), scale = Vector(0.044,0.044,0.044)},
	rope = {l = Vector(0,0,2), r = Vector(3,-1.65,1)},
}

function SWEP:DrawWorldModel()
	if not IsValid(self:GetOwner()) then return end

	local wrender = self.wrender

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
	end

	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
	end

	local rpos, rang = self:GetBonePos( wrender.right.bone, self:GetOwner() )

	if not (rpos and rang) then return end

	-- Right
	local fixed_rpos = rpos + (rang:Forward() * wrender.right.pos.x) + (rang:Right() * wrender.right.pos.y) + (rang:Up() * wrender.right.pos.z)
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() -- Prevents moving axes

	self.cmdl_RightCuff:SetPos( fixed_rpos )

	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )

	self.cmdl_RightCuff:SetAngles( rang )

	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )

	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()

	-- Left
	if CurTime() > (wrender.left.NextThink or 0) then
		local dist = wrender.left.pos:Distance( fixed_rpos )

		if dist > 100 then
			wrender.left.pos = fixed_rpos
			wrender.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - wrender.left.pos) * 0.3
			wrender.left.vel.x = math.Approach( wrender.left.vel.x, target.x, 1 )
			wrender.left.vel.y = math.Approach( wrender.left.vel.y, target.y, 1 )
			wrender.left.vel.z = math.Approach( wrender.left.vel.z, target.z, 3 )
		end

		wrender.left.vel.x = math.Approach( wrender.left.vel.x, 0, 0.5 )
		wrender.left.vel.y = math.Approach( wrender.left.vel.y, 0, 0.5 )
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, 0, 0.5 )

		local targetZ = ((fixed_rpos.z - 10) - wrender.left.pos.z) * wrender.left.gravity
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, targetZ, 3 )
		wrender.left.pos:Add( wrender.left.vel )
	end

	self.cmdl_LeftCuff:SetPos(wrender.left.pos)
	self.cmdl_LeftCuff:SetAngles(wrender.left.ang)

	if not self.IsLeash then
		local matrix = Matrix()
		matrix:Scale( wrender.right.scale )

		self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
		self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
		self.cmdl_LeftCuff:DrawModel()
	end

	-- Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam(
		wrender.left.pos + wrender.rope.l,
		rpos + (rang:Forward() * wrender.rope.r.x) + (rang:Right() * wrender.rope.r.y) + (rang:Up() * wrender.rope.r.z),
		0.7,
		0,
		5,
		RopeCol
	)
end

-- Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )

	if not bone then return end

	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )

	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end

	if self.ViewModelFlip then ang.r = -ang.r end

	return pos, ang
end

--addons/handschellen/lua/weapons/weapon_cuff_tactical.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------


AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Diese Handfesseln sind schnell anzulegen."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Schnelle Handfesseln"

-- Handcuff Vars
SWEP.CuffTime = 0.1
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/bluemetal"
SWEP.CuffRope = "cable/blue"
SWEP.CuffStrength = 0.55
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 0

SWEP.CuffReusable = true
SWEP.CuffRecharge = 20

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1
SWEP.CuffRegenVariance = 0.3

--addons/vfire_extinguisher/lua/weapons/weapon_extinguisher.lua:

--[[

If you want to override the default extinguishing action, or do something custom when something gets extinguished by this mod, use this hook

hook.Add( "ExtinguisherDoExtinguish", "", function( prop )
	print( prop ) -- The prop that is being extinguished, can be any entity
	return true -- true to prevent default action. Other values or no return will mean do default action.
end )

]]

AddCSLuaFile()
AddCSLuaFile( "effects/rb655_extinguisher_effect.lua" )

if ( SERVER ) then resource.AddWorkshop( "104607228" ) end

SWEP.PrintName = "Extinguisher"
SWEP.Author = "Robotboy655"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it. Jump into water to get more ammo!"

SWEP.Slot = 5
SWEP.SlotPos = 35
SWEP.Weight = 1

SWEP.DrawAmmo = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true

SWEP.DrawWeaponInfoBox = false
SWEP.Spawnable = true
SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_fire_extinguisher.mdl"
SWEP.ViewModelFOV = 55
SWEP.WorldModel = "models/weapons/w_fire_extinguisher.mdl"
SWEP.HoldType = "slam"

game.AddAmmoType( { name = "rb655_extinguisher" } )
if ( CLIENT ) then language.Add( "rb655_extinguisher_ammo", "Extinguisher Ammo" ) end

SWEP.MaxAmmo = 5000

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = SWEP.MaxAmmo
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "rb655_extinguisher"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextIdle" )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )

	self:Idle()

	return true
end

function SWEP:Holster( weapon )
	if ( CLIENT ) then return end

	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	return true
end

function SWEP:OnDrop()
	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	-- Do not give any more extra ammo
	self.Primary.DefaultClip = 0
end

function SWEP:DoEffect( effectscale )

	local effectdata = EffectData()
	effectdata:SetAttachment( 1 )
	effectdata:SetEntity( self.Owner )
	effectdata:SetOrigin( self.Owner:GetShootPos() )
	effectdata:SetNormal( self.Owner:GetAimVector() )
	effectdata:SetScale( effectscale or 1 )
	util.Effect( "rb655_extinguisher_effect", effectdata )

end

function SWEP:DoExtinguish( pushforce, effectscale )

	if ( self:Ammo1() < 1 ) then return end

	if ( CLIENT ) then
		if ( self.Owner == LocalPlayer() ) then self:DoEffect( effectscale ) end -- FIXME
		return
	end

	if ( !self.IsInfinite ) then
		self:TakePrimaryAmmo( 1 )
	end

	effectscale = effectscale or 1
	pushforce = pushforce or 0

	local tr
	if ( self.Owner:IsNPC() ) then
		tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 16384,
			filter = self.Owner
		} )
	else
		tr = self.Owner:GetEyeTrace()
	end

	local pos = tr.HitPos

	for id, prop in pairs( ents.FindInSphere( pos, 80 ) ) do
		if ( !IsValid( prop ) or prop:GetPos():Distance( self:GetPos() ) > 256 ) then continue end
		if ( prop:IsWeapon() and IsValid( prop:GetOwner() ) ) then continue end -- Played equipped weapons
		if ( prop:GetClass():find( "viewmodel" ) ) then continue end -- View models

		if ( pushforce > 0 ) then
			local physobj = prop:GetPhysicsObject()
			if ( IsValid( physobj ) ) then
				physobj:ApplyForceOffset( self.Owner:GetAimVector() * pushforce, pos )
			end
		end

		-- Perhaps this random call should be replaced by a timer of sorts?
		if ( math.random( 0, 1000 ) > 500 ) then
			local retval = hook.Call( "ExtinguisherDoExtinguish", nil, prop )
			if ( retval == true ) then continue end

			if ( prop:IsOnFire() ) then prop:Extinguish() end

			local class = prop:GetClass()
			if ( string.find( class, "ent_minecraft_torch" ) and prop:GetWorking() ) then
				prop:SetWorking( false )
			elseif ( string.find( class, "env_fire" ) ) then -- Gas Can support. Should work in ravenholm too.
				prop:Fire( "Extinguish" )
			end
		end
	end

	self:DoEffect( effectscale )

end

function SWEP:PrimaryAttack()
	if ( self:GetNextPrimaryFire() > CurTime() ) then return end

	if ( IsFirstTimePredicted() ) then

		self:DoExtinguish( 196, 1 )

		if ( SERVER ) then

			if ( self.Owner:KeyPressed( IN_ATTACK ) or !self.Sound ) then
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

				self.Sound = CreateSound( self.Owner, Sound( "weapons/extinguisher/fire1.wav" ) )

				self:Idle()
			end

			if ( self:Ammo1() > 0 and self.Sound ) then self.Sound:Play() end

		end
	end

	self:SetNextPrimaryFire( CurTime() + 0.05 )
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:PlaySound()
	self:EmitSound( "weapons/extinguisher/release1.wav", 100, math.random( 95, 110 ) )
end

function SWEP:Think()

	if ( self:GetNextIdle() > 0 and CurTime() > self:GetNextIdle() ) then

		self:DoIdleAnimation()
		self:Idle()

	end

	if ( self:GetNextSecondaryFire() > CurTime() or CLIENT ) then return end

	if ( ( self.NextAmmoReplenish or 0 ) < CurTime() and self.Owner:WaterLevel() > 1 ) then
		if ( !self.IsInfinite && self:Ammo1() < self.MaxAmmo * 2 ) then
			self.Owner:SetAmmo( math.min( self:Ammo1() + 25, self.MaxAmmo * 2 ), self:GetPrimaryAmmoType() )
		end
		self.NextAmmoReplenish = CurTime() + 0.1
	end

	if ( self.Sound and self.Sound:IsPlaying() and self:Ammo1() < 1 ) then
		self.Sound:Stop()
		self.Sound = nil
		self:PlaySound()
		self:DoIdleAnimation()
		self:Idle()
	end

	if ( self.Owner:KeyReleased( IN_ATTACK ) or ( !self.Owner:KeyDown( IN_ATTACK ) and self.Sound ) ) then

		self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )

		if ( self.Sound ) then
			self.Sound:Stop()
			self.Sound = nil
			if ( self:Ammo1() > 0 ) then
				self:PlaySound()
				if ( !game.SinglePlayer() ) then self:CallOnClient( "PlaySound", "" ) end
			end
		end

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )
		self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() )

		self:Idle()

	end
end

function SWEP:DoIdleAnimation()
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() > 0 ) then self:SendWeaponAnim( ACT_VM_IDLE_1 ) return end
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() < 1 ) then self:SendWeaponAnim( ACT_VM_IDLE_EMPTY ) return end
	self:SendWeaponAnim( ACT_VM_IDLE )
end

function SWEP:Idle()

	self:SetNextIdle( CurTime() + self:GetAnimationTime() )

end

function SWEP:GetAnimationTime()
	local time = self:SequenceDuration()
	if ( time == 0 and IsValid( self.Owner ) and !self.Owner:IsNPC() and IsValid( self.Owner:GetViewModel() ) ) then time = self.Owner:GetViewModel():SequenceDuration() end
	return time
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon.png" )

function SWEP:DrawWeaponSelection( x, y, w, h, a )

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	surface.SetDrawColor( 255, 255, 255, a )
	surface.SetMaterial( self.WepSelectIcon )

	local size = math.min( w, h ) - 32
	surface.DrawTexturedRect( x + w / 2 - size / 2, y + h * 0.05, size, size )

	render.PopFilterMag()
	render.PopFilterMin()

end

--addons/handschellen/lua/weapons/weapon_leash_base.lua:
---------------------------------------
--   	 Base | Lash Handcuffs       --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Slot = 2
SWEP.PrintName = "Base - Leash"

SWEP.IsLeash = true

local Col = {
	Text = Color(255,255,255), TextShadow = Color(0,0,0),

	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
}

local matGrad = Material( "gui/gradient" )

function SWEP:DrawHUD()
	if not self:GetIsCuffing() then
		if self:GetCuffTime() <= CurTime() then return end

		local w,h = (ScrW() / 2), (ScrH() / 2)

		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, h + 54, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, h + 55, 200, 20 )

		local CuffingPercent = math.Clamp( (self:GetCuffTime() - CurTime()) / self.CuffRecharge, 0, 1 )

		render.SetScissorRect( w - 100, h + 55, (w - 100) + (CuffingPercent * 200), h + 75, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w - 100,h + 55, 200,20 )

			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w - 100, h + 55, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )

		return
	end

	local w,h = (ScrW() / 2), (ScrH() / 2)

	draw.SimpleText( "Lege Leine an...", "HandcuffsText", w + 1, h + 31, Col.TextShadow, TEXT_ALIGN_CENTER )
	draw.SimpleText( "Lege Leine an...", "HandcuffsText", w, h + 30, Col.Text, TEXT_ALIGN_CENTER )

	surface.SetDrawColor( Col.BoxOutline )
	surface.DrawOutlinedRect( w - 101, h + 54, 202, 22 )
	surface.SetDrawColor( Col.BoxBackground )
	surface.DrawRect( w-100, h + 55, 200, 20 )

	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime() - CurTime()) / self.CuffTime), 0, 1 )

	render.SetScissorRect( w - 100, h + 55, (w - 100) + (CuffingPercent * 200), h + 75, true )
		surface.SetDrawColor( Col.BoxRight )
		surface.DrawRect( w - 100, h + 55, 200,20 )

		surface.SetMaterial( matGrad )
		surface.SetDrawColor( Col.BoxLeft )
		surface.DrawTexturedRect( w - 100, h + 55, 200,20 )
	render.SetScissorRect( 0,0,0,0, false )
end

function SWEP:PrimaryAttack()
	if self:GetIsCuffing() then return end

	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )

	if CLIENT then return end

	if self:GetCuffTime() > CurTime() then return end

	local tr = self:TargetTrace()

	if not tr then return end
	if not tr.Entity:IsPlayer() then return end

	self:SetCuffTime( CurTime() + self.CuffTime )
	self:SetIsCuffing( true )
	self:SetCuffing( tr.Entity )

	sound.Play( self.CuffSound, self:GetOwner():GetShootPos(), 75, 100, 1 )
end

function SWEP:TargetTrace()
	if not IsValid(self:GetOwner()) then return end

	local tr = util.TraceLine({
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + (self:GetOwner():GetAimVector() * 150),
		filter = {self, self:GetOwner()}
	})

	if IsValid(tr.Entity) then
		local ent = tr.Entity

		if ent:IsPlayer() then
			if ent == self:GetOwner() then return end
			if ent:IsHandcuffed() then return end

			if hook.Run( "CuffsCanHandcuff", self:GetOwner(), ent ) == false then return end
		end

		return tr
	end
end

--addons/handschellen/lua/weapons/weapon_leash_rope.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_leash_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Dies ist eine Seilleine."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Leine"


-- Handcuff Vars
SWEP.CuffTime = 4
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 150
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1
SWEP.CuffRegenVariance = 0.2

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_grievous.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Grievous" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_grievous" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Macht-Geschwindigkeit",
	"Beinhieb"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/byph.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_kolar.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Agen Kolar" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_kolar" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Macht-Öffnung",
	"Machtstoß",
	"Macht-Griff",
	"Macht-Sicht",
	"Macht-Stürmen",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Beben",
	"Klingensturm",
	"Beinhieb",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1},
	["Form VII | Juyo"]   = {1, 2, 3},
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/jocastanu.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color( 0, 63, 255 )
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_kon.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/jocastanu.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Plo Koon" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_kon" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Atemkontrolle",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Sicht",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Smaragdblitze",
	"Macht-Beben",
	"Beinhieb",
	"Machtblockade",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/jocastanu.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_koth.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/jocastanu.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Eeth Koth" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_koth" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Atemkontrolle",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Klingensturm",
	"Macht-Beben",
	"Beinhieb",
	"Machtblockade",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/jocastanu.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 185, 5) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end
--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_nightsister.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Nachtschwester-Klinge" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_nightsister" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machttarnung",
	"Machtschub",
	"Machtzug",
	"Blenden",
	"Blutopfer",
	"Hass kanalisieren",
	"Hexen Machtblitze"
}

SWEP.DevestatorList = { "Innere Furcht" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form V | Djem So"]  = {2},
	["Form VII | Vaapad"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "SWTOR 9"
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 1 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_ti.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/shaakti.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Shaak Ti" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_ti" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Machtheilung",
	"Gruppenheilung",
	"Selbstheilung",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Kristallschlag",
	"Macht-Sicht",
	"Machtschild",
	"Macht-Verlangsamung",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Schallentladung", "Flammenschauer" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/shaakti.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_tiplar.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Tiplar" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_tiplar" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stürmen",
	"Macht-Sicht",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Atemkontrolle",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/compressedcrystal.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_training.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.TrainingLightsaber = true


------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Trainingslichtschwert" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_training" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 75 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(225, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop8.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on4_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off4_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_vos.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Quinlan Vos" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_vos" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Stürmen",
	"Machtstoß",
	"Macht-Öffnung",
	"Schwert-Barriere",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Griff",
	"Macht-Sicht",
	"Lähmender Schlag",
	"Machttarnung",
	"Schattenschlag",
	"Machtblitze",
	"Macht-Würgegriff",
	"Macht-Beben",
	"Klingensturm",
	"Beinhieb",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_windu.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Mace Windu" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_windu" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Machtschub",
	"Atemkontrolle",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Machtblockade",
	"Willenskraft",
	"Macht-Brechen",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/egm_tfa_mines/lua/weapons/weapon_mine_emp/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_mine_base"
SWEP.PrintName 				= "Mine - EMP"
SWEP.Category 				= "SW:RP (Republik)"

SWEP.Spawnable				= true

SWEP.Mine 					= "mine_emp"
SWEP.Skin 					= 2

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

--addons/egm_tfa_mines/lua/weapons/weapon_mine_incendiary/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_mine_base"
SWEP.PrintName 				= "Mine - Brandmine"
SWEP.Category 				= "SW:RP (Republik)"

SWEP.Spawnable				= true

SWEP.Mine 					= "mine_incendiary"
SWEP.Skin 					= 3

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

--gamemodes/starwarsrp/entities/weapons/weapon_swrp_breathingswep/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

include("shared.lua")

hook.Add("HUDPaint", "Realism.BreatPaint", function()
	local ply = LocalPlayer()

	if not ply:HasWeapon("weapon_swrp_breathingswep") then return end

	local weapon = ply:GetWeapon("weapon_swrp_breathingswep")

	if weapon:GetOxygen() < weapon.MaxOxygen then
		local percentage = math.Round(weapon:GetOxygen(), 1) / weapon.MaxOxygen
		local color = percentage > 0.25 and GetColor("black", 127) or GetColor("red", 127)

		-- Background bar.
		draw.RoundedBox(5, ScrW() * 0.4, ScrH() * 0.95, ScrW() * 0.2, ScrH() * 0.011, color)

		-- Foreground bar.
		draw.RoundedBox(5, math.floor(ScrW() * 0.4 + ScrW() * 0.1 * (1 - percentage)), ScrH() * 0.95, math.ceil(ScrW() * 0.2 * percentage), ScrH() * 0.011, GetColor("blue", 175))

		if percentage < 0.5 then
			local alphaValue = math.max(0, (0.5 - percentage) * 2) * 250
			draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), GetColor("gray", alphaValue))
		end
	end
end)
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15a_sk.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15A SK"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(0, 0, 1.4)
SWEP.VMAng = Vector(-10, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = true

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(5, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15sk"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_sk.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.5, -7, 0.8), angle = Angle(10, -90, 0), size = Vector(0.95, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dc15sk"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_sk.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 285
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 140

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-3.15, -6, -0.85)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15a_blaster_rifle/dc15a_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15a_training.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15A Training"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(0, -2, -1.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15a"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, -1.5, 2.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dc15a"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15a_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_aqua"

-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 285
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 140

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 0

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2.83, -6, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15a_blaster_rifle/dc15a_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15le.lua:
-- Written by Oninoni and Meredin

SWEP.Base                        = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName                   = "DC-15LE"
SWEP.Category                    = "SW:RP (Republik)"
SWEP.Type                        = "Republic Heavy Scoped Blaster Rifle"
SWEP.Manufacturer                = "BlasTech Industries"
SWEP.Slot                        = 0
SWEP.SlotPos                     = 0

SWEP.Spawnable                   = true

-- Model --

SWEP.ViewModel                   = "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel                  = "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos                       = Vector(0, -2, -1.5)
SWEP.VMAng                       = Vector(0, 0, 0)

SWEP.HoldType                    = "ar2"
SWEP.ReloadHoldTypeOverride      = "ar2"

SWEP.UseHands                    = true

SWEP.ShowWorldModel              = false

SWEP.ViewModelBoneMods           = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements                   = {
	["dc15le"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15le_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, -1.5, 2.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "dc15le", pos = Vector(8, 2.075, 3.38), angle = Angle(0, 180, 0), size = Vector(0.245, 0.245, 0.245), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements                   = {
	["dc15le"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15le_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments                 = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName                  = "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize            = 20
-- Magazine Count
SWEP.Primary.DefaultClip         = SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo                = "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption     = 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes                   = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM                 = 80
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi            = 80

-- Burst Fire RPM
SWEP.Primary.RPM_Burst           = nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay          = nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range               = 16000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots            = 1
-- Damage per bullet
SWEP.Primary.Damage              = 90

-- Aiming --

SWEP.data                        = {}
-- Enable Iron Sights
SWEP.data.ironsights             = 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV           = 75 -- TODO

SWEP.RTScopeAttachment           = -1
SWEP.Scoped_3D                   = false
SWEP.ScopeReticule               = "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom         = 2
SWEP.ScopeReticule_Scale         = { 1.1, 1.1 }
SWEP.IronSightsSensitivity       = 0.25

SWEP.ZoomLevels = {
	2,
	5,
    6
}

SWEP.Primary.Spread              = 0.004
SWEP.Primary.IronAccuracy        = 0.0015

SWEP.Primary.SpreadMultiplierMax = 2.5
SWEP.Primary.SpreadIncrement     = 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos               = Vector(-4.965, -12, 1.765)
SWEP.IronSightsAng               = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos                = Vector(5.226, -2, 0)
SWEP.RunSightsAng                = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos                  = Vector(8, -4.8, -3)
SWEP.InspectAng                  = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound               = Sound("weapons/dc15a_blaster_rifle/dc15a_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound         = Sound("w/heavy.wav")

DEFINE_BASECLASS(SWEP.Base)

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15le_lmg.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15LE LMG"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Scoped Light Mashine Gun"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(0, -2, -1.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15le"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15lmg.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, -1.5, 2.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}},
}

SWEP.WElements = {
	["dc15le"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15lmg.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {}},
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 5

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 700
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 240

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8120

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 25

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.012

SWEP.Primary.SpreadMultiplierMax 	= 2.6
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2.83, -6, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15a_blaster_rifle/dc15a_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17_stun.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-17 Stun"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0.35, 0, 0.2), angle = Angle(0, 180, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/fisher/extendeddc17/extendeddc17.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 1.5, -1.5), angle = Angle(0, -90, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(2.5, 0.2, -2)
SWEP.HolsterAngle = Angle(0, -90, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 250

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 31

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0145
SWEP.Primary.IronAccuracy 			= 0.0048

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/dc17_blaster_pistol/dc17_fire.ogg");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav");

DEFINE_BASECLASS( SWEP.Base )
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_det/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Detonator
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Ein Detonator für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Platzieren\nRechtsklick oder E zum Zünden\nNachladen zum Aufsammeln eines Detonators"

SWEP.Category = "SW:RP (Event)"

SWEP.PrintName = "Detonator"

SWEP.Base = "weapon_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 50
SWEP.Slot = 2
SWEP.SlotPos = 0

SWEP.DefaultHoldType = "pistol"

SWEP.ViewModel = "models/weapons/v_swrcdeton.mdl"
SWEP.WorldModel = "models/weapons/w_swrcdeton.mdl"

SWEP.ShowWorldModel = true

SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "rpg_round"
SWEP.Primary.ClipSize        = 1
SWEP.Primary.DefaultClip    = 3
SWEP.AdditionalAmmo         = 2

SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.NextDeplace = 0

function SWEP:Initialize()
	self:SetHoldType(self.DefaultHoldType)
	self.Detonators = {}
end

function SWEP:PrimaryAttack()
	if self:CanPrimaryAttack() then
		if #self.Detonators >= 3 then return end

		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

		self:SetNextPrimaryFire(CurTime() + 4)
		self:SetNextSecondaryFire(CurTime() + 4)

		timer.Simple(2, function()
			self:DefaultReload( ACT_VM_RELOAD )
			self:PlaceDetonator()
		end)
	end
end

function SWEP:SecondaryAttack()
	if SERVER then
		for k, detonator in pairs(self.Detonators) do
			if IsValid(detonator) then
				detonator:ActivateDetonator()
			end
		end

		self.Detonators = {}
	end
end

function SWEP:PlaceDetonator()
	local owner = self:GetOwner()

	self:SendWeaponAnim(ACT_VM_DRAW)
	owner:SetAnimation(PLAYER_ATTACK1)

	if SERVER then
		local tr = util.TraceLine({
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + 115 * owner:GetAimVector(),
			filter = owner
		})

		if tr.Hit then
			local detonator = ents.Create("swrp_detonator")
			detonator:SetPos(tr.HitPos + tr.HitNormal)
			tr.HitNormal.z = -tr.HitNormal.z
			detonator:SetAngles( tr.HitNormal:Angle() - Angle(90, 180, 0))
			detonator:Spawn()
			detonator:SetMoveType(MOVETYPE_NONE)
			detonator.detOwner = self:GetOwner()

			self.Detonators[#self.Detonators + 1] = detonator

			timer.Simple(1, function()
				if IsValid(self) then
					self:SendWeaponAnim(ACT_VM_IDLE)
					self:TakePrimaryAmmo(1)
				end
			end)
		end
	end
end

function SWEP:Reload()
	if self:Clip1() <= 0 then
		self:DefaultReload( ACT_VM_RELOAD )

		self:SetNextPrimaryFire(CurTime() + 4)
		self:SetNextSecondaryFire(CurTime() + 4)
		return
	end

	if self.NextDeplace >= CurTime() then return end

	self:DeplaceDetonator()

	self.NextDeplace = CurTime() + 5
end

function SWEP:DeplaceDetonator()
	local owner = self:GetOwner()

	if SERVER then
		local tr = util.TraceLine({
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + 115 * owner:GetAimVector(),
			filter = owner
		})

		if IsValid(tr.Entity) and tr.Entity:GetClass() == "swrp_detonator" then
			local detonator = tr.Entity

			self:SendWeaponAnim(ACT_VM_DRAW)
			owner:SetAnimation(PLAYER_ATTACK1)

			table.RemoveByValue(self.Detonators, detonator)

			if detonator.detOwner == owner then
				owner:GiveAmmo(1, "rpg_round")
				detonator:Remove()
			end

			timer.Simple(1, function()
				if IsValid(self) then
					self:SendWeaponAnim(ACT_VM_IDLE)
				end
			end)
		end
	end
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dl44dual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DL44 Dual"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel						= "models/sw_battlefront/weapons/dl44_pistol.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "duel"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {
	["dl44"] = { type = "Model", model = SWEP.WorldModel, bone = "LeftHand_1stP", rel = "", pos = Vector(4, 2, -1), angle = Angle(0, 0, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dl44+"] = { type = "Model", model = SWEP.WorldModel, bone = "RightHand_1stP", rel = "", pos = Vector(-4, -2, 1), angle = Angle(180, 0, -90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dl44"] = { type = "Model", model = SWEP.WorldModel, bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(4, 2, 1.5), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dl44+"] = { type = "Model", model = SWEP.WorldModel, bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, -1.5), angle = Angle(0, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash 			= true
SWEP.Secondary.DoMuzzleFlash 		= true
SWEP.Blowback_Shell_Enabled 		= true
SWEP.Blowback_Shell_Effect 			= "None"

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_dual_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100 * 2
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 218 * 1.5

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -5, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(0, -7.5, -10)
SWEP.RunSightsAng = Vector(37.5, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, -5, -5)
SWEP.InspectAng = Vector(37.5,0,0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/dl44_fire.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/dl44_reload.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dp24.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DP-24"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dp24"] = { type = "Model", model = "models/cs574/weapons/dp24.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-0.6, 0.3, 0.9), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dp24"] = { type = "Model", model = "models/cs574/weapons/dp24.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 0.5, -1.25), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 400
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 250

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 32

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.02
SWEP.Primary.IronAccuracy 			= 0.0067

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2.55, -7, 2.3)
SWEP.IronSightsAng = Vector (2, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)



-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dc15.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/rifles.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dt12dual.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName				= "Dual DT-12"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 90

SWEP.VMPos = Vector(0, -5.5, -1.5)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "duel"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {
	["rk3"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "LeftHand_1stP", rel = "", pos = Vector(5, -02, -1), angle = Angle(-10, 0, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rk3+"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "RightHand_1stP", rel = "", pos = Vector(-5, 02, 1), angle = Angle(170, 0, -90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.WElements = {
	["rk3"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(5.5, 01.25, -2.75), angle = Angle(0, -10, 2), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["rk3+"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5.5, 01.25, 2.75), angle = Angle(0, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash 			= true
SWEP.Secondary.DoMuzzleFlash 		= true
SWEP.Blowback_Shell_Enabled 		= true
SWEP.Blowback_Shell_Effect 			= "None"

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_dual_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 50 * 2
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 281 * 1.5

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 31

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -5, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(0, -7.5, -10)
SWEP.RunSightsAng = Vector(37.5, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, -5, -5)
SWEP.InspectAng = Vector(37.5,0,0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dpst.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/pistols.wav");

if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_e5.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "E-5"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "Baktoid Armor Workshop"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["e5"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5_blaster.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 1, -3.8), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["e5"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5_blaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1.3, 3), angle = Angle(-11.723, 0, 180), size = Vector(1.15, 1.15, 1.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(10, 0, -3)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 45
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 400
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 200

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 25

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("weapons/e5_fire.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_e5s.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "E-5s"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Separatist Sniper rifle"
SWEP.Manufacturer           = "Baktoid Armor"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_t21.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV					= 55

SWEP.VMPos = Vector(1.943, -2.814, -0.585)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_t21_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["e5s"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5s_blaster.mdl", bone = "v_t21_reference001", rel = "", pos = Vector(0.85, 1, -2.1), angle = Angle(0, -90, 0), size = Vector(1.4, 1.4, 1.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_t21_reference001", rel = "e5s", pos = Vector(13.4, 0, 10.25), angle = Angle(0, 180, 0), size = Vector(0.25, 0.25, 0.25), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["e5s"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5s_blaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2), angle = Angle(-8, 0, 180), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(10, 0, -3)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 1 },
	[2] = { offset = { 0, 0 }, atts = { "swrp_snp_silencer" }, order = 2 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"
SWEP.ImpactEffect 					= "rw_sw_impact_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 10
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 20

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto",
	"Single",
}

SWEP.DefaultFireMode = "Single"

-- Automatic RPM
SWEP.Primary.RPM					= 400
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 150

hook.Add("TFA_GetStat", "E5s.Override", function(self, stat, finalReturn)
	if self:GetClass() == "weapon_swrp_e5s" then
		if stat == "Primary.Damage" then
			if self:GetFireMode() == 1 then
				local relativeModifier = finalReturn / 150

				return 25 * relativeModifier
			else
				local relativeModifier = finalReturn / 150

				return 150 * relativeModifier
			end
		end

		if stat == "Primary.IronAccuracy" then
			if self:GetFireMode() == 1 then
				return 0.004
			else
				return 0
			end
		end

		if stat == "Primary.AmmoConsumption" then
			if self:GetFireMode() == 1 then
				return 2
			else
				return 20
			end
		end
	end
end)

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_red"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {0.95,0.95}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.02
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-3.5, -21, 0.98)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 1.5)
SWEP.RunSightsAng = Vector(-22, 32.50, -19)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/e5s.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_red.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end

-- Recoil
SWEP.Primary.KickUp             = 0.3

DEFINE_BASECLASS( SWEP.Base )
--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SH         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_fusioncutter_base"

SWEP.PrintName 				= "Fusion Cutter"
SWEP.Category 				= "SW:RP (Support)"
SWEP.Author 				= "Deltaa"
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= ""
SWEP.Purpose 				= "Werkzeug zum Reparieren von Objekten"

SWEP.Spawnable				= true
SWEP.AdminOnly				= false

SWEP.HoldType 				= "slam"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 1

SWEP.Modes = {
	["vehicleMode"] = true,
	["systemEnt"] = true,
	["emplacement"] = true,
	["mines"] = true,
	["repairkit"] = true
}



--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter_base/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | CL         --
---------------------------------------

include("shared.lua")

function SWEP:PrimaryAttack()
	return
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
	if self:GetNextPrimaryFire() >= CurTime() then return end
	self:SetNextPrimaryFire(CurTime() + 1)

	local trace = self:GetOwner():GetEyeTrace()
	local mode = self:GetMode()

	if mode == "false" then
		Fusioncutter:SelectMode()
		return
	end

	if not IsValid(trace.Entity) then
		Fusioncutter:SelectMode()
		return
	end

	if Fusioncutter.Modes[mode].canUse(self, trace.Entity) == false then
		Fusioncutter:SelectMode()
	end
end

function SWEP:DrawHUD()
	local mode = self:GetMode()
	local trace = self:GetOwner():GetEyeTrace()

	draw.RoundedBox(0, ScrW() - (ScrW() * 0.12), ScrH() * 0.8, ScrW() * 0.12, math.ceil(ScrH() * 0.03), GetColor("darkgray", 200))
	draw.SimpleText(Fusioncutter.Modes[mode] and Fusioncutter.Modes[mode].displayName or "Kein Modus", "EGMText10", ScrW() * 0.89, ScrH() * 0.815, GetColor("yellow"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

	local target = trace.Entity
	if not target then return end

	hook.Run("Fusioncutter.DrawInfo", mode, target)
end

--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter_vehicle/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SH         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_fusioncutter_base"

SWEP.PrintName 				= "Fusion Cutter (Fahrzeug)"
SWEP.Category 				= "SW:RP (Support)"
SWEP.Author 				= "Deltaa"
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= ""
SWEP.Purpose 				= "Werkzeug zum Reparieren von Objekten"

SWEP.Spawnable				= true
SWEP.AdminOnly				= false

SWEP.HoldType 				= "slam"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 1

SWEP.Modes = {
	["vehicleMode"] = true,
}



--gamemodes/starwarsrp/entities/weapons/weapon_swrp_hiddenbladeswt/shared.lua:
--code by Blizzard -> rework this!

SWEP.DefaultHoldType = "normal"
SWEP.ViewModelFOV = 56
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ShowViewModel = true
SWEP.UseHands = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["knife thing"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "strap", pos = Vector(-2.122, 0, 2.977), angle = Angle(0, 0, 0), size = Vector(0.086, 0.156, 0.495), color = Color(123, 123, 123, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["strap"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(3.969, 0, 0.079), angle = Angle(-90, 0, 0), size = Vector(0.193, 0.193, 0.009), color = Color(85, 85, 85, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "knife thing", pos = Vector(-0.247, 0, 4.623), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.791), color = Color(255, 255, 255, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["strap+"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(9.324, 0, 0.483), angle = Angle(-90, 0, 0), size = Vector(0.172, 0.172, 0.009), color = Color(85, 85, 85, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} }
}

--SWEP.WElements = {
--	["blade"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.642, 1.562, 1), angle = Angle(-99.703, -8.254, 0), size = Vector(0.5, 0.5, 0.791), color = Color(255, 255, 255, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} }
--}

SWEP.Purpose = "Linksklick: Normaler Stich,\n Rechtsklick: ausgewählte Art von hinten,\n Reload: Wechsel zwischen den Arten"
SWEP.AutoSwitchTo = true
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Author = "Airfox / Konsti"
SWEP.FiresUnderwater = true
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.Instructions = ""
SWEP.AutoSwitchFrom = false
SWEP.base = "weapon_base"
SWEP.Category = "SW:RP (Sonstiges)"
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.PrintName = "Hidden Blade SWT"

SWEP.Primary.Delay			= 0.4
SWEP.Primary.Recoil			= 0
SWEP.Primary.Damage			= 75
SWEP.Primary.NumShots		= 1
SWEP.Primary.Cone			= 0
SWEP.Primary.ClipSize		= 0
SWEP.Primary.DefaultClip	= 0
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "none"

SWEP.StunTime 				= 90
SWEP.Mode 					= "Stun"
if SERVER then
	SWTHiddenBlade = true
end

function SWEP:PrimaryAttack()
	if self:GetOwner():GetNW2Bool("CamoEnabled", false) then return end

	-- Automatically disable cloakingdevice on attack
	if SERVER then
		if self.Owner:IsCloaked() then 
			self.Owner:Cloak(self.Owner:GetCloakId(), false)
		end
	end

	self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.7)

	local trace = self.Owner:GetEyeTrace()

	self:SetHoldType("knife")
	timer.Simple(0.1, function()
		if !IsValid(self) then return end

		self:SetHoldType(self.DefaultHoldType)
	end)

	if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 100 then
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = self.Owner:GetShootPos()
		bullet.Dir    = self.Owner:GetAimVector()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 2
		bullet.Damage = 75
		bullet.Callback = function(attacker, tr, dmgInfo)
			dmgInfo:SetDamageType(DMG_SLASH)
		end
			self.Owner:FireBullets(bullet)
			self.Owner:SetAnimation( PLAYER_ATTACK1 );
			self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
			self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)
	else
		self.Weapon:EmitSound("thehiddenblademiss1.wav", 25, 100, 0.75)
		self.Weapon:EmitSound("thehiddenblademiss2.wav", 25, 100, 0.75)
		self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
	end
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )

	return true
end

function SWEP:SecondaryAttack()
	if self:GetOwner():GetNW2Bool("CamoEnabled", false) then return end

	-- Automatically disable cloakingdevice on attack
	if SERVER then
		if self.Owner:IsCloaked() then 
			self.Owner:Cloak(self.Owner:GetCloakId(), false)
		end
	end

	self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
	self.Weapon:SetNextSecondaryFire(CurTime() + 5)

	local tracedata = { }
	local ShootPos = self.Owner:GetShootPos()
	local AimVector = self.Owner:GetAimVector()
	tracedata.start = ShootPos
	tracedata.endpos = ShootPos + AimVector*45
	tracedata.filter = self.Owner
	local trace = util.TraceLine(tracedata)

	if IsValid(trace.Entity) and SERVER then

		if !trace.Entity:IsWorld() then

			if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 75 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.55 then

				if self.Mode == "Kill" then

					if trace.Entity:IsPlayer() then

						local dmg = DamageInfo()
						dmg:SetDamage(1000000)
						dmg:SetAttacker(self.Owner)
						dmg:SetInflictor(self)
						dmg:SetDamageType(DMG_SLASH)
						trace.Entity:TakeDamageInfo(dmg)

						self.Owner:SetAnimation(PLAYER_ATTACK1)
						self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
						self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)

					elseif trace.Entity:IsNPC() then

						trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
						self.Owner:AddFrags(1)
						self.Owner:SetAnimation(PLAYER_ATTACK1)
						self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
						self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)
					end
				elseif self.Mode == "Stun" then
					if trace.Entity:IsPlayer() then

						local target = trace.Entity

						local dmg = DamageInfo()
						dmg:SetDamage(0)
						dmg:SetAttacker(self.Owner)
						dmg:SetInflictor(self)
						dmg:SetDamageType(DMG_SLASH + 1)
						target:TakeDamageInfo(dmg)

						DeathSystem:Stun(target, self.StunTime)

						self.Owner:SetAnimation( PLAYER_ATTACK1 )
						self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
						self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)

					elseif trace.Entity:IsNPC() then

						local target = trace.Entity

						trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
						self.Owner:AddFrags(1)
						self.Owner:SetAnimation( PLAYER_ATTACK1 )
						self.Weapon:EmitSound("thehiddenbladehit1.wav")--, 25, 100, 0.75)
						self.Weapon:EmitSound("thehiddenbladehit2.wav")--, 25, 100, 0.75)
					end
				end
			end
		end
	end
end

function SWEP:Reload()
	if not timer.Exists("SWTHiddenBladeReload"..self.Owner:SteamID64()) then
		timer.Create("SWTHiddenBladeReload"..self.Owner:SteamID64(), 0.75, 1, function() end)

		if self.Mode == "Stun" then
			self.Mode = "Kill"
		elseif self.Mode == "Kill" then
			self.Mode = "Stun"
		end
	end
end

function SWEP:Initialize()

	-- other initialize code goes here
	self:SetHoldType( self.DefaultHoldType )

	if CLIENT then

		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels

		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)

				--[[-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end]]--
			end
		end
	end
end
function SWEP:Holster()

	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self.Mode = "Stun"
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()

		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end

		if (!self.VElements) then return end

		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then

			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end

		end

		for k, name in ipairs( self.vRenderOrder ) do

			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end

			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (!v.bone) then continue end

			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )

			if (!pos) then continue end

			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end

				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end

			elseif (v.type == "Sprite" and sprite) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

			elseif (v.type == "Quad" and v.draw_func) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end

		end

	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()

		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (!self.WElements) then return end

		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end

		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for k, name in pairs( self.wRenderOrder ) do

			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end

			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if (!pos) then continue end

			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end

				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end

			elseif (v.type == "Sprite" and sprite) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

			elseif (v.type == "Quad" and v.draw_func) then

				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end

		end

	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )

		local bone, pos, ang
		if (tab.rel and tab.rel != "") then

			local v = basetab[tab.rel]

			if (!v) then return end

			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )

			if (!pos) then return end

			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

		else

			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end

			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			if (IsValid(self.Owner) and self.Owner:IsPlayer() and
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end

		end

		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then

				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end

			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite)
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then

				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)

			end
		end

	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)

		if self.ViewModelBoneMods then

			if (!vm:GetBoneCount()) then return end

			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end

				loopthrough = allbones
			end
			-- !! ----------- !! --

			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end

				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms
				-- !! ----------- !! --

				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end

	end

	function SWEP:ResetBonePositions(vm)

		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end

	end

	function table.FullCopy( tab )
		if (!tab) then return end

		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		return res
	end
end

function SWEP:DrawHUD()

	-- No crosshair when Scoped is on
	if ( self.Weapon:GetNetworkedBool( "Scoped" ) ) then return end

	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	local scale = 2 * self.Primary.Cone

	-- Scale the size of the crosshair according to how long ago we fired our weapon
	local LastShootTime = self.Weapon:GetNetworkedFloat( "LastShootTime", 0 )
	scale = scale * (2 - math.Clamp( (CurTime() - LastShootTime) * 5, 0.0, 1.0 ))

	surface.SetDrawColor( 255, 255, 255, 255 )

	-- Draw an awesome crosshair
	local gap = 40 * scale
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )

	draw.RoundedBox(0, 0, ScrH() * 0.90, ScrW() * 0.13, ScrH() * 0.03, GetColor("darkgray", 200))
	draw.SimpleText("Mode: "..self.Mode, "EGMText12", ScrW() * 0.06, ScrH() * 0.9, GetColor("yellow"), TEXT_ALIGN_CENTER)

end

SWEP.Primary.Cone = 0.2
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_meditation/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Meditieren
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Ein SWEP für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Meditieren\nRechtsklick zum Aufstehen"

SWEP.Category = "SW:RP (Sonstiges)"

SWEP.PrintName = "Meditieren"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.Primary.ClipSize       = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic      = false
SWEP.Primary.Ammo           = "none"

SWEP.Secondary.ClipSize     = -1
SWEP.Secondary.DefaultClip  = -1
SWEP.Secondary.Automatic    = false
SWEP.Secondary.Ammo         = "none"

SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = false

local function stopMeditating(ply)
	if CLIENT or !IsValid(ply) then return end
	if ply:GetNWBool("meditating", false) then
		local max = ply:OBBMaxs()
		local min = ply:OBBMins()

		ply:SetViewOffset(Vector(0, 0, max.z - min.z))
		ply:SetMoveType(MOVETYPE_WALK)
		ply:SetNWBool("meditating", false)
	end
end

if SERVER then
	hook.Add("PlayerSwitchWeapon", "meditation_block_switch", function(ply, o, n)
		if ply:GetNWBool("meditating", false) then
			return true
		end
	end)

	hook.Add("PlayerDeath", "meditation", stopMeditating)
	hook.Add("PlayerDisconnected", "meditation", stopMeditating)
	hook.Add("PlayerSpawn", "meditation", stopMeditating)
end

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Reload()
	return
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	local owner = self:GetOwner()
	if !owner:OnGround() then return end
	if owner:GetNWBool("meditating", false) then return end
	if owner:GetMoveType() ~= MOVETYPE_WALK then return end

	owner:SetLocalVelocity(Vector(0, 0, 0))
	owner:SetViewOffset(Vector(0, 0, 40))
	owner:SetMoveType(MOVETYPE_NONE)
	owner:SetNWBool("meditating", true)
end

function SWEP:SecondaryAttack()
	if CLIENT then return end

	local owner = self:GetOwner()
	stopMeditating(owner)
end

function SWEP:Deploy()
	local owner = self:GetOwner()
	owner:DrawViewModel(false)
end

function SWEP:OnDrop()
	local owner = self:GetOwner()
	stopMeditating(owner)
end

hook.Add("CalcMainActivity", "meditation", function(ply)
	if ply:GetNWBool("meditating", false) then
		return ply:SetSequence(ply:LookupSequence("sit_zen"))
	end
end)
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad_fc/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: FC Datapad
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Datapad (Navy)"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.Primary.Automatic = false
SWEP.AllowIronSightsDoF = false
SWEP.Scoped = false

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = { 
		type = "Model", 
		model = "models/weapons/w_datapad.mdl", 
		bone = "ValveBiped.Bip01_R_Hand", 
		rel = "", 
		pos = Vector(1, 4, 1), 
		angle = Angle(-160, -160, -45), 
		size = Vector(1.2, 1.2, 1.2), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.Info = {}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/pad")
end

function SWEP:PrimaryAttack()
	if CLIENT and IsFirstTimePredicted() then
		surface.PlaySound(UI.ButtonSound)
		FCMenu:Open()
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end
function SWEP:IronSights()
end
function SWEP:DrawHUDAmmo()
	return false
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_scattershotgun.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Scatter Shotgun"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_dlt19.mdl"
SWEP.WorldModel						= "models/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV					= 70

SWEP.VMPos = Vector(0.9, -2, -4)
SWEP.VMAng = Vector(0,0,-25)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 1), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["sg"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/bf1/scattergun.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 4, -3.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["sg"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/bf1/scattergun.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8, 1, 0.75), angle = Angle(-11, 0, 180), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(9, 0, -2.5)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_purple"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 120
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 12
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 12

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 60

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 700

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 12
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 10
SWEP.ScopeReticule_Scale 			= {2.5,2.5}

SWEP.Primary.Spread					= 0.15
SWEP.Primary.IronAccuracy 			= 0.05

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.5, 0, 6.5)
SWEP.IronSightsAng = Vector(0, 0, 25)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-22, 35, 3)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, 0)
SWEP.InspectAng = Vector(11.199, 38, 25)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/scatter.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_wrist_blaster.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Wristblaster"
SWEP.Category               = "SW:RP (Sonstiges)"
SWEP.Type					= "Blaster"
SWEP.Manufacturer           = "various"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88,0,0)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.55

SWEP.UseHands 						= false

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["b2"] = { type = "Model", model = "models/cs574/weapons/b2_hand.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["base"] = { type = "Model", model = "models/cs574/weapons/arc_leftwrist.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "", pos = Vector(1.5, -0.25, 3.1), angle = Angle(0, 0, 175), size = Vector(1.05, 1.05, 1.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster"] = { type = "Model", model = "models/sw_battlefront/weapons/2019/a280cfe_defaultbarrel.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "base", pos = Vector(-17.2, -0.25, 04.15), angle = Angle(-03.5, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster2"] = { type = "Model", model = "models/sw_battlefront/weapons/mods/blurrg_cycler_default.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "blaster", pos = Vector(17.75, 0.72, -8.15), angle = Angle(0, 90, -8), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 50
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 340

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 1000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 23

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/e5_fire.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_wrist_rocket.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Wristblaster Rocket"
SWEP.Category               = "SW:RP (Sonstiges)"
SWEP.Type					= "Blaster"
SWEP.Manufacturer           = "various"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --
SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= false

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["b2"] = { type = "Model", model = "models/cs574/weapons/b2_hand.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["base"] = { type = "Model", model = "models/cs574/weapons/arc_leftwrist.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "", pos = Vector(-0.5, -0.25, 3.1), angle = Angle(0, 0, 175), size = Vector(1.05, 1.05, 1.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster"] = { type = "Model", model = "models/sw_battlefront/weapons/2019/a280cfe_defaultbarrel.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "base", pos = Vector(-17.2, -0.25, 04.15), angle = Angle(-03.5, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster2"] = { type = "Model", model = "models/sw_battlefront/weapons/mods/blurrg_cycler_default.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "blaster", pos = Vector(15.175, 0.7175, -9.631), angle = Angle(0, 90, -8), size = Vector(1.55, 1.55, 1.55), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"
SWEP.ImpactDecal 					= "FadingScorch"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 1
-- Magazine Count
SWEP.Primary.DefaultClip			= 1
-- Ammo Type
SWEP.Primary.Ammo					= "XBowBolt"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 95

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 32000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 250

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 3

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

SWEP.IronRecoilMultiplier			= 0.44
SWEP.CrouchRecoilMultiplier			= 0.33
SWEP.JumpRecoilMultiplier			= 1.3
SWEP.WallRecoilMultiplier			= 1.1
SWEP.ChangeStateRecoilMultiplier	= 1.18
SWEP.CrouchAccuracyMultiplier		= 0.7
SWEP.ChangeStateAccuracyMultiplier	= 1
SWEP.JumpAccuracyMultiplier			= 2.6
SWEP.WalkAccuracyMultiplier			= 1.18
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 1100

SWEP.ProjectileEntity 				= "ent_rw_rocket"
SWEP.ProjectileModel 				= nil

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/launcher.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/reload_fast.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_z3.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Z-3"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(5, -20, -6.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "crossbow"
SWEP.ReloadHoldTypeOverride 		= "crossbow"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["z6"] = { type = "Model", model = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, 0, 1), angle = Angle(0, -90, 0), size = Vector(1.2, 1.1, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["z6"] = { type = "Model", model = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, 1), angle = Angle(-6, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(20, 0, 4)
SWEP.HolsterAngle = Angle(0, 180, 180)

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 350
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic"
}

-- Automatic RPM
SWEP.Primary.RPM					= 1000
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= nil

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 13

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.01
SWEP.Primary.IronAccuracy 			= 0.01

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -6, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/z6_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("weapons/sw_noammo.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_z6.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Z-6"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(5, -20, -6.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "crossbow"
SWEP.ReloadHoldTypeOverride 		= "crossbow"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["z6"] = { type = "Model", model = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, 0, 1), angle = Angle(0, -90, 0), size = Vector(1.2, 1.1, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["z6"] = { type = "Model", model = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, 1), angle = Angle(-6, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(20, 0, 4)
SWEP.HolsterAngle = Angle(0, 180, 180)

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 350
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic"
}

-- Automatic RPM
SWEP.Primary.RPM					= 1000
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= nil

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Damage fall off

SWEP.Primary.RangeFalloff           = .18

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 20

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0125

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(0, -6, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/z6_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("weapons/sw_noammo.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/wos-grandmaster-einf/lua/weapons/wos_alcs_duelplacer/cl_init.lua:
include( "shared.lua" )

SWEP.DrawAmmo			= true
SWEP.DrawCrosshair		= true
SWEP.CSMuzzleFlashes	= true

SWEP.ViewModelFOV		= 74
SWEP.ViewModelFlip		= false

SWEP.PrintName = "wiltOS Duel Dome Placer"
SWEP.Slot = 5
SWEP.Slotpos = 5


function SWEP:DrawHUD()

	draw.SimpleText( "PRIMARY FIRE: Place Duel Dome ( Center )        SECONDARY FIRE: Select Nearest Duel Dome          RELOAD: Delete Nearest Duel Dome		USE: Open Configuration Menu", "Trebuchet24", ScrW() * 0.5, ScrH() - 200, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
	
	local text = "NO DOME SELECTED"
	if self:GetSelected() != NULL then
		text = "SELECTED: " .. self:GetSelected():GetTitle() .. "		|		RADIUS: " .. self:GetSelected():GetRadius()
	end
	draw.SimpleText( text, "Trebuchet24", ScrW() * 0.5, ScrH() - 170, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		

end

function SWEP:Deploy()

	self.Weapon:SendWeaponAnim( ACT_VM_DRAW )

	return true
	
end  

function SWEP:ShootEffects()	
	
	self.Owner:MuzzleFlash()								
	self.Owner:SetAnimation( PLAYER_ATTACK1 )	
	
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK ) 
	
end

function SWEP:PrimaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 1 )
	self.Weapon:EmitSound( self.Primary.Sound, 100, math.random(95,105) )
	self.Weapon:ShootEffects()
	
end

function SWEP:SecondaryAttack()

	self.Weapon:EmitSound( self.Primary.Swap )	
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
end
--addons/wos-alcs-custom/lua/weapons/wos_poolitemplacer/shared.lua:
if SERVER then
	AddCSLuaFile( "shared.lua" )

	SWEP.Weight				= 1
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then
	ClientItemPlacerTbl = {}
	ClientItemPlacerTbl[ "teh" ] = {}

	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.CSMuzzleFlashes	= true

	SWEP.ViewModelFOV		= 74
	SWEP.ViewModelFlip		= false

	SWEP.PrintName = "Item Placement Tool"
	SWEP.Slot = 5
	SWEP.Slotpos = 5

	function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	end
end

SWEP.HoldType = "pistol"

SWEP.ViewModel	= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.UseHands = true

SWEP.Primary.Swap           = Sound( "weapons/clipempty_rifle.wav" )
SWEP.Primary.Sound			= Sound( "NPC_CombineCamera.Click" )
SWEP.Primary.Delete1		= Sound( "Weapon_StunStick.Melee_Hit" )
SWEP.Primary.Delete			= Sound( "Weapon_StunStick.Melee_HitWorld" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.AmmoType = "Knife"

SWEP.ItemTypes = { "info_wos_itemspawn", }

SWEP.ServersideItems = { "info_wos_itemspawn" }

SWEP.SharedItems = { "info_wos_itemspawn" }

if SERVER then
	util.AddNetworkString( "ItemPlacerSynch" )
	util.AddNetworkString( "CategorySynch" )
end

local SpawnedCategories = {}
function SWEP:Initialize()
	if SERVER then
		self:SetWeaponHoldType( self.HoldType )
	end

	for i = 1, 9 do
		SpawnedCategories[i] = 1
	end
end

function SWEP:Synch()
	for k,v in pairs( self.ServersideItems ) do
		local ents = ents.FindByClass( v )
		local postbl = {}

		for c,d in pairs( ents ) do
			table.insert( postbl, d:GetPos() )
		end

		net.Start( "ItemPlacerSynch" )
		net.WriteString(v)
		net.WriteTable(postbl)
		net.Send(self:GetOwner())
	end

end

if CLIENT then
	function SWEP:DrawHUD()

		draw.SimpleText( "PRIMARY FIRE: Place Item          SECONDARY FIRE: Change Item Type          +USE: Delete Nearest Item Of Current Type          RELOAD: Remove All Of Current Item Type", "Trebuchet24", ScrW() * 0.5, ScrH() - 120, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( "CURRENT ITEM TYPE: " .. self.ItemTypes[ self.Weapon:GetNW2Int( "ItemType", 1 ) ], "Trebuchet24", ScrW() * 0.5, ScrH() - 100, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		for k, v in pairs( ClientItemPlacerTbl ) do
			for c, d in pairs( v ) do
				local pos = d:ToScreen()
				if pos.visible then
					draw.SimpleText( "info_wos_itemspawn", "Trebuchet24", pos.x, pos.y - 15, Color(80,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					draw.RoundedBox( 0, pos.x - 2, pos.y - 2, 4, 4, Color(255,255,255) )
				end
			end
		end
	end
end


net.Receive( "ItemPlacerSynch", function( len )
	ClientItemPlacerTbl[ net.ReadString() ] = net.ReadTable()
end )

net.Receive( "CategorySynch", function( len )
	SpawnedCategories = net.ReadTable()
end )

function SWEP:Deploy()
	if SERVER then
		self:Synch()
	end

	self:SendWeaponAnim( ACT_VM_DRAW )

	return true
end 

function SWEP:Think()
	if CLIENT then return end

	if self:GetOwner():KeyDown( IN_USE ) and ( ( self.NextDel or 0 ) < CurTime() ) then
		self.NextDel = CurTime() + 1

		local tr = util.TraceLine( util.GetPlayerTrace( self:GetOwner() ) )

		local closest
		local dist = 1000

		for k,v in pairs( ents.FindByClass( self.ItemTypes[ self.Weapon:GetNW2Int( "ItemType", 1 ) ] ) ) do
			if v:GetPos():Distance( tr.HitPos ) < dist then
				dist = v:GetPos():Distance( tr.HitPos )
				closest = v
			end
		end

		if IsValid( closest ) then
			closest:Remove()

			self:GetOwner():EmitSound( self.Primary.Delete1 )

			self:Synch()
		end
	end
end

function SWEP:Reload()
	if CLIENT then return end

	for k,v in pairs( ents.FindByClass( self.ItemTypes[self:GetNW2Int( "ItemType", 1 )] ) ) do
		v:Remove()
	end

	self:Synch()

	self:GetOwner():EmitSound( self.Primary.Delete )
end

function SWEP:Holster()
	return true
end

function SWEP:ShootEffects()
	self:GetOwner():MuzzleFlash()
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
end

function SWEP:PlaceItem()
	local itemtype = self.ItemTypes[ self:GetNW2Int( "ItemType", 1 ) ]
	local tr = util.TraceLine( util.GetPlayerTrace( self:GetOwner() ) )

	local ent = ents.Create( itemtype )
	ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
	ent:Spawn()
	ent.AdminPlaced = true

	local WriteCategories = {}
	for slot, val in pairs( SpawnedCategories ) do
		WriteCategories[ slot ] = ( val == 1 )
	end

	ent.SpawnCategories = table.Copy( WriteCategories )

end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + 1 )
	self:EmitSound( self.Primary.Sound, 100, math.random(95,105) )
	self:ShootEffects()

	if SERVER then
		self:PlaceItem()
		self:Synch()
	end
end

SWEP.CategoryNames = { "Crystals", "Igniters", "Idlers", "Vortex Regulators", "Hilts", "Misc 1", "Misc 2", "Blueprints", "Raw Materials" }

local Options
function SWEP:SecondaryAttack()
	if CLIENT then
		if IsValid( Options ) then return end
		gui.EnableScreenClicker( true )
		Options = vgui.Create( "DFrame" )
		Options:SetSize( ScrW()*0.2, ScrH()*0.2 )
		Options:SetTitle( "Allowed Items" )
		Options:Center()

		local omenu = vgui.Create( "DScrollPanel", Options )
		omenu:SetSize( ScrW()*0.2, ScrH()*0.2*0.95 )
		omenu:SetPos( 0, ScrH()*0.05*0.2 )
		omenu.Paint = nil

		local posx, posy = ScrW() * 0.2 * 0.05, ScrH() * 0.2 * 0.13
		local offsety = ScrH() * 0.2 * 0.005
		for i = 1, 9 do
			local l = vgui.Create( "DCheckBox", omenu )
			l:SetSize( 16, 16 )
			l:SetPos( posx + ScrW() * 0.2 * 0.8, posy )
			l:SetColor( color_black )
			l.ID = i
			l:SetChecked( SpawnedCategories[ l.ID ] == 1 )
			l.OnChange = function( pan, val )
				if val then
					SpawnedCategories[pan.ID] = 1
				else
					SpawnedCategories[pan.ID] = 0
				end
			end

			local l2 = vgui.Create( "DLabel", omenu )
			l2:SetPos( posx, posy )
			l2:SetColor( color_white )
			l2:SetText( self.CategoryNames[ i ] )
			l2:SizeToContents()

			posy = posy + 16 + offsety
		end

		Options.OnClose = function( pan )
			net.Start( "CategorySynch" )
				net.WriteTable( SpawnedCategories )
			net.SendToServer()
			gui.EnableScreenClicker( false )
			Options = nil
		end
	end
end

--addons/map_control/lua/entities/alarm/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Mapcontrol             --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mapcontrol | SH           --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Deltaa"

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Alarmsteuerung"
ENT.Category = "CW:RP Systementites"
ENT.IsSystem = true

ENT.NextUse = 0

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end

function ENT:GetState()
	if self:Health() >= self:GetMaxHealth() * 0.5 then
		return "Online", GetColor("green")
	elseif self:Health() > 0 then
		return "Beschädigt", GetColor("yellow")
	else
		return "Offline", GetColor("red")
	end
end

--addons/bkeypads/lua/entities/bkeypads_fading_door/shared.lua:
AddCSLuaFile()

ENT.Type = "point"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Fading Door (Billy's Keypads)"
ENT.Author = "Billy"

ENT.Spawnable = false

ENT.RenderGroup = RENDERGROUP_OTHER

function ENT:Initialize()
	self:SetTransmitWithParent(true)

	self:DrawShadow(false)
	self:SetRenderMode(RENDERMODE_NONE)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetSolid(SOLID_NONE)

	if CLIENT and IsValid(self:GetFadeEnt()) then
		self:FadeEntChanged(nil, nil, self:GetFadeEnt())
		bKeypads.ESP:Refresh()
	end
end

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "FadeEnt")

	self:NetworkVar("Bool", 0, "Toggle")
	self:NetworkVar("Bool", 1, "Reversed")

	self:NetworkVar("String", 0, "FadeMaterial")
	self:NetworkVar("String", 1, "OpenSound")
	self:NetworkVar("String", 2, "ActiveSound")
	self:NetworkVar("String", 3, "CloseSound")

	self:NetworkVar("Int", 0, "KeyboardButton")

	if CLIENT then
		self:NetworkVarNotify("FadeEnt", self.FadeEntChanged)
	else
		self:NetworkVarNotify("KeyboardButton", self.KeyboardButtonChanged)
	end
	self:NetworkVarNotify("Toggle", self.RebuildConfig)
	self:NetworkVarNotify("Reversed", self.RebuildConfig)
	self:NetworkVarNotify("FadeMaterial", self.RebuildConfig)
	self:NetworkVarNotify("OpenSound", self.RebuildConfig)
	self:NetworkVarNotify("ActiveSound", self.RebuildConfig)
	self:NetworkVarNotify("CloseSound", self.RebuildConfig)
end

if CLIENT then
	function ENT:FadeEntChanged(_, __, FadeEnt)
		self:ParentTo(FadeEnt)
		bKeypads.ESP:Refresh()
	end
else
	function ENT:RemoveKeyBinds()
		if self.BindUp then
			numpad.Remove(self.BindUp)
			self.BindUp = nil
		end
		if self.BindDown then
			numpad.Remove(self.BindDown)
			self.BindDown = nil
		end
	end

	function ENT:AddKeyBinds(key)
		local ply = self:GetCreator()
		if IsValid(ply) then
			self.BindUp = numpad.OnUp(ply, key, "bKeypads.FadingDoor.Up", self)
			self.BindDown = numpad.OnDown(ply, key, "bKeypads.FadingDoor.Down", self)
		end
	end

	function ENT:KeyboardButtonChanged(_, oldKey, newKey)
		self:RebuildConfig("KeyboardButton", oldKey, newKey)

		if oldKey == newKey then return end
		self:RemoveKeyBinds()
		if newKey > 0 then
			self:AddKeyBinds(newKey)
		end
	end

	local function BtnDown(ply, controller)
		if not IsValid(controller) then return end
		local ent = controller:GetFadeEnt()
		if not IsValid(ent) or not bKeypads.FadingDoors:IsFadingDoor(ent) then return end

		if not controller.m_bBindPressed and bKeypads.Config.FadingDoors.EnableKeyboardPress and bKeypads.Permissions:Check(ply, "fading_doors/keyboard") then
			controller.m_bBindPressed = true
			if controller:GetToggle() then
				ent:fadeToggleActive()
			elseif controller:GetReversed() then
				ent:fadeDeactivate()
			else
				ent:fadeActivate()
			end
		end
	end

	local function BtnUp(ply, controller)
		if not IsValid(controller) then return end
		local ent = controller:GetFadeEnt()
		if not IsValid(ent) or not bKeypads.FadingDoors:IsFadingDoor(ent) then return end

		if controller.m_bBindPressed then
			controller.m_bBindPressed = nil
			if not controller:GetToggle() then
				if controller:GetReversed() then
					ent:fadeActivate()
				else
					ent:fadeDeactivate()
				end
			end
		end
	end

	numpad.Register("bKeypads.FadingDoor.Down", BtnDown)
	numpad.Register("bKeypads.FadingDoor.Up", BtnUp)
end

do
	local fadeBroadcast, fadeActivate, fadeDeactivate, fadeToggleActive
	if SERVER then
		function fadeBroadcast(self)
			net.Start("bKeypads.FadingDoors.Fade")
				net.WriteEntity(self)
				net.WriteBool(self.fadeActive)
			net.Broadcast()
		end

		function fadeActivate(self)
			self.fadeActive = true
			fadeBroadcast(self)
			bKeypads.FadingDoors:DoFade(self)
		end

		function fadeDeactivate(self)
			self.fadeActive = false
			fadeBroadcast(self)
			bKeypads.FadingDoors:DoFade(self)
		end

		function fadeToggleActive(self)
			self.fadeActive = not self.fadeActive
			fadeBroadcast(self)
			bKeypads.FadingDoors:DoFade(self)
		end

		function fadeCancel(self)
			self.fadeActive = self.fadeReversed
			fadeBroadcast(self)
			bKeypads.FadingDoors:DoFade(self)
		end
	end

	function ENT:ParentTo(ent)
		ent.bKeypads_FadingDoor = self

		self:SetParent(ent)

		ent.isFadingDoor = true
		ent.fadeActive = false
		if SERVER then
			self:SetFadeEnt(ent)

			ent:DeleteOnRemove(self)
			
			ent.fadeDeactivate = fadeDeactivate
			ent.fadeActivate = fadeActivate
			ent.fadeToggle = fadeToggle
			ent.fadeToggleActive = fadeToggleActive
			ent.fadeCancel = fadeCancel

			self.StuckTickTimer = "bKeypads.FadingDoors.StuckTick:" .. self:GetCreationID()
		else
			bKeypads.ESP:Refresh()
		end

		self:RebuildConfig()

		bKeypads_FadingDoors_Registry[ent] = self
	end
end

function ENT:SaveRestoreData()
	local ent = self:GetFadeEnt()
	if not IsValid(ent) then return end

	self.m_FadingDoorData.Restore = {
		Material = ent:GetMaterial(),
		DrawShadow = not ent:IsEffectActive(EF_NOSHADOW),
		Solid = ent:GetSolid(),
		SolidFlags = ent:GetSolidFlags(),
		CollisionGroup = ent:GetCollisionGroup()
	}

	local phys = ent:GetPhysicsObject()
	if IsValid(phys) then
		self.m_FadingDoorData.Restore.Moveable = phys:IsMoveable()
	end
end

function ENT:GetRestoreData()
	return self.m_FadingDoorData.Restore
end

function ENT:Restore()
	if self.m_FadingDoorData.Restore then
		local ent = self:GetFadeEnt()
		if not IsValid(ent) then return end

		ent:SetMaterial(self.m_FadingDoorData.Restore.Material)

		ent:DrawShadow(self.m_FadingDoorData.Restore.DrawShadow)
		if CLIENT then ent:MarkShadowAsDirty() end
		
		ent:SetSolid(self.m_FadingDoorData.Restore.Solid)
		ent:SetSolidFlags(self.m_FadingDoorData.Restore.SolidFlags)
		ent:SetCollisionGroup(self.m_FadingDoorData.Restore.CollisionGroup)

		if self.m_FadingDoorData.Restore.Moveable then
			local phys = ent:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableMotion(self.m_FadingDoorData.Restore.Moveable)
				phys:Wake()
			end
		end

		self.m_FadingDoorData.Restore = nil
	end
end

function ENT:RebuildConfig(varName, _, newVal)
	if not self.m_FadingDoorData then
		self.m_FadingDoorData = {}
	end

	if not self.m_FadingDoorData.Config then
		if not IsValid(self:GetFadeEnt()) then return end
		self.m_FadingDoorData.Config = {}
	end

	if varName then
		self.m_FadingDoorData.Config[varName] = newVal
	else
		self.m_FadingDoorData.Config.Player = self:GetPlayer()
		self.m_FadingDoorData.Config.Toggle = self:GetToggle()
		self.m_FadingDoorData.Config.Reversed = self:GetReversed()
		self.m_FadingDoorData.Config.FadeMaterial = self:GetFadeMaterial()
		self.m_FadingDoorData.Config.OpenSound = self:GetOpenSound()
		self.m_FadingDoorData.Config.ActiveSound = self:GetActiveSound()
		self.m_FadingDoorData.Config.CloseSound = self:GetCloseSound()
		self.m_FadingDoorData.Config.KeyboardButton = self:GetKeyboardButton()
	end

	self:GetFadeEnt().fadeToggle = self:GetToggle()
	self:GetFadeEnt().fadeReversed = self:GetReversed()

	if SERVER then
		duplicator.StoreEntityModifier(self:GetFadeEnt(), "bKeypads.FadingDoor", self.m_FadingDoorData.Config)
	end

	return self.m_FadingDoorData.Config
end

function ENT:GetConfig()
	return self.m_FadingDoorData.Config or self:RebuildConfig()
end

do
	local function CleanParent(ent)
		if not IsValid(ent) then return end

		ent.bKeypads_FadingDoor = nil

		if ent.FadeDoorSound then
			ent.FadeDoorSound:Stop()
			ent.FadeDoorSound = nil
		end

		ent.isFadingDoor = nil
		ent.fadeActive = nil
		if SERVER then
			ent.fadeDeactivate = nil
			ent.fadeActivate = nil
			ent.fadeToggle = nil
			ent.fadeToggleActive = nil

			duplicator.ClearEntityModifier(ent, "bKeypads.FadingDoor")
		end
	end

	if SERVER then
		function ENT:OnRemove()
			self:RemoveKeyBinds()

			self:Restore()
			CleanParent(self:GetFadeEnt())
			timer.Remove(self.StuckTickTimer)

			bKeypads_FadingDoors_Registry[self] = nil
		end
	else
		function ENT:OnRemove()
			bKeypads.ESP:Refresh()

			local ent = self:GetFadeEnt()
			if not IsValid(ent) then return end

			bKeypads:nextTick(function()
				if not IsValid(self) then
					CleanParent(ent)
					bKeypads_FadingDoors_Registry[self] = nil
				end
			end)
		end
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/bkeypads/lua/entities/bkeypads_networkvarpostnotify/shared.lua:
AddCSLuaFile()

ENT.Base = "base_gmodentity"

ENT.Spawnable = false

local function NetworkVarNotifyCallback(self, name, oldVal, newVal)
	if newVal == nil then
		bKeypads:print("NetworkVar " .. tostring(name) .. " tried to set itself to nil...? Please let Billy know", bKeypads.PRINT_TYPE_WARN, "WARNING")
		debug.Trace()
		return
	end
	self.dt[name] = newVal
	self._dt_callbacks[name](self, name, oldVal, newVal)
end
function ENT:NetworkVarPostNotify(name, func)
	self._dt_callbacks = self._dt_callbacks or {}
	self._dt_callbacks[name] = func

	self:NetworkVarNotify(name, NetworkVarNotifyCallback)
end
--addons/bkeypads_cracker/lua/entities/bkeypads_popped_keypad/cl_init.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

function ENT:Initialize()
	self.bKeypadOff = true
	self:SetModel(bKeypads.MODEL.KEYPAD)
	self:SetBodygroup(bKeypads.BODYGROUP.KEYPAD, 1)
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
end

function ENT:RenderOverride(flags)
	self:DrawModel()
	self:RenderCable(flags)
end

function ENT:Think()
	local deployedCracker = self.m_eDeployedCracker
	if not IsValid(deployedCracker) then return end
	if not IsValid(deployedCracker.m_eCrackingKeypad) then
		self:Remove()
		return
	end
	
	if deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CRACKING or
	   deployedCracker.m_iAnimationStage == deployedCracker.ANIM.OPEN_PANEL or
	   deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CLOSE_PANEL then
		self:AnimatePanelSwing()
	elseif  deployedCracker.m_iAnimationStage == deployedCracker.ANIM.POP_IN_PANEL then
		self:AnimatePanelPopIn()
	end
end

function ENT:AnimatePanelSwing()
	local deployedCracker = self.m_eDeployedCracker
	
	local animDuration = deployedCracker.AnimationStages[
		deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CRACKING and deployedCracker.ANIM.OPEN_PANEL or
		deployedCracker.ANIM.CLOSE_PANEL
	].Duration
	
	local f = math.Clamp(math.TimeFraction(deployedCracker.m_fAnimationStart, deployedCracker.m_fAnimationStart + animDuration, CurTime()), 0, 1)

	if self.m_iSwingAnimation ~= deployedCracker.m_iAnimationStage then
		self.m_fSwingAngleStart = self.m_fSwingAngle or 0
		self.m_iSwingAnimation = deployedCracker.m_iAnimationStage
	end
	if deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CRACKING then
		f = bKeypads.ease.OutBack(f)
		self.m_fSwingAngle = bKeypads:LerpUnclamped(f, self.m_fSwingAngleStart, -100)
	elseif deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CLOSE_PANEL then
		f = bKeypads.ease.OutCubic(f)
		self.m_fSwingAngle = Lerp(f, self.m_fSwingAngleStart, 0)
	else
		return
	end

	local ang = deployedCracker.m_eCrackingKeypad:GetAngles()
	ang:RotateAroundAxis(ang:Right(), self.m_fSwingAngle)
	self:SetAngles(ang)

	local pivot = self:OBBMins() * .95
	pivot.y = self:OBBCenter().y

	local pos = deployedCracker.m_eCrackingKeypad:LocalToWorld(pivot)
	pivot:Rotate(ang)
	pos = pos - pivot
	
	if deployedCracker.m_iAnimationStage == deployedCracker.ANIM.CLOSE_PANEL then
		pos = pos + (self:GetForward() * f)
	end

	self:SetPos(pos)
end

function ENT:AnimatePanelPopIn()
	local deployedCracker = self.m_eDeployedCracker
	
	self.m_aPopInAng = self.m_aPopInAng or self:GetAngles()
	self.m_vPopInPos = self.m_vPopInPos or self:GetPos()

	local popInAnimFrac = bKeypads.ease.OutQuint(math.Clamp(math.TimeFraction(deployedCracker.m_fAnimationStart + deployedCracker.AnimationStages[deployedCracker.ANIM.POP_IN_PANEL].Delay, deployedCracker.m_fAnimationStart + deployedCracker.AnimationStages[deployedCracker.ANIM.POP_IN_PANEL].Duration, CurTime()), 0, 1))
	self:SetPos(LerpVector(popInAnimFrac, self.m_vPopInPos, deployedCracker.m_eCrackingKeypad:GetPos()))
	self:SetAngles(LerpAngle(popInAnimFrac, self.m_aPopInAng, deployedCracker.m_eCrackingKeypad:GetAngles()))
end

bKeypads_Initialize_Fix(ENT)
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/entities/bs_hshield_senat/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Heavy shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/entities/bs_hshield_st/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/entities/bs_shield/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end  
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/entities/bs_shield_st/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

function ENT:Use(activator)
	if IsValid(activator) && activator:IsPlayer() && self.Owner == activator then
		activator:Give("deployable_shield_st")
		activator:EmitSound("npc/combine_soldier/gear2.wav")

		table.RemoveByValue(activator.bs_shields, self)

		self:Remove()
	end
end
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--lua/entities/chemlight_gib1/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Gib1"
ENT.Author			= "Patrick Hunt"
ENT.Information		= ""
ENT.Category		= "Fun + Games"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false


--lua/entities/dc17m_at_rocket2/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--lua/entities/ent_chemlight_for_attachment/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self.Entity:DrawModel()
end


function ENT:Think()

 
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = rgba.g * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = rgba.b * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 1000
		dlight.DieTime = CurTime() + 0.05 --+ GetGlobalFloat( "global_Cheml_Lifetime", 25 ) --0.05


	end
end
--lua/entities/ent_chemlight_glow/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r
		dlight.g = rgba.g
		dlight.b = rgba.b
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_green/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Green"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_glow_red/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Red"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_inf/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight (Inf)"
ENT.Author			= "Patrick Hunt"
ENT.Information		= ""
ENT.Category		= "Fun + Games"
ENT.Spawnable		= true
ENT.AdminSpawnable	= true
ENT.AdminOnly		= true


--lua/entities/ent_chemlight_rgb.lua:
AddCSLuaFile()
ENT.Base					= "base_gmodentity"
ENT.Type					= "anim"
ENT.PrintName				= "Chemlight (RGB)"
ENT.Category				= "Fun + Games"
ENT.AdminOnly				= true
ENT.Spawnable				= true
ENT.AutomaticFrameAdvance	= true

		local rgbr = 255
		local rgbg = 0
		local rgbb = 0
		
		
		
ENT.Mod = "models/glowstick/chemstick.mdl"								-- "models/Gibs/HGIBS.mdl" Моделька.
ENT.Mat = ""									-- "" Материал. Можно оставить пустым.
ENT.Col = Color(rgbr,rgbg,rgbb)									-- Color(255,255,255) Цвет.
if CLIENT then

function ENT:Draw()
self:DrawModel()
end


end


function ENT:SpawnFunction( ply, tr, class )
		local tr,trace = {},{}
		tr.start = ply:GetShootPos()
		tr.endpos = tr.start + ply:GetAimVector() * 22500
		tr.filter = ply
		tr.mask = MASK_WATER + MASK_SOLID
		trace = util.TraceLine( tr )
		local SpawnPos = trace.HitPos + trace.HitNormal * 1
		ent = ents.Create( class )
		ent:SetPos( SpawnPos )
		ent.Owner = ply 
		ent:SetAngles( ply:GetAngles() )
		ent:Spawn()
		ent:Activate()
		return ent
	end


function ENT:Initialize()

	if SERVER then
		self.Entity:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		if GetGlobalBool( "global_Cheml_oldmodel" ) then 
		self:SetModel(self.Mod or "models/glowstick/stick_antic.mdl")
		else
		self:SetModel(self.Mod or "models/glowstick/stick.mdl")
		end
		--self:SetModel(self.Mod or "models/glowstick/stick.mdl")
		self:SetMaterial(self.Mat or "")
		self:SetColor(self.Col or Color(rgbr,rgbg,rgbb))
		
		self:PhysicsInit(SOLID_VPHYSICS )
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
		
		local phys = self:GetPhysicsObject()
		
		
		if (phys:IsValid()) then
			phys:Wake()
		end
		
	end
	
	self:SetPlaybackRate(1)
end

function ENT:Think()



if  rgbg == 0 and rgbb == 0 then rgbr = 255 end
if  rgbr >= 255 and rgbg == 0 then rgbb = rgbb + 0.5 end
if  rgbb >= 255 then rgbr = rgbr - 0.5 end
if  rgbr <= 0 and rgbb >= 255 then rgbg = rgbg + 0.5 end
if  rgbg >= 255 and rgbr <= 0 then rgbb = rgbb - 0.5 end
if  rgbb <= 0 and rgbg == 255 then rgbr = rgbr + 0.5 end
if  rgbr >= 255 and rgbb <= 0 then rgbg = rgbg - 0.5 end

if rgbr <= 0 then rgbr = 0 end if rgbg <= 0 then rgbg = 0 end if rgbb <= 0 then rgbb = 0 end
if rgbr >= 255 then rgbr = 255 end if rgbg >= 255 then rgbg = 255 end if rgbb >= 255 then rgbb = 255 end

if CLIENT then
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgbr
		dlight.g = rgbg
		dlight.b = rgbb
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end

self:SetColor(Color(rgbr,rgbg,rgbb))
end
--lua/entities/gmod_contr_spawner/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--lua/entities/gmod_contr_spawner/shared.lua:
ENT.Type 			= "anim"
ENT.Base			= WireLib and "base_wire_entity" or "base_gmodentity"
ENT.PrintName		= "Contraption Spawner"
ENT.Author			= "TB"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--addons/system_entities/lua/entities/gravgen/cl_init.lua:
include( "shared.lua" )

surface.CreateFont( "BlahBlah2", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
	shadow = true,
	outline = false
} )

function ENT:Draw()
	self:DrawModel()

	--[[local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90]]--
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		
		plyAng = self:GetAngles()
		ang = Angle(plyAng.x, plyAng.y, plyAng.z)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 26, ang, .08)
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 66, 135, 245, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Gravitationsmodul", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -70, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			if self:Health() > self.GenHealth / 2 then
				draw.DrawText( "online", "BlahBlah2", 39, - 295, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			if (self:Health() <= self.GenHealth / 2 && self:Health() > 0) then
				draw.DrawText( "kritisch", "BlahBlah2", 42, - 295, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
			end

			if self:Health() == 0 then
				draw.DrawText( "offline", "BlahBlah2", 39, - 295, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			end

		cam.End3D2D()
	end
end

--addons/hbombs_base/lua/entities/hb_base_radiation_ent.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      
          
function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.RadRadius = self:GetVar("Rad_Radius")
		 if self.RadRadius==nil then
			self.RadRadius=500
		 end
		 if self.Burst==nil then
			self.Burst=10
		 end
     end
end

function ENT:Think()
	
	if (SERVER) then
	if !self:IsValid() then return end
	local pos = self:GetPos()
	for k, v in pairs(ents.FindInSphere(pos,self.RadRadius)) do
		if v:IsPlayer() and !v:IsNPC() and v.hazsuited==false then
			local dist = (self:GetPos() - v:GetPos()):Length()
			local relation = math.Clamp((self.RadRadius - dist) / self.RadRadius, 0, 1)
			local dmg = DamageInfo()
			dmg:SetDamage(10*relation)
			dmg:SetDamageType(DMG_RADIATION)
			if self.HBOWNER==nil or !self.HBOWNER:IsValid() then
				self.HBOWNER=table.Random(player.GetAll())
			end
			dmg:SetAttacker(self.HBOWNER)
			v:EmitSound("player/geiger2.wav", 100, 100)
			v:TakeDamageInfo(dmg)
		end
	end
	self.Bursts = self.Bursts + 1
	if (self.Bursts >= self.Burst) then
		self:Remove()
	end
	self:NextThink(CurTime() + math.random(1,2))
	return true
	end
end

function ENT:Draw()
     return true
end
--addons/hbombs_base/lua/entities/hb_emp_entity.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.Spawnable		            	 =  false        
ENT.AdminSpawnable		             =  false

ENT.PrintName		                 =  "EMP Device"
ENT.Author			                 =  "natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "Garry's Bombs 5"

ENT.Model                            =  "models/thedoctor/emp_bomb.mdl"                      
ENT.Effect                           =  "emp_main"                  
ENT.EffectAir                        =  "emp_main"                   
ENT.EffectWater                      =  "water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/special/emp.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  25
ENT.PhysForce                        =  5
ENT.ExplosionRadius                  =  5
ENT.SpecialRadius                    =  1250
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0
ENT.Shocktime                        = 0.1
ENT.HBOWNER                          =  nil            

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE )
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,30000)) do
		 if v:IsValid() then
			 if(v.isWacAircraft) && (v.active==true) then
				v:setEngine(false)
				v.engineDead = true							 
				ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,v,0) 
			 end
			if v:GetClass()=="prop_vehicle_jeep" or v:GetClass()=="prop_vehicle_airboat" then 
				v:EmitSound("ambient/machines/spindown.wav")
				local ent = ents.Create("hb_emp_v_dead")
				ent:SetPos(v:GetPos() ) 
				ent:Spawn()
				ent:Activate()
				ent.radowner = v
				ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,v,0) 
				timer.Simple(math.random(), function()
					local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
					ent:EmitSound(sound)
				end)
			 end
			 if(GetConVar("hb_safeemp"):GetInt() >= 1) then
				 if math.random(1,10)==10 then
					 if(table.HasValue(emp_whiteragdolllist,v:GetClass())) then
					 local ent = ents.Create("prop_ragdoll")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end		
					 
					 if v:GetClass()=="npc_grenade_frag" then
						 local ent = ents.Create("prop_physics")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 	
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end		
					 
					 if(table.HasValue(emp_whitelist,v:GetClass())) then
						 local ent = ents.Create("prop_physics")
						 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
						 local old_angle = v:GetAngles( )
						 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
						 ent:SetModel(v:GetModel())
						 ent:Spawn()
						 ent:Activate()
						 ent:SetVar("HBOWNER",ply)
						 ent:SetColor(Color(65,65,65,255))
						 ent:Ignite(5,0)
						 ent:SetAngles(old_angle)
						 for _, Prop in pairs (old_ent_constrains) do
							constraint.Weld( ent, Prop, 0, 0, 0, true, false )	
						 end
						 v:Remove()
						 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
						 timer.Simple(math.random(), function()
							local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
							ent:EmitSound(sound)
						 end)
						 timer.Simple(math.random(4,5)+math.random(), function()
							if !ent:IsValid() then return end
							ent:Remove()
						 end)
					 end
				end
			else
				if(table.HasValue(emp_whiteragdolllist,v:GetClass())) then
					 local ent = ents.Create("prop_ragdoll")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end		
				 
				 if v:GetClass()=="npc_grenade_frag" then
					 local ent = ents.Create("prop_physics")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 	
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end		
				 
				 if(table.HasValue(emp_whitelist,v:GetClass())) then
					 local ent = ents.Create("prop_physics")
					 local old_ent_constrains = constraint.GetAllConstrainedEntities( v )
					 local old_angle = v:GetAngles( )
					 ent:SetPos( v:LocalToWorld(self:OBBCenter()) ) 
					 ent:SetModel(v:GetModel())
					 ent:Spawn()
					 ent:Activate()
					 ent:SetVar("HBOWNER",ply)
					 ent:SetColor(Color(65,65,65,255))
					 ent:Ignite(5,0)
					 ent:SetAngles(old_angle)
					 for _, Prop in pairs (old_ent_constrains) do
						constraint.Weld( ent, Prop, 0, 0, 0, true, false )	
					 end
					 v:Remove()
					 ParticleEffectAttach("emp_electrify_model",PATTACH_POINT_FOLLOW,ent,0) 
					 timer.Simple(math.random(), function()
						local sound = string.Explode(" ",table.Random(emp_soundlist))[1]
						ent:EmitSound(sound)
					 end)
					 timer.Simple(math.random(4,5)+math.random(), function()
						if !ent:IsValid() then return end
						ent:Remove()
					 end)
				 end
			end
		 end
	 end 
	 
	self:Remove()
	end
end

--addons/hbombs/lua/entities/hb_main_fab.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

local ExploSnds = {}
ExploSnds[1]                         =  "ambient/explosions/explode_1.wav"
ExploSnds[2]                         =  "ambient/explosions/explode_2.wav"
ExploSnds[3]                         =  "ambient/explosions/explode_3.wav"
ExploSnds[4]                         =  "ambient/explosions/explode_4.wav"
ExploSnds[5]                         =  "ambient/explosions/explode_5.wav"
ExploSnds[6]                         =  "npc/env_headcrabcanister/explosion.wav"

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "Fuel Air Bomb"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/military2/bomb/bomb_kab.mdl"                      
ENT.Effect                           =  "h_fab"                  
ENT.EffectAir                        =  "h_fab_air"                   
ENT.EffectWater                      =  "h_water_small"
ENT.ExplosionSound                   =  "gbombs_5/explosions/heavy_bomb/ex2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  900
ENT.PhysForce                        =  32
ENT.ExplosionRadius                  =  1555
ENT.SpecialRadius                    =  575
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  20                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  350
ENT.Mass                             =  890
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.Shocktime                        = 4
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "scorch_big_2"

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

function ENT:Explode()
	 if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local owner = self.HBOWNER
   	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 50)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 50)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE", 500)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal

	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)		 
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/fab/fab_initial.wav")
	 ent:SetVar("Shocktime", 3)	 
	 
	 timer.Simple(0.25, function()
			 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 200)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 100)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 150)
		 ent:SetVar("HBOWNER", owner)
		 ent:SetVar("MAX_RANGE", 3000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",150)		 
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/fab/fab_explo.wav")
		 ent:SetVar("Shocktime", 3)
	 end)
	 
	 
	 for k, v in pairs(ents.FindInSphere(pos,2000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end


	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs/lua/entities/hb_main_implosionbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly                        =  true

ENT.PrintName						 =  "Implosion Bomb"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/thedoctor/mutagenbomb.mdl"                      
ENT.Effect                           =  "h_implosion"                  
ENT.EffectAir                        =  "h_implosion"                   
ENT.EffectWater                      =  "h_implosion"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1000
ENT.Mass                             =  1000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"



function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())

	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",50000)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/special/implosionbomb_1.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
	 timer.Simple(6, function ()
	 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 750)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 200)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",20000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",70)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
	 end)
	 
	 timer.Simple(19.5, function()
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",5000)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/special/liquid_tiberium.mp3") 

		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 750)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 200)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 1)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",10000)
		ent:SetVar("SHOCKWAVE_INCREMENT",100)
		ent:SetVar("DELAY",0.01)
		ent.trace=self.TraceLength
		ent.decal=self.Decal		
	 end)
	 
	 self.Exploding = true
	 self:StopParticles()
	 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 36 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_main_moab.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "MOAB"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/chappi/moab.mdl"                      
ENT.Effect                           =  "h_moab"                  
ENT.EffectAir                        =  "h_moab_airburst"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ExplosionSound                   =  "hbombs/moab.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  5500
ENT.PhysForce                        =  3500
ENT.ExplosionRadius                  =  9000
ENT.SpecialRadius                    =  3500
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  20                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  400
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  3000
ENT.ArmDelay                         =  2   
ENT.Timer                            =  0

ENT.Shocktime                        = 4
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decals                           = "nuke_medium"

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,90,0)

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 32 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

function ENT:Explode()
	if !self.Exploded then return end
	local pos = self:LocalToWorld(self:OBBCenter())

	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	ent:SetVar("SHOCKWAVE_INCREMENT",150)
	ent:SetVar("DELAY",0.01)
	ent.trace=self.TraceLength
	ent.decal=self.Decal

	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",150)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", self.ExplosionSound)
	ent:SetVar("Shocktime", self.Shocktime)
	
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs_base/lua/entities/hb_main_sodacan.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true     
ENT.AdminSpawnable		             =  true 

ENT.AdminOnly 						 =  true

ENT.PrintName		                 =  "A Simple Soda Can"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/props_junk/PopCan01a.mdl"                      
ENT.Effect                           =  "hnuke1"                  
ENT.EffectAir                        =  "hnuke1_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/tsar_detonate.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  90000
ENT.SpecialRadius                    =  85000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1300
ENT.Mass                             =  50000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_tsar"
function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(data.Speed > 200) then
		if math.random(1,2)==1 then
			self:EmitSound("gbombs_5/arm/tsarland.wav", 80, math.random(90,110))
		else
			self:EmitSound("gbombs_5/arm/tsarland2.wav", 80, math.random(90,110))
		end
	 end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then

	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",90000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("DEFAULT_PHYSFORCE", 955)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 15)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 155)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 30
		ent.RadRadius=75000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 30
		ent.RadRadius=75000
	 end			 

	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",75000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_detonate.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",75000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true	 
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",75000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() && v:Alive() then
			    v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
	     if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 self:StopParticles()
     end)
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

		     local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
		         ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		    
			 end
		 else
		     local tracedata    = {}
	         tracedata.start    = pos
		     tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		     tracedata.filter   = self.Entity
				
		     local trace = util.TraceLine(tracedata)
	     
		     if trace.HitWorld then
		         ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			     timer.Simple(2, function()
			         if !self:IsValid() then return end 
			         ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				     self:Remove()
             end)	
		     else 
			     ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 --Here we do an emp check
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		     end
		 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_mortar_cache.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Mortar Cache"
ENT.Author			                 =  "Chappi"
ENT.Contact			                 =  "chappi555@gmail.com"
ENT.Category                         =  "HBOMBS Misc"
ENT.Type                             =  "anim"
ENT.Model                            =  "models/models/gb4/mortar_cache.mdl"
ENT.Mass                             =  100
ENT.AutomaticFrameAdvance = true

ENT.Effect                           =  "bomb_explosion"                  
ENT.EffectAir                        =  "bomb_explosion_air"  

ENT.GBOWNER                          =  nil             -- don't you fucking touch this.

local ExploSnds = {}
ExploSnds[1]                         =  "ambient/explosions/explode_1.wav"
ExploSnds[2]                         =  "ambient/explosions/explode_2.wav"
ExploSnds[3]                         =  "ambient/explosions/explode_3.wav"
ExploSnds[4]                         =  "ambient/explosions/explode_4.wav"
ExploSnds[5]                         =  "ambient/explosions/explode_5.wav"
ExploSnds[6]                         =  "npc/env_headcrabcanister/explosion.wav"

if (SERVER) then util.AddNetworkString( "mortar_cache" ) end
function ENT:Initialize()

	if (SERVER) then
		self:LoadModel()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetUseType( ONOFF_USE ) 
		
		local phys = self:GetPhysicsObject()
		local skincount = self:SkinCount()
		
		if (phys:IsValid()) then
			phys:SetMass(self.Mass)
			phys:Wake()
		end

		self.Armed    = false
		self.Exploded = false
		self.Used     = false
		self.Arming   = false
		self.OldCount = 0
		self.Life     = 100
		self.BarrelCount = 0
	
		self.RequestTime   = CurTime()
		self.RequestTime2  = CurTime()
		self.Mortar        = nil
		self.AmmoList      = {}

		
	


	end
end


function ENT:ExploSound(pos)
	 local ent = ents.Create("gb4_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("GBOWNER", self.GBOWNER)
	 ent:SetVar("MAX_RANGE",500000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",20000)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", table.Random(ExploSnds))
	 ent:SetVar("Shocktime",1)
end


function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.GBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 32 ) 
     ent:Spawn()
     ent:Activate()
     return ent
end

function ENT:FilterMortars()
	local mortars = {}
	for k, v in pairs(ents.FindInSphere(self:GetPos(), 500)) do
		if (v.HBOWNER!=nil or v.GBOWNER!=nil and v.ClassName != self.ClassName and v:GetMoveType() != "MOVETYPE_NONE" ) or (v:GetClass() == "prop_physics" and v:GetModel() == "models/props_c17/oildrum001_explosive.mdl" )then	
			table.insert(mortars, v)
		end
	end
	return mortars
end

function ENT:HasMortarCountChanged()
	local nm = self:FilterMortars()
	nm = #nm
	
	if self.OldCount == nm then 

	else
		if nm > 0 && self.OldCount==0 then 
			self.OldCount = nm
			self:ResetSequence( self:LookupSequence( "open" ))
			self:SetPlaybackRate( 2 )
			self:EmitSound("open.wav", 70, 100)
			
			timer.Simple(self:SequenceDuration(), function()
				if !self:IsValid() then return end
				
				self.IsOpen=true
			end)			
		elseif nm < 1 && self.OldCount>=1 then
			self.OldCount = nm
			self:EmitSound("close.wav", 70, 100)
			self:ResetSequence( self:LookupSequence( "close" ))
			self:SetPlaybackRate( 2 )
			timer.Simple(self:SequenceDuration(), function()
				if !self:IsValid() then return end
				self.IsOpen=false
			end)

		end
		
	end
	
			
end

function ENT:CanLaunch2()
	if (self.RequestTime2+(math.random(250,270)/1000)) < CurTime()then
		self.RequestTime2=CurTime()
		return true
	else	
		return false
	end
end


function ENT:TakeAmmo()
	
	if self.IsOpen == true then
		for k, v in pairs(self:FilterMortars()) do
			
			if v:GetPos():Distance(self:GetPos()) < 80 && v.Armed!=true then 
				self:EmitSound("items/ammopickup.wav", 80, 100)
				if self.AmmoList[v:GetClass()] == nil then 
					self.AmmoList[v:GetClass()] = 1 
					self:SetNWInt(v:GetClass(), self.AmmoList[v:GetClass()])

				else
				
					self.AmmoList[v:GetClass()] = self.AmmoList[v:GetClass()] + 1 
					self:SetNWInt(v:GetClass(), self.AmmoList[v:GetClass()])
				end
				v:Remove()
			end
		end
	end
end

function ENT:ReconfigureWeight()
	local sum = 0
	for k, v in pairs(self.AmmoList) do
		sum = sum + 1
	end
	
	self:GetPhysicsObject():SetMass(250 + (sum * -100))
end




net.Receive( "mortar_cache", function( len, ply )
	local tbl = net.ReadTable()
	local entity = net.ReadEntity()
	if entity:IsValid()==false then return end
	local function tableToString(tbl)
		local ammo_count = "Ammo left\n"
		for k, v in pairs(tbl) do
			ent = k
			num = v
			ammo_count = ammo_count..ent..": "..num.."\n"
			
		end
		return ammo_count
		
	end
	
	if LocalPlayer():EyePos():Distance( entity:GetPos() ) < 156  then
		AddWorldTip( entity:EntIndex(), ( tableToString(tbl) ), 0.5, entity:GetPos(), entity  )
	end
end )


function ENT:Think()
	if (SERVER) then
		if !self:IsValid() then return end
		self:HasMortarCountChanged()
		self:TakeAmmo()
		self:ReconfigureWeight()


		net.Start( "mortar_cache" )
			net.WriteTable(self.AmmoList)
			net.WriteEntity(self)
		net.Broadcast()


		self:NextThink(CurTime()) 
		
		return true
	end
end


function ENT:CanLaunch()
	if (self.RequestTime+1) < CurTime()then
		self.RequestTime=CurTime()
		return true
	else	
		return false
	end
end

function ENT:TriggerInput(iname, value)	 
end 

function ENT:LoadModel()
     if self.UseRandomModels then
	     self:SetModel(table.Random(Models))
	 else
	     self:SetModel(self.Model)
	 end
end
	 

function ENT:Explode()
	if (CLIENT) then return end
	if !self.Exploded then return end
	local pos = self:GetPos()
    
	 
	self:EmitSound("phx/explode02.wav", 100, 100)

	for class, total in pairs(self.AmmoList) do
		for i=0, total do
			if class == "prop_physics" then
				local ang = math.random(0,628)/100
				local radius = math.random(100,200)
				local pos = Vector(math.cos(ang), math.sin(ang), math.sin(ang))*radius + self:GetPos()
				local ent = ents.Create(class)
				ent:SetPos(self:GetPos() + Vector(math.random(-180,180),math.random(-180,180),math.random(-180,180)))
				ent:SetModel("models/props_c17/oildrum001_explosive.mdl")
				ent:Spawn()
				ent:Activate()
				ent:SetAngles((self:GetPos()-pos):Angle())
				ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
				ent:Ignite(10,0)
				local pos = self:GetPos()
				for i=0, 500 do 
					timer.Simple(i/100, function()
						if ent:IsValid() then 
							ent:GetPhysicsObject():AddVelocity(  Vector(math.random(-180,180),math.random(-180,180),math.random(-180,180)) * 100 )
							
						end
					end)
				end
				local trail = util.SpriteTrail(ent, 0, Color(255,15, 15, 255), false, 15, 1, 8, 1/(15+1)*0.5, "trails/smoke.vmt")			
			else
			
				local ang = math.random(0,628)/100
				local radius = math.random(100,200)
				local pos = Vector(math.cos(ang), math.sin(ang), math.sin(ang))*radius + self:GetPos()
				local ent = ents.Create(class)
				ent:SetPos(self:GetPos() + Vector(math.random(-180,180),math.random(-180,180),math.random(-180,180)))
				ent:Spawn()
				ent:Activate()
				ent:SetAngles((self:GetPos()-pos):Angle())
				ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
				local pos = self:GetPos()

				ent:GetPhysicsObject():SetVelocity((pos-ent:GetPos()):GetNormal() * -math.random(600,600))
	

				ent:Arm()
				local trail = util.SpriteTrail(ent, 0, Color(155,155,155, 50), false, 15, 1, 4, 1/(15+1)*0.5, "trails/smoke.vmt")
			end

		end
	end


    self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
	if (CLIENT) then return end
	if self.Exploded then return end
	self:TakePhysicsDamage(dmginfo)

	local phys = self:GetPhysicsObject()

	if (self.Life <= 0) then return end

	if self:IsValid() then
	self.Life = self.Life - dmginfo:GetDamage()
	if (self.Life <= 0) then 
	if !self:IsValid() then return end 
	self.Exploded = true
	self:Explode()
	end
	end
end

function ENT:PhysicsCollide( data, physobj )
end

function ENT:Arm()
end	 

function ENT:Use( activator, caller )
	if self:CanLaunch() then
		 if !self:IsValid() then return end
		 self:Explode()
	end
end

function ENT:OnRemove()
	if (SERVER) then
		
	end
end


if (CLIENT) then
	function ENT:Draw()
		
		self:DrawModel()

	end

end


function ENT:OnRestore()
     Wire_Restored(self.Entity)
end

function ENT:BuildDupeInfo()
     return WireLib.BuildDupeInfo(self.Entity)
end

function ENT:ApplyDupeInfo(ply, ent, info, GetEntByID)
     WireLib.ApplyDupeInfo( ply, ent, info, GetEntByID )
end

function ENT:PrentityCopy()
     local DupeInfo = self:BuildDupeInfo()
     if(DupeInfo) then
         duplicator.StorentityModifier(self,"WireDupeInfo",DupeInfo)
     end
end

function ENT:PostEntityPaste(Player,Ent,CreatedEntities)
     if(Ent.EntityMods and Ent.EntityMods.WireDupeInfo) then
         Ent:ApplyDupeInfo(Player, Ent, Ent.EntityMods.WireDupeInfo, function(id) return CreatedEntities[id] end)
     end
end
--addons/hbombs/lua/entities/hb_nuclear_grable_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Mk33 [Atomic] - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/atomicshell.mdl"                      
ENT.Effect                           =  "h_nuke_a"                  
ENT.EffectAir                        =  "h_nuke_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  0                              
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end



function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_instant")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_BURSTS", 1)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("DELAY",0.1)
	 ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
	 ent:SetVar("Shocktime",1)
	 
	 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
	 end	
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 100)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",8000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( self:GetPos() ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT", 130)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")

	 
	 
	 
	 
	 
	 
	 
	 
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() and !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 
		 
		 
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
	
		 self:StopParticles()
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_ivymike_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Ivy Mike - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/ivy_mike.mdl"                      
ENT.Effect                           =  "hnuke2_a"                  
ENT.EffectAir                        =  "hnuke2_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio3.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  18000
ENT.SpecialRadius                    =  9000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  18500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_big"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 200)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)	 
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",18000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal

	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",20)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",5)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",40000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
	 end			 
	 local ent = ents.Create("hb_shockwave_rumbling")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",19000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",220)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",210)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 256 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_proj_v2_small.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_rocket_" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "V2 - MRD1022"
ENT.Author							 =  ""
ENT.Contact							 =  ""
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/v2.mdl"
ENT.RocketTrail                      =  "h_v2"
ENT.RocketBurnoutTrail               =  ""
ENT.Effect                           =  "h_rktboom"
ENT.EffectAir                        =  "h_rktboom_air"
ENT.EffectWater                      =  "h_water_huge" 
ENT.ExplosionSound                   =  "gbombs_5/explosions/heavy_bomb/explosion_big_3.mp3"        
ENT.StartSound                       =  "gbombs_5/launch/srb_launch.wav"          
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"    
ENT.EngineSound                      =  "Motor_Small"

ENT.ShouldUnweld                     =  true          
ENT.ShouldIgnite                     =  true         
ENT.UseRandomSounds                  =  false         
ENT.SmartLaunch                      =  false
ENT.Timed                            =  false 

ENT.ExplosionDamage                  =  700
ENT.ExplosionRadius                  =  9000             
ENT.PhysForce                        =  1000             
ENT.SpecialRadius                    =  900            
ENT.MaxIgnitionTime                  =  2           
ENT.Life                             =  35            
ENT.MaxDelay                         =  0           
ENT.TraceLength                      =  600           
ENT.ImpactSpeed                      =  800         
ENT.Mass                             =  10000             
ENT.EnginePower                      =  50          
ENT.FuelBurnoutTime                  =  40           
ENT.IgnitionDelay                    =  2            
ENT.ArmDelay                         =  0.5
ENT.RotationalForce                  =  0                      
ENT.ForceOrientation                 =  "NONE"
ENT.Timer                            =  0
ENT.Shocktime                        = 3
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-350,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)  
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType(MOVETYPE_VPHYSICS)
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end
	 if (skincount > 0) then
		 self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Fired    = false
	 self.Burnt    = false
	 self.Ignition = false
	 self.Arming   = false
	 self.Power    = 0.8
	 if !(WireAddon == nil) then self.Inputs = Wire_CreateInputs(self, { "Arm", "Detonate", "Launch" }) end
	end
end

function ENT:ExploSound(pos)
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",500000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime",4)
end

function ENT:Think()
	 if(self.Burnt) then return end
	 if(!self.Ignition) then return end -- if there wasn't ignition, we won't fly
	 if(self.Exploded) then return end -- if we exploded then what the fuck are we doing here
	 if(!self:IsValid()) then return end -- if we aren't good then something fucked up
	 if self.Power <= 1.5 then
		self.Power = self.Power + 0.01
	 elseif self.Power >=1.5 then
		self.Power = 1.5
	 end
	 local phys = self:GetPhysicsObject()  
	 local thrustpos = self:GetPos()
	 if(self.ForceOrientation == "RIGHT") then
		 phys:AddVelocity(self:GetRight() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "LEFT") then
		 phys:AddVelocity(self:GetRight() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "UP") then
		 phys:AddVelocity(self:GetUp() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "DOWN") then 
		 phys:AddVelocity(self:GetUp() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "INV") then
		 phys:AddVelocity(self:GetForward() * -self.EnginePower) -- Continuous engine impulse
	 else
		 local tickrate = 1 / engine.TickInterval()
		 
		 if tickrate >= 65 and tickrate <=67 then
			phys:AddVelocity(self:GetForward() * (12*self.Power)) -- Continuous engine impulse
		 else
			phys:AddVelocity(self:GetForward() * 2*(12*self.Power)) -- Continuous engine impulse
		 end
	 end
	 if (self.Armed) then
		phys:AddAngleVelocity(Vector(self.RotationalForce,0,0)) -- Rotational force
	 end
	 
	 self:NextThink(CurTime() + 0.01)
	 return true
end

function ENT:Launch()
	 if(self.Exploded) then return end
	 if(self.Burned) then return end
	 --if(self.Armed) then return end
	 if(self.Fired) then return end
	 
	 local phys = self:GetPhysicsObject()
	 if !phys:IsValid() then return end
	 
	 self.Fired = true
	 if(self.SmartLaunch) then
		 constraint.RemoveAll(self)
	 end
	 timer.Simple(0.05,function()
		 if not self:IsValid() then return end
		 if(phys:IsValid()) then
			 phys:Wake()
			 phys:EnableMotion(true)
		 end
	 end)
	 timer.Simple(self.IgnitionDelay,function()
		 if not self:IsValid() then return end  -- Make a short ignition delay!

		 local phys = self:GetPhysicsObject()
		 self.Ignition = true
		 self:Arm()
		 local pos = self:GetPos()
		 sound.Play(self.StartSound, pos, 160, 130,1)
		 self:EmitSound(self.EngineSound)

		 ParticleEffectAttach(self.RocketTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
		 util.ScreenShake( self:GetPos(), 5555, 3555, 10, 500 )
		 util.ScreenShake( self:GetPos(), 5555, 555, 8, 500 )
		 util.ScreenShake( self:GetPos(), 5555, 555, 5, 500 )
		 if(self.FuelBurnoutTime != 0) then 
			 timer.Simple(self.FuelBurnoutTime,function()
				 if not self:IsValid() then return end 
				 self.Burnt = true
				 self:StopParticles()
				 self:StopSound(self.EngineSound)
				 ParticleEffectAttach(self.RocketBurnoutTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
			 end)	 
		 end
	 end)		 
end

function ENT:Explode()
	 if not self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	  	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 250)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",8000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 
	for k, v in pairs(ents.FindInSphere(pos,8000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(5,0)
			end
		 end
	 end
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",5)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",18000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		 if v:IsValid() then
			 --local phys = v:GetPhysicsObject()
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
			 phys = v:GetPhysicsObjectNum(i)	  
			 if (phys:IsValid()) then		
		 		 local mass = phys:GetMass()
				 local F_ang = self.PhysForce
				 local dist = (pos - v:GetPos()):Length()
				 local relation = math.Clamp((self.SpecialRadius - dist) / self.SpecialRadius, 0, 1)
				 local F_dir = (v:GetPos() - pos):GetNormal() * (self.PhysForce or 690)
				   
				 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
				 phys:AddVelocity(F_dir)
			 end
			 i = i + 1
			 end
		 end
	 end

	 timer.Simple (1, function()
	 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT", 130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/heavy_bomb/explosion_big_3.mp3")
		 ent:SetVar("Shocktime", 3)
		 
	  	 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 100)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE", 11000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
	 end)

	 
	 
	 
	 
	 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)   
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 Explosion={}
		 Explosion[1]="h_rktboom"
		 Explosion[2]="h_rktboom"
		 
		 Explosionair={}
		 Explosionair[1]="h_rktboom_air"
		 Explosionair[2]="h_rktboom_air"	
		 
		 if trace.HitWorld then
			 ParticleEffect(table.Random(Explosion),pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(table.Random(Explosionair),pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 46 ) 
	 ent:SetAngles(Angle(-90,0,0))
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_instant.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
ENT.Burst                            = 0 
function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,self.MAX_RANGE)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
			         dmg:SetDamage(math.random(25,100))
			         dmg:SetDamageType(DMG_RADIATION)
			         dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690)
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 phys:Wake()
						 phys:EnableMotion(true)
						 constraint.RemoveAll(v)
					 end
				 end
				 if (v:IsPlayer()) then
					
					 v:SetMoveType( MOVETYPE_WALK )
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 v:SetMoveType( MOVETYPE_WALK )
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsNPC()) then
					 v:TakeDamageInfo(dmg)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= self.Burst) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/heart_turbolaser_tool/lua/entities/heart_turbolaser_spawner/shared.lua:
ENT.Type = "point";
ENT.Base = "base_gmodentity";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;
--addons/egm_lvs_ships/lua/entities/laat_detonator/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/egm_lvs_ships/lua/entities/laat_dioxisbomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--lua/entities/ladder_small3/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

ENT.Type 			= "anim";
ENT.Base 			= "ladder_base";
ENT.PrintName		= "Ladder (Small - Runged)"
ENT.Category		= "Ladders"
ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Model			= Model("models/props/cs_militia/ladderrung.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;
--addons/system_entities/lua/entities/lifesupport/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Lebenserhaltungsmodul"
ENT.Category = "CW:RP Systementites"

ENT.IsSystem = true

ENT.SuppHealth = 2000

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end

--addons/lvs_base/lua/entities/lvs_base/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseEntity"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.Editable = true

ENT.LVS = true

ENT.MDL = "models/props_c17/trappropeller_engine.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 100
ENT.MaxShield = 0

ENT.SpawnNormalOffset = 15
ENT.HitGroundLength = 10

ENT.lvsDisableZoom = true

function ENT:AddDT( type, name, data )
	if not self.DTlist then self.DTlist = {} end

	if self.DTlist[ type ] then
		self.DTlist[ type ] = self.DTlist[ type ] + 1
	else
		self.DTlist[ type ] = 0
	end

	self:NetworkVar( type, self.DTlist[ type ], name, data )
end

function ENT:CreateBaseDT()
	local InitWeaponsSuccess, ErrorMsg = pcall( function() self:InitWeapons() end )

	if not InitWeaponsSuccess then
		ErrorNoHalt( "\n[ERROR] "..ErrorMsg.."\n\n" )
	end

	self:AddDT( "Entity", "Driver" )
	self:AddDT( "Entity", "DriverSeat" )

	self:AddDT( "Bool", "Active" )
	self:AddDT( "Bool", "EngineActive" )
	self:AddDT( "Bool", "AI",	{ KeyName = "aicontrolled",	Edit = { type = "Boolean",	order = 1,	category = "AI"} } )

	local ShowAIGunnerInMenu = false

	if istable( self.WEAPONS ) then
		for id, _ in pairs( self.WEAPONS ) do
			if id == 1 then continue end

			ShowAIGunnerInMenu = true

			break
		end
	end

	if ShowAIGunnerInMenu then
		self:AddDT( "Bool", "AIGunners",	{ KeyName = "aigunners",	Edit = { type = "Boolean",	order = 2,	category = "AI"} } )
	else
		self:AddDT( "Bool", "AIGunners" )
	end

	self:AddDT( "Bool", "lvsLockedStatus" )
	self:AddDT( "Bool", "lvsReady" )
	self:AddDT( "Bool", "NWOverheated" )

	self:AddDT( "Int", "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 3, category = "AI"} } )
	self:AddDT( "Int", "SelectedWeapon" )
	self:AddDT( "Int", "NWAmmo" )

	self:AddDT( "Float", "HP", { KeyName = "health", Edit = { type = "Float", order = 2,min = 0, max = self.MaxHealth, category = "Misc"} } )
	self:AddDT( "Float", "Shield" )
	self:AddDT( "Float", "NWHeat" )

	self:OnSetupDataTables()

	if SERVER then
		self:NetworkVarNotify( "AI", self.OnToggleAI )
		self:NetworkVarNotify( "HP", self.PDSHealthValueChanged )
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )

		self:SetAITEAM( self.AITEAM )
		self:SetHP( self.MaxHealth )
		self:SetShield( self.MaxShield )
		self:SetSelectedWeapon( 1 )
	end
end

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:OnSetupDataTables()
end

function ENT:CalcMainActivity( ply )
end

function ENT:GetPlayerBoneManipulation( ply, PodID )
	return self.PlayerBoneManipulate[ PodID ] or {}
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end

function ENT:StartCommand( ply, cmd )
end

function ENT:HitGround()
	local trace = util.TraceLine( {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.HitGroundLength) ),
		filter = self:GetCrosshairFilterEnts()
	} )
	
	return trace.Hit 
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetMaxShield()
	return self.MaxShield
end

function ENT:GetShieldPercent()
	return self:GetShield() / self:GetMaxShield()
end

function ENT:GetMaxHP()
	return self.MaxHealth
end

function ENT:IsInitialized()
	if not self.GetlvsReady then return false end -- in case this is called BEFORE setupdatatables

	return self:GetlvsReady()
end

function ENT:GetWeaponHandler( num )
	if num == 1 then return self end

	local pod = self:GetPassengerSeat( num )

	if not IsValid( pod ) then return NULL end

	return pod:lvsGetWeapon()
end

function ENT:GetPassengerSeat( num )
	if num == 1 then
		return self:GetDriverSeat()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then continue end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod
			end
		end

		return NULL
	end
end

function ENT:GetPassengerSeats()
	if not self:IsInitialized() then return {} end

	if not istable( self.pSeats ) then
		self.pSeats = {}

		local DriverSeat = self:GetDriverSeat()

		for _, v in pairs( self:GetChildren() ) do
			if v ~= DriverSeat and v:GetClass():lower() == "prop_vehicle_prisoner_pod" then
				table.insert( self.pSeats, v )
			end
		end
	end

	return self.pSeats
end

function ENT:HasActiveSoundEmitters()
	local active = false

	for _, emitter in ipairs( self:GetChildren() ) do
		if emitter:GetClass() ~= "lvs_soundemitter" then continue end

		if not IsValid( emitter ) or not emitter.GetActive or not emitter.GetActiveVisible then continue end

		if emitter:GetActive() and emitter:GetActiveVisible() then
			active = true

			break
		end
	end

	return active
end

function ENT:GetPassenger( num )
	if num == 1 then
		return self:GetDriver()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then
				return NULL
			end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod:GetDriver()
			end
		end

		return NULL
	end
end

function ENT:GetEveryone()
	local plys = {}

	local Pilot = self:GetDriver()
	if IsValid( Pilot ) then
		table.insert( plys, Pilot )
	end

	for _, Pod in pairs( self:GetPassengerSeats() ) do
		if not IsValid( Pod ) then continue end

		local ply = Pod:GetDriver()

		if not IsValid( ply ) then continue end

		table.insert( plys, ply )
	end

	return plys
end

function ENT:GetPodIndex()
	return 1
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

function ENT:GetVehicle()
	return self
end

function ENT:GetVehicleType()
	return "LBaseEntity"
end

function ENT:GetBoneInfo( BoneName )
	local BoneID = self:LookupBone( BoneName )
	local numHitBoxSets = self:GetHitboxSetCount()

	if not BoneID then
		goto SkipLoop
	end

	for hboxset = 0, numHitBoxSets - 1 do
		local numHitBoxes = self:GetHitBoxCount( hboxset )

		for hitbox=0, numHitBoxes - 1 do
			local bone = self:GetHitBoxBone( hitbox, hboxset )
			local name = self:GetBoneName( bone )

			if BoneName ~= name then continue end

			local mins, maxs = self:GetHitBoxBounds( hitbox, hboxset )
			local pos, ang = self:GetBonePosition( BoneID )

			return self:WorldToLocal( pos ), self:WorldToLocalAngles( ang ), mins, maxs
		end
	end

	:: SkipLoop ::

	return vector_origin, angle_zero, vector_origin, vector_origin
end
--addons/lvs_starwars/lua/entities/lvs_base_fakehover/cl_hud.lua:
ENT.IconHealth = Material("lvs/heart.png")
ENT.IconShield = Material("lvs/shield.png")
ENT.IconEngine = Material("lvs/engine.png")

function ENT:LVSHudPaintInfoText(X, Y, W, H, ScrX, ScrY, ply)
	local maxHealth = self:GetMaxHP()
	local health = math.Round((self:GetHP() * 100) / maxHealth)

	surface.SetMaterial(self.IconHealth)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.021, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.02, Y * 1.045, H * 0.5, H * 0.5, 0)

	draw.DrawText(health .. "%", "LVS_FONT_HUD_LARGE", X + 50, Y + 20, color_white, TEXT_ALIGN_LEFT)

	local maxShield = self:GetMaxShield()
	local shield = math.Round((self:GetShield() * 100) / maxShield)

	surface.SetMaterial(self.IconShield)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.126, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.125, Y * 1.045, H * 0.5, H * 0.5, 0)

	if shield >= 0 then
		draw.DrawText(shield .. "%", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	else
		draw.DrawText("0 %", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	end

	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText("km/h ", "LVS_FONT", X + 370, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText(kmh, "LVS_FONT_HUD_LARGE", X + 370, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial(self.IconEngine)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(hX * 1.007, hY * 1.008, H * 0.75, H * 0.75, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(hX * 1.008, hY * 1.008, H * 0.75, H * 0.75, 0)

	if not self:GetEngineActive() then
		draw.SimpleText("X" , "LVS_FONT",  hX * 1.007, hY * 1.008, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		self:LVSDrawCircle(hX * 1.007, hY * 1.008, H * 0.4, self:GetThrottle())
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor(Color(255,255,255,255 * zoom))
	surface.SetMaterial(zoom_mat)
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	self:PaintZoom( X, Y, ply )
end

--addons/lvs_starwars/lua/entities/lvs_base_repulsorlift/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "[LVS] Base Gunship"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ThrustVtol = 30
ENT.ThrustRateVtol = 2

ENT.MaxPitch = 60

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))

	if ply:lvsMouseAim() then
		VtolY = math.Clamp( VtolY + ((ply:lvsKeyDown( "-ROLL_SF" ) and 1 or 0) - (ply:lvsKeyDown( "+ROLL_SF" ) and 1 or 0)), -1 , 1)
	end

	VtolY = VtolY * math.max( 1 - self:GetThrottle() ^ 2, 0 )
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol
	else
		return Vector(0,0,0)
	end
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyLeft then MouseX = -(10 / SensX) * ReturnDelta end
	if KeyRight then MouseX = (10 / SensX) * ReturnDelta end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if ply:lvsMouseAim() then
		if SERVER then
			self:PlayerMouseAim( ply, cmd )
		end
	else
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetVehicleType()
	return "repulsorlift"
end
--addons/lvs_starwars/lua/entities/lvs_base_starfighter/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("sh_camera_eyetrace.lua")
include("cl_hud.lua")
include("cl_flyby.lua")
include("cl_deathsound.lua")

ENT.TrailAlpha = 25

DEFINE_BASECLASS( "lvs_base" )

function ENT:Think()
	BaseClass.Think( self )

	self.EFxScale = self.EFxScale and (self.EFxScale - self.EFxScale * RealFrameTime()) or 0

	self:CalcOnThrottle()
end

function ENT:CalcOnThrottle()
	if not self:GetEngineActive() then 
		self._oldOnTHR = nil

		return
	end

	local Throttle = self:GetThrottle()

	if self._oldOnTHR ~= Throttle then
		if self._oldOnTHR == 0 and Throttle > 0 then
			self._IsAccelerating = true
		end

		if Throttle > (self._oldOnTHR or 0) then
			self._IsAccelerating = true
		else
			self._IsAccelerating = false
		end

		if self._oldOnTHR == 1 then
			self:StopBoost()
		end

		self._oldOnTHR = Throttle
	end

	if self._oldAccelerating ~= self._IsAccelerating then
		self._oldAccelerating = self._IsAccelerating

		if not self._IsAccelerating then return end

		self:StartBoost()
	end
end

function ENT:StartBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self.EFxScale = 100

	self:OnStartBoost()
end

function ENT:StopBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self:OnStopBoost()
end

function ENT:GetBoost()
	return (self.EFxScale or 0)
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end
--addons/lvs_starwars/lua/entities/lvs_base_starfighter/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Base Starfighter"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.ThrottleRateUp = 0.6
ENT.ThrottleRateDown = 0.6

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Bool", "Disabled" )
	self:AddDT( "Vector", "Steer" )
	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Vector", "NWVtolMove" )
	self:AddDT( "Float", "NWThrottle" )
	self:AddDT( "Float", "MaxThrottle" )

	if SERVER then
		self:NetworkVarNotify( "Disabled", self.OnDisabled )

		self:SetMaxThrottle( 1 )
	end
end

function ENT:PlayerDirectInput( ply, cmd )
	local Pod = self:GetDriverSeat()

	local Delta = FrameTime()

	local KeyLeft = ply:lvsKeyDown( "-ROLL_SF" )
	local KeyRight = ply:lvsKeyDown( "+ROLL_SF" )
	local KeyPitchUp = ply:lvsKeyDown( "+PITCH_SF" )
	local KeyPitchDown = ply:lvsKeyDown( "-PITCH_SF" )
	local KeyRollRight = ply:lvsKeyDown( "+YAW_SF" )
	local KeyRollLeft = ply:lvsKeyDown( "-YAW_SF" )

	local MouseX = cmd:GetMouseX()
	local MouseY = cmd:GetMouseY()

	if ply:lvsKeyDown( "FREELOOK" ) and not Pod:GetThirdPersonMode() then
		MouseX = 0
		MouseY = 0
	else
		ply:SetEyeAngles( Angle(0,90,0) )
	end

	local SensX, SensY, ReturnDelta = ply:lvsMouseSensitivity()

	if KeyPitchDown then MouseY = (10 / SensY) * ReturnDelta end
	if KeyPitchUp then MouseY = -(10 / SensY) * ReturnDelta end
	if KeyRollRight or KeyRollLeft then
		local NewX = (KeyRollRight and 10 or 0) - (KeyRollLeft and 10 or 0)

		MouseX = (NewX / SensX) * ReturnDelta
	end

	local Input = Vector( MouseX * 0.4 * SensX, MouseY * SensY, 0 )

	local Cur = self:GetSteer()

	local Rate = Delta * 3 * ReturnDelta

	local New = Vector(Cur.x, Cur.y, 0) - Vector( math.Clamp(Cur.x * Delta * 5 * ReturnDelta,-Rate,Rate), math.Clamp(Cur.y * Delta * 5 * ReturnDelta,-Rate,Rate), 0)

	local Target = New + Input * Delta * 0.8

	local Fx = math.Clamp( Target.x, -1, 1 )
	local Fy = math.Clamp( Target.y, -1, 1 )

	local TargetFz = (KeyLeft and 1 or 0) - (KeyRight and 1 or 0)
	local Fz = Cur.z + math.Clamp(TargetFz - Cur.z,-Rate * 3,Rate * 3)

	local F = Cur + (Vector( Fx, Fy, Fz ) - Cur) * math.min(Delta * 100,1)

	self:SetSteer( F )
end

function ENT:CalcThrottle( ply, cmd )
	if CLIENT then return end

	local Delta = FrameTime()

	local ThrottleUp =  ply:lvsKeyDown( "+THRUST_SF" ) and self.ThrottleRateUp or 0
	local ThrottleDown = ply:lvsKeyDown( "-THRUST_SF" ) and -self.ThrottleRateDown or 0

	local Throttle = (ThrottleUp + ThrottleDown) * Delta

	self:SetThrottle( self:GetThrottle() + Throttle )
end

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = ThrottleZero and (ply:lvsKeyDown( "-VTOL_X_SF" ) and -1 or 0) or 0
	local VtolY = ((ply:lvsKeyDown( "+VTOL_Y_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Y_SF" ) and 1 or 0))
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end

function ENT:SetVtolMove( NewMove )
	if self:GetEngineActive() then
		self:SetNWVtolMove( NewMove )
	else
		self:SetNWVtolMove( Vector(0,0,0) )
	end
end

function ENT:SetThrottle( NewThrottle )
	if self:GetEngineActive() then
		self:SetNWThrottle( math.Clamp(NewThrottle,0,self:GetMaxThrottle()) )
	else
		self:SetNWThrottle( 0 )
	end
end

function ENT:GetThrottle()
	if self:GetEngineActive() then
		return self:GetNWThrottle()
	else
		return 0
	end
end

function ENT:GetVtolMove()
	if self:GetEngineActive() and not self:GetAI() then
		return self:GetNWVtolMove() * self.ThrustVtol * (1 - math.min( self:GetThrottle(), 1 ))
	else
		return Vector(0,0,0)
	end
end

function ENT:StartCommand( ply, cmd )
	if self:GetDriver() ~= ply then return end

	if SERVER then
		local KeyJump = ply:lvsKeyDown( "VSPEC" )

		if self._lvsOldKeyJump ~= KeyJump then
			self._lvsOldKeyJump = KeyJump

			if KeyJump then
				self:ToggleVehicleSpecific()
			end
		end
	end

	if not ply:lvsMouseAim() then
		self:PlayerDirectInput( ply, cmd )
	end

	self:CalcThrottle( ply, cmd )
	self:CalcVtolThrottle( ply, cmd )
end

function ENT:GetThrustStrenght()
	local ForwardVelocity = self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x

	return (self.MaxVelocity * self:GetThrottle() - ForwardVelocity) / self.MaxVelocity
end

function ENT:GetVehicleType()
	return "starfighter"
end

--addons/lvs_starwars/lua/entities/lvs_base_starfighter/cl_deathsound.lua:

function ENT:OnDestroyed()
	if not self.DeathSound then return end

	if self:GetVelocity():Length() <= self.MaxVelocity * 0.5 then return end

	self._sndDeath = CreateSound( self, self.DeathSound )
	self._sndDeath:SetSoundLevel( 125 )
	self._sndDeath:PlayEx( 1, 50 + 50 * self:CalcDoppler( LocalPlayer() ) )
end

function ENT:StopDeathSound()
	if not self._sndDeath then return end

	self._sndDeath:Stop()
end


--addons/lvs_starwars/lua/entities/lvs_concussionmissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_protontorpedo"

ENT.Type            = "anim"

ENT.PrintName = "Concussion Missile"
ENT.Author = "Luna"
ENT.Information = "sprengt dir ein zweites arschloch"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_concussion_explosion"
ENT.GlowColor = Color( 255, 40, 100, 255 )

if SERVER then
	function ENT:GetDamage() return
		self._dmg or 8000
	end

	function ENT:GetRadius()
		return self._radius or 200
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
	effectdata:SetOrigin(self:GetPos())
	effectdata:SetEntity(self)
	util.Effect("lvs_concussion_trail", effectdata)
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aat/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterTurret( pod:lvsGetWeapon() )

	self:InvalidateBoneCache()
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_casus/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Casus Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2354.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1750

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_celeritas/cl_init.lua:
include("shared.lua")

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_czerka/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(3, 79, 209, 254)
ENT.EngineColor2 = Color(157, 94, 133)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-11, 22, 23),
	Vector(-11, -22, 23)
}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 15

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 20 + self:GetUp() * 15, angles, fov
	end

	return pos, angles, fov
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_isp/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "ISP Speeder"
ENT.Author = "Deltaa"
ENT.Information = "The Biker Advanced Recon Commando speeder was designed for use by the Grand Army of the Republic during the Clone Wars"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/necro/isp_speeder/isp_speeder.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 7500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 1

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 150

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Entity", "GunnerSeat")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(110, -40, 17),
		Vector(110, -20, 17)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 150
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 0, 255))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.SNDRight:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self.SecondaryFirePositions = {
		Vector(110, 20, 17),
		Vector(110, 40, 17)
	}

	-- Secondary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local veh = ent:GetVehicle()

		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #veh.SecondaryFirePositions then ent.NumPrim = 1 end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward()) > 60 then return true end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local EyeAngle = dir:Angle()
		local forward = EyeAngle:Forward()

		local direction = forward:GetNormalized()
		local CurPos = veh.SecondaryFirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = veh:LocalToWorld(CurPos)
		bullet.Dir = Vector(direction.x, direction.y, 0)
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 150
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 0, 255))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		veh.SNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon, 2)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/isp/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_supertank/cl_init.lua:
include("shared.lua")


function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	return self:LocalToWorld(Vector(0, 0, 300)), angles, fov
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_tx130/sh_turret.lua:
function ENT:CanUseBTL()
	return self:GetBodygroup(1) == 1
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment("lazer_cannon_muzzle")

	local Muzzle = self:GetAttachment(ID)
	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine({
		start = pos,
		endpos = pos + dir * 50000,
	})

	return trace
end

function ENT:SetPoseParameterBTL(weapon)
	if self:GetIsCarried() then
		self:SetPoseParameter("cannon_pitch", 0)
		self:SetPoseParameter("cannon_yaw", 0)

		return
	end

	if not IsValid(weapon:GetDriver()) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal(weapon:GetPos() + weapon:GetAimVector()):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("cannon_pitch", AimAng.p)
	self:SetPoseParameter("cannon_yaw",  AimAng.y)
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then return true end

		local trace = base:TraceBTL()

		base:BallturretDamage(trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized())
	end
	weapon.StartAttack = function(ent)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then return end
		if not base:CanUseBTL() then return end

		base:SetBTLFire(true)

		if not IsValid(self.SNDTurret) then return end

		self.SNDTurret:Play()
		self.SNDTurret:EmitSound("lvs/vehicles/laat/ballturret_fire.mp3", 113)
	end
	weapon.FinishAttack = function(ent)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		base:SetBTLFire(false)

		if not IsValid(self.SNDTurret) then return end
		self.SNDTurret:Stop()
	end
	weapon.OnThink = function(ent, active)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if not base:CanUseBTL() then return end

		local pod = self:GetGunnerSeat()
		base:SetPoseParameterBTL(pod:lvsGetWeapon())
	end
	weapon.HudPaint = function(ent, X, Y, ply)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter(Pos2D, color_white)
		base:PaintCrosshairOuter(Pos2D, color_white)
		base:LVSPaintHitMarker(Pos2D)
	end
	self:AddWeapon(weapon, 2)
end

--addons/lvs_starwars/lua/entities/lvs_fakehover_wheel.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/tire001c_car.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)

		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
	end

	function ENT:Define( data )
		local bbox = Vector(data.radius,data.radius,data.radius)

		self:PhysicsInitSphere( data.radius, "gmod_silent" )
		self:SetCollisionBounds( -bbox, bbox )

		local PhysObj = self:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:EnableDrag( false )
			PhysObj:EnableMotion( false )
			PhysObj:SetMass( data.mass )
			PhysObj:SetBuoyancyRatio( data.buoyancyratio )
		end
	end

	function ENT:SetPhysics( enable )
		if enable then
			if self.PhysicsEnabled then return end

			self:GetPhysicsObject():SetMaterial("jeeptire")
			self.PhysicsEnabled = true
		else
			if self.PhysicsEnabled == false then return end

			self:GetPhysicsObject():SetMaterial("friction_00")
			self.PhysicsEnabled = false
		end
	end

	function ENT:CheckPhysics()
		local base = self:GetBase()

		if not IsValid( base ) then return end

		if not base:GetEngineActive() then
			self:SetPhysics( true )

			self:NextThink( CurTime() + 0.25 )

			return
		end

		self:NextThink( CurTime() + 0.1 )

		local Ang = base:GetAngles()
		local steer = math.abs( base:WorldToLocalAngles( Angle(Ang.p,base:GetSteerTo(),Ang.r) ).y )
		local move = base:GetMove()
		local speed = base:GetVelocity():LengthSqr()

		local enable = (math.abs( move.x ) + math.abs( move.y )) < 0.001 and steer < 3 and speed < 600

		self:SetPhysics( enable )
	end

	function ENT:Think()
		self:CheckPhysics()

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:TakeDamageInfo( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local T = CurTime()

	if (self._nextFX or 0) > T then return end

	self._nextFX = T + 0.02

	local base = self:GetBase()

	if not IsValid( base ) then return end

	if base:GetVelocity():Length() < 50 then return end

	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - 10 ) ),
		filter = base:GetCrosshairFilterEnts(),
		mask = MASK_WATER
	}

	local traceWater = util.TraceLine( data )

	if not traceWater.Hit then
		return
	end

	local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetEntity( base )
		effectdata:SetMagnitude( self:BoundingRadius() )
	util.Effect( "lvs_hover_water", effectdata )
end

function ENT:Draw()
end

function ENT:OnRemove()
end

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_x34/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(255, 153, 0)
ENT.EngineColor2 = Color(255, 0, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-137, 0, 47),
	Vector(-95, 64, 18),
	Vector(-95, -64, 18)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 40

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_x34/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "X-34"
ENT.Author = "Deltaa"
ENT.Information = "The X-34 landspeeder was a model of civilian landspeeder manufactured by SoroSuub Corporation and available during the Galactic Civil War between the Galactic Empire and the Alliance to Restore the Republic."
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/niksacokica/x-34/x-34.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 1000
ENT.MaxVelocityY = 750

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_x34_gun/cl_init.lua:
include("shared.lua")

--addons/egm_lvs_ships/lua/entities/lvs_jack_senatepod/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end
--addons/lvs_starwars/lua/entities/lvs_repulsorlift_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Float",0, "DamageEffectsTime" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 0, 255, 255 ) )
	end

	function ENT:Think()
		local T = CurTime()
		local vehicle = self:GetBase()

		if not IsValid( vehicle ) or not vehicle:GetEngineActive() or self:GetDamageEffectsTime() < T then self:NextThink( T + 1 ) return true end

		if vehicle:GetHP() >= vehicle:GetMaxHP() then
			self:SetDamageEffectsTime( 0 )

			self:NextThink( T + 1 )

			return true
		end

		local PhysObj = vehicle:GetPhysicsObject()

		local Pos = self:GetPos()
		local Len = vehicle:WorldToLocal( Pos ):Length()

		PhysObj:ApplyForceOffset( -vehicle:GetVelocity() * (PhysObj:GetMass() / Len) * FrameTime() * 50, Pos )

		self:NextThink( T )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		local vehicle = self:GetBase()
	
		if not IsValid( vehicle ) then return end

		local TimeBork = 2 + (vehicle:GetHP() / vehicle:GetMaxHP()) * 123

		self:SetDamageEffectsTime( CurTime() + TimeBork )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	self:DamageFX( vehicle )
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = vehicle:GetHP()
	local MaxHP = vehicle:GetMaxHP() 

	if (self.nextDFX or 0) > T then return end

	if self:GetDamageEffectsTime() < T then
		if HP <= 0 or HP > MaxHP * 0.5 then return end
	end

	self.nextDFX = T + 0.05

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( vehicle )
	util.Effect( "lvs_engine_blacksmoke", effectdata )

	if HP < MaxHP * 0.5 and self:GetDamageEffectsTime() > T then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( -self:GetForward() )
			effectdata:SetMagnitude( 2 )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_exhaust_fire", effectdata )
	end
end

--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship/cl_init.lua:
include("shared.lua")
include("cl_spotlights.lua")
include("sh_driverweapons.lua")
include("sh_gunnerweapons.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 255, 255, 10)

ENT.ReactorColor = Color(0, 127, 255)
ENT.ReactorPos = {
	Vector(-270, -20, 265),
	Vector(-270, 20, 265),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 440, 70), 5, 50, 2, 100, 150)
	self:RegisterTrail(Vector(-100, -440, 70), 5, 50, 2, 100, 150)
end

function ENT:OnFrame()
	self:WingTurretProjector()
	self:DrawSpotlights()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	render.SetMaterial(self.EngineGlow)
	local delta = CurTime() - self.ActiveTime
	local max = math.min(15 * ( delta / 1 ), 15)

	local t = 0
	for _, v in pairs(self.ReactorPos) do
		local vOffset = self:LocalToWorld(v)
		local vNormal = -self:GetForward()

		for i = 0, max do
			local vUp = -self:GetUp()
			local ind = i * 2
			local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

			render.DrawSprite(vOffsetTmp, 60, 60, self.ReactorColor)
		end

		t = t + 1
	end
end

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()
	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity(self)
		util.Effect("lvs_laat_wing_projector", effectdata)
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

function ENT:OnEngineActiveChanged( Active )
	if Active then
		self:EmitSound("laat_bf2/engine_start.mp3")
		self.ActiveTime = CurTime()
	else
		self:EmitSound("laat_bf2/engine_end.mp3")
		self.StopTime = CurTime()
	end
end


--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_carrier/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/c"
ENT.Author = "Luna"
ENT.Information = "Tank Carrier of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laat_c.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 40

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 15000
ENT.MaxShield = 3000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "HeldEntity" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src = att.Pos
			bullet.Dir = att.Ang:Up()
			bullet.Spread = Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force = 10
			bullet.HullSize = 25
			bullet.Damage = 300
			bullet.Velocity = 60000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart(Vector(50, 255, 50))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				util.Effect("lvs_laser_impact", effectdata)
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1
	weapon.HeatRateUp = 10
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		ent:ToggleGrabber()
	end
	self:AddWeapon( weapon )



	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.RearGunAngleRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then return true end

		local trace = ent:GetEyeTrace()

		local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		local ID = self:LookupAttachment( "muzzle_reargun" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return true end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 195
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		if not IsValid( self.SNDTail ) then return end

		self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then base:SetPoseParameter("reargun_yaw", 0 ) return end

		local trace = ent:GetEyeTrace()

		local _,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		base:SetPoseParameter("reargun_pitch", -Ang.p )
		base:SetPoseParameter("reargun_yaw", -Ang.y )

	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local StartPos = pod:LocalToWorld( pod:OBBCenter() ) + angles :Up() * 250
		local EndPos = StartPos - angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local RearGunInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange

		local Col = RearGunInRange and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

sound.Add( {
	name = "LVS.LAAT.GRABBER",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "lvs/vehicles/laat/door_large_open.wav"
} )

sound.Add( {
	name = "LVS.LAAT.GRABBER_CANTDROP",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "buttons/button8.wav"
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:ResetFilters()
	-- clear the filters, so they can be rebuild
	self.CrosshairFilterEnts = nil
end

function ENT:BuildFilter()
	if not istable( self.CrosshairFilterEnts ) then
		self:GetCrosshairFilterEnts()
	end

	local HeldEnt = self:GetHeldEntity()

	if not IsValid( HeldEnt ) then return end

	if HeldEnt.GetCrosshairFilterEnts then
		for _, ent in pairs( HeldEnt:GetCrosshairFilterEnts() ) do
			table.insert( self.CrosshairFilterEnts, ent )
		end
	else
		table.insert( self.CrosshairFilterEnts , HeldEnt )
	end
end

--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_le/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/le"
ENT.Author = "Deltaa"
ENT.Information = "Police helicopter of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/KingPommes/starwars/patrol_transport/main.mdl"

ENT.MaxHealth = 9000
ENT.MaxShield = 3000

ENT.AITEAM = 2

ENT.MaxVelocity = 1500
ENT.MaxThrust = 1500

ENT.MaxPitch = 50

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-295, 0, -75)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Door")
	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end

end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(222, 34, 22),
		Vector(222, -34, 22)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 0, 255))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.PrimarySNDRight:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.PrimarySNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Siren and light
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Ammo = -1
	weapon.Delay = 1
	weapon.HeatRateUp = -1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		if ent.NextSiren and ent.NextSiren > CurTime() then return end
		ent.NextSiren = CurTime() + 1

		local base = ent:GetVehicle()

		if base:GetSkin() == 4 then
			base:SetSkin(5)
			base:EmitSound("kingpommes/starwars/patrol/siren.wav")
		elseif base:GetSkin() == 5 then
			base:SetSkin(4)
			base:StopSound("kingpommes/starwars/patrol/siren.wav")
		end
	end
	self:AddWeapon(weapon)
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/laat/boost_1.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

function ENT:CalcMainActivity(ply)
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then
		ply.m_bWasNoclipping = nil
		ply:AnimResetGestureSlot(GESTURE_SLOT_CUSTOM)

		if CLIENT then
			ply:SetIK(true)
		end
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence("idle_all_02")

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence("idle_" .. holdtype)

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_nuclass/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(25, 200, 255, 255)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-500, 250, 150), 5, 50, 2, 100, 150)
	self:RegisterTrail(Vector(-500, -250, 150), 5, 50, 2, 100, 150)
end

function ENT:OnFrame()
	self:AnimDoor()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 120 + self:GetThrottle() * 40 + self:GetBoost() * 0.8
	local Size2 = 150 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld(Vector(-450, 35.5, 180)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-450, 35.5, 250)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-450, -35.5, 250)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-450, -35.5, 180)), Size, Size, self.EngineColor)

	render.DrawSprite(self:LocalToWorld(Vector(-490, -124, 180)), Size2, Size2 + 150, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-490, 124, 180)), Size2, Size2 + 150, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-490, 160, 160)), Size2, Size2 + 150, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-490, -160, 160)), Size2, Size2 + 150, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-490, 206, 140)), Size2, Size2 + 150, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-490, -206, 140)), Size2, Size2 + 150, self.EngineColor)
end

function ENT:AnimDoor()
	local Tval = self:GetDoor() and 89 or 0
	local Tval2 = self:GetDoor() and 178 or 0

	local Rate = 50 * FrameTime()
	local Rate2 = 100 * FrameTime()

	self.smRH = self.smRH and self.smRH + math.Clamp(Tval - self.smRH, -Rate, Rate) or 0
	self.smRH2 = self.smRH2 and self.smRH2 + math.Clamp(Tval2 - self.smRH2, -Rate2, Rate2) or 0

	if not self.HatchID then
		self.HatchID = self:LookupBone("Z_DoorMain")
		self.HatchID2 = self:LookupBone("Z_DoorSmall")
	else
		self:ManipulateBoneAngles(self.HatchID, Angle(0, -0, -self.smRH))
		self:ManipulateBoneAngles(self.HatchID2, Angle(0, -0, -self.smRH2))
	end
end

function ENT:OnEngineActiveChanged( Active )
	if Active then
		self:EmitSound("laat_bf2/engine_start.mp3")
		self.ActiveTime = CurTime()
	else
		self:EmitSound("laat_bf2/engine_end.mp3")
		self.StopTime = CurTime()
	end
end


--addons/lvs_base/lua/entities/lvs_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "ActiveVisible" )
	self:NetworkVar( "Bool",2, "Doppler" )

	self:NetworkVar( "String",1, "Sound")
	self:NetworkVar( "String",2, "SoundInterior")

	self:NetworkVar( "Int",0, "SoundLevel" )

	if SERVER then
		self:SetSoundLevel( 110 )
		self:SetActiveVisible( true )
	end
end

if SERVER then
	util.AddNetworkString( "lvs_soundemitter_playonce" )

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 150, 150, 150 ) )
	end

	function ENT:Think()
		return false
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:PlayOnce( pitch, volume )
		net.Start( "lvs_soundemitter_playonce", true )
			net.WriteEntity( self )
			net.WriteInt( pitch or 100, 9 )
			net.WriteFloat( volume or 1 )
		net.SendPVS( self:GetPos() )
	end

	function ENT:Play()
		self:SetActive( true )
	end

	function ENT:Stop()
		self:SetActive( false )
	end

	return
end

net.Receive( "lvs_soundemitter_playonce", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not ent.PlayOnce then return end

	ent:PlayOnce( net.ReadInt( 9 ), net.ReadFloat() )
end )

function ENT:PlayOnce( pitch, volume )
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()

	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd == snd_int then self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON ) return end

	if IsValid( veh ) and veh == self:GetBase() and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			else
				self:EmitSound( snd_int, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			end
		else
			self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
		end
	else
		self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
	end
end

function ENT:Initialize()
end

function ENT:RemoveSounds()
	if self.snd then
		self.snd:Stop()
		self.snd = nil
	end

	if self.snd_int then
		self.snd_int:Stop()
		self.snd_int = nil
	end
end

function ENT:HandleSounds()
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()
	local base = self:GetBase()

	if self:GetDoppler() and IsValid( base ) then
		local Doppler = base:CalcDoppler( ply )

		if self.snd then self.snd:ChangePitch( 100 * Doppler, 0.5 ) end
		if self.snd_int then self.snd_int:ChangePitch( 100 * Doppler, 0.5 ) end
	end

	if not self.snd_int then return end

	if IsValid( veh ) and veh == base and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				if self.snd then self.snd:ChangeVolume( 1 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
			else
				if self.snd then self.snd:ChangeVolume( 0 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 1 ) end
			end
		else
			if self.snd then self.snd:ChangeVolume( 1 ) end
			if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
		end
	else
		if self.snd then self.snd:ChangeVolume( 1 ) end
		if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
	end
end

function ENT:StartSounds()
	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd ~= "" then
		self.snd = CreateSound( self, snd )
		self.snd:SetSoundLevel( self:GetSoundLevel() )
		self.snd:PlayEx(0,100)
	end

	if snd == snd_int or snd_int == "" or LocalPlayer():lvsGetVehicle() ~= self:GetBase() then
		if self.snd then self.snd:ChangeVolume( 1, 0 ) end

		return
	end

	self.snd_int = CreateSound( self, snd_int )
	self.snd_int:SetSoundLevel( self:GetSoundLevel() )
	self.snd_int:PlayEx(0,100)
end

function ENT:StopSounds()
	self.NextActive = CurTime() + 0.12

	if self.snd then
		self.snd:ChangeVolume( 0, 0.1 )
	end

	if self.snd_int then
		self.snd_int:ChangeVolume( 0, 0.1 )
	end

	timer.Simple(0.11, function()
		if not IsValid( self ) then return end
		self:RemoveSounds()
	end)
end

function ENT:OnActiveChanged( Active )
	if Active then
		self:StartSounds()
	else
		self:StopSounds()
	end
end

ENT._oldActive = false
function ENT:Think()
	local Active = self:GetActive() and (self.NextActive or 0) < CurTime()

	if self._oldActive ~= Active then
		self._oldActive = Active
		self:OnActiveChanged( Active )
	end

	if Active then
		self:HandleSounds()
	end
end

function ENT:OnRemove()
	self:RemoveSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_arc/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,64.51,8.36),
	Vector(-163.81,-64.51,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:AnimAstromech()
	self:AnimWings()
	self:AnimGunner()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()
	if not IsValid(Pod) then return end

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis(EyeAngles:Up(), 180)

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0,Pitch) )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 4, Angle(0,0,Pitch) )
end

function ENT:AnimAstromech()
	if self.nextAstro and self.nextAstro < CurTime() then
		self.nextAstro = CurTime() + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end


		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 1, Angle(self.smastro,0,0) )
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetWings() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	local Ang = (1 - self._sm_wing) * 20

	self:ManipulateBoneAngles(13, Angle(0, -Ang, 0))
	self:ManipulateBoneAngles(18, Angle(0, Ang, 0))

	self:ManipulateBoneAngles(15, Angle(0, Ang, 0))
	self:ManipulateBoneAngles(14, Angle(0, -Ang, 0))

	self:InvalidateBoneCache()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_droidtrifighter/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Droid Tri-Fighter"
ENT.Author = "Luna"
ENT.Information = "Droid Starfighter of the Separatists"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salza/droidtrifighter.mdl"
ENT.GibModels = {
	"models/salza/tridroid_gib1.mdl",
	"models/salza/tridroid_gib2.mdl",
	"models/salza/tridroid_gib3.mdl",
	"models/salza/tridroid_gib4.mdl",
	"models/salza/tridroid_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6500

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(114.58,0,86.08),
		Vector(112.54,74.47,-42.69),
		Vector(112.54,-74.47,-42.69),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src = ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 900
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255,50,50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.75
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Src = ent:LocalToWorld(Vector(152.24,0,0))
		bullet.Dir = ent:GetForward()
		bullet.Spread = Vector(0.015, 0.015, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 250
		bullet.HullSize = 25
		bullet.Damage = 1600
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 0, 0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset( "TURBO"))
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/droidtrifighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_ebonhawk/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Dynamic-class Freighter"
ENT.Author = "Deltaa"
ENT.Information = "Prototype bomber by the Nubian Design Collective, stolen and modified by pirates and other unsavories"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/ehawk/ehawk1.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 1900
ENT.MaxThrust = 1900

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.9
ENT.TurnRateYaw = 0.9
ENT.TurnRateRoll = 0.9

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 18000
ENT.MaxShield = 4500

function ENT:OnSetupDataTables()
	self:AddDT("Entity", "GunnerSeat")
end


function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(-63, 396, 113),
			Vector(-63, 396, 88)

		},

		{
			Vector(-63, -396, 113),
			Vector(-63, -396, 88)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.01, 0.01, 0)
			bullet.Tracer = 1
			bullet.TracerName = "lvs_laser_green"
			bullet.Force = 100
			bullet.HullSize = 10
			bullet.Damage = 300
			bullet.Attacker = ent:GetDriver()
			bullet.Velocity = 40000
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart(Vector(50, 255, 50))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				util.Effect("lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)
		end

		if ent.NumPrim == 1 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self.SecondaryFirePos = {
		Vector(-282, 14, 200),
		Vector(-282, -14, 200)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.15
	weapon.HeatRateDown = 0.2
	weapon.Attack = function(ent)
		local base = ent:GetVehicle()

		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #base.SecondaryFirePos then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = base.SecondaryFirePos[ent.NumPrim]

		local bullet = {}
		bullet.Src = base:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 40000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(50, 255, 50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		base.SNDTail:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon, 2)
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/nuclass/hum.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/nuclass/hum.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_gauntlet/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 200, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-320, 500, 170), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-320, -500, 170), 5, 20, 2, 1000, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	-- Draws the effect
	local Size = 300 + self:GetThrottle() * 120 + self:GetBoost()
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld(Vector(-480, 270, 175)), Size, Size, Color(255, 200, 0, 255))
	render.DrawSprite(self:LocalToWorld(Vector(-480, -270, 175)), Size, Size, Color(255, 200, 0, 255))
	render.DrawSprite(self:LocalToWorld(Vector(-480, 210, 175)), Size, Size, Color(255, 200, 0, 255))
	render.DrawSprite(self:LocalToWorld(Vector(-480, -210, 175)), Size, Size, Color(255, 200, 0, 255))
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local Pos = {
		Vector(-495, 210, 175),
		Vector(-495, -210, 175),
		Vector(-495, 270, 175),
		Vector(-495, -270, 175),
	}

	local emitter = ParticleEmitter(self:GetPos(), false)

	for _, v in pairs(Pos) do
		local vOffset = self:LocalToWorld(v)
		local vNormal = -self:GetForward()

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then return end

		particle:SetVelocity(vNormal * math.Rand(500, 2500) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(35, 55))
		particle:SetEndSize(math.Rand(1, 20))
		particle:SetRoll(math.Rand(-1, 1) * 100)
		particle:SetColor(200, 250, 200)
	end
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_havoc/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 0, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-95, 220, 24), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-95, -220, 24), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-160, 48, 68), 0, 20, 2, 700, 150)
	self:RegisterTrail(Vector(-160, -48, 68), 0, 20, 2, 700, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()

	render.SetMaterial(self.EngineGlow)

	for i = -1,1,2 do
		local pos = self:LocalToWorld(Vector(-120, 20 * i, 35))
		render.DrawSprite( pos, Size, Size, self.EngineColor)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimGunner()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = ParticleEmitter(self:GetPos(), false)

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(-104.75,-20 * i,30) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 100, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetGunnerSeat()
	if not IsValid(Pod) then return end

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local EyeAngles = self:WorldToLocalAngles(weapon:GetAimVector():Angle())
	EyeAngles:RotateAroundAxis(EyeAngles:Up(), 180)

	local Yaw = math.Clamp( EyeAngles.y,-180,180)
	local Pitch = math.Clamp( EyeAngles.p,-180,180 )

	self:ManipulateBoneAngles( 1, Angle(-Yaw, 0, 0) )
	self:ManipulateBoneAngles( 2, Angle(0, 0, math.max( Pitch, -25)))
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_scimitar/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 0, 0)
ENT.EnginePos = {
	Vector(-113.5,37,92.5),
	Vector(-115,30,92.5),
	Vector(-116.5,23,92.5),
	Vector(-118,16,92.5),
	Vector(-119.5,9,92.5),
	Vector(-121,2,92.5),

	Vector(-121,-2,92.5),
	Vector(-119.5,-9,92.5),
	Vector(-118.5,-16,92.5),
	Vector(-116.5,-23,92.5),
	Vector(-115,-30,92.5),
	Vector(-113.5,-37,92.5),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-65, 170, 85), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-65, -170, 85), 5, 20, 2, 1000, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	cam.Start3D2D(self:LocalToWorld(Vector(-116,22,92)), self:LocalToWorldAngles(Angle(0,70,-90)), 1)
		draw.NoTexture()
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRectRotated(0, 0, 40, 7, 0)
		surface.DrawTexturedRectRotated(0, 0, 40, 7, 0)
	cam.End3D2D()

	cam.Start3D2D(self:LocalToWorld(Vector(-116,-22,92)), self:LocalToWorldAngles(Angle(0,110,-90)), 1)
		draw.NoTexture()
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRectRotated(0, 0, 40, 7, 0)
		surface.DrawTexturedRectRotated(0, 0, 40, 7, 0)
	cam.End3D2D()

	local Size = 150 + self:GetThrottle() * 15 + self:GetBoost() * 1.5

	for _, v in pairs(self.EnginePos) do
		local pos = self:LocalToWorld(v)
		render.SetMaterial(self.EngineGlow)
		render.DrawSprite(pos, Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/scimitar/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/scimitar/brake.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle/shared.lua:
ENT.Base = "lvs_starfighter_shuttle_armed"

ENT.PrintName = "Transport HVC Unarmed"
ENT.Author = "Miller"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lt_c/sci_fi/shuttle/shuttle_static.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 7500
ENT.MaxShield = 4500

function ENT:InitWeapons()
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_vulture/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Vulture Droid"
ENT.Author = "Deltaa"
ENT.Information = "Droid Starfighter of the Trade Federation"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/vulturecis.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.3
ENT.TurnRateYaw = 1.3
ENT.TurnRateRoll = 1.3

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.3
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(50, 110, 120),
		Vector(50, -110, 120),
		Vector(50, 110, 110),
		Vector(50, -110, 110)
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 1600
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Torpedo Weapon
	/*[local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 3
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(40, ent._swapMissile and -110 or 110, 115)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat( NewHeat )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon) 
*/

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/vulturedroid/boost.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "^lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_base/lua/entities/lvs_vehicle_air_refil.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Refil Balloon"
ENT.Author = "Luna"
ENT.Information = "Refils Ammo on Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.RenderGroup = RENDERGROUP_BOTH 

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/balloons/hot_airballoon.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Balloon terminated.")

			return
		end

		pObj:SetMass( 1000 ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:StartMotionController()

		self:PhysWake()
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local StartPos = self:LocalToWorld( self:OBBCenter() )
		local traceUp = util.TraceLine( {
			start = StartPos,
			endpos = StartPos + Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )
		local traceDown = util.TraceLine( {
			start = StartPos,
			endpos = StartPos - Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )

		local Force = (traceUp.HitPos + traceDown.HitPos) * 0.5 - StartPos

		local ForceLinear, ForceAngle = phys:CalculateForceOffset( Force, phys:LocalToWorld( phys:GetMassCenter() + Vector(0,0,1) ) )

		ForceLinear = ForceLinear - phys:GetVelocity()
		ForceAngle = ForceAngle - phys:GetAngleVelocity()

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local SpriteColor = Color( 255, 150, 0, 255 )
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/refil.png" )

	function ENT:Draw()
	end

	function ENT:DrawTranslucent()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:LocalToWorld( self:OBBCenter() )

		if Small then
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 1 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				cam.End3D2D()
			end
		else
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 0.75 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				cam.End3D2D()
			end
		end
	end

	function ENT:OnRemove()
		if IsValid( self._RepairMDL ) then
			self._RepairMDL:Remove()
		end
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte_hoverscript/cl_init.lua:
include("shared.lua")

--addons/egm_lvs_ground/lua/entities/lvs_walker_atte_hoverscript/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Generic Hover"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 140
ENT.HoverTraceLength = 200
ENT.HoverHullRadius = 20

ENT.HoverCollisionFilter = {
	[COLLISION_GROUP_DEBRIS] = true,
	[COLLISION_GROUP_DEBRIS_TRIGGER] = true,
	[COLLISION_GROUP_PLAYER] = true,
	[COLLISION_GROUP_WEAPON] = true,
	[COLLISION_GROUP_VEHICLE_CLIP] = true,
	[COLLISION_GROUP_WORLD] = true,
}

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:GetCrosshairFilterLookup()
	if self._EntityLookUp then return self._EntityLookUp end

	self._EntityLookUp = {}

	for _, ent in pairs( self:GetCrosshairFilterEnts() ) do
		self._EntityLookUp[ ent:EntIndex() ] = true
	end

	return self._EntityLookUp
end


--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:AimTurretPrimary()
	self:AimTurretSecondary()
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then
		for _, tab in pairs(self.IK_Joints) do
			for _,prop in pairs( tab ) do
				if IsValid(prop) then
					prop:Remove()
				end
			end
		end

		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts(index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS)
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[index] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[index] then
		self.IK_Joints[index] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()

		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/egm_tfa_mines/lua/entities/mine_antiperson/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Anti Person        --
---------------------------------------

include("shared.lua")
--addons/egm_tfa_mines/lua/entities/mine_antivehicle/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Anti Vehicle       --
---------------------------------------

include("shared.lua")
--addons/egm_tfa_mines/lua/entities/mine_incendiary/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mines | Incendiary        --
---------------------------------------

ENT.Base = "mine_base"

ENT.PrintName = "Feuer Mine"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Skin = 3

ENT.Spawnable = true
--addons/mortar/lua/entities/mortar_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"Mortar Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "CW:RP Sonstiges"


--addons/hbombs_base/lua/entities/nuclear_siren/shared.lua:
DEFINE_BASECLASS( "base_gmodentity" )

ENT.PrintName		= "Nuclear Siren"
ENT.Author		= ""
ENT.Information		= ""
ENT.Category		= "HBOMBS Misc"

ENT.Editable		= false
ENT.Spawnable		= true
ENT.AdminOnly		= false
--lua/entities/obj_ammo.lua:
AddCSLuaFile()

ENT.Type   = "anim"
ENT.PrintName = "Chemlight Crate"
ENT.Category = "Fun + Games"
ENT.AdminOnly = false
ENT.Spawnable = true
ENT.AutomaticFrameAdvance = true

ENT.Mod = "models/Items/item_item_crate.mdl"								-- "models/Gibs/HGIBS.mdl" Моделька.
ENT.Mat = ""									-- "" Материал. Можно оставить пустым.
ENT.Col = Color(255,255,255)									-- Color(255,255,255) Цвет.

if CLIENT then

function ENT:Draw()
self:DrawModel()
end


end

function ENT:SpawnFunction( ply, tr, class )
		local tr,trace = {},{}
		tr.start = ply:GetShootPos()
		tr.endpos = tr.start + ply:GetAimVector() * 22500
		tr.filter = ply
		tr.mask = MASK_WATER + MASK_SOLID
		trace = util.TraceLine( tr )
		local SpawnPos = trace.HitPos + trace.HitNormal * 1
		local ent = ents.Create( class )
		ent:SetPos( SpawnPos )
		ent.Owner = ply 
		ent:SetAngles( ply:GetAngles() )
		ent:Spawn()
		ent:Activate()
		return ent
	end


function ENT:Use(act)

if SERVER and IsValid(act) and act:IsPlayer() then
act:GiveAmmo( 8, "glowsticks", false )
self:Remove()
end

end

function ENT:Initialize()

	if SERVER then
	
		self:SetModel(self.Mod or "models/Items/item_item_crate.mdl")
		self:SetMaterial(self.Mat or "")
		self:SetColor(self.Col or Color(255,255,255))
		
		self:PhysicsInit(SOLID_VPHYSICS )
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		self:SetUseType(SIMPLE_USE)
    
		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
       
		
	end
	
	self:SetPlaybackRate(1)
	
end
--lua/entities/obj_npcspawner/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	//net.Start("slv_npctools_spawner_reqtrack")
	//	net.WriteEntity(self)
	//net.SendToServer()
end

function ENT:Draw()
end
/*
net.Receive("slv_npctools_spawner_rectrack",function(len)
	local ent = net.ReadEntity()
	if(!ent:IsValid()) then return end
	local track = net.ReadString()
	ent.m_soundtrack = track
end)

net.Receive("slv_npctools_spawner_play",function(len)
	local ent = net.ReadEntity()
	if(!ent:IsValid() || !ent.m_soundtrack) then return end
	if(cspSoundtrack) then cspSoundtrack:Stop() end
	local track = ent.m_soundtrack
	cspSoundtrack = CreateSound(LocalPlayer(),track)
	cspSoundtrack:SetSoundLevel(0.2)
	cspSoundtrack:Play()
	local dur = SoundDuration(track) // Doesn't work with .mp3 files
	local tm = RealTime() +dur
	hook.Add("Think","slv_npc_soundtrack",function()
		if(!ent:IsValid()) then
			cspSoundtrack:FadeOut(4)
			hook.Remove("Think","slv_npc_soundtrack")
			return
		end
		if(RealTime() >= tm) then
			cspSoundtrack:Stop()
			cspSoundtrack = CreateSound(LocalPlayer(),track)
			cspSoundtrack:SetSoundLevel(0.2)
			cspSoundtrack:Play()
			tm = RealTime() +dur
		end
	end)
end)

local cspSoundtrack
net.Receive("slv_npc_soundtrack",function(len)
	local ent = net.ReadEntity()
	if(!ent:IsValid()) then return end

end)
*/
--lua/entities/obj_npcspawner/shared.lua:
ENT.Type 			= "point"
ENT.Base 			= "base_gmodentity"
ENT.PrintName		= "NPC Autospawner"
ENT.Author			= "Silverlan"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--lua/entities/obj_patrolpoint/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
end

function ENT:Draw()
end
--lua/entities/pfx1_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [v_3]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]groundflame1"
--lua/entities/pfx1_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Ember field"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]embers_~"
--lua/entities/pfx1_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Black Smoke Cloud"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]big_smoke"
--lua/entities/pfx1_08#_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Pink]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_pink"
--lua/entities/pfx1_08_.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Red]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_red"
--lua/entities/pfx1_08_~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Yellow]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_yellow"
--lua/entities/pfx1_08_~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Yellow]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_yellow"
--lua/entities/pfx1_08_~a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Purple]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_purple"
--lua/entities/pfx1_0c~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large fire"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]ground_fire_1*"
--lua/entities/pfx2_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Sparkle 2"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]sparkle2"



--lua/entities/pfx2_02_a_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Alien Blood [Alien]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood_alien"
--lua/entities/pfx4_00_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f_s"
--lua/entities/pfx4_00_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Basic Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f_s*"
--lua/entities/pfx4_01_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Blue Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b_s"

--lua/entities/pfx4_03_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g_s*"
--lua/entities/pfx4_05~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs [Small]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1_small"
--lua/entities/pfx4_06_1.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_g"
--lua/entities/pfx4_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "BFG Projectile"
ENT.Category         = "PPE: Weapons" -- too lazy to move this to different entity category.
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]bfg_*proj"
--lua/entities/pfx4_08.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Beam"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]electric_beam"
--lua/entities/pfx4_09.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Matrix Core"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]matrix_core"
--lua/entities/pfx4_0a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Vehicle Nitro Flame"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]_car_nitro"
--lua/entities/pfx4_0b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Matrix Sphere"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]binary_sphere"
--lua/entities/pfx5_00_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_b"
--lua/entities/pfx5_00_alt_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Small Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_micro_b"
--lua/entities/pfx5_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Starfield 1"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]starfield1"
--lua/entities/pfx6_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Gunfire"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]gunfire_generic"
--lua/entities/pfx6_02b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "AR2 Tracer"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]bullet_tracer_ar2"
--lua/entities/pfx7_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Rain"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]rain"
--lua/entities/pfx8_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Flame 2"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_flame"
--lua/entities/pfxa_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Waterleak"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[A]waterleak_1"
--lua/entities/pfxcom.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFXCOM"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[com]jet"
--addons/system_entities/lua/entities/powerstation/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Türsteuerungsmodul"
ENT.Category = "CW:RP Systementites"

ENT.PowerHealth = 2000
ENT.LockedDoors = {}

ENT.IsSystem = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end

--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_flash/shared.lua:
ENT.Type = "anim"
ENT.PrintName			= "explosive Grenade"
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions			= ""
ENT.DoNotDuplicate = true 
ENT.DisableDuplicator = true

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end

/*---------------------------------------------------------
PhysicsCollide
---------------------------------------------------------*/

function ENT:PhysicsCollide(data,phys)
	if data.Speed > 60 then
		self.Entity:EmitSound(Sound("TFA_CSGO_SmokeGrenade.Bounce"))
	end
	
end

--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_incendiary.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/Incendiary_Charge_01.wav")
	self.ActiveTimer = CurTime() + 1.5
	self.IgniteEnd = 0
	self.IgniteEndTimer = CurTime()
	self.IgniteStage = 0
	self.IgniteStageTimer = CurTime()
	ParticleEffectAttach("incgrenade_thrown_trail",PATTACH_POINT_FOLLOW,self,1)
	self:PhysicsInitSphere( 8 )
end

function ENT:PhysicsCollide( data,phys )
	if SERVER and self.ActiveTimer > CurTime() || data.Speed >= 150 then
		self:EmitSound( "TFA_CSGO_SmokeGrenade.Bounce" )
	end
	local ang = data.HitNormal:Angle()
	ang.p = math.abs( ang.p )
	ang.y = math.abs( ang.y )
	ang.r = math.abs( ang.r )
	
	if ang.p > 90 or ang.p < 60 then
		self.Entity:EmitSound(Sound("TFA_CSGO_SmokeGrenade.Bounce"))

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
		phys:ApplyForceCenter(impulse)
	else
		if SERVER then
			local hull = ents.Create("rj_molotov_hull")
			if not hull then return end
			hull:SetPos(data.HitPos + data.HitNormal * 40)
			hull:SetAngles(data.HitNormal:Angle() + Angle(90,0,0))
			hull:SetOwner(self.Owner)
			hull.Owner = self.Owner
			hull.vFirePos = data.HitPos
			hull.vFireVel = data.OurOldVelocity
			hull.Inflictor = self.Weapon
			hull:Spawn()

			self:SetMoveType( MOVETYPE_NONE )
			self:SetSolid( SOLID_NONE )
			self:PhysicsInit( SOLID_NONE )
			self:SetCollisionGroup( COLLISION_GROUP_NONE )
			self:SetRenderMode( RENDERMODE_TRANSALPHA )
			self:SetColor( Color( 255, 255, 255, 0 ) )
			self:DrawShadow( false )
			self:StopParticles()
		end
		self:EmitSound("TFA_CSGO_IncGrenade.Start")
		self.IgniteEnd = 1
		self.IgniteEndTimer = CurTime() + 7
		self.IgniteStage = 1
		self.IgniteStageTimer = CurTime() + 0.1
	end
end

function ENT:OnRemove()
	if SERVER then
		self:StopSound( "TFA_CSGO_Inferno.Loop" )
		self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_stun.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Shock_Explosion_02.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_flash.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 3
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("weapons/tfa_starwars/Shock_Charge_01.wav")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then

		if  (20 < data.Speed and 0.25 < data.DeltaTime) then
		self.Delay = 0
		end
		
		--if self:GetVelocity():Length() < 5 then
		--	self:SetMoveType(MOVETYPE_NONE)
		--end
	end
end

function ENT:Think()
	if SERVER then    
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
	end
	if self.IsDetonated == true then
		local elec = EffectData()
		elec:SetOrigin(self:GetPos())
		elec:SetMagnitude(3)
		util.Effect("Sparks", elec)
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 120 ) ) do
			if v:IsPlayer() then
				FreezePlayer(self)
				v:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 100), 0.2, 0)
				damage = DamageInfo()
				damage:SetDamage( 0 )
				damage:SetAttacker( self:GetOwner() )
				damage:SetDamageType( DMG_SHOCK )
				v:TakeDamageInfo( damage )
			end
		end
	end
	self:NextThink( CurTime() + 0.3 )
	return true
end

function FreezePlayer(self,pos)
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 200 ) ) do
	if v:IsPlayer() then
	local fx = EffectData()
		fx:SetOrigin( v:GetPos() )
		fx:SetMagnitude(2)
		util.Effect("TeslaHitBoxes",fx)
		v:Freeze( true )
		timer.Simple(3, function()
			v:Freeze( false )
			end)
		end
	end
end
	
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
	end
	
	--self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,5)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_train.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

ENT.ExplodeSound = Sound("weapons/tfa_starwars/Shock_Explosion_02.wav")

function ENT:Draw()
	self:DrawModel()
	pos = self:GetPos()
	render.SetMaterial(Material("particle/particle_glow_04_additive"))
	render.DrawSprite(pos, 10, 10, Color(255, 90, 0))
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/cs574/explosif/grenade_train.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self.ExplodeTimer = CurTime() + 2.5
end

function ENT:Think()
	if SERVER and self.ExplodeTimer <= CurTime() then
		self:EmitSound(self.ExplodeSound)
		self:Explode()
		self:Remove()
	end
end

function ENT:PhysicsCollide( data )
	if SERVER and data.Speed > 150 then
	self:EmitSound( "TFA_CSGO_SmokeGrenade.Bounce" )
	end
end

function ENT:OnRemove()
end

function ENT:Explode()
	local effectdata = EffectData()
	effectdata:SetOrigin( self:GetPos() )
	effectdata:SetScale(2)
	util.Effect("train_light", effectdata)
end
--lua/entities/sent_swrc_hoth/shared.lua:
AddCSLuaFile( )
DEFINE_BASECLASS( "base_anim" )

ENT.IsDODSTNT = true
ENT.TotalExplosions = 1
ENT.AutomaticFrameAdvance = true

util.PrecacheModel( "models/props/starwars/weapons/hoth_bomb.mdl" )
util.PrecacheSound( "buttons/spark6.wav" )
util.PrecacheSound( "ambient/fire/mtov_flame2.wav" )

if CLIENT then
	ENT.Mat = Material( "sprites/redglow1" )
	ENT.Mat2 = Material( "cable/redlaser" )
	
	ENT.LP = Vector( -.5, 1, 2 )
end

function ENT:SetupDataTables( )
	self:NetworkVar( "Float", 0, "Defuse" )
	self:NetworkVar( "Float", 1, "Fuse" )
	
	self:NetworkVar( "Int", 0, "BurnAdjust" )
	
	self:NetworkVar( "Bool", 0, "Live" )
end

function ENT:Draw( )

	
	local bone, n, light
	
	bone = self:GetAttachment( self:LookupAttachment( "wick" ) )
	
	if not bone then
		return
	end
	
	self:DrawModel( )
	
	if self:GetDefuse( ) < 1 then
		
		--if self.BurnSound then
			--self.BurnSound:PlayEx( .5, 170 )
		--end
	else
		if self.BurnSound then
			self.BurnSound:Stop( )
		end
	end
end

function ENT:OnRemove( )
	if self.BurnSound then
		self.BurnSound:Stop( )
	end
end

function ENT:Use(activator, caller)
	self.Entity:ActivateX(1)
end

function ENT:ActivateX( scale )
	if not self:GetLive( ) then
		self:SetLive( true )
		self:SetBurnAdjust( scale or 1 )
		
		seq = self:LookupSequence( "w_tnt_wick" )
		self:ResetSequence( seq )
		self:SetPlaybackRate( 1 / self:GetBurnAdjust( ) )
		
		if not self.BurnSound then
			self.BurnSound = CreateSound( self, Sound( "weapons/sw_detonator.wav" ) )
		end
		self.BurnSound:Play( )
	end
end

function ENT:OnTakeDamage( info )
	self:TakePhysicsDamage( info )
	if info and self:IsValid( ) and not self.Refuse then
		if info:IsExplosionDamage( ) then
			self:Explode( )
		end
	end
end

function ENT:Initialize( )
	self:SetModel( "models/props/starwars/weapons/hoth_bomb.mdl" )
	
	if SERVER then
		self:SetDefuse( 0 )
		self:SetFuse( 0 )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		
		self:PhysWake( )
	end
end

function ENT:Think( )
	local now, delta
	
	
	if CLIENT then
		return
	end
	
	now = CurTime( )
	
	delta = now - ( self.LastThink or now )
	
	self.LastThink = now
	
	if self:GetLive( ) then
		if not self.Used then
			self:SetDefuse( math.Clamp( self:GetDefuse( ) - delta * .5, 0, 1 ) )
		end
	end
	
	if self:GetDefuse( ) >= 1 and self:GetLive( ) then
		self:SetLive( false )
		
		self:EmitSound( "buttons/spark6.wav", 100, 63 )
		self:SetPlaybackRate( 0 )
	end
	
	if self:GetLive( ) then
		self:SetFuse( math.Clamp( self:GetFuse( ) + delta / ( self:GetBurnAdjust( ) * 19 ), 0, 1 ) )
		
		if self:GetFuse( ) >= 0.20 and SERVER then
			self:SetLive( false )
			self:Explode( )
		end
	end
	
	if self:GetLive( ) and self:WaterLevel( ) > 0 then
		self:SetLive( false )
		self:SetDefuse( 1 )
	end
	
	self.Used = false
end

local function Spin( vector, up, right, forward )
	local ang
	
	ang = ( vector * 1 ):Angle( )
	
	ang:RotateAroundAxis( ang:Up( ), math.random( -up / 2 , up / 2 ) )
	ang:RotateAroundAxis( ang:Right( ), math.random( -right / 2 , right / 2 ) )
	ang:RotateAroundAxis( ang:Forward( ), math.random( -forward / 2 , forward / 2 ) )
	
	return ang:Forward( )
end

function ENT:Explode( )
	if self.Refuse then
		return
	end
	
	self.Refuse = true
	
	for k, v in pairs (ents.FindInSphere(self.Entity:GetPos(), 250)) do
		v:Fire("EnableMotion", "", math.random(0, 0.5))
	end
	
	local explode = ents.Create( "env_explosion" )
	explode:SetPos( self:GetPos() )
	explode:SetKeyValue( "iMagnitude", "250" )
	explode:EmitSound( "weapon_AWP.Single", 100, 100 )
	explode:Spawn()
	explode:Activate()
	explode:Fire( "Explode", "", 0 )
	
	self:Remove()
end
--addons/system_entities/lua/entities/shieldgenerator/cl_init.lua:
include( "shared.lua" )

surface.CreateFont( "BlahBlah2", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
	shadow = true,
	outline = false
} )

--WORK IN PROGRESS

function ENT:Draw()
	self:DrawModel()

	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		cam.Start3D2D( p + Vector( -5, 0, 20 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Shieldgenerator", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -70, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			if self:Health() > self.PowerHealth / 2 then
				draw.DrawText( "online", "BlahBlah2", 39, - 295, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			if (self:Health() <= self.PowerHealth / 2 && self:Health() > 0) then
				draw.DrawText( "kritisch", "BlahBlah2", 42, - 295, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
			end

			if self:Health() == 0 then
				draw.DrawText( "offline", "BlahBlah2", 39, - 295, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			end

		cam.End3D2D()
	end
end

--addons/system_entities/lua/entities/shieldgenerator/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = false
ENT.AdminOnly = true

ENT.PrintName = "Shieldgenerator [WIP]"
ENT.Category = "CW:RP Systementites"

ENT.PowerHealth = 2000

ENT.IsSystem = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end

--WORK IN PROGRESS

--addons/vanilla-tools/lua/entities/shipdestruction/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_ShipExplosion"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--addons/emplacements/lua/entities/swrp_turret_stand_bullets2.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Turret Stand Bullets2"
ENT.Category = "CW:RP Geschütze"
ENT.Editable = true
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/turret/mg_stand.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll 
	pAngle.yaw = pAngle.yaw + 180
	local ent = ents.Create( ClassName ) 
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()
	return ent	
end

if CLIENT then

	surface.CreateFont( "info_1", {
	font = "Arial",
	extended = false,
	size = 25,
	weight = 100,
	shadow = true,
	outline = false
	} )

	function ENT:Draw()
		self:DrawModel()

		local p = self:GetPos()

		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90
		if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
			cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
				--draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
				--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
				--draw.DrawText( "Turret Stand", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
				
				local swep = LocalPlayer():GetActiveWeapon()
				if swep:IsValid() and swep:GetClass() == "weapon_swrp_bullets2_deployable" then
					draw.RoundedBox( 5, - 166, - 470, 330, 100, Color( 0, 0, 0, 230 ) )
					draw.RoundedBox( 1, - 166, - 424, 330, 2, Color( 255, 255, 255, 230 ) )
					draw.DrawText( "> Geschütz platzieren <", "info_1", -1, - 410, Color( 0, 255, 51, 255 ), TEXT_ALIGN_CENTER )
				else
					draw.RoundedBox( 5, - 166, - 470, 330, 45, Color( 0, 0, 0, 230 ) )
				end
				draw.DrawText( "Heavy Blaster Cannon", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
		self:SetTrigger(true)
	

	end
end

if SERVER then
	function ENT:Think()
		if self:GetNWBool("Remove?", false) then
			self:Remove()
			local cannon = ents.Create("turret_bullets2_deployable") -- Tesla Effect
			cannon:SetPos(self:GetPos())
			cannon:Spawn()
		end
	end

	function ENT:Use(activator, caller, useType, value)
		if IsValid(activator) and activator:IsPlayer() and self.owner == activator then
			activator:Give("weapon_swrp_bullets2_deployable")
			self:EmitSound("summe/sw01_gadgets_burstshield_stop_var_02.mp3")
			self:Remove()
		end
	end

end
--addons/emplacements/lua/entities/swrp_turret_stand_grenade_launcher.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Turret Stand GL"
ENT.Category = "CW:RP Geschütze"
ENT.Editable = true
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/turret/gl_stand.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll 
	pAngle.yaw = pAngle.yaw + 180
	local ent = ents.Create( ClassName ) 
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()
	return ent	
end

if CLIENT then

	surface.CreateFont( "info_1", {
	font = "Arial",
	extended = false,
	size = 25,
	weight = 100,
	shadow = true,
	outline = false
	} )

	function ENT:Draw()
		self:DrawModel()

		local p = self:GetPos()

		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90
		if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
			cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
				--draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
				--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
				--draw.DrawText( "Turret Stand", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
				
				local swep = LocalPlayer():GetActiveWeapon()
				if swep:IsValid() and swep:GetClass() == "weapon_swrp_grenade_launcher_deployable" then
					draw.RoundedBox( 5, - 150, - 470, 295, 100, Color( 0, 0, 0, 230 ) )
					draw.RoundedBox( 1, - 150, - 424, 295, 2, Color( 255, 255, 255, 230 ) )
					draw.DrawText( "> Geschütz platzieren <", "info_1", -1, - 410, Color( 0, 255, 51, 255 ), TEXT_ALIGN_CENTER )
				else
					draw.RoundedBox( 5, - 150, - 470, 295, 45, Color( 0, 0, 0, 230 ) )
				end
				draw.DrawText( "Grenade Launcher", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
		self:SetTrigger(true)
	

	end
end

if SERVER then
	function ENT:Think()
		if self:GetNWBool("Remove?", false) then
			self:Remove()
			local cannon = ents.Create("turret_grenade_deployable") -- Tesla Effect
			cannon:SetPos(self:GetPos())
			cannon:Spawn()
		end
	end

	function ENT:Use(activator, caller, useType, value)
		if IsValid(activator) and activator:IsPlayer() and self.owner == activator then
			activator:Give("weapon_swrp_grenade_launcher_deployable")
			self:EmitSound("summe/sw01_gadgets_burstshield_stop_var_02.mp3")
			self:Remove()
		end
	end

end
--addons/starwars_universe/lua/entities/swu_controller/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Controller"
ENT.Author = "The Coding Ducks"
ENT.Information = ""
ENT.Category = "[SWU] Universe"

ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Vector", 0, "ShipPos")
    self:NetworkVar("Float", 0, "InternalShipAngleY")
    self:NetworkVar("Float", 1, "InternalTargetShipAngleY")

    self:NetworkVar("Int", 0, "TargetShipAcceleration")
    self:NetworkVar("Int", 1, "CurrentShipAcceleration")
    self:NetworkVar("Int", 2, "Hyperspace")
    self:NetworkVar("Int", 3, "TargetShipAccelerationLimit")

    self:NetworkVar("Bool", 0, "CanJumpIntoHyperspace")

    if SERVER then
        self:SetTargetShipAccelerationLimit(100)
        self:SetCanJumpIntoHyperspace(true)
    end
end

function ENT:GetShipAngles()
    return Angle(0,self:GetInternalShipAngleY(),0)
end

function ENT:SetShipAngles(angle)
    self:SetInternalShipAngleY(angle.y)
end

function ENT:GetTargetShipAngles()
    return Angle(0,self:GetInternalTargetShipAngleY(),0)
end

function ENT:SetTargetShipAngles(angle)
    self:SetInternalTargetShipAngleY(angle.y)
end

function ENT:Initialize()
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_NONE)

    self:SetModel("models/hunter/blocks/cube025x025x025.mdl")

    self.maxAcceleration = SWU.GlobalConfig.maxAcceleration

    if (SERVER) then
        local shipPos, shipAngle = SWU:ReadShipData()
        self:SetShipPos(shipPos or Vector(-1,0,0))
        self:SetShipAngles(shipAngle or Angle(0,80,0))
        self:SetTargetShipAngles(shipAngle or Angle(0,80,0))

        local controller = ents.FindByClass(self:GetClass())
        for i, v in ipairs(controller) do
            if (v ~= self) then
                v:Remove()
            end
        end
    else
        self:SetPredictable(true)
    end

    self:SetHyperspace(SWU.Hyperspace.OUT)

    SWU.Controller = self

    self.AccelerationPerPercent = 0.1
    self.LastAccelerationPerPercent = 0.1
    self.TurnSpeedPerDegree = 0.5

    self.TotalAccelerationTime = 0
    self.StartAcceleration = 0
    self.StartAccelerationTime = 0
    self.LastTargetAcceleration = 0

    self.LastTargetShipAngles = Angle()
    self.StartShipAngles = Angle()
    self.StartTurnTime = 0
    self.TotalTurnTime = 0

    if (SERVER) then
        self.Hyperspace = ents.Create("swu_hyperspace")
        self.Hyperspace:SetPos(self:GetPos())
        self.Hyperspace:SetAngles((SWU.config.shipOffsetRotation or Angle(0,180,0)) * -1)
        self.Hyperspace:SetModelScale(SWU.config.hyperspace.scale or 1)
        self.Hyperspace:Spawn()


        net.Receive("swu_setShipPos", function (len, ply)
            if (not ply:IsAdmin() and not ply:IsSuperAdmin()) then return end

            local pos = net.ReadVector()
            local ang = net.ReadAngle()

            self:SetShipPos(pos)
            self:SetTargetShipAngles(ang)
            self:SetShipAngles(ang)
        end)
    end
end

function ENT:Load(config)
    self:SetPos(config.controllerPos)
end

function ENT:AccelerateShip(accelerationPerPercentOverride)
    local targetAcceleration = self:GetTargetShipAcceleration()
    local currentAcceleration = self:GetCurrentShipAcceleration()
    local _accelerationPerPercent = (accelerationPerPercentOverride or self.AccelerationPerPercent)

    if (currentAcceleration == targetAcceleration and _accelerationPerPercent == self.LastAccelerationPerPercent) then return end

    if (targetAcceleration ~= self.LastTargetAcceleration or _accelerationPerPercent ~= self.LastAccelerationPerPercent) then
        self.LastTargetAcceleration = targetAcceleration
        self.StartAcceleration = currentAcceleration
        self.StartAccelerationTime = CurTime()
        self.TotalAccelerationTime = math.abs(targetAcceleration - currentAcceleration) * _accelerationPerPercent
        self.LastAccelerationPerPercent = _accelerationPerPercent
    end

    local startAccelerationTime = self.StartAccelerationTime
    local startAcceleration = self.StartAcceleration

    local ratio = (CurTime() - startAccelerationTime) / self.TotalAccelerationTime
    -- Check if ratio is NaN or inf
    if (ratio ~= ratio) then
        ratio = 1
    end

    local newCurrentAcceleration = Lerp(ratio, startAcceleration, targetAcceleration)

    if (ratio >= 1) then
        newCurrentAcceleration = targetAcceleration
    end
    self:SetCurrentShipAcceleration(newCurrentAcceleration)
end

local function f(t)
    return 1 / (1 * (1 + math.pow(t / (1 - t), -2)))
end

function ENT:TurnShip()
    local currentShipAngles = self:GetShipAngles()
    local targetShipAngles = self:GetTargetShipAngles()
    currentShipAngles:Normalize()
    targetShipAngles:Normalize()

    if (currentShipAngles == targetShipAngles) then return end

    if (targetShipAngles ~= self.LastTargetShipAngles) then
        self.LastTargetShipAngles = targetShipAngles
        self.StartShipAngles = currentShipAngles
        self.StartTurnTime = CurTime()
        local diff = targetShipAngles - currentShipAngles
        diff:Normalize()
        self.TotalTurnTime = math.abs(diff.y) * self.TurnSpeedPerDegree
    end

    local startTurnTime = self.StartTurnTime
    local startShipAngles = self.StartShipAngles

    local ratio = (CurTime() - startTurnTime) / self.TotalTurnTime

    local newCurrentAngles = LerpAngle(f(ratio), startShipAngles, targetShipAngles)

    if (ratio >= 1) then
        newCurrentAngles = targetShipAngles
    end
    self:SetShipAngles(newCurrentAngles)
end

function ENT:CheckCollide()
    if (not SWU.Configuration:GetConVar("swu_enable_planet_collision"):GetBool()) then return end

    for _, objects in pairs(SWU.ActiveChunks or {}) do
        for i, v in ipairs(objects) do
            if (IsValid(v.ent)) then
                v = v.ent
                if (v:GetPos():DistToSqr(self:GetPos()) <= math.pow(SWU.config.collisionRange + v:GetCollisionRange(), 2)) then
                    v:Collide()
                end
            end
        end
    end
end

function ENT:CheckTargetDestination()
    if (not SERVER or not IsValid(SWU.NavigationComputer) or SWU.NavigationComputer:GetTargetPlanet() == nil or SWU.NavigationComputer:GetTargetPlanet() == "") then return end

    local dist = self:GetShipPos():DistToSqr(SWU.NavigationComputer:GetTargetVector())
    local breakTime = 2.1 + 100 * (self.AccelerationPerPercent * 0.005)
    local hyperspaceSpeedModifier = SWU.Configuration:GetConVar("swu_hyperspace_speed_modifier"):GetFloat()
    local externalHyperspaceSpeedModifier = SWU.Configuration:GetConVar("swu_external_hyperspace_speed_modifier"):GetFloat()

    local breakDist = SWU.GlobalConfig.hyperspaceAcceleration.x * breakTime * (1 + (0.25 / hyperspaceSpeedModifier) / externalHyperspaceSpeedModifier)

    if (dist <= breakDist * breakDist) then
        SWU.NavigationComputer.Lever:ReceiveNetAction(nil, nil, false)
    end
end

function ENT:Think()
    local maxAcceleration = self.maxAcceleration
    local accelerationPerPercentOverride
    if (self:GetHyperspace() >= SWU.Hyperspace.TRANSITIONING) then
        maxAcceleration = SWU.GlobalConfig.hyperspaceAcceleration
        accelerationPerPercentOverride = self.AccelerationPerPercent * 0.005
    end

    if (self:GetHyperspace() == SWU.Hyperspace.IN) then
        accelerationPerPercentOverride = self.AccelerationPerPercent * 0.001
        self:CheckTargetDestination()
    end

    self:AccelerateShip(accelerationPerPercentOverride)
    if (self:GetHyperspace() == SWU.Hyperspace.OUT) then
        self:TurnShip()
    end

    if (self:GetHyperspace() ~= SWU.Hyperspace.IN) then
        self:CheckCollide()
    end

    local newPos = SWU:CalculateMovement(self:GetShipPos(), self:GetShipAngles(), self:GetCurrentShipAcceleration() * 0.01, maxAcceleration)
    self:SetShipPos(newPos)

    self:NextThink(CurTime())

    if (self.lastChunk ~= SWU.Util:VectorToChunk(self:GetShipPos())) then
        self:OnChunkChange()
    end

    return true
end

function ENT:GetInternalShipAngles()
    return self:GetShipAngles() + (SWU.config.shipOffsetRotation or Angle())
end

function ENT:OnChunkChange()
    self.lastChunk = SWU.Util:VectorToChunk(self:GetShipPos())

    if (SERVER) then
        SWU:LoadChunks(self:GetShipPos())
    end
end

function ENT:JumpIntoHyperspace()
    if (self:GetHyperspace() ~= SWU.Hyperspace.OUT) then return false end

    self:SetTargetShipAngles(self:GetShipAngles())
    self:SetTargetShipAcceleration(100)

    if (SERVER) then
        self.Hyperspace:Jump()
    end
    return true
end

function ENT:ExitHyperspace()
    if (self:GetHyperspace() ~= SWU.Hyperspace.IN) then return false end

    if (SERVER) then
        self.Hyperspace:Exit(function ()
            self:SetTargetShipAcceleration(0)
        end)
    end
    return true
end

function ENT:IsInHyperspace()
    return self:GetHyperspace() == SWU.Hyperspace.IN
end

function ENT:OnRemove()
    if (SERVER) then
        SWU:PersistShipData()
    end
end

--addons/starwars_universe/lua/entities/swu_hyperspace/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/starwars_universe/lua/entities/swu_hyperspace/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Controller"
ENT.Author = "The Coding Ducks"
ENT.Information = ""
ENT.Category = "[SWU] Universe"
ENT.AutomaticFrameAdvance = true

ENT.Spawnable = false

function ENT:Initialize()
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_NONE)

    if (SERVER) then
        self:SetModel(SWU.config.hyperspace.stars)
    end

    if (IsValid(SWU.Controller)) then
        self:SetPos(SWU.Controller:GetPos())
    end
    self:SetNoDraw(true)
end

function ENT:Load(config)
    self:SetPos(config.controllerPos)
end

function ENT:Think()
    self:NextThink(CurTime())
    return true
end

function ENT:Jump()
    if (SWU.Controller:GetHyperspace() ~= SWU.Hyperspace.OUT) then return end

    self:SetModel(SWU.config.hyperspace.stars)
    self:SetNoDraw(false)

    local id, duration = self:LookupSequence("in")
    self:ResetSequence(id)
    SWU.Controller:SetHyperspace(SWU.Hyperspace.TRANSITIONING)

    timer.Simple(duration - 0.1, function ()
        if (not IsValid(self)) then return end
        SWU.Controller:SetHyperspace(SWU.Hyperspace.IN)
        self:SetModel(SWU.config.hyperspace.tunnel)
        self:SetSkin(1)

        timer.Simple(0.2, function ()
            if (not IsValid(self)) then return end
            self:SetSkin(0)
        end)
    end)
end

function ENT:Exit(onExit)
    if (SWU.Controller:GetHyperspace() ~= SWU.Hyperspace.IN) then return end

    self:SetNoDraw(false)
    self:SetModel(SWU.config.hyperspace.tunnel)
    self:SetSkin(1)
    SWU.Controller:SetHyperspace(SWU.Hyperspace.TRANSITIONING)

    timer.Simple(0.2, function ()
        if (not IsValid(self)) then return end
        self:SetModel(SWU.config.hyperspace.stars)
        local id, duration = self:LookupSequence("out")
        self:ResetSequence(id)

        timer.Simple(duration - 0.1, function ()
            if (not IsValid(self)) then return end

            if (isfunction(onExit)) then
                onExit()
            end

            SWU.Controller:SetHyperspace(SWU.Hyperspace.OUT)
            self:SetNoDraw(true)
        end)
    end)
end
--addons/starwars_universe/lua/entities/swu_lever_hyperspace/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:ClientInitialize()
    self.Scale = 100
    self.ButtonWidth = 367
    self.ButtonHeight = 137
    self.Pos = 0
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:DrawTranslucent()
    local color
    local jumpHyperspace = SWU.Controller:IsInHyperspace()
    local parent = self:GetParent()
    if (not IsValid(parent) or not isfunction(parent.GetLoading)) then
        return
    end
    if (parent:GetLoading() or parent:GetEstimatedJumpTime() < 5) then
        color = Color(75, 75, 75)
    end
    if not SWU.Controller:GetCanJumpIntoHyperspace() then
        color = SWU.Colors.Default.error
    end
    if (SWU.Controller:GetHyperspace() == SWU.Hyperspace.TRANSITIONING) then
        if adraw.Entity3D2D(self, Vector(0.33, -1.84, 4.8), Angle(0, 90, 23), 1 / self.Scale) then
            adraw.xTextButton("", SWU.Fonts.PlainText, 0, 0, self.ButtonWidth, self.ButtonHeight, 4, color or Color(80,80,80), color or Color(255,255,255), color or Color(80,80,80))
            adraw.End3D2D()
        end
        return
    end
    if (not jumpHyperspace) then
        if adraw.Entity3D2D(self, Vector(0.33, -1.84, 4.8), Angle(0, 90, 23), 1 / self.Scale) then
            if adraw.xTextButton("JUMP", SWU.Fonts.PlainText, 0, 0, self.ButtonWidth, self.ButtonHeight, 4, color or Color(80,159,0), color or Color(255,255,255), color or Color(0,219,0)) then
                self:StartNetAction()
                net.WriteBool(not jumpHyperspace)
                net.SendToServer()
            end
            adraw.End3D2D()
        end
    else
        if adraw.Entity3D2D(self, Vector(0.33, -1.84, 4.8), Angle(0, 90, 23), 1 / self.Scale) then
            if adraw.xTextButton("ABORT", SWU.Fonts.PlainText, 0, 0, self.ButtonWidth, self.ButtonHeight, 4, color or Color(110,16,0), color or Color(255,255,255), color or Color(189,0,11)) then
                self:StartNetAction()
                net.WriteBool(not jumpHyperspace)
                net.SendToServer()
            end
            adraw.End3D2D()
        end
    end
end
--addons/starwars_universe/lua/entities/swu_lever_hyperspace/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Lever"
ENT.Author = "The Coding Ducks"
ENT.Information = ""
ENT.Category = "[SWU] Universe"

ENT.Spawnable = false

SWU = SWU or {}

function ENT:Initialize()
    self:SetModel("models/props_wasteland/panel_leverhandle001a.mdl")
    self:SetMoveType(MOVETYPE_NONE)
    self:SetCollisionGroup(COLLISION_GROUP_NONE)

    self.LeverLevelSpeed = 1.8

    self.StartLeverTime = 0
    self.StartLeverRatio = 0
    self.TargetLeverRatio = 0
    self.LastTargetLeverRatio = 0
    self.CurrentLeverRatio = 0
    self.TotalLeverSpeed = 0

    if (CLIENT) then
        self:ClientInitialize()
    end
end

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "LeverPos")
end

function ENT:Think()
    self.TargetLeverRatio = self:GetLeverPos()

    if (self.TargetLeverRatio ~= self.LastTargetLeverRatio) then
        self.LastTargetLeverRatio = self.TargetLeverRatio
        self.StartLeverTime = CurTime()
        self.StartLeverRatio = self.CurrentLeverRatio

        self.TotalLeverSpeed = self.LeverLevelSpeed
    end

    -- TODO: Only move if values have changed and ensure that the movement is still smooth
    local ratio = math.Clamp((CurTime() - self.StartLeverTime) / self.TotalLeverSpeed, 0, 1)
    self.CurrentLeverRatio = Lerp(ratio, self.StartLeverRatio, self.TargetLeverRatio)
    if (isvector(self:GetParent().StartLever) and isvector(self:GetParent().StopLever)) then
        self:SetLocalPos(LerpVector(self.CurrentLeverRatio,
                self:GetParent().StartLever,
                self:GetParent().StopLever))
    end
end
--addons/starwars_universe/lua/entities/swu_lever_speed/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Lever"
ENT.Author = "The Coding Ducks"
ENT.Information = ""
ENT.Category = "[SWU] Universe"

ENT.Spawnable = false

function ENT:Initialize()
    self:SetModel("models/props_wasteland/panel_leverhandle001a.mdl")
    self:SetMoveType(MOVETYPE_NONE)
    self:SetCollisionGroup(COLLISION_GROUP_NONE)

    self.LeverLevelSpeed = 0.3

    self.TotalLeverSpeed = 0
    self.CurrentLeverRatio = 0

    self.StartLeverTime = 0
    self.StartLeverRatio = 0
    self.TargetLeverRatio = 0
    self.LastTargetLeverRatio = 0

    if (CLIENT) then
        self:ClientInitialize()
    end
end

function ENT:Think()
    self.TargetLeverRatio = SWU.Controller:GetTargetShipAcceleration() / 20 / 5

    if (self.TargetLeverRatio ~= self.LastTargetLeverRatio) then
        self.LastTargetLeverRatio = self.TargetLeverRatio
        self.StartLeverTime = CurTime()
        self.StartLeverRatio = self.CurrentLeverRatio

        self.TotalLeverSpeed = math.abs(self.CurrentLeverRatio * 5 - self.TargetLeverRatio * 5) * self.LeverLevelSpeed
    end

    -- TODO: Only move if values have changed and ensure that the movement is still smooth
    local ratio = math.Clamp((CurTime() - self.StartLeverTime) / self.TotalLeverSpeed, 0, 1)
    self.CurrentLeverRatio = Lerp(ratio, self.StartLeverRatio, self.TargetLeverRatio)
    if (isvector(self:GetParent().StartLever) and isvector(self:GetParent().StopLever)) then
        self:SetLocalPos(LerpVector(self.CurrentLeverRatio,
                self:GetParent().StartLever,
                self:GetParent().StopLever))
    end
end
--addons/starwars_universe/lua/entities/swu_map/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize()
    self.Scale = 100
end

function ENT:Draw()
    --self:DrawModel()
end

local shipIcon = Material("the-coding-ducks/swu/ship-icon.png")
local planetIcon = Material("the-coding-ducks/swu/planet-icon.png")
local background = Material("the-coding-ducks/swu/map-background.png", "noclamp smooth")

function ENT:DrawShip(centerX, centerY, shipWidth, shipHeight)
    surface.SetDrawColor(255,255,255,255)
    surface.SetMaterial(shipIcon)
    local curShipAngle = SWU.Controller:GetShipAngles().y + 90
    adraw.DrawTexturedRectRotatedPoint(centerX, centerY, shipWidth, shipHeight, curShipAngle * -1, 0,0)
    if (adraw.IsHovering(centerX - (shipWidth * 0.5), centerY - (shipHeight * 0.35), shipWidth - 10, shipHeight - 130)) then
        return {{x = centerX + shipWidth * 0.3, y = centerY, name = "[" .. math.Round(SWU.Controller:GetShipPos().x, 3) .. ":" .. math.Round(SWU.Controller:GetShipPos().y, 3) .. "]"}}
    end
end

function ENT:DrawPlanets(centerX, centerY, planetW, planetH, shipPos, sw, sh)
    local toBeDrawnNames = {}

    for i, planet in ipairs(SWU.Map) do
        local scaleX, scaleY = 250 * self:GetModelScale(), 250 * self:GetModelScale()

        local pos = (planet:GetUniversePos() - shipPos)

        local canvasPosX, canvasPosY = centerX + pos.x * scaleX - planetW * 0.5, centerY + pos.y * -1 * scaleY - planetH * 0.5
        if (canvasPosX < 0 or canvasPosX > sw - planetW
                or canvasPosY < 0 or canvasPosY > sh - planetH) then
            goto con
        end

        local color = SWU.Colors.Default.primary
        if (adraw.IsHovering(canvasPosX, canvasPosY, planetW, planetH)) then
            color = Color(110, 219, 0)
            table.insert(toBeDrawnNames, {x = canvasPosX +  planetW * 0.5, y = canvasPosY + planetH * 0.5, name = planet:GetId()})
        end

        surface.SetMaterial(planetIcon)
        surface.SetDrawColor(color)
        surface.DrawTexturedRect(canvasPosX, canvasPosY, planetW, planetH)

        ::con::
    end

    return toBeDrawnNames
end

function ENT:DrawNames(toBeDrawnNames, planetW)
    for i, v in ipairs(toBeDrawnNames) do
        draw.SimpleTextOutlined(v.name:upper(), SWU.Fonts.PlainMapPlanet, v.x + planetW * 0.6, v.y, SWU.Colors.Default.passive, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 10, Color(24,24,24,255))
    end
end

function ENT:DrawTranslucent()
    if not IsValid(SWU.Controller) then return end

    local min, max = self:GetModelRenderBounds()
    min, max = min * self:GetModelScale(), max * self:GetModelScale()
    local h, w, z = max.x - min.x, max.y - min.y, max.z - min.z
    local startPoint = Vector(-h * 0.5, -w * 0.5, z * 0.5)


    if adraw.Entity3D2D(self, startPoint, Angle(0, 90, 0), 1 / self.Scale) then
        local sw, sh = w * self.Scale, h * self.Scale
        local centerX, centerY = sw * 0.5, sh * 0.5
        local shipPos = SWU.Controller:GetShipPos()

        surface.SetDrawColor(255,255,255,255)
        surface.SetMaterial(background)
        local scaleX, scaleY = 250 * self:GetModelScale(), 250 * self:GetModelScale()
        local tileSizeX, tileSizeY = sw / (w / 11), sh / (h / 11)
        local gridOffsetX, gridOffsetY = (shipPos.x % tileSizeX) / tileSizeX * scaleX, (shipPos.y % tileSizeY) / tileSizeY * scaleY
        surface.DrawTexturedRectUV(0,0,sw, sh, 0 + gridOffsetX, 0 - gridOffsetY, w / 11 + gridOffsetX, h / 11 - gridOffsetY)

        local shipWidth, shipHeight = shipIcon:Width() * 1.5, shipIcon:Height() * 1.5
        local planetW, planetH = shipWidth * 0.5, shipHeight * 0.5
        local toBeDrawnNames = self:DrawPlanets(centerX, centerY, planetW, planetH, shipPos, sw, sh)

        toBeDrawnNames = table.Add(toBeDrawnNames, self:DrawShip(centerX, centerY, shipWidth, shipHeight))

        self:DrawNames(toBeDrawnNames, planetW)

        adraw.End3D2D()
    end
end
--addons/starwars_universe/lua/entities/swu_navigation_computer/shared.lua:
ENT.Type        = "anim"
ENT.PrintName   = "[SWU] Navigation Computer"
ENT.Author      = "The Coding Ducks"
ENT.Information = ""
ENT.Category    = "[SWU] Universe"

ENT.Spawnable	= false

ENT.SWU_Interactable = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Pages")
    self:NetworkVar("Int", 1, "CurPage")

    self:NetworkVar("Float", 0, "Progress")
    self:NetworkVar("Float", 1, "JumpStartTime")
    self:NetworkVar("Float", 2, "EstimatedJumpTime")
    self:NetworkVar("Bool", 0, "Loading")

    self:NetworkVar("String", 0, "Planets")
    self:NetworkVar("String", 1, "TargetPlanet")
    self:NetworkVar("String", 2, "SearchTerm")

    self:NetworkVar("Angle", 0, "TargetAngle")
    self:NetworkVar("Vector", 0, "TargetVector")
end

function ENT:SetupUsedKeys()
    self.SWU_UsedKeys = {
        [KEY_PAD_ENTER] = SWU.Util:InteractableClient(self.OpenSearchBar),
        [KEY_ENTER] = SWU.Util:InteractableClient(self.OpenSearchBar),
        [KEY_LEFT] = SWU.Util:InteractableServer(self.SwitchPage, -1),
        [KEY_RIGHT] = SWU.Util:InteractableServer(self.SwitchPage, 1),
    }
end

function ENT:SharedInitialize()
    self.ProgressCalculationDuration = 5
    self.ProgressStart = 0

    self.StartLever = Vector(22, -3.6, 28)
    self.StopLever = Vector(13, -3.6, 30)

    SWU.NavigationComputer = self

    self:SetupUsedKeys()
end

function ENT:Think()
    if (self:GetLoading()) then
        if (self:GetProgress() == -1) then
            self.ProgressStart = CurTime()
        end

        local progress = math.min((CurTime() - self.ProgressStart) / self.ProgressCalculationDuration, 1)
        self:SetProgress(progress)
        if (progress >= 1) then
            self:SetLoading(false)
        end
    end

    if (CLIENT) then
        self:NextThink(CurTime())
        return true
    end
end

--addons/starwars_universe/lua/entities/swu_so_model_object/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if (SWU.Controller:GetHyperspace() == SWU.Hyperspace.IN) then return end

	self:DrawModel()
end

--addons/starwars_universe/lua/entities/swu_so_model_object/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Model Object"
ENT.Base = "swu_so_base"
ENT.AutomaticFrameAdvance = true

function ENT:PreInitialize()
    self.Model = self:GetObjectModel()
end

function ENT:PostLoad()
    self:SetModel(self:GetObjectModel())
end

function ENT:InheritanceChildInitialize()
    self:Rescale(1)

    if (CLIENT) then
        table.insert(SWU.Map, self)
    end
end

function ENT:Load(info)
    self:SetId(info.name)
    self:SetUniversePos(info.pos or Vector())
    self:SetUniverseAngles(info.angle or Angle())
    self:SetBaseScale(info.baseScale or 1)
    self:SetObjectModel(info.model)
    self.Model = info.model
    self:PostLoad()
end

function ENT:SetupExtraDataTables()
    self:NetworkVar("String", 1, "ObjectModel")
end

function ENT:Rescale(scale)
    scale = scale * self:GetBaseScale()

    self:SetModelScale(scale)

    local renderBoundsMin, renderBoundsMax = self:GetModelRenderBounds()

    if (CLIENT) then
        self:SetRenderBounds(renderBoundsMin * 1.005 * scale, renderBoundsMax * 1.01 * scale)
    end
end

function ENT:Collide()
end

function ENT:OnRemove()
    if (CLIENT) then
        table.RemoveByValue(SWU.Map, self)
    end
end

--addons/starwars_universe/lua/entities/swu_so_planet/cl_init.lua:
include("shared.lua")

function ENT:SetupRenderVars()
	self.renderVarsSetup = true

	self.terrainMat = Material(self:GetTerrainMaterial())
	self.cloudMat = Material(self:GetCloudMaterial())

	self.atmosphereColor = self:GetAtmosphereColor():ToColor()
end

local centerOrigin = Vector()
local white = Color(255,255,255)
function ENT:Draw()
	if (SWU.Controller:GetHyperspace() == SWU.Hyperspace.IN) then return end

	if (not self.renderVarsSetup) then
		self:SetupRenderVars()
	end

	self:DrawModel()

	if (self:GetAnimated()) then return end

	local terrainModelMatrix = cam.GetModelMatrix()
	terrainModelMatrix:SetTranslation(self:GetPos())
	terrainModelMatrix:Rotate(Angle(0,CurTime() % 360,0))

	local terrainRadius = self.PlanetRadius
	local cloudRadius = self.PlanetRadius * 1.005
	local atmosphereRadius = self.PlanetRadius * 1.01

	cam.PushModelMatrix(terrainModelMatrix)
	render.SetMaterial(self.terrainMat)
	render.DrawSphere(centerOrigin, terrainRadius, 50, 50, white)
	cam.PopModelMatrix()

	if (self:GetWeather()) then
		if (self.cloudMat ~= nil and not self.cloudMat:IsError()) then
			local cloudModelMatrix = cam.GetModelMatrix()
			cloudModelMatrix:SetTranslation(self:GetPos())
			cloudModelMatrix:Rotate(Angle(0,CurTime() % 360 * 3,0))

			cam.PushModelMatrix(cloudModelMatrix)
			render.SetMaterial(self.cloudMat)
			render.DrawSphere(centerOrigin, cloudRadius, 50, 50, white)
			cam.PopModelMatrix()
		end

		render.SetColorMaterial()
		render.DrawSphere(self.worldPos, atmosphereRadius, 50, 50, self.atmosphereColor)
	end
end
--addons/starwars_universe/lua/entities/swu_so_shipyard/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "[SWU] Model Object"
ENT.Base = "swu_so_base"
ENT.AutomaticFrameAdvance = true

function ENT:PreInitialize()
    self.Model = self:GetObjectModel()
end

function ENT:PostLoad()
    if (CLIENT) then return end

    self:SetModel("models/lordtrilobite/starwars/isd/imp_shipyard_128.mdl")

    self.PartA = ents.Create("base_gmodentity")
    self.PartA:SetParent(self)
    self.PartA:SetModel("models/lordtrilobite/starwars/isd/imp_shipyard_128.mdl")
    self.PartA:SetPos(self:GetPos())
    self.PartA:SetLocalAngles(Angle(0,120,0))
    self.PartA:SetModelScale(self:GetBaseScale())
    self.PartA:Spawn()

    self.PartB = ents.Create("base_gmodentity")
    self.PartB:SetParent(self)
    self.PartB:SetModel("models/lordtrilobite/starwars/isd/imp_shipyard_128.mdl")
    self.PartB:SetPos(self:GetPos())
    self.PartB:SetLocalAngles(Angle(0,-120,0))
    self.PartB:SetModelScale(self:GetBaseScale())
    self.PartB:Spawn()
end

function ENT:OnRemove()
    if (SERVER) then
        self.PartA:Remove()
        self.PartB:Remove()
    end
end

function ENT:InheritanceChildInitialize()
    self:Rescale(1)

    if (CLIENT) then
        table.insert(SWU.Map, self)
    end
end

function ENT:Load(info)
    self:SetId(info.name)
    self:SetUniversePos(info.pos or Vector())
    self:SetUniverseAngles(info.angle or Angle())
    self:SetBaseScale(info.baseScale or 1)
    self:SetObjectModel(info.model)
    self.Model = info.model

    self:PostLoad()
end

function ENT:SetupExtraDataTables()
    self:NetworkVar("String", 1, "ObjectModel")
end

function ENT:Rescale(scale)
    scale = scale * self:GetBaseScale()

    self:SetModelScale(scale)
    for i, v in ipairs(self:GetChildren()) do
        v:SetModelScale(scale)
    end

    local renderBoundsMin, renderBoundsMax = self:GetModelRenderBounds()

    if (CLIENT) then
        self:SetRenderBounds(renderBoundsMin * 1.005 * scale, renderBoundsMax * 1.01 * scale)
    end
end

function ENT:Collide()
end

function ENT:OnRemove()
    if (CLIENT) then
        table.RemoveByValue(SWU.Map, self)
    end
end

--addons/starwars_universe/lua/entities/swu_speed_controller/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize()
	self.Scale = 200
	self.BlockWidth = 0.2
	self.BlockHeight = 0.4
	self.BlockMarginVertical = 0.2
	self.BlockMarginHorizontal = 0.1

	self:SharedInitialize()
	self:SetupUsedKeys()
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if adraw.Entity3D2D(self, Vector(3, 6, 44), Angle(0, 90, 61), 1 / self.Scale) then
		local count = 1
		for i = 1, 5 do
			local isLimited = i*20 > SWU.Controller:GetTargetShipAccelerationLimit()

			local clr = SWU.Colors.Default.passive
			if self:GetCurrentSpeed() / 20 >= i then
				clr = SWU.Colors.Default.accent
			elseif isLimited then
				clr = SWU.Colors.Default.error
			end
			surface.SetFont(SWU.Fonts.TechAurabeshSpeed)
			local tW, tH = surface.GetTextSize(tostring(i))
			draw.SimpleText(i - 1, SWU.Fonts.TechAurabeshSpeed, -0.3 * self.Scale, (i - 0.8) * tH, clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)


			for j = 1, 20 do
				local color = Color(94, 94, 94)
				local highlighted = 0
				if count <= self:GetCurrentSpeed() then
					color = Color(255,255,255)
					highlighted = 0.05
				elseif isLimited then
					color = SWU.Colors.Default.error
				end
				draw.RoundedBox(0, (j - 1) * (self.BlockMarginHorizontal + self.BlockWidth) * self.Scale, (i - 1) * (self.BlockMarginVertical + self.BlockHeight) * self.Scale, (self.BlockWidth + highlighted) * self.Scale, (self.BlockHeight + highlighted) * self.Scale, color)
				count = count + 1
			end
		end
		adraw.End3D2D()
	end
end

function ENT:GetCurrentSpeed()
	if (not IsValid(SWU.Controller)) then return 0 end
	return SWU.Controller:GetCurrentShipAcceleration()
end

--addons/tfa_base/lua/entities/tfa_ammo_base.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "AmmoBase"
ENT.Category = "TFA Ammunition"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Class = ""
ENT.MyModel = "models/props_junk/popcan01a.mdl"
ENT.ImpactSound = "Default.ImpactSoft"
ENT.AmmoCount = 100
ENT.AmmoType = "357"
ENT.TextPosition = Vector(-2.5, -3.3, 4)
ENT.TextAngles = Vector(48, -90, 0)
ENT.TextColor = Color(240, 35, 35, 255)
ENT.DrawText = false
ENT.ShouldDrawShadow = true
ENT.ImpactSound = "Default.ImpactSoft"
ENT.DamageThreshold = 80
ENT.ExplosionOffset = Vector(0, 0, 10)
ENT.Damage = 30
ENT.TextOffX = 30
ENT.TextOffY = -20
ENT.TextScale = 1

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(ply, tr, classname)
		if (not tr.Hit) then return end
		local pos = tr.HitPos + tr.HitNormal * 4
		local ent = ents.Create(classname)
		ent:SetPos(pos)
		ent:Spawn()
		ent:Activate()
		ent.Class = classname
		ent.Spawner = ply

		return ent
	end

	function ENT:Initialize()
		local model = self.MyModel
		self.Class = self:GetClass()
		self:SetModel(model)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:DrawShadow(self.ShouldDrawShadow)
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetUseType(SIMPLE_USE)
		self:SetHealth(self.DamageThreshold)
		self:SetNW2Bool("ShouldRemove", false)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
		end
	end

	function ENT:PhysicsCollide(data, physobj)
		if (data.Speed > 60 and data.DeltaTime > 0.2) then
			self:EmitSound(self.ImpactSound)
		end
	end

	function ENT:Use(activator, caller)
		if IsValid(activator) and activator:IsPlayer() then
			activator:GiveAmmo(self.AmmoCount, self.AmmoType)
			self:SetNW2Bool("ShouldRemove", true)
		end
	end

	local bul = {}
	local randvec = Vector(0, 0, 0)
	bul.Tracer = 3
	bul.Num = 1
	bul.TracerName = "Tracer"
	bul.Spread = Vector(0, 0, 0)

	local cv_dc = GetConVar("sv_tfa_ammo_detonation_chain")
	local cv_dm = GetConVar("sv_tfa_ammo_detonation_mode")
	function ENT:OnTakeDamage(dmginfo)
		if not IsValid(self) then return end
		local at = dmginfo:GetInflictor()
		local shouldtakedamage = true

		if IsValid(at) then
			local base = at.Base

			if (base and string.find(base, "tfa_ammo_base")) or string.find(at:GetClass(), "tfa_ammo_") and not cv_dc:GetBool() then
				shouldtakedamage = false
			end
		end

		if dmginfo:GetDamage() < 1 then
			shouldtakedamage = false
		end

		self.Attacker = at

		if shouldtakedamage then
			self:SetHealth(self:Health() - dmginfo:GetDamage())
		end

		self:EmitSound(self.ImpactSound)
		local phy = self:GetPhysicsObject()

		if IsValid(phy) then
			local f = dmginfo:GetDamageForce()
			local p = dmginfo:GetDamagePosition()

			if f and p then
				phy:ApplyForceOffset(f / 4, p)
			end
		end
	end

	function ENT:Think()
		if self:GetNW2Bool("ShouldRemove", false) then
			self:Remove()

			return false
		end

		if not cv_dc:GetBool() then return true end

		if self:Health() <= 0 then
			self:EmitSound(self.ImpactSound)
			local adm = cv_dm:GetInt()
			bul.AmmoType = self.AmmoType
			bul.Damage = self.Damage
			bul.Force = math.Max(self.Damage / 25, 0.1)
			bul.Attacker = self

			if IsValid(self.Attacker) then
				bul.Attacker = self.Attacker
			end

			local upang = self:GetAngles():Up()
			bul.Dir = upang + randvec * 0.75
			local numbuls = math.random(math.Round(self.AmmoCount * 0.25), math.Round(self.AmmoCount * 0.75))
			local i = 1

			if adm == 2 then
				bul.Damage = bul.Damage / 2
			end

			bul.Dir = (upang + randvec * 0.75):GetNormalized()
			bul.Src = self:GetPos()
			self:FireBullets(bul)

			if adm ~= 1 then
				while i <= math.Clamp(numbuls, 1, 35) do
					randvec.x = math.Rand(-1, 1)
					randvec.y = math.Rand(-1, 1)
					randvec.z = math.Rand(-1, 1)
					bul.Dir = (upang + randvec * 0.75):GetNormalized()
					bul.Src = self:GetPos()
					self:FireBullets(bul)
					i = i + 1
				end
			end

			local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos())
			effectdata:SetMagnitude(0.1)
			effectdata:SetScale(0.5)

			if adm == 1 then
				bul.Damage = bul.Damage * 3 / 4
			end

			if adm > 0 then
				util.BlastDamage(bul.Attacker, bul.Attacker, bul.Src, (bul.Damage * 6 + 128) / 2, bul.Damage * 2)
				util.Effect("Explosion", effectdata)
			end

			if adm ~= 1 then
				util.Effect("cball_explode", effectdata)
			end

			self:SetNW2Bool("ShouldRemove", true)
		end
	end
end

if CLIENT then
	function ENT:Initialize()
		self.Class = self:GetClass()
	end

	function ENT:Draw()
		self:DrawModel()

		if self.TextPosition and self.TextAngles and self.DrawText then
			local pos = self:GetPos() + (self:GetUp() * self.TextPosition.z) + (self:GetRight() * self.TextPosition.x) + (self:GetForward() * self.TextPosition.y)
			local ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Right(), self.TextAngles.x)
			ang:RotateAroundAxis(ang:Up(), self.TextAngles.y)
			ang:RotateAroundAxis(ang:Forward(), self.TextAngles.z)

			if not self.Text then
				self.Text = string.upper(self.AmmoType)
			end

			cam.Start3D2D(pos, ang, .07 * self.TextScale)
			draw.SimpleText(self.Text, "DermaLarge", self.TextOffX, self.TextOffY, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end
	end
end

--addons/egm_tfa_grenades/lua/entities/tfa_csgo_fire_1/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Damage = 1

function ENT:Draw()
end

function ENT:Initialize()
	self.Damage = 1
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
		for i = 1, 20 do
			local fire = ents.Create("info_particle_system")
			if (i < 2) then
				fire:SetKeyValue("effect_name","molotov_fire_main_gm")
			else
				fire:SetKeyValue("effect_name","molotov_fire_child_gm")
			end
			local pos = self:GetPos()
			//fire:SetPos( Vector( pos.x + 100 * math.sin( math.rad( i * 20 ) ), pos.y + 100 * math.cos( math.rad( i * 20 ) ), pos.z ) )
			fire:SetPos( Vector( pos.x + math.Rand(0, 144) * math.sin( math.rad( i * math.Rand( 0, 180 ) ) ), pos.y + math.Rand(0, 144) * math.cos( math.rad( i * math.Rand( 0, 180 ) ) ), pos.z ) )
			fire:SetAngles( self:GetAngles() )
			fire:SetParent( self )
			fire:Spawn()
			fire:Activate()
			fire:Fire("Start","",0)
			fire:Fire("Kill","",8)
		end
	end
	self:NextThink( CurTime() )
end

function ENT:Think()
	if SERVER then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 150 ) ) do
			if v:IsPlayer() or v:IsNPC() then
				if v:GetPos():Distance( self:GetPos() ) < 150 then
					damage = DamageInfo()
					damage:SetDamage( math.random( 3, 7 ) )
					damage:SetAttacker( self:GetOwner() )
					damage:SetInflictor( self:GetCreator() )
					damage:SetDamageType( DMG_BURN )
					v:TakeDamageInfo( damage )
				end
			end
		end
	end
	if self:GetNWBool("extinguished",true) then
		if not self.PlayedSound then
			self:EmitSound("TFA_CSGO_Molotov.Extinguish")
			self.PlayedSound = true
		end
		if SERVER then
			SafeRemoveEntity( self )
		end
	end
	self:NextThink( CurTime() + math.Rand( 0.2, 0.7 ) )
end
--addons/tfa_base/lua/entities/tfa_thrown_blade/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/tfa_base/lua/entities/tfa_thrown_blade/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Thrown Blade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true

ENT.HitSounds = {
	[MAT_DIRT] = {Sound("physics/metal/metal_grenade_impact_hard1.wav"), Sound("physics/metal/metal_grenade_impact_hard2.wav"), Sound("physics/metal/metal_grenade_impact_hard3.wav")},
	[MAT_FLESH] = {Sound("physics/flesh/flesh_impact_bullet1.wav"), Sound("physics/flesh/flesh_impact_bullet2.wav"), Sound("physics/flesh/flesh_impact_bullet3.wav")}
}

ENT.ImpactSound = Sound("weapons/blades/impact.mp3")
--addons/tfa_base/lua/entities/tfbow_arrow_stuck/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "TFBow Arrow Stuck"
ENT.Author = "TheForgottenArchitect"
ENT.Contact = "Don't"
ENT.Purpose = "Arrow Entity"
ENT.Instructions = "Arrow that's stuck in ground"

local cv_al = GetConVar("sv_tfa_arrow_lifetime")

function ENT:Initialize()
	if SERVER then
		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat(), function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(2)
		end

		if IsValid(self) and self.SetUseType then
			self:SetUseType(SIMPLE_USE)
		end
	end

	if (self:GetModel() and self:GetModel() == "") then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	self:SetOwner(nil)
	self.PhysicsCollide = function() end
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	local phys = self:GetPhysicsObject()

	if (phys:IsValid()) then
		phys:Sleep()
	end
end

function ENT:Use(activator, caller)
	if activator:IsPlayer() and activator:GetWeapon(self.gun) then
		activator:GiveAmmo(1, activator:GetWeapon(self.gun):GetPrimaryAmmoType(), false)
		self:Remove()
	end
end

--addons/tfa_base/lua/entities/tfbow_arrow_stuck_clientside/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if IsValid( self:GetParent() ) then
		self:GetParent():SetupBones()
	end
	self:SetupBones()
	self:DrawModel()
end
--addons/emplacements/lua/entities/turret_grenade_deployable/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "CW:RP Geschütze"
ENT.PrintName 		= "Grenade Launcher Deployable"
ENT.Author			= "Wolly/BOT_09 | Airfox"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.IsTurret		= true

ENT.TurretFloatHeight=3
ENT.TurretModelOffset=Vector(0,0,44)
ENT.TurretTurnMax=0.7

ENT.LastShot=0
ENT.ShotInterval = 5


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end



function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
			-- local effectPosAng = self:GetAttachment(self.MuzzleAttachment)
			-- local vPoint = effectPosAng.Pos
			-- local effectdata = EffectData()
			-- effectdata:SetStart( vPoint )
			-- effectdata:SetOrigin( vPoint )
			-- effectdata:SetAngles(effectPosAng.Ang + Angle(0,-90,0))
			-- effectdata:SetEntity(self)
			-- effectdata:SetScale( 1 )
			-- util.Effect( "MuzzleEffect", effectdata )
			
		--elseif SERVER then
			self:EmitSound(self.ShotSound,50,100)
			
			
		end
		
		if IsValid(self.shootPos) and SERVER then

			local nade = ents.Create("turret_40mm_frag")
			local attachAng=self:GetAttachment(self.MuzzleAttachment)
			nade:SetPos(self.shootPos:GetPos())
			nade:SetAngles(self:GetAngles() + Angle(self:GetAngles().p,-90,0))
			nade:Spawn()
			nade:SetOwner(self.Shooter)
			nade.flightvector = self:GetRight() * 75
			--self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-10000 )
			--[[local b = ents.Create( "info_target" )
			if (IsValid(b)) then
				b:SetPos( self.Shooter:GetEyeTrace( ).HitPos )
				b:Spawn( )
				--nade:Launch()
				nade:PointAtEntity( b )
				b:Remove( )
			end]]--
			
			
		end
		
		self.LastShot=CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--addons/wos-grandmaster-einf/lua/entities/wos_alcs_inner_fear/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
--addons/wos-alcs-custom/lua/entities/wos_character_station/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "Character Skill Station"
ENT.Author		= "King David"
ENT.Contact		= ""
ENT.Category = "wiltOS Technologies"
ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:Think()
	if not self.BuildingSound then
		self.BuildingSound = CreateSound( self.Entity, "ambient/levels/citadel/citadel_hub_ambience1.mp3" )
		self.BuildingSound:Play()
	end
end

function ENT:OnRemove()
	self.BuildingSound:Stop()
end
--addons/wos-alcs-custom/lua/entities/wos_duel_dome/shared.lua:
ENT.Type = 			"anim"
ENT.Base 			= "base_anim"


function ENT:SetupDataTables()

	self:NetworkVar( "String", 0, "Title" )

	self:NetworkVar( "Int", 0, "MaxDuelHealth" )
	
	self:NetworkVar( "Entity", 0, "Rival" )
	self:NetworkVar( "Entity", 1, "Duelist" )
	
	self:NetworkVar( "Bool", 0, "Started" )
	self:NetworkVar( "Bool", 1, "HasStarted" )

	self:NetworkVar( "Float", 0, "Radius" )
	self:NetworkVar( "Float", 1, "TimeLimit" )
	self:NetworkVar( "Float", 2, "Stake" )
	
end

--addons/wos-alcs-custom/lua/entities/wos_dueling_station/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "Dueling Station"
ENT.Author		= "King David"
ENT.Contact		= ""
ENT.Category = "wiltOS Technologies"
ENT.Spawnable			= false
ENT.AdminSpawnable		= true

function ENT:Think()
	if not self.BuildingSound then
		self.BuildingSound = CreateSound( self.Entity, "ambient/machines/combine_shield_loop3.wav" )
		self.BuildingSound:Play()
	end
end

function ENT:OnRemove()
	self.BuildingSound:Stop()
end
--addons/wos-alcs-custom/lua/entities/wos_item_base/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "Modular Item Base"
ENT.Author		= "King David"
ENT.Contact		= ""
ENT.Category = "wiltOS Technologies"
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

function ENT:SetupDataTables()
	self:NetworkVar( "String", 0, "ItemName" )
	self:NetworkVar( "String", 1, "ItemDescription" )
	self:NetworkVar( "String", 2, "RarityName" )
	self:NetworkVar( "Int", 0, "ItemType" )
	self:NetworkVar( "Int", 1, "Amount" )
	self:NetworkVar( "Vector", 0, "RColor" )
end


--addons/wos-alcs-custom/lua/entities/wos_sonic_discharge/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
--addons/wos-alcs-blades-anzati/lua/effects/anzati_hearts/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/heart", pos2 )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor11/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor11", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor7/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor7", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/effect_sw_laser_blue_akimbo/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_blue_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_red/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_white_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_white_main")
local MaterialFront = Material("effects/sw_laser_white_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/gdcw_universal_impact_t/init.lua:

					//Sound,Impact

					// 1        2       3      4      5
					//Dirt, Concrete, Metal, Glass, Flesh

					// 1     2     3      4      5      6      7      8         9
					//Dust, Dirt, Sand, Metal, Smoke, Wood,  Glass, Blood, YellowBlood
local mats={				
	[MAT_ALIENFLESH]		={5,9},
	[MAT_ANTLION]			={5,9},
	[MAT_BLOODYFLESH]		={5,8},
	[MAT_CLIP]			={3,5},
	[MAT_COMPUTER]			={4,5},
	[MAT_FLESH]			={5,8},
	[MAT_GRATE]			={3,4},
	[MAT_METAL]			={3,4},
	[MAT_PLASTIC]			={2,5},
	[MAT_SLOSH]			={5,5},
	[MAT_VENT]			={3,4},
	[MAT_FOLIAGE]			={1,5},
	[MAT_TILE]			={2,5},
	[MAT_CONCRETE]			={2,1},
	[MAT_DIRT]			={1,2},
	[MAT_SAND]			={1,3},
	[MAT_WOOD]			={2,6},
	[MAT_GLASS]			={4,7},
}

local sounds={
	[1]={"Bullet.Dirt",},
	[2]={"Bullet.Concrete",},
	[3]={"Bullet.Metal",},
	[4]={"Bullet.Glass",},
	[5]={"Bullet.Flesh",},
}

function EFFECT:Init(data)
	self.Origin = data:GetOrigin()
	self.DirVec = data:GetNormal()
	self.Scale  = data:GetScale()
	self.Radius = data:GetRadius()
	self.Emitter = ParticleEmitter( self.Origin )

	self.Mat=math.ceil(self.Radius)


	
	if(self.Mat != nil)then
		if     mats[self.Mat][2]==1 then	self:Dust()	
		elseif mats[self.Mat][2]==2 then	self:Dirt()
		elseif mats[self.Mat][2]==3 then	self:Sand()
		elseif mats[self.Mat][2]==4 then	self:Metal()
		elseif mats[self.Mat][2]==5 then	self:Smoke()
		elseif mats[self.Mat][2]==6 then	self:Wood()
		elseif mats[self.Mat][2]==7 then	self:Glass()
		elseif mats[self.Mat][2]==8 then	self:Blood()
		elseif mats[self.Mat][2]==9 then	self:YellowBlood()
		else 					self:Smoke()
		end
	else
		self:Dirt()
	end
end
 
 function EFFECT:Dust()
	sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 15*self.Scale do
		local Smoke = self.Emitter:Add( "particles/smokey", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,500*self.Scale) + VectorRand():GetNormalized()*100*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2.5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 12*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 300 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 130,125,115 )
		end
	end

	for i=0, 10*self.Scale do
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,400*self.Scale) + VectorRand():GetNormalized()*20*self.Scale )
		Smoke:SetDieTime( math.Rand( 0.5 , 1.5 )*self.Scale )
		Smoke:SetStartAlpha( 150 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 105,100,90 )
		end
	end

	for i=0, 10*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Origin )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(200,300*self.Scale) + VectorRand():GetNormalized() * 300*self.Scale )
		Debris:SetDieTime( math.random( 0.6, 1) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(2,5*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 105,100,90 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 1 )			
		end
	end
	
		for i=0,1 do 
			local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
			if (Flash) then
			Flash:SetVelocity( self.DirVec*100 )
			Flash:SetAirResistance( 200 )
			Flash:SetDieTime( 0.1 )
			Flash:SetStartAlpha( 255 )
			Flash:SetEndAlpha( 0 )
			Flash:SetStartSize( math.Rand( 30, 40 )*self.Scale )
			Flash:SetEndSize( 0 )
			Flash:SetRoll( math.Rand(180,480) )
			Flash:SetRollDelta( math.Rand(-1,1) )
			Flash:SetColor(255,255,255)	
			end
		end
 end
 
 function EFFECT:Dirt()
		sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 15*self.Scale do
		local Smoke = self.Emitter:Add( "particles/smokey", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,500*self.Scale) + VectorRand():GetNormalized()*100*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2.5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 12*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 300 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 90,85,75 )
		end
	end

	for i=0, 10*self.Scale do
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,400*self.Scale) + VectorRand():GetNormalized()*20*self.Scale )
		Smoke:SetDieTime( math.Rand( 0.5 , 1.5 )*self.Scale )
		Smoke:SetStartAlpha( 200 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 90,85,75 )
		end
	end

	for i=0, 15*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Origin )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(200,300*self.Scale) + VectorRand():GetNormalized() * 300*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 1.25) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,7*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 1 )			
		end
	end
	
		for i=0,1 do 
			local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
			if (Flash) then
			Flash:SetVelocity( self.DirVec*100 )
			Flash:SetAirResistance( 200 )
			Flash:SetDieTime( 0.1 )
			Flash:SetStartAlpha( 255 )
			Flash:SetEndAlpha( 0 )
			Flash:SetStartSize( math.Rand( 10, 20 )*self.Scale )
			Flash:SetEndSize( 0 )
			Flash:SetRoll( math.Rand(180,480) )
			Flash:SetRollDelta( math.Rand(-1,1) )
			Flash:SetColor(255,255,255)	
			end
		end
 end

 function EFFECT:Sand()
		sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 15*self.Scale do
		local Smoke = self.Emitter:Add( "particles/smokey", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,500*self.Scale) + VectorRand():GetNormalized()*100*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2.5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 60, 80 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 12*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 300 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 120,110,90 )
		end
	end

	for i=0, 20*self.Scale do
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,400*self.Scale) + VectorRand():GetNormalized()*20*self.Scale )
		Smoke:SetDieTime( math.Rand( 0.5 , 1.5 )*self.Scale )
		Smoke:SetStartAlpha( 150 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 120,110,90 )
		end
	end

	
 end

 function EFFECT:Metal()
			sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 15*self.Scale do
		local Smoke = self.Emitter:Add( "particle/smokestack", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 0,50*self.Scale) + VectorRand():GetNormalized()*200*self.Scale )
		Smoke:SetDieTime( math.Rand( 3 , 7 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 50, 70 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 40*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 300 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 100,100,100 )
		end
	end
	
		for i=0,3 do 
			local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
			if (Flash) then
			Flash:SetVelocity( self.DirVec*100 )
			Flash:SetAirResistance( 200 )
			Flash:SetDieTime( 0.1 )
			Flash:SetStartAlpha( 255 )
			Flash:SetEndAlpha( 0 )
			Flash:SetStartSize( math.Rand( 20, 30 )*self.Scale^2 )
			Flash:SetEndSize( 0 )
			Flash:SetRoll( math.Rand(180,480) )
			Flash:SetRollDelta( math.Rand(-1,1) )
			Flash:SetColor(255,255,255)	
			end
		end

 	 
 		for i=0, 20*self.Scale do 
 			local particle = self.Emitter:Add( "effects/spark", self.Origin ) 
 			if (particle) then 
 			particle:SetVelocity( ((self.DirVec*0.75)+VectorRand()) * math.Rand(50, 300)*self.Scale ) 
 			particle:SetDieTime( math.Rand(0.3, 0.5) ) 				 
 			particle:SetStartAlpha( 255 )  				 
 			particle:SetStartSize( math.Rand(4, 6)*self.Scale ) 
 			particle:SetEndSize( 0 ) 				 
 			particle:SetRoll( math.Rand(0, 360) ) 
 			particle:SetRollDelta( math.Rand(-5, 5) ) 				 
 			particle:SetAirResistance( 20 ) 
 			particle:SetGravity( Vector( 0, 0, -600 ) ) 
 			end 
			
		end 

end


 function EFFECT:Smoke()
		sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 15*self.Scale do
		local Smoke = self.Emitter:Add( "particle/smokestack", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 20,70*self.Scale) + VectorRand():GetNormalized()*150*self.Scale )
		Smoke:SetDieTime( math.Rand( 3 , 7 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 50, 70 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 50*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) ) ) 			
		Smoke:SetColor( 100,100,100 )
		end
	end

	for i=0, 15*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Origin )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,100*self.Scale) + VectorRand():GetNormalized() * 300*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 1) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(1,3*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 1 )			
		end
	end

		for i=0,1 do 
			local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
			if (Flash) then
			Flash:SetVelocity( self.DirVec*100 )
			Flash:SetAirResistance( 200 )
			Flash:SetDieTime( 0.1 )
			Flash:SetStartAlpha( 255 )
			Flash:SetEndAlpha( 0 )
			Flash:SetStartSize( math.Rand( 10, 20 )*self.Scale^2 )
			Flash:SetEndSize( 0 )
			Flash:SetRoll( math.Rand(180,480) )
			Flash:SetRollDelta( math.Rand(-1,1) )
			Flash:SetColor(255,255,255)	
			end
		end
 end

 function EFFECT:Wood()
		sound.Play( "Bullet.Impact", self.Origin)
	self.Emitter = ParticleEmitter( self.Origin )
		
	for i=0, 5*self.Scale do
		local Smoke = self.Emitter:Add( "particle/smokestack", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 20,70*self.Scale) + VectorRand():GetNormalized()*150*self.Scale )
		Smoke:SetDieTime( math.Rand( 3 , 7 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 40, 60 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 50*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) ) ) 			
		Smoke:SetColor( 100,100,100 )
		end
	end

	for i=0, 10*self.Scale do
		local Smoke = self.Emitter:Add( "particle/smokestack", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 20,70*self.Scale) + VectorRand():GetNormalized()*150*self.Scale )
		Smoke:SetDieTime( math.Rand( 3 , 7 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 40, 60 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 20*self.Scale )
		Smoke:SetEndSize( 50*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) * self.Scale, math.Rand(-70, 70) ) ) 			
		Smoke:SetColor( 90,85,75 )
		end
	end

	for i=0, 15*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_wood"..math.random(1,2), self.Origin+self.DirVec )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,300*self.Scale) + VectorRand():GetNormalized() * 300*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 1) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,6*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.5 )			
		end
	end

 end

 function EFFECT:Glass()

	
	for i=0, 10*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Origin+self.DirVec )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,200)*self.Scale + VectorRand():GetNormalized() * 60*self.Scale )
		Debris:SetDieTime( math.random( 1, 1.5) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(2,4*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 100,100,100 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.3 )			
		end
	end

	for i=0, 20*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Origin )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec*-1 * math.random(50,300)*self.Scale + VectorRand():GetNormalized() * 60*self.Scale )
		Debris:SetDieTime( math.random( 0.5, 1) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(2,4*self.Scale) )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 100,100,100 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
	end
 end

 function EFFECT:Blood()

	for i=0, 10*self.Scale do
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(0,50)*self.Scale )
		Smoke:SetDieTime( math.Rand( 0.3 , 0.7 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
	end

 end

 function EFFECT:YellowBlood()

	for i=0, 10*self.Scale do
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(0,70)*self.Scale )
		Smoke:SetDieTime( math.Rand( 0.3 , 0.7 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -100) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
	end
 end
 

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--addons/lvs_starwars/lua/effects/lvs_laat_right_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_right" )
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTRFire() then
		return false
	end
	
	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )

			local vel = VectorRand()  * 100 + dir * 40

			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--addons/lvs_starwars/lua/effects/lvs_laser_blue_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_impact.lua:
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local trace = util.TraceLine( {
		start = self.Pos - self.Dir,
		endpos = self.Pos + self.Dir,
		mask = MASK_SOLID_BRUSHONLY,
	} )

	self.Flat = trace.Hit and not trace.HitSky

	local Col = self.Col
	local Pos = self.Pos

	local emitter = ParticleEmitter( Pos, false )

	for i = 0, 10 do
		local particle = emitter:Add( "sprites/light_glow02_add", Pos )

		local vel = VectorRand() * 200 + self.Dir  * 80

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( Col.x,Col.y,Col.z )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	local S1 = 200 * Scale
	local S2 = 50 * Scale

	if self.Flat then
		cam.Start3D2D( self.Pos + self.Dir, self.Dir:Angle() + Angle(90,0,0), 1 )
			surface.SetMaterial( self.GlowMat )
			surface.SetDrawColor( self.Col.x, self.Col.y, self.Col.z, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S1 , S1 , 0 )

			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S2 , S2 , 0 )
		cam.End3D2D()
	end

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos + self.Dir, S1, S1, Color( self.Col.x, self.Col.y, self.Col.z, 255 ) )
	render.DrawSprite( self.Pos + self.Dir, S2, S2, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_tracer_yellow.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 125, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 80, 0, 255 ) )
end

--addons/egm_lvs_ground/lua/effects/lvs_tx130_projector.lua:
EFFECT.Mat = Material("effects/lvs/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init(data)
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment("lazer_cannon_muzzle")

		if self.ID then
			local Muzzle = self.Entity:GetAttachment(self.ID)
			self:SetRenderBoundsWS(self.Entity:GetPos(), Muzzle.Ang:Up() * 100000)
		end
	end
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end

	return true
end


function EFFECT:Render()
	--if not self.ID or not IsValid(self.Entity) then return end

	local Muzzle = self.Entity:GetAttachment(self.ID)

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine({start = StartPos, endpos = StartPos + Dir * 100000, filter = self})
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS(StartPos, EndPos)

	render.SetMaterial(self.Mat)
	render.DrawBeam(StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,0,255,255))
	render.DrawBeam(StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255))

	render.SetMaterial(self.HitMat)
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite(StartPos, A, A, Color(0,0,255,255))
	render.DrawSprite(StartPos, B, B, Color(255,255,255,255))

	render.DrawSprite(EndPos, A, A, Color(0,0,255,255) )
	render.DrawSprite(EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter(EndPos, false)
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

		for i = 0, 10 do
			local particle = emitter:Add("sprites/rico1", EndPos)
			local vel = VectorRand() * 100 + dir * 40

			if particle then
				particle:SetVelocity(vel)
				particle:SetAngles(vel:Angle() + Angle(0, 90, 0))
				particle:SetDieTime(math.Rand(0.1, 0.3) * 0.5)
				particle:SetStartAlpha(math.Rand(200, 255))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(1, 30))
				particle:SetEndSize(0)
				particle:SetRoll(math.Rand(-100, 100))
				particle:SetRollDelta(math.Rand(-100, 100))
				particle:SetAirResistance(0)
			end
		end

		emitter:Finish()
	end
end

--addons/egm_lvs_ground/lua/effects/missile_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init(data)
	local Pos = data:GetOrigin()
	self.Pos = Pos

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	self.mat = Material("sprites/light_glow02_add")

	sound.Play("LAATc_ATTE_EXPLOSION", Pos, 95, 140, 1)
	self:Explosion(Pos)
end

function EFFECT:Explosion(pos)
	local emitter = ParticleEmitter(pos, false)
	if not emitter then return end

	for i = 0,30 do
		local particle = emitter:Add(Materials[math.random(1,table.Count(Materials))], pos)
		if particle then
			particle:SetVelocity(VectorRand(-1,1) * 800)
			particle:SetDieTime(math.Rand(4,6))
			particle:SetAirResistance(math.Rand(200,600))
			particle:SetStartAlpha(100)
			particle:SetStartSize(math.Rand(30, 60))
			particle:SetEndSize(math.Rand(100, 150))
			particle:SetRoll(math.Rand(-1, 1))
			particle:SetColor(50, 50, 50)
			particle:SetGravity(Vector(0, 0, 100))
			particle:SetCollide(false)
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add("sprites/light_glow02_add", pos)

		local vel = VectorRand() * 400

		if particle then
			particle:SetVelocity(vel)
			particle:SetAngles(vel:Angle() + Angle(0,90,0))
			particle:SetDieTime(math.Rand(0.4,0.8))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(24,48))
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(-100,100))
			particle:SetRollDelta(math.Rand(-100,100))
			particle:SetColor(0,127,255)
			particle:SetGravity(Vector(0,0,-600))
			particle:SetAirResistance(0)
			particle:SetCollide(true)
			particle:SetBounce(0.5)
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add("sprites/flamelet" .. math.random(1, 5), pos)
		if particle then
			particle:SetVelocity(VectorRand(-1,1) * 500)
			particle:SetDieTime(0.14)
			particle:SetStartAlpha(255)
			particle:SetStartSize(10)
			particle:SetEndSize(math.Rand(30,60))
			particle:SetEndAlpha(100)
			particle:SetRoll(math.Rand(-1, 1))
			particle:SetColor(200,150,150)
			particle:SetCollide(false)
		end
	end

	local dlight = DynamicLight(math.random(0,9999))
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 200
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial(self.mat)
	render.DrawSprite(self.Pos, 400 * Scale, 400 * Scale, Color(0, 127, 255, 255))
	render.DrawSprite(self.Pos, 100 * Scale, 100 * Scale, Color(255, 255, 255, 255))
end

--lua/effects/rw_sw_dual_laser_blue.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 30
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_green.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_green_main")
local MaterialFront 		= Material("effects/sw_laser_green_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_lightblue.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_lightblue")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_lightblue")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 210
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_impact_grey.lua:
local MaterialGlow		= Material( "cs574/impacts/sw_laser_bit_grey" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_red.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_red" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_yellow.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_yellow" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_laser_lightblue.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_lightblue")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_lightblue")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 210
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_laser_purple.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_purple_main" )
local MaterialFront			= Material( "effects/sw_laser_purple_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 125
			dlight.g = 0
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_muzzleflash_lightblue.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,160,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_white.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,255,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/sw_explosion.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	
	self:Explosion( Pos )
	
	sound.Play( "ambient/explosions/explode_4.wav", Pos, 95, 200, 0.5 )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,20 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 800 )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetAirResistance( math.Rand(1000,1500) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(5,15) )
			particle:SetEndSize( math.Rand(30,50) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 20,20,20 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.15) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(6,12) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 300 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( math.Rand(10,20) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
	
	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 100
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/tfa_base/lua/effects/tfa_muzzleflash_cryo/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.5
EFFECT.HeatSize = 1.5
EFFECT.Color = Color(162,192,255)
EFFECT.ColorSprites = true

--lua/effects/tfa_muzzleflash_fubar_blu/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 16
        dlight.g                = 64
        dlight.b                = 255
        dlight.Brightness = 6.0
        dlight.size     = 110
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar_blu",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--addons/tfa_base/lua/effects/tfa_muzzleflash_gauss/init.lua:
local blankvec = Vector(0, 0, 0)

local vector_origin = Vector()

function EFFECT:Init(data)
	self.Position = blankvec
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()
	end

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 2 - self.WeaponEntOG:GetAnimCycle()
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	self.Position = self:GetTracerShootPos(angpos.Pos, self.WeaponEnt, self.Attachment)
	self.Norm = self.Dir
	self.vOffset = self.Position
	local dir = self.Norm
	local dlight

	if IsValid(self.WeaponEnt) then
		dlight = DynamicLight(self.WeaponEnt:EntIndex())
	else
		dlight = DynamicLight(0)
	end

	local fadeouttime = 0.2

	if (dlight) then
		dlight.Pos = self.Position + dir * 1 - dir:Angle():Right() * 5
		dlight.r = 25
		dlight.g = 200
		dlight.b = 255
		dlight.Brightness = 4.0
		dlight.size = 96
		dlight.decay = 1000
		dlight.DieTime = CurTime() + fadeouttime
	end

	ParticleEffectAttach("tfa_muzzle_gauss", PATTACH_POINT_FOLLOW, self.WeaponEnt, data:GetAttachment())
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_incendiary/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 2
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 128, 64)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/effects/tfa_muzzleflash_shotgun/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1.3
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1.5
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzlesmoke/init.lua:
local ang
local limit_particle_cv = GetConVar("cl_tfa_fx_muzzlesmoke_limited")
local SMOKEDELAY = 1.5

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	if limit_particle_cv:GetBool() and self.WeaponEnt:GetOwner() ~= LocalPlayer() then return end
	self.Attachment = data:GetAttachment()
	local smokepart = "smoke_trail_tfa"
	local delay = self.WeaponEnt.GetStatL and self.WeaponEnt:GetStatL("SmokeDelay") or self.WeaponEnt.SmokeDelay

	if self.WeaponEnt.SmokeParticle then
		smokepart = self.WeaponEnt.SmokeParticle
	elseif self.WeaponEnt.SmokeParticles then
		smokepart = self.WeaponEnt.SmokeParticles[self.WeaponEnt.DefaultHoldType or self.WeaponEnt.HoldType] or smokepart
	end

	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	if TFA.GetMZSmokeEnabled == nil or TFA.GetMZSmokeEnabled() then
		local e = self.WeaponEnt
		local w = self.WeaponEntOG
		local a = self.Attachment
		local tn = "tfasmokedelay_" .. w:EntIndex() .. "_" .. a
		local sp = smokepart

		if timer.Exists(tn) then
			timer.Remove(tn)
		end

		e.SmokePCF = e.SmokePCF or {}
		local _a = w:GetStatL("IsAkimbo") and a or 1

		if IsValid(e.SmokePCF[_a]) then
			e.SmokePCF[_a]:StopEmission()
		end

		timer.Create(tn, delay or SMOKEDELAY, 1, function()
			if not IsValid(e) then return end
			e.SmokePCF[_a] = CreateParticleSystem(e, sp, PATTACH_POINT_FOLLOW, a)

			if IsValid(e.SmokePCF[_a]) then
				e.SmokePCF[_a]:StartEmission()
			end
		end)
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_ricochet/init.lua:
local RicochetColor = Color(255, 255, 255, 255)
local RicochetIDOffset = 33
local RicochetMat = Material("effects/yellowflare")
local cv_gv = GetConVar("sv_gravity")
local cv_sl = GetConVar("cl_tfa_fx_impact_ricochet_sparklife")
local cv_sc = GetConVar("cl_tfa_fx_impact_ricochet_sparks")

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Dir:Normalize()
	self.Len = 128
	self.EndPos = self.StartPos + self.Dir * self.Len
	self.LifeTime = 0.1
	self.DieTime = CurTime() + self.LifeTime
	self.Grav = Vector(0, 0, -cv_gv:GetFloat())
	self.PartMult = data:GetMagnitude()
	self.SparkLife = cv_sl:GetFloat()
	local emitter = ParticleEmitter(self.StartPos)

	--Sparks
	for _ = 1, cv_sc:GetInt() * self.PartMult do
		local part = emitter:Add("effects/yellowflare", self.StartPos)
		part:SetVelocity((self.Dir + VectorRand() * 0.5) * math.Rand(75, 185))
		part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
		part:SetStartAlpha(255)
		part:SetStartSize(math.Rand(2, 4))
		part:SetEndSize(0)
		part:SetRoll(0)
		part:SetGravity(self.Grav)
		part:SetCollide(true)
		part:SetBounce(0.55)
		part:SetAirResistance(0.5)
		part:SetStartLength(0.2)
		part:SetEndLength(0)
		part:SetVelocityScale(true)
		part:SetCollide(true)
	end

	--Impact
	local part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(225)
	part:SetStartSize(64)
	part:SetDieTime(self.LifeTime)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(255)
	part:SetStartSize(30 * self.PartMult)
	part:SetDieTime(self.LifeTime * 1.5)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	emitter:Finish()
	local dlight = DynamicLight(LocalPlayer():EntIndex() + RicochetIDOffset)

	if (dlight) then
		dlight.Pos = self.StartPos
		dlight.r = 255
		dlight.g = 225
		dlight.b = 185
		dlight.Brightness = 2.75 * self.PartMult
		dlight.size = 48
		--dlight.DieTime 	= CurTime() + self.DieTime*0.7
		dlight.Decay = 1000 / math.max(0.01, math.min(self.SparkLife * 0.66, 1))
	end
end

function EFFECT:Think()
	if self.DieTime and (CurTime() > self.DieTime) then return false end

	return true
end

function EFFECT:Render()
	if self.DieTime then
		local fDelta = (self.DieTime - CurTime()) / self.LifeTime
		fDelta = math.Clamp(fDelta, 0, 1)
		render.SetMaterial(RicochetMat)
		local color = ColorAlpha(RicochetColor, 255 * fDelta)
		local precision = 16
		local i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), 8 * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end
	end
end
--addons/tfa_base/lua/effects/tfa_shell/init.lua:
EFFECT.Velocity = {120, 160}
EFFECT.VelocityRand = {-15, 40}
EFFECT.VelocityAngle = Vector(1,1,10)
EFFECT.VelocityRandAngle = Vector(10,10,5)

local modelReplaceLookup = {
	["models/hdweapons/rifleshell.mdl"] = "models/tfa/rifleshell.mdl",
	["models/hdweapons/rifleshell_hd.mdl"] = "models/tfa/rifleshell.mdl",
	["models/weapons/rifleshell_hd.mdl"] = "models/tfa/rifleshell.mdl",
	["models/hdweapons/shell.mdl"] = "models/tfa/pistolshell.mdl",
	["models/hdweapons/shell_hd.mdl"] = "models/tfa/pistolshell.mdl",
	["models/weapons/shell_hd.mdl"] = "models/tfa/pistolshell.mdl",
	["models/hdweapons/shotgun_shell.mdl"] = "models/tfa/shotgunshell.mdl",
	["models/hdweapons/shotgun_shell_hd.mdl"] = "models/tfa/shotgunshell.mdl",
	["models/weapons/shotgun_shell_hd.mdl"] = "models/tfa/shotgunshell.mdl",
}

EFFECT.ShellPresets = {
	["sniper"] = {"models/tfa/rifleshell.mdl", math.pow(0.487 / 1.236636, 1 / 3), 90}, --1.236636 is shell diameter, then divide base diameter into that for 7.62x54mm
	["rifle"] = {"models/tfa/rifleshell.mdl", math.pow(0.4709 / 1.236636, 1 / 3), 90}, --1.236636 is shell diameter, then divide base diameter into that for standard nato rifle
	["pistol"] = {"models/tfa/pistolshell.mdl", math.pow(0.391 / 0.955581, 1 / 3), 90}, --0.955581 is shell diameter, then divide base diameter into that for 9mm luger
	["smg"] = {"models/tfa/pistolshell.mdl", math.pow(.476 / 0.955581, 1 / 3), 90}, --.45 acp
	["shotgun"] = {"models/tfa/shotgunshell.mdl", 1, 90}
}

EFFECT.SoundFiles = {Sound(")player/pl_shell1.wav"), Sound(")player/pl_shell2.wav"), Sound(")player/pl_shell3.wav")}
EFFECT.SoundFilesSG = {Sound(")weapons/fx/tink/shotgun_shell1.wav"), Sound(")weapons/fx/tink/shotgun_shell2.wav"), Sound(")weapons/fx/tink/shotgun_shell3.wav")}
EFFECT.SoundLevel = {45, 55}
EFFECT.SoundPitch = {80, 120}
EFFECT.SoundVolume = {0.85, 0.95}
EFFECT.LifeTime = 15
EFFECT.FadeTime = 0.5
EFFECT.SmokeTime = {3, 3}
EFFECT.SmokeParticle = "tfa_ins2_weapon_shell_smoke"
local cv_eject
local cv_life
local upVec = Vector(0,0,1)

function EFFECT:ComputeSmokeLighting()
	if not self.PCFSmoke then return end
	local licht = render.ComputeLighting(self:GetPos() + upVec * 2, upVec)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	self.PCFSmoke:SetControlPoint(1, lichtFinal)
end

function EFFECT:Init(data)
	self.IsTFAShell = true

	if not cv_eject then
		cv_eject = GetConVar("cl_tfa_fx_ejectionsmoke")
	end

	if not cv_life then
		cv_life = GetConVar("cl_tfa_fx_ejectionlife")
	end

	if cv_life then
		self.LifeTime = cv_life:GetFloat()
	end

	self.StartTime = CurTime()
	self.Emitter = ParticleEmitter(self:GetPos())
	self.SmokeDelta = 0

	if cv_eject:GetBool() then
		self.SmokeDeath = self.StartTime + math.Rand(self.SmokeTime[1], self.SmokeTime[2])
	else
		self.SmokeDeath = -1
	end

	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	if self.WeaponEntOG.LuaShellEffect and self.WeaponEntOG.LuaShellEffect == "" then return end
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	self.DirAng = data:GetNormal():Angle()
	self.OriginalOrigin = data:GetOrigin()
	local owent = self.WeaponEnt:GetOwner()

	if self.LifeTime <= 0 or not IsValid(owent) then
		self.StartTime = -1000
		self.SmokeDeath = -1000

		return
	end

	if owent:IsPlayer() and owent == GetViewEntity() and not owent:ShouldDrawLocalPlayer() then
		self.WeaponEnt = self.WeaponEnt.OwnerViewModel
		if not IsValid(self.WeaponEnt) then return end
	end

	local model, scale, yaw = self:FindModel(self.WeaponEntOG)
	model = self.WeaponEntOG:GetStatL("ShellModel") or self.WeaponEntOG:GetStatL("LuaShellModel") or model
	model = modelReplaceLookup[model] or model
	scale = self.WeaponEntOG:GetStatL("ShellScale") or self.WeaponEntOG:GetStatL("LuaShellScale") or scale
	yaw = self.WeaponEntOG:GetStatL("ShellYaw") or self.WeaponEntOG:GetStatL("LuaShellYaw") or yaw

	if model:lower():find("shotgun") then
		self.Shotgun = true
	end

	self:SetModel(model)
	self:SetModelScale(scale, 0)
	self:SetPos(data:GetOrigin())
	local mdlang = self.DirAng * 1
	mdlang:RotateAroundAxis(mdlang:Up(), yaw)
	local owang = IsValid(owent) and owent:EyeAngles() or mdlang
	self:SetAngles(owang)
	self:SetRenderMode(RENDERMODE_TRANSALPHA)
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self:SetCollisionBounds(self:OBBMins(), self:OBBMaxs())
	self:PhysicsInitBox(self:OBBMins(), self:OBBMaxs())
	local velocity = self.Dir * math.Rand(self.Velocity[1], self.Velocity[2]) + owang:Forward() * math.Rand(self.VelocityRand[1], self.VelocityRand[2])

	if IsValid(owent) then
		velocity = velocity + owent:GetVelocity()
	end

	local physObj = self:GetPhysicsObject()

	if physObj:IsValid() then
		physObj:SetDamping(0.1, 1)
		physObj:SetMass(5)
		physObj:SetMaterial("gmod_silent")
		physObj:SetVelocity(velocity)
		local localVel = velocity:Length() * self.WeaponEnt:WorldToLocalAngles(velocity:Angle()):Forward()
		physObj:AddAngleVelocity(localVel.y * self.VelocityAngle)
		physObj:AddAngleVelocity(VectorRand() * velocity:Length() * self.VelocityRandAngle * 0.5)
	end

	local ss = self.WeaponEntOG:GetStatL("ShellSound") or self.WeaponEntOG:GetStatL("LuaShellSound")

	if ss then
		self.ImpactSound = ss
	else
		self.ImpactSound = self.Shotgun and self.SoundFilesSG[math.random(1, #self.SoundFiles)] or self.SoundFiles[math.random(1, #self.SoundFiles)]
	end

	self.setup = true
end

function EFFECT:FindModel(wep)
	if not IsValid(wep) then return unpack(self.ShellPresets["rifle"]) end
	local ammotype = (wep.Primary.Ammo or wep:GetPrimaryAmmoType()):lower()
	local guntype = (wep.Type or wep:GetHoldType()):lower()

	if guntype:find("sniper") or ammotype:find("sniper") or guntype:find("dmr") then
		return unpack(self.ShellPresets["sniper"])
	elseif guntype:find("rifle") or ammotype:find("rifle") then
		return unpack(self.ShellPresets["rifle"])
	elseif ammotype:find("pist") or guntype:find("pist") then
		return unpack(self.ShellPresets["pistol"])
	elseif ammotype:find("smg") or guntype:find("smg") then
		return unpack(self.ShellPresets["smg"])
	elseif ammotype:find("buckshot") or ammotype:find("shotgun") or guntype:find("shot") then
		return unpack(self.ShellPresets["shotgun"])
	end

	return unpack(self.ShellPresets["rifle"])
end

function EFFECT:BounceSound()
	sound.Play(self.ImpactSound, self:GetPos(), math.Rand(self.SoundLevel[1], self.SoundLevel[2]), math.Rand(self.SoundPitch[1], self.SoundPitch[2]), math.Rand(self.SoundVolume[1], self.SoundVolume[2]))
end

function EFFECT:PhysicsCollide(data)
	if self:WaterLevel() > 0 then return end

	if TFA.GetEJSmokeEnabled() and not self.PCFSmoke and CurTime() < self.SmokeDeath then
		self.PCFSmoke = CreateParticleSystem(self, self.SmokeParticle, self:GetAttachment(1) ~= nil and PATTACH_POINT_FOLLOW or PATTACH_ABSORIGIN_FOLLOW, 1)
		if IsValid(self.PCFSmoke) then
			self:ComputeSmokeLighting()
			self.PCFSmoke:StartEmission()
		else
			self.PCFSmoke = nil
		end
	end

	if data.Speed > 60 then
		self:BounceSound()
		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal) * 0.33
		local phys = self:GetPhysicsObject()

		if phys:IsValid() then
			phys:ApplyForceCenter(impulse)
		end
	end
end

function EFFECT:Think()
	if CurTime() > self.SmokeDeath and self.PCFSmoke then
		self.PCFSmoke:StopEmission()
		self.PCFSmoke = nil
	else
		self:ComputeSmokeLighting()
	end

	if self:WaterLevel() > 0 and not self.WaterSplashed then
		self.WaterSplashed = true
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		ef:SetScale(1)
		util.Effect("watersplash", ef)
	end

	if CurTime() > self.StartTime + self.LifeTime then
		if self.Emitter then
			self.Emitter:Finish()
		end

		return false
	else
		return true
	end
end

function EFFECT:Render()
	if not self.setup then return end
	self:SetColor(ColorAlpha(color_white, (1 - math.Clamp(CurTime() - (self.StartTime + self.LifeTime - self.FadeTime), 0, self.FadeTime) / self.FadeTime) * 255))
	self:SetupBones()
	self:DrawModel()
end

hook.Add("EntityEmitSound", "TFA_BlockShellScrapeSound", function(sndData)
	if IsValid(sndData.Entity) and sndData.Entity.IsTFAShell and sndData.SoundName:find("scrape") then
		return false
	end
end)
--lua/effects/tfa_tracer_fubar/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--lua/effects/tfa_tracer_fubar_blu/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail_blu", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--lua/effects/tfa_tracer_fubar_light_blu/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam_blu", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--addons/wos-grandmaster-einf/lua/effects/thor_thunder/init.lua:

EFFECT.Mat = Material( "trails/electric" )

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	
	local dir = self.StartPos - self.EndPos
	dir:Normalize()
	
	self.Dir = dir
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )
	
	self.Alpha = 100
	self.Color = Color( 0, 255, 255, self.Alpha )
	
	local dlight = DynamicLight( self:EntIndex() )
	
	if dlight then
	
		dlight.Pos = self.StartPos
		dlight.r = 255
		dlight.g = 150
		dlight.b = 50
		dlight.Brightness = 3
		dlight.Decay = 256
		dlight.size = 256 * math.Rand( 0.5, 1.0 )
		dlight.DieTime = CurTime() + 5
		
	end

end

function EFFECT:Think( )

	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Alpha = self.Alpha - FrameTime() * 200
	self.Color = Color( 255, 255, 255, self.Alpha )
	
	return self.Alpha > 0

end

function EFFECT:Render( )

	if self.Alpha < 1 then return end
	
	--[[self.Length = ( self.StartPos - self.EndPos ):Length()
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( self.StartPos, self.EndPos, ( 100 / self.Alpha ) * 0.5 + 0.5, 0, 0, self.Color )]]
	
	if ( self.Alpha < 1 ) then return end

	self.Length = (self.StartPos - self.EndPos):Length()
		
	local texcoord = CurTime() * -0.2
	
	for i = 1, 10 do
	
		render.SetMaterial( self.Mat )
		
		texcoord = texcoord + i * 0.05 * texcoord
	
		render.DrawBeam( self.StartPos, 										
						self.EndPos,											
						i * self.Alpha * 0.03,									
						texcoord,												
						texcoord + (self.Length / (128 + self.Alpha)),		
						self.Color )
						

		render.DrawSprite( self.StartPos + self.Dir * i, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
		render.DrawSprite( self.EndPos, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
	
	end

end

--addons/egm_tfa_grenades/lua/effects/train_light.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)

	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)

	for i = 1, math.random(25, 35) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.2, 0.35))
		p:SetStartAlpha(255)
		p:SetEndAlpha(40)
		p:SetStartSize(math.random(35, 55) * self.size)
		p:SetEndSize(45 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 90, 0)
	end
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--lua/effects/vfire_smoke_plume.lua:
function EFFECT:Init(data)

	-- Get our data
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local mag = data:GetMagnitude()
	local ent = data:GetEntity()

	-- Should we LOD ourselves?
	local LOD
	if IsValid(ent) and ent.LOD != nil then
		LOD = ent.LOD
	else
		LOD = vFireGetLOD(pos)
	end

	local smokeCount = mag * 2

	local pe = ParticleEmitter(pos)

		for i=1, smokeCount do
			local p = pe:Add(table.Random(list.Get("vFireSmoke")), pos)

				local pull = 30 * i / smokeCount

				p:SetLifeTime(0)
				p:SetDieTime(3)
			
				p:SetStartSize(0)
				p:SetEndSize(10 * pull)

				p:SetStartAlpha(math.random(100, 255))
				p:SetEndAlpha(0)

				local d = math.random(0, 200)
				p:SetColor(255-d, 255-d, math.random(235, 250)-d)
				p:SetLighting(true)
				
				local upAdd = math.Rand(0.5, 1.5)
				local newDir = Vector(dir.x, dir.y, dir.z + upAdd)
				p:SetVelocity(newDir * 50)
				p:SetGravity(newDir * 1 * pull)
				p:SetAirResistance(math.random(10, 15))

				p:SetCollide(true)

				p:SetRollDelta(math.Rand(-0.5, 0.5))
		end

	pe:Finish()
end

function EFFECT:Render()
end

function EFFECT:Think()
	return false
end
--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_acidpool/init.lua:

PrecacheParticleSystem( "[2]acid_ground" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	
	self.Particle = CreateParticleSystem( ent, "[2]acid_ground", PATTACH_ABSORIGIN_FOLLOW ) 
	self.LifeTime = CurTime() + 3
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/wos_alcs_ascended_darkness/init.lua:
local smoke = Material( "decals/dark" )

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	for i = 0, len do
		local pos2 = pos + dir * 25 * i
		local particle = emitter:Add( smoke, pos2 )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 40 )

			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 120 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )

			particle:SetColor( 0, 0, 0 )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--gamemodes/egmrp/gamemode/core/sql/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--             SQL index             --
---------------------------------------

if SERVER then
    SQL = SQL or {}

	include("sv_config.lua")
    
	InitServersideSQL()
end
--gamemodes/egmrp/gamemode/core/propertymodel/sh_propertymodel_meta.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | Property model meta   --
---------------------------------------

-- Contains functions for interacting with a property model instance.
PropertyModel.Meta = {}
PropertyModel.Meta.__index = PropertyModel.Meta

-- Override for the __tostring metamethod.
--
-- @return String string
function PropertyModel.Meta:__tostring()
    return "PropertyModel (" .. self:GetModel().Name .. ") " .. (self:GetId() or "0")
end

-- Default override for GetName.
-- Should be overridden by the property model with a proper name.
--
-- @return String name
function PropertyModel.Meta:GetName()
    return self:__tostring()
end

-- Default override for GetId.
-- Should be overridden by the property model with a proper sort value.
--
-- @return Number id
function PropertyModel.Meta:GetSort()
    return self:GetId()
end

-- Checks if the values differ from each other. Only one layer of tables is checked.
--
-- @param String oldValue
-- @param String value
-- @return Boolean valueDiffers
function PropertyModel.Meta:ValueDiffers(oldValue, value)
	-- If both are the same value, they don't differ.
	-- Even with tables, if they are the same table, they don't differ.
	if oldValue == value then return false end

	-- If the types differ, they differ.
	if type(oldValue) ~= type(value) then return true end

	-- Compare table content 1 level deep.
	if istable(oldValue) and istable(value) then
		local diff = CompareTableRecursive(value, oldValue)
		if diff then
			return true
		else
			return false
		end
	end

	return value ~= oldValue
end

-- Checks if the value differs from the current data value.
--
-- @param String dataKey
-- @param String value
-- @return Boolean valueDiffers
function PropertyModel.Meta:DataValueDiffers(key, value)
    local oldValue = self:Get(key)

    return self:ValueDiffers(oldValue, value)
end


-- Checks if the value differs from the current property value.
--
-- @param String propertyKey
-- @param String value
-- @return Boolean valueDiffers
function PropertyModel.Meta:PropertyValueDiffers(key, value)
    local oldValue = self:GetProperty(key)

    return self:ValueDiffers(oldValue, value)
end

-- Checks whether the value of the property equals to the default value.
-- Utilizes PropertyModel.Meta:PropertyValueDiffers.
--
-- @param String key
-- @return Boolean isDefault
function PropertyModel.Meta:IsDefaultPropertyValue(key)
    local property = self:GetModel():GetProperty(key)

    return not self:PropertyValueDiffers(key, property.default)
end

-- Checks whether the value for the data with the given key is valid.
--
-- @param String key
-- @param String value
-- @return Boolean isValid
-- @return? String validationError - provides more information, why data is invalid.
function PropertyModel.Meta:IsDataValid(key, value)
    if not self:GetModel():HasData(key) then
        return false, egmt("propertymodel.unknown_data")
    end

    local data = self:GetModel():GetData(key)

    -- Data that is not send to the client can't exist on the client.
    if CLIENT and not data.sendToClient(self, LocalPlayer()) then
        return true
    end

    -- Call custom validate check, if exists.
    if data.validate then
        return data.validate(self, value)
    end

    return true
end

-- Checks whether all the data is valid.
--
-- @param? Boolean skipIdCreated - whether to skip the validation of the id field. Useful for validating not yet created property models.
-- @param? Table data - checks this table instead of the property model's data. If one data value is not present in this table, it uses the current value.
-- @return Boolean isDataValid
-- @return? Table validationErrors - contains every error produced when validating the properties.
function PropertyModel.Meta:IsAllDataValid(skipIdCreated, data)
    local isValid = true
    local validationErrors = {}

    for k, v in pairs(self:GetModel():GetData()) do
        if not skipIdCreated or (k ~= self:GetModel():GetIdKey() and k ~= "created") then
            local isDataValid, validationError = self:IsDataValid(k, data and data[k] or self:Get(k))

            if not isDataValid then
                isValid = false

                if validationError then
                    validationErrors[k] = validationError
                else
                    validationErrors[k] = egmt("propertymodel.unknown_reason_data")
                end
            end
        end
    end

    return isValid, validationErrors
end

-- Checks whether the value for the property with the given key is valid.
--
-- @param String key
-- @param String value
-- @return Boolean isValid
-- @return? String validationError - provides more information, why property is invalid.
function PropertyModel.Meta:IsPropertyValid(key, value)
    if not self:GetModel():HasProperty(key) then
        return false, egmt("propertymodel.unknown_property")
    end

    local property = self:GetModel():GetProperty(key)

    -- Properties that are not send to the client can't exist on the client.
    if CLIENT and not property.sendToClient(self, LocalPlayer()) then
        return true
    end

    -- Call custom validate check, if exists.
    if property.validate then
        return property.validate(self, value)
    end

    return true
end

-- Checks whether all the properties are valid.
--
-- @param? Table properties - checks this table instead of the property model's properties.
-- @return Boolean arePropertiesValid
-- @return? Table validationErrors - contains every error produced when validating the properties.
function PropertyModel.Meta:ArePropertiesValid(properties)
    local isValid = true
    local validationErrors = {}

    for k, property in pairs(self:GetModel():GetProperties()) do
        local isPropertyValid, validationError = self:IsPropertyValid(k, properties and properties[k] or self:GetProperty(k))

        if not isPropertyValid then
            isValid = false

            if validationError then
                validationErrors[k] = validationError
            else
                validationErrors[k] = egmt("propertymodel.unknown_readon_property")
            end
        end
    end

    return isValid, validationErrors
end

-- Checks whether the property model is completely valid. Validates data first. Only validates properties when data is valid.
--
-- @param? Boolean skipIdCreated - whether to skip the validation of the id field. Useful for validating not yet created property models.
-- @return Boolean isValid
-- @return? Table validationErrors - contains every error produced when validating.
function PropertyModel.Meta:IsValid(skipIdCreated)
    local isDataValid, dataValidationErrors = self:IsAllDataValid(skipIdCreated)

    if not isDataValid then
        return false, dataValidationErrors
    end

    local arePropertiesValid, propertyValidationErrors = self:ArePropertiesValid()

    if not arePropertiesValid then
        return false, propertyValidationErrors
    end

    return true
end

-- Checks wether a player is able to edit a specific data value.
-- Only checks permissions through hooks, does not validate the data.
--
-- @param Player ply
-- @param String key
-- @param? Any value
-- @param? Boolean skipGlobal
-- @return Boolean canEdit
function PropertyModel.Meta:CanPlayerEditData(ply, key, value, skipGlobal)
    if not skipGlobal then
        local globalPermissions = hook.Run(self:GetModel().Name .. ".CanPlayerEditData", ply, self, {[key] = value})

        if isbool(globalPermissions) then
            return globalPermissions
        end
    end

    return hook.Run(self:GetModel().Name .. ".CanPlayerEditData." .. key, ply, self, value) == true
end

-- Checks wether a player is able to edit the data of the property model.
-- Only checks permissions through hooks, does not validate the data.
--
-- @param Player ply
-- @param Table data
-- @return Boolean canEdit
function PropertyModel.Meta:CanPlayerEditMultipleData(ply, data)
    local globalPermissions = hook.Run(self:GetModel().Name .. ".CanPlayerEditData", ply, self, data)

    if isbool(globalPermissions) then
        return globalPermissions
    end

    for k, v in pairs(data) do
        if not self:CanPlayerEditData(ply, k, v, true) then
            return false
        end
    end

    return true
end

-- Checks wether a player is able to edit a specific property value.
-- Only checks permissions through hooks, does not validate the data.
--
-- @param Player ply
-- @param String key
-- @param? Any value
-- @return Boolean canEdit
function PropertyModel.Meta:CanPlayerEditProperty(ply, key, value)
    local globalPermissions = hook.Run(self:GetModel().Name .. ".CanPlayerEditProperties", ply, self, {[key] = value})

    if isbool(globalPermissions) then
        return globalPermissions
    end

    return hook.Run(self:GetModel().Name .. ".CanPlayerEditProperty." .. key, ply, self, value) == true
end

-- Checks wether a player is able to edit the properties of the property model.
-- Only checks permissions through hooks, does not validate the data.
--
-- @param Player ply
-- @param Table properties
-- @return Boolean success
function PropertyModel.Meta:CanPlayerEditProperties(ply, properties)
    local globalPermissions = hook.Run(self:GetModel().Name .. ".CanPlayerEditProperties", ply, self, properties)

    if isbool(globalPermissions) then
        return globalPermissions
    end

    for k, v in pairs(properties) do
        if not self:CanPlayerEditProperty(ply, k, v) then
            return false
        end
    end

    return true
end

-- Checks whether a player is able to delete the property model.
--
-- @param Player ply
-- @return Boolean canDelete
function PropertyModel.Meta:CanPlayerDelete(ply)
    if hook.Run(self:GetModel().Name .. ".CanPlayerDelete", ply, self) == true then
        return true
    end

    return false
end

-- Returns the data of a property model.
function PropertyModel.Meta:GetData()
    return self.data
end

-- Returns the id of the property model.
--
-- @return Number id
function PropertyModel.Meta:GetId()
    return self:Get(self:GetModel():GetIdKey())
end

-- Returns the properties of the property model.
--
-- @return Table properties
function PropertyModel.Meta:GetProperties()
    return self.properties
end

-- Sets multiple data values at once.
--
-- @param Table data
-- @param? Boolean skipValidation
-- @param? Boolean preventNetwork - wether to skip the networking of changes (serverside only).
-- @return Boolean success
-- @return? Table errors
function PropertyModel.Meta:SetMultipleData(data, skipValidation, preventNetwork)
    if not skipValidation then
        -- Do not set any data, if there is one invalid field.
        local isValid = true
        local validationErrors = {}

        for k, v in pairs(data) do
            local isDataValid, dataValidationError = self:IsDataValid(k, v)

            if not isDataValid then
                isValid = false

                if dataValidationError then
                    table.insert(validationErrors, dataValidationError)
                end
            end
        end

        if not isValid then
            return false, validationErrors
        end
    end

    for key, value in pairs(data) do
        -- Do not validate the data again, because we already did it.
        self:SetData(key, value, true, preventNetwork)
    end

    return true
end

-- Sets multiple properties at once.
--
-- @param Table properties
-- @param? Boolean skipValidation
-- @param? Boolean preventNetwork - wether to skip the networking of changes (serverside only).
-- @return Boolean success
-- @return? Table errors
function PropertyModel.Meta:SetProperties(properties, skipValidation, preventNetwork)
    if not skipValidation then
        -- Do not set any propery if there is one invalid field.
        local isValid = true
        local validationErrors = {}

        for k, v in pairs(properties) do
            local isPropertyValid, propertyValidationError = self:IsPropertyValid(k, v)

            if not isPropertyValid then
                isValid = false

                if propertyValidationError then
                    table.insert(validationErrors, propertyValidationError)
                end
            end
        end

        if not isValid then
            return false, validationErrors
        end
    end

    for key, value in pairs(properties) do
        -- Do not validate the property again, because we already did it.
        self:SetProperty(key, value, true, preventNetwork)
    end

    return true
end

-- Caches the property model.
function PropertyModel.Meta:Cache()
    if hook.Run(self:GetModel().Name .. ".Cache", self) == nil then
        self:GetModel().Cache[self:GetId()] = self
    end
end

-- Removes the property model from cache.
function PropertyModel.Meta:RemoveFromCache()
    if hook.Run(self:GetModel().Name .. ".RemoveFromCache", self) == nil then
        self:GetModel().Cache[self:GetId()] = nil
    end
end

-- Create a copy of the propertymodel.
function PropertyModel.Meta:Copy()
    local data = table.Copy(self:GetData())
    data[self:GetModel():GetSQLIdKey()] = nil
    data.created = nil

    -- Append (Copy) localized to the name of the copied propertyModel.
    local properties = table.Copy(self:GetProperties())
    if properties.name then
        properties.name = egmt("propertymodel.copy", properties.name)
    end

    self:GetModel():Create(data, properties)
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/slider.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or 0
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local min = propertyListData.values.min or 0
	local max = propertyListData.values.max or 255
	local dec = propertyListData.values.dec or 0

	local sliderProperty = vgui.Create("DNumSlider", propertyPanel)
	propertyPanel.SliderProperty = sliderProperty

	sliderProperty:SetHeight(ScrH() * 0.02)
	sliderProperty:Dock(FILL)
	sliderProperty:DockMargin(0, 0, 0, 0)
	sliderProperty:SetMin(min)
	sliderProperty:SetMax(max)
	sliderProperty:SetDecimals(dec)
	function sliderProperty:ApplySchemeSettings()
	end

	sliderProperty.TextArea:SetPaintBackground(true)
	sliderProperty.TextArea:SetFont("EGMText6")
	sliderProperty.TextArea:SetTextColor(Color(0, 0, 0))
	sliderProperty.TextArea:SetWidth(ScrW() * 0.03)

	function sliderProperty.Slider:Paint(ww, hh)
		draw.RoundedBox(0, 0, hh / 2 - 4, ww, 8, UI.BackgroundColor)
	end
	sliderProperty.Slider.Knob:SetHeight(ScrH() * 0.02)
	function sliderProperty.Slider.Knob:Paint(ww, hh)
		if canEdit then
			draw.RoundedBox(0, 0, 0, ww, hh, UI.ForegroundColor)
		else
			draw.RoundedBox(0, 0, 0, ww, hh, Color(80, 80, 80))
		end
	end

	sliderProperty.Label:SetVisible(false)

	sliderProperty:InvalidateLayout(true)

	sliderProperty:SetValue(currentValue)

	sliderProperty:SetMouseInputEnabled(canEdit)
	function sliderProperty:Paint(width, height)
		if canEdit then
			draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
		else
			draw.RoundedBox(0, 0, 0, width, height, Color(180, 180, 180))
		end
	end
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.SliderProperty) then
		return 0
	end

	return math.Round(propertyPanel.SliderProperty:GetValue(), propertyPanel.SliderProperty:GetDecimals())
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Checking 0 should be sufficient.
	-- If the player can edit 0, he can edit all numbers.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, propertyListData.default or 0) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/loading/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Loading index           --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

Loading = Loading or {}

if SERVER then
    AddCSLuaFile("cl_config.lua")
    AddCSLuaFile("cl_loading.lua")
    AddCSLuaFile("cl_loadingscreen.lua")

    include("sv_loading.lua")
end

if CLIENT then
    include("cl_config.lua")
    include("cl_loading.lua")
    include("cl_loadingscreen.lua")
end
--gamemodes/egmrp/gamemode/core/util/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Utilities | Index         --
---------------------------------------

if SERVER then
	AddCSLuaFile("sh_net.lua")
	AddCSLuaFile("sh_table.lua")
	AddCSLuaFile("sh_position.lua")
	AddCSLuaFile("sh_hook.lua")
	AddCSLuaFile("sh_string.lua")
	AddCSLuaFile("sh_color.lua")
	AddCSLuaFile("sh_skincount.lua")

	AddCSLuaFile("cl_draw.lua")

	include("sh_net.lua")
	include("sh_table.lua")
	include("sh_position.lua")
	include("sh_hook.lua")
	include("sh_string.lua")
	include("sh_color.lua")
	include("sh_skincount.lua")
end

if CLIENT then
	include("sh_net.lua")
	include("sh_table.lua")
	include("sh_position.lua")
	include("sh_hook.lua")
	include("sh_string.lua")
	include("sh_color.lua")
	include("sh_skincount.lua")

	include("cl_draw.lua")
end
--gamemodes/egmrp/gamemode/core/util/sh_net.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Network Utilities | Shared    --
---------------------------------------

-- Converts the given table to a string using json and compresses
-- the string using LZMA algorithm.
--
-- @param Table data
-- @return String compressed
function CompressTable(data)
    return util.Compress(util.TableToJSON(data))
end

-- Decompresses the given string using LZMA algorithm and
-- converts it to a table using json.
--
-- @param String compressed
-- @return Table data
function DecompressTable(data)
    return util.JSONToTable(util.Decompress(data))
end

--gamemodes/egmrp/gamemode/core/util/sh_string.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     String Utilities | Shared     --
---------------------------------------

-- Helper function to create a random string.
--
-- @param Number length
-- @return String str
function string.Random(length)
    local result = ""

    for i = 1, length do
        result = result .. string.char(math.random(32, 126))
    end

    return result
end

-- Changes a string to its plural form if the quantity is not 1.
--
-- @param String str
-- @param Number quantity
-- @param String pluralAddition
-- @return String str
local function pluralizeString( str, quantity, pluralAddition)
    return str .. ( ( quantity ~= 1 ) and pluralAddition or "" )
end

-- Returns a nice time string, that is better readable than the default one.
--
-- @param Number seconds
function string.EvenNicerTime( seconds )
    local years = 0
    local weeks = 0
    local days = 0
    local hours = 0
    local minutes = 0

    years = math.floor(seconds / (60 * 60 * 24 * 365))
    seconds = seconds % (60 * 60 * 24 * 365)
    weeks = math.floor(seconds / (60 * 60 * 24 * 7))
    seconds = seconds % (60 * 60 * 24 * 7)
    days = math.floor(seconds / (60 * 60 * 24))
    seconds = seconds % (60 * 60 * 24)
    hours = math.floor(seconds / (60 * 60))
    seconds = seconds % (60 * 60)
    minutes = math.floor(seconds / 60)
    seconds = math.floor(seconds % 60)

    if years ~= 0 then
        return years .. " " .. pluralizeString(egmt("ui.year"), years, egmt("ui.yearaddition")) .. " "
            .. weeks .. " " .. pluralizeString(egmt("ui.week"), minutes, egmt("ui.weekaddition")) .. " "
            .. days .. " " .. pluralizeString(egmt("ui.day"), minutes, egmt("ui.dayaddition")) .. " "
            .. hours .. " " .. pluralizeString(egmt("ui.hour"), minutes, egmt("ui.houraddition")) .. " "
            .. minutes .. " " .. pluralizeString(egmt("ui.minute"), minutes, egmt("ui.minuteaddition"))
            .. " " .. egmt("ui.and") .. " "
            .. seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    elseif weeks ~= 0 then
        return weeks .. " " .. pluralizeString(egmt("ui.week"), minutes, egmt("ui.weekaddition")) .. " "
            .. days .. " " .. pluralizeString(egmt("ui.day"), minutes, egmt("ui.dayaddition")) .. " "
            .. hours .. " " .. pluralizeString(egmt("ui.hour"), minutes, egmt("ui.houraddition")) .. " "
            .. minutes .. " " .. pluralizeString(egmt("ui.minute"), minutes, egmt("ui.minuteaddition"))
            .. " " .. egmt("ui.and") .. " "
            .. seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    elseif days ~= 0 then
        return days .. " " .. pluralizeString(egmt("ui.day"), minutes, egmt("ui.dayaddition")) .. " "
            .. hours .. " " .. pluralizeString(egmt("ui.hour"), minutes, egmt("ui.houraddition")) .. " "
            .. minutes .. " " .. pluralizeString(egmt("ui.minute"), minutes, egmt("ui.minuteaddition"))
            .. " " .. egmt("ui.and") .. " "
            .. seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    elseif hours ~= 0 then
        return hours .. " " .. pluralizeString(egmt("ui.hour"), minutes, egmt("ui.houraddition")) .. " "
            .. minutes .. " " .. pluralizeString(egmt("ui.minute"), minutes, egmt("ui.minuteaddition"))
            .. " " .. egmt("ui.and") .. " "
            .. seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    elseif minutes ~= 0 then
        return minutes .. " " .. pluralizeString(egmt("ui.minute"), minutes, egmt("ui.minuteaddition"))
            .. " " .. egmt("ui.and") .. " "
            .. seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    else
        return seconds .. " " .. pluralizeString( egmt("ui.second"), seconds, egmt("ui.secondaddition"))
    end
end

--gamemodes/egmrp/gamemode/core/ui/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--             UI | Index            --
---------------------------------------

UI = UI or {}

if SERVER then
	include("sh_config.lua")
	include("sh_ui.lua")

	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_ui.lua")
	AddCSLuaFile("cl_ui.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_ui.lua")
	include("cl_ui.lua")
end
--gamemodes/egmrp/gamemode/core/ui/cl_ui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            UI | Client            --
---------------------------------------

local EGMRP = GM or GAMEMODE

-- Disable the information when looking at a player.
function EGMRP:HUDDrawTargetID()
end

-- Draw all HUD Elements.
function UI:DrawHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end

	for key, element in pairs(self.HUDElements) do
		local drawFunction = element.Draw
		if isfunction(drawFunction) then
			drawFunction(element, ply)
		end
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Draw the HUD
hook.Add("HUDPaint", "UI.HUDPaint", function()
	if hook.Run("HUDShouldDraw", "EGMRPHud") == false then return end

	UI:DrawHUD()
end)

-- Disable the default death notice
hook.Add("DrawDeathNotice", "UI.Disable", function()
	return true
end)

-- List of default hud elements to hide.
local hidden = {
	["CHudAmmo"] = true,
	["CHudBattery"] = true,
	["CHudHealth"] = true,
	["CHudDamageIndicator"] = true,
	["CHudSecondaryAmmo"] = true,
	["CHudCrosshair"] = false,
}

-- Hide default hud elements.
hook.Add("HUDShouldDraw", "UI.DisableDefault", function(element)
	if hidden[element] then
		return false
	end
end)

-- Load the watermark texture into a material.
hook.Add("EGMRP.Loaded", "UI.LoadWatermark", function()
	if not UI.Watermark then return end

	UI.WatermarkTexture = Material(UI.Watermark)
end)

-- Draw the watermark.
hook.Add("DrawOverlay", "UI.DrawWatermark", function()
	local waterMarkTexture = UI.WatermarkTexture

	if not waterMarkTexture then return end
	if waterMarkTexture:IsError() then return end

	surface.SetDrawColor(255, 255, 255, 50)
	surface.SetMaterial(waterMarkTexture)
	surface.DrawTexturedRect(0, 0, 64, 64)
end)
--gamemodes/egmrp/gamemode/core/ui/styles/default/cl_colors.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Default UI | Colors        --
---------------------------------------

-- Main Background Color
UI.BackgroundColor = GetColor("darkgray", 200)

-- Secondary Background Color
UI.BackgroundColor2 = GetColor("gray", 250)

-- Main Foreground Color
UI.ForegroundColor = GetColor("yellow")

-- Secondary Foreground Color
UI.ForegroundColor2 = GetColor("blue")

-- Accent Color
UI.TextColor = GetColor("white")

-- Danger Color
UI.DangerColor = GetColor("red")

-- Success Color
UI.SuccessColor = GetColor("green")
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmclosebutton.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       VGUI | EGMCloseButton       --
---------------------------------------

ELEMENT.Name = "EGMCloseButton"
ELEMENT.Base = "DButton"

-- Initializes the EGMCloseButton.
function ELEMENT:Init()
	self.Activated = true

	self:SetText("")
end

-- Close the connected panel on click.
function ELEMENT:DoClick()
	if not self.Activated then
		return
	end

	local panel = self.Panel
	if IsValid(panel) then
		if isfunction(panel.Close) then -- Close DFrames with the close method.
			panel:Close()
		else
			panel:Remove()
		end
	end
end

-- Draws the button.
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
	if self.Activated then
		draw.RoundedBox(5, 0, 0, width, height, GetColor("gray"))

		draw.NoTexture()
		surface.SetDrawColor(GetColor("red"))
		surface.DrawPoly({
			{x = width * 0.5, y = height * 0.4},
			{x = width * 0.8, y = height * 0.1},
			{x = width * 0.9, y = height * 0.1},
			{x = width * 0.6, y = height * 0.5},
			{x = width * 0.9, y = height * 0.9},
			{x = width * 0.8, y = height * 0.9},
			{x = width * 0.5, y = height * 0.6},
			{x = width * 0.2, y = height * 0.9},
			{x = width * 0.1, y = height * 0.9},
			{x = width * 0.4, y = height * 0.5},
			{x = width * 0.1, y = height * 0.1},
			{x = width * 0.2, y = height * 0.1}
		})
	end
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the connected panel that should close.
--
-- @param DPanel panel
function ELEMENT:SetPanel(panel)
	self.Panel = panel
end

-- Shows or hides the button.
--
-- @param Boolean bool
function ELEMENT:SetActivated(bool)
	self.Activated = bool
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmcombobox.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         VGUI | EGMComboBox        --
---------------------------------------

ELEMENT.Name = "EGMComboBox"
ELEMENT.Base = "DComboBox"

-- Initializes the EGMComboBox
function ELEMENT:Init()
    self.DropDownHeight = 22

    self.MainColor = UI.ForegroundColor
    self.MainTextColor = UI.TextColor

    self.DropDownColor = UI.BackgroundColor2
    self.DropDownTextColor = UI.TextColor
    self.DropDownHoverColor = UI.ForegroundColor

    self.ScrollbarColor = GetColor("darkgray")
    self.ScrollbarGripColor = UI.ForegroundColor
    self.ScrollbarButtonColor = GetColor("black")
    self.ScrollbarButtonBackgroundColor = UI.ForegroundColor

    self:SetTextColor(Color(0, 0, 0, 0))
end

-- Override the menu creation to create a custom menu.
function ELEMENT:OnMenuOpened(dMenu)
    local _self = self

    local _, startY = self:LocalToScreen(0, 0)
    local maxHeight = ScrH() - startY
    local maxChildren = math.floor(maxHeight / self.DropDownHeight) - 1
    dMenu:SetMaxHeight(self.DropDownHeight * maxChildren)

    for _, child in pairs(dMenu:GetCanvas():GetChildren()) do
        child:SetTextColor(Color(0, 0, 0, 0))

        function child:PerformLayout(w, h)
            self:SizeToContents()
            self:SetWide(self:GetWide() + 30)

            w = math.max(self:GetParent():GetWide(), self:GetWide())
            self:SetSize(w, _self.DropDownHeight)

            if (IsValid(self.SubMenuArrow)) then
                self.SubMenuArrow:SetSize(15, 15)
                self.SubMenuArrow:CenterVertical()
                self.SubMenuArrow:AlignRight(4)
            end

            DButton.PerformLayout(self, w, h)
        end
        function child:Paint(w, h)
            draw.RoundedBox(0, 0, 0, w, h, _self.DropDownColor)

            if self:IsHovered() then
                draw.RoundedBox(0, 4, 2, w - 8, h - 4, _self.DropDownHoverColor)
            end

            local text = self:GetText()
            if text ~= "" then
                draw.SimpleText(text, "EGMText8", w * 0.5, h * 0.5, _self.DropDownTextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end
        end
    end

	-- Override paint functions

	function dMenu.VBar:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarColor)
	end

	function dMenu.VBar.btnGrip:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarGripColor)
	end

	function dMenu.VBar.btnUp:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarButtonBackgroundColor)

		surface.SetDrawColor(_self.ScrollbarButtonColor)
		draw.NoTexture()
		surface.DrawPoly({
			{x = 3, y = 11.5},
			{x = 7.5, y = 3.5},
			{x = 12, y = 11.5}
		})
	end
	function dMenu.VBar.btnDown:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, _self.ScrollbarButtonBackgroundColor)

		surface.SetDrawColor(_self.ScrollbarButtonColor)
		draw.NoTexture()
		surface.DrawPoly({
			{x = 12, y = 3.5},
			{x = 7.5, y = 11.5},
			{x = 3, y = 3.5}
		})
	end
end

-- Paint the main button.
function ELEMENT:Paint(width, height)
    if not self:IsMouseInputEnabled() then
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
    else
        draw.RoundedBox(0, 0, 0, width, height, self.MainColor)
    end

    local text = self:GetText()
    if text ~= "" then
        draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, self.MainTextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the DropDownHeight of the EGMComboBox
--
-- @param Number height
function ELEMENT:SetDropDownHeight(height)
    self.DropDownHeight = height
end

-- Sets the MainColor of the EGMComboBox
--
-- @param Color color
function ELEMENT:SetMainColor(color)
    self.MainColor = color
end

-- Sets the TextColor of the EGMComboBox
--
-- @param Color color
function ELEMENT:SetMainTextColor(color)
    self.MainTextColor = color
end

-- Sets the DropDownColor of the EGMComboBox
--
-- @param Color color
function ELEMENT:SetDropDownColor(color)
    self.DropDownColor = color
end

-- Sets the DropDownTextColor of the EGMComboBox
--
-- @param Color color
function ELEMENT:SetDropDownTextColor(color)
    self.DropDownTextColor = color
end

-- Sets the DropDownHoverColor of the EGMComboBox
--
-- @param Color color
function ELEMENT:SetDropDownHoverColor(color)
    self.DropDownHoverColor = color
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmmodal.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          VGUI | EGMModal          --
---------------------------------------

ELEMENT.Name = "EGMModal"
ELEMENT.Base = "DFrame"


-- Initializes the EGMModal
function ELEMENT:Init()
	self.CustomTitle = ""
	self.TitleColor = UI.TextColor
	self.BarColor = UI.ForegroundColor
	self.Color = UI.BackgroundColor2

	local w, h = ScrW() * 0.25, ScrH() * 0.3
	self.BarHeight = h * 0.15

	self:SetSize(w, h)
	self:Center()
	self:SetTitle("")
	self:SetDraggable(true)
	self:ShowCloseButton(false)
	self:DockPadding(w * 0.01, h * 0.2, w * 0.01, h * 0.01)

	self:MakePopup()
end

-- Draws the EGMModal
function ELEMENT:Paint(width, height)
	draw.RoundedBox(0, 0, 0, width, height, self.Color)

	draw.RoundedBox(0, 0, 0, width, self.BarHeight, self.BarColor)

	draw.SimpleText(self.CustomTitle, "EGMText15", width * 0.5, self.BarHeight / 2, self.TitleColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end



---------------------------------------
--         Internal Functions        --
---------------------------------------

-- Cleans a modal from all previous elements
function ELEMENT:CleanModal()
	if IsValid(self.InfoPanel) then
		self.InfoPanel:Remove()
	end

	if IsValid(self.ConfirmButton) then
		self.ConfirmButton:Remove()
	end

	if IsValid(self.CancelButton) then
		self.CancelButton:Remove()
	end

	if IsValid(self.SelectionPanel) then
		self.SelectionPanel:Remove()
	end
end

-- Adds an info panel to the modal
--
-- @param String info
function ELEMENT:AddInfoPanel(info)
	local infoPanel = vgui.Create("RichText", self)
	infoPanel:Dock(FILL)
	infoPanel:SetVerticalScrollbarEnabled(true)
	infoPanel:SetText(info)
	function infoPanel:PerformLayout()
		self:SetFontInternal("EGMText8")
	end

	self.InfoPanel = infoPanel
end

-- Adds a button to the modal
--
-- @param? String text
-- @param? Color textColor
-- @param? Color buttonColor
-- @param? Function onClick
-- @return EGMButton button
function ELEMENT:AddButton(text, textColor, buttonColor, onClick)
	local _self = self

	local button = vgui.Create("EGMButton", self)
	button:DockMargin(0, self:GetTall() * 0.02, 0, 0)
	button:Dock(BOTTOM)
	button:SetHeight(self:GetTall() * 0.1)
	button:SetFont("EGMText8")

	button:SetButtonColor(buttonColor or UI.ForegroundColor)
	button:SetTextColor(textColor or UI.TextColor)
	button:SetText(text or "")
	function button:DoClick()
		_self:Remove()

		if isfunction(onClick) then
			onClick()
		end
	end

	return button
end

-- Adds a confirm button to the modal
--
-- @param? String confirmText
-- @param? Color confirmTextColor
-- @param? Color confirmColor
-- @param? Function onConfirm
function ELEMENT:AddConfirmButton(confirmText, confirmTextColor, confirmColor, onConfirm)
	local confirmButton = self:AddButton(confirmText or egmt("ui.modalconfirm"), confirmTextColor, confirmColor, onConfirm)

	self.ConfirmButton = confirmButton
end

-- Adds a cancel button to the modal
--
-- @param? String cancelText
-- @param? Color cancelTextColor
-- @param? Color cancelColor
-- @param? Function onCancel
function ELEMENT:AddCancelButton(cancelText, cancelTextColor, cancelColor, onCancel)
	local cancelButton = self:AddButton(cancelText or egmt("shared.abort"), cancelTextColor, cancelColor, onCancel)

	self.CancelButton = cancelButton
end



---------------------------------------
--          Modal Functions          --
---------------------------------------

-- Transforms the modal to a notify modal. Has a text and a confirm button inside.
--
-- @param String info
-- @param? String or Boolean confirmText
-- @param? Color confirmTextColor
-- @param? Color confirmColor
-- @param? Function onConfirm
function ELEMENT:Notify(info, confirmText, confirmTextColor, confirmColor, onConfirm)
	self:CleanModal()

	self:AddInfoPanel(info)
	self:AddConfirmButton(confirmText, confirmTextColor, confirmColor, onConfirm)
end

-- Transforms the modal to a confirm modal. Has a text, an accept and an decline button inside.
--
-- @param? String info
-- @param? Function onConfirm
-- @param? Function onCancel
-- @param? String confirmText
-- @param? String cancelText
-- @param? Color confirmTextColor
-- @param? Color confirmButtonColor
-- @param? Color cancelTextColor
-- @param? Color cancelButtonColor
function ELEMENT:Confirm(info, onConfirm, onCancel, confirmText, cancelText, confirmTextColor, confirmButtonColor, cancelTextColor, cancelButtonColor)
	self:CleanModal()

	self:AddInfoPanel(info)

	self:AddCancelButton(cancelText, cancelTextColor, cancelButtonColor, onCancel)
	self:AddConfirmButton(confirmText, confirmTextColor, confirmColor, onConfirm)
end

-- Transforms the modal to a selection modal. Has an info, a selection, a confirm and a cancel button inside.
--
-- @param? String info
-- @param? Table optionsText
-- @param? Table options
-- @param? Function onConfirm(optionData)
-- @param? Function onCancel()
-- @param? String confirmText
-- @param? String cancelText
-- @param? Color confirmTextColor
-- @param? Color confirmButtonColor
-- @param? Color cancelTextColor
-- @param? Color cancelButtonColor
function ELEMENT:Selection(info, optionsText, options, onConfirm, onCancel, confirmText, cancelText, confirmTextColor, confirmButtonColor, cancelTextColor, cancelButtonColor)
	local _self = self
	self:CleanModal()

	self:AddInfoPanel(info)

	self:AddCancelButton(cancelText, cancelTextColor, cancelButtonColor, onCancel)
	self:AddConfirmButton(confirmText, confirmTextColor, confirmButtonColor, function()
		onConfirm(_self.SelectionPanel.SelectedValue)
	end)

	local selectionPanel = vgui.Create("EGMComboBox", self)
	selectionPanel:DockMargin(0, self:GetTall() * 0.02, 0, self:GetTall() * 0.02)
	selectionPanel:Dock(BOTTOM)
	selectionPanel:SetHeight(self:GetTall() * 0.1)
	selectionPanel:SetDropDownHeight(self:GetTall() * 0.06)
	selectionPanel:SetValue(optionsText)
	selectionPanel:SetSortItems(false)
	for _, choice in pairs(options) do
		selectionPanel:AddChoice(choice.text, choice.data, choice.selected)

		if choice.selected then
			selectionPanel.SelectedValue = choice.data
		end
	end
	function selectionPanel:OnSelect(index, value, data)
		selectionPanel.SelectedValue = data
	end

	self.SelectionPanel = selectionPanel
end

-- Transforms the modal to a confirm modal. Has a text, an accept and an decline button inside.
--
-- @param? String info - defaults to "".
-- @param? onConfirm - called when the accept button is clicked.
-- @param? onCancel - called when the decline button is clicked.
-- @param Number minValue
-- @param Number maxValue
-- @param Number decimals
-- @param? String confirmText - defaults to "Okay".
-- @param? String cancelText - defaults to egmt("shared.abort").
-- @param? Color confirmTextColor - defaults to white.
-- @param? Color confirmButtonColor - defaults to green.
-- @param? Color cancelTextColor - defaults to white.
-- @param? Color cancelButtonColor - defaults to yellow.
function ELEMENT:Slider(info, onConfirm, onCancel, minValue, maxValue, decimals, confirmText, cancelText, confirmTextColor, confirmButtonColor, cancelTextColor, cancelButtonColor)
	local _self = self
	self:CleanModal()

	self:AddInfoPanel(info)

	self:AddCancelButton(cancelText, cancelTextColor, cancelButtonColor, onCancel)
	self:AddConfirmButton(confirmText, confirmTextColor, confirmButtonColor, function()
		local selectedValue = _self.SliderPanel:GetValue()
		selectedValue = math.Clamp(selectedValue, minValue, maxValue)
		selectedValue = math.Round(selectedValue, decimals)

		onConfirm(selectedValue)
	end)

	local sliderPanel = vgui.Create("DNumSlider", self)
    sliderPanel:SetHeight(self:GetTall() * 0.1)
    sliderPanel:Dock(BOTTOM)
    sliderPanel:DockMargin(0, 0, 0, 0)
    sliderPanel:SetMin(minValue)
    sliderPanel:SetMax(maxValue)
    sliderPanel:SetDecimals(decimals)
    function sliderPanel:ApplySchemeSettings()
    end

    sliderPanel.TextArea:SetPaintBackground(true)
    sliderPanel.TextArea:SetFont("EGMText6")
    sliderPanel.TextArea:SetTextColor(Color(0, 0, 0))
    sliderPanel.TextArea:SetWidth(ScrW() * 0.03)

    function sliderPanel.Slider:Paint(ww, hh)
        draw.RoundedBox(0, 0, hh / 2 - 4, ww, 8, UI.BackgroundColor)
    end
    sliderPanel.Slider.Knob:SetHeight(ScrH() * 0.02)
    function sliderPanel.Slider.Knob:Paint(ww, hh)
        if canEdit then
            draw.RoundedBox(0, 0, 0, ww, hh, UI.ForegroundColor)
        else
            draw.RoundedBox(0, 0, 0, ww, hh, Color(80, 80, 80))
        end
    end

    sliderPanel.Label:SetVisible(false)

    sliderPanel:InvalidateLayout(true)

	sliderPanel:SetValue(minValue)

	sliderPanel:SetMouseInputEnabled(true)
	function sliderPanel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
	end

	self.SliderPanel = sliderPanel

end

---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the title of the EGMModal
function ELEMENT:SetCustomTitle(title)
	self.CustomTitle = title
end

-- Sets the title color of the EGMModal
function ELEMENT:SetTitleColor(color)
	self.TitleColor = color
end

-- Sets the bar color of the EGMModal
function ELEMENT:SetBarColor(color)
	self.BarColor = color
end

-- Sets the background color of the EGMModal
function ELEMENT:SetColor(color)
	self.Color = color
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmprogressbar.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       VGUI | EGMProgressbar       --
---------------------------------------

ELEMENT.Name = "EGMProgressBar"
ELEMENT.Base = "DPanel"

-- Initializes the EGMProgressbar.
function ELEMENT:Init()
	self.BackgroundColor = UI.BackgroundColor2
	self.ProgressColor = UI.ForegroundColor

	self.Text = ""
	self.TextColor = UI.TextColor

	self.Progress = 0
end

-- Draws the EGMProgressbar.
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
	draw.RoundedBox(5, 0, 0, width, height, self.BackgroundColor)
	draw.RoundedBox(5, 0, 0, width * self.Progress, height, self.ProgressColor)

	draw.SimpleText(
		self.Text,
		"EGMText12",
		width / 2,
		height / 2,
		self.TextColor,
		TEXT_ALIGN_CENTER,
		TEXT_ALIGN_CENTER
	)
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the bar text.
--
-- @param String text
function ELEMENT:SetText(text)
	self.Text = text
end

-- Sets the bar text color.
--
-- @param String textColor
function ELEMENT:SetTextColor(textColor)
	self.TextColor = textColor
end

-- Sets the bar background color.
--
-- @param String backgroundColor
function ELEMENT:SetBackgroundColor(backgroundColor)
	self.BackgroundColor = backgroundColor
end

-- Sets the bar progress color.
--
-- @param String progressColor
function ELEMENT:SetProgressColor(progressColor)
	self.ProgressColor = progressColor
end

-- Sets the progress value.
--
-- @param Number progress between 0 and 1
function ELEMENT:SetProgress(progress)
	self.Progress = math.Clamp(progress, 0, 1)
end
--gamemodes/egmrp/gamemode/core/settings/sh_settings.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Settings | Shared         --
---------------------------------------

local PLAYER = FindMetaTable("Player")

function PLAYER:GetSetting(name)
    return self:GetNWBool("Settings." .. name, false)
end
--gamemodes/egmrp/gamemode/core/scoreboard/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Scoreboard | Config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- The width of the scoreboard. ScrW() represents the current screen width.
Scoreboard.Width = ScrW() * 0.8

-- The height of the scoreboard. ScrH() represents the current screen height.
Scoreboard.Height = ScrH() * 0.8

-- The padding of the scoreboard. Basically the spacing between different elements.
Scoreboard.Padding = 10
--gamemodes/egmrp/gamemode/core/scoreboard/vgui/cl_scorerow.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          VGUI | Scorerow          --
---------------------------------------

local EGMScoreRow = {}

-- Creates a new EGMScoreRow.
function EGMScoreRow:Init()
    local row = self
    self.backgroundColor = Color(20, 20, 20, 120)
    self.hoveredColor = UI.ForegroundColor
    self.NextThink = CurTime()

    local h = ScrH() / 32
    self:SetCursor("hand")
    self:Dock(TOP)
    self:DockMargin(ScrW() * 0.01, ScrH() * 0.005, ScrW() * 0.01, 0)
    self:SetHeight(h)

    self.avatarButton = vgui.Create("DButton", self)
    self.avatarButton:SetPos(2, 2)
    self.avatarButton:SetSize(h - 4, h - 4)
    function self.avatarButton:DoClick()
        row.Player:ShowProfile()
    end
    function self.avatarButton:Paint(width, height)
    end

    self.avatar = vgui.Create("AvatarImage", self.avatarButton)
    self.avatar:SetSize(h - 4, h - 4)
    self.avatar:SetMouseInputEnabled(false)

    -- Donator module support.
    if Config.Modules["donator"] then
        self.donator = vgui.Create("DImage", self)
        self.donator:SetPos(h + 2, 2)
        self.donator:SetSize(h - 4, h - 4)
        self.donator:SetImage(egmt("donator.icon"))
        self.donator:SetVisible(false)
    end

    -- Instructor module support.
    if Config.Modules["instructor"] then
        self.instructor = vgui.Create("DImage", self)
        self.instructor:SetSize(h - 4, h - 4)
        self.instructor:SetImage("icons/instructor/ausbilder.png")
        self.instructor:SetVisible(false)
        self.instructor:SetImageColor(GetColor("green"))
    end

    self.mute = vgui.Create("DImageButton", self)
    self.mute:SetSize(h - 4, h - 4)
    function self.mute.DoClick() -- .DoClick instead of :DoClick because we need the self to be EGMScoreRow
        self.Player:SetMuted(not self.Player:IsMuted())
        self.mute:SetImage(self.Player:IsMuted() and "icon32/muted.png" or "icon32/unmuted.png")
    end
end

function EGMScoreRow:PerformLayout()
    local h = ScrH() / 32
    self.mute:SetPos(self:GetWide() - h, 4)

    if self.instructor then
        self.instructor:SetPos(self:GetWide() - h * 2, 4)
    end
end

-- Update the player data every second.
function EGMScoreRow:Think()
    if not IsValid(self.Player) then self:Remove() return end

    if CurTime() >= self.NextThink and self.Ready then
        self:UpdatePlayerData()

        self.NextThink = CurTime() + 1
    end
end

-- Draws the scorerow with it's data.
function EGMScoreRow:Paint(width, height)
    if not self.Ready then return end

    local hovered = self:IsHovered() or IsValid(self.contextMenu)

    draw.RoundedBox(0, 0, 0, width, height, hovered and self.hoveredColor or self.backgroundColor)

    for k, v in SortedPairs(self.plyData) do
        draw.SimpleText(v.text, v.font, Scoreboard:GetScoreColumnDataPos(k), height / 2 - 1, not hovered and v.color or UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

-- Opens the context menu with the options specified in Scoreboard.Options.
function EGMScoreRow:OnMousePressed(mouseEnum)
    if mouseEnum == MOUSE_RIGHT then
        self.contextMenu = DermaMenu(self)
        function self.contextMenu:Paint(width, height)
            draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
            surface.SetDrawColor(UI.ForegroundColor)
            self:DrawOutlinedRect()
        end

        local lastOrder = 0
        for k, option in SortedPairsByMemberValue(Scoreboard.Options, "order") do
            if isfunction(option.shouldShow) and option.shouldShow(self.Player) or option.shouldShow == true then
                if option.order - lastOrder >= 50 then
                    local spacer = self.contextMenu:AddSpacer()
                    function spacer:Paint(width, height)
                        draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)
                    end
                end

                local optionPanel = self.contextMenu:AddOption(option.name, function()
                    option.callback(self.Player)
                end)
                optionPanel:SetColor(GetColor("white"))
                optionPanel:SetFont("DermaDefaultBold")
                function optionPanel:Paint(width, height)
                    if self:IsHovered() then
                        draw.RoundedBox(0, 0, 0, width, height, GetColor("blue"))
                    elseif k % 2 == 0 then
                        draw.RoundedBox(0, 0, 0, width, height, GetColor("darkgray"))
                    else
                        draw.RoundedBox(0, 0, 0, width, height, GetColor("gray"))
                    end
                end

                local icon = vgui.Create("DImage", optionPanel)
                icon:SetPos(optionPanel:GetWide() * 0.075, optionPanel:GetTall() * 0.05)
                icon:SetSize(16, 16)
                icon:SetImage(option.icon)

                lastOrder = option.order
            end
        end

        self.contextMenu:Open()
    end
end

-- Remove the contextMenu when the score row gets removed.
function EGMScoreRow:OnRemove()
    if IsValid(self.contextMenu) then
        self.contextMenu:Remove()
    end
end

-- Sets the player assosiated with the scorerow.
--
-- @param Player ply
function EGMScoreRow:SetPlayer(ply)
    if IsValid(ply) then
        self.Player = ply
        ply.ScoreRow = self

        self.avatar:SetPlayer(ply)

        self:UpdatePlayerData()

        self.Ready = true
    end
end

-- Updates the player data visible in the scorerrow.
function EGMScoreRow:UpdatePlayerData()
    self.plyData = {}

    for k, v in SortedPairs(Scoreboard.Columns) do
        local text, color = v.data(self.Player)

        local size = ScrW() * v.width
        local length = #tostring(text)

        local fontSize = math.Min(math.Max(math.Round(math.sqrt(size / length) * 1.75, 0), 1), 16)
        local font = "EGMText10"

        if fontSize < 10 then
            font = "EGM" .. "Text" .. fontSize
        end

        table.insert(self.plyData, {["text"] = text, ["color"] = color or Color(255, 255, 255, 255), ["font"] = font})
    end

    self.mute:SetImage(self.Player:IsMuted() and "icon32/muted.png" or "icon32/unmuted.png")

    if self.donator then
        local donatorColors = self.Player:GetScoreboardDonatorColors()
        if table.Count(donatorColors) > 0 then
            self.donator:SetVisible(true)

            -- Rainbow Donator!
            local color = donatorColors[(math.floor(CurTime()) % #donatorColors) + 1]
            self.donator:SetImageColor(color)
        else
            self.donator:SetVisible(false)
        end
    end

    if self.instructor then
        self.instructor:SetVisible(self.Player:IsInstructor())
        self.instructor:SetImageColor(Instructor:GetScoreboardColor(self.Player))
    end
end

-- Sets the Background Color of the Scorerrow
--
-- @param Color color
function EGMScoreRow:SetBackgroundColor(color)
    self.backgroundColor = color
end

-- Sets the Hovered Color of the Scorerrow
--
-- @param Color color
function EGMScoreRow:SetHoveredColor(color)
    self.hoveredColor = color
end

vgui.Register("EGMScoreRow", EGMScoreRow, "DPanel")
--gamemodes/egmrp/gamemode/core/eventlog/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Server | Event Log Keybinds    --
---------------------------------------

-- Keybind to open the event logs.
KeyBind:Register(egmt("eventlog.title"), egmt("shared.team"), function()
    EventLog:Open()
end, EventLog.DefaultKey)

--gamemodes/egmrp/gamemode/core/performance/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Performance | Index        --
---------------------------------------

if SERVER then
    AddCSLuaFile("sh_performance.lua")
    AddCSLuaFile("cl_performance.lua")

    include("sh_performance.lua")
    include("sv_performance.lua")
end

if CLIENT then
    include("sh_performance.lua")
    include("cl_performance.lua")
end
--gamemodes/egmrp/gamemode/core/manager/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Keybinds | Client         --
---------------------------------------

-- Add a keybind for opening the faction rank manager.
KeyBind:Register(egmt("manager.name"), egmt("shared.team"), function()
    Manager:Open()
end, Manager.DefaultKey)

--gamemodes/egmrp/gamemode/core/manager/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Interact | Client         --
---------------------------------------

if Config.Modules["interact"] then
    hook.Add("EGMRP.Loaded", "Manager.Interact", function()
        Interact:RegisterOption("team", egmt("manager.name"), 1, function()
            Manager:Open()
            Interact.Menu:Remove()
        end, function()
            return LocalPlayer():IsAtLeast(Manager.MinAccessGroup)
        end)
    end)
end
--gamemodes/egmrp/gamemode/core/player/sh_player.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Player System      --
---------------------------------------

-- Set sharedside property variables.
PlayerData.Name = "PlayerData"

-- SteamId64 of the player. Used for identification.
PlayerData:AddData("steamId64", "string", "steamid64", "VARCHAR(17) NOT NULL UNIQUE",
function(playerData, value)
    if not isstring(value) or not #value == 17 then
        return false, egmt("player.invalid_steamid64")
    end

    return true
end,
function(playerData, ply)
    return true
end)

-- Initialize networking
-- Only Edit Networking is enable, since player is networked manually on creation and cannot be deleted.
PlayerData:InitEditNetworking()

-- Add player properties for the players steamname
PlayerData:AddProperty("steamname", "string", nil, nil, function(playerData, ply)
    if playerData:GetPlayer() then
        return false
    end

    return true
end)

-- Add player properties for the players last online time.
PlayerData:AddProperty("lastonline", "number", nil, nil, function(playerData, ply)
    return true
end)

-- Limit access to the edit functions.
hook.Add("PlayerData.CanPlayerEditProperties", "PlayerData.EditPropertiesPermissions", function(ply, playerData, properties)
    if ply:IsAtLeast("superadmin") then
        return true
    end
end)

-- Player Cache extension, to support getting a cached player data by Steam64Id.
-- Lookup table for getting the player id from a Steam64Id.
PlayerData.SteamId64ToId = PlayerData.SteamId64ToId or {}

-- Override the PlayerData.Cache function, to support caching the Steam64Id.
hook.Add("PlayerData.Cache", "PlayerData.SteamId64Cache", function(propertyModel)
    PlayerData.SteamId64ToId[propertyModel:Get("steamId64")] = propertyModel:GetId()
end)

-- Override the PlayerData.RemoveFromCache function, to support removing the Steam64Id from the cache.
hook.Add("PlayerData.RemoveFromCache", "PlayerData.SteamId64Cache", function(propertyModel)
    PlayerData.SteamId64ToId[propertyModel:Get("steamId64")] = nil
end)

-- Override the PlayerData.GetCached function to support getting a cached player data by Steam64Id.
hook.Add("PlayerData.GetCached", "PlayerData.SteamId64Cache", function(steamId64)
    if isstring(steamId64) and #steamId64 == 17 then
        return PlayerData:GetCached(PlayerData.SteamId64ToId[steamId64])
    end
end)

-- Tries to fetch a Player by the SteamId64 on the player data.
-- Only works if the player is currently online.
--
-- @return Player ply
function PlayerData.Meta:GetPlayer()
    local ply = player.GetBySteamID64(self:Get("steamId64"))

    if IsValid(ply) then
        return ply
    end

    return false
end

-- Checks whether the player data belongs to the player.
--
-- @param Player ply
-- @return Boolean belongsTo
function PlayerData.Meta:BelongsTo(ply)
    return self:Get("steamId64") == ply:SteamID64()
end

-- Returns the steamname of the player.
--
-- @return String steamname
function PlayerData.Meta:GetName()
    return self:GetPlayer() and self:GetPlayer():SteamName() or self:GetProperty("steamname", egmt("player.display_name", self:GetId()))
end
--gamemodes/egmrp/gamemode/core/faction/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Faction | Index          --
---------------------------------------

Faction = Faction or table.Copy(PropertyModel)
FactionManager = FactionManager or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_faction.lua")
    AddCSLuaFile("cl_faction.lua")

    AddCSLuaFile("cl_manager.lua")

    include("sh_config.lua")
    include("sh_faction.lua")
    include("sv_faction.lua")

    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_faction.lua")
    include("cl_faction.lua")

    include("cl_manager.lua")
end
--gamemodes/egmrp/gamemode/core/faction/cl_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Faction         --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Faction.PropertyList = {}

-- Add faction properties to list. These are editable in faction creation and edit.
Faction:AddPropertyToList("name", egmt("factionrank.name"), egmt("faction.name_description"), "string", nil, nil, 1, nil)

Faction:AddPropertyToList("prefix", egmt("faction.prefix"), egmt("faction.prefix_description"), "string", nil, nil, 2, nil)

Faction:AddPropertyToList("parentId", egmt("faction.parentId"), egmt("faction.parentId_description"), "dropdown", function(faction)
	local values = {}

	for k, parentFaction in pairs(Faction:GetCache()) do
		if parentFaction == faction then continue end

		table.insert(values, {
			text = parentFaction:GetName(),
			data = parentFaction:GetId(),
		})
	end

	table.insert(values, {
		text = egmt("faction.no_faction"),
		data = -1,
	})

	return values
end, nil, 3, nil)

Faction:AddPropertyToList("description", egmt("faction.description"), egmt("faction.description_description"), "text", nil, nil, 4, nil)

Faction:AddPropertyToList("color", egmt("faction.color"), egmt("faction.color_description"), "color", nil, nil, 5, nil)

Faction:AddPropertyToList("models", egmt("faction.models"), egmt("faction.models_description"), "models", function(faction)
	local validModels = table.Copy(player_manager.AllValidModels())
	hook.Run("Faction.AddModels", faction, validModels)
	hook.Run("Faction.RemoveModels", faction, validModels)

	local inheritedModels = {}

	local parentFaction = faction:GetParent()
	if parentFaction then
		inheritedModels = parentFaction:GetModels()
	end

	local values = {
		validModels = validModels,
		inheritedModels = inheritedModels
	}

	return values
end, nil, 1, egmt("equipment.category"))

Faction:AddPropertyToList("weapons", egmt("faction.weapons"), egmt("faction.weapons_description"), "table", function(faction)
	local values = {
		validValues = {}
	}

	local parentFaction = faction:GetParent()
	if parentFaction then
		values.inheritedValues = parentFaction:GetWeapons()
	end

	for weaponClass, weaponData in SortedPairs(list.Get("Weapon")) do
		if Manager.HideUnspawnableWeapons and not weaponData.Spawnable then continue end
		if table.HasValue(Character.DefaultWeapons, weaponClass) then continue end

		values.validValues[weaponClass] = weaponData.PrintName or weaponClass
	end

	-- Allow other modules to add or remove weapons.
	hook.Run("Faction.AddWeapons", values.validValues, faction)
	hook.Run("Faction.RemoveWeapons", values.validValues, faction)

	return values
end, nil, 2, egmt("equipment.category"))

-- Register faction package type.
Loading:RegisterPackageType("faction", egmt("faction.package"), function(packageData)
	for k, fData in pairs(packageData) do
		Faction:Load(fData.data, fData.properties):Cache()
	end

	hook.Run("Faction.LoadedAll")
end)
--gamemodes/egmrp/gamemode/core/rank/cl_rank.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Client | Rank           --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Rank.PropertyList = {}

-- Add rank properties to list. These are editable in rank creation and edit.
Rank:AddPropertyToList("name", egmt("factionrank.name"), egmt("rank.name_description"), "string", nil, nil, 1, nil)

Rank:AddPropertyToList("prefix", egmt("rank.prefix"), egmt("rank.prefix_description"), "string", nil, nil, 2, nil)

Rank:AddPropertyToList("inheritRank", egmt("rank.inherit"), egmt("rank.inherit_description"), "boolean", nil, nil, 3, nil)

Rank:AddPropertyToList("description", egmt("rank.description"), egmt("rank.description_description"), "text", nil, nil, 4, nil)

Rank:AddPropertyToList("color", egmt("rank.color"), egmt("rank.color_description"), "color", nil, nil, 5, nil)

Rank:AddPropertyToList("authorityLevel", egmt("rank.authorityLevel"), egmt("rank.authorityLevel_description"), "number", nil, nil, 1, egmt("rank.permissions"))

Rank:AddPropertyToList("permissions", egmt("rank.permissions"), egmt("rank.permissions_description"), "list", function(faction, rank)
    local values = {}

    for id, name in SortedPairs(Rank.Permissions) do
        table.insert(values, {
            text = name,
            data = id,
        })
    end

    return values
end, nil, 2, egmt("rank.permissions"))

Rank:AddPropertyToList("health", egmt("rank.health"), egmt("rank.health_description"), "number", nil, nil, 1, egmt("rank.stats"))

Rank:AddPropertyToList("armor", egmt("rank.armor"), egmt("rank.armor_description"), "slider", function(faction, rank)
	return {min = 0, max = 255}
end, nil, 2, egmt("rank.stats"))

Rank:AddPropertyToList("speed", egmt("rank.speed"), egmt("rank.speed_description"), "slider", function(faction, rank)
	return {min = 1, max = 500}
end, nil, 3, egmt("rank.stats"))

Rank:AddPropertyToList("jumpPower", egmt("rank.jumpPower"), egmt("rank.jumpPower_description"), "slider", function(faction, rank)
	return {min = 1, max = 1000}
end, nil, 4, egmt("rank.stats"))

Rank:AddPropertyToList("scale", egmt("rankscale.name"), egmt("rankscale.description"), "slider", function(faction, rank) --
	return {min = 0.8, max = 1.2, dec = 2} -- Tight limits, because ragdolls cannot be scaled.
end, nil, 5, egmt("rank.stats"))

Rank:AddPropertyToList("models", egmt("rank.models"), egmt("rank.models_description"), "models", function(faction, rank)
    local validModels = table.Copy(player_manager.AllValidModels())
	hook.Run("Rank.AddModels", faction, rank, validModels)
	hook.Run("Rank.RemoveModels", faction, rank, validModels)

    local factionModels = faction:GetModels()

    local values = {
        validModels = validModels,
        inheritedModels = factionModels
    }

    return values
end, nil, 1, egmt("equipment.category"))

Rank:AddPropertyToList("weapons", egmt("rank.weapons"), egmt("rank.weapons_description"), "table", function(faction, rank)
    local values = {
        validValues = {},
    }

    values.inheritedValues = faction:GetWeapons()

    for weaponClass, weaponData in SortedPairs(list.Get("Weapon")) do
        if Manager.HideUnspawnableWeapons and not weaponData.Spawnable then continue end
        if table.HasValue(Character.DefaultWeapons, weaponClass) then continue end

        values.validValues[weaponClass] = weaponData.PrintName or weaponClass
    end

	-- Allow other modules to add or remove weapons.
	hook.Run("Rank.AddWeapons", values.validValues, faction, rank)
	hook.Run("Rank.RemoveWeapons", values.validValues, faction, rank)

    return values
end, nil, 2, egmt("equipment.category"))

Rank:AddPropertyToList("isTeammember", egmt("rank.team"), egmt("rank.team_description"), "boolean", nil, nil, 1, egmt("character.slotType_name"))

Rank:AddPropertyToList("isStartRank", egmt("rank.isStartRank"), egmt("rank.isStartRank_description"), "boolean", nil, nil, 2, egmt("character.slotType_name"))

Rank:AddPropertyToList("slotType", egmt("character.slotType_name"), egmt("character.slotType_description"), "dropdown", function(faction, rank)
    local slotTypes = {}

    for k, v in pairs(Rank.SlotTypes) do
        table.insert(slotTypes, {text = v.name, data = k})
    end

    return slotTypes
end, nil, 3, egmt("character.slotType_name"))

-- Register rank package type.
Loading:RegisterPackageType("rank", egmt("rank.package"), function(packageData)
    for k, rData in pairs(packageData) do
        Rank:Load(rData.data, rData.properties):Cache()
    end
end)



---------------------------------------
--               Hooks               --
---------------------------------------

-- Overide the player info, when the source is a team member.
hook.Add("UI.ShouldDrawFullName", "Rank.OverrideTeamMember", function(currentCharacter, currentFaction, targetCharacter, targetFaction)
	local rank = currentCharacter:GetRank()
	if not rank then return end

	if rank:GetProperty("isTeammember", false) then
		return true
	end
end)
--gamemodes/egmrp/gamemode/core/equipment/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Equipment         --
---------------------------------------

Equipment = Equipment or table.Copy(PropertyModel)

if SERVER then
    AddCSLuaFile("sh_equipment.lua")
    AddCSLuaFile("cl_equipment.lua")
    AddCSLuaFile("cl_manager.lua")

    include("sh_equipment.lua")
    include("sv_equipment.lua")
end

if CLIENT then
    include("sh_equipment.lua")
    include("cl_equipment.lua")
    include("cl_manager.lua")
end
--gamemodes/egmrp/gamemode/core/equipment/sh_equipment.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Equipment        --
---------------------------------------

-- Set sharedside property variables.
Equipment.Name = "Equipment"

Equipment:AddData("factionId", "number", "faction_id", "INT NOT NULL",
function(equip, value)
    if not isnumber(value) then
        return false, egmt("equipment.invalid_faction_id")
    end

    local faction = Faction:GetCached(value)

    if not (faction and faction:IsValid()) then
        return false, egmt("equipment.invalid_faction")
    end

    return true
end,
function(equip, ply)
    return true
end)

-- Returns the Faction of the equipment.
--
-- @return Table faction
function Equipment.Meta:GetFaction()
    return Faction:GetCached(self:Get("factionId"))
end

-- Alias for Equipment:GetFaction used in the manager.
--
-- @return Table faction
function Equipment.Meta:GetParent()
    return self:GetFaction()
end

-- Gets every equipment belonging to the given faction id.
--
-- @param Number factionId
-- @param Boolean hideInherited
-- @return Table equipment
function Equipment:GetByFaction(factionId, hideInherited)
    local equipment = {}

    for id, equip in pairs(self:GetCache()) do
        if equip:Get("factionId") ~= factionId then
            continue
        end

        if hideInherited and not equip:GetProperty("inheritEquipment", false) then
            continue
        end

        table.insert(equipment, equip)
    end

    local faction = Faction:GetCached(factionId)
    local parent = faction:GetParent()
    if parent then
        local parentEquipments = self:GetByFaction(parent:GetId(), true)
        MergeTableByValue(equipment, parentEquipments)
    end

    return equipment
end

-- Alias function for Equipment:GetByFaction.
function Faction.Meta:GetEquipment()
    return Equipment:GetByFaction(self:GetId())
end

-- Initialize networking.
Equipment:InitCreationNetworking()
Equipment:InitEditNetworking()
Equipment:InitDeletionNetworking()

-- Util Function to get the rank whitelist string.
--
-- @param Table rankWhitelist
-- @return String rankWhitelistString
function Faction.Meta:GetRankWhitelistString(rankWhitelist)
	local affectedList = {}
	local allAffected = true

	local hasHigher = true
	local simpleHigher

	local lowerPossible = true
	local simpleLower
	if table.Count(rankWhitelist) == 0 then
		allAffected = true
	else
		for _, rank in ipairs(self:GetSortedRanks()) do
			if table.HasValue(rankWhitelist, rank:GetId()) then
				local short = rank:GetPrefix()
				if short == "" then
					short = rank:GetName()
				end

				if hasHigher then
					simpleHigher = short
				else
					simpleHigher = false
				end

				if lowerPossible and not simpleLower then
					simpleLower = short
				end

				table.insert(affectedList, short)
			else
				hasHigher = false
				allAffected = false

				if simpleLower then
					lowerPossible = false
					simpleLower = false
				end
			end
		end
	end

	local rankWhitelistString = ""
	if table.Count(affectedList) == 1 then
		rankWhitelistString = affectedList[1]
	elseif allAffected then
		rankWhitelistString = egmt("equipment.all_ranks")
	elseif table.Count(affectedList) == 0 then
		rankWhitelistString = egmt("equipment.no_ranks")
	elseif simpleHigher then
		rankWhitelistString = simpleHigher .. "+"
	elseif simpleLower then
		rankWhitelistString = simpleLower .. "-"
	else
		rankWhitelistString = table.concat(affectedList, ", ")
	end

	if #rankWhitelistString > 42 then
		rankWhitelistString = egmt("equipment.long_ranks")
	end

	return rankWhitelistString
end

-- Used to get the name of the equipment.
-- Dynamically generated from the the content.
--
-- @return String name
function Equipment.Meta:GetName()
    local effectList = {}

    local healthBonus = self:GetProperty("healthBonus", 0)
    if healthBonus > 0 then
        table.insert(effectList, egmt("equipment.health_plus"))
    elseif healthBonus < 0 then
        table.insert(effectList, egmt("equipment.health_minus"))
    end

    local armorBonus = self:GetProperty("armorBonus", 0)
    if armorBonus > 0 then
        table.insert(effectList, egmt("equipment.armor_plus"))
    elseif armorBonus < 0 then
        table.insert(effectList, egmt("equipment.armor_minus"))
    end

    local speedBonus = self:GetProperty("speedBonus", 0)
    if speedBonus > 0 then
        table.insert(effectList, egmt("equipment.speed_plus"))
    elseif speedBonus < 0 then
        table.insert(effectList, egmt("equipment.speed_minus"))
    end

    local blacklist = self:GetProperty("blacklist", false)
    local equipmentModels = self:GetProperty("models", {})
    local equipmentWeapons = self:GetProperty("weapons", {})

    if table.Count(equipmentModels) > 0 then
        if blacklist then
            table.insert(effectList, egmt("equipment.model_blacklist"))
        else
            table.insert(effectList, egmt("equipment.model_whitelist"))
        end
    end

    if table.Count(equipmentWeapons) > 0 then
        if blacklist then
            table.insert(effectList, egmt("equipment.weapon_blacklist"))
        else
            table.insert(effectList, egmt("equipment.weapon_whitelist"))
        end
    end

    -- Run hook to add custom effects.
    hook.Run("Equipment.GetEffectList", self, effectList)

    -- If no effects are set, return the default name.
    if table.Count(effectList) == 0 then
        return egmt("equipment.no_effect")
    end

    local effectString = table.concat(effectList, ", ")

	local rankWhiteList = self:GetProperty("rankWhitelist", {})
	local affectedString = self:GetFaction():GetRankWhitelistString(rankWhiteList)

    -- Add custom affected data in brackets.
    local affectedBonus = {}
    hook.Run("Equipment.AddAffectedBonus", self, affectedBonus)
    if table.Count(affectedBonus) > 0 then
        affectedString = affectedString .. " (" .. table.concat(affectedBonus, ", ") .. ")"
    end

	-- Allow a full override of the affected string.
	local overrideAffected = ""
	overrideAffected = hook.Run("Equipment.OverrideAffected", self)
	if isstring(overrideAffected) then
		affectedString = overrideAffected
	end

    return affectedString .. " | " .. effectString
end

-- Add equipment property: rankWhitelist
Equipment:AddProperty("rankWhitelist", "table", {}, function(equip, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(equip, ply)
    return true
end)

-- Return, if the equipment is whitelisted for the given rank.
--
-- @param Table rank
function Equipment.Meta:IsRankWhitelisted(rank)
	if not rank then return false end

	local rankWhitelist = self:GetProperty("rankWhitelist", {})
	if table.Count(rankWhitelist) == 0 then
		return true
	end

    return table.HasValue(rankWhitelist, rank:GetId())
end

-- Add equipment property: inheritEquipment
Equipment:AddProperty("inheritEquipment", "boolean", false, function(equip, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(equip, ply)
    return true
end)

-- Add equipment property: healthBonus
Equipment:AddProperty("healthBonus", "number", 0, function(equip, value)
	if not isnumber(value) then
		return false, egmt("equipment.invalid_health")
	end

	return true
end,
function(equip, ply)
	return true
end)

-- Add equipment property: armorBonus
Equipment:AddProperty("armorBonus", "number", 0, function(equip, value)
	if not isnumber(value) then
		return false, egmt("equipment.invalid_armor")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Add equipment property: speedBonus
Equipment:AddProperty("speedBonus", "number", 0, function(equip, value)
	if not isnumber(value) then
		return false, egmt("equipment.invalid_speed")
	end

	return true
end,
function(equip, ply)
	return true
end)

-- Add equipment property: jumpBonus
Equipment:AddProperty("jumpBonus", "number", 0, function(equip, value)
	if not isnumber(value) then
		return false, egmt("equipment.invalid_jump")
	end

	return true
end,
function(equip, ply)
	return true
end)

Equipment:AddProperty("blacklist", "boolean", false, function(equip, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(equip, ply)
    return true
end)

-- Add equipment property: models
Equipment:AddProperty("models", "table", {}, function(equipment, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(equipment, ply)
    return true
end)

-- Returns all models, that are available for that equipment.
--
-- @return Table models
function Equipment.Meta:GetModels()
    local equipmentModels = {}
    for _, model in pairs(self:GetProperty("models", {})) do
        if isstring(model) then
            table.insert(equipmentModels, model)
        elseif istable(model) then
            -- Check, if one skin is available.
            for _, selected in pairs(model.Skins) do
                if selected then
                    table.insert(equipmentModels, model.Model)
                    break
                end
            end
        end
    end

    return equipmentModels
end

-- Returns all skins, that are available for that equipment given a model.
--
-- @param String model
-- @return Boolean allSkins
-- @return? Table equipmentSkins
function Equipment.Meta:GetSkins(model)
    if not isstring(model) then return false end

    for _, modelData in pairs(self:GetProperty("models", {})) do
        if isstring(modelData) and modelData == model then
            return true
        end

        local equipmentSkins = {}
        if istable(modelData) and modelData.Model == model then
            for skin, selected in pairs(modelData.Skins) do
                if selected then
                    table.insert(equipmentSkins, skin)
                end
            end

            return false, equipmentSkins
        end
    end

    return false
end

-- Add equipment property: weapons
Equipment:AddProperty("weapons", "table", {}, function(equipment, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(equipment, ply)
    return true
end)

-- Limit access to the edit functions.
hook.Add("Equipment.CanPlayerEditProperties", "Equipment.EditPropertiesPermissions", function(ply, equip, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Equipment.CanPlayerEditData.factionId", "Equipment.EditFactionIdPermissions", function(ply, equip, factionId)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Equipment.CanPlayerCreate", "Equipment.CreatePermissions", function(ply, data, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Equipment.CanPlayerDelete", "Equipment.DeletePermissions", function(ply, character)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)
--gamemodes/egmrp/gamemode/core/character/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--  Character - Scoreboard | Client  --
---------------------------------------

-- Add "Promote / Demote" option to the scoreboard.
Scoreboard:AddOption(
	egmt("character.promote_demote"),
	"icon16/award_star_gold_2.png",
	801,
	function(target)
		target:GetCurrentCharacter():OpenEditRankMenu()
	end,
	function(target)
		local ply = LocalPlayer()

		local character = target:GetCurrentCharacter()
		if not character then return false end

		-- Only show the promote / demote button if we can promote / demote to at least one other rank.
		for k, rank in pairs(character:GetFaction():GetRanks()) do
			if ply:CanChangeFactionRank(character, rank:GetId()) then
				return true
			end
		end

		return false
	end
)

-- Adds the "Kick" option to the scoreboard.
Scoreboard:AddOption(
	egmt("instructor.kick"),
	"icon16/award_star_delete.png",
	803,
	function(target)
		target:GetCurrentCharacter():OpenKickMenu()
	end,
	function(target)
		local ply = LocalPlayer()

		local character = target:GetCurrentCharacter()
		if not character then return false end

		-- Only show the kick button if we can kick to at least one rank.
		for _, rank in pairs(Rank:GetCache()) do
			if not rank:CanBeKickedOnto() then continue end

			if ply:CanChangeFactionRank(character, rank:GetId(), rank:GetFaction():GetId()) then
				return true
			end
		end

		return false
	end
)

-- Add "Invite" option to the scoreboard.
Scoreboard:AddOption(
	egmt("character.invite"),
	"icon16/award_star_gold_2.png",
	802,
	function(target)
		target:GetCurrentCharacter():OpenInviteMenu()
	end,
	function(target)
		local ply = LocalPlayer()

		local character = target:GetCurrentCharacter()
		if not character then return false end

		local targetFaction = character:GetFaction()
		if not targetFaction then return false end

		local playerCharacter = ply:GetCurrentCharacter()
		if not playerCharacter then return false end

		local faction = playerCharacter:GetFaction()
		if not faction then return false end

		if faction:GetId() == targetFaction:GetId() then return false end

		-- Only show the button when we can invite to at least one other rank.
		-- We are only checking ranks inside the faction, because you are only allowed to invite to your faction.
		for k, rank in pairs(faction:GetRanks()) do
			if ply:CanChangeFactionRank(character, rank:GetId(), faction:GetId(), true) then
				return true
			end
		end

		local allowInvite = hook.Run("Character.CanInvite", ply, character)
		if allowInvite then
			return true
		end

		return false
    end
)
--gamemodes/egmrp/gamemode/core/deathsystem/cl_deathsystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       DeathSystem | Client        --
---------------------------------------

-- Net receivers to keep the last death time updated (for the respawn info).
net.Receive("DeathSystem.SyncLastDeathTime", function()
    local ply = LocalPlayer()

    ply.LastDeathTime = net.ReadInt(32)
    ply.LastDeathDuration = net.ReadInt(32)
    ply.LastDeathStunned = net.ReadBool()

    local overrideDeathMessage = hook.Run("DeathSystem.OverrideDeathMessage", ply)
    if isstring(overrideDeathMessage) then
        ply.LastDeathMessage = overrideDeathMessage

        return
    end

    if ply.LastDeathStunned then
        ply.LastDeathMessage = egmt("deathsystem.stunned")
    else
        ply.LastDeathMessage = egmt("deathsystem.dead")
    end
end)

hook.Add("HUDShouldDraw", "Injuries.HideHUD", function(element)
    local ply = LocalPlayer()

    if IsValid(ply) and not ply:Alive() and (element == "EGMRPHud" or element == "EGMRPComlink") then
        return false
    end
end)

-- Paint the death screen.
hook.Add("HUDPaint", "DeathSystem.PaintScreen", function()
    local ply = LocalPlayer()
    if not IsValid(ply) then return end
    if ply:Alive() then return end

    local lastDeathTime = ply.LastDeathTime

    if lastDeathTime and lastDeathTime > 0 then
        local readyToSpawn = false
        local timeUntilRespawn = 0
        local w, h = ScrW(), ScrH()

        if lastDeathTime then
            timeUntilRespawn = (lastDeathTime + ply.LastDeathDuration) - CurTime()

            if timeUntilRespawn <= 0 then
                readyToSpawn = true
            end
        else
            readyToSpawn = true
        end

        draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), UI.BackgroundColor)

        draw.RoundedBox(0, 0, 0, ScrW(), h * 0.1, UI.BackgroundColor2)
        draw.RoundedBox(0, 0, ScrH() - h * 0.1, ScrW(), h * 0.1, UI.BackgroundColor2)

        if readyToSpawn then
            draw.DrawText(egmt("deathsystem.respawnready"), "EGMText15", w * 0.5, h * 0.9, GetColor("green"), TEXT_ALIGN_CENTER)
        else
            draw.DrawText(os.date("%M:%S", timeUntilRespawn), "EGMText15", w * 0.5, h * 0.9, GetColor("red"), TEXT_ALIGN_CENTER)
        end

        draw.DrawText(ply.LastDeathMessage, "EGMText15", w * 0.5, h * 0.035, UI.TextColor, TEXT_ALIGN_CENTER)
    end
end)
--gamemodes/egmrp/gamemode/modules/interact/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Interact index           --
---------------------------------------

Interact = Interact or {}

if SERVER then
    AddCSLuaFile("cl_interactmenu.lua")
    AddCSLuaFile("cl_interact.lua")
    AddCSLuaFile("cl_keybinds.lua")
end

if CLIENT then
    include("cl_interactmenu.lua")
    include("cl_interact.lua")
    include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/modules/unarmed/sh_pickup.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--      Unarmed Pickup | Shared      --
---------------------------------------

-- Can a player pick up a target?
--
-- @param Player ply
-- @param Entity target
-- @return Boolean canPickup
-- @return? Entity target
function Unarmed:CanPlayerPickup(ply, target)
	if ply:GetNWBool("Unarmed.CarryingRagdoll", false) then
		return false
	end

	local wep = ply:GetActiveWeapon()
	if not IsValid(wep) or wep:GetClass() ~= "egmrp_unarmed" then
		return false
	end

	if ply:GetNWBool("Unarmed.AnimationActive", false) then
		return false
	end

	local trace = ply:GetEyeTrace()
	if not trace.Hit then
		return false
	end

	local traceTarget = trace.Entity
	if IsValid(target) then
		if target ~= traceTarget then
			return false
		end
	else
		target = traceTarget
	end

	if not IsValid(target) then
		return false
	end

	-- Prevent recursion.
	if target:GetNWBool("Unarmed.CarryingRagdoll", false) then
		return false
	end

	if not target:IsPlayer() then
		return false
	end

	local distance = ply:GetPos():Distance(target:GetPos())
	if distance > 100 then
		return false
	end

	return true, target
end
--gamemodes/egmrp/gamemode/modules/unarmed/cl_pickup.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--      Unarmed Pickup | Client      --
---------------------------------------

---------------------------------------
--           Player Pickup           --
---------------------------------------

-- Display a message to the player, if they want to be picked up.
net.Receive("Unarmed.PickUpPlayer", function(len)
	local ent = net.ReadEntity()

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("unarmed.pick_up_title"))
	modal:Confirm(egmt("unarmed.pick_up_confirm"), function()
		net.Start("Unarmed.PickUpPlayerConfirm")
			net.WriteEntity(ent)
		net.SendToServer()
	end)
end)



---------------------------------------
--               Hooks               --
---------------------------------------

-- Copyright: https://steamcommunity.com/sharedfiles/filedetails/?id=2818729885&searchtext=prop+interact

Unarmed.RotateKeyPressed = false

-- Check Key Press for the rotate key to keep track of it.
hook.Add("KeyPress", "Unarmed.RotateKeyCheck", function(ply, key)
    if not IsFirstTimePredicted() then return end
    if key ~= Unarmed.RotateKey then return end

    if ply:GetNWBool("PhysicsPickup", false) then
        net.Start("Unarmed.KeyPressed")
            net.WriteBool(true)
        net.SendToServer()

        Unarmed.RotateKeyPressed = true
    else
        Unarmed.RotateKeyPressed = false
    end
end)

-- Check Key Release for the rotate key to keep track of it.
hook.Add("KeyRelease", "Unarmed.RotateKeyCheck", function(ply, key)
    if not IsFirstTimePredicted() then return end
    if key ~= Unarmed.RotateKey then return end

    if ply:GetNWBool("PhysicsPickup", false) then
        net.Start("Unarmed.KeyPressed")
            net.WriteBool(false)
        net.SendToServer()
    end

    Unarmed.RotateKeyPressed = false
end)

-- Freeze the Camera if the the rotate mode is active.
hook.Add("InputMouseApply", "Unarmed.CamFreeze", function(cmd, mouseX, mouseY, ang)
    if Unarmed.RotateKeyPressed and LocalPlayer():GetNWBool("PhysicsPickup", false) then
        ang = LocalPlayer():EyeAngles()

        return true
    end
end)

-- Disable normal ThirdPerson, if the player is being carried.
hook.Add("ThirdPerson.CanThirdPerson", "Unarmed.DisableThirdperson", function(ply)
	local carryPly = ply:GetNWEntity("Unarmed.CarriedPlayer")
	if IsValid(carryPly) then
		return false
	end
end)

hook.Add("CalcView", "Unarmed.ThirdPerson", function(ply, pos, angle)
	local carryPly = ply:GetNWEntity("Unarmed.CarriedPlayer")
	if IsValid(carryPly) then
		local view = {}
		view.drawviewer = true

		-- We start a trace from the players eyePos to the third person camera position (behind the player).
		local traceData = {}
		traceData.start = carryPly:EyePos()
		traceData.endpos = traceData.start + angle:Forward() * -ThirdPerson.Distance
		traceData.filter = {
			ply, carryPly
		}

		local trace = util.TraceLine(traceData)

		-- The position of the camera will be the point where the trace hit an object or completely behind a player.
		pos = trace.HitPos

		-- If we hit something, then we manipulate the position, so that the player can't look through an object.
		if trace.Fraction < 1 then
			pos = pos + trace.HitNormal * 5
		end

		view.origin = pos

		return view
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory/cl_inventory.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Inventory        --
---------------------------------------

-- Determine the changed items and re-equip them.
--
-- @param Player ply
-- @param Table char
-- @param Table oldInventory
-- @param Table newInventory
function Inventory:UpdateEquippedItems(ply, char, oldInventory, newInventory)
	-- Check the old inventory for items that arent there anymore.
	for slotId, slotItemData in pairs(oldInventory) do
		if not Inventory:IsEquipmentSlot(slotId) then continue end

		local newSlotItemData = newInventory[slotId] or {}
		for subId, itemData in pairs(slotItemData) do
			-- Check, if the item was already equipped.
			local newItemData = newSlotItemData[subId] or {}

			if not self:CanStack(itemData, newItemData) then
				local success, itemClass, itemType = self:GetItemClass(itemData)
				if success then
					itemClass:OnUnequip(ply, char, itemType, itemData)
				end
			end
		end
	end

	-- Check the new inventory for items that wasnt there before.
	for slotId, slotItemData in pairs(newInventory) do
		if not Inventory:IsEquipmentSlot(slotId) then continue end

		local oldSlotItemData = oldInventory[slotId] or {}
		for subId, itemData in pairs(slotItemData) do
			-- Check, if the item was already equipped.
			local oldItemData = oldSlotItemData[subId] or {}

			if not self:CanStack(itemData, oldItemData) then
				local success, itemClass, itemType = self:GetItemClass(itemData)
				if success then
					itemClass:OnEquip(ply, char, itemType, itemData)
				end
			end
		end
	end
end

-- Unequips the given inventory on the given player.
--
-- @param Player ply
-- @param Table char
-- @param? Table inventory
function Inventory:UnequipInventory(ply, char, inventory)
	for slotId, slotItemData in pairs(inventory or char:GetInventory()) do
		if not Inventory:IsEquipmentSlot(slotId) then continue end

		for _, itemData in pairs(slotItemData) do
			local success, itemClass, itemType = self:GetItemClass(itemData)
			if success then
				itemClass:OnUnequip(ply, char, itemType, itemData)
			end
		end
	end
end

-- Equip the given inventory on the given player.
--
-- @param Player ply
-- @param Table char
-- @param? Table inventory
function Inventory:EquipInventory(ply, char, inventory)
	for slotId, slotItemData in pairs(inventory or char:GetInventory()) do
		if not Inventory:IsEquipmentSlot(slotId) then continue end

		for _, itemData in pairs(slotItemData) do
			local success, itemClass, itemType = self:GetItemClass(itemData)
			if success then
				itemClass:OnEquip(ply, char, itemType, itemData)
			end
		end
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Syncs the equipped item.
hook.Add("Character.PropertyChanged", "Inventory.SyncOnEquip", function(char, key, value, oldValue)
	if key ~= "inventory" then return end

	local ply = char:GetOwner()
	if not IsValid(ply) then return end

	Inventory:UpdateEquippedItems(ply, char, oldValue, value)
end)

-- Update Equipment on Character Change.
hook.Add("EntityNetworkedVarChanged", "Inventory.OnCharacterChanged", function(ent, name, old, new)
	if name == "CurrentCharacterId" and ent:IsPlayer() then
		-- Unequip the old inventory.
		local oldChar = Character:GetCached(old)
		if oldChar then
			Inventory:UnequipInventory(ent, oldChar)
		end

		-- Equip the new inventory.
		local newChar = Character:GetCached(new)
		if newChar then
			Inventory:EquipInventory(ent, newChar)
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Manager | Item Type        --
---------------------------------------

Manager:RegisterObjectCategory(
    ItemType.Name,
    egmt("itemType.name"),
    function()
        return ItemType:GetCache()
    end,
    function()
        return ItemType:Create({}, {name = egmt("itemType.new")})
    end,
    nil,
    egmt("itemType.duplicate_long"),
    egmt("itemType.delete"),
    egmt("itemType.delete_warning"),
    egmt("itemType.add"),
    egmt("itemType.save")
)
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/backpack/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 44

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/backpack/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.backpack_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 4
--gamemodes/egmrp/gamemode/modules/comlink/cl_comlink.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Comlink         --
---------------------------------------

-- Add faction properties to list. These are editable in faction creation and edit.
Faction:AddPropertyToList("comlinkBehaviour", egmt("comlink.behaviour"), egmt("comlink.behaviour_description"), "dropdown", function(faction)
	local values = {}

	for id, name in SortedPairs(Faction.ComlinkBehaviours) do
		table.insert(values, {
			text = name,
			data = id,
		})
	end

	return values
end, nil, 1, egmt("comlink.category"))

-- Add equipment properties to list. These are editable in equipment creation and edit.
Equipment:AddPropertyToList("comlinkAccess", egmt("comlink.propertyEquipment"), egmt("comlink.propertyEquipment_description"), "list", function(faction)
	local channels = {}

	for _, channel in pairs(ComChannel:GetCache()) do
		table.insert(channels, {
			text = channel:GetName(),
			data = "custom_" .. channel:GetId(),
		})
	end

	return channels
end, nil, 1, egmt("comlink.category"))

-- Update the clientside state of the comlink.
net.Receive("Comlink.Status", function()
	local len = net.ReadInt(32)
	local comlinkData = DecompressTable(net.ReadData(len))

	local ply = LocalPlayer()
	ply.ComlinkEnabled = comlinkData.En or false
	ply.ActiveComlinkChannel = comlinkData.Ac or false
	ply.PassiveComlinkChannels = comlinkData.Pa or {}
end)



---------------------------------------
--          Network Control          --
---------------------------------------

-- Toggles the comlink.
function Comlink:Toggle()
	net.Start("Comlink.Toggle")
	net.SendToServer()

	if LocalPlayer():IsComlinkEnabled() then
		surface.PlaySound("npc/metropolice/vo/off2.wav")
	else
		surface.PlaySound("npc/metropolice/vo/on2.wav")
	end
end

-- Enter a comlink channel.
--
-- @param Boolean joinActive
-- @param String channelId
function Comlink:EnterChannel(joinActive, channelId)
	if not LocalPlayer():IsComlinkEnabled() then return end

	net.Start("Comlink.EnterChannel")
		net.WriteString(channelId)
		net.WriteBool(joinActive)
	net.SendToServer()

	surface.PlaySound("npc/metropolice/vo/on2.wav")
end

-- Leave a comlink channel.
--
-- @param String channelId
function Comlink:LeaveChannel(channelId)
	if not LocalPlayer():IsComlinkEnabled() then return end

	net.Start("Comlink.LeaveChannel")
		net.WriteString(channelId)
	net.SendToServer()

	surface.PlaySound("npc/metropolice/vo/off2.wav")
end

-- Rotates the active comlink channel.
function Comlink:Rotate()
	if not LocalPlayer():IsComlinkEnabled() then return end

	net.Start("Comlink.RotateChannels")
	net.SendToServer()

	surface.PlaySound("npc/metropolice/vo/on2.wav")
end

-- Disables the active comlink channel.
function Comlink:AllPassive()
	if not LocalPlayer():IsComlinkEnabled() then return false end

	net.Start("Comlink.AllPassive")
	net.SendToServer()

	surface.PlaySound("npc/metropolice/vo/on2.wav")
end



---------------------------------------
--         Password Channels         --
---------------------------------------

-- Enter a password to either create a new channel or join an existing one.
--
-- @param String password
function Comlink:EnterPassword(password)
	local channelsFound = {}

	local ply = LocalPlayer()

	-- Check, if a channel with the given password exists.
	for channelId, comlinkData in pairs(Comlink.Channels) do
		if not isstring(comlinkData.Password) then continue end
		if comlinkData.Password ~= password then continue end

		-- Unlock the channel for the player client side.
		table.insert(channelsFound, channelId)
		comlinkData.AccessCharacters[ply:GetCurrentCharacter():GetId()] = true
	end

	net.Start("Comlink.Password")
		net.WriteString(password)
	net.SendToServer()

	return
end

-- Ask, to create a new channel.
net.Receive("Comlink.CreateChannel", function()
	local password = net.ReadString()

	local ply = LocalPlayer()

	-- If no channel was found, ask the user to create a new one.
	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("comlink.confirmCreateTitle"))
	modal:Confirm(egmt("comlink.confirmCreate"), function()
		local currentCharacter = ply:GetCurrentCharacter()
		if not currentCharacter then return end

		local comlinkData = Comlink:RegisterChannel("dynamic", currentCharacter:GetId(), egmt("comlink.create_channel", currentCharacter:GetFullName()))
		comlinkData.AccessCharacters[currentCharacter:GetId()] = true
		comlinkData.Password = password

		-- Network the creation of the new channel.
		net.Start("Comlink.CreateChannel")
			net.WriteString(password)
		net.SendToServer()

		-- Update the comlink menu.
		if IsValid(Comlink.Frame) then
			Comlink:OpenMenu()
		end
	end)
end)

-- Add unlocked dynamic channels to the comlink menu.
net.Receive("Comlink.Password", function()
	local len = net.ReadInt(32)
	local joinedDynamic = DecompressTable(net.ReadData(len))

	for channelId, comlinkData in pairs(joinedDynamic) do
		Comlink.Channels[channelId] = comlinkData
	end

	-- Update the comlink menu.
	if IsValid(Comlink.Frame) then
		Comlink:OpenMenu()
	end
end)

-- Remove a dynamic channel.
function Comlink:RemoveChannel(channelId)
	if not LocalPlayer():IsComlinkEnabled() then return end

	net.Start("Comlink.RemoveChannel")
		net.WriteString(channelId)
	net.SendToServer()

	surface.PlaySound("npc/metropolice/vo/off2.wav")
end

-- Receive the removal of a dynamic channel.
net.Receive("Comlink.RemoveChannel", function()
	local channelId = net.ReadString()

	Comlink.Channels[channelId] = nil

	-- Update the comlink menu.
	if IsValid(Comlink.Frame) then
		Comlink:OpenMenu()
	end
end)

-- Paint the hud that displays the current comlink status.
hook.Add("HUDPaint", "Comlink.PaintHUD", function()
	if hook.Run("HUDShouldDraw", "EGMRPComlink") == false then return end

	local text = egmt("comlink.inactive", KeyBind:GetName(egmt("comlink.category")))

	if LocalPlayer():IsComlinkEnabled() then
		local activeChannel = LocalPlayer():GetActiveComlinkChannel()
		local passiveChannels = LocalPlayer():GetPassiveComlinkChannels()

		if not istable(passiveChannels) or table.Count(passiveChannels) == 0 then
			text = egmt("comlink.no_channel", KeyBind:GetName(egmt("comlink.category")))
		else
			text = ""

			for channelId, _ in SortedPairs(passiveChannels) do
				if channelId == activeChannel then
					text = text .. "\n<color=" .. table.concat(UI.SuccessColor:ToTable(), ",") .. ">".. Comlink.Channels[activeChannel].Name .. "</color>"
				else
					text = text .. "\n" .. Comlink.Channels[channelId].Name
				end
			end
		end
	end

	local parsed = markup.Parse("<font=EGMText8><color=" .. table.concat(UI.ForegroundColor:ToTable(), ",") .. ">" .. text .. "</color></font>", ScrW() * 0.14)

	draw.RoundedBox(5, ScrW() * 0.84, ScrH() * 0.01, ScrW() * 0.15, parsed:GetHeight() + ScreenScale(8), UI.BackgroundColor)

	parsed:Draw(ScrW() * 0.85, ScrH() * 0.01 + ScreenScale(4), TEXT_ALIGN_LEFT)
end)
--gamemodes/egmrp/gamemode/modules/comlink/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Comlink keybinds    --
---------------------------------------

-- Register a keybind for changing the talking radius.
KeyBind:Register(egmt("comlink.category"), egmt("shared.normal"), function()
	if input.IsKeyDown(KEY_LSHIFT) then
		Comlink:OpenMenu()
	elseif input.IsKeyDown(KEY_LALT) then
		Comlink:Rotate()
	elseif input.IsKeyDown(KEY_CAPSLOCK) then
		Comlink:AllPassive()
	else
		Comlink:Toggle()
	end
end, KEY_H)
--gamemodes/egmrp/gamemode/modules/bonemerge/cl_bonemerge.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | BoneMerge        --
---------------------------------------

-- List of all attached models.
BoneMerge.Models = BoneMerge.Models or {}

-- Detach a model from an entity.
--
-- @param Entity ent
-- @param String id
function BoneMerge:Detach(ent, id)
	-- print("\nBoneMerge:Detach", ent, ent:GetModel(), id)

	-- Get the table for the entity.
	local entTable = self.Models[ent] or {}

	-- Check, if the slot is empty.
	local clientEnt = entTable[id]
	if not IsValid(clientEnt) then
		return
	end

	-- Remove the client entity.
	clientEnt:Remove()

	-- Remove the client entity from the table.
	entTable[id] = nil

	-- Update the table.
	self.Models[ent] = entTable
end

-- Detach all models from an entity.
--
-- @param Entity ent
function BoneMerge:DetachAll(ent)
	-- print("\nBoneMerge:DetachAll", ent, ent:GetModel())

	-- Get the table for the entity.
	local entTable = self.Models[ent] or {}

	-- Loop through all client entities.
	for _, clientEnt in pairs(entTable) do
		-- Remove the client entity.
		clientEnt:Remove()
	end

	-- Clear the table.
	self.Models[ent] = nil
end

-- Attach a model to an entity using bonemerge.
--
-- @param Entity ent
-- @param String id
-- @param String model
-- @return Boolean success
-- @return Entity/String clientEnt/error
function BoneMerge:Attach(ent, id, model)
	-- print("\nBoneMerge:Attach", ent, ent:GetModel(), id, model)

	if not IsValid(ent) then
		return false, "Invalid entity"
	end

	-- Get the table for the entity.
	local entTable = self.Models[ent] or {}

	-- Check, if the slot is already used.
	local clientEnt = entTable[id]
	if IsValid(clientEnt) then
		if clientEnt:GetModel() == model then
			return true, clientEnt
		end

		-- Remove the old model.
		self:Detach(ent, id)
	end

	-- Check the model.
	if not isstring(model) then
		return false, "Invalid model string"
	end

	-- Create the new client entity.
	clientEnt = ClientsideModel(model, ent:GetRenderGroup())
	if not IsValid(clientEnt) then
		return false, "Invalid model"
	end

	-- Set the parent and bonemerge.
	clientEnt:SetParent(ent)
	clientEnt:AddEffects(EF_BONEMERGE)
	clientEnt:AddEffects(EF_BONEMERGE_FASTCULL)

	-- Add the client entity to the table.
	entTable[id] = clientEnt

	-- Update the table.
	self.Models[ent] = entTable

	return true, clientEnt
end



---------------------------------------
--            Entity Hooks           --
---------------------------------------

-- Remove all attached models from an entity on removal of the entity.
hook.Add("EntityRemoved", "BoneMerge.RemoveOnDelete", function(ent)
	BoneMerge:DetachAll(ent)
end)

-- Update the properties of all attached models, to match the base entity.
-- Might need some more properties later.
hook.Add("Think", "BoneMerge.UpdateProperties", function()
	for ent, entTabe in pairs(BoneMerge.Models) do
		local renderMode = ent:GetRenderMode()
		local materialOverride = ent:GetMaterial()
		local color = ent:GetColor()
		local noDraw = ent:GetNoDraw()

		for _, clientEnt in pairs(entTabe) do
			clientEnt:SetRenderMode(renderMode)

			if isstring(materialOverride) and materialOverride ~= "" then
				clientEnt:SetMaterial(materialOverride)
			else
				clientEnt:SetMaterial("")
			end

			clientEnt:SetColor(color)

			if noDraw or color.a == 0 then
				clientEnt:SetNoDraw(true)
			else
				clientEnt:SetNoDraw(false)
			end
		end
	end
end)



---------------------------------------
--       Character Integration       --
---------------------------------------

-- List of all attached models for characters.
BoneMerge.Character = BoneMerge.Character or {}

-- Detach a model from a character.
--
-- @param Character character
-- @param String id
function BoneMerge:DetachCharacter(character, id)
	if not character then
		return
	end

	-- Get the table for the character.
	local charTable = self.Character[character] or {}

	-- Get the table for the id.
	local idTable = charTable[id] or {}

	-- Check, if the slot is empty.
	local clientEnt = idTable.ClientEnt
	if not IsValid(clientEnt) then
		return
	end

	-- Remove the client entity.
	clientEnt:Remove()

	-- Clear the table.
	charTable[id] = nil

	-- Update the table.
	self.Character[character] = charTable
end

-- Detach all models from a character.
--
-- @param Character character
function BoneMerge:DetachAllCharacter(character)
	if not character then
		return
	end

	-- Get the owner of the character.
	local ply = character:GetOwner()
	if not IsValid(ply) then
		return
	end

	-- Remove all client entities.
	BoneMerge:DetachAll(ply)

	-- Clear the table.
	self.Character[character] = nil
end

-- Attach a model to a character using bonemerge.
--
-- @param Character character
-- @param String id
-- @param function getModel
-- @param function applyModel
-- @return Boolean success
-- @return String error
function BoneMerge:AttachCharacter(character, id, getModel, applyModel)
	if not character then
		return false, "Invalid character"
	end

	-- Get the table for the character.
	local charTable = self.Character[character] or {}

	-- Get the table for the id.
	local idTable = charTable[id] or {}

	-- Check, if the slot is already used and remove the old model.
	local oldClientEnt = idTable.ClientEnt
	if IsValid(oldClientEnt) then
		local success, err = self:DetachCharacter(character, id)
		if not success then
			return false, err
		end
	end

	-- Get the owner of the character.
	local ply = character:GetOwner()
	if not IsValid(ply) then
		return false, "Invalid owner"
	end

	-- Check the model function, if nil is returned abort silently.
	local model = getModel(character)
	if model == nil then
		-- Still needs to detach the model, if it was attached before.
		self:Detach(ply, id)

		return true
	end

	-- Add the new model.
	local success, clientEnt = self:Attach(ply, id, model)
	if not success then
		return false, clientEnt
	end

	-- Apply the model.
	if isfunction(applyModel) then
		applyModel(character, clientEnt)
	end

	-- Update the table.
	idTable.ClientEnt = clientEnt
	idTable.GetModel = getModel
	idTable.ApplyModel = applyModel

	charTable[id] = idTable

	return true
end

-- Re-Attach all models for a character.
--
-- @param Character character
-- @return Boolean success
-- @return? String error
function BoneMerge:ReAttachCharacter(character)
	if not character then
		return false, "Invalid character"
	end

	-- Get the table for the character.
	local charTable = self.Character[character] or {}

	-- Get the owner of the character.
	local ply = character:GetOwner()
	if not IsValid(ply) then
		return false, "Invalid owner"
	end

	-- Loop through all client entities.
	for id, idTable in pairs(charTable) do
		if IsValid(idTable.ClientEnt) then
			-- Remove the old model.
			self:Detach(ply, id)
		end

		-- Skip if the model is nil.
		local model = idTable.GetModel()
		if model == nil then
			continue
		end

		-- Add the new model.
		local success, clientEnt = self:Attach(ply, id, model)
		if not success then
			return false, clientEnt
		end

		-- Apply the model.
		local applyModel = idTable.ApplyModel
		if isfunction(applyModel) then
			applyModel(character, clientEnt)
		end
	end

	return true
end

-- List of all registered character models.
BoneMerge.CharacterModels = {}

-- Register a character model.
--
-- @param String id
-- @param function getModel
-- @param function applyModel
function BoneMerge:RegisterCharacterModel(id, getModel, applyModel)
	-- Check the model function.
	if not isfunction(getModel) then
		return
	end

	-- Add the model.
	self.CharacterModels[id] = {
		GetModel = getModel,
		ApplyModel = applyModel,
	}
end

-- Apply all registered character models to a character.
--
-- @param Character character
function BoneMerge:ApplyCharacterModels(character)
	if not character then
		return
	end

	-- Get the owner of the character.
	local ply = character:GetOwner()
	if not IsValid(ply) then
		return
	end

	-- Loop through all registered models.
	for id, modelData in pairs(self.CharacterModels) do

		-- Add the new model.
		local success, err = self:AttachCharacter(character, id, modelData.GetModel, modelData.ApplyModel)
		if not success then
			LogError("BoneMerge.ApplyCharacterModels: " .. err)
		end
	end
end

-- Call an update for a registered character model.
--
-- @param Character character
-- @param String id
function BoneMerge:UpdateCharacterModel(character, id)
	if not character then
		return
	end

	local modelData = self.CharacterModels[id]
	if not istable(modelData) then
		return
	end

	-- Re-Attach the model.
	local success, err = self:AttachCharacter(character, id, modelData.GetModel, modelData.ApplyModel)
	if not success then
		LogError("BoneMerge.UpdateCharacterModel: " .. err)
	end
end



---------------------------------------
--          Character Hooks          --
---------------------------------------

-- Remove and reattach models if the player leave or enter the PVS.
hook.Add("NotifyShouldTransmit", "BoneMerge.OnPVS", function(ent, shouldtransmit)
	if not ent:IsPlayer() then
		return
	end

	local character = ent:GetCurrentCharacter()
	if not character then
		return
	end

	-- Are we entering the PVS?
	if shouldtransmit then
		-- Attach all ClientEnts, if a character enter the PVS.
		BoneMerge:ApplyCharacterModels(character)
	else
		-- Detach all ClientEnts, if a character leave the PVS.
		BoneMerge:DetachAllCharacter(character)
	end
end)

-- Detach all models from a character on removal of the entity. (Disconnect)
hook.Add("EntityRemoved", "BoneMerge.OnEntityRemoved", function(ent)
	if not ent:IsPlayer() then
		return
	end

	local character = ent:GetCurrentCharacter()
	if not character then
		return
	end

	-- Detach all ClientEnts, if a character was removed.
	BoneMerge:DetachAllCharacter(character)
end)

-- Remove all attached models from a character on current character change.
hook.Add("EntityNetworkedVarChanged", "BoneMerge.OnCharacterChanged", function(ent, name, old, new)
	if name ~= "CurrentCharacterId" then return end
	if not ent:IsPlayer() then return end

	-- Detach all ClientEnts, if a character was deleted.
	if new == -1 then
		BoneMerge:DetachAll(ent)

		return
	end

	-- Detach all ClientEnts, if a character was changed.
	local oldCharacter = Character:GetCached(old)
	if oldCharacter then
		BoneMerge:DetachAllCharacter(oldCharacter)
	end

	-- Attach all ClientEnts, if a character was changed.
	local newCharacter = Character:GetCached(new)
	if newCharacter then
		BoneMerge:ApplyCharacterModels(newCharacter)
	end

	ent.LastBoneMergeCharSwitch = CurTime()
end)

-- Attach all models for a character on Spawn.
gameevent.Listen("player_spawn")
hook.Add("player_spawn", "Species.OnSpawn", function(data)
	local ply = Player(data.userid)
	if not IsValid(ply) then return end

	-- Skip, if we have just updated due to char switch.
	-- Current Character might not be updated yet, so we skip here, to be safe.
	local diff = (ply.LastBoneMergeCharSwitch or 0) - CurTime()
	if diff < 1 then return end

	local character = ply:GetCurrentCharacter()
	if not character then return end

	BoneMerge:ApplyCharacterModels(character)
end)

-- Detach all models for a character on Death.
gameevent.Listen("entity_killed")
hook.Add("entity_killed", "Species.OnDeath", function(data)
	local ply = Entity(data.entindex_killed)
	if not IsValid(ply) then return end

	if not ply:IsPlayer() then return end

	local character = ply:GetCurrentCharacter()
	if not character then return end

	BoneMerge:DetachAllCharacter(character)
end)

-- Attach all models for a character on Load.
hook.Add("Loading.Finished", "BoneMerge.OnLoad", function()
	for _, ply in pairs(player.GetAll()) do
		local character = ply:GetCurrentCharacter()
		if character then
			BoneMerge:ApplyCharacterModels(character)
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/sh_inventory_bonemerge.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | Inventory BoneMerge   --
---------------------------------------

-- Add faction property: bmModels
Faction:AddProperty("bmModels", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get the bone merged models of a faction.
--
-- @return Table bmModels
function Faction.Meta:GetBoneMergeModels()
	local bmModels = table.Copy(self:GetProperty("bmModels", {}))

	local parent = self:GetParent()
	if parent then
		MergeTableByValue(bmModels, parent:GetBoneMergeModels())
	end

	return bmModels
end

-- Add rank property: bmModels
Rank:AddProperty("bmModels", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the bone merged models of a rank.
--
-- @return Table bmModels
function Rank.Meta:GetBoneMergeModels()
	return self:GetProperty("bmModels", {})
end

-- Add equipment property: bmModels
Equipment:AddProperty("bmModels", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Get the bone merged models of a equipment.
--
-- @return Table bmModels
function Equipment.Meta:GetBoneMergeModels()
	return self:GetProperty("bmModels", {})
end

-- Get the bone merged models of a character.
function Character.Meta:GetBoneMergeModels()
	local validBMModels = {}

	-- Load bone merged models from faction.
	local faction = self:GetFaction()

	if faction then
		validBMModels = faction:GetBoneMergeModels()
	end

	-- Load bone merged models from rank apply the blacklist filter, to remove models, that are blacklisted by the rank.
	local rank = self:GetRank()
	if rank then
		local rankBMModels = rank:GetBoneMergeModels()
		MergeTableByValue(validBMModels, rankBMModels)
		validBMModels = FilterBlacklist(validBMModels)
	end

	-- Load bone merged models from the equipment or remove them from the valid bone merged models, if they are blacklisted.
	local equipBlacklist = {}
	local relevantEquipment = self:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		local equipBMModels = equip:GetBoneMergeModels()
		if equip:GetProperty("blacklist", false) then
			MergeTableByValue(equipBlacklist, equipBMModels)
		else
			MergeTableByValue(validBMModels, equipBMModels)
		end
	end
	for _, equipBMModels in pairs(equipBlacklist) do
		table.RemoveByValue(validBMModels, equipBMModels)
	end

	hook.Run("Character.GetValidBMModels", self, validMaterialSets)
	hook.Run("Character.RemoveValidBMModels", self, validMaterialSets)

	return validBMModels
end

-- Add bone merged models to the effect list.
hook.Add("Equipment.GetEffectList", "InventoryBoneMerge.EquipmentEffect", function(equip, effectList)
	local bmModels = equip:GetBoneMergeModels()
	if not istable(bmModels) then return end

	local blacklist = equip:GetProperty("blacklist", false)

	if table.Count(bmModels) > 0 then
		if blacklist then
			table.insert(effectList, "BMDL-")
		else
			table.insert(effectList, "BMDL+")
		end
	end
end)

-- Add item type property: requiredArmor
ItemType:AddProperty("requiredArmor", "table", {}, function(item, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(item, ply)
	return true
end)

-- Check, if the player has one of the required armors equipped.
--
-- @param Table inventory
-- @return Bool hasRequiredArmor
function ItemType.Meta:HasRequiredArmor(inventory)
	local requiredArmor = self:GetProperty("requiredArmor", {})

	-- Empty table means all armors are fine.
	if table.IsEmpty(requiredArmor) then
		return true
	end

	for slotId, slotItemData in pairs(inventory) do
		if not Inventory:IsEquipmentSlot(slotId) then continue end

		for _, itemData in pairs(slotItemData) do
			local typeId = itemData.TypeId

			if table.HasValue(requiredArmor, typeId) then
				return true
			end
		end
	end

	return false
end



---------------------------------------
--           Base Functions          --
---------------------------------------

-- List of all bone merged base models.
InventoryBoneMerge.BaseModels = {}

-- List of all types for quick access.
InventoryBoneMerge.TypeList = {}

-- Register a bone merged base model.
--
-- @param String type
-- @param String model
-- @param String name
-- @param Table materialMapping
function InventoryBoneMerge:RegisterBaseModel(type, model, name, materialMapping)
	BaseModel:RegisterBaseModel(model, materialMapping)

	self.BaseModels[model] = {
		Type = type,
		Name = name
	}

	self.TypeList[type] = true
end

-- Get a bone merged base model item by type currently equipped by a character.
--
-- @param String type
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function InventoryBoneMerge:GetCurrentItem(type, char, inventory)
	if char then
		-- Current characters have a cached item.
		if char:IsCurrentCharacter() then
			local itemCache = char.BoneMergeItemCache or {}
			local cachedItem = itemCache[type]
			if cachedItem then
				return cachedItem
			end
		end

		inventory = inventory or char:GetInventory()
	end

	-- If the character is not the current character, we need to check the inventory manually.
	if istable(inventory) then
		for slotId, slotItemData in pairs(inventory) do
			if not Inventory:IsEquipmentSlot(slotId) then continue end

			for _, itemData in pairs(slotItemData) do
				local success, itemClass, _ = Inventory:GetItemClass(itemData)
				if not success then continue end
				if not itemClass.IsBoneMerged then continue end

				local model = itemData.Model
				if not isstring(model) then continue end

				local baseModelData = self.BaseModels[model]
				if not istable(baseModelData) then continue end

				if baseModelData.Type == type then
					return itemData
				end
			end
		end
	end
end
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/cl_corpse.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Inventory BoneMerge   --
---------------------------------------

-- Apply the bone merge items to the corpse.
hook.Add("Inventory.BoneMergeItem.OnUnequip", "InventoryBoneMerge.ApplyToCorpse", function(ply, char, itemType, itemData)
	if not IsValid(ply) or not char then return end

	local corpse = ply:GetObserverTarget()
	if not IsValid(corpse) then return end
	if not corpse:IsRagdoll() then return end
	if not corpse:GetNWBool("IsPlayerCorpse", false) then return end

	-- Update the corpse.
	BoneMerge:UpdateCorpse(corpse, true)
end)

-- Override with the networked model.
hook.Add("BoneMerge.GetRespawnedCorpseModel", "InventoryBoneMerge.GetCorpseModel", function(ent, id)
	if not InventoryBoneMerge.TypeList[id] then return end

	local modelSkin = ent:GetNWString("IBM.ModelSkin." .. id, "")
	if not isstring(modelSkin) or modelSkin == "" or modelSkin == "|" then return end

	local modelSkinSplit = string.Explode("|", modelSkin)
	if #modelSkinSplit ~= 2 then return end

	local model = modelSkinSplit[1]
	if not isstring(model) or model == "" then return end

	return model
end)

-- Apply the base model bodygroups and material set.
hook.Add("BoneMerge.ApplyRespawnedCorpseModel", "InventoryBoneMerge.ApplyCorpseModel", function(ent, id, clientEnt)
	if not InventoryBoneMerge.TypeList[id] then return end

	local modelSkin = ent:GetNWString("IBM.ModelSkin." .. id, "")
	if not isstring(modelSkin) or modelSkin == "" or modelSkin == "|" then return end

	local modelSkinSplit = string.Explode("|", modelSkin)
	if #modelSkinSplit ~= 2 then return end

	local skinId = modelSkinSplit[2]
	if not isstring(skinId) or skinId == "" then return end

	local skinIdNum = tonumber(skinId)
	if isnumber(skinIdNum) then
		clientEnt:SetSkin(skinIdNum)
	else
		local success, err = BaseModel:ApplyBaseModel(clientEnt, clientEnt:GetModel(), skinId)
		if not success then
			LogInfo("InventoryBoneMerge.ApplyCorpseModel: " .. err)
		end
	end
end)

net.Receive("InventoryBoneMerge.UpdateCorpse", function()
	local ent = net.ReadEntity()
	if not IsValid(ent) then return end

	local id = net.ReadString()
	if not isstring(id) or id == "" then return end

	-- Clientside override, since the data is not networked yet at this point.
	ent:SetNWString("IBM.ModelSkin." .. id, "")

	-- If the entitiy is valid clientside we are in the PVS of the local player.
	BoneMerge:UpdateCorpse(ent, true)
end)
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/item_classes/bonemerge/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | BoneMerge Item      --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "base"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {}

-- Sorting order of the item.
ITEM_CLASS.Sort = 100

-- Helper boolean to check if the item is a bone merged item.
ITEM_CLASS.IsBoneMerged = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Validate the item data.
--
-- @param itemType
-- @param itemData
-- @return Boolean success
-- @return String error
function ITEM_CLASS:Validate(itemType, itemData)
	local model = itemData.Model
	local skinId = itemData.SkinId or 0

	-- Check if the model is a string.
	if not isstring(model) then
		return false, "The model is not a string."
	end

	-- Check if the model is valid.
	if not util.IsValidModel(model) then
		return false, "The model is not valid."
	end

	-- Check, if the model and skinid are whitelisted for the item type.
	for _, modelData in pairs(itemType:GetModels()) do
		if istable(modelData) then
			if modelData.Model == model then
				if isnumber(skinId) then
					if modelData.Skins[skinId] then
						return true
					end
				elseif isstring(skinId) then
					if table.HasValue(itemType:GetMaterialSets(), model .. "_" .. skinId) then
						return true
					end
				end
			end
		else
			if modelData == model then
				if isnumber(skinId) then
					return true
				elseif isstring(skinId) then
					if table.HasValue(itemType:GetMaterialSets(), model .. "_" .. skinId) then
						return true
					end
				end
			end
		end
	end

	return false, "The model and skinid are not whitelisted for the item type."
end

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	local canAdd, error = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not canAdd then
		return false, error
	end

	-- Check, if the item is valid.
	if not self:Validate(itemType, itemData) then
		return false, "The item is not valid."
	end

	-- Skip checks, if the slot type is not an equipment slot.
	if not Inventory:IsEquipmentSlotType(slotType) then
		return true
	end

	-- Check, if a required armor is equipped.
	if not itemType:HasRequiredArmor(inventory) then
		return false, "You need to equip a matching armor first."
	end

	return true
end

-- Helper function to get the name of the item.
--
-- @param String model
-- @param? Number skinId
-- @return String name
function ITEM_CLASS:GetItemName(model, skinId)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then
		return model
	end

	local modelName = baseModelData.Name
	if isnumber(skinId) and skinId > 0 then
		modelName = modelName .. " (" .. skinId .. ")"
	elseif isstring(skinId) then
		local materialSetData = baseModelData.MaterialSets[skinId]
		if istable(materialSetData) then
			modelName = materialSetData.Name
		end
	end

	return modelName
end

-- Get all variants of the item as a table.
--
-- @param ItemType itemType
-- @return Table itemVariants
function ITEM_CLASS:GetVariants(itemType)
	local itemVariants = {}

	-- Add normal models and skin ids.
	for _, model in pairs(itemType:GetModels()) do
		if istable(model) then
			for skinId, enabled in pairs(model.Skins) do
				if not enabled then continue end

				itemVariants[model.Model .. "_" .. skinId] = self:GetItemName(model.Model, model.SkinId)
			end
		else
			itemVariants[model] = self:GetItemName(model)
		end
	end

	-- Add material sets.
	for _, materialSetString in pairs(itemType:GetMaterialSets()) do
		local split = string.Split(materialSetString, ".mdl_")

		local model = materialSetString
		local materialSet
		if #split > 1 then
			model = split[1] .. ".mdl"
			materialSet = split[2]
		end

		itemVariants[materialSetString] = self:GetItemName(model, materialSet)
	end

	return itemVariants
end

-- Get item data from variant string.
--
-- @param ItemType itemType
-- @param String variant
-- @return? Table itemData
function ITEM_CLASS:GetVariantData(itemType, variant)
	if isstring(variant) then
		if variant ~= "" then
			local split = string.Split(variant, ".mdl_")
			if #split == 2 then
				local model = split[1] .. ".mdl"
				local skinId = split[2]

				return {
					TypeId = itemType:GetId(),

					Model = model,
					SkinId = skinId,
				}
			end
		end

		-- Fallback if there is only one model.
		local modelList = itemType:GetModels()
		if #modelList == 1 then
			local model = modelList[1]
			if istable(model) then
				return {
					TypeId = itemType:GetId(),

					Model = model.Model,
					SkinId = model.SkinId,
				}
			end

			return {
				TypeId = itemType:GetId(),

				Model = model,
			}
		end

		-- Random model if no variant is given.
		return {
			TypeId = itemType:GetId(),

			Model = table.Random(modelList),
		}
	end

	return false
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Gets the name for the item.
--
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:GetName(itemType, itemData)
	local model = itemData.Model
	local baseModelDataBM = InventoryBoneMerge.BaseModels[model]
	if not istable(baseModelDataBM) then return end

	local baseModelData = BaseModel:GetBaseModel(model)
	if istable(baseModelData) then
		local skinId = itemData.SkinId
		if isstring(skinId) then
			local materialSetData = baseModelData.MaterialSets[skinId]
			if istable(materialSetData) then
				return materialSetData.Name
			end
		end
	end

	return baseModelDataBM.Name
end
--gamemodes/starwarsrp/gamemode/modules/cwutils/cl_utils.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            CW:RP Utils            --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | CW:RP Utils       --
---------------------------------------

hook.Add("EGMRP.Loaded", "Chat.Fix", function()
	chat.OldClose()
	chat.Close()
	SCB_LOADED = false
	include("autorun/scb.lua")
end)

local holdTypes = {
	["normal"] = true,
	["slam"] = true,
	["grenade"] = true
}

local blockedSequences = {
	["pose_ducking_02"] = true,
	["run_all_01"] = true,
	["idle_all_01"] = true,
	["walk_all"] = true,
	["cwalk_all"] = true
}

hook.Add("CalcMainActivity", "EGM.KneelAnimation", function(ply, vel)
	if ply:IsOnGround() and ply:Crouching() and !ply:GetNWBool("SitGroundSitting", false) and vel:Length2DSqr() < 1 and ply:GetActiveWeapon()
	and IsValid(ply:GetActiveWeapon()) and holdTypes[ply:GetActiveWeapon():GetHoldType()] then
		if !blockedSequences[ply:GetSequence()] then
			local crouch_anim = ply:LookupSequence("pose_ducking_01")

			return ACT_MP_JUMP, crouch_anim
		else
			return
		end
	end
end)


--gamemodes/egmrp/gamemode/modules/species/cl_species.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Species System      --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Species.PropertyList = {}

-- Add species properties to list. These are editable in species creation and edit.
Species:AddPropertyToList("name", egmt("species.name"), egmt("species.name_description"), "string", nil, nil, 1, nil)

Species:AddPropertyToList("factionLimit", egmt("species.factionLimit"), egmt("species.factionLimit_description"), "slider", function()
	return {min = 0, max = 32}
end, nil, 2, nil)

Species:AddPropertyToList("characterLimit", egmt("species.characterLimit"), egmt("species.characterLimit_description"), "slider", function()
	return {min = 0, max = 8}
end, nil, 3, nil)

Species:AddPropertyToList("bloodColor", egmt("species.bloodColor"), egmt("species.bloodColor_description"), "dropdown", function()
	local bloodColors = {}

	table.insert(bloodColors, {text = egmt("species.blood_none"), data = DONT_BLEED})
	table.insert(bloodColors, {text = egmt("species.blood_red"), data = BLOOD_COLOR_RED})
	table.insert(bloodColors, {text = egmt("species.blood_yellow"), data = BLOOD_COLOR_YELLOW})
	table.insert(bloodColors, {text = egmt("species.blood_green"), data = BLOOD_COLOR_GREEN})
	table.insert(bloodColors, {text = egmt("species.blood_sparks"), data = BLOOD_COLOR_MECH})
	table.insert(bloodColors, {text = egmt("species.blood_antlion"), data = BLOOD_COLOR_ANTLION})
	table.insert(bloodColors, {text = egmt("species.blood_zombie"), data = BLOOD_COLOR_ZOMBIE})
	table.insert(bloodColors, {text = egmt("species.blood_antlion_worker"), data = BLOOD_COLOR_ANTLION_WORKER})

	return bloodColors
end, nil, 4, nil)

Species:AddPropertyToList("headModels", egmt("species.headModels"), egmt("species.headModels_description"), "models", function()
	return {validModels = Species.HeadModels}
end, nil, 1, egmt("species.models"))

Species:AddPropertyToList("bodyModelGroup", egmt("species.bodyModelGroup"), egmt("species.bodyModelGroup_description"), "dropdown", function()
	local bodyModelGroups = {}

	for name, _ in pairs(Species.BodyModels) do
		table.insert(bodyModelGroups, {text = name, data = name})
	end

	table.insert(bodyModelGroups, {text = "None", data = ""})

	return bodyModelGroups
end, nil, 2, egmt("species.models"))

Species:AddPropertyToList("bodyModels", egmt("species.bodyModels"), egmt("species.bodyModels_description"), "models", function(species)
	local validModels = table.Copy(player_manager.AllValidModels())

	local additionalBodyModels = species:GetBodyModelGroupModels()

	return {
		validModels = validModels,
		inheritedModels = additionalBodyModels,
		noSkins = true
	}
end, nil, 3, egmt("species.models"))

Species:AddPropertyToList("healthBonus", egmt("species.healthBonus"), egmt("species.healthBonus_description"), "slider", function()
	return {min = -1000, max = 1000}
end, nil, 1, egmt("rank.stats"))

Species:AddPropertyToList("armorBonus", egmt("species.armorBonus"), egmt("species.armorBonus_description"), "slider", function()
	return {min = -255, max = 255}
end, nil, 2, egmt("rank.stats"))

Species:AddPropertyToList("speedBonus", egmt("species.speedBonus"), egmt("species.speedBonus_description"), "slider", function()
	return {min = -500, max = 500}
end, nil, 3, egmt("rank.stats"))

Species:AddPropertyToList("jumpBonus", egmt("species.jumpBonus"), egmt("species.jumpBonus_description"), "slider", function()
	return {min = -1000, max = 1000}
end, nil, 4, egmt("rank.stats"))

Species:AddPropertyToList("scaleModifier", egmt("species.scaleModifier"), egmt("species.scaleModifier_description"), "slider", function()
	return {min = 0.8, max = 1.2, dec = 2} -- Tight limits, because ragdolls cannot be scaled.
end, nil, 5, egmt("rank.stats"))

Species:AddPropertyToList("damageImmunities", egmt("species.damageImmunities"), egmt("species.damageImmunities_description"), "table", function()
	return { validValues = Species.DamageTypes }
end, nil, 6, egmt("rank.stats"))

-- Register species package type.
Loading:RegisterPackageType("species", egmt("species.package"), function(packageData)
	for k, sData in pairs(packageData) do
		Species:Load(sData.data, sData.properties):Cache()
	end
end)



---------------------------------------
--       Character Integration       --
---------------------------------------

Rank:AddPropertyToList("speciesWhitelist", egmt("species.speciesWhitelist"), egmt("species.speciesWhitelist_description"), "table", function(rank, faction, character)
	local values = {
		validValues = {}
	}

	for _, species in pairs(Species:GetCache()) do
		values.validValues[species:GetId()] = species:GetName()
	end

	return values
end, function(rank, faction, character)
	return true
end, 1, egmt("species.category"))

Equipment:AddPropertyToList("speciesWhitelist", egmt("species.speciesWhitelist"), egmt("species.speciesWhitelistEquipment_description"), "table", function(rank, faction, character)
	local values = {
		validValues = {}
	}

	for _, species in pairs(Species:GetCache()) do
		values.validValues[species:GetId()] = species:GetName()
	end

	return values
end, function(rank, faction, character)
	return true
end, 4, egmt("equipment.conditions"))

Character:AddPropertyToList("species", egmt("species.character"), egmt("species.character_description"), "dropdown", function(rank, faction, character)
	local options = {}

	if not rank then return options end

	-- Add whitelisted species to the dropdown.
	for _, species in pairs(Species:GetCache()) do
		table.insert(options, {
			text = species:GetName(),
			data = species:GetId()
		})
	end

	return options
end, function(rank, faction, character)
	return true
end, 1, egmt("species.category"))

Character:AddPropertyToList("headModel", egmt("species.headModel"), egmt("species.headModel_description"), "dropdown", function(rank, faction, character)
	if not character then return {} end

	local species = character:GetSpecies()
	if not species then return {} end

	local options = {}
	for _, model in pairs(species:GetHeadModels()) do
		local name = table.KeyFromValue(Species.HeadModels, model)
		if not isstring(name) then continue end

		table.insert(options, {
			text = name,
			data = model
		})
	end

	return options
end, function(rank, faction, character)
	-- Only show the property if there is at least one option.

	-- Allow, if we are in the character creation menu.
	if not character then return true end

	local species = character:GetSpecies()
	if not species then return false end

	return #species:GetHeadModels() > 0
end, 2, egmt("species.category"))



---------------------------------------
--       BoneMerge Integration       --
---------------------------------------

-- Add the species head model to the bone merge system.
BoneMerge:RegisterCharacterModel("Head", function(char)
	local model, skinId = char:GetModelSkin()
	if not isstring(model) then return end

	local headModel = char:GetHeadModel(model, skinId)
	if not headModel then return end

	return headModel
end, function(char, clientEnt)
	-- Nothing to do here.
end)

-- Update the head model, when the species head model changes.
hook.Add("Character.PropertyChanged", "Species.UdateOnModelChanged", function(char, key, value, oldValue)
	if not char:IsCurrentCharacter() then return end

	local shouldUpdate = false

	-- Default Update Keys.
	if (key == "modelSkin")
	or (key == "headModel")
	or (key == "species") then
		shouldUpdate = true
	end

	-- Allow other addons to override the update.
	local override = hook.Run("Species.ShouldHeadModelUpdate", char, key, value, oldValue)
	if override ~= nil then
		shouldUpdate = override
	end

	-- Update the head model.
	if shouldUpdate then
		BoneMerge:UpdateCharacterModel(char, "Head")
	end
end)
--gamemodes/egmrp/gamemode/modules/species/cl_species_gui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Character Creation | Species   --
---------------------------------------

-- Apply the species to the preview.
--
-- @param Panel previewPanel
-- @param Panel speciesDropdownProperty
-- @param Panel headModelDropdownProperty
function Species:ApplySpeciesToPreview(previewPanel, speciesDropdownProperty, headModelDropdownProperty)
	local speciesId = speciesDropdownProperty.SelectedSpecies
	if not isnumber(speciesId) then
		local choices = speciesDropdownProperty.Choices
		if table.Count(choices or {}) == 1 then
			speciesDropdownProperty:ChooseOptionID(1)
		end
	else
		local species = Species:GetCached(speciesId)
		if not species then return end

		local selectedHeadModel = headModelDropdownProperty.SelectedHeadModel
		if not isstring(selectedHeadModel) then
			headModelDropdownProperty:Clear()

			local headModels = species:GetProperty("headModels", {})
			if table.Count(headModels) == 0 then
				headModelDropdownProperty:SetDisabled(true)
			end

			for _, model in pairs(headModels) do
				local name = table.KeyFromValue(Species.HeadModels, model)
				if isstring(name) then
					headModelDropdownProperty:AddChoice(name, model)
				end
			end

			if table.Count(headModels) == 1 then
				headModelDropdownProperty:ChooseOptionID(1)
			end
		else
			local ent = previewPanel.Entity
			if IsValid(ent) then
				-- Do not use a head model, if the body model is not compatible.
				if not table.HasValue(Species.BodyModelCache, ent:GetModel()) then
					return
				end

				local success, clientEnt = BoneMerge:Attach(ent, "Head", selectedHeadModel)
				if not success then return end

				previewPanel.BoneMergeModels = previewPanel.BoneMergeModels or {}
				previewPanel.BoneMergeModels["Head"] = clientEnt
			end
		end
	end
end

-- Apply the species to the preview.
hook.Add("CharacterCreation.UpdatePreview", "Species.ApplySpecies", function(previewPanel, propertyPanels)
	local speciesPanel = propertyPanels["species"]
	local headModelPanel = propertyPanels["headModel"]
	if IsValid(speciesPanel) and IsValid(headModelPanel) then
		local speciesDropdownProperty = speciesPanel.DropdownProperty
		if not IsValid(speciesDropdownProperty) then return end

		local headModelDropdownProperty = headModelPanel.DropdownProperty
		if not IsValid(headModelDropdownProperty) then return end

		-- Update the preview when the species changes.
		function speciesDropdownProperty:OnSelectCustom(index, value, data)
			self.SelectedSpecies = data
			headModelDropdownProperty.SelectedHeadModel = nil

			previewPanel:Update()
		end

		-- Update the preview when the head model changes.
		function headModelDropdownProperty:OnSelectCustom(index, value, data)
			self.SelectedHeadModel = data

			previewPanel:Update()
		end

		Species:ApplySpeciesToPreview(previewPanel, speciesDropdownProperty, headModelDropdownProperty)
	end
end)

-- Add the species to the character panel.
hook.Add("CharacterSelection.GetCharacterInfo", "Species.OverrideSelection", function( panel, character, characterInfo)
	if not character then return end

	local species = character:GetSpecies()
	if not species then return end

	table.insert(characterInfo, egmt("species.character_info", species:GetName()))
end)
--gamemodes/egmrp/gamemode/modules/species/cl_inv_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Species System      --
---------------------------------------

if not Config.Modules["inventory"] then return end

Species:AddPropertyToList("weightBonus", egmt("species.weightBonus"), egmt("species.weightBonus_description"), "slider", function()
    return {min = -1000, max = 1000}
end, nil, 1, egmt("inventory.title"))
--gamemodes/egmrp/gamemode/modules/inventory_private/sh_inventory_private.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Inventory Private    --
---------------------------------------

-- Add character property: storage
Character:AddProperty("storage", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the private storage of a character.
--
-- @return Table storage
function Character.Meta:GetStorage()
	return self:GetProperty("storage", {})
end

-- Add Faction property: hasPrivSto
Faction:AddProperty("hasPrivSto", "boolean", false, function(faction, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Add Rank property: hasPrivSto
Rank:AddProperty("hasPrivSto", "boolean", false, function(rank, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Gets the private storage slot limit of a character.
--
-- @return Number slotLimit
function Character.Meta:GetPrivateStorageLimit()
	local configLimit = InventoryPrivate.SlotLimit
	if configLimit == false then
		configLimit = math.huge
	end

	local override = hook.Run("InventoryPrivate.GetCharacterStorageLimit", self, configLimit)
	if isnumber(override) then
		return override
	end

	local rank = self:GetRank()
	if rank and rank:GetProperty("hasPrivSto", false) then
		return configLimit
	end

	local faction = self:GetFaction()
	if faction and faction:GetProperty("hasPrivSto", false) then
		return configLimit
	end

	return 0
end
--gamemodes/egmrp/gamemode/modules/inventory_private/item_slots/storage/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Storage Item Slot    --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 15

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_money/item_classes/money/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Money Item        --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "base"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"belt",
	"backpack"
}

-- Sorting order of the item.
ITEM_CLASS.Sort = -1

-- Helper boolean to check if the item is a money item.
ITEM_CLASS.IsMoney = true

-- Allow stacking of the item outside of storage.
ITEM_CLASS.AlwaysStack = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Validate the item data.
--
-- @param itemType
-- @param itemData
-- @return Boolean success
-- @return String error
function ITEM_CLASS:Validate(itemType, itemData)
	return true
end



---------------------------------------
--                Util               --
---------------------------------------

-- Get the model depending on the amount of money.
--
-- @param Number amount
-- @return String model
-- @return Number scale
function ITEM_CLASS:GetMoneyModel(amount)
	local model = "models/hunter/plates/plate.mdl"
	local skinId = 1
	for _, modelTable in ipairs(InventoryMoney.Models) do
		local minAmount = modelTable.MinAmount
		if isnumber(minAmount) and amount < minAmount then
			continue
		end

		local maxAmount = modelTable.MaxAmount
		if isnumber(maxAmount) and amount > maxAmount then
			continue
		end

		model = modelTable.Model
		skinId = modelTable.SkinId
	end

	return model, skinId
end

--gamemodes/egmrp/gamemode/modules/instructor/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Instructor | Config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum group that is able to educate players even when not being instructor.
Instructor.MinEducateGroup = "operator"

-- Minimum group that is required to use the instructor manager or edit instructor properties.
Instructor.MinAccessGroup = "operator"

-- Allow Instructors, to rename start characters.
Instructor.AllowRename = true

-- Whether instructors should be able to use reserved slots.
Instructor.UseReservedSlots = true

-- If there are less than this amount of instructors online, then instructors are reserved.
-- Set this to 0 if all instructors should be reserved, no matter how many are already online.
Instructor.MaxInstructorsForReservedSlots = 5

-- The modifier on XP, that is applied when you have instructed someone.
-- (Only works, if the experience module is enabled)
Instructor.XPBonus = 1.5

-- The time for which the modifier is applied for in hours.
-- (Only works, if the experience module is enabled)
Instructor.XPBonusTime = 24

-- Background image for the insturctor manager.
InstructorManager.Background = "backgrounds/noshpa_pick_up_that_can.jpg"

-- The maximum number of elements a page can have in the instructor manager. The higher the number the higher the loading time.
InstructorManager.PageSize = 50
--gamemodes/egmrp/gamemode/modules/instructor/sh_instructor.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Instructor | Shared        --
---------------------------------------

local Player = FindMetaTable("Player")

-- Add player data property: instructor
PlayerData:AddProperty("instructor", "boolean", false, function(playerData, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return true
end)

-- Alias function to check whether a player is an instructor.
--
-- @return Boolean isInstructor
function Player:IsInstructor()
	local playerData = self:GetData()

	if playerData then
		return playerData:GetProperty("instructor", false)
	end

	return false
end

-- Checks whether the player can educate.
--
-- @return Boolean canEducate
function Player:CanEducate()
	if self:IsInstructor() or self:IsAtLeast(Instructor.MinEducateGroup) then
		return true
	end

	return false
end

-- Add player data property: instructorMentor
PlayerData:AddProperty("instructorMentor", "boolean", false, function(playerData, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return true
end)

-- Alias function to check whether a player is an instructor mentor.
--
-- @return Boolean isInstructorMentor
function Player:IsInstructorMentor()
	local playerData = self:GetData()

	if playerData then
		return playerData:GetProperty("instructorMentor", false)
	end

	return false
end

-- Add player data property: lastInstruction
PlayerData:AddProperty("lastInstruction", "number", nil, nil, function(playerData, ply)
	return true
end)

-- Alias function to get the last instruction time.
--
-- @return Number lastInstruction
function Player:GetLastInstruction()
	local playerData = self:GetData()

	if playerData then
		return playerData:GetProperty("lastInstruction", nil)
	end

	return nil
end

-- Add rank property: educatedRank
Rank:AddProperty("educatedRank", "boolean", false, function(rank, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Alias function to check whether a rank is an educated rank.
--
-- @return Boolean isEducatedRank
function Rank.Meta:IsEducatedRank()
	return self:GetProperty("educatedRank", false)
end

-- Returns every rank that has the educatedRank property.
--
-- @return Table ranks
function Instructor:GetEducatedRanks()
	local ranks = {}

	for k, rank in pairs(Rank:GetCache()) do
		if rank:IsEducatedRank() then
			table.insert(ranks, rank)
		end
	end

	return ranks
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Do not allow normal promotion of un-educated characters.
hook.Add("Player.BlockChangeFactionRank", "Instructor.PreventPromotion", function(ply, character, rankId, factionId, inviteConfirmed)
	local rank = Rank:GetCached(rankId)
	if not rank then return end

	if rank:IsStartRank() then
		return true
	end
end)

-- Allow moderators and instructor mentors to edit the instructor property.
hook.Add("PlayerData.CanPlayerEditProperty.instructor", "Instructor.EditIstructor", function(ply, playerData, value)
	if ply:IsAtLeast("moderator") then
		return true
	end

	if ply:IsInstructorMentor() then
		return true
	end
end)

-- Only allow moderators to edit the instructorMentor property.
hook.Add("PlayerData.CanPlayerEditProperty.instructorMentor", "Instructor.EditInstructorMentor", function(ply, playerData, value)
	if ply:IsAtLeast("moderator") then
		return true
	end
end)

-- Allow instructors to rename recruits
hook.Add("Character.CanPlayerEditProperty.name", "Instructor.InstructorRename", function(ply, character, value)
	if not Instructor.AllowRename then return end

	if not ply:IsInstructor() then return end

	local rank = character:GetRank()
	if not rank then return end

	if rank:IsStartRank() then
		return true
	end
end)

-- Change can be kicked onto to only respect the educated rank property.
hook.Add("Rank.CanBeKickedOnto", "Instructor.Override", function(rank)
	return rank:IsEducatedRank()
end)

-- Allow instructors to edit species for recruits.
hook.Add("Character.CanPlayerEditProperty.species", "Instructor.EditSpeciesPermissions", function(ply, character, value)
	if not ply:IsInstructor() then return end

	local rank = character:GetRank()
	if not rank then return end

	if rank:IsStartRank() then
		return true
	end
end)

-- Allow instructors to edit head model for recruits.
hook.Add("Character.CanPlayerEditProperty.headModel", "Instructor.EditHeadModelPermissions", function(ply, character, value)
	if not ply:IsInstructor() then return end

	local rank = character:GetRank()
	if not rank then return end

	if rank:IsStartRank() then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/instructor/cl_instructor.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Instructor | Client        --
---------------------------------------

-- Add properties to the property list.
PlayerData:AddPropertyToList("instructor", egmt("instructor.name"), egmt("instructor.description"), "boolean", nil, nil, 1, egmt("instructor.name"))

PlayerData:AddPropertyToList("instructorMentor", egmt("instructor.mentor_name"), egmt("instructor.mentor_description"), "boolean", nil, nil, 2, egmt("instructor.name"))

Rank:AddPropertyToList("educatedRank", egmt("instructor.educated_name"), egmt("instructor.educated_description"), "boolean", nil, nil, 3, egmt("character.slotType_name"))

-- Returns the color of the instructor icon in the scoreboard.
--
-- @param Entity ply
-- @return Color / Boolean
function Instructor:GetScoreboardColor(ply)
    if ply:IsInstructorMentor() then
        return GetColor("red")
    elseif ply:IsInstructor() then
        return UI.ForegroundColor
    end
    return false
end

-- Opens the menu for educating a character.
--
-- @param Player target
function Instructor:OpenEducateMenu(target)
    if not LocalPlayer():CanEducate() then
        return false, egmt("instructor.error")
    end

    local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("instructor.process"))

    -- Add every educated rank to the options.
    local options = {}
    for k, rank in pairs(self:GetEducatedRanks()) do
        table.insert(options, {
            ["text"] = rank:GetFaction():GetName() .. " " .. rank:GetName(),
            ["data"] = rank,
            ["authorityLevel"] = rank:GetAuthorityLevel()
        })
    end

    table.SortByMember(options, "authorityLevel")

    modal:Selection("", egmt("character.select_rank"), options, function(rank)
        net.Start("Intructor.EducatePlayer")
            net.WriteString(target:SteamID64())
            net.WriteInt(rank:GetId(), 32)
        net.SendToServer()
    end, nil, egmt("instructor.process2"))
end
--gamemodes/starwarsrp/gamemode/modules/backpack/item_classes/backpack/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Backpack Item      --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Rucksack"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "backpackSlots", "requiredArmor"}



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override Camera Position for the model icon.
hook.Add("EGMModelIcon.OverrideDisplay", "Backpack.OverrideBackpack", function(displayType, modelPanel, ent)
	if displayType ~= "Backpack" then return end

	local bodyBone = ent:LookupBone("ValveBiped.Bip01_Spine2")
	if bodyBone then
		local bodyPos = ent:GetBonePosition(bodyBone)

		modelPanel:SetLookAt(bodyPos + Vector(   0, 0, 4))
		modelPanel:SetCamPos(bodyPos + Vector(-300, 0, 4))

		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/jetpack/sh_jetpack.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Jetpack         --
---------------------------------------

-- Add item type property: jpUp
ItemType:AddProperty("jpUp", "number", 1000, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: jpFor
ItemType:AddProperty("jpFor", "number", 4, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: jpSide
ItemType:AddProperty("jpSide", "number", 2, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: jpFuel
ItemType:AddProperty("jpFuel", "number", 100, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: jpEFuel
ItemType:AddProperty("jpEFuel", "number", 20, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: secFuel
ItemType:AddProperty("secFuel", "number", 2000, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Add item type property: jpRegen
ItemType:AddProperty("jpRegen", "number", 10, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)



---------------------------------------
--     Jetpack Functiontionality     --
---------------------------------------

-- Recharge the jetpack fuel, if the last jetpack run is older than the cooldown.
--
-- @param Player ply
function Jetpack:RechargeJetpack(ply, jetpackItem)
	local maxFuel = ply.MaxJetpackFuel

	local jetpackFuel = ply.JetpackFuel or 0
	if jetpackFuel >= maxFuel then
		ply.JetpackFuel = maxFuel

		return
	end

	local secondaryFuel = ply.SecondaryFuel or ply.MaxSecondaryFuel
	if secondaryFuel == 0 then
		return
	end

	local lastRun = ply.LastJetpackRun or 0
	if CurTime() - lastRun > ply.CoolDown then
		local diff = maxFuel - jetpackFuel
		local rechargeAmount = math.min(diff, secondaryFuel)

		ply.JetpackFuel = jetpackFuel + rechargeAmount
		ply.SecondaryFuel = secondaryFuel - rechargeAmount
	end
end

-- Apply the jetpack from the item to the player.
--
-- @param Player ply
-- @param Boolean enabled
-- @param? Table jetpackItem
function Jetpack:ApplyJetpack(ply, enabled, jetpackItem)
	if enabled then
		-- Try finding the jetpack item, if not provided.
		if not jetpackItem then
			local char = ply:GetCurrentCharacter()
			if char then
				jetpackItem = Inventory:GetCurrentJetpack(char, inventory)
			end
		end

		-- Skip, if the player has no jetpack item. (Should not happen)
		if not jetpackItem then
			ply.JetpackActive = false

			return
		end

		-- Get the jetpack configuration from the item class
		local success, _, itemType = Inventory:GetItemClass(jetpackItem)
		if not success then return end

		ply.JetpackActive = true

		ply.BoostUp = itemType:GetProperty("jpUp", 1000)
		ply.MaxBoostSpeed = ply.BoostUp * 2

		ply.BoostHover = math.min(ply.BoostUp, 1000)

		ply.StrafeForward = itemType:GetProperty("jpFor", 4)
		ply.StrafeSide = itemType:GetProperty("jpSide", 2)
		ply.MaxStrafeForward = ply.StrafeForward * 200
		ply.MaxStrafeSide = ply.StrafeSide * 200

		ply.BrakeFactor = 0.5

		ply.MaxJetpackFuel = itemType:GetProperty("jpFuel", 100)
		ply.CoolDown = itemType:GetProperty("jpRegen", 10)
		ply.EmergencyFuel = itemType:GetProperty("jpEFuel", 20)

		ply.MaxSecondaryFuel = itemType:GetProperty("secFuel", 2000)

		self:RechargeJetpack(ply, jetpackItem)
	else
		ply.JetpackActive = false

		ply.BoostUp = nil
		ply.BoostHover = nil
		ply.MaxBoostSpeed = nil

		ply.StrafeForward = nil
		ply.StrafeSide = nil
		ply.MaxStrafeForward = nil
		ply.MaxStrafeSide = nil

		ply.BrakeFactor = nil

		ply.CoolDown = nil
		ply.MaxJetpackFuel = nil
		ply.EmergencyFuel = nil

		ply.MaxSecondaryFuel = nil
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

local gravity = GetConVar("sv_gravity"):GetFloat() * 0.5

local boostFuelFactor = 1 / 2
local hoverFuelFactor = 1 / 8
local strafeFuelFactor = 50

-- Handle Jetpack Movement
hook.Add("SetupMove", "Jetpack.SetupMove", function(ply, mv, cmd)
	if not ply.JetpackActive then return end
	if ply:IsOnGround() then return end
	if ply:GetMoveType() ~= MOVETYPE_WALK then return end

	-- Track, if the jetpack is running.
	local jetpackFuel = ply.JetpackFuel or 0
	local emergencyMode = jetpackFuel <= ply.EmergencyFuel
	local fuelCost = 0

	local vel = mv:GetVelocity()
	local frameTime = FrameTime()

	-- Check player weight
	local char = ply:GetCurrentCharacter()
	if not char then return end

	local weight = char:GetInventoryWeight()
	local maxWeight = char:GetMaxWeight()
	local weightPercentage = weight / maxWeight

	-- Check, if the jetpack is overloaded.
	local jetpackPower = math.min(1, 3 - weightPercentage)

	-- Boost up
	if ply:KeyDown(IN_JUMP) then
		if vel.z < ply.MaxBoostSpeed and not emergencyMode then
			vel.z = vel.z + ply.BoostUp * frameTime * jetpackPower

			fuelCost = fuelCost + (ply.BoostUp * boostFuelFactor) * frameTime
		end
	-- Hovering / Brake
	elseif ply:KeyDown(IN_SPEED) then
		if vel.z < 0 then -- Only hover if going down.
			vel.z = math.Approach(vel.z, gravity * frameTime, ply.BoostHover * frameTime * jetpackPower)

			fuelCost = fuelCost + (ply.BoostHover * hoverFuelFactor) * frameTime
		end
	end

	-- Get an up aligned move direction.
	local ang = mv:GetMoveAngles()
	ang.p = 0

	-- Forward / Backward Movement
	local straveFor = Vector(0, 0, 0)
	straveFor:Add(ang:Forward() * mv:GetForwardSpeed() * ply.StrafeForward)
	if straveFor:Length2DSqr() > 0 and not emergencyMode then
		straveFor:Normalize()
		straveFor:Mul(ply.MaxStrafeForward * frameTime * jetpackPower)

		vel:Add(straveFor)

		fuelCost = fuelCost + (ply.StrafeForward * strafeFuelFactor) * frameTime
	end

	-- Left / Right Movement
	local straveSide = Vector(0, 0, 0)
	straveSide:Add(ang:Right() * mv:GetSideSpeed() * ply.StrafeForward)
	if straveSide:Length2DSqr() > 0 and not emergencyMode then
		straveSide:Normalize()
		straveSide:Mul(ply.MaxStrafeSide * frameTime * jetpackPower)

		vel:Add(straveSide)

		fuelCost = fuelCost + (ply.StrafeSide * strafeFuelFactor) * frameTime
	end

	-- If the jetpack is not running, we don't need to apply any movement.
	if fuelCost == 0 then return end

	ply.LastJetpackRun = CurTime()

	-- Only apply the velocity, if we have fuel.
	if jetpackFuel > 0 then
		-- Resistance to slow down the player. (Depends on weight and air resistance.)
		local airResistance = ply.BrakeFactor * frameTime
		vel.x = math.Approach( vel.x, 0, airResistance * vel.x )
		vel.y = math.Approach( vel.y, 0, airResistance * vel.y )

		mv:SetVelocity(vel)

		if IsFirstTimePredicted() then
			ply.JetpackFuel = math.max(0, jetpackFuel - fuelCost * frameTime)
		end
	end
end)

-- Override the player's animation, if the jetpack is active.
hook.Add("CalcMainActivity", "Jetpack.CalcMainActivity", function(ply, vel)
	if not ply.JetpackActive then return end
	if ply:IsOnGround() then return end

	return ACT_MP_SWIM, -1
end)

-- Override the player's animation, if the jetpack is active.
hook.Add("UpdateAnimation", "Jetpack.UpdateAnimation", function(ply, vel, maxseqgroundspeed)
	if not ply.JetpackActive then return end
	if ply:IsOnGround() then return end

	ply:SetPlaybackRate( 0 )    --don't do the full swimming animation
	return true
end)

-- Timer to recharge the jetpack fuel.
timer.Create("Jetpack.Recharge", 1, 0, function()
	pcall(function()
		hook.Run("Jetpack.Recharge")
	end)
end)

-- Recharge the jetpack fuel for all players.
hook.Add("Jetpack.Recharge", "Jetpack.Recharge", function()
	for _, ply in ipairs(player.GetAll()) do
		if ply.JetpackActive then
			Jetpack:RechargeJetpack(ply)
		end
	end
end)

--gamemodes/starwarsrp/gamemode/modules/jetpack/item_classes/jetpack/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Jetpack Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Jetpack"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "backpackSlots", "jpUp", "jpFor", "jpSide", "jpFuel", "jpEFuel", "secFuel", "jpRegen", "requiredArmor"}

-- Callback run, when the item is equipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnEquip(ply, char, itemType, itemData)
	ITEM_CLASS.Base.OnEquip(self, ply, char, itemType, itemData)

	-- Only equip valid items.
	if not self:Validate(itemType, itemData) then
		return
	end

	-- Load the jetpack fuel from the item on equip.
	if itemData.JetpackFuel then
		ply.JetpackFuel = itemData.JetpackFuel
	else
		ply.JetpackFuel = itemType:GetProperty("jpFuel", 100)
	end

	-- Load the secondary fuel from the item on equip.
	if itemData.SecondaryFuel then
		ply.SecondaryFuel = itemData.SecondaryFuel
	else
		ply.SecondaryFuel = itemType:GetProperty("secFuel", 2000)
	end
end

-- Callback run, when the item is unequipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnUnequip(ply, char, itemType, itemData)
	ITEM_CLASS.Base.OnUnequip(self, ply, char, itemType, itemData)

	-- Only unequip valid items.
	if not self:Validate(itemType, itemData) then
		return
	end

	-- Reset the jetpack fuel on the player.
	ply.JetpackFuel = nil
	ply.SecondaryFuel = nil
end



---------------------------------------
--              Tooltip              --
---------------------------------------

function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
	ITEM_CLASS.Base.AddDescriptionLines(self, itemType, itemData, lines)

	-- If the jetpack is equipped, do not show the fuel value in the tooltip.
	-- This is done, since the secondary fuel value is only calculated, when the jetpack is unequipped.
	local slotId = itemData.SlotId
	if not isstring(slotId) or not Inventory:IsEquipmentSlot(slotId) then
		table.insert(lines, {})

		local maxFuel = itemType:GetProperty("secFuel", 2000)
		local fuel = itemData.SecondaryFuel or maxFuel
		local fuelPercent = math.Round(fuel / maxFuel * 100)

		table.insert(lines, {
			Text = "Treibstoff: " .. fuelPercent .. "%",
			Color = UI.ForegroundColor2,
			Align = TEXT_ALIGN_LEFT
		})
	end
end



---------------------------------------
--            UI Behaviour           --
---------------------------------------

-- Callback run, to add additional context menu options to the item.
--
-- @param Table slot
-- @param Panel dermaMenu
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:AddContextMenuOptions(slot, dermaMenu, itemType, itemData)
	ITEM_CLASS.Base.AddContextMenuOptions(self, slot, dermaMenu, itemType, itemData)

	-- Only allow refueling in the supply station.
	local _, _, context = slot:GetId()
	if context ~= "supply_player" then return end

	dermaMenu:AddSpacer()

	dermaMenu:AddOption("Refuel", function()
		local slotId = itemData.SlotId
		local subId = itemData.SubId

		net.Start("Jetpack.Refuel")
			net.WriteString(slotId)
			net.WriteUInt(subId, 16)
		net.SendToServer()
	end):SetIcon("icon16/arrow_rotate_anticlockwise.png")
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override Camera Position for the model icon.
hook.Add("EGMModelIcon.OverrideDisplay", "Jetpack.OverrideJetpack", function(displayType, modelPanel, ent)
	if displayType ~= "Jetpack" then return end

	local bodyBone = ent:LookupBone("ValveBiped.Bip01_Spine2")
	if bodyBone then
		local bodyPos = ent:GetBonePosition(bodyBone)

		modelPanel:SetLookAt(bodyPos + Vector(   0, 0, 4))
		modelPanel:SetCamPos(bodyPos + Vector(-300, 0, 4))

		return true
	end

	local hipsBone = ent:LookupBone("ValveBiped.Bip01_Pelvis")
	if hipsBone then
		local hipsPos = ent:GetBonePosition(hipsBone)

		modelPanel:SetLookAt(hipsPos + Vector(   0, 0, -30))
		modelPanel:SetCamPos(hipsPos + Vector(-250, 0, -30))

		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_medicsystem.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

local callbackFunction = nil

-- Selects the treatment and configure the message
--
-- @param? Player ply
-- @param? String hitGroup
-- @param? String injuryKey
-- @param? String treatment
function Medicsystem:SelectTreatment(ply, hitGroup, injuryName, treatment)
	if tobool(Settings:Get("Eigenes PassivRP")) or Medicsystem.Treatments[treatment].ForceCustomMessage then
		local modal = vgui.Create("MedicModal")
		modal:SetCustomTitle("Aktion schreiben")
		modal:Deltaa_TextEntry("Beschreibe deine Aktion. \nKörperteil: " .. hitGroup .. " \nVerletzung: " .. injuryName ~= hitGroup and Medicsystem:TranslateInjury(injuryName) or "Keine" .. "\nAusgewählte Behandlung: " .. Medicsystem.Treatments[treatment].Name, function(text)
			self:TreatInjury(ply, hitGroup, injuryName, treatment, text)
		end, function()
		end, "Beschreibe ein Vorgehen. Lass das /me weg!")
	else
		self:TreatInjury(ply, hitGroup, injuryName, treatment)
	end
end

-- Starts a netmessage to treat an player
--
-- @param? Player ply
-- @param? String hitGroup
-- @param? String injuryKey
-- @param? String treatment
-- @param? String message
function Medicsystem:TreatInjury(ply, hitGroup, injuryName, treatment, message)
	net.Start("Medicsystem.TreatPlayer")
		net.WriteEntity(ply)
		net.WriteString(hitGroup)
		net.WriteString(injuryName)
		net.WriteString(treatment)
		net.WriteString(message or "")
	net.SendToServer()

	local weapon = LocalPlayer():GetActiveWeapon()
	weapon.treatmentCurrentlyAppling = true
	weapon.treatmentAppliedTime = CurTime()
	weapon.treatmentFinishedTime = CurTime() + Medicsystem.Treatments[treatment].TreatmentTime
end

-- Sends a request to server to get injuries synced
--
-- @param? Player ply
-- @param? function callback
function Medicsystem:GetInjuries(ply, hitgroup, callback)
	if not isfunction(callback) then return end

	if not IsValid(ply) then
		return false, "Not valid player"
	end

	callbackFunction = callback

	net.Start("Medicsystem.RequestInjuries")
		net.WriteEntity(ply)
		net.WriteString(hitgroup)
	net.SendToServer()

	timer.Simple(5, function()
		if isfunction(callbackFunction) then
			callbackFunction = nil
		end
	end)
end

-- Receives the injury table from server
--
net.Receive("Medicsystem.GetInjuries", function()
	if not isfunction(callbackFunction) then return end

	local length = net.ReadInt(32)
	local injuries = net.ReadData(length)

	callbackFunction(DecompressTable(injuries))
	callbackFunction = nil
end)

-- Closes the Medicsystem menu.
--
function Medicsystem:CloseMenu()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Opens the scanner menu
--
-- @param? Player ply
function Medicsystem:OpenMenu(ply, title)
	if not IsValid(ply) then return end

	local w, h = ScrW() * 0.6, ScrH() * 0.8
	local selectedHitGroup = ""

	local backgroundColor = Color(33, 33, 39, 200)
	local bannerColor = Color(0, 90, 126, 100)
	local lineColor = Color(55, 200, 255)

	Medicsystem:GetInjuries(ply, "", function(injuries)
		self:CloseMenu()
		surface.PlaySound(UI.ButtonSound)

		self.Frame = vgui.Create("DFrame")
		self.Frame:SetPos((ScrW() - w) / 2, (ScrH() - h) / 2)
		self.Frame:SetSize(w, h)
		self.Frame:SetTitle("")
		self.Frame:ShowCloseButton(false)
		self.Frame:SetDraggable(false)
		function self.Frame:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, bannerColor)

			surface.SetDrawColor(lineColor)
			self:DrawOutlinedRect()
		end

		self.Title = vgui.Create("DPanel", self.Frame)
		self.Title:SetPos(w * 0.15, h * 0.02)
		self.Title:SetSize(w - w * 0.15 * 2, h * 0.06)
		function self.Title:Paint(width, height)
			draw.RoundedBox(1, 0, 0, width, height, backgroundColor)

			surface.SetDrawColor(lineColor)
			self:DrawOutlinedRect()

			draw.DrawText(title, "EGMText12", width / 2, height * 0.13, lineColor, TEXT_ALIGN_CENTER)
		end

		self.ModelPanel = vgui.Create("DPanel", self.Frame)
		self.ModelPanel:SetSize(w * 0.4, h * 0.5)
		self.ModelPanel:SetPos(w * 0.05, h * 0.1)
		function self.ModelPanel:Paint(width, height)
			draw.RoundedBox(1, 0, 0, width, height, backgroundColor)

			surface.SetDrawColor(lineColor)
			self:DrawOutlinedRect()
		end

		self.Model = vgui.Create("DModelPanel", self.ModelPanel)
		self.Model:Dock(FILL)
		self.Model:SetModel(ply:GetModel())
		self.Model:SetFOV(65)
		function self.Model:LayoutEntity(ent)
			ent:SetAngles(Angle(0, 45, 0))
			ent:SetPos(Vector(0, 0, 3))
		end

		local buttonWidth, buttonHeight = w * 0.1, h * 0.04
		local bodyButtons = {
			{
				pos = {
					x = w * 0.15,
					y = h * 0.02
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_HEAD]
			},
			{
				pos = {
					x = w * 0.15,
					y = h * 0.12
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_CHEST]
			},
			{
				pos = {
					x = w * 0.15,
					y = h * 0.19
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_STOMACH]
			},
			{
				pos = {
					x = w * 0.26,
					y = h * 0.15
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_LEFTARM]
			},
			{
				pos = {
					x = w * 0.04,
					y = h * 0.15
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_RIGHTARM]
			},
			{
				pos = {
					x = w * 0.26,
					y = h * 0.34
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_LEFTLEG]
			},
			{
				pos = {
					x = w * 0.04,
					y = h * 0.34
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_RIGHTLEG]
			},
		}

		self.BodyButtons = {}
		for k, buttonData in pairs(bodyButtons) do
			local button = vgui.Create("EGMButton", self.Model)
			button:SetSize(buttonWidth, buttonHeight)
			button:SetPos(buttonData.pos.x, buttonData.pos.y)
			button:SetText("")
			button.selected = false
			button.buttonData = buttonData

			function button:Paint(width, height)
				local hitGroup = buttonData.hitGroup
				local count = injuries and injuries[buttonData.hitGroup] and table.Count(injuries[buttonData.hitGroup]) or 0
				local buttonName = hitGroup .. " (" .. count .. ")"

				if self.selected then
					draw.RoundedBox(0, 0, 0, width, height, GetColor("red", 200))
					draw.SimpleText(buttonName, "EGMText6", width / 2, height / 2, lineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				else
					draw.RoundedBox(0, 0, 0, width, height, backgroundColor)
					draw.SimpleText(buttonName, "EGMText6", width / 2, height / 2, lineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end

				surface.SetDrawColor(lineColor)
				self:DrawOutlinedRect()
			end
			function button:DoClick()
				for _, button in pairs(Medicsystem.BodyButtons) do
					button.selected = button.buttonData.hitGroup == self.buttonData.hitGroup
				end

				selectedHitGroup = button.buttonData.hitGroup

				Medicsystem.InjuryList:Refresh(button.buttonData.hitGroup)
				Medicsystem.InjuryInfo:Initilize()
			end

			self.BodyButtons[k] = button
		end

		self.InjuryPanel = vgui.Create("DPanel", self.Frame)
		self.InjuryPanel:SetSize(w * 0.4, h * 0.85)
		self.InjuryPanel:SetPos(w * 0.55, h * 0.1)
		function self.InjuryPanel:Paint(width, height)
			draw.RoundedBox(1, 0, 0, width, height, backgroundColor)

			surface.SetDrawColor(lineColor)
			self:DrawOutlinedRect()
		end

		self.InjuryInfo = vgui.Create("RichText", self.InjuryPanel)
		self.InjuryInfo:Dock(FILL)
		self.InjuryInfo:SetVerticalScrollbarEnabled(false)
		self.InjuryInfo:SetText("")
		function self.InjuryInfo:PerformLayout()
			self:SetFontInternal("EGMText10")
		end

		function self.InjuryInfo:Refresh(index, injury)
			local injuryData = Medicsystem.Injuries[Medicsystem:TranslateInjury(injury.name)]

			self:SetText("")

			self:InsertColorChange(GetColor2("blue"))
			self:AppendText("Kondition\n")

			self:InsertColorChange(GetColor2("yellow"))
			self:AppendText("Status: ")
			self:InsertColorChange(GetColor2("white"))
			self:AppendText(Medicsystem:HasPulse(ply) .. "\n\n")

			self:InsertColorChange(GetColor2("blue"))
			self:AppendText("Verletzungsinformationen\n")

			self:InsertColorChange(GetColor2("yellow"))
			self:AppendText("Verletzungsart: ")
			self:InsertColorChange(GetColor2("white"))
			self:AppendText(injury.name .. "\n")

			self:InsertColorChange(GetColor2("yellow"))
			self:AppendText("Betroffenes Körperteil: ")
			self:InsertColorChange(GetColor2("white"))
			self:AppendText(selectedHitGroup .. "\n")

			if not injuryData.Incurable then
				self:InsertColorChange(GetColor2("yellow"))
				self:AppendText("Schwere der Verletzung: ")
				self:InsertColorChange(GetColor2("white"))
				self:AppendText(Medicsystem.InjurySeverities[injury.severity]  .. "\n")

				self:InsertColorChange(GetColor2("yellow"))
				self:AppendText("Angewandte Behandlungen:\n")
				self:InsertColorChange(GetColor2("white"))

				for k, v in pairs(injury.treatmentsApplied) do
					self:AppendText("- " .. Medicsystem.Treatments[k].Name .. "\t")

					self:AppendText("\n")
					self:InsertColorChange(GetColor2("white"))
				end
			end
		end

		function self.InjuryInfo:Initilize()
			self:SetText("")

			self:InsertColorChange(GetColor2("blue"))
			self:AppendText("Kondition\n")

			self:InsertColorChange(GetColor2("yellow"))
			self:AppendText("Status: ")
			self:InsertColorChange(GetColor2("white"))
			self:AppendText(Medicsystem:HasPulse(ply) .. "\n\n")
		end

		self.InjuryInfo:Initilize()

		self.InjuryListPanel = vgui.Create("DPanel", self.Frame)
		self.InjuryListPanel:SetSize(w * 0.4, h * 0.3)
		self.InjuryListPanel:SetPos(w * 0.05, h * 0.65)
		function self.InjuryListPanel:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, backgroundColor)

			surface.SetDrawColor(lineColor)
			self:DrawOutlinedRect()
		end

		self.InjuryList = vgui.Create("EGMListView", self.InjuryListPanel)
		self.InjuryList:Dock(FILL)
		self.InjuryList:SetHeaderHeight(h * 0.045)
		self.InjuryList:SetDataHeight(h * 0.035)
		self.InjuryList:AddCustomColumn("Verletzungen")
		self.InjuryList:SetMultiSelect(false)
		self.InjuryList:SetSortable(false)

		self.InjuryList.backgroundColor = backgroundColor
		self.InjuryList.lineAltBgColor = backgroundColor
		self.InjuryList.columnBgColor = ColorAlpha(lineColor, 100)

		function self.InjuryList:OnRowSelected(index, line)
			Medicsystem.InjuryInfo:Refresh(index, line.injury)
		end

		function self.InjuryList:Refresh(hitGroup)
			if not hitGroup then return end

			self:Clear()

			if not istable(injuries) or not istable(injuries[hitGroup]) then return end

			for k, injury in pairs(injuries[hitGroup]) do
				local line = self:AddCustomLine(injury.name)
				line.injury = injury
			end
		end

		self.Close = vgui.Create("EGMCloseButton", self.Frame)
		self.Close:SetPanel(self.Frame)
		self.Close:SetPos(w * 0.96, h * 0.01)
		self.Close:SetSize(h * 0.04, h * 0.04)

		self.Frame:MakePopup()
	end)
end

-- Select a hitgroup
--
-- @param? Player ply
--
-- @return? Function callback
function Medicsystem:SelectHitgroup(ply, treatment, callback)
	Medicsystem:GetInjuries(ply, "", function(injuries)
		local w, h = ScrW() * 0.5, ScrH() * 0.7

		local selectedHitGroup = ""
		local treatmentData = Medicsystem.Treatments[treatment]

		self:CloseMenu()

		self.Frame = vgui.Create("DFrame")
		self.Frame:SetPos((ScrW() - w) / 2, (ScrH() - h) / 2)
		self.Frame:SetSize(w, h)
		self.Frame:SetTitle("")
		self.Frame:ShowCloseButton(false)
		function self.Frame:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, GetColor("darkgray", 250))
		end

		self.Title = vgui.Create("DPanel", self.Frame)
		self.Title:SetPos(w * 0.15, 0)
		self.Title:SetSize(w - w * 0.15 * 2, h * 0.1)
		function self.Title:Paint(width, height)
			draw.RoundedBox(0, w * 0.05, 0, width - w * 0.05 * 2, height, UI.BackgroundColor2)

			surface.SetDrawColor(UI.BackgroundColor2)
			draw.NoTexture()

			surface.DrawPoly({
				{x = 0, y = 0},
				{x = w * 0.051, y = 0},
				{x = w * 0.051, y = height}
			})
			surface.DrawPoly({
				{x = width - w * 0.051, y = 0},
				{x = width, y = 0},
				{x = width - w * 0.051, y = height}
			})

			draw.DrawText("Körperteil wählen", "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
		end

		self.Model = vgui.Create("DModelPanel", self.Frame)
		self.Model:SetSize(w / 1.5, h / 1.5)
		self.Model:SetPos(w * 0.15, h * 0.15)
		self.Model:SetModel(ply:GetModel())
		self.Model:SetFOV(75)
		self.Model:SetZPos(-1)
		function self.Model:LayoutEntity(ent)
			ent:SetAngles(Angle(0, 45, 0))
		end

		local panelWidth, panelHeight  = self.Model:GetWide(), self.Model:GetTall()
		local buttonWidth, buttonHeight = panelWidth * 0.2, panelHeight * 0.075
		local bodyButtons = {
			{
				pos = {
					x = panelWidth * 0.4,
					y = panelHeight * 0.05
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_HEAD]
			},
			{
				pos = {
					x = panelWidth * 0.4,
					y = panelHeight * 0.315
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_CHEST]
			},
			{
				pos = {
					x = panelWidth * 0.4,
					y = panelHeight * 0.45
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_STOMACH]
			},
			{
				pos = {
					x = panelWidth * 0.625,
					y = panelHeight * 0.4
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_LEFTARM]
			},
			{
				pos = {
					x = panelWidth * 0.175,
					y = panelHeight * 0.4
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_RIGHTARM]
			},
			{
				pos = {
					x = panelWidth * 0.6,
					y = panelHeight * 0.7
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_LEFTLEG]
			},
			{
				pos = {
					x = panelWidth * 0.2,
					y = panelHeight * 0.7
				},
				hitGroup = Medicsystem.Hitgroups[HITGROUP_RIGHTLEG]
			},
		}

		self.BodyButtons = {}
		for k, buttonData in pairs(bodyButtons) do
			local button = vgui.Create("EGMButton", self.Model)
			button:SetSize(buttonWidth, buttonHeight)
			button:SetPos(buttonData.pos.x, buttonData.pos.y)
			button:SetText("")
			button.selected = false
			button.buttonData = buttonData
			function button:Paint(width, height)
				local hitGroup = buttonData.hitGroup
				local count = injuries and injuries[buttonData.hitGroup] and table.Count(injuries[buttonData.hitGroup]) or 0
				local buttonName = hitGroup .. " (" .. count .. ")"

				if self.selected then
					draw.RoundedBox(5, 0, 0, width, height, GetColor("blue", 250))
					draw.SimpleText(buttonName, "EGMText6", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				else
					draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 250))
					draw.SimpleText(buttonName, "EGMText6", width / 2, height / 2, GetColor("yellow"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
			end

			function button:DoClick()
				for _, button in pairs(Medicsystem.BodyButtons) do
					button.selected = button.buttonData.hitGroup == self.buttonData.hitGroup
				end

				selectedHitGroup = button.buttonData.hitGroup
			end

			self.BodyButtons[k] = button
		end

		self.selectButton = vgui.Create("EGMButton", self.Frame)
		self.selectButton:SetSize(w * 0.9, h * 0.05)
		self.selectButton:SetPos(w * 0.05, h * 0.925)
		self.selectButton:SetText("")
		function self.selectButton:CanUse()
			if selectedHitGroup == "" then return false end

			local canGlobal = isfunction(treatmentData.CanGlobalUse) and treatmentData:CanGlobalUse(LocalPlayer(), ply, selectedHitGroup)
			if canGlobal == true then
				return true
			end

			local injuryCount = injuries[selectedHitGroup] and table.Count(injuries[selectedHitGroup]) or 0
			if injuryCount > 0 then
				for _, injuryData in pairs(injuries[selectedHitGroup]) do
					local injury = Medicsystem.Injuries[Medicsystem:TranslateInjury(injuryData.name)]
					if injury.Incurable then continue end

					local canLocal = isfunction(treatmentData.CanLocalUse) and treatmentData:CanLocalUse(LocalPlayer(), ply, hitGroup, injuryData)
					if canLocal == true then
						return true
					end
				end
			end

			return false
		end

		function self.selectButton:Paint(width, height)
			if self:CanUse() then
				draw.RoundedBox(5, 0, 0, width, height, GetColor("yellow", 250))

				draw.SimpleText("Auswählen", "EGMText8", width / 2, height / 2, GetColor("white"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end

		function self.selectButton:DoClick()
			if self:CanUse() then
				callback(selectedHitGroup)
			end
		end

		self.Close = vgui.Create("EGMCloseButton", self.Frame)
		self.Close:SetPanel(self.Frame)
		self.Close:SetPos(w * 0.96, h * 0.01)
		self.Close:SetSize(h * 0.04, h * 0.04)

		self.Frame:MakePopup()
	end)
end

-- Select an injectable treatment
--
-- @return? Function callback
function Medicsystem:OpenTreatments(itemType, callback)
	local w, h = ScrW() * 0.4, ScrH() * 0.45
	local selectedTreatment = ""

	self:CloseMenu()

	self.Frame = vgui.Create("DFrame")
	self.Frame:SetPos((ScrW() - w) / 2, (ScrH() - h) / 2)
	self.Frame:SetSize(w, h)
	self.Frame:SetTitle("")
	self.Frame:ShowCloseButton(false)
	function self.Frame:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, GetColor("darkgray"))
		self:DrawOutlinedRect()
	end

	self.Title = vgui.Create("DPanel", self.Frame)
	self.Title:SetPos(w * 0.1, h * 0.01)
	self.Title:SetSize(w * 0.8, h * 0.12)
	function self.Title:Paint(width, height)
		draw.RoundedBox(0, w * 0.05, 0, width - w * 0.05 * 2, height, UI.BackgroundColor2)

		surface.SetDrawColor(UI.BackgroundColor2)
		draw.NoTexture()

		surface.DrawPoly({
			{x = 0, y = 0},
			{x = w * 0.051, y = 0},
			{x = w * 0.051, y = height}
		})
		surface.DrawPoly({
			{x = width - w * 0.051, y = 0},
			{x = width, y = 0},
			{x = width - w * 0.051, y = height}
		})

		draw.DrawText("Wähle eine Behandlung", "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
	end

	self.Close = vgui.Create("EGMCloseButton", self.Frame)
	self.Close:SetPanel(self.Frame)
	self.Close:SetPos(w * 0.95, h * 0.01)
	self.Close:SetSize(h * 0.07, h * 0.07)

	self.TreatmentsList = vgui.Create("EGMListView", self.Frame)
	self.TreatmentsList:SetSize(w * 0.5, h * 0.6)
	self.TreatmentsList:SetPos(w * 0.005, h * 0.2)
	self.TreatmentsList:SetMultiSelect(false)
	self.TreatmentsList:SetSortable(false)
	self.TreatmentsList:SetHeaderHeight(h * 0.1)
	self.TreatmentsList:SetDataHeight(h * 0.075)
	self.TreatmentsList:AddCustomColumn("Behandlungen")
	function self.TreatmentsList:OnRowSelected(index, line)
		local infoPanel = Medicsystem.TreatmentInfo
		local treatment = line.treatment

		infoPanel:SetText("")

		infoPanel:InsertColorChange(GetColor2("blue"))
		infoPanel:AppendText(Medicsystem.Treatments[treatment].Name .. "\n")
		infoPanel:InsertColorChange(GetColor2("white"))
		infoPanel:AppendText(Medicsystem.Treatments[treatment].Description)

		selectedTreatment = treatment
	end
	function self.TreatmentsList:OnRowRightClick(index, line)
		local contextMenu = DermaMenu(line)
		local optionPanel = contextMenu:AddOption("Behandeln", function()
			if selectedTreatment then
				callback(selectedTreatment)

				Medicsystem.Frame:Close()
			end
		end)
		optionPanel:SetColor(GetColor("white"))
		optionPanel:SetFont("EGMText6")
		function contextMenu:Paint(width, height)
			draw.RoundedBox(0, 0, 0, width, height, GetColor("gray"))
			surface.SetDrawColor(GetColor("red"))
			self:DrawOutlinedRect()
		end

		contextMenu:Open()
	end
	function self.TreatmentsList:Refresh(searchValue)
		if not searchValue then searchValue = "" end
		self:Clear()

		for treatment, treatmentData in SortedPairsByMemberValue(Medicsystem.Treatments, "Name") do
			if not treatmentData.Type[itemType] then continue end

			if string.find(string.lower(treatmentData.Name), string.lower(searchValue)) then
				local line = self:AddCustomLine(treatmentData.Name)
				line.treatment = treatment
				line.treatmentData = treatmentData
			end
		end
	end
	self.TreatmentsList:Refresh()

	self.TreatsmentFilter = vgui.Create("DTextEntry", self.Frame)
	self.TreatsmentFilter:SetPos(w * 0.005, h * 0.91)
	self.TreatsmentFilter:SetSize(w * 0.5, h * 0.08)
	self.TreatsmentFilter:SetUpdateOnType(false)
	self.TreatsmentFilter:SetPlaceholderText("Behandung suchen...")
	function self.TreatsmentFilter:OnChange()
		Medicsystem.TreatmentsList:Refresh(self:GetValue())
	end

	self.TreatmentInfo = vgui.Create("RichText", self.Frame)
	self.TreatmentInfo:SetSize(w * 0.5, h * 0.7)
	self.TreatmentInfo:SetPos(w * 0.51, h * 0.2)
	self.TreatmentInfo:SetVerticalScrollbarEnabled(false)
	self.TreatmentInfo:SetText("")
	function self.TreatmentInfo:PerformLayout()
		self:SetFontInternal("EGMText10")
	end

	self.Frame:MakePopup()
end

function Medicsystem:ListInjuries()
	if LocalPlayer():Alive() then return end
	if not LocalPlayer():GetCurrentCharacter() then return end

	local w, h = ScrW(), ScrH()

	Medicsystem:GetInjuries(LocalPlayer(), "", function(injuries)
		self.DeathInjuryList = vgui.Create("EGMListView")
		self.DeathInjuryList:SetSize(w * 0.25, h * 0.2)
		self.DeathInjuryList:SetPos(w * 0.025, h * 0.3)
		self.DeathInjuryList:SetHeaderHeight(h * 0.045)
		self.DeathInjuryList:SetDataHeight(h * 0.035)
		self.DeathInjuryList:AddCustomColumn("Verletzungen")
		self.DeathInjuryList:SetMultiSelect(false)
		self.DeathInjuryList:SetSortable(false)

		function self.DeathInjuryList.Think(self2)
			if LocalPlayer():Alive() then self.DeathInjuryList:Remove() end
		end

		function self.DeathInjuryList:OnRowSelected(index, line)
		end

		function self.DeathInjuryList:Refresh()
			self:Clear()

			if not istable(injuries) then return end

			for hitGroup, hitgroupData in pairs(injuries) do
				if not istable(hitgroupData) then continue end

				for injury, injuryData in pairs(hitgroupData) do
					local line = self:AddCustomLine(hitGroup .. ": " .. injuryData.name  .. " (" .. Medicsystem.InjurySeverities[injuryData.severity] .. ")")
					line.injury = injury
				end
			end
		end

		self.DeathInjuryList:Refresh()
	end)
end

net.Receive("Medicsystem.DeathMenu", function()
	if IsValid(Medicsystem.DeathInjuryList) then
		Medicsystem.DeathInjuryList:Remove()
	end
end)

--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_effects.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

Medicsystem.Effects = {}

net.Receive("Medicsystem.ToggleEffect", function()
	local injury = net.ReadString()
	local bool = net.ReadBool()

	Medicsystem:ToggleEffect(injury, bool)
end)

-- Changes the state of an injury effect
--
-- @param? String injury
-- @param? Bool state
function Medicsystem:ToggleEffect(injury, state)
	Medicsystem.Effects[injury] = state
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_modal.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

local ELEMENT = {}

ELEMENT.Name = "MedicModal"
ELEMENT.Base = "EGMModal"

-- Modal
-- Transforms the modal to a textentry modal. Has a text, a textentry, an accept and an decline button inside.
--
-- @param? String info - defaults to "".
-- @param? onAccept - called when the accept button is clicked.
-- @param? onDecline - called when the decline button is clicked.
-- @param? String placeholder
-- @param? Bool numeric
-- @param? String acceptText - defaults to "Okay".
-- @param? String declineText - defaults to egmt("shared.abort").
-- @param? Color acceptTextColor - defaults to white.
-- @param? Color acceptButtonColor - defaults to green.
-- @param? Color declineTextColor - defaults to white.
-- @param? Color declineButtonColor - defaults to yellow.

function ELEMENT:Deltaa_TextEntry(info, onAccept, onDecline, placeholder, numeric, acceptText, declineText, acceptTextColor, acceptButtonColor, declineTextColor, declineButtonColor)
	local _self = self

	self:CleanModal()

	local frame = self

	if info and #info > 0 then
		frame.info = vgui.Create("RichText", frame)
		frame.info:DockMargin(0, 0, 0, self:GetTall() * 0.15)
		frame.info:Dock(TOP)
		frame.info:SetText(info)
		function frame.info:PerformLayout()
			self:SetFontInternal("EGMText8")
			self:SetToFullHeight()

			local _, h = self:GetSize()
			if h > _self:GetTall() * 0.4 then
				self:SetHeight(_self:GetTall() * 0.4)
			end
		end
		function frame.info:Think()
			if self:GetNumLines() > 1 then
				self:SetVerticalScrollbarEnabled(true)
			else
				self:SetVerticalScrollbarEnabled(false)
			end
		end
	end

	frame.textentry = vgui.Create("DTextEntry", frame)
	frame.textentry:DockMargin(0, 0, 0, self:GetTall() * 0.05)
	frame.textentry:Dock(TOP)
	frame.textentry:SetHeight(self:GetTall() * 0.125)
	frame.textentry:SetPlaceholderText(placeholder)
	frame.textentry:SetNumeric(numeric)
	frame.textentry:SetMultiline(false)

	frame.accept = vgui.Create("EGMButton", frame)
	frame.accept:DockMargin(0, 0, 0, self:GetTall() * 0.01)
	frame.accept:Dock(TOP)
	frame.accept:SetHeight(self:GetTall() * 0.125)
	frame.accept:SetFont("EGMText8")
	frame.accept:SetText(acceptText or "Okay")
	frame.accept:SetTextColor(acceptTextColor or UI.TextColor)
	frame.accept:SetButtonColor(acceptButtonColor or GetColor("green"))
	function frame.accept:DoClick()
		_self:Close()

		if isfunction(onAccept) then
			if string.Trim(frame.textentry:GetValue()) == "" then return end
			onAccept(string.Trim(frame.textentry:GetValue()))
		end
	end

	frame.decline = vgui.Create("EGMButton", frame)
	frame.decline:Dock(TOP)
	frame.decline:SetHeight(self:GetTall() * 0.125)
	frame.decline:SetFont("EGMText8")
	frame.decline:SetTextColor(declineTextColor or UI.TextColor)
	frame.decline:SetText(declineText or "Abbrechen")
	frame.decline:SetButtonColor(declineButtonColor or UI.ForegroundColor)
	function frame.decline:DoClick()
		_self:Close()

		if isfunction(onDecline) then
			onDecline()
		end
	end
end

vgui.Register(ELEMENT.Name, ELEMENT, ELEMENT.Base)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_dropdrugs/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | SH        	 --
---------------------------------------

SWEP.Gun							= "gun_base"
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Medicsystem)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Deltaa"
SWEP.Contact 						= "https://www.einfach-gaming.de/user/4179-deltaa/"

SWEP.PrintName						= "Versorgungskit - Medikamente"
SWEP.Type							= "Versorgerkit"
SWEP.Slot							= 3
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 90, 0),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -06),
		angle = Angle(180, -05, -4),
		size = Vector(0.6, 0.6, 0.6),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.HolsterOffset = Vector(-2, 0, 7)
SWEP.HolsterAngle = Angle(90, 0, 0)

if SERVER then
	function SWEP:Think()
		if (self:Clip1() <= 0) and IsValid(self) and self:OwnerIsValid() then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= 3
SWEP.Primary.DefaultClip			= 3
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "medicsystem_refill_pack"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.RunSpeed						= 0.9
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= ""
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

function SWEP:PostSpawnProjectile(ent)
	ent:SetOwner(nil)
end
DEFINE_BASECLASS( SWEP.Base )
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_injector/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Injector       --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Injektor"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable 				= true

SWEP.ViewModel				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel				= "models/bf2017/w_scoutblaster.mdl"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.ItemType 				= "Injector"
SWEP.NeedsKnowledge 		= true

SWEP.VElements = {
	["syringe"] = {
		type = "Model",
		model = "models/katharsmodels/syringe_out/syringe_out.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(-1, -0.5, 0),
		angle = Angle(45, 90, 0),
		size = Vector(1.014, 1.014, 1.014),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["syringe"] = { type = "Model", model = "models/katharsmodels/syringe_out/syringe_out.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 2, -0.5), angle = Angle(-45.584, -12.858, 90), size = Vector(1.014, 1.014, 1.014), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 20
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_injector_swt/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Injector       --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Injektor (SWT)"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Special Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable 				= true

SWEP.ViewModel				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel				= "models/bf2017/w_scoutblaster.mdl"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 5

SWEP.ItemType 				= "SWT"
SWEP.NeedsKnowledge 		= true

SWEP.VElements = {
	["syringe"] = {
		type = "Model",
		model = "models/katharsmodels/syringe_out/syringe_out.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(-1, -0.5, 0),
		angle = Angle(45, 90, 0),
		size = Vector(1.014, 1.014, 1.014),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["syringe"] = { type = "Model", model = "models/katharsmodels/syringe_out/syringe_out.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 2, -0.5), angle = Angle(-45.584, -12.858, 90), size = Vector(1.014, 1.014, 1.014), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 20
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)
--gamemodes/starwarsrp/gamemode/modules/gravitylock/entities/swrp_gravitylock_big/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Lock            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Gravity Lock | SH         --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Gravity Lock (Groß)"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false

ENT.IsGravitylocker = true

--gamemodes/egmrp/gamemode/modules/escapescreen/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Escape screen index        --
---------------------------------------

EscapeScreen = {}

if SERVER then
    AddCSLuaFile("cl_config.lua")
    AddCSLuaFile("cl_escapescreen.lua")
end

if CLIENT then
    include("cl_config.lua")
    include("cl_escapescreen.lua")
end
--gamemodes/egmrp/gamemode/modules/escapescreen/cl_escapescreen.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Escape screen      --
---------------------------------------

-- Opens the main menu.
function EscapeScreen:Open()
    self:Close()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetSubTitle("")
    self.Frame:SetBackground(self.Background)

    self.ButtonPanel = vgui.Create("EGMScrollPanel", self.Frame)
    self.ButtonPanel:SetPos(ScrW() * 0.05, ScrH() * 0.2)
    self.ButtonPanel:SetSize(ScrW() * 0.3, 0) -- height is set later based on the buttons.
    self.ButtonPanel:SetBackgroundColor(UI.BackgroundColor)
    self.ButtonPanel:SetCornerRadius(5)

    -- Add buttons to the navbar.
    local h = ScrH() * 0.015
    for k, buttonData in pairs(self.Buttons) do
        if buttonData.dockTop then
            h = h + ScrH() * buttonData.dockTop
        end

        local button = vgui.Create("EGMButton", self.ButtonPanel)
        button:SetPos(ScrW() * 0.015, h)
        button:SetSize(ScrW() * 0.27, ScrH() * 0.075)
        button:SetButtonColor(UI.ForegroundColor)
        button:SetButtonHoverColor(UI.ForegroundColor2)
        button:SetButtonCornerRadius(10)
        button:SetFont("EGMText10")
        button:SetTextColor(UI.TextColor)
        button:SetText(buttonData.name)
        function button:DoClick()
            buttonData.func()
        end

        h = h + ScrH() * 0.075 + ScrH() * 0.015
    end

    if h > ScrH() * 0.75 then
        -- Spacer that makes a gap between the last button and the end of the list view.
        local spacer = vgui.Create("DPanel", self.ButtonPanel)
        spacer:SetPos(0, h)
        spacer:SetSize(0, 0)

        self.ButtonPanel:SetTall(ScrH() * 0.75)
    else
        self.ButtonPanel:SetTall(h)
    end

    self.Frame:MakePopup()
end


-- Closes the main menu.
function EscapeScreen:Close()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

-- Hide the normal pause menu.
hook.Add("OnPauseMenuShow", "EscapeScreen.HidePauseMenu", function()
	local override = hook.Run("EscapeScreeen.Override")
	if override then
		return false
	end

	if IsValid(EscapeScreen.Frame) then
		EscapeScreen:Close()
	else
		EscapeScreen:Open()
	end

	return false
end)
--gamemodes/egmrp/gamemode/modules/morgue/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Morgue | Index          --
---------------------------------------

if not RequireModules({"unarmed"}) then
	return false
end

Morgue = Morgue or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_morgue.lua")
	AddCSLuaFile("cl_morgue.lua")

	AddCSLuaFile("cl_interact.lua")

	include("sh_config.lua")
	include("sh_morgue.lua")
	include("sv_morgue.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_morgue.lua")
	include("cl_morgue.lua")

	include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/modules/morgue/entities/egmrp_morgue/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Entity          --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")
--gamemodes/egmrp/gamemode/modules/morgue/entities/egmrp_morgue/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Entity          --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = egmt("morgue.entity")
ENT.Category = "EGM:RP"
ENT.Author = "Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

-- Initializes the entity.
function ENT:Initialize()
	self.IsEGMRPMorgue = true
	self.WorldModel = self.WorldModel or Morgue.Model

	if util.IsValidModel(self.WorldModel) then
		self:SetModel(self.WorldModel)
	else
		self:SetModel("models/props_wasteland/laundry_washer003.mdl")
	end
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)

	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
	end

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()
	end
end
--gamemodes/egmrp/gamemode/modules/permaprops/sh_permaprops.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Permaprop Shared          --
---------------------------------------
local Player = FindMetaTable("Player")

function Player:CanPermaProp()
	if hook.Run("PermaProps.CanPlayerEdit", self) then
		return true
	end

	-- Check if the player is allowed to use the permaprops.
	if self:GetNW2Bool("permaprops_whitelist", false) then
		return true
	end

	if self:IsAtLeast(PermaProps.MinimumGroup) then
		return true
	end

	return false
end

-- Gets the Prop by it's PPID.
--
-- @param number ppid
-- @return Entity permaProp
function PermaProps:GetProp(ppid)
    for _, ent in pairs(ents.GetAll()) do
        if ent:GetNW2Int("PPID", -1) == ppid then
            return ent
        end
    end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Allow everything above Spawnpoints.MinAccessGroup to edit the spawnpoints.
hook.Add("Spawnpoints.CanPlayerEdit", "PermaProps.CanEditPermissions", function(ply)
	if ply:GetNW2Bool("permaprops_whitelist", false) then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/permaprops/sh_stool_permaprop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Permaprop STool     --
---------------------------------------

local TOOL = {}

TOOL.Category = "EGM:RP"
TOOL.Name = "#Tool.permaprop.name"
TOOL.Command = nil
TOOL.ConfigName = nil

if CLIENT then
    language.Add("Tool.permaprop.name", "Perma Prop")
    language.Add("Tool.permaprop.desc", "Speichert Props auf der Map")
    language.Add("Tool.permaprop.0", "Linksklick: Speichern; Rechtsklick: Entfernen")

    function TOOL:LeftClick(trace)
        local ply = self:GetOwner()

        if ply:CanPermaProp() then
            return true
        end
    end

    function TOOL:RightClick(trace)
        local ply = self:GetOwner()

        if ply:CanPermaProp() then
            return true
        end
    end
end

if SERVER then
    function TOOL:LeftClick(trace)
        local ent = trace.Entity
        local ply = self:GetOwner()

        if ply:CanPermaProp() then
            if IsValid(ent) then
                if not ent:IsPlayer() then
                    if ent:GetNW2Int("PPID", -1) < 0 then
                        if #PermaProps.Props < PermaProps.MaxProps then
                            PermaProps:AddProp(ply, ent)
                        else
                            Notify:Danger(ply, "Fehler!", "Die maximale Anzahl an PermaProps ist erreicht!")
                        end
                    else
                        Notify:Danger(ply, "Fehler!", "Das ist bereits ein PermaProp!")
                    end
                else
                    Notify:Danger(ply, "Fehler!", "Das ist ein Spieler!")
                end
            else
                Notify:Danger(ply, "Fehler!", "Ungültiges Entity!")
            end
        else
            Notify:Danger(ply, "Fehler!", "Fehlende Berechtigung!")
        end

        return true
    end

    function TOOL:RightClick(trace)
        local ent = trace.Entity
        local ply = self:GetOwner()

        if ply:CanPermaProp() then
            if IsValid(ent) then
                if ent:GetNW2Int("PPID", -1) >= 0 then
                    PermaProps:Remove(ent:GetNW2Int("PPID", -1))
                    Notify:Success(ply, "Entfernt!", "Entity erfolgreich entfernt!")
                else
                    Notify:Danger(ply, "Fehler!", "Das ist kein PermaProp!")
                end
            else
                Notify:Danger(ply, "Fehler!", "Ungültiges Entity!")
            end
        else
            Notify:Danger(ply, "Fehler!", "Fehlende Berechtigung!")
        end

        return true
    end
end

function TOOL:BuildCPanel()
    self:AddControl("Header", {
        Text = "PermaProps",
        Description = "Speichert Props auf der Map.\nNeu entwickelt von P4sca1, Oninoni & Mattzi"
    })

    self:AddControl("Button", {
        Text = "Perma Prop Menu",
        Command = "perma_prop_menu"
    })
end

stools.Register(TOOL, "permaprop")
--gamemodes/egmrp/gamemode/modules/reports/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | Reports System      --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum group that has full access to the reports.
Reports.MinAccessGroup = "operator"

-- Background for the reports menu.
Reports.Background = "backgrounds/teops_g_planet.jpg"
--gamemodes/egmrp/gamemode/modules/reports/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Reports Interact     --
---------------------------------------

hook.Add("EGMRP.Loaded", "Reports.Interact", function()
    if Config.Modules["reports"] then
        Interact:RegisterOption(nil, egmt("reports.show"), 1, function()
            local target = LocalPlayer():GetEyeTrace().Entity

            if IsValid(target) and target:IsPlayer() then
                local character = target:GetCurrentCharacter()

                if character then
                    Reports:Open(character)
                end
            end

            Interact.Menu:Remove()
        end, function()
            local target = LocalPlayer():GetEyeTrace().Entity

            if IsValid(target) and target:IsPlayer() then
                local character = target:GetCurrentCharacter()

                if character then
                    return LocalPlayer():CanViewReports(character)
                end
            end

            return false
        end)
    end
end)
--gamemodes/egmrp/gamemode/modules/multiserver/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Multiserver index         --
---------------------------------------

if not RequireModules({"socket", "hostname"}) then
    return false
end

MultiServer = MultiServer or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_chats.lua")

    AddCSLuaFile("cl_multiserver_count.lua")
    AddCSLuaFile("cl_multiserver.lua")

    AddCSLuaFile("cl_scoreboard.lua")

    include("sv_socket_propertymodel.lua")

    include("sh_config.lua")
    include("sh_chats.lua")

    include("sv_multiserver_count.lua")
    include("sv_multiserver_join.lua")
    include("sv_multiserver.lua")

    include("sv_chats.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_chats.lua")

    include("cl_multiserver_count.lua")
    include("cl_multiserver.lua")

    include("cl_scoreboard.lua")
end
--gamemodes/egmrp/gamemode/modules/hostname/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Hostname index           --
---------------------------------------

HostName = HostName or {}

if SERVER then

	include("sv_config.lua")
	include("sv_hostname.lua")
end

--gamemodes/egmrp/gamemode/modules/multiserver/cl_multiserver.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        MultiServer | Client       --
---------------------------------------

-- Receive Server change command from server.
net.Receive("MultiServer.ChangeServer", function()
    local id = net.ReadInt(32)
    local server = Socket.GroupServers[id]
    local serverString = server.ip .. ":" .. server.port

    local forceServerSwitch = net.ReadBool()

    if forceServerSwitch then
        permissions.AskToConnect(serverString)
    else
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("multiserver.switch"))
        modal:Confirm(egmt("multiserver.confirm", server.name), function()
            permissions.AskToConnect(serverString)
        end)
    end
end)

-- Closes the Loading Screen. (Used for Auto-Character Assignment.)
net.Receive("MultiServer.CloseLoadingScreen", function()
    Loading:CloseMenu()
end)

-- Change a player to a different server.
function MultiServer:OpenAdminChangeServerMenu(target)
    if not LocalPlayer():IsAtLeast(MultiServer.MinimumChangeServerRank) then
        return false
    end

    local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("multiserver.send"))

    -- Adds all available Servers to the list.
    local options = {}
    for id, server in pairs(Socket.GroupServers) do
        table.insert(options, {
            text = server.name,
            data = id
        })
    end

    table.SortByMember(options, "text")

    modal:Selection(egmt("multiserver.send_to"), egmt("multiserver.select"), options, function(id)
        net.Start("MultiServer.ChangeServer")
            net.WriteString(target:SteamID64())
            net.WriteInt(id, 32)
        net.SendToServer()
    end, nil, egmt("multiserver.send_short"))
end
--gamemodes/egmrp/gamemode/modules/experience/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Experience Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- The amount of exp a player receives per minute when not being afk. 0 or false to disable.
Experience.ExpPerMinute = 10

-- The amount of exp a player receives when killing an npc. 0 or false to disable.
Experience.ExpPerNPCKill = 15

-- The maximum possible level.
Experience.MaxLevel = 150

-- The amount of exp that is required to become a higher level.
Experience.ExpPerLevel = 100

-- The ExpPerLevel value is multiplied with this value ^ the next level to determine how many exp is required.
Experience.LevelExpMultiplier = 1.04

-- The amount of levels required to become a new skill point.
Experience.LevelPerSkillPoint = 10

-- The default key for opening the perk menu.
Experience.PerkMenuDefaultKey = KEY_P

-- The background image for the perks menu.
Experience.PerkMenuBackground = "backgrounds/du_citadel_core_meltdown.jpg"

-- The image used for unknown perks.
Experience.UnknownPerkImage = "materials/icons/experience/questionmark.png"

-- Every existing perk category and their perks. Note that the functionality for new perk categories need to be made with custom Lua.
Experience.Perks = {
    offensive = {
        name = egmt("experience.offensive"),
        image = "materials/icons/experience/offensive.png",
        imageCurrent = "materials/icons/experience/offensive_f.png",
        values = {
            [1] = {
                value = 1.05,
                name = egmt("experience.offensive1"),
                description = egmt("experience.offensive1_description")
            },
            [2] = {
                value = 1.10,
                name = egmt("experience.offensive2"),
                description = egmt("experience.offensive2_description")
            },
            [3] = {
                value = 1.15,
                name = egmt("experience.offensive3"),
                description = egmt("experience.offensive3_description")
            },
            [4] = {
                value = 1.20,
                name = egmt("experience.offensive4"),
                description = egmt("experience.offensive4_description")
            },
            [5] = {
                value = 1.25,
                name = egmt("experience.offensive5"),
                description = egmt("experience.offensive5_description")
            }
        }
    },
    health = {
        name = egmt("experience.life"),
        image = "materials/icons/experience/defensive.png",
        imageCurrent = "materials/icons/experience/defensive_f.png",
        values = {
            [1] = {
                value = 1.05,
                name = egmt("experience.life1"),
                description = egmt("experience.life1_description")
            },
            [2] = {
                value = 1.10,
                name = egmt("experience.life2"),
                description = egmt("experience.life2_description")
            },
            [3] = {
                value = 1.15,
                name = egmt("experience.life3"),
                description = egmt("experience.life3_description")
            },
            [4] = {
                value = 1.20,
                name = egmt("experience.life4"),
                description = egmt("experience.life4_description")
            },
            [5] = {
                value = 1.25,
                name = egmt("experience.life5"),
                description = egmt("experience.life5_description")
            }
        }
    },
    movement = {
        name = egmt("experience.movement"),
        image = "materials/icons/experience/sprint.png",
        imageCurrent = "materials/icons/experience/sprint_f.png",
        values = {
            [1] = {
                value = 1.025,
                name = egmt("experience.movement1"),
                description = egmt("experience.movement1_description")
            },
            [2] = {
                value = 1.05,
                name = egmt("experience.movement2"),
                description = egmt("experience.movement2_description")
            },
            [3] = {
                value = 1.075,
                name = egmt("experience.movement3"),
                description = egmt("experience.movement3_description")
            },
            [4] = {
                value = 1.1,
                name = egmt("experience.movement4"),
                description = egmt("experience.movement4_description")
            },
            [5] = {
                value = 1.125,
                name = egmt("experience.movement5"),
                description = egmt("experience.movement5_description")
            }
        }
    }
}
--gamemodes/egmrp/gamemode/modules/experience/cl_experience.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Experience        --
---------------------------------------

Character:AddPropertyToList("level", egmt("experience.level"), egmt("experience.level_description"), "number")

-- Cache the needed exp, because the Experience:GetNeededExp function needs computing.
local expNeeded
local oldLevel

-- Draw the level hud.
hook.Add("HUDPaint", "Experience.ShowExperience", function()
    if hook.Run("HUDShouldDraw", "EGMRPExperience") == false then return end

    local char = LocalPlayer():GetCurrentCharacter()

    if not char then return end

    local level = char:GetLevel()
    local experience = char:GetExperience()

    if level ~= oldLevel then
        expNeeded = Experience:GetNeededExp(level)
        oldLevel = level
    end

    local progress = experience / expNeeded

    -- Initialize drawing.
    surface.SetDrawColor(UI.BackgroundColor)
    draw.NoTexture()

    -- Background.
    surface.DrawPoly({
        {x = math.floor(ScrW() * 0.12), y = math.floor(ScrH() * 0.97)},
        {x = 0, y = math.floor(ScrH() * 0.97)},
        {x = 0, y = math.floor(ScrH() * 0.94)},
        {x = math.floor(ScrW() * 0.12), y = math.floor(ScrH() * 0.94)},
    })

    surface.DrawPoly({
        {x = math.floor(ScrW() * 0.12 + ScrH() * 0.03), y = math.floor(ScrH() * 0.97)},
        {x = math.floor(ScrW() * 0.12), y = math.floor(ScrH() * 0.97)},
        {x = math.floor(ScrW() * 0.12), y = math.floor(ScrH() * 0.94)},
    })

    -- Progress bar.
    draw.RoundedBox(0, ScrW() * 0.01, ScrH() * 0.944, ScrW() * 0.1, ScrH() * 0.023, ColorAlpha(UI.BackgroundColor, 255))

    if char:IsMaxLevel() then
        draw.RoundedBox(0, ScrW() * 0.01, ScrH() * 0.944, ScrW() * 0.1, ScrH() * 0.023, GetColor("purple", 40))
    else
        draw.RoundedBox(0, ScrW() * 0.01, ScrH() * 0.944, ScrW() * 0.1 * progress, ScrH() * 0.023, GetColor("green", 40))
    end

    -- Level display.
    draw.SimpleText(egmt("experience.level") .. " " .. level, "EGMText8", ScrW() * 0.06, ScrH() * 0.9555, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end)
--gamemodes/egmrp/gamemode/modules/inventory_container/item_slots/container/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | Container Item Slot   --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 44

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_loadout/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Index | Inventory Loadout     --
---------------------------------------

if not RequireModules({"inventory_storage"}) then
	return false
end

InventoryLoadout = InventoryLoadout or {}

if SERVER then
	AddCSLuaFile("sh_inventory_loadout.lua")
	AddCSLuaFile("cl_inventory_loadout.lua")

	include("sh_inventory_loadout.lua")
	include("sv_inventory_loadout.lua")

	include("sv_net.lua")
end

if CLIENT then
	include("sh_inventory_loadout.lua")
	include("cl_inventory_loadout.lua")
end
--gamemodes/egmrp/gamemode/modules/afk/sh_afk.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           AFK | Shared            --
---------------------------------------

local Player = FindMetaTable("Player")

-- Returns whether a player is afk.
--
-- @return Boolean afk
function Player:IsAFK()
    return self.afk or false
end
--gamemodes/egmrp/gamemode/modules/afk/cl_afk.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           AFK | Client            --
---------------------------------------

-- Update afk-status on client-side
net.Receive("AFK.UpdateStatus", function(len)
    LocalPlayer().afk = net.ReadBool()
end)
--gamemodes/starwarsrp/gamemode/modules/helmet/item_classes/helmet/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Helmet Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "bonemerge"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"head",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 3

-- Helper boolean to check if the item is an helmet or not.
ITEM_CLASS.IsHelmet = true

-- Hide from utility supply.
ITEM_CLASS.SkipUtilitySupply = true



---------------------------------------
--           Util Functions          --
---------------------------------------

-- Gets the current helmet of the character.
--
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function Inventory:GetCurrentHelmet(char, inventory)
	return InventoryBoneMerge:GetCurrentItem("Helmet", char, inventory)
end
--gamemodes/starwarsrp/gamemode/modules/helmet/item_classes/helmet/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Helmet Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Helm"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "hideHead", "requiredArmor"}



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override Camera Position for the model icon.
hook.Add("EGMModelIcon.OverrideDisplay", "Helmet.OverrideCamPos", function(displayType, modelPanel, ent)
	if displayType ~= "Helmet" then return end

	local bodyBone = ent:LookupBone("ValveBiped.Bip01_Head1")
	if bodyBone then
		local bodyPos = ent:GetBonePosition(bodyBone)

		modelPanel:SetLookAt(bodyPos + Vector(   0, 0, 4))
		modelPanel:SetCamPos(bodyPos + Vector(200, 0, 4))

		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/helmet/item_slots/head/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Head Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = "Kopf"

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/starwarsrp/gamemode/modules/armorweapon/item_classes/armorweapon/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Armor Weapon       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "armor"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"body",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 1

-- Skip weapon finding for this item.
ITEM_CLASS.SkipWeaponFind = true
--gamemodes/egmrp/gamemode/modules/donator/sh_donator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Donator System      --
---------------------------------------

local Player = FindMetaTable("Player")

PlayerData:AddProperty("donatorData", "table", {}, function(playerData, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return true
end)

-- Get the DonatorData of the Player.
function PlayerData.Meta:GetDonatorData()
	return self:GetProperty("donatorData", {})
end

-- Checks, whether the player has a specific donator type.
--
-- @param? String name
-- @return Boolean hasDonatorType
function PlayerData.Meta:HasDonatorType(name)
	name = name or "donator"

	local donatorData = self:GetDonatorData()
	if table.HasValue(donatorData, name) then
		return true
	end

	return false
end

-- Checks whether player is a donator or has a specific donator type.
--
-- @param? String name
-- @return Boolean isDonator
function Player:IsDonator(name)
	local playerData = self:GetData()
	if not playerData then
		return false
	end

	return playerData:HasDonatorType(name)
end

-- Add a hidden property, that is used, to easily query, what steamid's have join privilidges.
PlayerData:AddProperty("donatorRSlot", "boolean", false, function(playerData, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return false
end)

-- Limit access to donator data.
hook.Add("PlayerData.CanPlayerEditProperty.donatorData", "PlayerData.EditDonatorPermissions", function(ply, playerData, value)
	if ply:IsAtLeast(Donator.MinAccessGroup) then
		return true
	end
end)



---------------------------------------
--           Donator Types           --
---------------------------------------

-- Registers a type of Donator.
--
-- @param String name
-- @param String displayName
-- @param? Boolean reserveSlot
-- @param? Color scoreboardColor
-- @param? Color chatColor
-- @param? String chatTag
function Donator:Register(name, displayName, reserveSlot, scoreboardColor, chatColor, chatTag)
	self.Types = self.Types or {}

	self.Types[name] = {
		Name = displayName,
		ReserveSlot = reserveSlot,
		ScoreboardColor = scoreboardColor,
		ChatColor = chatColor,
		ChatTag = chatTag,
	}
end

-- Register the default Donator Type.
hook.Add("EGMRP.Loaded", "Donator.LoadDonatorRank", function()
	Donator:Register("donator", Donator.Name, true, UI.ForegroundColor)
end)



---------------------------------------
--           Util Function           --
---------------------------------------

-- Get a list of all donator rank colors for the scoreboard.
--
-- @return Table scoreboardColors
function Player:GetScoreboardDonatorColors() -- TODO: Implement All Uses through hook
	local playerData = self:GetData()
	if not playerData then return {} end

	local scoreboardColor = {}

	local donatorData = playerData:GetDonatorData()
	for _, name in pairs(donatorData) do
		local donatorType = Donator.Types[name]
		if donatorType and donatorType.ScoreboardColor then
			table.insert(scoreboardColor, donatorType.ScoreboardColor)
		end
	end

	return scoreboardColor
end

-- Get a list of all donator rank suffixes for the chat.
--
-- @return Table chatSuffixes
function Player:GetDonatorChatSuffixes() -- TODO: Implement All Uses through hook
	local playerData = self:GetData()
	if playerData then return {} end

	local chatSuffixes = {}

	local donatorData = playerData:GetDonatorData()
	for _, name in pairs(donatorData) do
		local donatorType = Donator.Types[name]
		if donatorType and donatorType.ChatColor then
			table.insert(chatSuffixes, {
				Color = donatorType.ChatColor,
				Text = "[" .. (donatorType.ChatTag or donatorType.Name) .. "]"
			})
		end
	end

	return chatSuffixes
end
--gamemodes/egmrp/gamemode/modules/donator/cl_donator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Donator System      --
---------------------------------------

-- TODO: Add Multi-Mention Support to the table UI (Maybe a "multitable")

-- Make the donatorData editable in a property list.
PlayerData:AddPropertyToList("donatorData", egmt("donator.ranks"), egmt("donator.ranks_description"), "table", function()
    local values = {
        validValues = {},
    }

    for name, donatorType in pairs(Donator.Types) do
        values.validValues[name] = donatorType.Name or name
    end

    return values
end)

--gamemodes/starwarsrp/gamemode/modules/extendeddonator/sh_extendeddonator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Extended Donator     --
---------------------------------------

Donator:Register("customChar", "CC & VIP Lifetime (Legacy)", true, GetColor("yellow"))

Donator:Register("vip", "VIP", true, GetColor("blue"))

Donator:Register("jedi", "Jedi", false, false)
Donator:Register("ccMain", "CC Hauptcharacter", false)
Donator:Register("ccSide", "CC Nebencharacter", false)

Donator:Register("nonlore", "Nonlore Commander", false)
Donator:Register("mainChar", "3. Hauptcharacter", false)
--gamemodes/egmrp/gamemode/modules/ammosystem/cl_ammosystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        AmmoSystem | Client        --
---------------------------------------

-- Opens the ammo system menu.
function AmmoSystem:OpenMenu()
    self:CloseMenu()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.MenuBackground)
    self.Frame:SetSubTitle(egmt("ammosystem.equipment"))

    self.AmmoList = vgui.Create("EGMScrollPanel", self.Frame)
    self.AmmoList:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.AmmoList:SetSize(ScrW() * 0.39, ScrH() * 0.7)
    self.AmmoList.AmmoTypes = {}

    for ammo, ammoProperties in pairs(AmmoSystem.AmmoTypes) do
        local sortFrame = vgui.Create("DPanel", self.AmmoList)
        sortFrame:Dock(TOP)
        sortFrame:SetHeight(ScrH() * 0.06)

        local ammoCounterLabel = vgui.Create("DLabel", sortFrame)
        ammoCounterLabel:SetHeight(ScrH() * 0.05)
        ammoCounterLabel:Dock(LEFT)
        ammoCounterLabel:SetFont("EGMText12")
        ammoCounterLabel:SetText(ammoProperties.name)
        ammoCounterLabel:SetTextColor(GetColor("white"))
        ammoCounterLabel:SetContentAlignment(4)
        ammoCounterLabel:SizeToContents()
        ammoCounterLabel:DockMargin(5, 0, 0, 0)

        if Realism.EnableAmmoWeight then
            local ammoWeightLabel = vgui.Create("DLabel", sortFrame)
            ammoWeightLabel:SetHeight(ScrH() * 0.05)
            ammoWeightLabel:Dock(RIGHT)
            ammoWeightLabel:SetFont("EGMText12")
            ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. tostring(ammoProperties.weight * tonumber(LocalPlayer():GetAmmoCount(ammo))))
            ammoWeightLabel:SetTextColor(GetColor("white"))
            ammoWeightLabel:SetContentAlignment(6)
            ammoWeightLabel:SizeToContents()
            ammoWeightLabel:DockMargin(0, 0, 5, 0)
        end
        local ammoCounter = vgui.Create("DNumSlider", self.AmmoList)
        ammoCounter:SetHeight(ScrH() * 0.05)
        ammoCounter:DockMargin(ScrW() * -0.2 ,5 ,0 ,5)
        ammoCounter:Dock(TOP)
        ammoCounter:SetMin(0)
        ammoCounter:SetMax(ammoProperties.limit)
        ammoCounter:SetValue(tostring(LocalPlayer():GetAmmoCount(ammo)))
        ammoCounter:SetDecimals(0)

        ammoCounter.Paint = function(panel, width, height)
            draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
        end
        if Realism.EnableAmmoWeight then
            ammoCounter.OnChange = function()
                if ammoCounter:GetValue() and tonumber(ammoCounter:GetValue()) then
                    ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. ammoProperties.weight * tonumber(ammoCounter:GetValue()))
                    ammoWeightLabel:SizeToContents()
                else
                    ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. ammoProperties.weight)
                    ammoWeightLabel:SizeToContents()
                end
            end
        end
        ammoCounter.AllowInput = function(panel, stringValue)
            if not isnumber(tonumber(stringValue)) or (tonumber(ammoCounter:GetValue()) and tonumber(tostring(ammoCounter:GetValue()) .. tostring(stringValue)) > ammoProperties.limit) then
                return true
            else
                return false
            end
        end

        local ammoCounterTable = {ammoCounter, ammo}
        table.insert(self.AmmoList.AmmoTypes, ammoCounterTable)
    end

    if Realism.EnableAmmoWeight then
        self.currentWeightPanel = vgui.Create("DPanel", self.Frame)
        self.currentWeightPanel:SetPos(ScrW() * 0.51, ScrH() * 0.25)
        self.currentWeightPanel:SetSize(ScrW() * 0.39, ScrH() * 0.13)

        self.currentWeightText = vgui.Create("DLabel", self.currentWeightPanel)
        self.currentWeightText:Dock(TOP)
        self.currentWeightText:SetFont("EGMText12")
        self.currentWeightText:SetText(egmt("ammosystem.weight_maxweight"))
        self.currentWeightText:SetContentAlignment(5)
        self.currentWeightText:SizeToContents()

        self.currentWeightIndicator = vgui.Create("DLabel", self.currentWeightPanel)
        self.currentWeightIndicator:Dock(TOP)
        self.currentWeightIndicator:SetFont("EGMText12")
        self.currentWeightIndicator:SetText(tostring((LocalPlayer():GetNWInt("Realism.currentWeight", 0) + LocalPlayer():GetNWInt("Realism.ammoWeight", 0)) .. " / " .. LocalPlayer():GetNWInt("Realism.maxWeight", 0)))
        self.currentWeightIndicator:SetContentAlignment(5)
        self.currentWeightIndicator:SizeToContents()
    end

    self.Confirm = vgui.Create("EGMButton", self.Frame)
    self.Confirm:SetPos(ScrW() * 0.4, ScrH() * 0.9)
    self.Confirm:SetSize(ScrW() * 0.2, ScrH() * 0.05)
    self.Confirm:SetFont("EGMText12")
    self.Confirm:SetTextColor(UI.TextColor)
    self.Confirm:SetText(egmt("shared.apply"))
    self.Confirm:SetButtonColor(GetColor("green"))
    self.Confirm:SetButtonCornerRadius(5)
    function self.Confirm:DoClick()
        local sendTable = {}

        for k,v in pairs(AmmoSystem.AmmoList.AmmoTypes) do
            table.insert(sendTable, {math.floor(v[1]:GetValue()), v[2]})
        end

        net.Start("AmmoSystem.ChangeLoadout")
            net.WriteTable(sendTable)
        net.SendToServer()

        AmmoSystem:CloseMenu()
    end

    self.Frame:MakePopup()
end

-- Closes the ammo system menu.
function AmmoSystem:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

-- Menu is opened when this net message is received.
net.Receive("AmmoSystem.OpenMenu", function()
    AmmoSystem:OpenMenu()
end)
--gamemodes/starwarsrp/gamemode/modules/garage/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Config | Garage          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

-- Garage Model
Garage.Model = "models/niksacokica/vendor/vendor_bounty_terminals_pickup.mdl"

-- Background Image
Garage.Background = "materials/wallpaper/wallpaper2you_534531.jpg"

-- Maximum Distance between Vehicle and Garage, to allow storing.
Garage.MaxStoreDistance = 1500
--gamemodes/starwarsrp/gamemode/modules/streamer/sh_streamer.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Streamer Module          --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Streamer Module | Shared     --
---------------------------------------

-- Add streamer player properties.
PlayerData:AddProperty("streamer", "boolean", false, function(playerData, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return true
end)

-- Add streamer url property
PlayerData:AddProperty("streamerurl", "string", "", function(playerData, value)
	if not isstring(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(playerData, ply)
	return true
end)


local Player = FindMetaTable("Player")

-- Verifies that the player is a streamer
function Player:IsStreamer()
	local playerData = self:GetData()

	if playerData then
		return playerData:GetProperty("streamer", false)
	end

	return false
end

-- Hook Part
--

-- Allows test moderators to edit the streaming state
hook.Add("PlayerData.CanPlayerEditProperty.streamer", "PlayerData.EditStreamerPerms", function(ply, playerData, value)
	if ply:IsTeamMember() then
		return true
	end
end)

-- Allows test moderators to edit the streaming url
hook.Add("PlayerData.CanPlayerEditProperty.streamerurl", "PlayerData.EditStreamerUrlPerms", function(ply, playerData, value)
	if ply:IsTeamMember() then
		return true
	end
end)

-- Overrides group name in scoreboard and chat
hook.Add("Player.OverrideUserGroupName", "Streamer.OverrideGroupName", function(ply)
	if not Streamer.Config.EnablePrefix then return end

	if ply:IsStreamer() then
		if ply:IsTeamMember() then
			local data = PlayerConfig.UserGroupData[ply:GetUserGroup()]

			if data and isstring(data.name) then
				return "Streamer | " .. data.name
			end
		else
			return "Streamer"
		end
	end
end)

-- Overrides group color in scoreboard and chat
hook.Add("Player.OverrideUserGroupColor", "Streamer.OverrideGroupColor", function(ply)
	if not Streamer.Config.EnablePrefix then return end
	if ply:IsTeamMember() then return end

	if ply:IsStreamer() then
		return Streamer.Config.Color
	end
end)

-- Displays the streamer's tag in chat
hook.Add("Player.UserGroupVisible", "Streamer.ChatSuffix", function(ply)
	if not Streamer.Config.EnablePrefix then return end

	if ply:IsStreamer() then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory_weight/sh_inventory_weight.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Inventory Weight     --
---------------------------------------

-- Add rank property: maxWeight
Rank:AddProperty("maxWeight", "number", InventoryWeight.DefaultWeightLimit, function(rank, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the max weight of a rank.
--
-- @return Number maxWeight
function Rank.Meta:GetMaxWeight()
	return self:GetProperty("maxWeight", InventoryWeight.DefaultWeightLimit)
end

-- Add Equiment property: weightBonus
Equipment:AddProperty("weightBonus", "number", 0, function(equipment, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Get the weight bonus of an equipment.
--
-- @return Number weightBonus
function Equipment.Meta:GetWeightBonus()
	return self:GetProperty("weightBonus", 0)
end

-- Get the weight of the inventory.
--
-- @return Number weight
function Character.Meta:GetInventoryWeight()
	local inventory = self:GetInventory()

	local weight = 0
	for slotId, slotItemData in pairs(inventory) do
		for subId, itemData in pairs(slotItemData) do
			local success, _, itemType = Inventory:GetItemClass(itemData)
			if not success then
				continue
			end

			weight = weight + itemType:GetWeight()
		end
	end

	-- Allow other modules to add additional weight.
	local weightTable = {weight}
	hook.Run("Inventory.AddWeight", self, weightTable)

	return weightTable[1]
end

-- Get the max weight of a character.
--
-- @return Number maxWeight
function Character.Meta:GetMaxWeight()
	local rank = self:GetRank()
	if not rank then
		return 0
	end

	-- Get base max weight from rank.
	local maxWeight = rank:GetMaxWeight()

	-- Apply stat modifiers from the equipment.
	local relevantEquipment = self:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		maxWeight = maxWeight + equip:GetWeightBonus()
	end

	local weightData = {maxWeight}
	hook.Run("Inventory.GetMaxWeight", self, weightData)

	-- TODO: Add to Skill System later

	return weightData[1]
end

-- Add item type property: weight
ItemType:AddProperty("weight", "number", 1, function(itemType, value)
	if not isnumber(value) or value < 0 then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the weight of the item type.
--
-- @return Number weight
function ItemType.Meta:GetWeight()
	return self:GetProperty("weight", 1)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Change movement speed based on inventory weight.
hook.Add("Character.GetMovement", "Inventory.ApplyInventoryWeight", function(character, movement)
	local weight = character:GetInventoryWeight()
	local maxWeight = character:GetMaxWeight()
	local percentage = weight / maxWeight

	local minSpeed = InventoryWeight.MinimumSpeed

	-- If the weight is above 125%, the player will not be able to move.
	if percentage > 1.25 then
		movement[1] = minSpeed

		return
	end

	-- If the weight is above 100%, the player will be slowed down.
	if percentage > 1 then
		-- Percentage is between 100% and 125% (1 and 1.25)
		-- I want the speed to go down from 100% to 50 absolute speed.

		-- Calculate the speed difference between 100% and 125%.
		local speedDifference = movement[1] - minSpeed

		-- Calculate the speed difference between the current percentage and 100%.
		local currentSpeedDifference = speedDifference * (percentage - 1) * 4

		-- Calculate the new speed.
		movement[1] = movement[1] - currentSpeedDifference
	end
end)

-- Add the weight of a carried corpse to the inventory weight.
hook.Add("Inventory.AddWeight", "Inventory.AddCorpseWeight", function(character, weightTable)
	if not character:IsCurrentCharacter() then return end

	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if not ply:GetNWBool("Unarmed.CarryingRagdoll") then return end

	-- Since we cannot easily get the weight of the ragdoll and it's inventory, we will just add a fixed weight.
	weightTable[1] = weightTable[1] + InventoryWeight.CorpseWeight
end)
--gamemodes/egmrp/gamemode/modules/special_character/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Index | Special Character     --
---------------------------------------

SpecialCharacter = SpecialCharacter or table.Copy(PropertyModel)

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_special_character.lua")
	AddCSLuaFile("cl_special_character.lua")

	AddCSLuaFile("cl_manager.lua")

	include("sh_config.lua")
	include("sh_special_character.lua")
	include("sv_special_character.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_special_character.lua")
	include("cl_special_character.lua")

	include("cl_manager.lua")
end
--gamemodes/egmrp/gamemode/modules/compass/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Compass | Config         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- List of all maps where there are no Magnetic directions. (Spaceships, etc..)
Compass.NoCompassMaps = {
    "rp_venator_extensive"
}
--gamemodes/egmrp/gamemode/modules/inventory_shop/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | Inventory Shop      --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Fallback model for the storage entity.
InventoryShop.Model = "models/props_c17/display_cooler01a.mdl"

-- Minimum user groups that is allowed, to edit shop entries.
ShopEntry.MinAccessGroup = "superadmin"
--gamemodes/egmrp/gamemode/modules/inventory_shop/cl_inventory_shop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Inventory Shop      --
---------------------------------------

-- Closes the shop menu.
function InventoryShop:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Open the shop menu.
function InventoryShop:Open(char, ent)
	local _self = self

	self.Frame = vgui.Create("EGMSmallFrame")
	self.Frame:SetCustomTitle(egmt("inventory_shop.title"))

	local oldX, oldY = self.Frame:GetPos()
	self.Frame:SetPos(oldX - ScrW() * 0.2, oldY)

	local oldW, oldH = self.Frame:GetSize()
	self.Frame:SetSize(oldW + ScrW() * 0.4, oldH)

	local cButPosX, cButPosY = self.Frame.CloseButton:GetPos()
	self.Frame.CloseButton:SetPos(cButPosX + ScrW() * 0.4, cButPosY)

	self:CreateShopPanel(char, ent)
	self:CreateBillingPanel(char, ent)

	self:ApplyBillingPanelMoney(char)

	hook.Run("InventoryShop.Open", self)

	self.Frame:MakePopup()
end

-- Create the shop panel.
--
-- @param Character char
-- @param Entity ent
function InventoryShop:CreateShopPanel(char, ent)
	local _self = self

	local shopPanel = vgui.Create("DPanel", self.Frame)
	shopPanel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	shopPanel:Dock(FILL)
	function shopPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end

	-- Create a search bar for the entry list.
	local searchBar = vgui.Create("DTextEntry", shopPanel)
	searchBar:Dock(BOTTOM)
	searchBar:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	searchBar:SetHeight(ScrH() * 0.03)
	searchBar:SetPlaceholderText(egmt("manager.search"))
	searchBar:SetFont("EGMText8")

	function searchBar:OnValueChange(value)
		_self:ApplyShopPanel(_self.StockData)
	end

	local shopList = vgui.Create("EGMScrollPanel", shopPanel)
	shopList:Dock(FILL)

	self.ShopPanel = shopPanel

	self.SearchBar = searchBar
	self.ShopList = shopList

	-- Request the shop stock from the server.
	net.Start("InventoryShop.Stock")
		net.WriteEntity(ent)
	net.SendToServer()
end

-- Should the item be displayed in the shop panel?
--
-- @param ShopEntry shopEntry
-- @param String category
-- @param String filter
-- @return Boolean shouldDisplay
function InventoryShop:ShouldDisplayShopEntry(shopEntry, category, filter)
	if shopEntry:GetCategory() ~= category then
		return false
	end

	-- Check if the filter is empty.
	if filter == "" then
		return true
	end

	filter = filter:lower()

	-- Filter by category first.
	local entryCategory = shopEntry:GetCategory():lower()
	if string.find(entryCategory, filter) then
		return true
	end

	-- Filter by name.
	local entryName = shopEntry:GetName():lower()
	if string.find(entryName, filter, 1, true) then
		return true
	end

	return false
end

-- Add the shop entries of a given category to the shop panel.
--
-- @param Table stockData
-- @param String category
-- @param? String filter
function InventoryShop:AddCategoryPanels(stockData, category, filter)
	local _self = self

	local shopPanel = self.ShopList

	local n = 6
	local cellWidth = (shopPanel:GetWide() - shopPanel:GetVBar():GetWide()) / n

	local x = 0
	local currentRow
	for _, shopEntryData in pairs(stockData) do
		local shopEntryId = shopEntryData.Id
		local shopEntry = ShopEntry:GetCached(shopEntryId)
		if not istable(shopEntry) then continue end

		if not self:ShouldDisplayShopEntry(shopEntry, category, filter) then continue end

		local price = shopEntryData.Price
		local stock = shopEntryData.Stock
		if stock <= 0 then continue end

		local maxStock = shopEntry:GetMaxStock() or 0

		local shopClass = shopEntry:GetShopClass()
		if not istable(shopClass) then continue end

		if x == 0 then
			local row = vgui.Create("DPanel", shopPanel)
			row:SetHeight(cellWidth)
			row:Dock(TOP)
			function row:Paint(ww, hh)
			end

			row.Cells = {}

			currentRow = row
			table.insert(shopPanel.ShopEntries, row)
		end

		local cell = vgui.Create("DPanel", currentRow)
		cell:SetWidth(cellWidth)
		cell:Dock(LEFT)
		function cell:Paint(ww, hh)
			draw.RoundedBox(0, 4, 4, ww - 4, hh - 4, Color(0, 0, 0, 255))
		end

		local shopEntryPanel = vgui.Create("DPanel", cell)
		shopEntryPanel:DockMargin(4, 4, 4, 4)
		shopEntryPanel:Dock(FILL)
		shopEntryPanel:SetMouseInputEnabled(false)
		cell.ShopEntryPanel = shopEntryPanel

		local name = shopEntry:GetName()
		cell.Name = name

		function cell:PaintOver(ww, hh)
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0,      ww, 4, UI.TextColor)
				draw.RoundedBox(0, 0, hh - 4, ww, 4, UI.TextColor)

				draw.RoundedBox(0, 0,      0, 4, hh, UI.TextColor)
				draw.RoundedBox(0, ww - 4, 0, 4, hh, UI.TextColor)
			end

			draw.SimpleText(self.Name, "EGMText6", ww * 0.5, 8, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			if price == 0 then
				draw.SimpleText(egmt("inventory_shop.free"), "EGMText6", 8, hh - 8, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
			else
				draw.SimpleText(egmt("inventory_shop.price_short", price), "EGMText6", 8, hh - 8, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
			end

			draw.SimpleText(stock .. " / " .. maxStock, "EGMText6", ww - 8, hh - 8, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)
		end
		function cell:OnMousePressed(keyCode)
			if keyCode ~= MOUSE_LEFT then return end

			_self:AddShopEntry(shopEntry, price, stock)
		end

		shopClass:CreateShopPanel(shopEntryPanel, shopEntry)

		table.insert(currentRow.Cells, cell)

		x = x + 1
		if x >= n then
			x = 0
		end
	end
end

-- Apply the stock to the shop panel.
--
-- @param Table stockData
function InventoryShop:ApplyShopPanel(stockData)
	local _self = self

	self.StockData = stockData

	local filter = self.SearchBar:GetText():lower()

	local shopPanel = self.ShopList

	-- Remove existing shop entries.
	for _, row in pairs(shopPanel.ShopEntries or {}) do
		row:Remove()

		for _, cell in pairs(row.Cells or {}) do
			cell:Remove()
		end
	end

	shopPanel.ShopEntries = {}

	-- Find all categories.
	local categories = {}

	for _, shopEntryData in pairs(stockData) do
		local shopEntryId = shopEntryData.Id
		local shopEntry = ShopEntry:GetCached(shopEntryId)
		if not istable(shopEntry) then continue end

		local category = shopEntry:GetCategory()
		if not table.HasValue(categories, category) then
			table.insert(categories, category)
		end
	end

	-- Add the category panels.
	for _, category in pairs(categories) do
		local labelRow = vgui.Create("DPanel", shopPanel)
		labelRow:SetHeight(ScrH() * 0.03)
		labelRow:Dock(TOP)
		function labelRow:Paint(ww, hh)
			draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)

			draw.SimpleText(category, "EGMText8", ww * 0.5, hh * 0.5, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		table.insert(shopPanel.ShopEntries, labelRow)

		local n = table.Count(shopPanel.ShopEntries)
		self:AddCategoryPanels(stockData, category, filter)

		if table.Count(shopPanel.ShopEntries) == n then
			labelRow:Remove()

			table.RemoveByValue(shopPanel.ShopEntries, labelRow)
		end
	end
end

-- Create the billing panel.
--
-- @param Character char
-- @param Entity ent
function InventoryShop:CreateBillingPanel(char, ent)
	local _self = self

	local billingPanel = vgui.Create("DPanel", self.Frame)
	billingPanel:SetWide(ScrW() * 0.15)
	billingPanel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	billingPanel:Dock(RIGHT)
	function billingPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end

	billingPanel.Money = 0
	billingPanel.StorageMoney = 0

	local billingLabel = vgui.Create("DLabel", billingPanel)
	billingLabel:SetHeight(ScrH() * 0.03)
	billingLabel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	billingLabel:Dock(TOP)
	billingLabel:SetFont("EGMText8")
	billingLabel:SetText(egmt("inventory_shop.billing"))
	billingLabel:SetContentAlignment(5)
	billingLabel:SetTextColor(UI.ForegroundColor)

	local scrollPanel = vgui.Create("EGMScrollPanel", billingPanel)
	scrollPanel:DockMargin(ScrW() * 0.005, 0, ScrW() * 0.005, ScrH() * 0.005)
	scrollPanel:Dock(FILL)

	scrollPanel.BillingData = {}
	scrollPanel.Entries = {}
	scrollPanel.Total = 0

	local buyButton = vgui.Create("EGMButton", billingPanel)
	buyButton:SetHeight(ScrH() * 0.03)
	buyButton:DockMargin(ScrW() * 0.005, 0, ScrW() * 0.005, ScrH() * 0.005)
	buyButton:Dock(BOTTOM)
	buyButton:SetText(egmt("inventory_shop.buy"))
	buyButton:SetFont("EGMText8")

	function buyButton:DoClick()
		local billingData = scrollPanel.BillingData
		if #billingData == 0 then return end

		local compressedData = CompressTable(billingData)

		net.Start("InventoryShop.Billing")
			net.WriteEntity(ent)

			net.WriteInt(#compressedData, 32)
			net.WriteData(compressedData, #compressedData)
		net.SendToServer()

		_self:Close()
	end

	local moneyPanel = vgui.Create("DPanel", billingPanel)
	moneyPanel:SetHeight(ScrH() * 0.1)
	moneyPanel:DockMargin(ScrW() * 0.005, 0, ScrW() * 0.005, ScrH() * 0.005)
	moneyPanel:Dock(BOTTOM)
	function moneyPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)

		draw.SimpleText(egmt("inventory_shop.money"), "EGMText8", ww * 0.01, hh * 0.1, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(billingPanel.Money, "EGMText8", ww * 0.99, hh * 0.1, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

		draw.SimpleText(egmt("inventory_shop.storage_money"), "EGMText8", ww * 0.01, hh * 0.35, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(billingPanel.StorageMoney, "EGMText8", ww * 0.99, hh * 0.35, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

		-- Draw a line
		draw.RoundedBox(0, 0, hh * 0.5 - 1, ww, 2, UI.ForegroundColor)

		draw.SimpleText(egmt("inventory_shop.total"), "EGMText8", ww * 0.01, hh * 0.9, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(scrollPanel.Total, "EGMText8", ww * 0.99, hh * 0.9, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
	end

	billingPanel.BillingLabel = billingLabel
	billingPanel.ScrollPanel = scrollPanel
	billingPanel.BuyButton = buyButton
	billingPanel.MoneyPanel = moneyPanel

	self.BillingPanel = billingPanel
end

-- Update the total in the billing panel.
function InventoryShop:UpdateBillingPanelTotal()
	local billingPanel = self.BillingPanel
	if not IsValid(billingPanel) then return end

	local char = LocalPlayer():GetCurrentCharacter()
	if not char then return end

	local scrollPanel = billingPanel.ScrollPanel
	if not IsValid(scrollPanel) then return end

	local total = 0
	for _, billEntry in pairs(scrollPanel.BillingData) do
		local shopEntry = ShopEntry:GetCached(billEntry.Id)
		if not istable(shopEntry) then continue end

		local price = shopEntry:GetPrice(char:IsSeller())

		local count = billEntry.Count

		total = total + price * count
	end

	scrollPanel.Total = total
end

-- Add an shop entry to the billing panel.
--
-- @param ShopEntry shopEntry
-- @param? Integer price
-- @param? Integer stock
function InventoryShop:AddShopEntry(shopEntry, price, stock)
	local _self = self

	local billingPanel = self.BillingPanel
	if not IsValid(billingPanel) then return end

	local scrollPanel = billingPanel.ScrollPanel
	if not IsValid(scrollPanel) then return end

	-- Check, if the shop entry is already in the billing panel and just increase the count.
	for _, billEntry in pairs(scrollPanel.BillingData) do
		if billEntry.Id == shopEntry:GetId() then
			local count = billEntry.Count
			if count >= stock then return end

			billEntry.Count = count + 1
			self:UpdateBillingPanelTotal()

			return
		end
	end

	-- Add the shop entry to the billing panel.
	local billEntry = {
		Id = shopEntry:GetId(),
		Count = 1,
	}

	local entryPanel = vgui.Create("DPanel", scrollPanel)
	entryPanel:SetHeight(ScrH() * 0.05)
	entryPanel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	entryPanel:Dock(TOP)
	function entryPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)

		draw.SimpleText(shopEntry:GetName(), "EGMText6", ww * 0.01, hh * 0.25, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		local count = billEntry.Count
		draw.SimpleText(count, "EGMText6", ww * 0.01, hh * 0.75, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		local total = price * count
		if total == 0 then
			draw.SimpleText(egmt("inventory_shop.free"), "EGMText6", ww * 0.99, hh * 0.75, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText(total, "EGMText6", ww * 0.99, hh * 0.75, UI.ForegroundColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
	end

	local buttonPanel = vgui.Create("DPanel", entryPanel)
	buttonPanel:SetHeight(ScrH() * 0.025)
	buttonPanel:Dock(TOP)
	function buttonPanel:Paint(ww, hh)
	end

	local plusButton = vgui.Create("EGMButton", buttonPanel)
	plusButton:SetWidth(ScrH() * 0.02)
	plusButton:DockMargin(0, ScrH() * 0.0025, ScrW() * 0.001, ScrH() * 0.0025)
	plusButton:Dock(RIGHT)
	plusButton:SetText("►")
	plusButton:SetFont("EGMText10")
	function plusButton:DoClick()
		billEntry.Count = billEntry.Count + 1
		_self:UpdateBillingPanelTotal()
	end

	local minusButton = vgui.Create("EGMButton", buttonPanel)
	minusButton:SetWidth(ScrH() * 0.02)
	minusButton:DockMargin(0, ScrH() * 0.0025, ScrW() * 0.002, ScrH() * 0.0025)
	minusButton:Dock(RIGHT)
	minusButton:SetText("◄")
	minusButton:SetFont("EGMText10")
	minusButton:SetButtonColor(UI.DangerColor)
	function minusButton:DoClick()
		_self:RemoveShopEntry(shopEntry)
	end

	table.insert(scrollPanel.Entries, entryPanel)

	table.insert(scrollPanel.BillingData, billEntry)
	self:UpdateBillingPanelTotal()
end

-- Remove an shop entry from the billing panel.
--
-- @param ShopEntry shopEntry
function InventoryShop:RemoveShopEntry(shopEntry)
	local _self = self

	local billingPanel = self.BillingPanel
	if not IsValid(billingPanel) then return end

	local scrollPanel = billingPanel.ScrollPanel
	if not IsValid(scrollPanel) then return end

	for i, billEntry in pairs(scrollPanel.BillingData) do
		if billEntry.Id == shopEntry:GetId() then
			local count = billEntry.Count
			if count <= 1 then
				table.remove(scrollPanel.BillingData, i)
				scrollPanel.Entries[i]:Remove()
				table.remove(scrollPanel.Entries, i)
			else
				billEntry.Count = count - 1
			end

			self:UpdateBillingPanelTotal()

			return
		end
	end
end

-- Apply the character money in the billing panel.
--
-- @param Character char
function InventoryShop:ApplyBillingPanelMoney(char)
	local billingPanel = self.BillingPanel

	billingPanel.Money = char:GetMoney()
	billingPanel.StorageMoney = char:GetStorageMoney()
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Update the shop money preview, if the property changes.
hook.Add("Character.PropertyChanged", "InventoryShop.Update", function(char, key)
	if not IsValid(InventoryShop.Frame) then return end

	if char:GetOwner() ~= LocalPlayer() then return end
	if not char:IsCurrentCharacter() then return end

	if key == "inventory" then
		InventoryShop:ApplyBillingPanelMoney(char)
	end
end)

hook.Add("EscapeScreeen.Override", "InventoryShop.CloseOnEscape", function()
	if IsValid(InventoryShop.Frame) then
		InventoryShop:Close()

		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory_shop/sh_shop_entry.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Shop Entry        --
---------------------------------------

-- Set sharedside property variables.
ShopEntry.Name = "ShopEntry"

-- Initialize networking.
ShopEntry:InitCreationNetworking()
ShopEntry:InitEditNetworking()
ShopEntry:InitDeletionNetworking()

-- Used to get the name of the shop entry.
-- Dynamically generated from the the content.
--
-- @return String name
function ShopEntry.Meta:GetName()
	local shopClass = self:GetShopClass()
	if not istable(shopClass) then return "???" end

	return shopClass:GetShopEntryName(self)
end

-- Add shop entry property: category
ShopEntry:AddProperty("category", "string", "", function(shopEntry, value)
	if not isstring(value) then
		return false, egmt("inventory_shop.invalid_category")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the category of the shop entry.
--
-- @return String category
function ShopEntry.Meta:GetCategory()
	return self:GetProperty("category", "")
end

-- Add shop entry property: shopClass
ShopEntry:AddProperty("shopClass", "string", "base", function(shopEntry, value)
	if not isstring(value) then
		return false, egmt("inventory_shop.invalid_shop_class")
	end

	local shopClass = InventoryShop:GetShopClassFromName(value)
	if not shopClass then
		return false, egmt("inventory_shop.invalid_shop_class")
	end

	-- Allow other modules to validate the shop entry.
	local override, err = hook.Run("ShopEntry.ValidateShopClass", shopEntry, value, shopClass)
	if isbool(override) then
		return override, err
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the shop class of the shop entry.
--
-- @return ShopClass shopClass
function ShopEntry.Meta:GetShopClass()
	return InventoryShop:GetShopClassFromName(self:GetProperty("shopClass", ""))
end

-- Add shop entry property: price
ShopEntry:AddProperty("price", "number", 1000, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_price")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_price")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the price of the shop entry.
--
-- @param Boolean isSeller
-- @return Number price
function ShopEntry.Meta:GetPrice(isSeller)
	local price = self:GetProperty("price", 1000)

	if isSeller then
		price = self:GetSellerPrice()
	end

	local priceTable = {price}
	hook.Run("ShopEntry.GetPrice", self, priceTable, isSeller)

	return priceTable[1]
end

-- Add shop entry property: maxStock
ShopEntry:AddProperty("maxStock", "number", 0, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_max_stock")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_max_stock")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the max stock of the shop entry.
--
-- @return Number maxStock
function ShopEntry.Meta:GetMaxStock()
	return self:GetProperty("maxStock", 0)
end

-- Add shop entry property: stock
ShopEntry:AddProperty("stock", "number", 0, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_stock")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_stock")
	end

	return true
end,
function(shopEntry, ply)
	return false -- Do not network.
end)

-- Returns the stock of the shop entry.
--
-- @return Number stock
function ShopEntry.Meta:GetStock()
	return self:GetProperty("stock", 0)
end

-- Add shop entry property: stockRegen
ShopEntry:AddProperty("stockRegen", "number", 0, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_stock_regen")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_stock_regen")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the stock regen of the shop entry.
--
-- @return Number stockRegen
function ShopEntry.Meta:GetStockRegen()
	return self:GetProperty("stockRegen", 0)
end

-- Add shop entry property: lastRegen
ShopEntry:AddProperty("lastRegen", "number", 0, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_last_regen")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_last_regen")
	end

	return true
end,
function(shopEntry, ply)
	return false -- Do not network.
end)

-- Returns the last regen of the shop entry.
--
-- @return Number lastRegen
function ShopEntry.Meta:GetLastRegen()
	return self:GetProperty("lastRegen", 0)
end

-- Limit access to the edit functions.
hook.Add("ShopEntry.CanPlayerEditProperties", "ShopEntry.EditPropertiesPermissions", function(ply, shopEntry, properties)
	return ply:IsAtLeast(ShopEntry.MinAccessGroup)
end)

hook.Add("ShopEntry.CanPlayerCreate", "ShopEntry.CreatePermissions", function(ply, data, properties)
	return ply:IsAtLeast(ShopEntry.MinAccessGroup)
end)

hook.Add("ShopEntry.CanPlayerDelete", "ShopEntry.DeletePermissions", function(ply, character)
	return ply:IsAtLeast(ShopEntry.MinAccessGroup)
end)



---------------------------------------
--       Filtered Shop Entries       --
---------------------------------------

-- Add shop entry property: sellerOnly
ShopEntry:AddProperty("sellerOnly", "boolean", false, function(shopEntry, value)
	if not isbool(value) then
		return false, egmt("inventory_shop.invalid_seller_only")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns if the shop entry is seller only.
--
-- @return Boolean sellerOnly
function ShopEntry.Meta:IsSellerOnly()
	return self:GetProperty("sellerOnly", false)
end

-- Add shop entry property: sellerPrice
ShopEntry:AddProperty("sellerPrice", "number", 500, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_seller_price")
	end

	if value < 0 then
		return false, egmt("inventory_shop.invalid_seller_price")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the seller price of the shop entry.
--
-- @return Number sellerPrice
function ShopEntry.Meta:GetSellerPrice()
	return self:GetProperty("sellerPrice", 500)
end

-- Add rank property: seller
Rank:AddProperty("seller", "boolean", false, function(rank, value)
	if not isbool(value) then
		return false, egmt("inventory_shop.invalid_seller")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Returns if the rank is a seller.
--
-- @return Boolean seller
function Rank.Meta:IsSeller()
	return self:GetProperty("seller", false)
end

-- Returns, if the character is a seller.
--
-- @return Boolean seller
function Character.Meta:IsSeller()
	local override = hook.Run("Character.IsSeller", self)
	if isbool(override) then
		return override
	end

	local rank = self:GetRank()
	if not rank then return false end

	return rank:IsSeller()
end

-- Add shop entry property: shopEntries
Rank:AddProperty("shopEntries", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("inventory_shop.invalid_shop_entries")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Returns the shop entries of the rank.
--
-- @return Table shopEntries
function Rank.Meta:GetShopEntries()
	return self:GetProperty("shopEntries", {})
end

-- Returns, if the rank has access to the shop entry.
--
-- @param ShopEntry shopEntry
-- @return Boolean hasAccess
function Rank.Meta:HasShopEntryAccess(shopEntry)
	-- Allow access if the shop entry is not seller only.
	if not shopEntry:IsSellerOnly() then
		return true
	end

	-- Prevent access if the rank is not a seller.
	if not self:IsSeller() then
		return false
	end

	-- Allow override, from other modules.
	local override = hook.Run("Rank.HasShopEntryAccess", self, shopEntry)
	if isbool(override) then
		return override
	end

	-- Allow access if the rank has access to the shop entry.
	local shopEntries = self:GetShopEntries()
	return table.HasValue(shopEntries, shopEntry:GetId())
end

-- Returns, if the character has access to the shop entry.
--
-- @param ShopEntry shopEntry
-- @return Boolean hasAccess
function Character.Meta:HasShopEntryAccess(shopEntry)
	local override = hook.Run("Character.HasShopEntryAccess", self, shopEntry)
	if isbool(override) then
		return override
	end

	local rank = self:GetRank()
	if not rank then return false end

	return rank:HasShopEntryAccess(shopEntry)
end



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- Add shop entry property: itemType
ShopEntry:AddProperty("itemType", "number", -1, function(shopEntry, value)
	if not isnumber(value) then
		return false, egmt("inventory_shop.invalid_item_type")
	end

	-- Allow no item class.
	if value == -1 then
		return true
	end

	local itemType = ItemType:GetCached(value)
	if not itemType then
		return false, egmt("inventory_shop.invalid_item_type")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the item type id of the shop entry.
--
-- @return Number itemTypeId
function ShopEntry.Meta:GetItemTypeId()
	return self:GetProperty("itemType", -1)
end

-- Returns the item type of the shop entry.
--
-- @return ItemType itemType
function ShopEntry.Meta:GetItemType()
	return ItemType:GetCached(self:GetItemTypeId())
end

-- Add shop entry property: itemVariant
ShopEntry:AddProperty("itemVariant", "string", "", function(shopEntry, value)
	if not isstring(value) then
		return false, egmt("inventory_shop.invalid_item_variant")
	end

	return true
end,
function(shopEntry, ply)
	return true
end)

-- Returns the item data of the shop entry.
--
-- @return String itemVariant
function ShopEntry.Meta:GetItemVariant()
	return self:GetProperty("itemVariant", "")
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/shop_classes/item/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Item Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Base Shop class, from which functions and such should be inherited.
SHOP_CLASS.BaseShopClass = "base"

-- Check, if a character can buy a given shop entry.
--
-- @param Character char
-- @param ShopEntry shopEntry
-- @return Boolean canBuy
-- @return? String error
function SHOP_CLASS:CanBuy(char, shopEntry)
	return true
end

-- Get the name of the shop entry.
--
-- @param ShopEntry shopEntry
-- @return String name
function SHOP_CLASS:GetShopEntryName(shopEntry)
	local itemType = shopEntry:GetItemType()
	if not itemType then return "???" end

	local itemClass = itemType:GetItemClass()
	if not itemClass then return "???" end

	local name = itemType:GetName()

	local itemVariant = shopEntry:GetItemVariant()
	if not isstring(itemVariant) then return name end

	if itemVariant == "" then
		return egmt("inventory_shop.name_random", name)
	end

	local variants = itemClass:GetVariants(itemType)
	if not istable(variants) then return name end

	local variantName = variants[itemVariant]
	if not isstring(variantName) then return name end

	return variantName
end
--gamemodes/starwarsrp/gamemode/modules/garage_shop/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Interact | Shop          --
---------------------------------------

hook.Add("EGMRP.Loaded", "Shop.Interact", function()
	Interact:RegisterOption(nil, "Schiff übertragen", 1, function()
		Interact.Menu:Remove()

		local vehicle = LocalPlayer():GetEyeTrace().Entity

		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle("Schiff übertragen")

		local options = {}
		for _, ply in pairs(player.GetHumans()) do
			if ply:SteamID64() == LocalPlayer():SteamID64() then continue end
			if ply:GetPos():Distance(LocalPlayer():GetPos()) <= 1000 then
				table.insert(options, {text = ply:GetCurrentCharacterFullName(), data = ply:SteamID64()})
			end
		end

		modal:Selection("Wähle den neuen Besitzer, auf den du das Fahrzeug übertragen willst.", "Wähle Besitzer", options, function(steamID64)
			net.Start("Shop.TransferVehicle")
				net.WriteEntity(vehicle)
				net.WriteString(steamID64)
			net.SendToServer()
		end, nil, "Besitzer Ändern")
	end, function()
		local vehicle = LocalPlayer():GetEyeTrace().Entity
		if IsValid(vehicle) then
			local vehicleOwner = vehicle:GetNWString("VehicleOwner", "")
			return isstring(vehicleOwner) and vehicleOwner == LocalPlayer():SteamID64()
		end
	end)
end)
--gamemodes/starwarsrp/gamemode/modules/stnotes/sh_stnotes.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | STNotes          --
---------------------------------------

-- Checks if you are allowed to open the stnotes.
hook.Add("STNotes.CanUse", "STNotes.OpenPermissions", function(ply)
	return ply:HasWeapon("weapon_swrp_pad_st")
end)

-- Add Character property: jailtime
Character:AddProperty("jailtime", "number", 0, nil, function(character, ply)
	return true
end)
--gamemodes/egmrp/gamemode/modules/inventory_faction/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Faction    --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Slot limit of different items in the faction inventory. (false is unlimited.)
InventoryFaction.SlotLimit = 30

-- Page Size of the faction inventory logs.
InventoryFaction.LogPageSize = 25
--gamemodes/egmrp/gamemode/modules/inventory_faction/sh_inventory_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Inventory Faction    --
---------------------------------------

-- Add faction property: storage
Faction:AddProperty("storage", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Add Faction property: hasFacSto
Faction:AddProperty("hasFacSto", "boolean", false, function(faction, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get all faction storages for a faction.
--
-- @return Table storages
function Faction.Meta:GetStorages()
	local storages = {}

	local parent = self:GetParent()
	if parent then
		storages = parent:GetStorages()
	end

	if self:GetProperty("hasFacSto") then
		storages[self:GetId()] = {
			Storage = self:GetProperty("storage", {}),
			Name = self:GetName(),
			Limit = self:GetFactionStorageLimit(),
			Faction = self,
		}
	end

	return storages
end

STORAGE_PERMISSION_ACCESS = "storage_access"
Rank:RegisterPermission(STORAGE_PERMISSION_ACCESS, egmt("inventory_faction.permission_access"))

STORAGE_PERMISSION_LOGS = "storage_logs"
Rank:RegisterPermission(STORAGE_PERMISSION_LOGS, egmt("inventory_faction.permission_logs"))

-- Get the faction storages for a character.
--
-- @return Table storages
function Character.Meta:GetFactionStorages()
	local storages = {}

	local rank = self:GetRank()
	if rank then
		local faction = self:GetFaction()
		if faction and rank:HasPermission(STORAGE_PERMISSION_ACCESS) then
			storages = faction:GetStorages()
		end

		-- Check for Logs access.
		for _, storageData in pairs(storages) do
			if rank:HasPermission(STORAGE_PERMISSION_LOGS) then
				storageData.LogsAccess = true
			end
		end
	end

	-- Hook, to add storages from other modules.
	hook.Run("Character.GetFactionStorages", self, storages)

	return storages
end

-- Gets the faction storage slot limit of a faction.
--
-- @return Number slotLimit
function Faction.Meta:GetFactionStorageLimit()
	local configLimit = InventoryFaction.SlotLimit
	if configLimit == false then
		configLimit = math.huge
	end

	local override = hook.Run("InventoryFaction.GetFactionStorageLimit", self, configLimit)
	if isnumber(override) then
		return override
	end

	if self and self:GetProperty("hasFacSto", false) then
		return configLimit
	end

	return 0
end
--gamemodes/egmrp/gamemode/modules/inventory_faction/cl_inventory_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Inventory Faction    --
---------------------------------------

-- Add properties to the property list.
Faction:AddPropertyToList("hasFacSto", egmt("inventory_faction.hasFacSto"), egmt("inventory_faction.hasFacSto_description"), "boolean", nil, nil, 1, egmt("inventory.title"))



---------------------------------------
--        Faction Storage Tab        --
---------------------------------------

-- Create a single faction storage panel.
function InventoryFaction:CreateFactionStorageSignle(parent, id, factionName, logsAccess)
	local factionStorage = InventoryStorage:CreateStoragePanel(parent, egmt("inventory_faction.type_faction_sub", factionName))
	parent.FactionStorages[id] = factionStorage

	if logsAccess then
		local logsList = vgui.Create("EGMListView", factionStorage)
		logsList:SetHeight(ScrH() * 0.2)
		logsList:DockMargin(ScrW() * 0.01, ScrH() * 0.01, ScrW() * 0.01, 0)
		logsList:Dock(TOP)
		logsList:SetHeaderHeight(ScrH() * 0.025)
		logsList:SetDataHeight(ScrH() * 0.025)
		logsList:SetMultiSelect(false)
		logsList:SetDataFont("EGMText8")
		logsList:AddCustomColumn(egmt("eventlog.log_entry"))
		logsList:AddCustomColumn(egmt("shared.time")):SetFixedWidth(ScrW() * 0.1)
		function logsList:OnRowRightClick(index, line)
			SetClipboardText(line:GetValue(2) .. " | " .. line:GetValue(1))
			Notify:Info(egmt("eventlog.title"), egmt("eventlog.copy"))
		end

		local pageSelector = vgui.Create("EGMPageSelector", factionStorage)
		pageSelector:SetHeight(ScrH() * 0.025)
		pageSelector:DockMargin(ScrW() * 0.01, 0, ScrW() * 0.01, 0)
		pageSelector:Dock(TOP)
		pageSelector:SetCallback(function(newPage)
			pageSelector:RequestPage(newPage)
		end)
		function pageSelector:RequestPage(page)
			net.Start("InventoryFaction.GetLogs")
				net.WriteUInt(id, 32)
				net.WriteUInt(page, 32)
			net.SendToServer()
		end
		pageSelector:RequestPage(1)

		factionStorage.LogsList = logsList
		factionStorage.PageSelector = pageSelector

		factionStorage:SetHeight(factionStorage:GetTall() + logsList:GetTall() + pageSelector:GetTall() + ScrH() * 0.01)
	end
end

-- Create the faction storage panel.
function InventoryFaction:CreateFactionStorage(parent, char, ent)
	parent.FactionStorages = {}

	for id, storageData in pairs(char:GetFactionStorages()) do
		self:CreateFactionStorageSignle(parent, id, storageData.Name, storageData.LogsAccess)
	end
end

-- Apply the faction storage for a specific faction storage panel.
function InventoryFaction:ApplyFactionStorageSingle(factionStorage, id, storage)
	InventoryStorage:ApplyStoragePanel(factionStorage, "storage", "faction_storage-" .. id, storage)

	local logsList = factionStorage.LogsList
	local pageSelector = factionStorage.PageSelector
	if IsValid(logsList) and IsValid(pageSelector) then
		local slots = factionStorage.ItemSlots
		local slotFrame = slots.Frame

		logsList:DockMargin(ScrW() * 0.01, slotFrame:GetTall() + ScrH() * 0.01, ScrW() * 0.01, 0)

		factionStorage:SetHeight(factionStorage:GetTall() + logsList:GetTall() + pageSelector:GetTall() + ScrH() * 0.01)
	end
end

-- Apply the faction storage to the faction storage panel.
--
-- @param Panel parent
-- @param Table storages
function InventoryFaction:ApplyFactionStorage(parent, storages)
	for id, factionStorage in pairs(parent.FactionStorages) do
		local storageData = storages[id] or {}
		self:ApplyFactionStorageSingle(factionStorage, id, storageData.Storage)
	end
end

-- Register Storage Tab: Faction Storage
-- This is the default faction storage tab, storing the items, accessible for all faction members.
InventoryStorage:RegisterStorageTab("faction_storage", egmt("inventory_storage.type_faction"),
function(parent, char, ent)
	InventoryFaction:CreateFactionStorage(parent, char, ent)

	hook.Run("InventoryFaction.CreateStorage", parent, char, ent)
end,
function(char, ent)
	local storages = char:GetFactionStorages()

	if table.Count(storages) > 0 then
		return true
	end

	return false
end, function(parent, char, ent)
	InventoryFaction:ApplyFactionStorage(parent, char:GetFactionStorages())
end)

-- Apply the faction storage logs.
--
-- @param Number factionId
-- @param Number page
-- @param Table logs
-- @param Number maxPages
function InventoryFaction:ApplyFactionStorageLogs(factionId, page, logs, maxPages)
	if not IsValid(InventoryStorage.Frame) then return end

	local currentChar = LocalPlayer():GetCurrentCharacter()
	if not currentChar then return end

	local storages = currentChar:GetFactionStorages()
	local storageData = storages[factionId]
	if not istable(storageData) then return end

	local storageTabs = InventoryStorage.StorageTabs
	if not istable(storageTabs) then return end

	local tabButton = storageTabs["faction_storage"]
	if not IsValid(tabButton) then return end

	local content = tabButton.Content
	if not IsValid(content) then return end

	local factionStorage = content.FactionStorages[factionId]
	if not IsValid(factionStorage) then return end

	local logsList = factionStorage.LogsList
	if not IsValid(logsList) then return end

	local pageSelector = factionStorage.PageSelector
	if not IsValid(pageSelector) then return end

	logsList:Clear()

	for _, entry in pairs(logs) do
		logsList:AddSortedLine(entry.text, nil, os.date(egmt("shared.date_time"), entry.created), entry.created)
	end

	-- Sort the list by the created time (descending).
	logsList:SortByColumns(2, true)

	pageSelector:SetPageCount(maxPages)
	pageSelector:SetPage(page)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Update the invntory, if the property changes.
hook.Add("Faction.PropertyChanged", "FactionStorage.Update", function(faction, key, value)
	if not IsValid(InventoryStorage.Frame) then return end

	if key == "storage" then
		local currentChar = LocalPlayer():GetCurrentCharacter()
		if not currentChar then return end

		local storages = currentChar:GetFactionStorages()

		local id = faction:GetId()
		local storageData = storages[id]
		if not istable(storageData) then return end

		local storageTabs = InventoryStorage.StorageTabs
		if not istable(storageTabs) then return end

		local tabButton = storageTabs["faction_storage"]
		if not IsValid(tabButton) then return end

		local content = tabButton.Content
		if not IsValid(content) then return end

		local factionStorage = content.FactionStorages[id]
		if not IsValid(factionStorage) then return end

		InventoryFaction:ApplyFactionStorageSingle(factionStorage, id, storageData.Storage)
	end
end)
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/sh_index.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Index | Cloakdisguise       --
---------------------------------------

if Config.Modules["cloneid"] and not RequireModules({"cloneid"}) then return end

Cloaking = Cloaking or {}
Disguise = Disguise or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_cloaking.lua")
	AddCSLuaFile("sh_disguise.lua")
	AddCSLuaFile("cl_cloaking.lua")
	AddCSLuaFile("cl_disguise.lua")

	include("sh_config.lua")
	include("sh_cloaking.lua")
	include("sh_disguise.lua")
	include("sv_cloaking.lua")
	include("sv_disguise.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_cloaking.lua")
	include("sh_disguise.lua")
	include("cl_cloaking.lua")
	include("cl_disguise.lua")
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     NextBot Spawner | SH Index    --
---------------------------------------

NextbotSpawner = NextbotSpawner or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")

	include("sh_config.lua")
	include("sv_nextbotspawner.lua")
end

if CLIENT then
	include("sh_config.lua")
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_droideka/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

include("shared.lua")

local colorRed = Color(200, 50, 0, 230)
local colorGrey = Color(15, 15, 15, 230)
local colorWhite = Color(255,255,255)


function ENT:DrawNameTag()
	local p = self:GetPos()

	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90

		local health = self:Health()
		local maxHealth = self:GetMaxHealth()

		cam.Start3D2D(p + Vector( 0, 0, 60 ), Angle( 0, ang.y, 90 ), .15)
			local width = draw.SimpleText("Zustand", "EGMText8", 0, - 160, colorWhite, TEXT_ALIGN_CENTER)

			draw.RoundedBox(5, - width / 2, - 120, width, 8, colorGrey)

			if health > 0 then
				draw.RoundedBox(5, - width / 2, - 120, width * (health / maxHealth), 8, colorRed)
			end
		cam.End3D2D()
	end
end

function ENT:Draw()
	self:DrawModel()
	self:DrawNameTag()

	local shieldMat = Material("models/props_combine/portalball001_sheet")

	local color1 = Color( 0, 175, 175, 49)
	local color2 = Color( 83, 255, 255, 10)

	if not self:GetShieldStatus() then return end
	render.SetColorMaterial()
	local pos = self:GetPos() + Vector(0, 0, 30)
	render.DrawSphere(pos, 50, 30, 30, color1)
	render.SetMaterial(shieldMat)
	render.DrawSphere(pos, 49, 30, 30, color2)
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_b2.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: B2"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "w/b2_blaster.wav"
SWEP.ClipSize = 20
SWEP.Damage = 19
SWEP.NumOfShots = 2

function SWEP:SecondaryAttack()
	if self:GetNextSecondaryFire() >= CurTime() then return end
	if self.TrainingMode then return end

	local startpos = self:GetOwner():GetShootPos() + self:GetOwner():EyeAngles():Right() * 10
	local ent = ents.Create( "lunasflightschool_missile_launcher" )
	ent:SetPos( startpos )
	ent:SetAngles( (self:GetOwner():GetEyeTrace().HitPos - startpos):Angle() )
	ent:SetOwner( self:GetOwner() )
	ent.Attacker = self:GetOwner()
	ent:Spawn()
	ent:Activate()

	ent:SetAttacker( self:GetOwner() )
	ent:SetInflictor( self:GetOwner():GetActiveWeapon() )

	local LockOnTarget = self:GetOwner():GetTarget()

	if IsValid( LockOnTarget ) then
		ent:SetLockOn( LockOnTarget )
	end

	self:EmitSound("weapons/e60r_fire.wav")
	self:SetNextSecondaryFire(CurTime() + 20)

	self:Reload()
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_bowcaster.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Bowcaster"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/hauptmann/star wars/weapons/bowcaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.5
SWEP.Sound = "w/bowcaster.wav"
SWEP.ClipSize = 10
SWEP.Damage = 45
SWEP.NumOfShots = 1
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_e5.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: E5"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = "models/kuro/sw_battlefront/weapons/e5_blaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "weapons/e5_fire.wav"
SWEP.ClipSize = 30
SWEP.Damage = 20


--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_ee3.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: EE3"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/ee3_carbine.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "w/ee3.wav"
SWEP.ClipSize = 100
SWEP.Damage = 23


--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_z3.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Z3"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/z6_rotary_cannon.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.1
SWEP.Sound = "weapons/z6_fire.ogg"
SWEP.ClipSize = 60
SWEP.Damage = 15


--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npcbase.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.PrintName = "#HL2_357"
SWEP.Spawnable = true
SWEP.Author = "Summe & Deltaa"
SWEP.Purpose = "Should only be used internally by advanced nextbots!"

SWEP.ViewModel = "models/weapons/v_357.mdl"
SWEP.Weight = 3

SWEP.Damage = 10

SWEP.NextShoot = 3
SWEP.TrainingMode = false
SWEP.Tracer = "rw_sw_laser_red"
SWEP.Range = 4000
SWEP.NumOfShots = 1

SWEP.Primary = {
	Ammo = "SMG1",
	DefaultClip = 20,
	Automatic = true,
	Range = 500
}

SWEP.Secondary = {
	Ammo = "None",
	DefaultClip = -1,
}

function SWEP:Initialize()
	self:SetHoldType("smg")
	self:SetClip1(self.ClipSize or 40)
end

function SWEP:CanPrimaryAttack()
	if self:Clip1() < 1 then
		self:Reload()
		return false
	end

	return CurTime() >= self:GetNextPrimaryFire()
end

function SWEP:CanSecondaryAttack()
	return false
end

local function ApplyStun(trace, dmgInfo)
	dmgInfo:SetDamageCustom(8888)

	local target = trace.Entity

	if IsValid(target) and target:IsPlayer() then
		target.LastDeathStunned = true
		target.LastDeathDuration = 60

		timer.Create("EGM.TFA.StunTimer." .. target:SteamID64(), 1, 1, function()
			if !IsValid(target) then return end
			if ! target:Alive() then return end

			target.LastDeathStunned = nil
			target.LastDeathDuration = nil
		end)
	end
end

function SWEP:PrimaryAttack()
	if !self:CanPrimaryAttack() then return end

	local owner = self:GetOwner()
	local weaponPos = owner:GetActiveWeapon():GetPos()

	local spread = self.Spread or 0
	local damage = self.Damage
	local training = self.TrainingMode

	owner:FireBullets({
		Num = self.NumOfShots,
		Src = weaponPos,
		Dir = self:GetOwner():GetAimVector(),
		Spread = Vector(spread, spread, 0),
		Distance = 20000,
		AmmoType = self:GetPrimaryAmmoType(),
		Damage = damage,
		Force = 0,
		Attacker = owner,
		TracerName = self.Tracer,
		Callback = function(attacker, tr, dmgInfo2)
			dmgInfo2:SetDamageType(DMG_AIRBOAT)

			local effect = EffectData()
			effect:SetEntity(self)
			effect:SetStart(tr.HitPos)
			effect:SetOrigin(tr.HitPos)
			effect:SetNormal(tr.HitNormal)
			effect:SetAngles(tr.HitNormal:Angle())
			effect:SetScale(1)
			effect:SetRadius(4)
			effect:SetMagnitude(1)
			effect:SetAttachment(1)
			util.Effect(self.ImpactEffect or "rw_sw_impact_red", effect)

			local target = tr.Entity

			if IsValid(target) and target:IsNextBot() then
				dmgInfo2:SetDamage(0)
				return
			end

			if training then
				ApplyStun(tr, dmgInfo2)
			end
		end
	})

	self:EmitSound(self.Sound)

	self:SetClip1(self:Clip1() - 1)
	self:SetNextPrimaryFire(CurTime() + self.NextShoot)
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	self:SetClip1(self.ClipSize or 40)

	self:SendWeaponAnim(self:GetOwner().AnimReload or ACT_HL2MP_GESTURE_RELOAD_SMG1)
	self:EmitSound(self.ReloadSound or "w/heavy.wav")

	self:SetNextPrimaryFire(CurTime() + 3)
end

if CLIENT then
	function SWEP:DrawWorldModel()

		if !self.WorldModel then return end

		if !IsValid(self.Model) then
			self.Model = ClientsideModel(self.WorldModel)
		end

		local _Owner = self:GetOwner()

		if (IsValid(_Owner)) then
			-- Specify a good position
			local offsetVec = Vector(5, -2.7, 0)
			local offsetAng = self.Offset or Angle(180, 180, 0)

			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			self.Model:SetPos(newPos)
			self.Model:SetAngles(newAng)

			self.Model:SetupBones()
		else
			self.Model:SetPos(self:GetPos())
			self.Model:SetAngles(self:GetAngles())
		end

		self.Model:DrawModel()
	end

	function SWEP:OnRemove()
		if !IsValid(self.Model) then return end
		self.Model:Remove()
	end
end

if SERVER then
	hook.Add("wOS.ALCS.Combat.PreProjectileDeflect", "Ligthsaber.RelectTraining", function(wep, ply, bullet, dmgInfo)
		local inflictor = dmgInfo:GetInflictor()

		if IsValid(inflictor) and inflictor.TrainingMode then
			bullet.TracerName = GetTracerName(bullet.TracerName)
			bullet.Callback = function(attacker, trace, dmgInfo2)
				ApplyStun(trace, dmgInfo2)
			end
		end
	end)
end
--gamemodes/starwarsrp/gamemode/modules/ticketsystem/sh_index.lua:
--------------------------------
--       Einfach-Gaming       --
--        Ticketsystem        --
--                            --
--     Created by Deltaa      --
--------------------------------

--------------------------------
--			   SH			  --
--------------------------------

if not RequireModules({"keybinds", "eventlog", "chat"}) then
	return false
end

Ticket = Ticket || {}
Ticket.Supports = Ticket.Supports || {}

if SERVER then
	AddCSLuaFile("sh_playermeta.lua")
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_core.lua")
	AddCSLuaFile("cl_menu.lua")
	AddCSLuaFile("cl_keybinds.lua")

	include("sh_config.lua")
	include("sh_playermeta.lua")
	include("sv_net.lua")
	include("sv_ticket.lua")
	include("sv_hook.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_playermeta.lua")
	include("cl_core.lua")
	include("cl_keybinds.lua")
	include("cl_menu.lua")
end
--gamemodes/starwarsrp/gamemode/modules/lightsaberutil/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Index | LightsaberUtil      --
---------------------------------------

if not RequireModules({"extrarank"}) then return end

LightsaberUtil = LightsaberUtil or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_lightsaberutil.lua")
	AddCSLuaFile("cl_lightsaberutil.lua")

	AddCSLuaFile("cl_forcepowers.lua")

	include("sh_config.lua")
	include("sh_lightsaberutil.lua")
	include("sv_lightsaberutil.lua")

	include("sv_forcepowers.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_lightsaberutil.lua")
	include("cl_lightsaberutil.lua")

	include("cl_forcepowers.lua")
end
--gamemodes/starwarsrp/gamemode/modules/lightsaberutil/cl_lightsaberutil.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | LightsaberUtil      --
---------------------------------------

-- Return a table of all skillable force powers and lightsaber forms
--
-- @return table skillTree
function LightsaberUtil:GetSkillTree()
	if not wOS or not wOS.SkillTrees then return {} end

	local skillTree = {}

	for tree, treeData in pairs(wOS.SkillTrees or {}) do
		for tier, tierData in pairs(treeData.Tier) do
			for skill, skillData in pairs(tierData) do
				skillTree[skillData.Name] = skillData.Name
			end
		end
	end

	return skillTree
end

Rank:AddPropertyToList("forcepowers", "Skilltree (Lichtschwert)", "Verfügbare Machtfähigkeiten und Lichtschwertstile im Skilltree", "table", function()
	return {
		validValues = LightsaberUtil:GetSkillTree()
	}
end, nil, 1, "Lightsaber")

Equipment:AddPropertyToList("forcepowers", "Skilltree (Lichtschwert)", "Verfügbare Machtfähigkeiten und Lichtschwertstile im Skilltree", "table", function()
	return {
		validValues = LightsaberUtil:GetSkillTree()
	}
end, nil, 1, "Lightsaber")

Equipment:AddPropertyToList("fPowers", "Machfähigkeiten (Direkt)", "Füge Machtfähigkeiten direkt zum Lichtschwert hinzu (Ohne Skilltree)", "table", function()
	local values = {
		validValues = {}
	}

	if not wOS or not wOS.AvailablePowers then return values end

	for power, _ in pairs(wOS.AvailablePowers) do
		values.validValues[power] = power
	end

	return values
end, nil, 3, "Lightsaber")



---------------------------------------
--               Hooks               --
---------------------------------------

-- Block the new holster inventory system for all lightsabers except the ones marked as new holster.
hook.Add("Inventory.BlockHolster", "LightsaberUtil.BlockHolster", function(itemClass, ply, char, itemType, itemData)
	local weaponClass = itemData.WeaponClass

	local wep = weapons.Get(weaponClass)
	if not istable(wep) then return end

	-- Skip if the weapon is not a lightsaber
	if not isstring(wep.UseHilt) and not wep.PersonalLightsaber then return end

	-- Skip if the weapon is marked as new holster
	if LightsaberUtil.InvHolster[weaponClass] then
		return
	end

	-- Block the holster
	return true
end)

-- Override the function, to render the holstered lightsabers.
hook.Add("PostPlayerDraw", "wOS.Lightsaber.HolsterDrawing", function( ply )
	if not ply.LightsaberMDL then
		ply.LightsaberMDL = {}
	end

	-- Cloaked Players don't show their lightsaber
	if ply:GetNW2Float("CloakTime", 0) >= CurTime() then return end

	local pi = -30
	local radian = 0

	if not wOS or not wOS.Lightsabers then return end
	for class, _ in pairs(wOS.Lightsabers.General) do
		-- Gets the weapon
		local wep = ply:GetWeapon(class)
		if not IsValid(wep) then continue end

		local activeWeapon = ply:GetActiveWeapon()
		if IsValid(activeWeapon) then
			-- Don't show the active weapon
			if wep == activeWeapon then continue end

			-- Don't show duals twice
			if activeWeapon.DualWielded and string.find(activeWeapon:GetClass(), wep:GetClass()) then
				continue
			end
		end

		-- Checks if the world model should not be drawn
		if not wep.WorldModel then continue end

		if LightsaberUtil.HiddenClasses[class] then continue end -- Don't show hidden weapons
		if LightsaberUtil.InvHolster[class] then continue end -- Don't show new holster weapons

		-- Replace the primary model with secondary model, if weapon is dual lightsaber
		local model = wep.WorldModel
		if wep.DualWielded then
			model = wep:GetSecWorldModel()
		end

		-- Setup the lightsaber clientside model
		if not ply.LightsaberMDL[class] then
			ply.LightsaberMDL[class] = ClientsideModel(model, RENDERGROUP_BOTH) -- model is nil?
			ply.LightsaberMDL[class]:SetNoDraw(true)
		end

		-- Sets the model
		ply.LightsaberMDL[ class ]:SetModel(model)

		-- Bone calculation
		local bone = ply:LookupBone("ValveBiped.Bip01_Pelvis")
		local spin = false

		if not bone then
			bone = ply:LookupBone("ValveBiped.Bip01_Spine")
			spin = true
		end

		if not bone then return end

		local pos, ang = ply:GetBonePosition(bone)
		local att = pi * radian
		if spin then
			ang:RotateAroundAxis(ang:Forward(), 220 + att)
		else
			ang:RotateAroundAxis(ang:Up(), 90 )
			ang:RotateAroundAxis(ang:Forward(), att)
		end

		pos = pos - ang:Right() * 8 - ang:Forward() * 8

		if spin then
			pos = pos + ang:Up() * 6 - ang:Forward() * 5 + ang:Right() * 5
		end

		if LightsaberUtil.DualModels[model] then
			pos = pos + ang:Right() + ang:Forward() * -10 + ang:Up()
		end

		if model == "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" then
			pos = pos - ang:Forward() * 1
		end

		if model == "models/weapons/starwars/w_kr_hilt.mdl" then
			pos = pos + ang:Forward() * 5
		end

		ang:RotateAroundAxis(ang:Forward(), 90)

		ply.LightsaberMDL[class]:SetPos(pos)
		ply.LightsaberMDL[class]:SetAngles(ang)
		ply.LightsaberMDL[class]:DrawModel()

		radian = radian + 1
	end
end)




---------------------------------- SAVE FORCEPOWERS ---------------------------------

-- Saves Force Powers upon Selection
net.Receive("wOS.ALCS.HybridForceSelect", function()
	local ply = LocalPlayer()
	local ls = ply:GetActiveWeapon()
	if not IsValid(ls) or not ls.IsLightsaber then return end

	local lsString = ls:GetClass()

	-- Remove the dual suffix from the weapon class
	if lsString:find("dual$") then
		lsString = lsString:gsub("dual$", "")
	end

	local tbl = net.ReadTable()

	local forcePowers = {}
	local cachedPowers = {}

	for _, power in pairs(tbl) do
		local data = ls.AvailablePowers[power]
		if not data then continue end

		local i = #forcePowers + 1
		forcePowers[i] = data
		cachedPowers[i] = power
	end

	ls.ForcePowers = forcePowers

	local charID = ply:GetCurrentCharacterId()
	if not isnumber(charID) or charID < 0 then return end

	local cookieKey = "EGM:RP." .. charID .. "." .. lsString .. ".forcepowers"
	local jsonData = util.TableToJSON(cachedPowers)

	cookie.Set(cookieKey, jsonData)
end)

------------------------------------- LOAD FORCEPOWERS ---------------------------------

net.Receive("LightsaberUtil.LoadForcePowers", function()
	local ply = LocalPlayer()
	local ls = ply:GetActiveWeapon()

	if not IsValid(ls) or not ls.IsLightsaber then return end

	local lsString = ls:GetClass()
	local charID = ply:GetCurrentCharacterId()

	if not isnumber(charID) or charID < 0 then return end

	-- Remove the dual suffix from the weapon class
	if lsString:find("dual$") then
		lsString = lsString:gsub("dual$", "")
	end

	local cookieKey = "EGM:RP." .. charID .. "." .. lsString .. ".forcepowers"
	local jsonData = cookie.GetString(cookieKey, "[]")

	local cachedPowers = util.JSONToTable(jsonData)

	-- If the player has no saved force powers for this lightsaber, return
	if not cachedPowers then return end

	-- Replace the force powers in the weapon.
	net.Start("wOS.ALCS.HybridForceSelect")
		for i = 1, wOS.ALCS.Config.MaximumForceSlots do
			local cachedPower = cachedPowers[i]
			if not isstring(cachedPower) or cachedPower == "" then
				continue
			end

			if not table.HasValue(ls.ForcePowerList or {}, cachedPower) then
				continue
			end

			net.WriteUInt(i, 10)
			net.WriteString(cachedPower)
		end
	net.SendToServer()
end)
--gamemodes/egmrp/gamemode/modules/realism/sh_staminasystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared |  Staminasystem      --
---------------------------------------

local function doStaminaThink(ply)
    if not ply:Alive() then return end

    local char = ply:GetCurrentCharacter()
    if not char then return end

    local rank = char:GetRank()
    if not rank then return end

    local maxStamina = char.MaxStamina or ply:GetNWInt("MaxStamina", Realism.MaxStamina)
    local stamina = char.stamina or maxStamina

    if not ply:IsOnGround() then return end

    if ply:IsSprinting() and stamina > 0 and not char.staminaFullRecharge
    and (ply:KeyDown(IN_FORWARD) or ply:KeyDown(IN_MOVELEFT) or ply:KeyDown(IN_MOVERIGHT))
    and ply:GetVelocity():Length() > ply:GetWalkSpeed() then
        char.stamina = math.max(0, stamina - Realism.StaminaLoose * FrameTime())
    else
        if stamina == 0 then
            char.staminaFullRecharge = true
        end

        char.stamina = math.min(maxStamina, stamina + Realism.StaminaRegeneration * FrameTime())

        if char.staminaFullRecharge and char.stamina == maxStamina then
            char.staminaFullRecharge = false
        end
    end
end

hook.Add("StartCommand", "Realism.DisableSprintingStamina", function(ply, ucmd)
    local currentChar = ply:GetCurrentCharacter()
    if currentChar and currentChar.staminaFullRecharge and ucmd:KeyDown(IN_SPEED) then
        ucmd:RemoveKey(IN_SPEED)
    end
end)

if SERVER then
    hook.Add("Think", "Realism.StaminaSystem", function()
        if not Realism.StaminaSystemEnabled then return end

        for _, ply in pairs(player.GetHumans()) do
            doStaminaThink(ply)
        end
    end)
end

if CLIENT then
    hook.Add("Think", "Realism.StaminaSystem", function()
        if not Realism.StaminaSystemEnabled then return end

        doStaminaThink(LocalPlayer())
    end)
end

if SERVER then
    -- Initialize stamina and reset stamina on death.
    hook.Add("Player.ChangedCharacter", "Realism.ResetStamina", function(ply, character, oldCharacter)
        local rank = character:GetRank()
        if not rank then return end
        character.MaxStamina = rank:GetProperty("stamina", Realism.MaxStamina)
        ply:SetNWInt("MaxStamina", character.MaxStamina)
        character.stamina = character.MaxStamina
        character.staminaFullRecharge = false
    end)
end

hook.Add("Character.DataChanged", "Realism.ReloadStamina", function(character, key, value)
    if key == "rankId" and character:IsCurrentCharacter() then
        local rank = Rank:GetCached(value)
        if not rank then return end

        character.MaxStamina = rank:GetProperty("stamina", Realism.MaxStamina)
    end
end)

Rank:AddProperty("stamina", "number", Realism.MaxStamina, function(rank, value)
    if not isnumber(value) then
        return false, egmt("shared.invalid_type")
    end

    if value > 500 or value < -Realism.MaxStamina then
        return false, egmt("realism.stamina_invalid")
    end

    return true
end,
function(rank, ply)
    return true
end)

if CLIENT then
    Rank:AddPropertyToList("stamina", egmt("realism.stamina_name"), egmt("realism.stamina_description", Realism.MaxStamina), "slider", function()
        return {min = -Realism.MaxStamina, max = 500}
    end)

    -- Paint stamina bar.
    hook.Add("HUDPaint", "Realism.StaminaSystem", function()
        local char = LocalPlayer():GetCurrentCharacter()
        if not char then return end

        local maxStamina = LocalPlayer():GetNWInt("MaxStamina", Realism.MaxStamina)

        if maxStamina then
            local stamina = char.stamina or maxStamina

            if char.staminaFullRecharge then
                draw.RoundedBox(5, ScrW() * 0.4, ScrH() * 0.95, ScrW() * 0.2, ScrH() * 0.011, GetColor("red", 127))
            end

            if stamina < maxStamina then
                local percentage = stamina / maxStamina
                local color = char.staminaFullRecharge and GetColor("red", 63) or GetColor("black", 127)

                -- Background bar.
                draw.RoundedBox(5, ScrW() * 0.4, ScrH() * 0.95, ScrW() * 0.2, ScrH() * 0.011, color)

                -- Foreground bar.
                draw.RoundedBox(5, ScrW() * 0.4 + ScrW() * 0.1 * (1 - percentage), ScrH() * 0.95, ScrW() * 0.2 * percentage, ScrH() * 0.011, GetColor("yellow", 127))
            end
        end
    end)
end


--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--  Lightsaber Crafting | SH Config  --
---------------------------------------

-- From which rank you can edit the lightsaber inventory
LightsaberCrafting.ModifyAtLeast = "admin"

-- Background for the inventory
LightsaberCrafting.Background = "materials/wallpaper/wallpaper2you_534531.jpg"

-- Default size of the inventory
LightsaberCrafting.InventorySize = 20

-- All personal lightsaber classes
LightsaberCrafting.PersonalLightsabers = {
	["weapon_lightsaber_personal"] = true,
	["weapon_lightsaber_personaldual"] = true
}

-- Translate the donation packets
LightsaberCrafting.DonatorPackets = {
	-- Power vortex
	["antique"] = "Antiker Kristall",
	["elder"] = "Elder Kristall",
	["elegant"] = "Eleganter Kristall",
	["flames"] = "Flammenkristall",
	["runic"] = "Gerunter Kristall",
	["prongs"] = "Gezackter Kristall",
	["unstable"] = "Instabiler Kristall",
	["sawblades"] = "Klingenkristall",
	["coded"] = "Kodierter Kristall",
	["mystical"] = "Mystischer Kristall",
	["sharp"] = "Scharfer Kristall",
	["splintery"] = "Splittriger Kristall",
	["amplified"] = "Verstärkter Kristall",
	["swirling"] = "Wirbelnder Kristall",
	["split"] = "Zweischneidiger Kristall",

	-- Color crystals
	["yellow"] = "Gelber Kristall",
	["pink"] = "Rosaner Kristall",
	["purple"] = "Violetter Kristall",
	["golden"] = "Goldener Kristall",
	["cyan"] = "Pazifik-Türkiser Kristall",
	["orange"] = "Orangener Kristall",

	-- Hilts
	["crossguard"] = "Crossguard Griff"
}

-- Model of the crafting machine
LightsaberCrafting.Model = "models/props/starwars/tech/machine.mdl"

-- Ambient sound around the machine
LightsaberCrafting.AmbientSound = "ambient/machines/combine_shield_loop3.wav"
--gamemodes/egmrp/gamemode/modules/course/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Course | Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum usergroup to edit Courses.
Course.MinAccessGroup = "operator"

-- Minimum usergroup to assign Courses.
Course.MinAssignGroup = "operator"
--gamemodes/egmrp/gamemode/modules/event/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Eventsystem index         --
---------------------------------------

Event = Event or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_event.lua")
    AddCSLuaFile("cl_event.lua")
    AddCSLuaFile("cl_keybinds.lua")

    include("sh_config.lua")
    include("sh_event.lua")
    include("sv_event.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_event.lua")
    include("cl_event.lua")
    include("cl_keybinds.lua")
end
--gamemodes/starwarsrp/gamemode/modules/weaponutil/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         WeaponUtil index          --
---------------------------------------

WeaponUtil = WeaponUtil or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_weaponutil.lua")
	AddCSLuaFile("sh_jedihands.lua")

	include("sh_config.lua")
	include("sh_weaponutil.lua")
	include("sh_jedihands.lua")
	include("sv_weaponutil.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_weaponutil.lua")
	include("sh_jedihands.lua")
end
--gamemodes/starwarsrp/gamemode/modules/weaponutil/item_classes/weapon_dual/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Waffe (Duals)"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}


-- Remove all Dual versions of the weapons.
--
-- @param table validWeapons
-- @param vararg ...
local function restrictWeapons(validWeapons, ...)
	local toBeRemoved = {}

	for weaponClass, _ in pairs(validWeapons) do
		if string.EndsWith(weaponClass, "dual") then
			table.insert(toBeRemoved, weaponClass)
		end
	end

	for _, weaponClass in ipairs(toBeRemoved) do
		validWeapons[weaponClass] = nil
	end
end

-- Register all hooks.
hook.Add("Faction.RemoveWeapons", "WeaponUtil.RestrictDuals", restrictWeapons)
hook.Add("Rank.RemoveWeapons", "WeaponUtil.RestrictDuals", restrictWeapons)
hook.Add("Equipment.RemoveWeapons", "WeaponUtil.RestrictDuals", restrictWeapons)
hook.Add("ItemType.RemoveWeapons", "WeaponUtil.RestrictDuals", restrictWeapons)

-- Mark the holstered weapons as duals.
hook.Add("Inventory.PostHolsterWeapon", "WeaponUtil.MarkDuals", function(itemClass, ply, char, itemType, itemData, holsteredWeapon)
	if not itemClass.IsDuals then return end

	holsteredWeapon.IsDuals = true

	-- If we are the right pistol, we mark it as the single version.
	local slotId = itemData.SlotId
	if slotId == "smallL" then
		holsteredWeapon.IsSingle = true
	end
end)

-- Block the rendering of the holster weapon.
hook.Add("Inventory.OverrideDrawHolsterWeapon", "WeaponUtil.OverrideDuals", function(ply, activeWeapon, holsteredWeapon)
	if not holsteredWeapon.IsDuals then return end

	local weaponClass = holsteredWeapon.WeaponClass
	local dualClass = weaponClass .. "dual"

	-- If we are holding the dual version, both weapons are drawn.
	if activeWeapon:GetClass() == dualClass then
		return false
	end

	-- If we are holding the single version, we do not draw the dual version.
	if activeWeapon:GetClass() == weaponClass then
		-- If we only have the single version, just hide the holster weapon.
		if not ply:HasWeapon(dualClass) then
			return false
		end

		if holsteredWeapon.IsSingle then
			return false
		else
			return true
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/pronemod/cl_settings.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--         ProneMod Extension        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      ProneMod Extension | CL      --
---------------------------------------
Settings:Register("Zum Hinlegen Doppel-Bind", "Prone Mod", function() end, "true")
Settings:Register("Zum Aufstehen Doppelsprung", "Prone Mod", function() end, "false")
--gamemodes/starwarsrp/gamemode/modules/rakghoul/weapons/weapon_swrp_rakghoul_swep/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | CL           --
---------------------------------------

include("shared.lua")

function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() >= CurTime() then return end

	local vm = self:GetOwner():GetViewModel()
	vm:ResetSequence( vm:LookupSequence( "fists_idle_01" ) )

	anim = self.AttackAnims[ math.random( 1, 2 ) ]

	timer.Simple( 0, function()
		if ( !IsValid( self ) || !IsValid( self:GetOwner() ) || !self:GetOwner():GetActiveWeapon() || self:GetOwner():GetActiveWeapon() != self ) then return end

		vm = self:GetOwner():GetViewModel()
		vm:ResetSequence( vm:LookupSequence( anim ) )
	end )

	self:GetOwner():DoAnimationEvent(ACT_GMOD_GESTURE_RANGE_FRENZY)
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
	return
end

--gamemodes/starwarsrp/gamemode/config/cl_compass.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Compass | Config         --
---------------------------------------

-- List of all maps where there are no Magnetic directions. (Spaceships, etc..)
Compass.NoCompassMaps = {
    "rp_venator_extensive"
}
--gamemodes/starwarsrp/gamemode/config/cl_notify.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Notify Config           --
---------------------------------------

-- Sound when a notification pops up, false to disable.
Notify.Sound = "notify/notify.mp3"
--gamemodes/starwarsrp/gamemode/config/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Scoreboard | Config        --
---------------------------------------

-- The width of the scoreboard. ScrW() represents the current screen width.
Scoreboard.Width = ScrW() * 0.8

-- The height of the scoreboard. ScrH() represents the current screen height.
Scoreboard.Height = ScrH() * 0.8

-- The padding of the scoreboard. Basically the spacing between different elements.
Scoreboard.Padding = 10
--gamemodes/starwarsrp/gamemode/config/sh_ammosystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        AmmoSystem | Config        --
---------------------------------------

-- Background for the menu
AmmoSystem.MenuBackground = "materials/wallpaper/Sci-Fi-Star-Wars-Clone-Trooper-HD-Wallpaper-Background-Image.jpg"

-- Model for the Ammo box.
AmmoSystem.Model = "models/reizer_props/srsp/sci_fi/crate_01/crate_01.mdl"

-- Configure all Ammo Types you want in the box here. ["weight"] is only usefull if you use ammo weight from realism module but it is required to be a value
AmmoSystem.AmmoTypes = {
	["rpg_round"] = {
		name = "Raketen",
		weight = 0,
		limit = 10
	},

	["smg1_grenade"] = {
		name = "Granatenhülsen",
		weight = 0,
		limit = 20
	},

	["ar2"] = {
		name = "Blaster Munition",
		weight = 0,
		limit = 2000
	},

	["XBowBolt"] = {
		name = "Mini Rakete",
		weight = 0,
		limit = 1,
	}
}
--gamemodes/starwarsrp/gamemode/config/sh_bodygroups.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | BodyGroup System     --
---------------------------------------

-- Background of the Changing room menu.
BodyGroups.MenuBackground = "materials/wallpaper/Sci-Fi-Star-Wars-Clone-Trooper-HD-Wallpaper-Background-Image.jpg"

-- Model for the Changing room.
BodyGroups.ChangingRoomModel = "models/props_wasteland/controlroom_storagecloset001a.mdl"

-- Dependencies of bodygroups.
-- A dependent bodygroups is only set on ApplyBodygroups, if the dependency is not set.
-- This does not affect, what is stored for the bodygroups of a character it just filters, what is applied to the player.
BodyGroups.Dependencies = {}
BodyGroups.Dependencies["Pauldron"]			           = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Pauldron (Simple)"]		   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Pauldron (Big)"]		       = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Pauldron (ARC)"]		       = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Ammo (Arm)"]				   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Ammo (Shoulder)"]		       = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Antenna (Shoulder)"]	       = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Antenna (Back)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Double Straps"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Double Straps (Grenades)"]	   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Double Straps Datapad"]	   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Strap"]			           = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Strap (Grenades)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Strap (Datapad)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Rand (Commander)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Armor (Chest)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["Armor (Shoulder)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}
BodyGroups.Dependencies["ARC Gear (Body)"]			   = {Dependency = "Body (Chest)", DependencyNotSet = 1}

-- Incompatible bodygroups.
-- An incompatible bodygroup is reset, if its incompatible partner is set.
BodyGroups.Incompatibles = {}

BodyGroups.Incompatibles["Kama"]			    = {Incompatible = "Kama (ARC)"}
BodyGroups.Incompatibles["Pauldron"]		    = {Incompatible = "Pauldron (Simple)", "Pauldron (Big)", "Pauldron (ARC)"}

BodyGroups.Incompatibles["Sunvisor"]			= {Incompatible = "Binocular", "Rangefinder"}
BodyGroups.Incompatibles["Binocular"]			= {Incompatible = "Camera", "Flashlight", "Rangefinder"}
BodyGroups.Incompatibles["Rangefinder"]			= {Incompatible = "Binocular"}

BodyGroups.Incompatibles["Rank CMD"]			= {Incompatible = "Rank MJR", "Rank CPT", "Rang FLT", "Rank LT", "Rank SMJ", "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank MJR"]			= {Incompatible = "Rank CPT", "Rang FLT", "Rank LT", "Rank SMJ", "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank CPT"]			= {Incompatible = "Rang FLT", "Rank LT", "Rank SMJ", "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank FLT"]			= {Incompatible = "Rank LT", "Rank SMJ", "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank LT"]			    = {Incompatible = "Rank SMJ", "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank SMJ"]			= {Incompatible = "Rank SSG", "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank SSG"]			= {Incompatible = "Rank SGT", "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank SGT"]			= {Incompatible = "Rank CPL", "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank CPL"]			= {Incompatible = "Rank LCPL", "Rank PFC"}
BodyGroups.Incompatibles["Rank LCPL"]			= {Incompatible = "Rank PFC"}


-- Access to the /model command.
BodyGroups.AccessGroup = "eventleiter"

BodyGroups.EnforceStrictModel = true
--gamemodes/starwarsrp/gamemode/config/sh_donator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--  Shared | Donator System Config   --
---------------------------------------

-- Name of the default donator rank.
Donator.Name = "Jedi & VIP Lifetime (Legacy)"

-- Minimum rank, to be able to use the donator system.
Donator.MinAccessGroup = "superadmin"
--gamemodes/starwarsrp/gamemode/config/sh_eventlog.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Server | Event Log Config     --
---------------------------------------

-- Specifies how long (in days) logs should be kept. false to not delete old logs.
EventLog.Expire = 40

-- The maximum number of elements a page can have in the player manager. The higher the number the higher the loading time.
EventLog.PageSize = 50

-- The minimum group required to access the event logs.
EventLog.MinAccessGroup = "testmoderator"

-- The background image of the event log menu.
EventLog.Background = "materials/wallpaper/924920.png"

-- The default key to open the event logs.
EventLog.DefaultKey = KEY_F9

-- Delay in seconds between each save of the event logs.
EventLog.SaveTimer = 30
--gamemodes/starwarsrp/gamemode/config/sh_inventory_shop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | Inventory Shop      --
---------------------------------------

-- Fallback model for the storage entity.
InventoryShop.Model = "models/niksacokica/tech/tech_gsi_bountyboard.mdl"

-- Minimum user groups that is allowed, to edit shop entries.
ShopEntry.MinAccessGroup = "admin"
--gamemodes/starwarsrp/gamemode/config/sh_permaprops.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permaprop | Config         --
---------------------------------------

-- Maximum amount of permaprops per map.
PermaProps.MaxProps = 750

-- Maximum amount of displayed items in the list.
PermaProps.PerMenuPage = 100

-- Minimum Rank to Permaprop something and list new users
PermaProps.MinimumGroup = "seniormoderator"

--Minimum Rank to get whitelisted as Permaprop User.
PermaProps.MinimumListGroup = "eventleiter"

-- should the prop actually be removed from the world when it's removed as a permaprop?
PermaProps.RemoveEntOnRemove = false

-- Deriving maps share the perma props of a base map.
PermaProps.DerivingMaps = {
	["rp_fortmithraw_day"] = "rp_fortmithraw",
	["rp_anaxmas_defcon_v2"] = "rp_anaxes_defcon_v2",
	["rp_dantooine_night_edition"] = "rp_dantooine_egm_edit",
	["rp_swarcanis_base1"] = "swarcanis_base1"
}

-- Blacklist for models when creating permaprops. Does not affect already saved permaprops.
PermaProps.ModelBlacklist = {
    --"models/props_debris/metal_panel02a.mdl"
}

-- Blacklist for entity classes when creating permaprops. Does not affect already saved permaprops.
PermaProps.EntityBlacklist = {
    --"prop_physics"
}

-- Delay after wich a permapropped weapon respawns if picked up in the weaponslots system.
PermaProps.WeaponRespawnDelay = 120
--gamemodes/starwarsrp/gamemode/config/sh_permission.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permission | Config        --
---------------------------------------

-- List of all usergroups.
-- Sorted by permission. The last usergroup has the highest permission.
Permission.UserGroupList = {
	"user",
	"stammi",
	"elite",
	"legende",
	"ultimate",
	"eventleiter",
	"testmoderator",
	"moderator",
	"seniormoderator",
	"admin",
	"superadmin",
	"communityleitung",
	"gruender"
}

Permission.AdminRank = "admin"

Permission.SuperAdminRank = "superadmin"

-- First team rank in the user group list. Determines wich ranks are handles as team members.
Permission.FirstTeamRank = "testmoderator"

-- Keybind, where teammembers will be noclipped and cloaked.
Permission.AdministrateDefaultKey = KEY_V

-- Rank where teammembers can toggle cloak and noclip.
Permission.AdministrateRank = "eventleiter"

-- Wich rank and above should get the DC15-T
Permission.AdministrateWeaponRank = "admin"

-- Weapon given to Admin+ When noclipping.
Permission.AdminWeapons = {"weapon_swrp_dc15t"}

-- Clientside restrictions.
if CLIENT then
    -- Minimum group at which a player is able to open the spawn menu. false to allow it to everyone.
    Permission.OpenSpawnMenu = "eventleiter"

    -- Minimum group at which a player is able to open the context menu (C-menu).
    Permission.MinimumContextMenuGroup = "eventleiter"
end

if SERVER then
    -- Minimum group at which a player is able to spawn any object. Global restriction for spawning.
    Permission.SpawnObjects = "eventleiter"

    -- Minimum group at which a player is able to spawn props.
    Permission.SpawnProp = "eventleiter"

    -- Minimum group at which a player is able to spawn NPCs.
    Permission.SpawnNPC = "eventleiter"

    -- Minimum group at which a player is able to use the contextmenu-options (C-Menu -> remove etc.).
    Permission.CanProperty = "eventleiter"

    -- Minimum group at which a player is able to use the context-menu optionns for map props.
    Permission.CanPropertyMap = "eventleiter"

    -- Minimum group at which a player is able to use tools.
    Permission.CanTool = "eventleiter"

    Permission.LimitedCanTool = {
    }

    -- Minim group at which a player is able to tool the map. The creator tool is ignored.
    Permission.CanRemoveMap = "seniormoderator"

    -- Minimum group at which a player is able to spawn ragdolls.
    Permission.SpawnRagdoll = "eventleiter"

    -- Minimum group at which a player is able to spawn scripted entities.
    Permission.SpawnSENT = "eventleiter"

    -- Minimum group at which a player is able to spawn effects.
    Permission.SpawnEffect = "eventleiter"

    -- Minimum group at which a player is able to spawn vehicle.
    Permission.SpawnVehicle = "eventleiter"

    -- Minimum group at which a player is able to spawn and give weapons via spawnmenu (Q-menu).
    Permission.SpawnGiveWeapon = "eventleiter"

    -- Whether players will be allowed to allow sprays.
    Permission.AllowSprays = false

    -- Whether to allow suiciding (kill command).
    -- - Boolean false to disallow suicide for everyone.
    -- - Boolean true to allow it for everyone.
    -- - String userGroup to allow it for everyone above the usergroup.
    Permission.AllowSuicide = false
end

-- Group that is required for "vanishing".
Permission.VanishRank = "admin"
--addons/wos-passiveevent/lua/wos/pes/loader/loader.lua:
wOS = wOS || {}
wOS.PES = wOS.PES || {}

if SERVER then
    //TEMPP RRESOURCE ADD TTILL ALL OTHHER ICONSS ARRE REAADY
    resource.AddSingleFile( "materials/wos/pes/bg.png" )
end

local base_dir = "wos/pes"

if SERVER then
    AddCSLuaFile( base_dir .. "/config/general/sh_config.lua")
	AddCSLuaFile( base_dir .. "/config/general/sh_permissions.lua")
    include( base_dir .. "/config/general/sv_config.lua" )
end

include( base_dir .. "/config/general/sh_config.lua")
include( base_dir .. "/config/general/sh_permissions.lua")

if SERVER then

	AddCSLuaFile( base_dir .. "/core/sh_sfs_extern.lua")

    AddCSLuaFile( base_dir .. "/vgui/wos_nodebackground.lua" )
    AddCSLuaFile( base_dir .. "/vgui/wos_node.lua" )
	AddCSLuaFile( base_dir .. "/vgui/wos_viewnodes.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_calendar.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_datacopy_editor.lua")

    AddCSLuaFile( base_dir .. "/core/sh_mod_mount.lua")
    AddCSLuaFile( base_dir .. "/core/sh_var_mount.lua")

    AddCSLuaFile( base_dir .. "/core/cl_core.lua")
	AddCSLuaFile( base_dir .. "/core/cl_admin_menu.lua")
    AddCSLuaFile( base_dir .. "/core/cl_net.lua")
	AddCSLuaFile( base_dir .. "/core/sh_net.lua")
    AddCSLuaFile( base_dir .. "/core/cl_accessors.lua")
	AddCSLuaFile( base_dir .. "/core/sh_settings.lua")

    include( base_dir .. "/core/sh_var_mount.lua" )
    include( base_dir .. "/core/sh_mod_mount.lua" )
	
    wOS.PES:ServerInclude( base_dir .. "/core/sv_node_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_trigger_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_trigger.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_node.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_event.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_net.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_core.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_permission.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_url_importer.lua")
else

    include( base_dir .. "/vgui/wos_nodebackground.lua" )
    include( base_dir .. "/vgui/wos_node.lua" )

	include( base_dir .. "/vgui/wos_viewnodes.lua")
	include( base_dir .. "/vgui/wos_calendar.lua")

    include( base_dir .. "/vgui/wos_datacopy_editor.lua")

    include( base_dir .. "/core/sh_mod_mount.lua")
    include( base_dir .. "/core/sh_var_mount.lua")
	
	include( base_dir .. "/core/cl_core.lua")
	include( base_dir .. "/core/cl_admin_menu.lua")
    include( base_dir .. "/core/cl_net.lua")
    include( base_dir .. "/core/cl_accessors.lua")

end

include( base_dir .. "/core/sh_sfs_extern.lua")
include( base_dir .. "/core/sh_settings.lua")
include( base_dir .. "/core/sh_net.lua")

hook.Call( "wOS.PES.OnLoaded" )
--addons/wos-passiveevent/lua/wos/pes/config/general/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Config = wOS.PES.Config or {}

// What user groups can create new events?
wOS.PES.Config.CreateEventUsersgroup = {
	["gruender"] = true,
	["communityleitung"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
	["testmoderator"] = true,
	["eventleiter"] = true,
}

// How often should we roll for a random event to happen, if there are any on the server? ( IN SECONDS )
wOS.PES.Config.RandomInterval = 60

// What is the maximum amount of random events that can run at the same time?
// 0 = NO LIMIT!
wOS.PES.Config.MaxRandoms = 1

// How long in advance should we wait to allow someone to snooze a randomly selected event? ( IN SECONDS )
// To prevent potentially weird overlap, this should always be less than the random interval
wOS.PES.Config.SnoozeDelay = 10

// This can be a table or a single value
wOS.PES.Config.SnoozeText = "Das Random-Event \"[[name]]\" wird in [[time]] beginnen. \n\nMöchtest du den Start abbrechen?"
--addons/wos-passiveevent/lua/wos/pes/vgui/wos_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[

	Copyright wiltOS Technologies LLC, 2021

	Contact: www.wiltostech.com

----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.EVENT
PANEL.MatrixCore = Matrix()
PANEL.ZoomScale = 1
PANEL.PES_Element = true

function PANEL:PushBackgroundScale()
    local zoom_scale = self:GetZoomScale()
    local scale = ( 1 - zoom_scale )*0.5
    self.MatrixCore:SetScale( Vector( zoom_scale, zoom_scale, 1 ) )
    local tall, wide = self:GetTall(), self:GetWide()
    self.MatrixCore:SetTranslation( Vector( wide*scale, tall*scale, 0 ) )
    cam.PushModelMatrix(self.MatrixCore)
end

function PANEL:PopBackgroundScale()
    cam.PopModelMatrix()
end

function PANEL:Init()
    self.DirtyNodes = false
    self.LastKey = 0
    self.Nodes = {}
    self.Name = ""
    self.Links = {}

    self._x = 0
    self._y = 0

    self._tx = 0
    self._ty = 0

    self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    //self._background:NoClipping( true )
    self._background.PES_BACKGROUND = true
    self._background.Paint = function(sef, w, h)

        self.WasClippedDisabled = DisableClipping( true )
        self:PushBackgroundScale()

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w*self:GetZoomScale(), h*self:GetZoomScale())

        for pnl, triggerLinks in pairs(self.Links) do
            if !IsValid(pnl) then
                self:NodeRemove(pnl)
                continue
            end

            for triggerName, panelTable in pairs(triggerLinks) do
                for index, oPnl in ipairs(panelTable) do
                    if !IsValid(oPnl) then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end

        // Draw the child nodes
        for _, child in ipairs( sef:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            child:RecursiveManualPaint()
        end

        DisableClipping( self.WasClippedDisabled )
        self:PopBackgroundScale()
    end

    local ohover = self._background.TestHover
    self._background.TestHover = function( bg, mx, my )
        mx, my = self:GetZoomedCursorPos(mx, my)
        mx, my = bg:ScreenToLocal( mx, my )
        local bx, by = bg:GetSize()
        return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
    end

    self._background.OnDepressed = function( s )
        if input.IsMouseDown( MOUSE_LEFT ) then
            self.SelectedPanel = nil
        end
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end

    local tools = vgui.Create("DPanel", self)
    tools:SetWide(70)
    tools:SetHeight(self:GetTall()-60)
	tools.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
	end

    local addNode = vgui.Create("DButton", tools)
    addNode:SetSize(60,60)
    addNode:Dock(TOP)
    addNode:DockMargin(6,5,6,5)
    addNode:SetText("Add\nNode")
    addNode.DoClick = function()
		self:OpenNode()
	end
	addNode.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end

    local printEvent = vgui.Create("DButton", tools)
    printEvent:SetSize(60, 60)
    printEvent:Dock(TOP)
    printEvent:DockMargin(6,5,6,5)
    printEvent:SetText("Save\nEvent")
	printEvent.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    printEvent.DoClick = function( pan )
        if not self:SanityCheckNodes() then return end
        local tbl = {
            Name = "",
            oldname = self.Name,
            Nodes = {},
        }

        if self.Imported then
            tbl.oldname = ""
        end

        for index, node in ipairs(self.Nodes) do

            if node.IsOpen then
                node:NodeClose()
            end

            local eventTbl = {
                ID = node.ID,
                Type = node.Type,
                Triggers = {},
                Pos = {},
                _vars = node:GetVars(),
                _toggles = {},
            }

            eventTbl.Pos.x, eventTbl.Pos.y = node:GetPos()

            local nodeData = wOS.PES.Nodes:Get(node.Type)

            if !nodeData and node:IsStart() then
                nodeData = {Triggers = {"Instant"}}
            end

            if self.Links[node] then
                for triggerName, panelTable in pairs(self.Links[node]) do
                    local tbl = {}
                    for _, oPnl in pairs(panelTable) do
                        tbl[#tbl + 1] = oPnl.ID
                    end
                    eventTbl.Triggers[triggerName] = tbl
                end
            end

            if nodeData and nodeData.Vars then
                for name, varData in pairs( nodeData.Vars ) do // make this run a getValue on it.
                    // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                    local var = node:GetVar( name )
                    if var == nil then
                        var = varData.Default
                    end
                    eventTbl._vars[name] = var

                    local disabled = node:GetVarDisabled( name )
                    if not disabled then continue end
                    eventTbl._toggles[name] = disabled
                end
            end

            if nodeData and nodeData.Triggers then
                for index, tdata in ipairs(nodeData.Triggers) do

                    local triggerName = tdata
                    if istable( tdata ) then
                        triggerName = tdata.Type or triggerName
                    end

                    local triggerData = wOS.PES.Triggers:Get(triggerName)
					if not triggerData then break end
                    for name, varData in pairs( triggerData.Vars ) do
                        // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                        local var = node:GetVar( name )
                        if var == nil then
                            var = varData.Default
                        end
                        eventTbl._vars[name] = var
                        local disabled = node:GetVarDisabled( name )
                        if not disabled then continue end
                        eventTbl._toggles[name] = disabled
                    end
                end
            end

            tbl.Nodes[node.ID] = eventTbl
        end
        self:CreateSaveBox( tbl )
    end
    self._tools = tools
end

function PANEL:AddToolBox( tools )
    -- for overrides
end

function PANEL:SetupTool()
    -- for overrides
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:SetDraggable( false )
    dummy_frame:ShowCloseButton( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan )
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Event Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local random = vgui.Create("DTextEntry", dframe)
    random:SetSize(280, 20)
    random:SetPos(10, 110)
    random:SetPlaceholderText("Event Randomness")
    random:SetPlaceholderText("Random Chance")
    if self.random != nil then
        random:SetText(self.random)
    end

    local randombuton = vgui.Create("DCheckBoxLabel", dframe)
    randombuton:SetSize(20,20)
    randombuton:SetPos(10, 90)
    randombuton:SetText("Start Event Randomly?")
    randombuton.OnChange = function(self, val)
        random:SetEnabled(val)
        if !val then random:SetText("") end
    end

    if self.random != nil and self.random != 0 then
        randombuton:SetChecked(true)
        random:SetEnabled(true)
    else
        random:SetEnabled(false)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 140)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave event name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.random = math.Round( math.abs(tonumber(random:GetText()) or 0))
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkEvent(event_tbl)

    end


    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
    self._tools:SetHeight(nH-60)
    self._tools:SetPos(nW - self._tools:GetWide(), 30)
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

function PANEL:GetZoomScale()
    return self.ZoomScale
end


    -- local base_offsetx = lcx - boundx/2
    -- local base_offsety = lcy - boundy/2
    -- local new_lcx, new_lcy = lcx - (boundx/2)*zoomscale, lcy - (boundy/2)*zoomscale
function PANEL:GetZoomedCursorPos(mx, my)
    if self:GetZoomScale() >= 1 then return mx, my end
    local bg = self._background
    local zoomscale = self:GetZoomScale()

    local ox, oy = self:LocalToScreen( self:GetPos() )
    local lcx, lcy = (ScrW() - ox*0.5)*0.5, (ScrH() - oy*0.5)*0.5
    local mouse_offx, mouse_offy = mx - lcx, my - lcy

    mx = lcx + mouse_offx/zoomscale
    my = lcy + mouse_offy/zoomscale

    return mx, my
end

function PANEL:CreateStartNode()
    local start = self:AddNode("Start", true)
    start.Type = nil
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )

    //I pulled this out of the node vgui because this won't always be done
    start.DeleteButton:Remove()
    start.ExpandButton:Remove()
    return start
end

function PANEL:AddNode(name, nofunc)
    local id = #self.Nodes + 1
    local x,y = self:GetCenter()
    local dbutton = vgui.Create("WOS_PES_NODE", self._background)

    dbutton.main = self
	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8
	dbutton:SetSize( wide, tall )
    dbutton:SetPos( x-wide/2, y-tall/2  )

	dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )
    dbutton.TextName = name
	dbutton.Type = name

    if not nofunc then
        dbutton:RecalculateName()
        dbutton:CreateLinks()
    end

    self.Nodes[id] = dbutton

    return dbutton
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = self:GetCursorPos()

    self.mousepos = {x = x, y = y}
end

local speed = 100

function PANEL:OpenEventSelector( events )
    if self.EventList then
        self.EventList:Remove()
    end
    self.EventList = vgui.Create( "DFrame", self )
    self.EventList:SetSize( ScrW(), ScrH() )
    self.EventList:SetTitle( "" )
    self.EventList:ShowCloseButton( false )
    self.EventList:SetDraggable( false )
    self.EventList.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    self.EventList:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    self.EventList.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local impbutt = vgui.Create("DButton", cats)
	impbutt:Dock(BOTTOM)
	impbutt:DockMargin(4,4,4,4)
	impbutt:SetTall(20)
	impbutt:SetText( "Import From URL" )
    impbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 300)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("")
        textentry:SetPos( 10, 35 )
        textentry:SetSize( 280, 130 )
        textentry.Paint = function( pan, ww, hh )
            local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING----------\n\nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
            text = wOS.PES.WrapText( text, "Trebuchet18", ww*0.95 )
            draw.DrawText(text, "Trebuchet18", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
        end

        local utextentry = vgui.Create("DTextEntry", dframe )
        utextentry:SetSize(260, 30)
        utextentry:SetText( "INPUT URL HERE" )
        utextentry:SetPos(20, 180)

        local no = vgui.Create("DButton", dframe)
        no:SetSize(260, 20)
        no:SetText("GO BACK")
        no:SetPos(20, 260)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(260, 20)
        yes:SetText("FETCH EVENT")
        yes:SetPos(20, 230)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            local text = utextentry:GetText()
            if #text < 1 then return end
            wOS.PES.RequestURLImport(text, function( data )
                local estruct = {}
                if data.Event then
                    estruct = data.Event
                else
                    estruct = data
                end
                wOS.PES:OpenNodeMenu( estruct, data.Dirty )
            end )
        end
    end

	local newbutt = vgui.Create("DButton", cats)
	newbutt:Dock(BOTTOM)
	newbutt:DockMargin(4,4,4,4)
	newbutt:SetTall(20)
	newbutt:SetText( "Create New Event" )
    newbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 100)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("Making a new event will completely delete any unsaved progress. Are you sure you want to create a new event?" )
        textentry:SetPos( 10, 5 )
        textentry:SetSize( 280, 65 )

        local no = vgui.Create("DButton", dframe)
        no:SetSize(60, 20)
        no:SetText("No")
        no:SetPos(25, 75)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(60, 20)
        yes:SetText("Yes")
        yes:SetPos(225, 75)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            wOS.PES:OpenNodeMenu(nil,nil,true)
        end
    end

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	for _, data in ipairs( events ) do
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = data.Name
        button.Data = data

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description or "No description available", "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )

            //Add more as we go along
            if data.IsSimulation then
                draw.SimpleText("SIMULATION", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            else
                draw.SimpleText("EVENT", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            end
		end

		button.DoClick = function( pan )

            pnl:Hide()
            local dframe = vgui.Create("DFrame", self.EventList )
            dframe:MakePopup()
            dframe:ShowCloseButton( true )
            dframe:SetDraggable( false )
            dframe:SetSize(300, 100)
            dframe:SetTitle( "" )
            dframe.Think = function( pan )
                pan:MoveToFront()
            end
            dframe.OnClose = function()
                self.EventList:Remove()
            end
            dframe:Center()

            local textentry = vgui.Create("DLabel", dframe )
            textentry:SetWrap( true )
            textentry:SetText("Loading a new layout will completely delete any unsaved progress. Are you sure you want to load this event?\n    NAME: " .. pan.Data.Name )
            textentry:SetPos( 10, 20 )
            textentry:SetSize( 280, 65 )

            local no = vgui.Create("DButton", dframe)
            no:SetSize(60, 20)
            no:SetText("No")
            no:SetPos(25, 75)
            no.Data = pan.Data
            no.DoClick =  function( pann )
                pnl:Show()
                dframe:Remove()
            end

            local yes = vgui.Create("DButton", dframe)
            yes:SetSize(60, 20)
            yes:SetText("Yes")
            yes:SetPos(225, 75)
            yes.Data = pan.Data
            yes.DoClick =  function( pann )
                if pann.DisableButt then return end
                pann.DisableButt = true
                no:Hide()
                yes:Hide()
                textentry:SetText("Fetching your requested layout from the server..\n\nNOTE: This may take a few seconds depending on the size" )
                if pann.Data.IsSimulation then
                    wOS.PES.RequestSimulationData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata.Event, true )
                    end, pann.Data.ID )
                else
                    wOS.PES.RequestEventData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata )
                    end )
                end
            end

		end
		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:OpenEventDeleter()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame )
    dframe:MakePopup()
    dframe:ShowCloseButton( false )
    dframe:SetDraggable( false )
    dframe:SetSize(300, 100)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    local textentry = vgui.Create("DLabel", dframe )
    textentry:SetWrap( true )
    textentry:SetText("This action can not be undone. Are you sure you want to delete this event?" )
    textentry:SetPos( 10, 5 )
    textentry:SetSize( 280, 65 )

    local no = vgui.Create("DButton", dframe)
    no:SetSize(60, 20)
    no:SetText("Cancel")
    no:SetPos(25, 75)
    no.DoClick =  function( pann )
        dummy_frame:Remove()
    end

    local yes = vgui.Create("DButton", dframe)
    yes:SetSize(60, 20)
    yes:SetText("Delete")
    yes:SetPos(225, 75)
    yes.DoClick =  function( pann )
        if self.CreationType == WOS_PES.CREATOR.EVENT then
            net.Start( "wOS.PES.RequestEventDelete" )
                net.WriteString( self.Name )
            net.SendToServer()
        elseif self.CreationType == WOS_PES.CREATOR.SIMULATION then
            net.Start( "wOS.CSS.RequestSimDelete" )
                net.WriteString( self.Name )
            net.SendToServer()

            net.Start("wOS.CombatSim.ResetTool")
            net.SendToServer()
            hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )
            self:GetParent():Remove()
            return
        else return end

        wOS.PES:OpenNodeMenu(nil,nil,true)
    end

end

function PANEL:OpenNode()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    dummy_frame.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	local tbl = wOS.PES.Nodes:GetAll()

	for name, data in SortedPairs(tbl) do
        if data.Hidden then continue end
        if data.UserGroups then
            if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
        end
        if data.SupportedTypes then
            local block = data.SupportedTypes != self.CreationType
            if istable( data.SupportedTypes ) then
                block = !table.HasValue( data.SupportedTypes, self.CreationType )
            end
            if block then continue end
        end
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = name

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description, "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )
		end

		button.DoClick = function( pan )
			self:AddNode(name)
			pnl:Remove()
		end

		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:DragThink()
    local x,y = self:GetCursorPos()
    if !self.mousepos then
        self.mousepos = {x = x, y = y}
    end
    local dX = x - self.mousepos.x
    local dY = y - self.mousepos.y

    local oldMouseY = self.mousepos.y
    self.mousepos = {x = x, y = y}

    self._tx = dX + self._x
    self._ty = dY + self._y
    local posChanged = false

    if self.tx != self._x then
        posChanged = true
        self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
    end

    if self.ty != self._y then
        local x,y = self._background:GetPos()

        posChanged = true
        self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
    end

    if posChanged then
        local aX = self:GetWide()/2 -self._background:GetWide()/2
        local aY = self:GetTall()/2 -self._background:GetTall()/2
        local x,y = self._background:GetPos()

        self._background:SetPos( aX+self._x,  aY + self._y)
    end
end

function PANEL:CopyNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 75 )
    self.StoredPanel = self.SelectedPanel:GetCopy()
end

function PANEL:PasteNode()
    if not self.StoredPanel then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 130 )
    local node = self:AddNode(self.StoredPanel.Type)

    node:SetVars( table.Copy( self.StoredPanel.Vars ) )
	node:SetDisableVars( table.Copy( self.StoredPanel.Toggles ) )
    local bx, by = self:GetCenter()
    local mx, my = self:GetCursorPos()
    mx = mx - ScrW()/2
    my = my - ScrH()/2
    local sw, sh = node:GetSize()
    node:SetPos( bx + mx - sw/2, by + my - sh/2 )
end

function PANEL:CutNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    self:CopyNode()
    self:NodeRemove(self.SelectedPanel)
end

function PANEL:ComboThink()

    if input.IsKeyDown( KEY_DELETE ) then
        if not IsValid( self.SelectedPanel ) then return end
        self:NodeRemove( self.SelectedPanel )
        self.SelectedPanel = nil
        self.LastKey = 0
        return
    end

    // Yo I hate the way this is done but it pretty much ensures you don't accidentally fuck a node up, so it stays until a better way

	// one for loop and if it doesn't break check last key?
	if input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL ) then
        if input.IsKeyDown( KEY_C ) then
            self.LastKey = KEY_C
        elseif input.IsKeyDown( KEY_V ) then
            self.LastKey = KEY_V
        elseif input.IsKeyDown( KEY_X ) then
            self.LastKey = KEY_X
        else
            if self.LastKey == KEY_C then
                self:CopyNode()
            elseif self.LastKey == KEY_V then
                self:PasteNode()
            elseif self.LastKey == KEY_X then
                self:CutNode()
            end
            self.LastKey = 0
        end
    end
end

function PANEL:OnMouseWheeled( delta )
    if not (input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL )) then return end
    self.ZoomScale = math.Clamp( self.ZoomScale + delta*0.02, 0.1, 1 )
end


function PANEL:Think()

    if not self.ToolBoxHook then
        self:AddToolBox( self._tools )
        self.ToolBoxHook = true
    end

    if self.Dragging then
        self:DragThink()
        return
    end

    self:ComboThink()

end

function PANEL:StopDragging()
    self.Dragging = false
end

/*
	Name: wOS.PES:MakeLink(pnl, oPnl, type)
	Description: Make a link to a node using the trigger Type
	Args: Panel pnl, Panel oPnl, String type
	Returns: boolean success
*/
function PANEL:MakeLink(pnl, oPnl, type)
    if pnl == oPnl then return false end
    if not oPnl then return false end
    if not oPnl:GetMainLink() then return false end
    self.Links[pnl] = self.Links[pnl] || {}
    self.Links[pnl][type] = self.Links[pnl][type] || {}
    if table.HasValue(self.Links[pnl][type], oPnl) then return false end
    table.insert(self.Links[pnl][type], oPnl)
	return true
end

/*
	Name: wOS.PES:RemoveLink(pnl, type, oPnl = nil)
	Description: Removes either a single link of all links of the trigger type
	Args: Panel pnl, String type, Panel oPnl
	Returns: boolean success
*/

function PANEL:RemoveLink(pnl, type, oPnl)
    if not self.Links[pnl] then return false end
    if not self.Links[pnl][type] then return false end

    if oPnl then
        table.RemoveByValue(self.Links[pnl][type],oPnl)
    else
        self.Links[pnl][type] = {}
    end

    return true
end

function PANEL:GetLinks(pnl)
    return self.Links[pnl] || {}
end

/*
	Name: wOS.PES:NodeRemove(node)
	Description: Removes a node from the menu
	Args: Panel node
	Returns: boolean success
*/
function PANEL:NodeRemove(node)
    if node:IsStart() then return false end
    self.Links[node] = nil

    local id = 1

    if IsValid(node) then
        node:Remove()
    end

    local invalidIndexs = {}

    for index, node in ipairs(self.Nodes) do
        if !IsValid(node) then
            invalidIndexs[#invalidIndexs + 1] = index
        else
            node.ID = id
            id = id + 1
            if not node:IsStart() then
                node:RecalculateName()
            end
        end
    end

    for x = 1, #invalidIndexs do
        table.remove(self.Nodes,invalidIndexs[#invalidIndexs])
    end
	return true
end

function PANEL:SelectNode( pan )
    self.SelectedPanel = nil
    if not IsValid( pan ) then return end
    self.SelectedPanel = pan
end

function PANEL:SanityCheckNodes()
    local TK_OK = true
    local ends = false
    for index, node in ipairs(self.Nodes) do
        if node.Type == "End" then
            ends = true
        end
        node:RecalculateDirty()
        if not node.NodeDirty then continue end
        TK_OK = false
    end

    if not TK_OK then
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: Nodes have unresolved errors ( make sure all variables are filled out! )", NOTIFY_ERROR, 3 )
    end

    if not ends then
        TK_OK = false
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: No END node to terminate event logic ( infinite events consume memory )", NOTIFY_ERROR, 3 )
    end

    return TK_OK
end

function PANEL:Paint()
    local globs = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs( globs ) do
        local class = child:GetClassName()
        if not ( child.SetLegacyType ) and not ( child.StartTime and child.fx and child.fy ) then continue end
        child:MakePopup()
    end
end

function PANEL:GetCursorPos()
    return self:GetZoomedCursorPos( input.GetCursorPos() )
end

vgui.Register( "WOS_PES_NodeBG", PANEL, "Panel" )
--addons/wos-passiveevent/lua/wos/pes/addons/camera/cl_core.lua:

local pesCameraPathInfo = {}

local removeCamera = function( id )
	hook.Remove("CalcView", "!!wOS.PES.CameraPath" .. id)
	hook.Remove("Think", "!!wOS.PES.CameraPath" .. id)
	hook.Remove("ThirdPerson.CanThirdPerson", "!!wOS.PES.CameraPath" .. id)
	pesCameraPathInfo[id] = nil
end

local startCamera = function(id, path, speed)
	pesCameraPathInfo[id] = {}
	pesCameraPathInfo[id].path = path
	pesCameraPathInfo[id].speed = speed
	pesCameraPathInfo[id].current = 1

	hook.Add("CalcView", "!!wOS.PES.CameraPath" .. id, function(ply, pos, ang, fov, znear, zfar)
	
		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera()
			return
		end

		local currentVal = math.floor(pesCameraPathInfo[id].current)

		local current = pesCameraPathInfo[id].path[currentVal]
		local next = pesCameraPathInfo[id].path[currentVal + 1]

		if not current or not next then return end

		local lerpVal = pesCameraPathInfo[id].current - currentVal
		local pos = LerpVector(lerpVal, current.Vector, next.Vector)
		local ang = LerpAngle(lerpVal, current.Angle, next.Angle)

		return {
			origin = pos,
			angles = ang,
			fov = fov,
			znear = znear,
			zfar = zfar,
			drawviewer = true
		}
	end)

	hook.Add("ThirdPerson.CanThirdPerson", "!!wOS.PES.CameraPath" .. id, function()
		return false
	end)

	hook.Add("Think", "!!wOS.PES.CameraPath" .. id, function()
		pesCameraPathInfo[id].current = pesCameraPathInfo[id].current + pesCameraPathInfo[id].speed * FrameTime()

		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera( id )
			return
		end
	end)

end
net.Receive("wOS.PES.StartCamera", function(len)
	local id = net.ReadUInt( 32 )
	local path = net.ReadTable()
	local speed = net.ReadFloat()
	
	startCamera(id, path, speed)
end)

net.Receive("wOS.PES.EndCamera", function(len)
	local id = net.ReadUInt( 32 )
	removeCamera( id )
end)
--addons/wos-passiveevent/lua/wos/pes/addons/map/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addons = {}

wOS.PES.Modules:RegisterAddon( "map", addons )

net.Receive( "wOS.PES.Maps", function()
	addons.Maps = net.ReadTable()
end )
--addons/wos-passiveevent/lua/wos/pes/core/sh_var_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Vars = wOS.PES.Vars || {}
wOS.PES.Vars.Data = wOS.PES.Vars.Data || {}


function wOS.PES.Vars:Autoloader()
    for _,source in pairs( file.Find( "wos/pes/vars/*", "LUA"), true ) do

        local lua = "wos/pes/vars/" .. source
        if SERVER then AddCSLuaFile(lua) end
		local varData = include(lua)

        if !varData then
            print("ERROR: " .. source .. " this variable is invalid")
            continue
        end

        varData.ToolTips = varData.ToolTips or {}
        local default_hint = {
            key = "gui/r.png",
            text = "Return to the Node Layout Menu",
        }
        table.insert( varData.ToolTips, 1, default_hint )

        self.Data[varData.Name] = varData
    end
end

function wOS.PES.Vars:GetAll()
    return wOS.PES.Vars.Data
end

function wOS.PES.Vars:Get(name)
    if not name then return end
    return self.Data[name]
end

wOS.PES.Vars:Autoloader()
--addons/wos-passiveevent/lua/wos/pes/vars/angle.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Angle"
VAR.UseTool = true
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Save your current aiming angles", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not isangle(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isangle(self.Value) then
            draw.SimpleText("Angle set at: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Angle needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Value
end

VAR.PrimaryAttack = function(wep, ply, panel)
    panel.Value = ply:EyeAngles()
end

VAR.OnStart = function(node, value, var)
    if !isangle(value) then

        local vec = Angle(value)
        if vec then
            node:SetVar(var.Name, vec)
        end
    end
end

VAR.Draw3D = function(wep, ply, element)
    local ang = element.Value
    if not isangle(vec) then return end

    local pos = EyePos()
    render.DrawLine(pos, pos + ang:Forward() * 30 , Color(255, 255, 255), false)
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/bounds.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}
VAR.Name = "Bounds"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT as a boundary point", key = "gui/lmb.png", },
    { text = "Add your current EYE position as a boundary point", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position as a boundary point", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the boundary points", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if table.Count(value) < 1 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end



VAR.DermaElement = function(varTable, value)
    if not istable(value) then value = {} end
    local dermaElement = vgui.Create("DPanel")
    dermaElement.Corners = value.Corners or {}

    local heightSelector = vgui.Create("DNumberWang", dermaElement)
    heightSelector:DockMargin(6,2,6,2)
    heightSelector:SetTall(30)
    heightSelector:Dock(LEFT)
    heightSelector:SetDecimals(0)
    heightSelector:SetMin( minCount or 1 )
    heightSelector:SetMax( maxCount or math.huge )
    heightSelector:SetValue(value.Height or 200)
    dermaElement.HeightSelector = heightSelector

    function dermaElement:PerformLayout(ww, hh)
        heightSelector:SetWide(ww * 0.25)
    end
    function dermaElement:Paint(ww, hh)
        draw.SimpleText("Height", nil, ww * 0.45, hh * 0.5, Color(0,0,0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

        draw.SimpleText("|", nil, ww * 0.5, hh * 0.5, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        draw.SimpleText("Corners: " .. #(dermaElement.Corners), nil, ww * 0.55, hh * 0.5, Color(0,0,0), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return dermaElement
end

VAR.GetValue = function(dermaElement)
    -- Return Debug Format Template
    local value = {
        Corners = dermaElement.Corners or {},
        Height = math.floor(dermaElement.HeightSelector:GetValue()),
    }

    -- Prepare values for more effiecient use.
    value.PreparedBorderValues = {}
    for i, borderPoint in pairs(value.Corners) do
        value.PreparedBorderValues[i] = {
            v = borderPoint
        }
    end

    local j = table.Count(value.Corners)
    for i=1, table.Count(value.Corners) do
        local borderI = value.PreparedBorderValues[i].v
        local borderJ = value.PreparedBorderValues[j].v

        if borderJ.y == borderI.y then
            value.PreparedBorderValues[i].c = borderI.x
            value.PreparedBorderValues[i].m = 0
        else
            value.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
            value.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
        end

        j = i
    end

    return value
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    table.insert(dermaElement.Corners, pos )
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Corners[#(dermaElement.Corners)] = nil
end

VAR.OnStart = function(node, varData, var)

end

VAR.OnEnd = function(node, varData, var)

end

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end

		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

VAR.Draw3D = function(wep, ply, element)
    DrawBorders(element.Corners, element.HeightSelector:GetValue(), Color(255, 255, 255))
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/entity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Entity"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to be saved", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    -- TODO


    if #varTable == 0 then
        return false
    end


    return true
end

VAR.DermaElement = function(varTable, varData)
    if !varData then varData = {} end
    local element = vgui.Create("DModelPanel")

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data = {
            Model = ent:GetModel(),
            Position = ent:GetPos(),
            Angle = ent:GetAngles(),
            Class = ent:GetClass(),
            // read var data
            // read bodygroup
            // read pose
        }
    end
end
 
VAR.OnStart = function(node, varData, var)
    if varData != {} then return end
    local entData = varData

    local ent = wOS.PES:SpawnEntity(entData)
    
    if not ent then return end 

    if not istable( ent ) then
        node:SetVar(var.Name, ent)
        return
    end

    -- // This enforces the first entry without having to hunt for it
    -- for _, entity in pairs( ent ) do
    --     node:SetVar( var.Name, entity )
    --     return
    -- end

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    if IsValid(varData) then
        varData:Remove()
    end
end

VAR.Draw3D = function(wep, ply, element)
    local ent = element.Values
    if ent then
        if not isvector(ent.Position) then return end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/multi_select.lua:

local VAR = {}

VAR.Name = "Multi Select"

VAR.IsValid = function(varTable, value)
	if (value == nil) then return false end
	if (type(value) != "table") then return false end

	return true
end

VAR.GetValue = function(dermaElement)

	local lines = dermaElement:GetSelected()

	local value = {}

	for k, v in pairs(lines) do
		local a = dermaElement.varTable.Values[v:GetColumnText(1)]
		value[k] = a  
	end

	return value
end

VAR.DermaElement = function(varTable, value)
	value = value or {}

	local bgPanel = vgui.Create("DListView")
	bgPanel.varTable = varTable
	bgPanel:AddColumn("Name")
	bgPanel.Values = value

	for k, v in pairs(varTable.Values) do
		local pnl = bgPanel:AddLine(k)
		
		if value[k] then
			bgPanel:SelectItem(pnl)
		end
	end
		
	bgPanel:SetTall(300)
	
	return bgPanel
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/pathvar.lua:

local VAR = {}

VAR.Name = "Path"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Add the position and angle you are AIMING AT to the path", key = "gui/lmb.png", },
    { text = "Add your current EYE position and angle to the path", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position and angle to the path", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position and angle from the path", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

	if (value == nil) then return false end
	if type(value) != "table" then return false end


	if #value != table.Count(value) then return false end

	if #value  < 1 then return false end

	return true
end

VAR.GetValue = function(element)
    if element.Path then
        return element.Path
    end
end

VAR.PrimaryAttack = function(wep, ply, element)
	element.Path = element.Path or {}

    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end

    local ang = ply:EyeAngles()
    
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end

	table.insert(element.Path, {
		Vector = pos,
		Angle = ang,
	})
    panel:RefreshList()
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    panel.Path = value

    function panel:Paint(ww, hh) end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Vector")
    listView:AddColumn("Angle")    
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Path or #panel.Path < 1 then
            pan:AddLine( "Path needs to be set!" )
            return
        end

        for id, vdata in pairs( panel.Path or {} ) do
            local line = pan:AddLine( vdata.Vector, vdata.Angle )
            line.ID = id
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
        table.remove( panel.Path, line.ID )
        pan:RefreshList()
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel
end

VAR.SecondaryAttack = function(wep, ply, element)
	element.Path = element.Path or {}
	if #element.Path > 0 then
		table.remove(element.Path, #element.Path)
	end
end

VAR.Draw3D = function(wep, ply, element)
	local path = element.Path or {}

	for _, v in pairs(path) do
		local pos = v.Vector
		local ang = v.Angle

		local pos2 = pos + ang:Forward() * 10

		render.DrawLine(pos, pos2, Color(0, 0, 0), true)
		render.DrawWireframeSphere(pos, 5, 10, 10, Color(255, 255, 255, 255))
	end
end

return VAR
--addons/wos-passiveevent/lua/wos/pes/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS || {}
wOS.PES = wOS.PES || {}
wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}
wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

local function QuickSort( a, b )
    return a[2] < b[2]
end

net.Receive("wOS.PES.Triggers.Sync",function()
    local size = net.ReadUInt( 32 )
    wOS.PES.Triggers.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )
end)

net.Receive("wOS.PES.Nodes.Sync",function()

    local size = net.ReadUInt( 32 )
    wOS.PES.Nodes.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )

	// We're gonna do the sorting clientside because really it only effects the client
	for name, data in pairs( wOS.PES.Nodes.Data ) do
		if not data.Vars then continue end

		local sort_tbl = {}

		for name, dat in pairs( data.Vars ) do
			table.insert( sort_tbl, { name, dat.ID } )
		end

		table.sort( sort_tbl, QuickSort )

		data.SortedVars = {}
        for _, dat in ipairs( sort_tbl ) do
            table.insert( data.SortedVars, dat[1] )
        end
	end

end)

/*
	Name: wOS.PES.NetworkEvent(event)
	Description: Networks an event in a header and body packets to the server
	Args: EventData event
	Returns: None
*/
function wOS.PES.NetworkEvent(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.PES.EventHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
        net.WriteDouble(event.random or -1)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.PES.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.PES.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()
        end )    
    end

    -- net.Start("wOS.PES.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

function wOS.PES.NetworkSimulation(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.CSS.SimulationHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
		net.WriteTable(event.Settings)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.CSS.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.CSS.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()    
        end )
    end

    -- net.Start("wOS.CSS.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

/*
	Name: wOS.PES.RequestEventList(callback)
	Description: Requests the event list from the server and calls the callback function
	Args: function callback
	Returns: None
*/
function wOS.PES.RequestEventList(callback)

    callback = callback or function() end

    net.Start("wOS.PES.EventList")
        net.WriteString("")
    net.SendToServer()

    net.Receive("wOS.PES.EventList",function()
        local missionNames = net.ReadTable()
        callback(missionNames)
    end)
end

function wOS.PES.RequestAdminSync(id, callback)
	net.Start("wOS.PES.Admin.Sync")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.Admin.Sync", callback)
end

function wOS.PES.RequestOpenAdminPreMenu()

	net.Start("wOS.PES.RequestPreAdminMenu")
	net.SendToServer()

	net.Receive("wOS.PES.RequestPreAdminMenu", function()
		local events = net.ReadTable()
		wOS.PES:OpenAdminActiveList( events )
	end)
end

function wOS.PES.RequestOpenAdminViewer( id )

	net.Start("wOS.PES.RequestAdminMenu")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.RequestAdminMenu", function()
		local nodes = net.ReadActivePESEvent()
		wOS.PES:OpenAdminEventViewer(id, nodes)
	end)
end

function wOS.PES.RequestSchedule(callback)
	net.Start("wOS.PES.RequestSchedule")
	net.SendToServer()

	net.Receive("wOS.PES.RequestSchedule", function()
		local eventCount = net.ReadUInt(16)

		local eventList = {}

		for x = 1, eventCount do
			local name = net.ReadString()
			local map = net.ReadString()
			local time = net.ReadUInt(32)

			eventList[x] = {
				Name = name,
				Time = time,
				Map = map,
			}
		end

		callback(eventList)
	end)
end

function wOS.PES.RequestStop( id )
	net.Start("wOS.PES.RequestStop")
		net.WriteUInt( id, 32 )
	net.SendToServer()
end

function wOS.PES.RequestEventData(name, callback)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.RequestEventData")
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        event, err = wOS.SFS_EXTERN:Decompress( fcompressed )

        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    -- net.Receive("wOS.PES.EventDataPrepare",function()
    --     if event.Processed then return end
    --     local dChecksum = net.ReadDouble()
    --     if dChecksum != checksum then return end

    --     local header = net.ReadPESEventHeader()
    --     table.Merge( event, header )

    --     if not event.BackupNodeCount then return end
    --     if event.BackupNodeCount < event.NodeCount then return end
    --     event.Processed = true
    --     event.BackupNodeCount = nil
	-- 	callback(event)
    -- end)

end

function wOS.PES.GetImportableEvents(callback, full)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableEvents" )
        net.WriteBool( full or false )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableEvents",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.GetImportableSimulations(callback)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableSimulations" )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableSimulations",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.RequestSimulationData(name, callback, sim)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.CSS.RequestSimulationData")
        net.WriteUInt( sim or 0, 32 )
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local simdata = {
		Settings = {},
        Event = {},
    }

    local segments = {}
    
    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )
    
end

function wOS.PES.RequestEventStart(eventName)
    if not eventName then return end
    net.Start("wOS.PES.RequestStart")
        net.WriteString(eventName)
    net.SendToServer()
end

function wOS.PES.RequestEventStartTime(eventName, time)
	net.Start("wOS.PES.RequestStartTime")
		net.WriteString(eventName)
		net.WriteDouble(time)
	net.SendToServer()
end

function wOS.PES.RequestTriggerStart(eventid, nodeid, triggerName)
	net.Start("wOS.PES.RequestTriggerStart")
		net.WriteUInt( eventid, 32 )
		net.WriteDouble(nodeid)
		net.WriteString(triggerName)
	net.SendToServer()
end

function wOS.PES.RequestURLImport(url, callback)
    if not url then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.Import.RequestURLEvent")
        net.WriteString(url)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}
    local simdata = {
        Name = name,
		Description = "",
        Nodes = {},
		Settings = {},
        Count = 0,
    }

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )

        event = wOS.SFS_EXTERN:Decompress( fcompressed )
        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )

end

net.Receive( "wOS.PES.Import.URLError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( msg, NOTIFY_ERROR, 6 )
end )

net.Receive( "wOS.PES.Export.SendLink", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button14.wav" )
    notification.AddLegacy( "[wOS-PES] Event was successfully exported to a URL! Check your chat for the link.", NOTIFY_GENERIC, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event has been successfully exported to the following link: ", Color( 66, 117, 176 ), msg )
end )

net.Receive( "wOS.PES.Export.SendError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( "[wOS-PES] Event failed to be exported to URL. Check your chat for the error.", NOTIFY_ERROR, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event failed to upload with the following error: ", Color( 255, 0, 0 ), msg )
end )



--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_menu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4

function PANEL:Init()
	self:DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:PerformLayout()
	local w, h = self:ChildrenSize()
	self:SetSize(math.max(self:GetMinimumWidth(), w), h)
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)

function Panel:Init()
	self:ScaleInit()

	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob.circle = {}
	self.Knob.Paint = self.KnobPaint
	self:SetTrapInside(true)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	self.Knob:SetSize(SUI.Scale(12), SUI.Scale(12))
	DSlider.PerformLayout(self, w, h)
end

sui.register("Slider", Panel, "DSlider")
--addons/sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local vbar = self:GetChildren()[1]
	if vbar then
		wide = wide - vbar:GetWide()
	end

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")
--addons/scb_chatbox/lua/scb/vgui/scb_emojis.lua:
if SCB_LOADED then return end

local draw = draw
local IsValid = IsValid
local math = math
local pairs = pairs
local table = table
local SortedPairsByMemberValue = SortedPairsByMemberValue
local timer = timer

local scb = scb
local sui = sui
local SUI = scb.SUI
local language = scb.language

local Panel = {}

local flag = "flag_" .. (system.GetCountry() or ""):lower()
local categories = {
	People = {1, "grinning"},
	Nature = {2, "cat"},
	Food = {3, "watermelon"},
	Activities = {4, "person_in_lotus_position"},
	Travel = {5, "desert_island"},
	Objects = {6, "coffee"},
	Symbols = {7, "question"},
	Flags = {8, scb.emojis[flag] and flag or "flag_eg"},
	Custom = {9, "unlock"}
}

local generate_emojis = function()
	for k, v in pairs(categories) do
		local key = tostring(v[1])
		local emojis = {}

		local i, max_pos = 1, -math.huge
		for name, cat in pairs(scb.emojis) do
			local pos = i
			if not scb.is_custom_emoji(cat) then
				cat, pos = cat:sub(1, 1), tonumber(cat:sub(2))
			end

			if cat ~= key and (k ~= "Custom" or not scb.is_custom_emoji(cat)) then continue end

			emojis[pos] = name
			max_pos = math.max(max_pos, pos)

			i = i + 1
		end

		v[3] = emojis
		v[4] = max_pos
	end
end
generate_emojis()
hook.Add("SCB.EmojisModified", "FixEmojis", generate_emojis)

local DoClick = function(s)
	local text_entry = scb.chatbox.text_entry
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. s.name .. ": ")

	s.parent:Remove()
end

local hovered_color = Color(50, 50, 50, 150)
local emoji_Paint = function(s, w, h)
	if s.parent.selected == s then
		s.search_field:SetPlaceholder(":" .. s.name .. ":")
		draw.RoundedBox(0, 0, 0, w, h, hovered_color)
	end
end

local emoji_OnCursorEntered = function(s, w, h)
	s.parent.selected = s
end

local category_list_Paint = function(_, w, h)
	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
end

local make_category_list = function(parent, columns)
	local category_list = parent:Add("SCB.ThreeGrid")
	category_list:Dock(FILL)
	category_list:DockMargin(2, 0, 2, 2)
	category_list:GetCanvas():DockPadding(2, 2, 2, 2)
	category_list:InvalidateParent(true)
	category_list:SetWide2(category_list:GetWide() - (SUI.Scale(4) * 2))
	category_list:InvalidateParent(true)

	category_list:SetColumns(columns)
	category_list:SetHorizontalMargin(4)

	category_list.Paint = category_list_Paint

	return category_list
end

local add_emoji = function(self, emoji, category_list, search_field)
	if not IsValid(category_list) then return end

	local emoji_size = SUI.ScaleEven(28)

	local pnl = vgui.Create("DButton")
	pnl:SetTall(emoji_size)
	category_list:AddCell(pnl)

	pnl:SetSize(emoji_size, emoji_size)
	pnl:SetText("")
	pnl:SetTooltip(emoji)

	pnl.parent = self
	pnl.name = emoji
	pnl.search_field = search_field
	pnl.Paint = emoji_Paint
	pnl.OnCursorEntered = emoji_OnCursorEntered
	pnl.DoClick = DoClick

	local img = pnl:Add("SCB.Image")
	img:Dock(FILL)
	img:DockMargin(3, 3, 3, 3)
	img:SetMouseInputEnabled(false)

	local info = scb.emojis[emoji]
	img:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. emoji .. ".png"))
end

function Panel:Init()
	local has_permission = scb.has_permission(LocalPlayer(), "custom_emojis")
	local categories_n = table.Count(categories) - (has_permission and 0 or 1)

	self.tabs_tall = 30
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	self:SetFont(SCB_14)

	self.w = self.tab_scroller:GetTall() * categories_n
	self.h = self.w + 10

	self:InvalidateLayout(true)

	self.tab_scroller:Dock(BOTTOM)

	local emoji_size = SUI.ScaleEven(28)
	local columns = math.floor(self.w / emoji_size) - 1

	local search_field = self:Add("SCB.TextEntry")
	search_field:Dock(TOP)
	search_field:DockMargin(2, 2, 2, 2)
	search_field:SetPlaceholder(language.search)
	search_field:SetMouseInputEnabled(true)
	search_field:SetNoBar(true)

	local old_Paint = search_field.Paint
	function search_field:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function search_field.OnValueChange(s, value)
		if value == "" then
			if IsValid(s.search_body) then
				s.search_body:Remove()
			end
			self:SetActiveTab(self.tabs[1])
			search_field:SetPlaceholder(language.search)
			return
		end

		value = value:gsub(":", ""):lower()

		local search_body = s.search_body
		if not IsValid(search_body) then
			self:SetActiveTab(nil)

			search_body = self:Add("Panel")
			s.search_body = search_body
		end

		search_body:Dock(FILL)
		search_body:InvalidateParent(true)
		search_body:Clear()

		local category_list = make_category_list(search_body, columns)

		local main_i = 0
		for k, v in SortedPairsByMemberValue(categories, 1) do
			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end
				if not emoji:find(value) then continue end

				timer.Simple(main_i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)

				main_i = main_i + 1
			end
		end
	end

	function self.tab_scroller:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("header"))
	end

	for k, v in SortedPairsByMemberValue(categories, 1) do
		if k == "Custom" and not has_permission then continue end

		self:AddSheet(SUI.Material("scb/emojis/" .. v[2] .. ".png"), function(parent)
			local category_list = make_category_list(parent, columns)

			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end

				timer.Simple(i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)
			end

			return category_list
		end):SetTooltip(k)
	end

	self:MakePopup()
	self:ParentToHUD()

	search_field:RequestFocus()

	hook.Add("VGUIMousePressed", self, function(_, panel, mouse_code)
		if self == panel then return end
		if self:IsOurChild(panel) then return end
		if mouse_code ~= MOUSE_LEFT then return end
		if panel == self.button then return end
		if panel == scb.chatbox.header then return end

		self:Remove()
	end)
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("frame"))
end

function Panel:OnKeyCodePressed(key_code)
	if key_code == KEY_ENTER and IsValid(self.selected) then
		self.selected:DoClick()
	end
end

local anim_speed = 0.2
function Panel:FixPos()
	local w, h = self.w, self.h

	self:SetSize(s, w * 1.1, h * 1.1)
	self:SetPos(self:_GetPos())
	self:SetAlpha(0)

	self:SizeTo(w, h, anim_speed, 0, -1)
	local x, y = self:_GetPos(w, h)
	self:MoveTo(x, y, anim_speed, 0, -1)
	self:AlphaTo(255, anim_speed + 0.02, 0, function()
		self.Think = self._Think
	end)
end

function Panel:_GetPos(m_w, m_h)
	local button = self.button

	if not m_w then
		m_w, m_h = self:GetSize()
	end

	local x, y, w = button:GetBounds()
	x, y = button:LocalToScreen(0, 0)
	x = x - (m_w / 2 - w / 2)
	y = y - m_h - 4

	return x, y
end

function Panel:_Think()
	self:SetPos(self:_GetPos())
	self:MoveToFront()
end

sui.register("EmojiList", Panel, "SCB.PropertySheet")
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/burned.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Brandschaden"
Injury.Treatments = {
	["plate"] = true,
	["welder"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		-- Selects the damage type
		local damageTypes = {[DMG_AIRBOAT] = true, [DMG_BULLET] = true, [DMG_BURN] = true, [DMG_SLOWBURN] = true, [DMG_ENERGYBEAM] = true, [DMG_PLASMA] = true, [DMG_DIRECT] = true}
		if damageTypes[dmgInfo:GetDamageType()] then
			-- Runs the injury addition
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "burned")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'burned' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end

		-- Other lightsaber handling
		if dmgInfo:GetDamageType() == 101010 then
			local hitgroups = {"Rechter Arm", "Linker Arm", "Rechtes Bein", "Linkes Bein", "Thorax", "Abdomen"}

			-- Runs the injury addition
			local success, message = Medicsystem:AddInjury(ply, table.Random(hitgroups), dmgInfo:GetDamage(), "burned")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'burned' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("burned", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/dent.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Delle"
Injury.Treatments = {
	["plate"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_CLUB then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "dent")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'dent' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("dent", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/dermaseal.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Dermaseal"
Treatment.Description = "Dermaseal war eine medizinische Substanz, die, wenn sie auf die Haut gesprüht oder gebürstet wurde, eine Wunde sicher bedeckte und versiegelte. Dadurch schützte sie vor Infektionen."

Treatment.TreatmentTime = 3
Treatment.UseMessage = "verwendet Dermaseal."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "player/sprayer.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" sprühte ",
		self.Name,
		" über ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("dermaseal", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/dimitalis.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Dimitalis"
Treatment.Description = "Ein Gift, welches den Anschein macht, das Opfer sei an einer natürlichen Ursache gestorben. Dimitalis selbst ist nicht nachweisbar. Anzeichen für eine Vergiftung ist Blässe."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet Dimitalis."

Treatment.Type = {["SWT"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	-- Don't inject it yourself
	if patient == ply then return false end

	return patient:IsPlayer()
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	-- Don't run several latheniol timers
	if timer.Exists("Medicsystem.Dimitalis_" .. patient:SteamID64()) then return end

	-- Kills the patient slowly
	if patient:Alive() then
		-- Creates the dimitalis kill timer
		local round = 1
		timer.Create("Medicsystem.Dimitalis_" .. patient:SteamID64(), 3, 4, function()
			if not IsValid(patient) then return end

			-- If Player is already dead, dimitalis kills him finally
			if not patient:Alive() or round > 3 then
				Medicsystem:Kill(patient)

				timer.Remove("Medicsystem.Dimitalis_" .. patient:SteamID64())
				return
			end

			-- Takes 25% of max health
			local damage = patient:GetMaxHealth() * 0.25
			patient:TakeDamage(damage)

			round = round + 1
		end)
	else
		Medicsystem:Kill(patient)
	end
end

Medicsystem:RegisterTreatment("dimitalis", Treatment)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/laserscalpel.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Laserskalpell"
Treatment.Description = "Mit diesem hochpräzisen, chirurgischen Werkzeug können präzise Schnitte vorgenommen werden."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet ein Laserskalpell."

Treatment.Type = {["Opkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/buzz.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	if injury.name == "Innere Blutung" then return true end

	return false
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" führt mit Hilfe eines Laserskalpells einen Schnitt am Körperteil ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" durch."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("laserscalpel", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/quickwake.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Quickwake"
Treatment.Description = "Ein Mittel um bewusstlose Personen wieder zu wecken."

Treatment.TreatmentTime = 4
Treatment.UseMessage = "verwendet Quickwake."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if patient:IsPlayer() then return true end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	if patient:Alive() then
		local dmgInfo = DamageInfo()
		dmgInfo:SetDamageType(DMG_POISON)
		dmgInfo:SetDamage(10)
		patient:TakeDamageInfo(dmgInfo)

		Medicsystem:AddInjury(patient, hitgroup, dmgInfo:GetDamage(), "poisoning")
		return false
	end

	if patient:GetNWBool("Medicsystem.IsDead", false) then return false end

	timer.Simple(0.3,function()
		if IsValid(patient) then
			DeathSystem:Revive(patient)
			Medicsystem:CalculateHealth(patient)
		end
	end)
end

Medicsystem:RegisterTreatment("quickwake", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/splint.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Schiene"
Treatment.Description = "Eine Schiene ist ein medizinisches Hilfsmittel, das zur Ruhigstellung von traumatisierten oder erkrankten Körperteilen oder zur Korrektur von Fehlstellungen eingesetzt wird. Dabei werden die Gelenke in einer bestimmten Position fixiert."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "legt eine Schiene an."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" legte ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" eine ",
		self.Name,
		" an."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("splint", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/symoxin.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Symoxin"
Treatment.Description = "Ein Mittel, um Personen (länger) zu betäuben."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet Symoxin."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	-- Don't inject it yourself
	if patient == ply then return false end

	return patient:Alive()
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	-- Don't run several symoxin timers
	if timer.Exists("Medicsystem.Symoxin_" .. patient:SteamID64()) then return end

	local round = 1
	timer.Create("Medicsystem.Symoxin_" .. patient:SteamID64(), 3, 4, function()
		if not IsValid(patient) or not IsValid(ply) then return end

		-- If Player is already dead removes the timer
		if not patient:Alive() or not ply:Alive() then
			timer.Remove("Medicsystem.Symoxin_" .. patient:SteamID64())
			return
		end

		if round > 3 then
			DeathSystem:Stun(patient, 60)

			timer.Remove("Medicsystem.Symoxin_" .. patient:SteamID64())
			return
		end

		-- Takes 25% of max health
		local damage = patient:GetMaxHealth() * 0.25
		if patient:Health() <= damage then
			DeathSystem:Stun(patient, 60)
		else
			patient:TakeDamage(damage)
		end

		round = round + 1
	end)

	return true
end

Medicsystem:RegisterTreatment("symoxin", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/concussion.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Gehirnerschütterung"
Injury.Treatments = {
	["antishock"] = true,
}

Injury.scanNeeded = true

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_SONIC then
			local success, message = Medicsystem:AddInjury(ply, "Kopf", dmgInfo:GetDamage(), "concussion")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'concussion' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,

	["Medicsystem.AddedInjury"] = function(ply, hitgroup, injury, damage, severity)
		-- Ragdolls cannot have concussion
		if ply:IsRagdoll() then return end

		if hitgroup == "Kopf" and injury == "crush" and severity >= 3 then
			-- It is unlikely that concussion will occur.
			if math.random(0, 1) < 0.8 then return end

			-- Adds the concussion
			local success, message = Medicsystem:AddInjury(ply, "Kopf", damage, "concussion")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'concussion' to player " .. ply:Nick() .. "(" .. message .. ").")
			end

			-- Activates the concussion effect
			Medicsystem:ToggleEffect(ply, "concussion", true)
		end
	end,

	["Medicsystem.InjuryTreated"] = function(ply, hitgroup, injury)
		if injury == "concussion" then
			-- For ragdolls, no effect needs to be removed
			if ply:IsRagdoll() then return end

			-- Disables the concussion effect
			Medicsystem:ToggleEffect(ply, "concussion", false)
		end
	end,

	["PlayerSpawn"] = function(ply)
		-- If the injuries persist, nothing is removed.
		if ply.KeepInjured then return end

		-- Disables the concussion effect
		Medicsystem:ToggleEffect(ply, "concussion", false)
	end,

	["Medicsystem.AdminHealed"] = function(ply)
		-- Disables the concussion effect
		Medicsystem:ToggleEffect(ply, "concussion", false)
	end
}

Injury.Effect = {
	hookName = "RenderScreenspaceEffects",
	material = "effects/tp_eyefx/tpeye",
	refract = 0.3
}

Medicsystem:RegisterInjury("concussion", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/disintegrated.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Disruptor"
Injury.Treatments = {}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		if dmgInfo:GetDamageType() == DMG_DISSOLVE then
			hitgroup = hitgroup or "Abdomen"
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "disintegrated")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'disintegrated' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
	["Medicsystem.AddResistanceInjury"] = function(ply, hitgroup, dmgInfo)
		if dmgInfo:GetDamageType() == DMG_DISSOLVE then
			hitgroup = hitgroup or "Abdomen"
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "disintegrated")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'disintegrated' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("disintegrated", Injury)

-- Always die when disintegrated.
hook.Add("Medicsystem.DeathCheck", "Medicsystem.DisruptorDeath", function(injuryName, hitGroup, injuryData)
	if injuryName == "disintegrated" then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/electricshock.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Stromschock"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["myocaine"] = true,
	["enkephalin"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 1

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_SHOCK then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "electricshock")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'electricshock' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("electricshock", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/explosivefragments.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Explosionsfragmente"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["forceps"] = true,
	["coagulin"] = true,
	["woundglue"] = true,
	["bactabandage"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_BLAST or dmgInfo:GetDamageType() == DMG_DIRECT then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "explosivefragments")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'explosivefragments' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,

	["Medicsystem.AddResistanceInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_BLAST or dmgInfo:GetDamageType() == DMG_DIRECT then
			-- Adds a contusion if damage is more than 10% of players max health
			if dmgInfo:GetDamage() >= (ply:GetMaxHealth() * 0.1) then
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage() * 0.25, "contusion")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'concussion' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			end

			-- Adds a concussion if damage is more than players max health
			if dmgInfo:GetDamage() >= ply:GetMaxHealth() then
				local success, message = Medicsystem:AddInjury(ply, "Kopf", dmgInfo:GetDamage(), "concussion")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'concussion' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			end
		end
	end
}

Medicsystem:RegisterInjury("explosivefragments", Injury)
--addons/bkeypads_cracker/lua/bkeypads_cracker_config.lua:
bKeypads.Cracker:SetConfig({ -- Don't touch this line

--################################################################################################################--
--[[##############################################################################################################--
      
      
       ██████╗ ██╗██╗     ██╗  ██╗   ██╗███████╗    ██╗  ██╗███████╗██╗   ██╗██████╗  █████╗ ██████╗ ███████╗
       ██╔══██╗██║██║     ██║  ╚██╗ ██╔╝██╔════╝    ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗██╔════╝
       ██████╔╝██║██║     ██║   ╚████╔╝ ███████╗    █████╔╝ █████╗   ╚████╔╝ ██████╔╝███████║██║  ██║███████╗
       ██╔══██╗██║██║     ██║    ╚██╔╝  ╚════██║    ██╔═██╗ ██╔══╝    ╚██╔╝  ██╔═══╝ ██╔══██║██║  ██║╚════██║
       ██████╔╝██║███████╗███████╗██║   ███████║    ██║  ██╗███████╗   ██║   ██║     ██║  ██║██████╔╝███████║
       ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝   ╚══════╝    ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝
      

    https://www.gmodstore.com/market/view/billys-keypads
    
    Thank you for purchasing my script and supporting my work :D I hope this will enrich your server.
	Make sure you've followed the installation instructions and activated your license if you haven't already.

	Using a leak? That's okay -- sometimes it's hard to justify splashing out on a new server, for example.
	But please be safe - the VAST majority of leaks contain backdoors and malicious code that can destroy
	your server and attract malicious players.

	If your server is successful, don't forget to support the creators who provided you with their hard work.

--################################################################################################################--
--################################################################################################################--

	This Lua file allows you to configure Billy's Deployable Keypad Crackers.

	PLEASE DO NOT EDIT THIS FILE IN NOTEPAD - IT'S LIKE TRYING TO DO SURGERY WITH A KITCHEN KNIFE.
	Use one of these:
	https://www.sublimetext.com/
	https://notepad-plus-plus.org/downloads/
	https://code.visualstudio.com/

	Unfortunately I cannot provide support regarding configuring the addon as I would just get flooded and wouldn't
	have time to help people with bugs or errors so please reach out to friends or the Internet if you need help.

	It follows the same syntax as actual Lua code so if you make a typo you are likely to break it. Be careful.

	Don't change anything in this file except for the settings themselves unless you know what you are doing.

	This config file uses Simplerr (the same thing DarkRP uses) to help you understand any errors.
	https://fptje.github.io/glualint-web/ can also help you debug your config file.

	Good luck, have fun :D

]]--##############################################################################################################--
--##[[                                                  DarkRP                                                ]]##--

-- Want to make a job spawn with a keypad cracker?
-- Give them the bkeypads_cracker weapon :)

F4Cracker = {
	-- Should the keypad cracker be added to the DarkRP F4 menu as a purchaseable weapon?
	EnableSingle = true,

	-- Should the keypad cracker be added to the DarkRP F4 menu as a purchaseable shipment?
	EnableShipment = true,

	Single = {
		-- The name of the F4 menu weapon
		-- If changing this doesn't work, your F4 menu isn't very well made
		label = "Keypad Cracker",

		amount = 1,
		price = 500,

		sortOrder = 0,
		category = "Other",

		customCheck = function(ply)
			return table.HasValue(ply:getJobTable().weapons, "bkeypads_cracker") -- This means only people whose job spawns with a keypad cracker can buy it
		end,
	},

	Shipment = {
		-- The name of the F4 menu shipment
		-- If changing this doesn't work, your F4 menu isn't very well made
		label = "Keypad Cracker",

		amount = 10,
		allowed = { TEAM_GUN },
		price = 5000,

		sortOrder = 0,
		category = "Other",
	},
},

--################################################################################################################--
--##[[                                                  CONFIG                                                ]]##--

-- While cracking, should the keypad cracker be deployed on the keypad, or should it be held in the players hands?
Deployed = true,

-- How long does it take to crack a keypad in seconds?
-- The cracking time is chosen randomly in between the two numbers, e.g. between 20 and 30 seconds.
-- The first number is the lower range, and the second number is the higher range.
CrackTime = {20, 30},

-- Here you can define special crack times
-- If a player is eligible for multiple special crack times, the one with the shortest duration will be selected.
SpecialCrackTimes = {
	--[[
	Custom check functions for advanced users

	{
		-- This special crack time will only apply to DarkRP police
		function(ply, keypad)
			if DarkRP and ply.isCP and ply:isCP() then
				return true
			end
		end,

		{30, 60}
	},

	{
		function(ply, keypad)
			return ply:SteamID() == "STEAM_0:1:40314158"
		end,
		
		-- You can also specify your own custom function for the crack time
		function(ply, keypad)
			return math.random(1, 5)
		end,
	},

	--]]
},

-- Add sunglasses to keypad cracker faces for players with special crack times?
SpecialSunglasses = false,

-- (DarkRP only) How much money to give a police officer if they stunstick a keypad cracker?
SeizeReward = 500,

-- (DarkRP only) Should the stunstick destroy keypad crackers or simply drop them off keypads?
StunstickDestroys = false,

-- Distance keypad cracker can be deployed from
CrackDistance = 2500,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed when they disconnect?
DestroyDeployedCrackersOnDisconnect = true,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed when they disconnect?
DestroyDroppedCrackersOnDisconnect = true,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed if they die?
DestroyDeployedCrackersOnDeath = false,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed if they die?
DestroyDroppedCrackersOnDeath = true,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be destroyed if they switch teams?
DestroyDeployedCrackersOnSwitch = true,

-- Should a player's DROPPED (on the ground) keypad crackers be destroyed if they switch teams?
DestroyDroppedCrackersOnSwitch = true,

-- Should DEPLOYED (actively cracking) keypad crackers be destroyed when they finish cracking?
-- This makes them one-time use items.
DestroyCrackersWhenFinished = false,

-- Should a player's DEPLOYED (actively cracking) keypad crackers be REPLACED if they crack a different keypad?
ReplaceOldDeployedCrackers = true,

-- Should a player's DROPPED (on the ground) keypad crackers be REPLACED if they crack a different keypad?
ReplaceOldDroppedCrackers = true,

-- If a player's keypad cracker gets destroyed, magically give them a new one?
ReplaceDestroyedCrackers = true,

-- In seconds, how long should it take for a DROPPED (on the ground) keypad cracker to destroy itself?
-- Set to 0 to disable
DroppedKeypadCrackerTimeout = 600,

-- Allow players to pick up DROPPED (on the ground) keypad crackers even if they didn't deploy them?
-- NOTE: This can be controlled through OpenPermissions (allowing you to specify teams that can pick them up)
AnyoneCanPickup = true,

-- Allow players to stop DEPLOYED (actively cracking) keypad crackers by pressing E even if they didn't deploy them?
-- Does nothing if keypad cracker damage is enabled.
-- NOTE: This can be controlled through OpenPermissions (allowing you to specify teams that can pick them up)
AnyoneCanStopCracker = true,

-- Allow players who spawned with the keypad cracker to pick up DROPPED (on the ground) keypad crackers even if they didn't deploy them?
LoadoutCanPickup = true,

-- Should DROPPED (on the ground) keypad crackers be visible through walls to the player who deployed it?
SeeDroppedCrackerThroughWalls = true,

Damage = {
	-- Can keypad crackers take damage?
	Enable = true,

	-- Should keypad crackers that take damage be destroyed by it?
	-- If not, they will simply drop off the keypad
	Destroy = true,

	-- Can DROPPED keypad crackers be destroyed?
	-- Does nothing if Destroy is false
	CanDestroyDropped = true,

	-- How much damage is required for a deployed cracker to drop off a keypad?
	-- Set to 0 for instant drop
	Health = 250,

	-- Show a health bar on DEPLOYED (actively cracking) keypad crackers?
	HealthBar = true,

	-- Should only certain damage types damage the keypad cracker?
	-- https://wiki.facepunch.com/gmod/Enums/DMG
	DamageTypeWhitelist = {
		-- DMG_BULLET,
		-- DMG_SLASH,
		-- DMG_CLUB,
		-- DMG_BUCKSHOT,
		-- DMG_SNIPER,
		-- DMG_GENERIC,
	},

	-- Should certain damage types be blocked from damaging the keypad cracker?
	-- https://wiki.facepunch.com/gmod/Enums/DMG
	DamageTypeBlacklist = {
		DMG_VEHICLE,
		DMG_POISON,
		DMG_PHYSGUN,
		DMG_CLUB
	},

	-- Allow bullets to damage keypads through walls?
	DamageThroughWalls = false,

	-- Should damage apply force to dropped keypad crackers?
	-- Players will be able to shoot dropped keypad crackers around
	DamageForce = true,
},

Beeps = {
	-- Emit the classic keypad cracking beep noises?
	Enable = true,

	-- How often should beeps be played?
	BeepInterval = 3,

	-- The distance/volume the beeps can be heard from.
	-- Measured in dB, https://wiki.facepunch.com/gmod/Enums/SNDLVL
	-- Don't actually use SNDLVL_* here, use the number they represent
	BeepVolume = 100,
},

-- Should there be a random chance that a keypad crack could fail entirely?
-- 0 = never fail
-- 1 = always fail
FailChance = 0.1,

-- Should the keypad cracker trigger "Access Denied" on the keypad if it fails?
AccessDeniedOnFail = true,

-- Should the keypad cracker trigger "Access Denied" on the keypad if cracking is somehow aborted?
AccessDeniedOnAbort = true,

-- The phrases shown on the keypad cracker's screen when it's being deployed
-- Only alphanumeric latin characters are supported (A-Z a-z 0-9)
CrackerPhrases = {
	"LET ME IN",
	"LETS GO",
	"ITS TIME",
	"PROTECT ME",
	"GOOD LUCK",
	"YOU GOT THIS",
}


--################################################################################################################--
--################################################################################################################--
}) -- Don't touch this line