--Stealed clientside server code by exechack.cc
--Hostname: Große Armee der Republik ★EGM★ [57 / 100] [v4.0.11] - Part 5/5 - 06/04/2025


--addons/bkeypads/lua/autorun/_bkeypads_load.lua:
bKeypads_Ready = nil

local function includeSV(path)
	if SERVER then
		return include(path)
	end
end

local function includeSH(path)
	if SERVER then
		AddCSLuaFile(path)
	end
	return include(path)
end

local function includeCS(path)
	if SERVER then
		AddCSLuaFile(path)
	end
	if CLIENT then
		return include(path)
	end
end

file.CreateDir("bkeypads")
if CLIENT then
	file.CreateDir("bkeypads/stool")
	file.CreateDir("bkeypads/saved")
	file.CreateDir("bkeypads/keypad_img")
	file.CreateDir("bkeypads/keypad_img/saved")
elseif SERVER then
	file.CreateDir("bkeypads/persistence")
end

if SERVER then
	resource.AddWorkshop("2299543771")
end

bKeypads_ConfigAutoRefresh = nil

bKeypads = {}

bKeypads.noop = function() end

bKeypads.Keypads = {}
bKeypads.KeypadsRegistry = {}
for _, ent in ipairs(ents.GetAll()) do
	if IsValid(ent) and ent.bKeypad then
		table.insert(bKeypads.Keypads, ent)
		bKeypads.KeypadsRegistry[ent] = true
	end
end

function bKeypads:IsKeypad(ent)
	return IsValid(ent) and ent.bKeypad
end

--## Polyfills ##--

if SERVER then
	local escapeEntities = { ["&"] = "&amp;", ["<"] = "&lt;", [">"] = "&gt;" }
	bKeypads.markup = {}
	bKeypads.markup.Escape = (markup and markup.Escape) or function(str)
		return (tostring(str):gsub("[&<>]", escapeEntities))
	end
	bKeypads.markup.Color = (markup and markup.Color) or function(col)
		return
			col.r .. "," ..
			col.g .. "," ..
			col.b ..
			(col.a == 255 and "" or ("," .. col.a))
	end
end

do
	bKeypads.math = {}
	bKeypads.math.min = function(...)
		if #({...}) == 1 then
			return select(1, ...)
		else
			return math.min(...)
		end
	end
	bKeypads.math.max = function(...)
		if #({...}) == 1 then
			return select(1, ...)
		else
			return math.max(...)
		end
	end
end

do
	bKeypads.table = {}
	bKeypads.table.Shuffle = table.Shuffle or function(t)
		local n = #t
		for i = 1, n - 1 do
			local j = math.random(i, n)
			t[i], t[j] = t[j], t[i]
		end
	end
end

do
	local _net = net

	local fake_net = {}
	local debug_meta = {
		__index = function(self, key)
			return getmetatable(self)[key] or _net[key]
		end
	}
	for name, func in pairs(_net) do
		if isfunction(func) and name:match("^Write") or name:match("^Read") or name:match("^Start") or name:match("^Send") or name:match("^Broadcast") then
			debug_meta[name] = function(...)

				local args = {...}
				for i, arg in ipairs(args) do
					args[i] = isstring(arg) and "\"" .. (arg:gsub("\\", "\\\\"):gsub("\n", "\\n"):gsub("\"", "\\\"")) .. "\"" or tostring(arg)
				end

				local returns = { func(...) }
				local debug_returns = {}
				for i, val in ipairs(returns) do
					debug_returns[i] = isstring(val) and "\"" .. (val:gsub("\\", "\\\\"):gsub("\n", "\\n"):gsub("\"", "\\\"")) .. "\"" or tostring(val)
				end
				bKeypads:print("[NET] net." .. name .. "(" .. table.concat(args, ", ") .. ")" .. (#debug_returns > 0 and (" = " .. table.concat(debug_returns, ", ")) or ""))

				return unpack(returns)
			end
		end
	end
	setmetatable(fake_net, debug_meta)

	local function apply_net_debug(bkeypads_net_debug)
		bKeypads.net = bkeypads_net_debug and fake_net or _net
		return bkeypads_net_debug
	end
	apply_net_debug(CreateConVar("bkeypads_net_debug", "0", FCVAR_CHEAT, nil, 0, 1):GetBool())
	cvars.AddChangeCallback("bkeypads_net_debug", function(_, __, net_debug) bkeypads_net_debug = apply_net_debug(tobool(net_debug)) end)
end

do
	bKeypads.player = {}

	local plyHashTable_SteamID = {}
	local plyHashTable_SteamID64 = {}
	local plyHashTable_AccountID = {}
	local plyHashTable_UniqueID = {}
	
	function bKeypads.player.GetBySteamID(sid)
		return plyHashTable_SteamID[sid] or false
	end
	function bKeypads.player.GetBySteamID64(sid64)
		return plyHashTable_SteamID64[sid64] or false
	end
	function bKeypads.player.GetByAccountID(accountid)
		return plyHashTable_AccountID[accountid] or false
	end
	function bKeypads.player.GetByUniqueID(uniqueid)
		return plyHashTable_UniqueID[uniqueid] or false
	end
	
	local hashTableKeyCache = {}
	local function register(ply)
		local sid = ply:SteamID()
		if sid then
			plyHashTable_SteamID[sid] = ply
		end
	
		local sid64 = ply:SteamID64()
		if sid64 then
			plyHashTable_SteamID64[sid64] = ply
		end
	
		local accountid = ply:AccountID()
		if accountid then
			plyHashTable_AccountID[accountid] = ply
		end
	
		local uniqueid = ply:UniqueID()
		if uniqueid then
			plyHashTable_UniqueID[uniqueid] = ply
		end
	
		if sid then
			hashTableKeyCache[sid] = {
				sid64 = sid64,
				accountid = accountid,
				uniqueid = uniqueid
			}
		end
	end
	
	if CLIENT then
		hook.Add("bKeypads.PlayerInitialSpawn", "bKeypads.PlayerGetters.PlayerInitialSpawn", register)
		timer.Create("bKeypads.LocalPlayer", 0, 0, function()
			if LocalPlayer():IsValid() then
				register(LocalPlayer())
				timer.Remove("bKeypads.LocalPlayer")
			end
		end)
	else
		hook.Add("PlayerInitialSpawn", "bKeypads.PlayerGetters.PlayerInitialSpawn", register)
	end
	
	gameevent.Listen("player_disconnect")
	hook.Add("player_disconnect", "bKeypads.PlayerGetters.player_disconnect", function(data)
		local sid = data.networkid
		if sid then
			plyHashTable_SteamID[sid] = nil
	
			local keyCache = hashTableKeyCache[sid]
			if keyCache then
				if keyCache.sid64 then
					plyHashTable_SteamID64[keyCache.sid64] = nil
				end
				if keyCache.accountid then
					plyHashTable_AccountID[keyCache.accountid] = nil
				end
				if keyCache.uniqueid then
					plyHashTable_UniqueID[keyCache.uniqueid] = nil
				end
				hashTableKeyCache[sid] = nil
			end
		end
	end)
	
	for _, ply in ipairs(player.GetAll()) do
		register(ply)
	end
end

--## Enumerations & Constants ##--

bKeypads.COLOR = {}
	bKeypads.COLOR.BLACK     = Color(0,0,0)
	bKeypads.COLOR.WHITE     = Color(255,255,255)
	bKeypads.COLOR.RED       = Color(255,0,0)
	bKeypads.COLOR.GREEN     = Color(0,255,0)
	bKeypads.COLOR.GMODBLUE  = Color(0,150,255)
	bKeypads.COLOR.SLATE     = Color(32,32,32)
	bKeypads.COLOR.LCDSCREEN = Color(84,104,91)
	bKeypads.COLOR.PINK      = Color(250,0,255)

bKeypads.BODYGROUP = {}
	bKeypads.BODYGROUP.KEYPAD       = 0
	bKeypads.BODYGROUP.INTERNALS    = 1
	bKeypads.BODYGROUP.CAMERA       = 2
	bKeypads.BODYGROUP.LED_TOP      = 3
	bKeypads.BODYGROUP.LED_BOTTOM   = 4
	bKeypads.BODYGROUP.KEYCARD_SLOT = 5
	bKeypads.BODYGROUP.PANEL        = 6

bKeypads.SCANNING_STATUS = {}
	bKeypads.SCANNING_STATUS.LOADING  = 0
	bKeypads.SCANNING_STATUS.IDLE     = 1
	bKeypads.SCANNING_STATUS.SCANNING = 2
	bKeypads.SCANNING_STATUS.GRANTED  = 3
	bKeypads.SCANNING_STATUS.DENIED   = 4

bKeypads.AUTH_MODE = {}
	bKeypads.AUTH_MODE.PIN     = 1
	bKeypads.AUTH_MODE.FACEID  = 2
	bKeypads.AUTH_MODE.KEYCARD = 3

bKeypads.ACCESS_TYPE = {}
bKeypads.ACCESS_GROUP = {}
	bKeypads.ACCESS_GROUP.VERSION               = 1
	  
	bKeypads.ACCESS_TYPE.WHITELIST              = 2
	bKeypads.ACCESS_TYPE.BLACKLIST              = 3
  
	bKeypads.ACCESS_GROUP.PAYMENT               = 4
  
	bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP     = 5
	bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION   = 6
	bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION = 18

	bKeypads.ACCESS_GROUP.PLAYER                = 7
	bKeypads.ACCESS_GROUP.USERGROUP             = 8
	bKeypads.ACCESS_GROUP.TEAM                  = 9
	bKeypads.ACCESS_GROUP.KEYCARD_LEVEL         = 10
	bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS     = 11
	bKeypads.ACCESS_GROUP.STEAM_FRIENDS         = 12
  
	bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY   = 13
	bKeypads.ACCESS_GROUP.DARKRP_JOB            = 14
	bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP     = 15
	bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP   = 16
	bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP   = 17

	bKeypads.ACCESS_GROUP.HELIX_FLAG            = 19

	bKeypads.ACCESS_GROUP.LAST = math.max(bKeypads.ACCESS_GROUP[table.GetWinningKey(bKeypads.ACCESS_GROUP)], bKeypads.ACCESS_TYPE[table.GetWinningKey(bKeypads.ACCESS_TYPE)])
	bKeypads.ACCESS_GROUP.BITS = 32

bKeypads.ACCESS_TYPES = { bKeypads.ACCESS_TYPE.WHITELIST, bKeypads.ACCESS_TYPE.BLACKLIST }
bKeypads.ACCESS_TYPES_REVERSE = { bKeypads.ACCESS_TYPE.BLACKLIST, bKeypads.ACCESS_TYPE.WHITELIST }
bKeypads.ACCESS_TYPES_BOOL = { true, false }

bKeypads.MODEL = {}
	bKeypads.MODEL.KEYPAD        = "models/bkeypads/keypad_3.0.0.mdl"
	bKeypads.MODEL.KEYCARD       = "models/bkeypads/keycard.mdl"
	bKeypads.MODEL.KEYCARD_HANDS = "models/bkeypads/c_keycard.mdl"

util.PrecacheModel(bKeypads.MODEL.KEYPAD)
util.PrecacheModel(bKeypads.MODEL.KEYCARD)
util.PrecacheModel(bKeypads.MODEL.KEYCARD_HANDS)

--## Printing ##--

bKeypads.PRINT_TYPE_NEUTRAL = Color(0,255,255)
bKeypads.PRINT_TYPE_GOOD    = Color(0,255,0)
bKeypads.PRINT_TYPE_BAD     = Color(255,0,0)
bKeypads.PRINT_TYPE_WARN    = Color(255,255,0)
bKeypads.PRINT_TYPE_SPECIAL = Color(255,0,255)

function bKeypads:print(txt, print_type, print_prefix)
	MsgC(print_type or bKeypads.PRINT_TYPE_NEUTRAL, "[bKeypads] " .. (print_prefix and ("[" .. print_prefix .. "] ") or ""), bKeypads.COLOR.WHITE, txt, "\n")
end

function bKeypads:chat(txt, print_type, print_prefix)
	chat.AddText(print_type or bKeypads.PRINT_TYPE_NEUTRAL, "[bKeypads] " .. (print_prefix and ("[" .. print_prefix .. "] ") or ""), bKeypads.COLOR.WHITE, txt)
end

bKeypads:print("Hello, world!")

--## License ##--

if SERVER then
	bKeypads.License = include("bkeypads/license.lua")
	if not bKeypads.License then return end
	bKeypads:print("Version " .. bKeypads.License.Version, bKeypads.PRINT_TYPE_SPECIAL)
	bKeypads:print("Licensed to " .. util.SteamIDFrom64(bKeypads.License.SteamID64), bKeypads.PRINT_TYPE_SPECIAL)
end

--## Guaranteed Hooks ##--

do
	local _InitPostEntity = {}
	function bKeypads:InitPostEntity(f)
		if bKeypads_InitPostEntity then
			f()
		else
			table.insert(_InitPostEntity, f)
		end
	end
	local function InitPostEntity()
		hook.Remove("InitPostEntity", "bKeypads.InitPostEntity")
		if bKeypads_InitPostEntity then return end

		bKeypads_InitPostEntity = true
		for _, f in ipairs(_InitPostEntity) do f() end
		_InitPostEntity = {}
	end
	hook.Add("InitPostEntity", "bKeypads.InitPostEntity", InitPostEntity)
	timer.Simple(0.1, InitPostEntity)
end

do
	local _Initialize = {}
	function bKeypads:GMInitialize(f)
		if bKeypads_Initialize then
			f()
		else
			table.insert(_Initialize, f)
		end
	end
	local function Initialize()
		bKeypads_Initialize = true
		for _, f in ipairs(_Initialize) do f() end
		_Initialize = {}
	end
	hook.Add("Initialize", "bKeypads.Initialize", Initialize)
end

do
	local _postLoadCustomDarkRPItems = {}
	function bKeypads:postLoadCustomDarkRPItems(f)
		if bKeypads_postLoadCustomDarkRPItems then
			f()
		end

		table.insert(_postLoadCustomDarkRPItems, f)
	end

	local function postLoadCustomDarkRPItems()
		bKeypads_postLoadCustomDarkRPItems = true
		for _, f in ipairs(_postLoadCustomDarkRPItems) do f() end

		hook.Remove("PlayerInitialSpawn", "bKeypads.postLoadCustomDarkRPItems")
	end
	hook.Add("loadCustomDarkRPItems", "bKeypads", function() timer.Simple(1, postLoadCustomDarkRPItems) end)
	hook.Add("postLoadCustomDarkRPItems", "bKeypads", function() timer.Simple(1, postLoadCustomDarkRPItems) end)
	hook.Add("PlayerInitialSpawn", "bKeypads.postLoadCustomDarkRPItems", postLoadCustomDarkRPItems)
	hook.Add("Initialize", "bKeypads.postLoadCustomDarkRPItems", postLoadCustomDarkRPItems)

	local function applyDarkRPConfig(_GAMEMODE)
		if not _GAMEMODE.Config then return end
		_GAMEMODE.Config.DisallowDrop["bkeycard"] = true
		_GAMEMODE.Config.noStripWeapons["bkeycard"] = true

		_GAMEMODE.Config.allowedProperties["bkeypads"] = true

		_GAMEMODE.Config.PocketBlacklist["keypad"] = true
		_GAMEMODE.Config.PocketBlacklist["bkeypad"] = true
		_GAMEMODE.Config.PocketBlacklist["bkeycard_pickup"] = true
	end
	local function safeApplyDarkRPConfig()
		local _GAMEMODE = GM or GAMEMODE
		if not DarkRP or not _GAMEMODE or not _GAMEMODE.Config then return end
		pcall(applyDarkRPConfig, _GAMEMODE)
	end
	bKeypads:postLoadCustomDarkRPItems(safeApplyDarkRPConfig)
	safeApplyDarkRPConfig()
end

if SERVER then
	function bKeypads:nextTick(func)
		timer.Simple(0, func)
	end
else
	local nextTick
	function bKeypads:nextTick(func)
		nextTick = nextTick or {}
		table.insert(nextTick, func)
	end
	hook.Add("Tick", "bKeypads.Tick", function()
		if not nextTick then return end
		local execNextTick = nextTick
		nextTick = nil
		for _, func in ipairs(execNextTick) do func() end
	end)
end

--## Config ##--

do
	for name in pairs(hook.GetTable()["bKeypads.ConfigUpdated"] or {}) do hook.Remove("bKeypads.ConfigUpdated", name) end

	function bKeypads:SetConfig(config)
		bKeypads.Config = config

		if bKeypads_ConfigAutoRefresh then
			hook.Run("bKeypads.ConfigUpdated")
			bKeypads:print("Config was updated", bKeypads.PRINT_TYPE_SPECIAL)
		else
			bKeypads_ConfigAutoRefresh = true
			bKeypads:print("Config loaded successfully", bKeypads.PRINT_TYPE_SPECIAL)
		end
	end

	function bKeypads:LoadConfig()
		bKeypads.Config = nil

		if SERVER and not bKeypads.Config then
			bKeypads.simplerr = simplerr or include("bkeypads/lib/simplerr.lua")
			if bKeypads.simplerr then
				local succ, err = bKeypads.simplerr.runFile("bkeypads_config.lua")
				if not succ then
					MsgC("\n")
					ErrorNoHalt(err or "[ERROR] UNKNOWN error in \"bkeypads_config.lua\"")
				end
			end
		end

		include("bkeypads_config.lua")
	end
	bKeypads:LoadConfig()

	if not bKeypads.Config then
		MsgC("\n")
		bKeypads:print("Your config file has a Lua error! Aborting.\n", bKeypads.PRINT_TYPE_BAD, "ERROR")
		return
	else
		bKeypads:postLoadCustomDarkRPItems(bKeypads.LoadConfig)
	end
end

--## Load files ##--

bKeypads:print("Loading files...")

AddCSLuaFile("bkeypads_config.lua")
AddCSLuaFile("bkeypads_custom_access.lua")

includeSH "bkeypads/sh_lang.lua"
includeSV "bkeypads/sv_keypads.lua"
includeSH "bkeypads/sh_keypad_data.lua"
includeSH "bkeypads/sh_context_menu.lua"

includeCS "bkeypads/cl_settings.lua"
includeCS "bkeypads/cl_fonts.lua"
includeCS "bkeypads/cl_ui.lua"
includeCS "bkeypads/cl_performance.lua"

includeSH "bkeypads/sh_permissions.lua"

includeSV "bkeypads/sv_networking.lua"

includeSH "bkeypads/sh_economy.lua"
includeSH "bkeypads/sh_keycards.lua"
includeSH "bkeypads/sh_keycard_inventory.lua"
includeSH "bkeypads/sh_keypad_images.lua"
includeSH "bkeypads/sh_keypad_linking.lua"
includeSH "bkeypads/sh_access_logs.lua"
includeSH "bkeypads/sh_fading_doors.lua"
includeSH "bkeypads/sh_map_linking.lua"
includeSH "bkeypads/sh_notifications.lua"
includeSH "bkeypads/sh_stool.lua"
includeSH "bkeypads/sh_destruction.lua"

includeCS "bkeypads/cl_keycard_textures.lua"
includeCS "bkeypads/cl_keypad_esp.lua"
includeCS "bkeypads/cl_properties_display.lua"
includeCS "bkeypads/cl_fake_angles.lua"
includeCS "bkeypads/cl_health_display.lua"
includeCS "bkeypads/cl_tutorial.lua"
includeSV "bkeypads/cl_tutorial_scenes.lua"

bKeypads.md5    = includeCS "bkeypads/lib/md5.lua"
bKeypads.clip   = includeCS "bkeypads/lib/clip.lua"
bKeypads.ease   = ease or ( includeSH "bkeypads/lib/ease.lua" )
bKeypads.markup = Either(SERVER, bKeypads.markup, includeCS "bkeypads/lib/markup.lua")

includeSH "bkeypads/sh_custom_access.lua"

if file.Exists("bkeypads/sh_cracker.lua", "LUA") then
	includeSH "bkeypads/sh_cracker.lua"
end

includeSV "bkeypads/sv_drm.lua"

bKeypads_Ready = true
hook.Run("bKeypads.Ready")
--addons/bkeypads/lua/bkeypads_config.lua:
bKeypads:SetConfig({ -- Don't touch this line

--################################################################################################################--
--[[##############################################################################################################--
      
      
       ██████╗ ██╗██╗     ██╗  ██╗   ██╗███████╗    ██╗  ██╗███████╗██╗   ██╗██████╗  █████╗ ██████╗ ███████╗
       ██╔══██╗██║██║     ██║  ╚██╗ ██╔╝██╔════╝    ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗██╔════╝
       ██████╔╝██║██║     ██║   ╚████╔╝ ███████╗    █████╔╝ █████╗   ╚████╔╝ ██████╔╝███████║██║  ██║███████╗
       ██╔══██╗██║██║     ██║    ╚██╔╝  ╚════██║    ██╔═██╗ ██╔══╝    ╚██╔╝  ██╔═══╝ ██╔══██║██║  ██║╚════██║
       ██████╔╝██║███████╗███████╗██║   ███████║    ██║  ██╗███████╗   ██║   ██║     ██║  ██║██████╔╝███████║
       ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝   ╚══════╝    ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝
      

    https://www.gmodstore.com/market/view/billys-keypads
    
    Thank you for purchasing my script and supporting my work :D I hope this will enrich your server.
	Make sure you've followed the installation instructions and activated your license if you haven't already.

	Using a leak? That's okay -- sometimes it's hard to justify splashing out on a new server, for example.
	But please be safe - the VAST majority of leaks contain backdoors and malicious code that can destroy
	your server and attract malicious players.

	If your server is successful, don't forget to support the creators who provided you with their hard work.

--################################################################################################################--
--################################################################################################################--

	This Lua file allows you to configure Billy's Keypads.

	PLEASE DO NOT EDIT THIS FILE IN NOTEPAD - IT'S LIKE TRYING TO DO SURGERY WITH A KITCHEN KNIFE.
	Use one of these:
	https://www.sublimetext.com/
	https://notepad-plus-plus.org/downloads/
	https://code.visualstudio.com/

	Unfortunately I cannot provide support regarding configuring the addon as I would just get flooded and wouldn't
	have time to help people with bugs or errors so please reach out to friends or the Internet if you need help.

	It follows the same syntax as actual Lua code so if you make a typo you are likely to break it. Be careful.

	Don't change anything in this file except for the settings themselves unless you know what you are doing.

	This config file uses Simplerr (the same thing DarkRP uses) to help you understand any errors.
	https://fptje.github.io/glualint-web/ can also help you debug your config file.

	Good luck, have fun :D

]]--##############################################################################################################--
--##[[                                              PERMISSIONS                                               ]]##--

-- NOTE: It is recommended that you install OpenPermissions with Billy's Keypads for advanced permissions control
-- If you have GmodAdminSuite installed then OpenPermissions should already be installed
-- Type !openpermissions in chat to open it
-- https://github.com/GmodAdminSuite/OpenPermissions

--################################################################################################################--
--##[[                                             GENERAL CONFIG                                             ]]##--

-- The maximum number of keypads a player can spawn
-- 0 = no maximum
MaxKeypads = {
	["default"] = 0,
},

-- If enabled, keypads can ONLY be placed on & linked to fading doors.
-- This will force "Auto Fading Door" for convenience.
-- Do not turn this on if you want your players to be able to link keypads to map objects! This overrides that.
-- NOTE: You can override this for usergroups/teams/jobs (e.g. donator ranks) if OpenPermissions is installed
KeypadOnlyFadingDoors = false,

-- Enable the creation of mirrored keypads?
-- Players will be able to place mirrored keypads on props that are automatically linked
-- Only one keypad will count towards their keypad limit!
KeypadMirroring = true,

-- The maximum distance players can link stuff from
-- Set to 0 for no maximum
-- NOTE: You can override this for usergroups/teams/jobs (e.g. admins) if OpenPermissions is installed
LinkingDistance = 0,

-- Set this to false to suppress the map's lighting on keypads when they're being interacted with by a player
-- May help with visibility
AlwaysEngineLighting = true,

Wiremod = {
	-- Enable Wiremod support
	-- (You can leave this enabled even without Wiremod installed)
	-- NOTE: You can control the permissions for access to Wiremod keypads (e.g. donator ranks) if OpenPermissions is installed
	Enabled = true,

	-- Enable the "Scanning" output for keypads
	-- This could theoretically be overpowered on DarkRP, leading clever players to create Wiremod keypads that open their door when the keypad
	-- is being scanned. This means they can make Keypad Crackers useless on the keypad.
	ScanningOutput = false,
},

-- Allow players to create keypads that press a key on their keyboard when access is granted or denied?
-- Billy's Keypads includes its own fading door tool which does not use a keyboard button for opening/closing the fading door.
-- This prevents fading door abuse and requires keypads to be linked to fading doors to control them. Therefore, in most cases
-- you won't need to enable this, and it's recommended you leave this off on roleplay servers.
-- More advanced users can instead use Wiremod for their creations, if it's installed (and you've enabled Wiremod keypads above)
-- NOTE: You can control the permissions for access to keyboard pressing (e.g. donator ranks) if OpenPermissions is installed
EnableKeyboardPress = false,

Notifications = {
	-- Allow players to receive "Access Granted" and "Access Denied" notifications from their keypads
	-- NOTE: You can control the permissions for receiving notifications (e.g. donator ranks) if OpenPermissions is installed
	Enable = true,

	-- Notifications by default have their own popups that show at the botttom of the screen
	-- If this doesn't fit in with the rest of your server, you can redirect notifications to chat instead
	UseChat = false,
},

--################################################################################################################--
--##[[                                                SCANNING                                                ]]##--

Scanning = {
	ScanMethods = {
		-- NOTE: You can control the permissions for access to scan methods (e.g. donator ranks) if OpenPermissions is installed

		-- Whether or not the PIN method of keypads is enabled
		EnablePIN = true,

		-- Whether or not the facial scanning method of keypads is enabled
		EnableFaceID = true,

		-- Whether or not keycards are enabled
		EnableKeycards = true,
	},

	ScanTimes = {
		-- How long should it take in seconds to scan the face of a player?
		FaceID = 4,

		-- How long should it take in seconds to scan an inserted keycard?
		Keycard = 1
	},

	-- In hammer units, what is the maximum distance a player/keycard can be scanned from?
	MaxDistance = 7000,

	-- Should the keypad abort scanning an inserted keycard if the player moves too far away?
	KeycardFailTooFarAway = true,

	AccessGranted = {
		-- The minimum amount of time in seconds a keypad can be "Access Granted" for
		-- Set to 0 for no minimum
		MinimumTime = 3,

		-- The maximum amount of time in seconds a keypad can be "Access Granted" for
		-- Set to 0 for no maxmimum
		MaximumTime = 0,

		-- Maximum number of repeats
		-- Set to 0 for no maximum
		MaximumRepeats = 10,

		-- Minimum repeat delay
		-- If set to 0 for no minimum
		MinimumRepeatDelay = 1,

		-- WARNING: If you have very high/unlimited MaximumRepeats and a low MinimumRepeatDelay, players could crash/lag the server by spamming repeats
	},

	AccessDenied = {
		-- The minimum amount of time in seconds a keypad can be "Access Denied" for
		-- Set to 0 for no minimum
		MinimumTime = 1,

		-- The maximum amount of time in seconds a keypad can be "Access Denied" for
		-- Set to 0 for no maxmimum
		MaximumTime = 0,

		-- Maximum number of repeats
		-- Set to 0 for no maximum
		MaximumRepeats = 10,

		-- Minimum repeat delay
		-- If set to 0 for no minimum
		MinimumRepeatDelay = 1,

		-- WARNING: If you have very high/unlimited MaximumRepeats and a low MinimumRepeatDelay, players could crash/lag the server by spamming repeats
	},
},

--################################################################################################################--
--##[[                                                KEYCARDS                                                ]]##--

Keycards = {
	ShowID = {
		-- Should keycard identification be enabled?
		AllowIndentification = false,

		-- The message that is displayed when a player presents their identification
		-- Available replacements:
		-- %name%      - Player's name
		-- %keycard%   - Keycard name
		-- %level%     - Keycard level
		-- %team%      - Team/job name
		-- %usergroup% - Player's usergroup
		Message = "%name% zeigt seine Keycard des Types %keycard% vor und identifiziert sich damit als Mitglied der %team%",

		-- If you are familiar with GMod's markup library's formatting, switch this option to true to enable markup tags
		-- https://wiki.facepunch.com/gmod/markup.Parse
		MessageMarkup = false,

		-- In hammer units, how far can players see keycard identification from?
		Distance = 10000,

		-- How long is the message displayed for?
		Time = 4,

		-- How long must the player wait before presenting their identification again?
		Cooldown = 2,
	},

	-- The message that is displayed when pressing E on a keycard scanner
	InsertKeycardMessage = "Please insert your keycard!",

	-- Should players spawn with a keycard?
	-- You can configure what teams spawn with keycards and the keycard level they spawn with below
	SpawnWithKeycard = false,

	-- Teams that should never spawn with a keycard
	SpawnWithoutKeycard = {
	},

	-- Can players drop the keycard they spawned with?
	-- NOTE: You can configure who can drop their keycard using OpenPermissions if installed
	CanDropSpawnedWithKeycard = true,

	-- Can players drop other keycards?
	-- Dropped keycards can be collected by players and used to access keypads
	-- NOTE: You can configure who can drop keycards using OpenPermissions if installed
	CanDropKeycard = true,

	-- Should the custom DarkRP /job be shown instead of the player's job's actual name?
	ShowCustomJobName = true,

	Levels = {
		-- You can configure keycard levels here

		-- NOTE: The order of the keycards matter!
		-- Keycards further down can access keypads which are configured to grant access to "Level X or higher" keycards
		-- Players can also have multiple keycard levels, but the one furthest down is the one VISIBLE to them and others.
		-- The "Name" field of the keycard levels does not affect this.

		{
			Name  = "Zivil",
			Color = Color(255, 255, 255),
			customCheck = function(ply)
				return false
			end,
		},

		{
			Name  = "Sicherheitslevel 1",
			Color = Color(0, 255, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 1")
			end,
		},

		{
			Name  = "Sicherheitslevel 2",
			Color = Color(255, 255, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 2")
			end,
		},

		{
			Name  = "Sicherheitslevel 3",
			Color = Color(255, 93, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 3")
			end,
		},

		{
			Name  = "Notfallsoldaten",
			Color = Color(255, 0, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Notfallsoldaten") or ply:HasKeycardAccess("Basissicherheit")
			end,
		},

		{
			Name  = "Geheimdienst",
			Color = Color(0, 0, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Geheimdienst")
			end,
		},

		{
			Name  = "Ausbilder",
			Color = Color(19, 34, 255),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Ausbilder")
			end,
		},

		{
			Name  = "Galaktischer Senat",
			Color = Color(0, 161, 255),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Galaktischer Senat")
			end,
		},

		{
			Name  = "Basissicherheit",
			Color = Color(119, 69, 176),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Basissicherheit")
			end,
		},

		--[[
		
		customCheck keycard level example:
		For more help, read this: https://wiki.gmodadminsuite.com/bkeypads#custom-checks TODO
		{
			Name = "Level 5",
			Color = Color(0, 0, 0),
			customCheck = function(ply)
				-- You can use a customCheck function here to use custom Lua code to determine a keycard's level
				-- For example, your custom SCP gamemode has its own keycard level system, and exposes a PLAYER:GetKeycardLevel() function
				-- In this example, you can use the following code to link this system to Billy's keycards:
				return ply:GetKeycardLevel() == 5
			end,
		}

		--]]
	},

	KeycardImage = {
		-- Keycards display various information on their world models, one of which being a small image that you can configure here

		-- Possible choices:

		-- avatar  : Displays the player's profile picture, if this cannot be displayed, Backup will be used instead
		-- keycard : Displays a keycard icon
		-- scp     : Displays the SCP Foundation logo
		-- <url>   : Displays a .png image downloaded from the given URL
		-- <path>  : Displays a texture in the client's game files (you may have to configure a way for clients to download this texture)

		-- Recommended size for images: 256x256

		Image = "keycard",
		Backup = "keycard",

		-- The color shown beneath the keycard image
		BackgroundColor = Color(0, 0, 0, 255)
	}
},

--################################################################################################################--
--##[[                                               APPEARANCE                                               ]]##--

Appearance = {
	ScreenColors = {
		-- What color should be displayed on keypads whilst scanning?
		Scanning = Color(32, 32, 32),

		-- What color should be displayed on keypads when access is granted?
		Granted = Color(80, 255, 80),

		-- What color should be displayed on keypads when access is denied?
		Denied = Color(255, 60, 60),

		-- What color should be displayed when a keypad is hacked or broken?
		Hacked = Color(150, 0, 0),
	},

	LEDColors = {
		-- What color should be displayed on the status LED whilst scanning?
		Scanning = Color(255, 175, 0),

		-- What color should be displayed on the status LED when access is granted?
		Granted = Color(0, 255, 0),

		-- What color should be displayed on the status LED when access is denied?
		Denied = Color(255, 0, 0),

		-- What color should be displayed on the status LED when a keypad is hacked or broken?
		Hacked = Color(255, 0, 0),
	},

	CustomImages = {
		-- Should custom images be enabled?
		-- This allows players to add custom images to their keypads, such as a logo.
		-- NOTE: You can control the permissions for the usage of custom images (e.g. donator ranks) if OpenPermissions is installed
		Enable = true,

		-- Domains that can be used as custom image URLs for keypads
		-- It is very important that you only use trusted websites & domains here because the images are downloaded clientside which exposes your players' IP addresses to possible malicious actors.
		-- So, do not add random, untrusted domains here. If a player asks to add a domain here, they are probably up to no good. Imgur should be good enough.
		URLWhitelist = {
			"i.imgur.com",
		},
	}
},

--################################################################################################################--
--##[[                                           PAYMENTS & ECONOMY                                           ]]##--

Payments = {
	-- Allow players to charge others for using their keypad?
	-- NOTE: You can control the permissions for access to this (e.g. donator ranks) if OpenPermissions is installed
	Enable = false,

	-- Should players be asked to confirm whether they want to make the payment or not?
	Prompt = true,

	-- Minimum amount of money players can charge (this cannot be below 1)
	MinimumPayment = 1,

	-- Maximum amount of money players can charge
	-- Set to 0 for no maximum
	MaximumPayment = 0,

	Economy = {
		-- If DarkRP isn't running, turn this on to use the below custom Lua functions instead of DarkRP functions for checking money, taking payments, etc.
		CustomEconomy = false,

		-- return true if the player can afford $"amount"
		canAfford = function(ply, amount)
			return ply:GetMoney() >= amount
		end,

		-- Note; "amount" may be negative (for TAKING money) or positive (for ADDING money)
		addMoney = function(ply, amount)
			ply:SetMoney(ply:GetMoney() + amount)
		end,

		-- Return a correctly formatted currency string
		-- e.g. 1000.5 -> $1,000.50
		formatMoney = function(amount)
			-- Separate 1000s into 1,000s
			local left, num, right = string.match(amount, "^([^%d]*%d)(%d*)(.-)$")
			local formatted = left .. (num:reverse():gsub("(%d%d%d)", "%1,"):reverse()) .. right

			-- Right-pad a 0 to single-digit cents/pennies
			formatted = (formatted:gsub("%.(%d)$", ".%10"))

			return "$" .. formatted
		end,
	},
},

--################################################################################################################--
--##[[                                               MAP LINKING                                              ]]##--

MapLinking = {
	-- Should map linking to doors be enabled?
	Doors = true,

	-- Should map linking to buttons be enabled?
	Buttons = true,
},

--################################################################################################################--
--##[[                                               ACCESS LOGS                                              ]]##--

AccessLogs = {
	-- TIP: Need a new job for your roleplay server? Maybe make a detective job which spawns with the bkeypads_access_logs weapon ;)

	-- Do police need a warrant to view the access logs of a keypad?
	PoliceNeedWarrant = true,

	-- Can the access log checker weapon be dropped?
	-- NOTE: In DarkRP, this is also controlled by GM.Config.dropspawnedweapons
	CanDrop = true,
},

--################################################################################################################--
--##[[                                               FADING DOORS                                             ]]##--

FadingDoors = {
	-- Allow players to create fading doors which open/close using buttons on the keyboard?
	-- Enabling this means your server is vulnerable to fading door abuse
	EnableKeyboardPress = false,

	-- Allow players to create reversed fading doors?
	-- (Fading doors that are open by default and close when activated)
	Reversible = false,

	-- The maximum number of fading doors a player can spawn
	-- 0 = no maximum
	Maximum = {
		["default"] = 0,
	},

	-- Prevent fading doors from closing on players and making them stuck?
	-- Players will be automatically pushed out of fading doors they're stuck in
	-- THIS ISN'T 100% ACCURATE! (Source Engine is kind of shit at this)
	KeepOpen = true,
	-- Increase this number if you have a laggy server :D (Fading doors will be less responsive when stuck checking)
	TickIntervalMul = 16,

	-- DarkRP:
	-- Whether to allow fading doors to be lockpicked or not
	-- (If they can't be lockpicked, players must keypad crack the corresponding keypad instead)
	Lockpick = false,

	-- The materials that players are allowed to use for their fading doors
	Materials = {
		"Models/effects/vol_light001",

		-- Active Forcefields
		--"sprites/heatwave",
		--"models/shadertest/shader3",
		--"models/shadertest/shader4",
		--"Models/effects/comball_sphere",
		--"Models/effects/comball_tape",
		--"Models/effects/splodearc_sheet",
		--"models/props_combine/stasisshield_sheet",
		--"models/props_combine/portalball001_sheet",
		--"models/props_combine/com_shield001a",
		--"models/props_c17/frostedglass_01a",
		--"models/props_lab/Tank_Glass001",
		--"models/props_combine/tprings_globe",

		-- Completely Useless
		--"models/wireframe",
		--"debug/env_cubemap_model",
		--"models/shadertest/shader5",
		--"models/shiny",
		--"models/debug/debugwhite",
		--"models/rendertarget",
		--"models/screenspace",
		--"brick/brick_model",
		--"models/props_pipes/GutterMetal01a",
		--"models/props_pipes/Pipesystem01a_skin3",
		--"models/props_wasteland/wood_fence01a",
		--"models/props_foliage/tree_deciduous_01a_trunk",
		--"models/props_c17/FurnitureFabric003a",
		--"models/props_c17/FurnitureMetal001a",
		--"models/props_c17/paper01",
		--"models/flesh",
	},

	-- Whether fading door sounds are enabled or not
	-- NOTE: You can control the permissions for access to fading door sounds (e.g. donator ranks) if OpenPermissions is installed
	EnableSounds = false,

	-- The sounds that players are allowed to use for the opening/closing sound of a fading door
	Sounds = {
		"doors/doorstop1.wav",
		"npc/turret_floor/retract.wav",
		"npc/roller/mine/combine_mine_deactivate1.wav",
		"npc/roller/mine/combine_mine_deploy1.wav",
		"npc/roller/mine/rmine_taunt1.wav",
		"npc/scanner/scanner_nearmiss2.wav",
		"npc/scanner/scanner_siren1.wav",
		"npc/barnacle/barnacle_gulp1.wav",
		"npc/barnacle/barnacle_gulp2.wav",
		"npc/combine_gunship/attack_start2.wav",
		"npc/combine_gunship/attack_stop2.wav",
		"npc/dog/dog_pneumatic1.wav",
		"npc/dog/dog_pneumatic2.wav",
	},

	-- The sounds that players are allowed to use for the active sound of a fading door
	-- These sounds must be looping sounds
	LoopSounds = {
		"ambient/machines/machine6.wav",
		"ambient/energy/force_field_loop1.wav",
		"physics/metal/canister_scrape_smooth_loop1.wav",
		"ambient/levels/citadel/citadel_drone_loop5.wav",
		"ambient/levels/citadel/citadel_drone_loop6.wav",
		"ambient/atmosphere/city_rumble_loop1.wav",
		"ambient/machines/city_ventpump_loop1.wav",
		"ambient/machines/combine_shield_loop3.wav",
		"npc/manhack/mh_engine_loop1.wav",
		"npc/manhack/mh_engine_loop2.wav",
	}
},

Persistence = {
	-- Whether persistent keypads should be saved on server shutdown
	-- If this is off, then any changes you make to permanent keypads will need to be saved using the profile switcher in the persistence tool's spawn menu section
	SaveOnShutDown = false,
},

KeypadDestruction = {
	-- Enable keypad damage (players can shoot to destroy & disable keypads)
	-- Admins will still be able to spawn destructible keypads if they explicitly choose to.
	-- NOTE: You can control the permissions for this if OpenPermissions is installed
	Enable = false,

	-- How much health should a keypad spawn with?
	KeypadHealth = 200,

	-- What is the maximum shield charge a keypad can hold as a percentage of its maximum health?
	-- 0 = Unlimited
	-- 100% = 1
	-- 200% = 2
	-- 300% = 3
	-- ...
	MaxShield = 1,

	-- In seconds, how often should a keypad regenerate health?
	-- 0 to disable
	KeypadRegenRate = 0.5,

	-- How much health should a keypad regenerate as a percentage of its maximum health?
	-- 0 to disable
	-- NOTE: The actual amount will be rounded up to get rid of any decimals
	-- Example:
	-- Maximum health = 200
	-- Health regeneration pct = 0.01 = 1%
	-- Health regeneration amount = 200 * 1% = 2
	-- Health regeneration rate = 0.5 seconds
	-- Time to fully regenerate = 200 / (200 * 1%) / 0.5 = 200 seconds
	KeypadRegenAmount = 0.01,

	-- How much should a battery charge a keypad's health as a percentage of its maximum health?
	-- 100% = 1
	-- 75% = 0.75
	-- 50% = 0.5
	-- 25% = 0.25
	-- ...
	BatteryCharge = 0.25,

	-- How much should a shield battery charge a keypad's shield as a percentage of its maximum health?
	ShieldBatteryCharge = 0.25,

	-- DarkRP F4 menu items
	DarkRP = {
		-- https://darkrp.miraheze.org/wiki/DarkRP:CustomEntityFields

		Battery = {
			Disabled = true,
			Name = "Keypad Battery",

			price = 500,
			max = 0,
			cmd = "buykeypadbattery",
			category = "Other",
			--allowed = { TEAM_MECHANIC },
			--customCheck = function(ply) return ply:GetUserGroup() == "donator" end,
		},

		ShieldBattery = {
			Disabled = true,
			Name = "Keypad Shield Battery",

			price = 1000,
			max = 0,
			cmd = "buykeypadshield",
			category = "Other",
			--allowed = { TEAM_MECHANIC },
			--customCheck = function(ply) return ply:GetUserGroup() == "donator" end,
		}
	},
},

-- Should experimental ENTITY:GetClass() override be enabled?
-- This will make sure that all keypad crackers work with Billy's Keypads
-- This is very experimental and could cause problems
ExperimentalKeypadCompatibility = true,

-- Congratulations, you've reached the end of the config!














--################################################################################################################--
--################################################################################################################--
}) -- Don't touch this line
--addons/bkeypads/lua/bkeypads/sh_context_menu.lua:
bKeypads.ContextMenu = {}

local function recursiveFilterCheck(member, ent, ply)
	for _, child in ipairs(member.Members) do
		if child.Filter and child:Filter(ent, ply) and ((not child.Members or #child.Members == 0) or (recursiveFilterCheck(child, ent, ply) == true)) then
			return true
		end
	end
	return false
end

local net_ids = { incr = 0, registry = {} }
bKeypads.ContextMenu.NetReceivers = {}
if SERVER then
	function bKeypads.ContextMenu:Receive(_, ply)
		local net_id = net.ReadUInt(8)
		if bKeypads.ContextMenu.NetReceivers[net_id] then
			local ent = net.ReadEntity()
			if not bKeypads.ContextMenu.NetReceivers[net_id].Filter or bKeypads.ContextMenu.NetReceivers[net_id]:Filter(ent, ply) == true then
				bKeypads.ContextMenu.NetReceivers[net_id].Callback(bKeypads.ContextMenu.NetReceivers[net_id], ent, ply)
			end
		end
	end
end

local memberMeta = {}
memberMeta.__index = memberMeta

function memberMeta:AddMember(name, icon, filter, callback, net_receiver)
	self.Members = self.Members or {}
	return self.Members[table.insert(self.Members, setmetatable({}, memberMeta)(name, icon, filter, callback, net_receiver))]
end

if CLIENT then
	local function interpolateIcon(member, option, ent)
		if isfunction(member.MenuIcon) then
			return member:MenuIcon(option, ent)
		else
			return member.MenuIcon
		end
	end
	function memberMeta:MenuOpen(submenu, ent, tr)
		if submenu.SetIcon then
			submenu = submenu:AddSubMenu()
		end
		for _, member in ipairs(self.Members) do
			if not member.Filter or member:Filter(ent, LocalPlayer()) == true then
				if not member.Members or #member.Members == 0 then
					local option = submenu:AddOption(member.MenuLabel, function()
						member.NetworkEnt = ent
						member:Callback(ent, LocalPlayer(), tr)
					end)
					option:SetIcon(interpolateIcon(member, option, ent))
				elseif recursiveFilterCheck(member, ent, LocalPlayer()) then
					local submenu, _ = submenu:AddSubMenu(member.MenuLabel)
					_:SetIcon(interpolateIcon(member, _, ent))
					member:MenuOpen(submenu, ent, LocalPlayer(), tr)
				end
			end
		end
	end
end

function memberMeta:__call(name, icon, filter, callback, net_receiver)
	self.MenuLabel = name
	self.MenuIcon = icon
	self.Filter = filter
	self.Callback = callback

	if net_receiver then
		local net_id = net_ids.registry[name]
		if not net_id then
			net_ids.incr = net_ids.incr + 1
			net_id, net_ids.registry[name] = net_ids.incr, net_ids.incr
		end
		self.NetID = net_id
		bKeypads.ContextMenu.NetReceivers[net_id] = self
	end

	return self
end

function memberMeta:Network()
	if not self.m_bNetworking then
		self.m_bNetworking = true

		bKeypads.ContextMenu:MsgStart()
		net.WriteUInt(self.NetID, 8)
		net.WriteEntity(self.NetworkEnt)
	else
		self.m_bNetworking = nil
		
		bKeypads.ContextMenu:MsgEnd()
	end
end

local function mergemetatables(dest, source)
	for k, v in pairs(source) do
		if k == "__index" then continue end
		if istable(v) and istable(dest[k]) then
			table.Merge(dest[k], v)
		else
			dest[k] = v
		end
	end

	return dest
end
properties.Add("bkeypads", bKeypads.ContextMenu)

setmetatable(bKeypads.ContextMenu, mergemetatables(table.Copy(getmetatable(bKeypads.ContextMenu)), memberMeta))("Billy's Keypads", "icon16/calculator.png", function(self, ent, ply)
	return recursiveFilterCheck(self, ent, ply)
end)

bKeypads.ContextMenu:AddMember(
	"#bKeypads_OwnedBy",

	-- Icon/Text
	function(self, option, ent)
		local owner = ent:GetKeypadOwner()
		self.m_Clipboard = owner:SteamID()

		option:SetText(owner:Nick())
		
		option:SetIcon("icon16/user.png")
		option.m_Image.AvatarImage = vgui.Create("AvatarImage", option.m_Image)
		option.m_Image.AvatarImage:SetSteamID(owner:SteamID64(), 32)
		option.m_Image.AvatarImage:Dock(FILL)

		return "icon16/user.png"
	end,

	-- Filter
	function(self, ent, ply)
		return ent.bKeypad and IsValid(ent:GetKeypadOwner())
	end,

	-- Callback
	function(self, ent, ply)
		if self.m_Clipboard then
			SetClipboardText(self.m_Clipboard)
			surface.PlaySound("garrysmod/content_downloaded.wav")
			notification.AddLegacy(bKeypads.L"CopiedExclamation", NOTIFY_CLEANUP, 2)
		end
	end
)
--addons/bkeypads/lua/bkeypads/cl_ui.lua:
local L = bKeypads.L

bKeypads.phi = (1 + math.sqrt(5)) / 2

bKeypads.Emotes = {
	["default"]   = Material("bkeypads/face_id.png"),
	["sad"]       = Material("bkeypads/face_id_sad.png"),
	["success"]   = Material("bkeypads/face_id_success.png"),
	["surprised"] = Material("bkeypads/face_id_surprised.png"),
	["angry"]     = Material("bkeypads/face_id_angry.png"),
	["evil"]      = Material("bkeypads/face_id_evil.png"),
	["neutral"]   = Material("bkeypads/face_id_neutral.png"),
	["happy"]     = Material("bkeypads/face_id_happy.png"),
	["sorry"]     = Material("bkeypads/face_id_sorry.png"),
	["shocked"]   = Material("bkeypads/face_id_shocked.png"),
	["confused"]  = Material("bkeypads/face_id_confused.png"),
}

bKeypads.EmoteList = table.GetKeys(bKeypads.Emotes)
bKeypads.Sunglasses = Material("bkeypads/face_id_sunglasses.png")

-- https://wiki.facepunch.com/gmod/Entity:GetAttachment example 2
function bKeypads:TranslateViewModelPosition(nFOV, pos)
	local vEyePos = EyePos()
	local aEyesRot = EyeAngles()

	local vOffset = pos - vEyePos
	local nViewX = math.tan(nFOV * math.pi / 360)
	local nWorldX = math.tan(LocalPlayer():GetFOV() * math.pi / 360)

	local vForward = aEyesRot:Forward()
	local vRight = aEyesRot:Right()
	local vUp = aEyesRot:Up()

	local nFactor = nViewX / nWorldX

	vRight:Mul(vRight:Dot(vOffset) * nFactor)
	vUp:Mul(vUp:Dot(vOffset) * nFactor)
	vForward:Mul(vForward:Dot(vOffset))

	vEyePos:Add(vRight)
	vEyePos:Add(vUp)
	vEyePos:Add(vForward)

	return vEyePos
end

do
	bKeypads.cam = bKeypads.cam or {}

	local IgnoreZ = false
	function bKeypads.cam.IgnoreZ(m_bIgnoreZ)
		local prev = IgnoreZ
		IgnoreZ = m_bIgnoreZ

		cam.IgnoreZ(m_bIgnoreZ)

		return prev
	end
end

do
	local du = 0.5 / 32
	local dv = 0.5 / 32
	local u0, v0 = (0 - du) / (1 - 2 * du), (0 - dv) / (1 - 2 * dv)
	local u1, v1 = (1 - du) / (1 - 2 * du), (1 - dv) / (1 - 2 * dv)
	function bKeypads:DrawSubpixelClippedMaterial(mat, x, y, w, h)
		surface.SetMaterial(mat)
		if system.IsOSX() then
			surface.DrawTexturedRect(x, y, w, h)
		else
			surface.DrawTexturedRectUV(x, y, w, h, u0, v0, u1, v1)
		end
	end
end

function bKeypads:LerpUnclamped(t, from, to)
	return from + (to - from) * t
end

function bKeypads:Rainbow(i)
	local optimizing = bKeypads.Performance:Optimizing()
	local r = math.sin(i + 0) * 127 + 128
	local g = math.sin(i + (optimizing and 2 or (2 * math.pi / 3))) * 127 + 128
	local b = math.sin(i + (optimizing and 4 or (4 * math.pi / 3))) * 127 + 128
	return r, g, b
end

function bKeypads:IntToColor(int)
	local b = int % 256
	local g = ((int - b) / 256) % 256
	local r = ((int - b) / 65536) - g / 256
	return Color(r,g,b)
end

function bKeypads:GetLuminance(col)
	return (0.699 * col.r + 0.587 * col.g + 0.05 * col.b) / 255
end
function bKeypads:DarkenForeground(col)
	return bKeypads:GetLuminance(col) >= 0.28
end

local shieldIcon = Material("icon16/shield.png")
local function PaintShield(self, w, h)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(shieldIcon)
	surface.DrawTexturedRect((w - 16) / 2, (h - 16) / 2, 16, 16)
end
function bKeypads:AddShieldIcon(pnl)
	if pnl:GetClassName() == "Panel" and IsValid(pnl.Button) then
		pnl.Button:Dock(LEFT)

		local ShieldIcon = vgui.Create("DImage", pnl)
		ShieldIcon:Dock(LEFT)
		ShieldIcon:DockMargin(5, 0, 5, 0)
		ShieldIcon:SetSize(16, 16)
		ShieldIcon:SetImage("icon16/shield.png")

		pnl.Label:Dock(FILL)
	elseif pnl:GetClassName() == "TextEntry" then
		local ShieldIcon = vgui.Create("DPanel", pnl:GetParent())
		ShieldIcon.Paint = PaintShield
		ShieldIcon:Dock(LEFT)
		ShieldIcon:DockMargin(0, 0, 5, 0)
		ShieldIcon:SetSize(16, 16)
		ShieldIcon:MoveToBack()
	end
end

function bKeypads:AddHelp(form, strHelp)
	local left = vgui.Create("bKeypads.WrapLabel", form)
	left:SetDark(true)
	left:SetTextInset(0, 0)
	left:SetText(strHelp)
	left:DockMargin(8, 0, 8, 8)

	form:AddItem(left, nil)

	left:InvalidateLayout(true)

	return left
end

do
	local function CPanel_AddItem(self, left, right)
		self:bKeypads_AddItem(left, right)
		if IsValid(self.Items[#self.Items]) then
			self.Items[#self.Items]:SetParent(self.SmoothScroll)
			self.SmoothScroll:InvalidateLayout()
		end
	end
	local function CPanel_PerformLayout(self, w, h)
		self:Dock(FILL)
		if IsValid(self:GetParent()) then
			self:GetParent():Dock(FILL)
		end
		if self.bKeypads_PerformLayout then
			return self:bKeypads_PerformLayout(self, w, h)
		end
	end
	function bKeypads:InjectSmoothScroll(CPanel)
		CPanel.bKeypads_AddItem = CPanel.bKeypads_AddItem or CPanel.AddItem
		CPanel.bKeypads_PerformLayout = CPanel.bKeypads_PerformLayout or CPanel.PerformLayout
		CPanel.AddItem = CPanel_AddItem
		CPanel.PerformLayout = CPanel_PerformLayout

		CPanel.SmoothScroll = vgui.Create("bKeypads.SmoothScroll", CPanel)
		CPanel.SmoothScroll:Dock(FILL)
	end
end

--## TV Animation ##--

function bKeypads:TVAnimation(animEnt, duration, w, h, reverse, x, y, easeFunc)
	if animEnt.m_bTVAnimationPushed then
		animEnt.m_bTVAnimationPushed = nil
		cam.PopModelMatrix()
		return
	end
	if not duration then return end

	if not animEnt.m_tTVAnimation then
		animEnt.m_tTVAnimation = {
			Start = CurTime(),
			Matrix = Matrix()
		}
	end

	local verticalFrac = math.Clamp(math.TimeFraction(animEnt.m_tTVAnimation.Start + (duration / 2), animEnt.m_tTVAnimation.Start + duration, CurTime()), 0, 1)
	if reverse then
		verticalFrac = 1 - verticalFrac
		if verticalFrac == 0 then
			animEnt.m_bTVAnimation = nil
			return true
		end
	else
		if verticalFrac == 1 then
			animEnt.m_bTVAnimation = nil
			return true
		end
	end

	local horizontalFrac = math.Clamp(math.TimeFraction(animEnt.m_tTVAnimation.Start, animEnt.m_tTVAnimation.Start + (duration / 2), CurTime()), 0, 1) if reverse then horizontalFrac = 1 - horizontalFrac end

	if easeFunc then
		verticalFrac = easeFunc(verticalFrac)
		horizontalFrac = easeFunc(horizontalFrac)
	end

	local verticalScalar = math.max(verticalFrac, 0.05)
	local horizontalScalar = math.max(horizontalFrac, 0.05)

	local verticalTranslation = (h / 2) * (1 - verticalScalar) + ((y or 0) * (1 - verticalScalar))
	local horizontalTranslation = ((w / 2) * (1 - horizontalScalar)) + ((x or 0) * (1 - horizontalScalar))

	animEnt.m_tTVAnimation.Matrix:SetUnpacked(
		horizontalScalar, 0, 0, horizontalTranslation,
		0, verticalScalar, 0, verticalTranslation,
		0, 0, 0, 0,
		0, 0, 0, 1
	)

	cam.PushModelMatrix(animEnt.m_tTVAnimation.Matrix, true)
	animEnt.m_bTVAnimationPushed = true
	animEnt.m_bTVAnimation = true
end

do
	local LogoWhite = Material("bkeypads/logo_wide_white.png", "smooth")
	local function MatrixPaintOver(self, w, h)
		local logo_w = math.min(w - 40, 264)
		local logo_h = math.min(logo_w * (128 / 335), 100)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(LogoWhite)
		surface.DrawTexturedRect((w - logo_w) / 2, (h - logo_h) / 2, logo_w, logo_h)
	end

	local function MatrixPerformLayout(self, w, h)
		self.Settings:AlignTop(5)
		self.Settings:AlignRight(5)
	end

	local function MatrixOnMousePressed(self,m)
		self._m = m
	end
	local function MatrixOnMouseReleased(self,m)
		if self._m == m and m == MOUSE_LEFT then
			gui.OpenURL("https://gmodstore.com/market/view/billys-keypads")
			surface.PlaySound("garrysmod/balloon_pop_cute.wav")
			self._m = nil
		end
	end

	function bKeypads:OpenSettings()
		for k, v in pairs(g_SpawnMenu:GetToolMenu().Items) do
			if v.Name ~= "Options" then continue end
			v.Tab:DoClick()
			for k, v in pairs(v.Panel.List.pnlCanvas:GetChildren()) do
				if v.Header:GetValue() ~= "Billy's Keypads" then continue end
				local btn = v:Find("DButton")
				btn:DoClick()
				btn:DoClickInternal()
				return
			end
			return
		end
	end
	
	function bKeypads:STOOLMatrix(CPanel, showCog)
		CPanel.Matrix = vgui.Create("bKeypads.Matrix", CPanel)
		CPanel.Matrix:SetTall(128)
		CPanel.Matrix:SetMatrixID("STOOL")
		CPanel.Matrix:SetBGColor(Color(0,150,255))
		CPanel.Matrix.PaintOver = MatrixPaintOver
		CPanel.Matrix:SetCursor("hand")
		CPanel.Matrix.OnMousePressed = MatrixOnMousePressed
		CPanel.Matrix.OnMouseReleased = MatrixOnMouseReleased
		CPanel:AddItem(CPanel.Matrix)

		if showCog ~= false then
			CPanel.Matrix.PerformLayout = MatrixPerformLayout

			CPanel.Matrix.Settings = vgui.Create("DImageButton", CPanel.Matrix)
			CPanel.Matrix.Settings:SetSize(16, 16)
			CPanel.Matrix.Settings:SetImage("icon16/cog.png")
			CPanel.Matrix.Settings.DoClick = bKeypads.OpenSettings
		end
	end
end

do
	local RoundedBoxColor = Color(26,26,26,225)

	local RTTexture = GetRenderTarget("GModToolgunScreen", 256, 256)

	local matWarning = CreateMaterial("bKeypads.ToolScreenNoPermissionx", "UnlitGeneric", {
		["$basetexture"] = "icon16/error.png",
		["$ignorez"] = "1",
		["$vertexalpha"] = "1",
		["$translucent"] = "1"
	})
	
	local TextMarkups = {}
	local _w, _h
	function bKeypads:ToolScreenWarning(text, w, h)
		render.BlurRenderTarget(RTTexture, 7, 4, 7)

		local TextMarkup = TextMarkups[text]
		if not TextMarkup or _w ~= w or _h ~= h then
			_w, _h = w, h
			TextMarkups[text] = bKeypads.markup.Parse("<font=bKeypads.ToolScreenNoPermission>" .. bKeypads.markup.Escape(text) .. "</font>", (w * .85) - 20)
			TextMarkup = TextMarkups[text]
		end

		local x,y = (w - (w * .85)) / 2, (h - (TextMarkup:GetHeight() + 20) + 32 + 10) / 2

		RoundedBoxColor.r = Lerp(math.Remap(math.cos(SysTime() * 2 * math.pi), -1, 1, 0, 1), 26, 255)
		draw.RoundedBox(5, x, y, w * .85, TextMarkup:GetHeight() + 20, RoundedBoxColor)

		TextMarkup:Draw(x + 10, y + 10, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 255, TEXT_ALIGN_CENTER)

		surface.SetMaterial(matWarning)
		surface.SetDrawColor(255,255,255,255)
		surface.DrawTexturedRect((w - 32) / 2, y - 32 - 15, 32, 32)
	end

	function bKeypads:ToolScreenNoPermission(w,h)
		return bKeypads:ToolScreenWarning(bKeypads.L("ToolScreenNoPermission"), w, h)
	end

	function bKeypads:ToolScreenNoPermissionEnt(w,h)
		return bKeypads:ToolScreenWarning(bKeypads.L("ToolScreenNoPermissionEnt"), w, h)
	end
end

do
	local function DermaMenuOption_ColorPaint(self,w,h)
		surface.SetDrawColor(self.DermaMenuOption_Color)
		surface.DrawRect(0,0,w,h)
	end
	bKeypads.DermaMenuOption_Color = function(option, color)
		option:SetIcon("icon16/box.png")
		option.m_Image.DermaMenuOption_Color = color
		option.m_Image.Paint = DermaMenuOption_ColorPaint
	end
end

do
	local padding = 20
	function bKeypads:CreateTooltipFont()
		local size = bKeypads.Settings:Get("tooltip_text_size")

		local dyslexia = bKeypads.Settings:Get("dyslexia")
		local dyslexia_weight = dyslexia and 700 or nil
		size = dyslexia and math.max(size, 20) or size
	
		surface.CreateFont("bKeypads.Tooltip", {
			font = dyslexia and "Comic Sans MS" or "Verdana",
			size = size,
			shadow = true,
			weight = dyslexia_weight
		})

		padding = math.min(math.floor(size * (20 / 14)), 20)
	end
	bKeypads:CreateTooltipFont()
	
	local BGColor = Color(0, 0, 0, 240)

	hook.Add("DrawOverlay", "bKeypads.Tooltip", function()
		local hovered = vgui.GetHoveredPanel()
		if not IsValid(hovered) or not hovered.bKeypads_Tooltip or (hovered.IsEnabled and not hovered:IsEnabled()) then return end

		local mX, mY = gui.MousePos()
		local text = hovered.bKeypads_Tooltip

		surface.SetFont("bKeypads.Tooltip")
		local w, h = surface.GetTextSize(text)
		local bgW, bgH = w + padding, h + (padding / 2)
		local x, y = math.Clamp(mX - (bgW / 2), 0, ScrW() - bgW), math.Clamp(mY + 20 + 5, 0, ScrH() - bgH)

		draw.RoundedBox(4, x, y, bgW, bgH, BGColor)

		draw.DrawText(text, "bKeypads.Tooltip", x + (padding / 2) + (w / 2), y + (padding / 2 / 2), bKeypads.COLOR.WHITE, TEXT_ALIGN_CENTER)
	end)

	function bKeypads:RecursiveTooltip(tooltip, ...)
		for _, pnl in ipairs({...}) do
			pnl.bKeypads_Tooltip = tooltip
			for _, c in ipairs(pnl:GetChildren()) do
				if not IsValid(c) then continue end
				bKeypads:RecursiveTooltip(tooltip, c)
			end
		end
		return ...
	end
end
	
local function NodeColorPaint(self,w,h)
	surface.SetDrawColor(self.NodeColor)
	surface.DrawRect(0,0,w,h)
end

do
	local function AvatarImageNode(node, steamid64)
		node.Icon.Paint = nil
		node.Icon.AvatarImage = vgui.Create("AvatarImage", node.Icon)
		node.Icon.AvatarImage:Dock(FILL)
		node.Icon.AvatarImage:SetSteamID(steamid64, 32)
	end

	local function AvatarImageLine(line, steamid64)
		line.AvatarImage = vgui.Create("AvatarImage", line)
		line.AvatarImage:SetSize(17,17)
		line.AvatarImage:SetSteamID(steamid64, 32)
	end

	local function OnNodeSelected(self, node)
		if not node.SteamID64 then
			node:SetExpanded(not node.m_bExpanded)
			node:SetSelected(false)
		end
	end

	bKeypads.PlayerSelector = {}

	do
		local function serialize(f)
			for steamid64, data in pairs(bKeypads.PlayerSelector.Recent) do
				f:Write(steamid64)
				f:WriteULong(data[1])
				if isstring(data[2]) then
					f:WriteByte(#data[2])
					f:Write(data[2])
				else
					f:WriteByte(0)
				end
			end

			bKeypads.KeypadData.File:Close("bkeypads/player_selector_recent.dat", "DATA")
		end
		function bKeypads.PlayerSelector:SerializeRecent()
			local succ = pcall(serialize, bKeypads.KeypadData.File:Open("bkeypads/player_selector_recent.dat", true, "DATA"))
			return succ
		end
	end

	do
		local function deserialize(f)
			local deserialized = {}

			while (f:Tell() < f:Size()) do
				local steamid64, last_seen, nick = f:Read(17), f:ReadULong(), f:Read(f:ReadByte())
				deserialized[steamid64] = {last_seen, nick and #nick > 0 and nick or nil}
				if not deserialized[steamid64][2] then
					steamworks.RequestPlayerInfo(steamid64)
				end
			end

			bKeypads.KeypadData.File:Close("bkeypads/player_selector_recent.dat", "DATA")

			return deserialized
		end
		function bKeypads.PlayerSelector:DeserializeRecent()
			local succ, deserialized = pcall(deserialize, bKeypads.KeypadData.File:Open("bkeypads/player_selector_recent.dat", false, "DATA"))
			if succ then
				return deserialized
			end
		end
	end

	bKeypads.PlayerSelector.Recent = {}
	if file.Exists("bkeypads/player_selector_recent.dat", "DATA") then
		bKeypads.PlayerSelector.Recent = bKeypads.PlayerSelector:DeserializeRecent()
		if not bKeypads.PlayerSelector.Recent then
			bKeypads.PlayerSelector.Recent = {}
			file.Delete("bkeypads/player_selector_recent.dat")
		end
	end

	function bKeypads.PlayerSelector:LookupName(steamid64)
		if bKeypads.PlayerSelector.Recent[steamid64] and bKeypads.PlayerSelector.Recent[steamid64][2] then
			return bKeypads.PlayerSelector.Recent[steamid64] and bKeypads.PlayerSelector.Recent[steamid64][2]
		else
			local steamName = steamworks.GetPlayerName(steamid64)
			if steamName == "[unknown]" or #steamName == 0 then
				steamworks.RequestPlayerInfo(steamid64)
				return nil
			else
				return steamName
			end
		end
	end

	function bKeypads.PlayerSelector:Open(callback)
		if IsValid(self.UI) then
			self.UI:Close()
		end

		local SelectedPlayers = {}

		local function PlayerNodeMouseDown(self)
			self:GetParent():SetSelected(true)
			self.m_mDown = true
		end
		local function PlayerNodeMouseUp(nodeBtn)
			local node = nodeBtn:GetParent()
			if nodeBtn.m_mDown then
				SelectedPlayers[node.SteamID64] = node.Nick
				self.UI.List.Players:Refresh()
			end
			node:SetSelected(false)
			nodeBtn.m_mDown = nil
		end
		local function PlayerNodeClickBind(node)
			node.Label.OnMousePressed = PlayerNodeMouseDown
			node.Label.OnMouseReleased = PlayerNodeMouseUp
		end

		self.UI = vgui.Create("DFrame")
		self.UI:SetDrawOnTop(true)
		self.UI:SetSize(700,500)
		self.UI:SetTitle("Billy's Keypads - " .. L"PlayersSelector")
		self.UI:SetIcon("icon16/group.png")
		self.UI:Center()
		self.UI:MakePopup()
		self.UI:DockPadding(10, 24 + 10, 10, 10)
		self.UI:MoveToFront()
		self.UI:DoModal()
		self.UI.OnClose = function()
			callback({})
			bKeypads.PlayerSelector.UI = nil
		end

		self.UI.List = vgui.Create("DPanel", self.UI)
		self.UI.List:Dock(RIGHT)
		self.UI.List:DockMargin(10,0,0,0)
		self.UI.List:SetWide(350)
		self.UI.List.Paint = nil

			self.UI.List.Done = vgui.Create("DButton", self.UI.List)
			self.UI.List.Done:Dock(TOP)
			self.UI.List.Done:DockMargin(0,0,0,10)
			self.UI.List.Done:SetTall(25)
			self.UI.List.Done:SetText(L"Done")
			self.UI.List.Done:SetIcon("icon16/accept.png")
			self.UI.List.Done:SetDisabled(true)
			self.UI.List.Done.DoClick = function()
				for steamid64, nick in pairs(SelectedPlayers) do
					bKeypads.PlayerSelector.Recent[steamid64] = {os.time(), nick}
				end
				bKeypads.PlayerSelector:SerializeRecent()

				callback(SelectedPlayers)
				self.UI:Close()
				bKeypads.PlayerSelector.UI = nil

				surface.PlaySound("garrysmod/save_load2.wav")
			end

			self.UI.List.Players = vgui.Create("DListView", self.UI.List)
			self.UI.List.Players:Dock(FILL)
			self.UI.List.Players:DockMargin(0,0,0,5)
			local col = self.UI.List.Players:AddColumn("") col:SetMaxWidth(17) col:SetMinWidth(17)
			self.UI.List.Players:AddColumn(L"Name")
			self.UI.List.Players:AddColumn("SteamID")
			self.UI.List.Players:SetMultiSelect(false)
			self.UI.List.Players.OnRowSelected = function(_, lineID, line)
				if input.IsMouseDown(MOUSE_RIGHT) then return end

				surface.PlaySound("garrysmod/ui_return.wav")

				local DMenu = DermaMenu(nil, self.UI)
				
					DMenu:AddOption(L"ViewProfile", function()
						surface.PlaySound("garrysmod/balloon_pop_cute.wav")
						gui.OpenURL("https://steamcommunity.com/profiles/" .. line.SteamID64)
					end):SetIcon("icon16/page_copy.png")
				
					DMenu:AddOption(L"CopySteamID", function()
						if GAS then
							GAS:SetClipboardText(util.SteamIDFrom64(line.SteamID64))
						else
							surface.PlaySound("garrysmod/content_downloaded.wav")
							SetClipboardText(util.SteamIDFrom64(line.SteamID64))
						end
					end):SetIcon("icon16/page_copy.png")
				
					DMenu:AddOption(L"CopySteamID64", function()
						if GAS then
							GAS:SetClipboardText(line.SteamID64)
						else
							surface.PlaySound("garrysmod/content_downloaded.wav")
							SetClipboardText(line.SteamID64)
						end
					end):SetIcon("icon16/page_copy.png")
				
					DMenu:AddOption(L"Remove", function()
						self.UI.List.Players.OnRowRightClick(_, lineID, line)
					end):SetIcon("icon16/delete.png")

				DMenu:Open()
			end
			self.UI.List.Players.OnRowRightClick = function(_, lineID, line)
				SelectedPlayers[line.SteamID64] = nil
				self.UI.List.Players:RemoveLine(lineID)
				self.UI.List.Done:SetDisabled(table.IsEmpty(SelectedPlayers))
				surface.PlaySound("friends/friend_join.wav")
			end
			self.UI.List.Players.Refresh = function()
				local prevLines = #self.UI.List.Players:GetLines()

				self.UI.List.Players:Clear()
				self.UI.List.Done:SetDisabled(true)
				for steamid64, nick in SortedPairsByValue(SelectedPlayers) do
					self.UI.List.Done:SetDisabled(false)
					local line = self.UI.List.Players:AddLine("", nick == 0 and L"Unknown" or nick == 1 and L"LoadingEllipsis" or nick or L"Unknown", util.SteamIDFrom64(steamid64))
					line.SteamID64 = steamid64
					AvatarImageLine(line, steamid64)
				end

				if #self.UI.List.Players:GetLines() > prevLines then
					surface.PlaySound("garrysmod/ui_click.wav")
				end
			end
			
			self.UI.List.SteamIDFinder = vgui.Create("DButton", self.UI.List)
			self.UI.List.SteamIDFinder:SetText(L"SteamIDFinder")
			self.UI.List.SteamIDFinder:SetIcon("icon16/world.png")
			self.UI.List.SteamIDFinder:Dock(BOTTOM)
			self.UI.List.SteamIDFinder:SetTall(25)
			self.UI.List.SteamIDFinder.DoClick = function()
				surface.PlaySound("garrysmod/balloon_pop_cute.wav")
				gui.OpenURL("https://steamid.uk")
			end
			
			self.UI.List.ManualSteamID = vgui.Create("DPanel", self.UI.List)
			self.UI.List.ManualSteamID.Paint = nil
			self.UI.List.ManualSteamID:Dock(BOTTOM)
			self.UI.List.ManualSteamID:DockMargin(0,0,0,5)
			self.UI.List.ManualSteamID:SetTall(25)

				self.UI.List.ManualSteamID.TextEntry = vgui.Create("DTextEntry", self.UI.List.ManualSteamID)
				self.UI.List.ManualSteamID.TextEntry:DockMargin(0,0,-1,0)
				self.UI.List.ManualSteamID.TextEntry:Dock(FILL)
				self.UI.List.ManualSteamID.TextEntry:SetPlaceholderText(L"ManualSteamID")

				self.UI.List.ManualSteamID.Add = vgui.Create("DButton", self.UI.List.ManualSteamID)
				self.UI.List.ManualSteamID.Add:Dock(RIGHT)
				self.UI.List.ManualSteamID.Add:SetSize(25,25)
				self.UI.List.ManualSteamID.Add:SetText("+")
				local SteamworksTimeoutTimers = {}
				self.UI.List.ManualSteamID.Add.OnRemove = function()
					for steamid64 in pairs(SteamworksTimeoutTimers) do
						timer.Remove("bKeypads.PlayerSelector.ManualSteamID.SteamworksTimeout:" .. steamid64)
					end
				end

				local textInput
				self.UI.List.ManualSteamID.Add.Parsed = function(_, steamid64, requestTextInput)
					if not IsValid(self.UI) or (requestTextInput ~= nil and requestTextInput ~= textInput) then return end

					local ply = bKeypads.player.GetBySteamID64(steamid64)

					local nick = IsValid(ply) and ply:Nick() or 1

					SelectedPlayers[steamid64] = nick
					self.UI.List.Players:Refresh()

					if nick == 1 then
						SteamworksTimeoutTimers[steamid64] = true
						timer.Create("bKeypads.PlayerSelector.ManualSteamID.SteamworksTimeout:" .. steamid64, 5, 1, function()
							if not IsValid(self.UI) then return end
							SteamworksTimeoutTimers[steamid64] = nil
							if SelectedPlayers[steamid64] then
								local nick = steamworks.GetPlayerName(steamid64)
								if #nick > 0 and nick ~= "[unknown]" then
									SelectedPlayers[steamid64] = nick
								else
									SelectedPlayers[steamid64] = 0
								end
								self.UI.List.Players:Refresh()
							end
						end)
						steamworks.RequestPlayerInfo(steamid64, function(steamName)
							if not IsValid(self.UI) then return end
							timer.Remove("bKeypads.PlayerSelector.ManualSteamID.SteamworksTimeout:" .. steamid64)
							SteamworksTimeoutTimers[steamid64] = nil
							if SelectedPlayers[steamid64] then
								SelectedPlayers[steamid64] = steamName or 0
								self.UI.List.Players:Refresh()
							end
						end)
					end

					self.UI.List.ManualSteamID.TextEntry:SetValue("")
					self.UI.List.ManualSteamID.Add:SetDisabled(false)
					self.UI.List.ManualSteamID.TextEntry:SetDisabled(false)
				end

				self.UI.List.ManualSteamID.Add.Error = function(_, txt)
					surface.PlaySound("buttons/button2.wav")
					Derma_Message(txt, L"PlayersSelector", L"Dismiss")
					self.UI.List.ManualSteamID.Add:SetDisabled(false)
					self.UI.List.ManualSteamID.TextEntry:SetDisabled(false)
				end

				self.UI.List.ManualSteamID.Add.DoClick = function()
					textInput = string.Trim(self.UI.List.ManualSteamID.TextEntry:GetValue())
					if #textInput == 0 then return end
					
					self.UI.List.ManualSteamID.Add:SetDisabled(true)
					self.UI.List.ManualSteamID.TextEntry:SetDisabled(true)
					
					if textInput:upper():match("^STEAM_%d:%d+:%d+$") then
						return self.UI.List.ManualSteamID.Add:Parsed(util.SteamIDTo64(textInput:upper()))
					elseif textInput:match("^7656119%d+$") then
						return self.UI.List.ManualSteamID.Add:Parsed(textInput)
					else
						local url = textInput:lower()
						if (
							url:match("^http://steamcommunity.com/") or
							url:match("^https://steamcommunity.com/") or
							url:match("^http://www.steamcommunity.com/") or
							url:match("^https://www.steamcommunity.com/") or
							url:match("^steamcommunity%.com/")
						) then
							local steamid64 = url:match("/profiles/(7656119%d+)$")
							if steamid64 then
								return self.UI.List.ManualSteamID.Add:Parsed(steamid64)
							else
								local customURL = url:match("/id/(.-)$")
								if customURL then
									local requestTextInput = textInput
									return http.Fetch("https://www.steamcommunity.com/id/" .. customURL, function(body, size, headers, httpCode)
										if httpCode == 200 then
											local steamid64 = body:match("\"steamid\":\"(7656119%d+)\"")
											if steamid64 then
												self.UI.List.ManualSteamID.Add:Parsed(steamid64, requestTextInput)
											else
												self.UI.List.ManualSteamID.Add:Error(L"ManualSteamIDProfileError")
											end
										elseif httpCode == 404 then
											self.UI.List.ManualSteamID.Add:Error(L"ManualSteamIDProfileNotFound")
										else
											self.UI.List.ManualSteamID.Add:Error(L"ManualSteamIDNetworkError")
										end
									end, function()
										self.UI.List.ManualSteamID.Add:Error(L"ManualSteamIDNetworkError")
									end)
								end
							end
						end
					end

					self.UI.List.ManualSteamID.Add:Error((L"ManualSteamIDError"):format(LocalPlayer():SteamID(), LocalPlayer():SteamID64(), "https://steamcommunity.com/profiles/" .. LocalPlayer():SteamID64(), "https://steamcommunity.com/id/DESTROYER_OF_THOTS"))
				end

		self.UI.SelectPlayers = vgui.Create("DPanel", self.UI)
		self.UI.SelectPlayers.Paint = nil
		self.UI.SelectPlayers:Dock(FILL)

			self.UI.RefreshBtn = vgui.Create("DButton", self.UI.SelectPlayers)
			self.UI.RefreshBtn:Dock(TOP)
			self.UI.RefreshBtn:DockMargin(0,0,0,10)
			self.UI.RefreshBtn:SetTall(25)
			self.UI.RefreshBtn:SetIcon("icon16/arrow_refresh.png")
			self.UI.RefreshBtn:SetText(L"Refresh")
			self.UI.RefreshBtn.DoClick = function()
				if self.UI.SelectPlayers.Tabs.Nearby.Activated then
					self.UI.SelectPlayers.Tabs.Nearby:Refresh()
				end
				if self.UI.SelectPlayers.Tabs.Online.Activated then
					self.UI.SelectPlayers.Tabs.Online:Refresh()
				end
				if self.UI.SelectPlayers.Tabs.Recent.Activated then
					self.UI.SelectPlayers.Tabs.Recent:Refresh()
				end
				if self.UI.SelectPlayers.Tabs.Search.Activated then
					self.UI.SelectPlayers.Tabs.Search:Refresh()
					self.UI.SelectPlayers.Tabs.Search.TextEntry:SearchTermUpdated()
				end
			end

			self.UI.SelectPlayers.Tabs = vgui.Create("DPropertySheet", self.UI.SelectPlayers)
			self.UI.SelectPlayers.Tabs:Dock(FILL)
			self.UI.SelectPlayers.Tabs.OnActiveTabChanged = function(self, old, new)
				local pnl = new:GetPanel()
				if not pnl.Activated then
					pnl.Activated = true
					pnl:Refresh()
				end
			end

				self.UI.SelectPlayers.Tabs.Nearby = vgui.Create("DTree", self.UI.SelectPlayers.Tabs)
				self.UI.SelectPlayers.Tabs.Nearby.Activated = true
				self.UI.SelectPlayers.Tabs.Nearby.OnNodeSelected = OnNodeSelected
				self.UI.SelectPlayers.Tabs.Nearby.Refresh = function()
					self.UI.SelectPlayers.Tabs.Nearby:Clear()

					local FriendsNode = self.UI.SelectPlayers.Tabs.Nearby:AddNode(L"Friends", "icon16/emoticon_happy.png")
					local PlayersNode = self.UI.SelectPlayers.Tabs.Nearby:AddNode(L"Players", "icon16/group.png")

					FriendsNode:SetExpanded(true)
					PlayersNode:SetExpanded(true)

					local has_friend_nearby = false

					for _, ply in ipairs(player.GetHumans()) do
						if ply:GetPos():Distance(LocalPlayer():GetPos()) <= 500 then
							local ParentNode
							if ply:GetFriendStatus() == "friend" then
								has_friend_nearby = true
								ParentNode = FriendsNode
							else
								ParentNode = PlayersNode
							end

							local node = ParentNode:AddNode(ply:Nick(), "icon16/box.png")
							node.SteamID64 = ply:SteamID64()
							node.Nick = ply:Nick()
							AvatarImageNode(node, ply:SteamID64())
							PlayerNodeClickBind(node)
						end
					end

					if not has_friend_nearby then
						FriendsNode:Remove()
					end
				end

			self.UI.SelectPlayers.Tabs:AddSheet(L"Nearby", self.UI.SelectPlayers.Tabs.Nearby, "icon16/map.png")

				self.UI.SelectPlayers.Tabs.Online = vgui.Create("DTree", self.UI.SelectPlayers.Tabs)
				self.UI.SelectPlayers.Tabs.Online.OnNodeSelected = OnNodeSelected
				self.UI.SelectPlayers.Tabs.Online.Refresh = function()
					self.UI.SelectPlayers.Tabs.Online:Clear()

					local FriendsNode = self.UI.SelectPlayers.Tabs.Online:AddNode(L"Friends", "icon16/emoticon_happy.png")
					local PlayersNode = self.UI.SelectPlayers.Tabs.Online:AddNode(L"Players", "icon16/group.png")

					FriendsNode:SetExpanded(true)
					PlayersNode:SetExpanded(true)

					local has_friend_online = false

					local TeamsNode = self.UI.SelectPlayers.Tabs.Online:AddNode(DarkRP and L"Jobs" or L"Teams", DarkRP and "icon16/user_gray.png" or "icon16/flag_purple.png")
					TeamsNode:SetExpanded(true)
					local TeamsNodes = {}
					if DarkRP then
						for _, category in SortedPairsByMemberValue(DarkRP.getCategories().jobs, "name") do
							if not table.IsEmpty(category.members) then
								local categoryNode
								for _, job in SortedPairsByMemberValue(category.members, "name") do
									if #team.GetPlayers(job.team) > 0 then
										if categoryNode == nil then
											categoryNode = TeamsNode:AddNode(category.name, "icon16/box.png")
											categoryNode.Icon.NodeColor = category.color
											categoryNode.Icon.Paint = NodeColorPaint
										end
										TeamsNodes[job.team] = categoryNode:AddNode(job.name, "icon16/box.png")
										TeamsNodes[job.team].Icon.NodeColor = job.color
										TeamsNodes[job.team].Icon.Paint = NodeColorPaint
									end
								end
							end
						end
					else
					for i, teamTbl in SortedPairsByMemberValue(team.GetAllTeams(), "Name") do
							if #team.GetPlayers(i) > 0 then
								TeamsNodes[i] = TeamsNode:AddNode(teamTbl.Name, "icon16/box.png")
								TeamsNodes[i].Icon.NodeColor = teamTbl.Color
								TeamsNodes[i].Icon.Paint = NodeColorPaint
							end
						end
					end

					local players = {}
					for _, ply in ipairs(player.GetHumans()) do
						players[ply] = ply:Nick()
					end
					for ply in SortedPairsByValue(players) do
						local ParentNode
						if ply:GetFriendStatus() == "friend" then
							has_friend_online = true
							ParentNode = FriendsNode
						else
							ParentNode = PlayersNode
						end

						for _, ParentNode in ipairs({ParentNode, TeamsNodes[ply:Team()]}) do
							local node = ParentNode:AddNode(ply:Nick(), "icon16/box.png")
							node.SteamID64 = ply:SteamID64()
							node.Nick = ply:Nick()
							AvatarImageNode(node, ply:SteamID64())
							PlayerNodeClickBind(node)
						end
					end

					if not has_friend_online then
						FriendsNode:Remove()
					end
				end

			self.UI.SelectPlayers.Tabs:AddSheet(L"Online", self.UI.SelectPlayers.Tabs.Online, "icon16/world.png")

				self.UI.SelectPlayers.Tabs.Recent = vgui.Create("DTree", self.UI.SelectPlayers.Tabs.Recent)
				self.UI.SelectPlayers.Tabs.Recent.OnNodeSelected = OnNodeSelected
				self.UI.SelectPlayers.Tabs.Recent.Refresh = function()
					self.UI.SelectPlayers.Tabs.Recent:Clear()

					local OnlineNode = self.UI.SelectPlayers.Tabs.Recent:AddNode(L"Online", "icon16/status_online.png")
					local OfflineNode = self.UI.SelectPlayers.Tabs.Recent:AddNode(L"Offline", "icon16/status_offline.png")

					OnlineNode:SetExpanded(true)

					for steamid64, data in SortedPairsByMemberValue(bKeypads.PlayerSelector.Recent, 2) do
						local ply = bKeypads.player.GetBySteamID64(steamid64)
						local ParentNode = IsValid(ply) and OnlineNode or OfflineNode

						local nick = IsValid(ply) and ply:Nick() or bKeypads.PlayerSelector:LookupName(steamid64)

						local node = ParentNode:AddNode(nick)
						node.SteamID64 = steamid64
						node.Nick = nick
						AvatarImageNode(node, steamid64)
						PlayerNodeClickBind(node)
					end
				end

			self.UI.SelectPlayers.Tabs:AddSheet(L"Recent", self.UI.SelectPlayers.Tabs.Recent, "icon16/clock.png")

			self.UI.SelectPlayers.Tabs.Search = vgui.Create("DPanel", self.UI.SelectPlayers.Tabs)
			self.UI.SelectPlayers.Tabs.Search.Paint = nil

				self.UI.SelectPlayers.Tabs.Search.TextEntry = vgui.Create("DTextEntry", self.UI.SelectPlayers.Tabs.Search)
				self.UI.SelectPlayers.Tabs.Search.TextEntry:Dock(TOP)
				self.UI.SelectPlayers.Tabs.Search.TextEntry:DockMargin(0, 0, 0, 10)
				self.UI.SelectPlayers.Tabs.Search.TextEntry:SetTall(25)
				self.UI.SelectPlayers.Tabs.Search.TextEntry:SetPlaceholderText(L"SearchEllipsis")
				self.UI.SelectPlayers.Tabs.Search.TextEntry:SetUpdateOnType(true)
				self.UI.SelectPlayers.Tabs.Search.TextEntry.SearchTermUpdated = function()
					local searchTerm = string.Trim(self.UI.SelectPlayers.Tabs.Search.TextEntry:GetValue()):lower()
					for _, line in ipairs(self.UI.SelectPlayers.Tabs.Search.Table:GetLines()) do
						line:SetVisible(#searchTerm == 0 or string.Trim(line.Columns[2]:GetText()):lower():find(searchTerm) ~= nil)
					end
					self.UI.SelectPlayers.Tabs.Search.Table:InvalidateLayout()
				end
				self.UI.SelectPlayers.Tabs.Search.TextEntry.OnValueChange = self.UI.SelectPlayers.Tabs.Search.TextEntry.SearchTermUpdated
				self.UI.SelectPlayers.Tabs.Search.TextEntry.OnFocusChanged = self.UI.SelectPlayers.Tabs.Search.TextEntry.SearchTermUpdated

				self.UI.SelectPlayers.Tabs.Search.Table = vgui.Create("DListView", self.UI.SelectPlayers.Tabs.Search)
				self.UI.SelectPlayers.Tabs.Search.Table:Dock(FILL)
				local col = self.UI.SelectPlayers.Tabs.Search.Table:AddColumn("") col:SetMinWidth(17) col:SetMaxWidth(17)
				self.UI.SelectPlayers.Tabs.Search.Table:AddColumn(L"Name")
				self.UI.SelectPlayers.Tabs.Search.Table:AddColumn("SteamID")
				self.UI.SelectPlayers.Tabs.Search.Table:AddColumn(L"Online")

				self.UI.SelectPlayers.Tabs.Search.Refresh = function()
					self.UI.SelectPlayers.Tabs.Search.Table:Clear()

					local mergedPlayers = {}
					for steamid64, data in pairs(bKeypads.PlayerSelector.Recent) do
						local ply = bKeypads.player.GetBySteamID64(steamid64)
						local nick = IsValid(ply) and ply:Nick() or bKeypads.PlayerSelector:LookupName(steamid64)
						mergedPlayers[steamid64] = nick
					end
					for _, ply in ipairs(player.GetHumans()) do
						mergedPlayers[ply:SteamID64()] = ply:Nick()
					end

					for steamid64, nick in SortedPairsByValue(mergedPlayers) do
						local line = self.UI.SelectPlayers.Tabs.Search.Table:AddLine("", nick, util.SteamIDFrom64(steamid64), IsValid(bKeypads.player.GetBySteamID64(steamid64)) and L"Online" or L"Offline")
						line.SteamID64 = steamid64
						line.Nick = nick
						AvatarImageLine(line, steamid64)
					end
				end

				self.UI.SelectPlayers.Tabs.Search.Table.OnRowSelected = function()
					for _, line in ipairs(self.UI.SelectPlayers.Tabs.Search.Table:GetSelected()) do
						SelectedPlayers[line.SteamID64] = line.Nick
					end
					self.UI.List.Players:Refresh()
				end

			self.UI.SelectPlayers.Tabs:AddSheet(L"Search", self.UI.SelectPlayers.Tabs.Search, "icon16/magnifier.png")
		
		self.UI.RefreshBtn:DoClick()
		return self.UI
	end
end

do

	bKeypads.JobSelector = {}
	function bKeypads.JobSelector:Open(callback)
		if IsValid(self.UI) then
			self.UI:Close()
		end

		local SelectedJobCommands = {}

		self.UI = vgui.Create("DFrame")
		self.UI:SetDrawOnTop(true)
		self.UI:SetSize(300,350)
		self.UI:SetTitle("bKeypads - " .. L"JobsSelector")
		self.UI:SetIcon("icon16/user_gray.png")
		self.UI:Center()
		self.UI:MakePopup()
		self.UI:MoveToFront()
		self.UI:DoModal()
		self.UI.OnClose = function()
			callback({})
			bKeypads.JobSelector.UI = nil
		end

		self.UI.Done = vgui.Create("DButton", self.UI)
		self.UI.Done:Dock(TOP)
		self.UI.Done:DockMargin(0,0,0,5)
		self.UI.Done:SetDisabled(true)
		self.UI.Done:SetText(L"Done")
		self.UI.Done:SetIcon("icon16/accept.png")
		self.UI.Done.DoClick = function()
			callback(table.GetKeys(SelectedJobCommands))
			self.UI:Close()
			bKeypads.JobSelector.UI = nil
			surface.PlaySound("garrysmod/save_load2.wav")
		end

		self.UI.JobTree = vgui.Create("DTree", self.UI)
		self.UI.JobTree:Dock(FILL)

		self.UI.JobTree.OnNodeSelected = function(self, node)
			if not node.JobCommand then
				node:SetExpanded(not node.m_bExpanded)
				node:SetSelected(false)
			else
				if SelectedJobCommands[node.JobCommand] then
					SelectedJobCommands[node.JobCommand] = nil
					node:SetSelected(false)
					surface.PlaySound("friends/friend_join.wav")
				else
					SelectedJobCommands[node.JobCommand] = node
					surface.PlaySound("garrysmod/ui_click.wav")
				end
				for command, node in pairs(SelectedJobCommands) do
					node:SetSelected(true)
				end
				bKeypads.JobSelector.UI.Done:SetDisabled(table.IsEmpty(SelectedJobCommands))
			end
		end

		for _, category in SortedPairsByMemberValue(DarkRP.getCategories().jobs, "name") do
			if not table.IsEmpty(category.members) then
				local categoryNode = self.UI.JobTree:AddNode(category.name, "icon16/box.png")
				categoryNode.Icon.NodeColor = category.color
				categoryNode.Icon.Paint = NodeColorPaint
				for _, job in SortedPairsByMemberValue(category.members, "name") do
					local jobNode = categoryNode:AddNode(job.name, "icon16/box.png")
					jobNode.Icon.NodeColor = job.color
					jobNode.Icon.Paint = NodeColorPaint
					jobNode.JobCommand = job.command
				end
			end
		end
		
		return self.UI
	end
end

--## Dyslexia ##--

function bKeypads.RecursiveDyslexia(pnl) -- R E C U R S I V E   D Y S L E X I A
	if pnl.SetFont and pnl.GetFont and pnl:GetFont() == "DermaDefault" or pnl:GetFont() == "DermaDefaultBold" then
		pnl:SetFont("bKeypads.DermaDefaultDyslexia")
		pnl:InvalidateLayout()
		pnl:InvalidateParent()
	end
	if pnl.GetChildren then
		for _, c in ipairs(pnl:GetChildren()) do
			bKeypads.RecursiveDyslexia(c)
		end
	end
end
hook.Add("bKeypads.BuildCPanel", "bKeypads.Dyslexia", function(CPanel)
	if not bKeypads.Settings:Get("dyslexia") then return end
	bKeypads.RecursiveDyslexia(CPanel)
end)
--addons/bkeypads/lua/bkeypads/sh_keycards.lua:
bKeypads.Keycards = bKeypads.Keycards or {}

local function SanitizeConfigData()
	bKeypads.Keycards.Levels = bKeypads.Config.Keycards.Levels
	bKeypads.Keycards.Levels[1] = bKeypads.Keycards.Levels[1] or {
		Name  = "Level 1",
		Color = Color(255,0,0)
	}

	bKeypads.Keycards.SpawnWithoutKeycard = {}
	for _, v in pairs(bKeypads.Config.Keycards.SpawnWithoutKeycard) do
		bKeypads.Keycards.SpawnWithoutKeycard[v] = true
	end
end
hook.Add("bKeypads.ConfigUpdated", "bKeypads.UpdateKeycardLevels", SanitizeConfigData)
SanitizeConfigData()

hook.Add("PlayerLoadout", "bKeypads.SpawnWithKeycard", function(ply)
	if not bKeypads.Config.Keycards.SpawnWithKeycard or bKeypads.Keycards.SpawnWithoutKeycard[ply:Team()] then return end
	ply:Give("bkeycard")
end)

local LevelRegistry
do
	local function UpdateLevelRegistry()
		if not bKeypads.Keycards then return end
		
		LevelRegistry = {
			Teams = {},
			Usergroups = {},
			customChecks = {}
		}

		for level, metadata in pairs(bKeypads.Keycards.Levels) do
			if metadata.Teams then
				for i, team_index in pairs(metadata.Teams) do
					if tonumber(team_index) then
						LevelRegistry.Teams[team_index] = LevelRegistry.Teams[team_index] or {}
						table.insert(LevelRegistry.Teams[team_index], level)
					end
				end
			end
			if metadata.Usergroups then
				for _, usergroup in ipairs(metadata.Usergroups) do
					LevelRegistry.Usergroups[usergroup] = LevelRegistry.Usergroups[usergroup] or {}
					table.insert(LevelRegistry.Usergroups[usergroup], level)
				end
			end
			if metadata.customCheck then
				LevelRegistry.customChecks[metadata.customCheck] = LevelRegistry.customChecks[metadata.customCheck] or {}
				table.insert(LevelRegistry.customChecks[metadata.customCheck], level)
			end
		end

		if DarkRP and RPExtraTeams then
			for _, job in ipairs(RPExtraTeams) do
				local level = tonumber(job.KeycardLevel)
				if level then
					local team_index = job.index
					LevelRegistry.Teams[team_index] = LevelRegistry.Teams[team_index] or {}
					table.insert(LevelRegistry.Teams[team_index], level)
				end
			end
		end

		-- Sorts the ordered table
		for k, v in pairs(LevelRegistry) do
			for _k, _v in pairs(v) do
				table.sort(_v)
			end
		end
	end
	hook.Add("bKeypads.ConfigUpdated", "bKeypads.UpdateLevelRegistry", UpdateLevelRegistry)
	UpdateLevelRegistry()

	concommand.Add("bkeypads_debug_keycards", function()
		local teamLevels = {}

		MsgC("\n")
		bKeypads:print("============= TEAMS ===============")
		for team_index, levels in pairs(LevelRegistry.Teams) do
			local keycards = ""

			for _, level in ipairs(levels) do
				teamLevels[level] = teamLevels[level] or {}
				teamLevels[level][team_index] = true
				keycards = keycards .. ((bKeypads.Keycards.Levels[level] or {Name="ERROR " .. level}).Name or "Level " .. level) .. ", "
			end

			bKeypads:print("[" .. team.GetName(team_index) .. "] = (Found: " .. #levels .. ") " .. keycards:sub(1, -3), bKeypads.PRINT_TYPE_SPECIAL)
		end

		MsgC("\n")
		bKeypads:print("============ KEYCARDS =============")
		for level, teams in pairs(teamLevels) do
			local teamsStr = ""
			local teamsCount = 0

			for team_index in pairs(teams) do
				teamsStr = teamsStr .. team.GetName(team_index) .. ", "
				teamsCount = teamsCount + 1
			end
			
			bKeypads:print("[" .. ((bKeypads.Keycards.Levels[level] or {Name="ERROR " .. level}).Name or "Level " .. level) .. "] = (Found: " .. teamsCount .. ") " .. teamsStr:sub(1, -3), bKeypads.PRINT_TYPE_SPECIAL)
		end
		MsgC("\n")
	end)
end

local function insert_levels(keycardData, insert)
	if #insert == 1 then
		if not keycardData.LevelsDict[insert[1]] then
			table.insert(keycardData.Levels, insert[1])
			keycardData.LevelsDict[insert[1]] = true
		end
		return insert[1]
	else
		local max_level = 1
		for _, level in ipairs(insert) do
			if not keycardData.LevelsDict[level] then
				table.insert(keycardData.Levels, level)
				keycardData.LevelsDict[level] = true
			end
			max_level = math.max(max_level, level)
		end
		return max_level
	end
end

function bKeypads.Keycards:GetKeycardData(ply)
	local keycardData = {
		Levels = {},
		LevelsDict = {},
		PrimaryLevel = 1,
		SteamID = ply:SteamID(),
		PlayerModel = ply:GetModel(),
		Team = ply:Team(),
		PlayerBind = ply:SteamID()
	}

	for func, levels in pairs(LevelRegistry.customChecks) do
		if func(ply) == true then
			keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, insert_levels(keycardData, levels))
		end
	end

	if OpenPermissions then
		if not table.IsEmpty(LevelRegistry.Usergroups) then
			local usergroups = OpenPermissions:GetUserGroups(ply)
			for usergroup in pairs(usergroups) do
				local usergroupLevels = LevelRegistry.Usergroups[usergroup]
				if usergroupLevels then
					keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, insert_levels(keycardData, usergroupLevels))
				end
			end
		end
	else
		local usergroupLevels = LevelRegistry.Usergroups[ply:GetUserGroup()]
		if usergroupLevels then
			keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, insert_levels(keycardData, usergroupLevels))
		end
	end

	local teamLevels = LevelRegistry.Teams[ply:Team()]
	if teamLevels then
		keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, insert_levels(keycardData, teamLevels))
	end

	local extraLevels = hook.Run("bKeypads.GetLevels", ply, {})
	if extraLevels then
		for level in pairs(extraLevels) do
			if not keycardData.LevelsDict[level] then
				table.insert(keycardData.Levels, level)
				keycardData.LevelsDict[level] = true
			end
			keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, level)
		end
	end

	table.sort(keycardData.Levels)

	return keycardData
end

bKeypads_Keycards_ID = bKeypads_Keycards_ID or 0
bKeypads_Keycards_Registry = bKeypads_Keycards_Registry or {}
function bKeypads.Keycards:GetByID(ID)
	return bKeypads_Keycards_Registry[ID]
end
if SERVER then
	function bKeypads.Keycards:AssignID(droppedKeycard)
		if droppedKeycard:GetIsChildKeycard() then return end

		local id
		if droppedKeycard:GetID() ~= 0 then
			id = droppedKeycard:GetID()
		else
			bKeypads_Keycards_ID = bKeypads_Keycards_ID + 1
			id = bKeypads_Keycards_ID
		end

		droppedKeycard:SetID(id)
		--print("Assigned ID", id, droppedKeycard)
	end
	for _, droppedKeycard in ipairs(ents.GetAll()) do
		if droppedKeycard:GetClass() ~= "bkeycard_pickup" then continue end
		bKeypads.Keycards:AssignID(droppedKeycard)
	end
end

if SERVER then
	function bKeypads.Keycards:SpawnKeycard(keycard, ply)
		if ply:Alive() then ply:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_DROP) end
		
		local ent = ents.Create("bkeycard_pickup")
		ent.m_DroppedBy = ply:SteamID()
		ent:SetQuantity(1)
		ent:SetTouchToPickup(false)
		ent:SetPhysicsEnabled(true)

		if keycard == 0 then
			assert(IsValid(ply), "Tried to drop the personal keycard of an invalid player!")

			local keycardData = bKeypads.Keycards:GetKeycardData(ply)
			ent:SetSteamID(ply:SteamID())
			ent:SetPlayerModel(ply:GetModel())
			ent:SetTeam(ply:Team())
			ent:SetLevelsStr(table.concat(keycardData.Levels, ","))
			ent:SetPlayerKeycardDataBind(ply:SteamID())
		else
			local keycardData = bKeypads.Keycards:GetByID(keycard)
			ent:SetIsChildKeycard(true)
			ent:SetID(keycard)
			ent:SetLevelsStr(table.concat(keycardData.Levels, ","))
			ent:SetSteamID(keycardData.SteamID or "")
			ent:SetPlayerModel(keycardData.PlayerModel or "models/player/kleiner.mdl")
			ent:SetTeam(keycardData.Team or 0)
		end

		-- shamelessly stolen from DarkRP
		-- https://github.com/FPtje/DarkRP/blob/cefc171d3236f979bd8d0b721ee4d8f9d6b6eda5/gamemode/modules/base/sv_util.lua#L125-L139
		local tr = util.TraceLine({
			start = ply:GetShootPos(),
			endpos = ply:GetShootPos() + ply:GetAimVector() * 50,
			filter = {ply, ent}
		})

		local ang = ply:EyeAngles()
		ang.pitch = 0
		ang.yaw = ang.yaw + 180
		ang.roll = 0
		ent:SetAngles(ang)

		local vFlushPoint = tr.HitPos - (tr.HitNormal * 512)
		vFlushPoint = ent:NearestPoint(vFlushPoint)
		vFlushPoint = ent:GetPos() - vFlushPoint
		vFlushPoint = tr.HitPos + vFlushPoint
		ent:SetPos(vFlushPoint)

		ent:Spawn()

		--print("Spawned", ent, keycard)

		return ent:GetID(), ent
	end
end

if SERVER then
	util.AddNetworkString("bKeypads.Keycards.Persistence.Save")

	function bKeypads.Keycards:DeletePersistent(ent)
		if bKeypads.Keycards.ShuttingDown or bKeypads.Keycards.BlockPersistenceSave then return end
		if IsValid(ent) and bKeypads.Keycards.Persistent and ent.bKeypads_PersistID and bKeypads.Keycards.Persistent.Keycards[ent.bKeypads_PersistID] then
			bKeypads.Keycards.Persistent.Keycards[ent.bKeypads_PersistID] = nil
			file.Write("bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", util.TableToJSON(bKeypads.Keycards.Persistent))
		end
	end

	function bKeypads.Keycards:SavePersistent(ent, block_write_file)
		if bKeypads.Keycards.ShuttingDown or bKeypads.Keycards.BlockPersistenceSave then return end
		
		if not bKeypads.Keycards.Persistent then
			bKeypads:print("Refusing to write to the dropped keycards persistence file because it is corrupted!", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")

			bKeypads:print("If you want to use persistence again, you'll have to delete the persistence file.", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")
			bKeypads:print("The persistence file can be found in:", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")
			bKeypads:print("garrysmod/data/bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", bKeypads.PRINT_TYPE_SPECIAL, "PERSISTENCE")

			return
		end

		if not ent:GetInfinite() and ent:GetQuantity() == 0 then return end

		if not ent.bKeypads_PersistID then
			bKeypads.Keycards.Persistent.ID = bKeypads.Keycards.Persistent.ID + 1
			ent.bKeypads_PersistID = bKeypads.Keycards.Persistent.ID
		end

		ent:SetPersist(true)

		local prevSaveData = bKeypads.Keycards.Persistent.Keycards[ent.bKeypads_PersistID]
		local saveData = {
			Infinite = ent:GetInfinite() or nil,
			Quantity = not ent:GetInfinite() and (prevSaveData ~= nil and prevSaveData.Quantity or ent:GetQuantity()) or nil,
			PlayerModel = ent:GetPlayerModel(),
			HideToHolders = ent:GetHideToHolders() or nil,
			Levels = ent:GetLevelsStr(),
			TouchToPickup = ent:GetTouchToPickup() or nil,
			Pos = not ent:GetPhysicsEnabled() and (prevSaveData ~= nil and prevSaveData.Pos) or ent:GetPos(),
			Angles = not ent:GetPhysicsEnabled() and (prevSaveData ~= nil and prevSaveData.Angles) or ent:GetAngles()
		}

		if prevSaveData then
			saveData.PhysicsEnabled = prevSaveData.Physics
		else
			saveData.PhysicsEnabled = ent:GetPhysicsEnabled()
		end
		
		bKeypads.Keycards.Persistent.Keycards[ent.bKeypads_PersistID] = saveData
		
		if not block_write_file and not table.IsEmpty(bKeypads.Keycards.Persistent.Keycards) then
			file.CreateDir("bkeypads/persistence/" .. game.GetMap())
			file.Write("bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", util.TableToJSON(bKeypads.Keycards.Persistent))
		end
	end

	function bKeypads.Keycards:SaveAllPersistent()
		if bKeypads.Keycards.ShuttingDown or bKeypads.Keycards.BlockPersistenceSave then return end
		
		for _, v in ipairs(ents.GetAll()) do
			if v:GetClass() == "bkeycard_pickup" and v.bKeypads_PersistID then
				bKeypads.Keycards:SavePersistent(v, true)
			end
		end
		
		if bKeypads.Keycards.Persistent.Keycards and not table.IsEmpty(bKeypads.Keycards.Persistent.Keycards) then
			file.CreateDir("bkeypads/persistence/" .. game.GetMap())
			file.Write("bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", util.TableToJSON(bKeypads.Keycards.Persistent))
		end
	end

	function bKeypads.Keycards:SpawnPersistent(saveData)
		bKeypads.Keycards.Persistent = saveData

		local spawned = 0
		for i, keycard in pairs(saveData.Keycards) do
			spawned = spawned + 1

			local ent = ents.Create("bkeycard_pickup")
			ent.bKeypads_PersistID = i
			ent:SetPersist(true)
			ent:SetInfinite(keycard.Infinite or false)
			if not keycard.Infinite then
				ent:SetQuantity(keycard.Quantity)
			end
			ent:SetLevelsStr(keycard.Levels)
			ent:SetPlayerModel(keycard.PlayerModel or "models/player/kleiner.mdl")
			ent:SetTouchToPickup(keycard.TouchToPickup or false)
			ent:SetPhysicsEnabled(keycard.PhysicsEnabled or false)
			ent:SetHideToHolders(keycard.HideToHolders or false)
			ent:SetPos(keycard.Pos)
			ent:SetAngles(keycard.Angles)
			ent:Spawn()
		end

		bKeypads:print("Spawned " .. spawned .. " persistent dropped keycard(s)", bKeypads.PRINT_TYPE_SPECIAL, "PERSISTENCE")
	end

	function bKeypads.Keycards:LoadPersistent()
		bKeypads.Keycards.BlockPersistenceSave = true

		bKeypads.Keycards.Persistent = { ID = 0, Keycards = {} }

		for _, v in ipairs(ents.GetAll()) do
			if v:GetClass() ~= "bkeycard_pickup" then continue end
			v.bKeypads_PersistID = nil
			v:SetPersist(false)
			v:Remove()
		end

		if not file.Exists("bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", "DATA") then
			bKeypads.Keycards.BlockPersistenceSave = nil
			return
		end

		local droppedKeycards = file.Read("bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", "DATA")
		if droppedKeycards then
			droppedKeycards = util.JSONToTable(droppedKeycards)
			if droppedKeycards then
				local succ = xpcall(bKeypads.Keycards.SpawnPersistent, function(err)
					ErrorNoHalt("\n" .. err .. "\n")
					debug.Trace()
				end, bKeypads.Keycards, droppedKeycards)

				if succ then
					bKeypads.Keycards.BlockPersistenceSave = nil
					return
				end
			end
		end

		bKeypads:print("The dropped keycards persistence file is corrupted!", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")
		bKeypads:print("Please open a support ticket and include the persistence file and the error(s) below with the ticket.\n", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")

		bKeypads:print("If you want to use persistence again, you'll have to delete the persistence file.", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")
		bKeypads:print("The persistence file can be found in:", bKeypads.PRINT_TYPE_BAD, "PERSISTENCE")
		bKeypads:print("garrysmod/data/bkeypads/persistence/" .. game.GetMap() .. "/dropped_keycards.json", bKeypads.PRINT_TYPE_SPECIAL, "PERSISTENCE")

		MsgC("\n")

		bKeypads.Keycards.Persistent = nil
		bKeypads.Keycards.BlockPersistenceSave = nil
	end

	bKeypads:InitPostEntity(function()
		timer.Simple(1, function()
			bKeypads.Keycards:LoadPersistent()
		end)
	end)

	hook.Add("PreCleanupMap", "bKeypads.Keycards.Persistence.PreCleanupMap", function()
		bKeypads.Keycards:SaveAllPersistent()
		bKeypads.Keycards.BlockPersistenceSave = true
	end)
	hook.Add("PostCleanupMap", "bKeypads.Keycards.Persistence.PostCleanupMap", function()
		bKeypads.Keycards.BlockPersistenceSave = nil
		bKeypads.Keycards:LoadPersistent()
	end)
	hook.Add("ShutDown", "bKeypads.Keycards.Persistence.Save", function()
		bKeypads.Keycards:SaveAllPersistent()
		bKeypads.Keycards.ShuttingDown = true
	end)

	hook.Add("PhysgunDrop", "bKeypads.Keycards.Persistence.Save", function(ply, ent)
		if not bKeypads.Permissions:Check(ply, "persistence/manage_persistent_keypads") then return end
		if ent:GetClass() == "bkeycard_pickup" and ent.bKeypads_PersistID then
			bKeypads.Keycards:SavePersistent(ent)

			net.Start("bKeypads.Keycards.Persistence.Save")
			net.Send(ply)
		end
	end)
else
	net.Receive("bKeypads.Keycards.Persistence.Save", function()
		notification.AddLegacy(bKeypads.L"PersistentKeycardSave", NOTIFY_GENERIC, 3)
		surface.PlaySound("ambient/water/drip" .. math.random(1, 4) .. ".wav")
	end)
end
--addons/bkeypads/lua/bkeypads/sh_keypad_images.lua:
bKeypads.KeypadImages = {}

function bKeypads.KeypadImages:VerifyURL(_url, ignore_force_imgur)
	if not bKeypads.Config.Appearance.CustomImages.Enable or (CLIENT and not bKeypads.Settings:Get("custom_images")) then return false end

	local url = _url:lower()
	if url:find("%.%.%/") then return false end

	local domain = url:match("^https?:%/%/(.-)$")
	if not domain then return false end
	domain = (domain:gsub("%/(.-)$", ""))

	local verified = false
	if CLIENT and ignore_force_imgur ~= true and bKeypads.Settings:Get("force_imgur") == true and domain ~= "i.imgur.com" then
		return verified, domain
	end
	for _, whitelisted in ipairs(bKeypads.Config.Appearance.CustomImages.URLWhitelist) do
		if domain:StartWith(whitelisted) then
			verified = true
			break
		end
	end
	
	return verified, domain
end

if CLIENT then
	local L = bKeypads.L

	function bKeypads.KeypadImages:GetURLHash(url)
		return bKeypads.md5.sumhexa((url:gsub("^[hH][tT][tT][pP][sS]?:%/%/", "")))
	end
		
	for _, f in ipairs((file.Find("bkeypads/keypad_img/*", "DATA"))) do
		file.Delete("bkeypads/keypad_img/" .. f)
	end
	
	do
		local failures = {}
		local cached = {}
		function bKeypads.KeypadImages:GetImage(url, callback, force, save)
			local function failed(reason)
				failures[url] = failures[url] or os.time() + 900
				callback(false, reason, failures[url])
			end

			if not force and failures[url] and failures[url] > os.time() then failed("Waiting " .. failures[url] - os.time() .. " seconds before trying again") return end
			failures[url] = nil

			local hash = bKeypads.KeypadImages:GetURLHash(url)

			local dir = save and "bkeypads/keypad_img/saved/" or "bkeypads/keypad_img/"

			local filename = (file.Exists(dir .. hash .. ".png", "DATA") and (dir .. hash .. ".png")) or (file.Exists(dir .. hash .. ".jpg", "DATA") and (dir .. hash .. ".jpg"))

			if filename then
				if not cached[filename] then
					local mat = Material("data/" .. filename, "mips")
					if mat:IsError() then failed("Gmod failed to initialize a Material for this image") return end
					cached[filename] = mat
				end
				
				callback(true, cached[filename])
			else
				http.Fetch(
					url,

					function(body, size, headers, httpCode)
						if size == 0 then failed("Empty response") return end
						if size > 2097152 then failed("File must be smaller than 2 MB") return end
						if httpCode < 200 or httpCode > 299 then failed("Error (HTTP " .. httpCode .. ")") return end

						local ContentType = headers["Content-Type"] or headers["content-type"]
						if not ContentType then
							for header, value in pairs(headers) do
								if header:lower() == "content-type" then
									ContentType = value
									break
								end
							end
						end

						if not ContentType then failed("Could not determine file type of image (PNG/JPG)") return end
						ContentType = ContentType:lower()

						local extension
						if ContentType == "image/jpeg" then
							extension = "jpg"
						elseif ContentType == "image/png" then
							extension = "png"
						else
							failed("Image must be a JPG or PNG") return
						end

						local filename = dir .. hash .. "." .. extension
						file.Write(filename, body)

						local mat = Material("data/" .. filename, "smooth mips")
						if mat:IsError() then failed("Gmod failed to initialize a Material for this image") return end
						
						cached[filename] = mat

						callback(true, cached[filename], nil, extension)
					end,

					function(err)
						failed("Gmod HTTP API Error: " .. err)
					end
				)
			end
		end
	end

	local authMode, backgroundColor

	local function picPreviewPaint(self, w, h)
		local backgroundColorInt = backgroundColor:GetInt()
		if self._backgroundColorInt ~= backgroundColorInt then
			self._backgroundColorInt = backgroundColorInt
			self._backgroundColor = bKeypads:IntToColor(backgroundColorInt)
			self._shouldDarkenForeground = bKeypads:DarkenForeground(self._backgroundColor)
		end

		surface.SetDrawColor(self._backgroundColor)
		surface.DrawRect(0,0,w,h)
		
		if self.CustomImage and not self.CustomImage:IsError() then
			surface.SetMaterial(self.CustomImage)
			surface.SetDrawColor(255,255,255)
			surface.DrawTexturedRect(5,5,128,128)
		elseif self.Image then
			if self._Image ~= authMode:GetInt() then
				self._Image = authMode:GetInt()
				self.Image = Material(authMode:GetInt() == bKeypads.AUTH_MODE.FACEID and "bkeypads/face_id" or "bkeypads/keycard")
			end
			surface.SetMaterial(self.Image)
			surface.SetDrawColor(self._shouldDarkenForeground and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE)
			surface.DrawTexturedRect(5,5,128,128)
		end

		surface.SetDrawColor(0,0,0)
		surface.DrawOutlinedRect(0,0,w,h)
	end

	local function picURLPaintOver(self, w, h)
		if self:IsHovered() then
			surface.SetTextColor(255,255,255)
			surface.SetFont("bKeypads.PicURLFont")

			local txtW, txtH = surface.GetTextSize(self:GetText())
			
			if txtW + 10 > self:GetWide() then
				DisableClipping(true)

					local txtHCenter = (h - txtH) / 2

					surface.SetDrawColor(0,0,0)
					surface.DrawRect(0, 0, txtW + 10, h)

					surface.SetTextPos(txtHCenter, txtHCenter)
					surface.DrawText(self:GetText())

				DisableClipping(false)
			end
		end
	end

	local function picNameAllowInput(self, char)
		return not char:match("[A-Za-z0-9-_]")
	end

	function bKeypads.KeypadImages:Open(callback)
		authMode, backgroundColor = GetConVar("bkeypads_auth_mode"), GetConVar("bkeypads_background_color")

		if IsValid(self.UI) then
			self.UI:Close()
		end

		local savedPicManifest = {}
		local picHashTable = {}
		if file.Exists("bkeypads/keypad_img/saved/manifest.json", "DATA") then
			local manifest = file.Read("bkeypads/keypad_img/saved/manifest.json", "DATA")
			if manifest then
				manifest = util.JSONToTable(manifest)
				if manifest then
					savedPicManifest = manifest
				end
			end
		end

		self.UI = vgui.Create("DFrame")
		self.UI:SetTitle(L"SetLogoImage")
		self.UI:SetIcon("icon16/picture.png")
		self.UI:SetSize(650, 341)
		self.UI:DockPadding(10, 10 + 24, 10, 10)
		self.UI:Center()
		self.UI:MakePopup()
		self.UI:SetDrawOnTop(true)
		self.UI:MoveToFront()
		self.UI:DoModal()
		self.UI.OnClose = function()
			if callback then callback(false) end
		end

		local whitelistedDomainsContainer = vgui.Create("DPanel", self.UI)
		whitelistedDomainsContainer:Dock(LEFT)
		whitelistedDomainsContainer:DockMargin(0, 0, 10, 0)
		whitelistedDomainsContainer:SetWide(150)
		whitelistedDomainsContainer.Paint = nil

			local whitelistedDomainsTip = vgui.Create("DLabel", whitelistedDomainsContainer)
			whitelistedDomainsTip:Dock(TOP)
			whitelistedDomainsTip:SetWrap(true)
			whitelistedDomainsTip:SetAutoStretchVertical(true)
			whitelistedDomainsTip:SetText(L"WhitelistedDomainsTip")
			whitelistedDomainsTip:SetContentAlignment(7)
			whitelistedDomainsTip:DockMargin(0, 0, 0, 10)

			local whitelistedDomains = vgui.Create("DListView", whitelistedDomainsContainer)
			whitelistedDomains:Dock(FILL)
			whitelistedDomains:AddColumn(L"WhitelistedDomains")
			for _, whitelisted in ipairs(bKeypads.Config.Appearance.CustomImages.URLWhitelist) do
				whitelistedDomains:AddLine(whitelisted)
			end

		local listContainer = vgui.Create("DPanel", self.UI)
		listContainer.Paint = nil
		listContainer:Dock(LEFT)
		listContainer:DockMargin(0, 0, 10, 0)
		listContainer:SetWide(250)
		
			local picList = vgui.Create("DListView", listContainer)
			picList:Dock(FILL)
			picList:DockMargin(0, 0, 0, 10)
			picList:AddColumn(L"Name")
			picList:AddColumn(L"Added")
			picList:AddColumn(L"Size")
			picList:SetMultiSelect(false)
			function picList:Populate(selectFile)
				self:Clear()

				local selectRow
				for name, manifest in pairs(savedPicManifest) do
					if not manifest.hash or not manifest.extension or not manifest.URL then continue end
					
					local filename = "bkeypads/keypad_img/saved/" .. manifest.hash .. "." .. manifest.extension

					local row = self:AddLine(name, os.date("%x %X", file.Time(filename, "DATA")), string.NiceSize(file.Size(filename, "DATA")))
					row.Hash = manifest.hash
					row.PicName = name
					row.URL = manifest.URL
					row.FileName = filename

					picHashTable[manifest.hash] = name

					if selectFile == name then
						selectRow = row
					end
				end
				if selectRow then self:SelectItem(selectRow) end

				self:SortByColumn(1, true)
			end
			picList:Populate()

			local newBtn = vgui.Create("DButton", listContainer)
			newBtn:Dock(BOTTOM)
			newBtn:SetTall(25)
			newBtn:SetText(L"NewImage")
			newBtn:SetIcon("icon16/add.png")
			newBtn.DoClick = function()
				Derma_StringRequest(L"NewImageTitle", L"NewImageSubtitle", "", function(url)
					if url and #url > 0 then
						local verified, domain = bKeypads.KeypadImages:VerifyURL(url, true)
						if verified then
							local hash = bKeypads.KeypadImages:GetURLHash(url)
							if picHashTable[hash] then
								Derma_Message(string.format(L"ImageAlreadyExists", picHashTable[hash]), L"NewImageTitle", L"Dismiss")
							else
								local loading = Derma_Message(L"CheckingURL", L"NewImageTitle", L"Cancel")
								bKeypads.KeypadImages:GetImage(url, function(success, mat, retry, extension)
								
									if not IsValid(loading) then return end

									loading:Close()

									if not success then Derma_Message(L"InvalidImage" .. mat, L"NewImageTitle", L"Dismiss") return end
									
									savedPicManifest[hash] = {
										hash = hash,
										URL = url,
										extension = extension
									}

									file.Write("bkeypads/keypad_img/saved/manifest.json", util.TableToJSON(savedPicManifest))

									picList:Populate(hash)

								end, true, true)
							end
						elseif domain then
							Derma_Message(L"DomainNotWhitelisted", L"NewImageTitle", L"Dismiss")
						else
							Derma_Message(L"InvalidURL", L"NewImageTitle", L"Dismiss")
						end
					end
				end)
			end

		local rightPanel = vgui.Create("DPanel", self.UI)
		rightPanel:Dock(FILL)
		rightPanel.Paint = nil

			local picPreviewPanel = vgui.Create("DPanel", rightPanel)
			picPreviewPanel:Dock(FILL)
			picPreviewPanel:DockPadding(10, 10, 10, 10)

				local picPreview = vgui.Create("DPanel", picPreviewPanel)
				picPreview:SetSize(128 + 10, 128 + 10)
				picPreview.Image = true
				picPreview.Paint = picPreviewPaint

				local picName = vgui.Create("DTextEntry", picPreviewPanel)
				picName:DockMargin(0, 128 + 10 + 10, 0, 0)
				picName:Dock(TOP)
				picName:SetTall(25)
				picName:SetDisabled(true)
				picName:SetPlaceholderText(L"ImageName")
				picName:SetUpdateOnType(true)
				picName.AllowInput = picNameAllowInput

				local picURL = vgui.Create("DTextEntry", picPreviewPanel)
				picURL:DockMargin(0, 10, 0, 0)
				picURL:Dock(TOP)
				picURL:SetTall(25)
				picURL:SetDisabled(true)
				picURL:SetPlaceholderText("URL...")
				picURL:SetUpdateOnType(true)
				picURL.PaintOver = picURLPaintOver
				picURL.AllowInput = function() return true end
				picURL.OnValueChange = function()
					if picURL.URL and picURL:GetText() ~= picURL.URL then
						picURL:SetText(picURL.URL)
					end
				end

				local btnContainer = vgui.Create("DPanel", picPreviewPanel)
				btnContainer:DockMargin(0, 10, 0, 10)
				btnContainer:Dock(TOP)
				btnContainer:SetTall(25)

					local save = vgui.Create("DButton", btnContainer)
					save:Dock(LEFT)
					save:SetText(L"Save")
					save:SetIcon("icon16/disk.png")
					save:SetDisabled(true)
					save.DoClick = function()
						save:SetDisabled(true)

						local oldName = picPreview.CustomImageName
						picPreview.CustomImageName = picName:GetText()
						
						savedPicManifest[picPreview.CustomImageName] = savedPicManifest[oldName]
						savedPicManifest[oldName] = nil

						picList:Populate(picPreview.CustomImageName)

						file.Write("bkeypads/keypad_img/saved/manifest.json", util.TableToJSON(savedPicManifest))
					end

					local delete = vgui.Create("DButton", btnContainer)
					delete:Dock(RIGHT)
					delete:SetText(L"Delete")
					delete:SetIcon("icon16/cancel.png")
					delete:SetDisabled(true)

				function btnContainer:PerformLayout(w,h)
					save:SetWide((w / 2) - 5)
					delete:SetWide((w / 2) - 5)
				end

				local done = vgui.Create("DButton", picPreviewPanel)
				done:Dock(TOP)
				done:SetTall(25)
				done:SetText(L"SetLogoImage")
				done:SetIcon("icon16/picture.png")
				done:SetDisabled(true)
				done.DoClick = function()
					callback(true, savedPicManifest[picPreview.CustomImageName].URL, picPreview.CustomImage)
					callback = nil
					self.UI:Close()
				end
				
				delete.DoClick = function()
					Derma_Query(L"AreYouSureDeleteImage", L"DeleteImage", L"Delete", function()

						local manifest = savedPicManifest[picPreview.CustomImageName]
						file.Delete("bkeypads/keypad_img/saved/" .. manifest.hash .. "." .. manifest.extension)
						
						savedPicManifest[picPreview.CustomImageName] = nil
						if table.IsEmpty(savedPicManifest) then
							file.Delete("bkeypads/keypad_img/saved/manifest.json")
						else
							file.Write("bkeypads/keypad_img/saved/manifest.json", util.TableToJSON(savedPicManifest))
						end

						picList:Populate()
						
						picPreview.CustomImage = nil
						picPreview.CustomImageName = nil
						picName:SetText("")
						picURL:SetText("")
						delete:SetDisabled(true)
						save:SetDisabled(true)
						done:SetDisabled(true)

					end, L"Cancel")
				end
			
			function rightPanel:PerformLayout()
				picPreview:CenterHorizontal()
				picPreview:AlignTop(10)
			end
		
		local function checkFields()
			local success = picName:GetText() ~= picPreview.CustomImageName and #string.Trim(picName:GetText()) > 0 and bKeypads.KeypadImages:VerifyURL(picURL:GetText(), true)
			save:SetDisabled(not success)
			done:SetDisabled(picPreview.CustomImage == nil or success)
		end

		picName.OnValueChange = checkFields
		picName.OnEnter = checkFields
		picName.OnFocusChanged = checkFields

		picList.OnRowSelected = function(self, index, pnl)
			picPreview.CustomImage = Material("data/" .. pnl.FileName, "smooth mip")
			picPreview.CustomImageName = pnl.PicName
		
			picName:SetText(pnl.PicName)
			picURL.URL = pnl.URL
			picURL:SetText(pnl.URL)

			picURL:SetDisabled(false)
			picName:SetDisabled(false)
			delete:SetDisabled(false)
			done:SetDisabled(false)
			
			checkFields()
		end
	end
end

do
	bKeypads.KeypadImages.Bans = {}
	bKeypads.KeypadImages.Bans.List = {}

	function bKeypads.KeypadImages.Bans:Check(ply)
		if SERVER then
			return bKeypads.KeypadImages.Bans.List[ply:SteamID()] == true
		else
			return bKeypads.KeypadImages.Bans.List[ply] == true
		end
	end

	if CLIENT then
		net.Receive("bKeypads.KeypadImages.Bans", function()
			if net.ReadBool() then
				-- Downloading all bans
				for i = 1, net.ReadUInt(8) do
					bKeypads.KeypadImages.Bans.List[net.ReadEntity()] = true
				end
			else
				-- Receiving single ban
				local banned = net.ReadBool()
				local ply = net.ReadEntity()
				bKeypads.KeypadImages.Bans.List[ply] = banned or nil
			end
		end)

		bKeypads:InitPostEntity(function()
			net.Start("bKeypads.KeypadImages.Bans")
			net.SendToServer()
		end)
	else
		util.AddNetworkString("bKeypads.KeypadImages.Bans")

		file.CreateDir("bkeypads/keypad_img")
		if file.Exists("bkeypads/keypad_img/bans.json", "DATA") then
			local banList = file.Read("bkeypads/keypad_img/bans.json", "DATA")
			if banList then
				banList = util.JSONToTable(banList)
				if banList then
					bKeypads.KeypadImages.Bans.List = banList
				end
			end
		else
			file.Write("bkeypads/keypad_img/bans.json", "{}")
		end

		function bKeypads.KeypadImages:Save()
			file.Write("bkeypads/keypad_img/bans.json", util.TableToJSON(bKeypads.KeypadImages.Bans.List))
		end

		bKeypads.KeypadImages.Bans.Players = {}

		do
			local downloaded = {}
			net.Receive("bKeypads.KeypadImages.Bans", function(_, ply)
				if downloaded[ply] then return end
				downloaded[ply] = true

				net.Start("bKeypads.KeypadImages.Bans")
					net.WriteBool(true)
					net.WriteUInt(#bKeypads.KeypadImages.Bans.Players, 8)
					for _, banPly in ipairs(bKeypads.KeypadImages.Bans.Players) do net.WriteEntity(banPly) end
				net.Send(ply)
			end)
		end

		hook.Add("PlayerDisconnected", "bKeypads.KeypadImages.Bans", function(ply)
			local sid = ply:SteamID()
			if sid and bKeypads.KeypadImages.Bans.List[sid] then
				table.RemoveByValue(bKeypads.KeypadImages.Bans.Players, ply)
			else
				for i = #bKeypads.KeypadImages.Bans.Players, 1, -1 do
					if not IsValid(bKeypads.KeypadImages.Bans.Players[i]) then
						table.remove(bKeypads.KeypadImages.Bans.Players, i)
					end
				end
			end
		end)

		hook.Add("PlayerInitialSpawn", "bKeypads.KeypadImages.Bans", function(ply)
			local sid = ply:SteamID()
			if bKeypads.KeypadImages.Bans.List[sid] then
				table.insert(bKeypads.KeypadImages.Bans.Players, ply)

				net.Start("bKeypads.KeypadImages.Bans")
					net.WriteBool(false)
					net.WriteEntity(ply)
					net.WriteBool(true)
				net.Broadcast()
			end
		end)

		function bKeypads.KeypadImages:Ban(ply, admin)
			if ply == admin then return end

			local sid = ply:SteamID()
			if not bKeypads.KeypadImages.Bans.List[sid] then
				bKeypads.KeypadImages.Bans.List[sid] = true
				table.insert(bKeypads.KeypadImages.Bans.Players, ply)

				net.Start("bKeypads.KeypadImages.Bans")
					net.WriteBool(false)
					net.WriteEntity(ply)
					net.WriteBool(true)
				net.SendOmit(admin)

				bKeypads.KeypadImages:Save()

				hook.Run("bKeypads.KeypadImages.Ban", ply, admin)
			end
		end

		function bKeypads.KeypadImages:Unban(ply, admin)
			if ply == admin then return end
			
			local sid = ply:SteamID()
			if bKeypads.KeypadImages.Bans.List[sid] then
				bKeypads.KeypadImages.Bans.List[sid] = nil
				table.RemoveByValue(bKeypads.KeypadImages.Bans.Players, ply)

				net.Start("bKeypads.KeypadImages.Bans")
					net.WriteBool(false)
					net.WriteEntity(ply)
					net.WriteBool(false)
				net.SendOmit(admin)

				bKeypads.KeypadImages:Save()

				hook.Run("bKeypads.KeypadImages.Unban", ply, admin)
			end
		end
	end

	do
		local keypadImages = bKeypads.ContextMenu:AddMember("#bKeypads_KeypadImages", "icon16/picture.png", function(self, ent, ply)
			return ent.bKeypad or (ent:IsPlayer() and ent ~= ply)
		end)

		keypadImages:AddMember(
			"#bKeypads_Remove",
			"icon16/delete.png",
			
			function(self, ent, ply)
				return ent.bKeypad and ((SERVER and ent:GetImageURL() ~= "") or (CLIENT and ent.CustomImage)) and bKeypads.Permissions:Check(ply, "administration/custom_img/remove") and (not IsValid(ent:GetKeypadOwner()) or (ent:GetKeypadOwner() ~= LocalPlayer() and not bKeypads.Permissions:Check(ent:GetKeypadOwner(), "administration/custom_img/remove")))
			end,

			function(self, ent, ply)
				if CLIENT then
					self:Network() self:Network()
				else
					ent:SetImageURL("")
					if IsValid(ent:GetKeypadOwner()) then
						hook.Run("bKeypads.KeypadImages.Removed", ent:GetKeypadOwner(), ply, ent)
					end
				end
			end,

			true
		)

		keypadImages:AddMember(
			"#bKeypads_BanFromFeature",
			"icon16/user_delete.png",

			function(self, ent, ply)
				if not bKeypads.Permissions:Check(ply, "administration/custom_img/ban") then return false end
				if ent:IsPlayer() and ent ~= LocalPlayer() and not bKeypads.Permissions:Check(ent, "administration/custom_img/ban") then
					return not bKeypads.KeypadImages.Bans:Check(ent)
				elseif ent.bKeypad and ((SERVER and ent:GetImageURL() ~= "") or (CLIENT and ent.CustomImage)) and IsValid(ent:GetKeypadOwner()) and ent:GetKeypadOwner() ~= LocalPlayer() and not bKeypads.Permissions:Check(ent:GetKeypadOwner(), "administration/custom_img/ban") then
					return not bKeypads.KeypadImages.Bans:Check(ent:GetKeypadOwner())
				end
			end,

			function(self, ent, ply)
				if CLIENT then
					local banPly = ent:GetKeypadOwner()

					self:Network()
						net.WriteEntity(banPly)
					self:Network()

					bKeypads.KeypadImages.Bans.List[banPly] = true

					notification.AddLegacy(bKeypads.L"BannedFromFeatureAdmin", NOTIFY_ERROR, 3)
				else
					local banPly = net.ReadEntity()
					if IsValid(banPly) and banPly:IsPlayer() then
						bKeypads.KeypadImages:Ban(banPly, ply)

						for _, keypad in ipairs(bKeypads.Keypads) do
							if keypad:GetKeypadOwner() == banPly then
								keypad:SetImageURL("")
							end
						end
					end
				end
			end,
			
			true
		)

		keypadImages:AddMember(
			"#bKeypads_UnbanFromFeature",
			"icon16/user_add.png",

			function(self, ent, ply)
				if not bKeypads.Permissions:Check(ply, "administration/custom_img/ban") then return false end
				if ent:IsPlayer() and ent ~= LocalPlayer() and not bKeypads.Permissions:Check(ent, "administration/custom_img/ban") then
					return bKeypads.KeypadImages.Bans:Check(ent)
				elseif ent.bKeypad and IsValid(ent:GetKeypadOwner()) and ent:GetKeypadOwner() ~= LocalPlayer() and not bKeypads.Permissions:Check(ent:GetKeypadOwner(), "administration/custom_img/ban") then
					return bKeypads.KeypadImages.Bans:Check(ent:GetKeypadOwner())
				end
			end,

			function(self, ent, ply)
				if CLIENT then
					local banPly = ent:GetKeypadOwner()
					
					self:Network()
						net.WriteEntity(banPly)
					self:Network()

					bKeypads.KeypadImages.Bans.List[banPly] = nil

					notification.AddLegacy(bKeypads.L"UnbannedFromFeatureAdmin", NOTIFY_HINT, 3)
				else
					local banPly = net.ReadEntity()
					if IsValid(banPly) and banPly:IsPlayer() then
						bKeypads.KeypadImages:Unban(banPly, ply)
					end
				end
			end,
			
			true
		)
	end
end
--addons/bkeypads/lua/bkeypads/sh_map_linking.lua:
if SERVER then
	for _, ent in ipairs(ents.GetAll()) do
		if ent:GetClass() == "bkeypads_map_link" then
			ent:Remove()
		end
	end
end

bKeypads.MapLinking = {}

bKeypads.MapLinking.Links = {}
bKeypads.MapLinking.LinkEnts = {}

bKeypads.MapLinking.F_PSEUDOLINK = 2^0
bKeypads.MapLinking.F_DISABLE_ENT = 2^1
bKeypads.MapLinking.F_REDIRECT_USE = 2^2

bKeypads.MapLinking.F_BUTTON_HIDE = 2^0
bKeypads.MapLinking.F_BUTTON_TOGGLE = 2^1
bKeypads.MapLinking.F_BUTTON_DOUBLE_TOGGLE = 2^2
bKeypads.MapLinking.F_BUTTON_HOLD = 2^3

bKeypads.MapLinking.F_DOOR_NOLOCKPICK = 2^0
bKeypads.MapLinking.F_DOOR_TOGGLE = 2^1
bKeypads.MapLinking.F_DOOR_LOCK = 2^2

function bKeypads.MapLinking:GetRootDoor(ent)
	local prnt = ent:GetParent()
	if IsValid(prnt) and bKeypads.MapLinking:IsDoor(prnt) then
		return bKeypads.MapLinking:GetRootDoor(prnt)
	else
		return ent
	end
end

do
	local DoorDarkRPMode = DarkRP and FindMetaTable("Entity").isDoor ~= nil or false
	local doorEntities = {
		["func_door"] = true,
		["func_door_rotating"] = true,
		["prop_door_rotating"] = true,
		["func_movelinear"] = true,
		["prop_dynamic"] = true
	}
	function bKeypads.MapLinking:IsDoor(door)
		if not bKeypads.Config.MapLinking.Doors then return false end
		if door:GetNWBool("bKeypads.IsDoor") then return true end
		if DoorDarkRPMode then
			return door:isDoor() or doorEntities[door:GetClass()] or false
		else
			return doorEntities[door:GetClass()] or false
		end
	end

	hook.Add("canLockpick", "bKeypads.MapLinking.canLockpick", function(ply, ent)
		if IsValid(ent) and bKeypads.MapLinking:IsDoor(ent) then
			local links = bKeypads.MapLinking:GetLinks(ent)
			if links then
				for keypad, linkData in pairs(links) do
					if not IsValid(keypad) then continue end

					local link = select(2, next(linkData))
					if not IsValid(link) then continue end

					if link:HasGeneralFlag(bKeypads.MapLinking.F_DISABLE_ENT) or link:HasDoorFlag(bKeypads.MapLinking.F_DOOR_NOLOCKPICK) then
						return false
					end
				end
			end
		end
	end)

	function bKeypads.MapLinking:IsSandboxButton(btn)
		return btn:GetClass() == "gmod_button"
	end

	local btnEntities = {
		["func_button"] = true,
		["func_rot_button"] = true
	}
	function bKeypads.MapLinking:IsMapButton(btn)
		if not bKeypads.Config.MapLinking.Buttons then return false end
		if btn:GetNWBool("bKeypads.IsButton") then return true end
		return btnEntities[btn:GetClass()]
	end

	function bKeypads.MapLinking:IsButton(btn)
		return bKeypads.MapLinking:IsMapButton(btn) or bKeypads.MapLinking:IsSandboxButton(btn)
	end

	function bKeypads.MapLinking:IsLinkEntity(ent)
		return bKeypads.MapLinking:IsDoor(ent) or bKeypads.MapLinking:IsButton(ent)
	end
end

function bKeypads.MapLinking:GetLinks(keypad_or_ent)
	return bKeypads.MapLinking.Links[keypad_or_ent] or bKeypads.MapLinking.Links[keypad_or_ent] or nil
end

function bKeypads.MapLinking:IsLinked(keypad, ent)
	return IsValid(keypad) and IsValid(ent) and bKeypads.MapLinking.Links[ent] and bKeypads.MapLinking.Links[ent][keypad] and next(bKeypads.MapLinking.Links[ent][keypad]) ~= nil
end

function bKeypads.MapLinking:RegisterLink(link, keypad, ent, accessType)
	bKeypads.MapLinking.Links[keypad] = bKeypads.MapLinking.Links[keypad] or {}
	bKeypads.MapLinking.Links[keypad][ent] = bKeypads.MapLinking.Links[keypad][ent] or {}
	bKeypads.MapLinking.Links[keypad][ent][accessType] = link

	bKeypads.MapLinking.Links[ent] = bKeypads.MapLinking.Links[ent] or {}
	bKeypads.MapLinking.Links[ent][keypad] = bKeypads.MapLinking.Links[ent][keypad] or {}
	bKeypads.MapLinking.Links[ent][keypad][accessType] = link
end

function bKeypads.MapLinking:DeregisterLink(keypad, ent, accessType)
	if bKeypads.MapLinking.Links[ent] and bKeypads.MapLinking.Links[ent][keypad] and bKeypads.MapLinking.Links[ent][keypad][accessType] then
		bKeypads.MapLinking.Links[ent][keypad] = nil
		if table.IsEmpty(bKeypads.MapLinking.Links[ent]) then
			bKeypads.MapLinking.Links[ent] = nil
		end
	end
	if bKeypads.MapLinking.Links[keypad] and bKeypads.MapLinking.Links[keypad][ent] and bKeypads.MapLinking.Links[keypad][ent][accessType] then
		bKeypads.MapLinking.Links[keypad][ent] = nil
		if table.IsEmpty(bKeypads.MapLinking.Links[keypad]) then
			bKeypads.MapLinking.Links[keypad] = nil
		end
	end
end

-- TODO add halos on persistence tool

function bKeypads.MapLinking:BuildLinksTable()
	bKeypads.MapLinking.RebuildLinkTable = nil

	bKeypads.MapLinking.Links = {}

	for link in pairs(bKeypads.MapLinking.LinkEnts) do
		if not IsValid(link) then
			bKeypads.MapLinking.LinkEnts[link] = nil
			continue
		end

		local keypad, ent, accessType = link:GetKeypad(), link:GetLinkedEnt(), link:GetAccessType()
		if IsValid(ent) and IsValid(keypad) then
			bKeypads.MapLinking:RegisterLink(link, keypad, ent, accessType)
		end

		if IsValid(ent) and link:HasButtonFlag(bKeypads.MapLinking.F_BUTTON_HIDE) then
			bKeypads.MapLinking:Hide(ent)
		end
	end

	if CLIENT then bKeypads.ESP:Refresh() end
end

do
	local function FindUseEntity(ply, defaultEnt)
		local linker = ply:GetTool()
		if not linker or linker.Mode ~= "bkeypads_linker" then linker = nil end

		local links = bKeypads.MapLinking:GetLinks(defaultEnt)
		if links then
			local redirectKeypad
			local closest_dist = math.huge
			for ent, linkData in pairs(links) do
				local link = select(2, next(linkData))
				if not IsValid(link) then continue end

				if link:HasGeneralFlag(bKeypads.MapLinking.F_REDIRECT_USE) and IsValid(link:GetKeypad()) then
					local dist = link:GetKeypad():WorldSpaceCenter():DistToSqr(defaultEnt:WorldSpaceCenter())
					if dist < closest_dist then
						closest_dist = dist
						redirectKeypad = link:GetKeypad()
					end
				end
			end
			
			if linker then
				linker.m_eFindUseEntity = defaultEnt
				linker.m_iFindUseEntityTick = engine.TickCount()
			end
			return redirectKeypad
		end

		if linker then
			linker.m_eFindUseEntity = nil
			linker.m_iFindUseEntityTick = engine.TickCount()
		end
	end

	function bKeypads.MapLinking.RedirectUse(ply, defaultEnt)
		if IsValid(defaultEnt) and not defaultEnt.bKeypad then
			local root = bKeypads.MapLinking:GetRootDoor(defaultEnt)
			if IsValid(root) and root ~= defaultEnt then
				return FindUseEntity(ply, root) or FindUseEntity(ply, defaultEnt)
			else
				return FindUseEntity(ply, defaultEnt)
			end
		end
	end

	hook.Add("FindUseEntity", "bKeypads.FindUseEntity", bKeypads.MapLinking.RedirectUse)
end

if CLIENT then
	function bKeypads.MapLinking:Hide(ent)
		if not IsValid(ent) then return end
		if not bKeypads.MapLinking:IsMapButton(ent) then return end
		if ent.bKeypads_MapLinking_SetNoDraw == nil then
			ent.bKeypads_MapLinking_SetNoDraw = not ent:GetNoDraw() or nil
		end
		ent:SetNoDraw(true)
	end

	function bKeypads.MapLinking:Show(ent)
		if not IsValid(ent) then return end
		if not bKeypads.MapLinking:IsMapButton(ent) then return end
		if ent.bKeypads_MapLinking_SetNoDraw then
			ent.bKeypads_MapLinking_SetNoDraw = nil
			ent:SetNoDraw(false)
		end
	end
end

local readyFuncs = {}
function bKeypads.MapLinking:Ready(callback)
	if bKeypads_MapLinking_Ready == true then
		bKeypads:InitPostEntity(callback)
	else
		table.insert(readyFuncs, callback)
	end
end
hook.Add("bKeypads.MapLinking.Ready", "bKeypads.MapLinking.Ready.Internal", function()
	bKeypads:InitPostEntity(function()
		if bKeypads_MapLinking_Ready then return end
		bKeypads_MapLinking_Ready = true
		for _, f in ipairs(readyFuncs) do f() end
		readyFuncs = nil
	end)
end)
--addons/bkeypads_cracker/lua/bkeypads/sh_cracker.lua:
bKeypads.Cracker = {}

if SERVER then
	bKeypads.Cracker.License = include("bkeypads/cracker_license.lua")
	if not bKeypads.Cracker.License then return end
	bKeypads:print("Version " .. bKeypads.Cracker.License.Version, bKeypads.PRINT_TYPE_SPECIAL, "CRACKER")
	bKeypads:print("Licensed to " .. util.SteamIDFrom64(bKeypads.Cracker.License.SteamID64), bKeypads.PRINT_TYPE_SPECIAL, "CRACKER")
	
	resource.AddWorkshop("2328355906")

	include("bkeypads/sv_cracker_drm.lua")
	include("bkeypads/sv_permissions.lua")

	AddCSLuaFile("bkeypads/cl_cracker.lua")
	AddCSLuaFile("bkeypads_cracker_config.lua")
else
	include("bkeypads/cl_cracker.lua")
end

--## Fonts ##--

if CLIENT then
	surface.CreateFont("bKeypads.Cracker", {
		size = 48,
		font = "8BIT WONDER"
	})

	surface.CreateFont("bKeypads.Cracker.Small", {
		size = 32,
		font = "8BIT WONDER"
	})
end

--## Materials ##--

if CLIENT then
	bKeypads.Cracker.Materials = {}
	bKeypads.Cracker.Materials.SCREEN_BLUE  = Material("bkeypads/keypad_cracker_screen_blue.png", "smooth")
	bKeypads.Cracker.Materials.SCREEN_RED   = Material("bkeypads/keypad_cracker_screen_red.png", "smooth")
	bKeypads.Cracker.Materials.SCREEN_GREEN = Material("bkeypads/keypad_cracker_screen_green.png", "smooth")

	bKeypads.Cracker.CrackingEmotes = { "neutral", "default", "happy", "surprised", "success", "confused", "sorry" }
end

--## Load Config ##--

bKeypads_Cracker_ConfigAutoRefresh = nil
function bKeypads.Cracker:SetConfig(conf)
	bKeypads.Cracker.Config = conf
	bKeypads.Cracker:ProcessConfig()

	if bKeypads_Cracker_ConfigAutoRefresh then
		hook.Run("bKeypads.Cracker.ConfigUpdated")
		bKeypads:print("Config was updated", bKeypads.PRINT_TYPE_SPECIAL, "CRACKER")
	else
		bKeypads_Cracker_ConfigAutoRefresh = true
		bKeypads:print("Config loaded successfully", bKeypads.PRINT_TYPE_SPECIAL, "CRACKER")
	end
end

function bKeypads.Cracker:LoadConfig()
	bKeypads.Cracker.Config = nil

	if SERVER and bKeypads.simplerr then
		local succ, err = bKeypads.simplerr.runFile("bkeypads_cracker_config.lua")
		if not succ then
			MsgC("\n")
			ErrorNoHalt(err or "[ERROR] UNKNOWN error in \"bkeypads_cracker_config.lua\"")
		end
	end
	include("bkeypads_cracker_config.lua")
end

function bKeypads.Cracker:ProcessConfig()
	bKeypads.Cracker.Settings = {}

	if isnumber(bKeypads.Cracker.Config.CrackTime) then
		bKeypads.Cracker.Settings.CrackTime = {bKeypads.Cracker.Config.CrackTime, bKeypads.Cracker.Config.CrackTime}
	elseif istable(bKeypads.Cracker.Config.CrackTime) and #bKeypads.Cracker.Config.CrackTime == 1 then
		bKeypads.Cracker.Settings.CrackTime = {bKeypads.Cracker.Config.CrackTime[1], bKeypads.Cracker.Config.CrackTime[1]}
	elseif istable(bKeypads.Cracker.Config.CrackTime) and #bKeypads.Cracker.Config.CrackTime == 2 and isnumber(bKeypads.Cracker.Config.CrackTime[1]) and isnumber(bKeypads.Cracker.Config.CrackTime[2]) then
		bKeypads.Cracker.Settings.CrackTime = {math.min(unpack(bKeypads.Cracker.Config.CrackTime)), math.max(unpack(bKeypads.Cracker.Config.CrackTime))}
	else
		bKeypads.Cracker.Settings.CrackTime = {20, 30}
	end

	bKeypads.Cracker.Settings.SpecialCrackTimes = {
		Teams = {},
		Usergroups = {},
		Functions = {}
	}
	for _, specialCrackTime in pairs(bKeypads.Cracker.Config.SpecialCrackTimes) do
		if #specialCrackTime ~= 2 then continue end

		local tbl
		if isstring(specialCrackTime[1]) then
			tbl = bKeypads.Cracker.Settings.SpecialCrackTimes.Usergroups
		elseif isnumber(specialCrackTime[1]) then
			tbl = bKeypads.Cracker.Settings.SpecialCrackTimes.Teams
		elseif isfunction(specialCrackTime[1]) then
			tbl = bKeypads.Cracker.Settings.SpecialCrackTimes.Functions
		else
			continue
		end

		local bounds = specialCrackTime[2]
		if isnumber(bounds) then
			bounds = {bounds, bounds}
		elseif istable(bounds) then
			if #bounds == 0 then continue end
			if #bounds == 1 then bounds[2] = bounds[1] end
			if not isnumber(bounds[1]) or not isnumber(bounds[2]) then continue end
			bounds = { math.min(unpack(bounds)), math.max(unpack(bounds)) }
		elseif not isfunction(bounds) then
			continue
		end
		
		if tbl == bKeypads.Cracker.Settings.SpecialCrackTimes.Functions then
			table.insert(tbl, bounds)
		else
			tbl[specialCrackTime[1]] = bounds
		end
	end

	if bKeypads.Cracker.Config.Damage.Enable and not table.IsEmpty(bKeypads.Cracker.Config.Damage.DamageTypeWhitelist) then
		bKeypads.Cracker.Settings.DamageTypeWhitelist = {}
		for _, dmg in pairs(bKeypads.Cracker.Config.Damage.DamageTypeWhitelist) do
			if isnumber(dmg) then
				table.insert(bKeypads.Cracker.Settings.DamageTypeWhitelist, dmg)
			end
		end
		bKeypads.Cracker.Settings.DamageTypeWhitelist = not table.IsEmpty(bKeypads.Cracker.Settings.DamageTypeWhitelist) and bit.bor(unpack(bKeypads.Cracker.Settings.DamageTypeWhitelist)) or nil

		bKeypads.Cracker.Settings.DamageTypeBlacklist = {}
		for _, dmg in pairs(bKeypads.Cracker.Config.Damage.DamageTypeBlacklist) do
			if isnumber(dmg) then
				table.insert(bKeypads.Cracker.Settings.DamageTypeBlacklist, dmg)
			end
		end
		bKeypads.Cracker.Settings.DamageTypeBlacklist = not table.IsEmpty(bKeypads.Cracker.Settings.DamageTypeBlacklist) and bit.bor(unpack(bKeypads.Cracker.Settings.DamageTypeBlacklist)) or nil
	end

	if not table.IsEmpty(bKeypads.Cracker.Config.CrackerPhrases) then
		bKeypads.Cracker.Settings.CrackerPhrases = {}
		for _, phrase in pairs(bKeypads.Cracker.Config.CrackerPhrases) do
			if not isstring(phrase) then continue end
			phrase = phrase:gsub("[^A-Za-z0-9 ]", "")
			if #phrase > 0 then
				table.insert(bKeypads.Cracker.Settings.CrackerPhrases, phrase)
			end
		end
	end
	if not bKeypads.Cracker.Settings.CrackerPhrases or table.IsEmpty(bKeypads.Cracker.Settings.CrackerPhrases) then
		bKeypads.Cracker.Settings.CrackerPhrases = { "CRACKING" }
	end

	bKeypads.Cracker.Settings.FailChance = 0
	if isnumber(bKeypads.Cracker.Config.FailChance) then
		bKeypads.Cracker.Settings.FailChance = math.Clamp(bKeypads.Cracker.Config.FailChance, 0, 1)
	end

	bKeypads.Cracker.Settings.CrackDistance = 2500
	if isnumber(bKeypads.Cracker.Config.FailChance) then
		bKeypads.Cracker.Settings.FailChance = math.max(bKeypads.Cracker.Config.FailChance, 0)
	end

	if CLIENT then
		if bKeypads.Cracker.Config.SeeDroppedCrackerThroughWalls then
			hook.Add("PreDrawViewModel", "bKeypads.Cracker.PreDrawViewModel", bKeypads.Cracker.PreDrawViewModel)
			hook.Add("PostDrawTranslucentRenderables", "bKeypads.Cracker.PostDrawTranslucentRenderables", bKeypads.Cracker.PostDrawTranslucentRenderables)
		else
			hook.Remove("PreDrawViewModel", "bKeypads.Cracker.PreDrawViewModel")
			hook.Remove("PostDrawTranslucentRenderables", "bKeypads.Cracker.PostDrawTranslucentRenderables")
		end
	end

	if DarkRP and DarkRP.createShipment and not bKeypads_Cracker_InitF4 then
		bKeypads_Cracker_InitF4 = true
		if bKeypads.Cracker.Config.F4Cracker.EnableShipment then
			local conf = table.Copy(bKeypads.Cracker.Config.F4Cracker.Shipment)
			conf.entity = "bkeypads_cracker"
			conf.model = "models/bkeypads/cracker.mdl"
			conf.separate = false
			conf.pricesep = nil
			conf.noship = nil

			conf.label = conf.label or "Keypad Cracker"
			DarkRP.createShipment("Keypad Cracker (Shipment)", conf)
		end
		if bKeypads.Cracker.Config.F4Cracker.EnableSingle then
			local conf = table.Copy(bKeypads.Cracker.Config.F4Cracker.Single)
			conf.entity = "bkeypads_cracker"
			conf.model = "models/bkeypads/cracker.mdl"
			conf.noship = true
			conf.separate = true
			conf.pricesep = conf.price or conf.pricesep or nil
			conf.price = conf.price or conf.pricesep or nil

			conf.label = conf.label or "Keypad Cracker"
			DarkRP.createShipment("Keypad Cracker", conf)
		end
	end
end

bKeypads.Cracker:LoadConfig()

if not bKeypads.Cracker.Config then
	MsgC("\n")
	bKeypads:print("Your KEYPAD CRACKER config file has a Lua error! Aborting.\n", bKeypads.PRINT_TYPE_BAD, "ERROR")
	return
else
	bKeypads:postLoadCustomDarkRPItems(bKeypads.Cracker.LoadConfig)
end

--## Sounds ##--

bKeypads.Cracker.Sounds = {
	alarm = {
		path = "bkeypads/cracker/alarm.mp3",
		duration = 0.5526562333107
	},
	error = {
		path = "bkeypads/cracker/error.mp3",
		duration = 1.1847916841507
	},
	success = {
		path = "bkeypads/cracker/success.mp3",
		duration = 0.46987500786781
	},
	typing = {
		{
			path = "bkeypads/cracker/typing_001.mp3",
			duration = 2.2309896945953
		},
		{
			path = "bkeypads/cracker/typing_002.mp3",
			duration = 10
		},
	},
	warning = {
		path = "bkeypads/cracker/warning.mp3",
		duration = 0.62650001049042
	},
	charge = {
		path = "bkeypads/cracker/charge.mp3",
		duration = 0.63439285755157
	},
	whirr = {
		path = "bkeypads/cracker/whirr.mp3",
		duration = 1.4367187023163
	},
	hello = {
		path = "bkeypads/cracker/hello.mp3",
		duration = 0.31719642877579
	},
	critical = {
		path = "bkeypads/cracker/critical.mp3",
		duration = 0.59707140922546
	},
}

for _, snd in ipairs(bKeypads.Cracker.Sounds) do
	if snd.path then
		snd.sound = Sound(snd.path)
	else
		for _, snd in ipairs(snd) do
			snd.sound = Sound(snd.path)
		end
	end
end

--## Utility ##--

function bKeypads.Cracker:GetCrackingPhrase()
	return bKeypads.Cracker.Settings.CrackerPhrases[math.random(1, #bKeypads.Cracker.Settings.CrackerPhrases)]
end

function bKeypads.Cracker:RollFailDice()
	if bKeypads.Cracker.Config.FailChance == 0 then return false end
	if bKeypads.Cracker.Config.FailChance == 1 then return true end
	return math.Rand(0, 1) <= bKeypads.Cracker.Settings.FailChance
end

function bKeypads.Cracker:CheckDamageType(dmg)
	if bKeypads.Cracker.Settings.DamageTypeWhitelist then
		return bKeypads.Cracker.Settings.DamageTypeWhitelist[dmg] or false
	else
		return true
	end
end

-- TODO bLogs support
--addons/bkeypads_cracker/lua/bkeypads/cl_cracker.lua:
--## Materials/Colors ##--

local matRadial = Material("bkeypads/radial_gradient.png", "smooth")
local matKeypadCracker = Material("bkeypads/keypad_cracker_selection")

local RT
local RTMat = CreateMaterial("bKeypads_CrackerESP", "UnlitGeneric", {
	["$vertexalpha"] = 1,
	["$translucent"] = 1
})

--## Data ##--

bKeypads.Cracker.Dropped = bKeypads.Cracker.Dropped or {}
bKeypads.Cracker.DroppedDict = bKeypads.Cracker.DroppedDict or {}
-- lua_run_cl table.insert(bKeypads.Cracker.Dropped, TRACE_ENT()) bKeypads.Cracker.DroppedDict[TRACE_ENT()] = true

--## Config ##--

local fadeDist = 200000
local fade2DDist = 100
local circleRadius = 40

local mins, maxs = Vector(-1.5, -4.0125, -0.075), Vector(2.25, 2.85, 3.3)
local pivot = (mins + maxs) / 2

--## Circle ##--

local circlePoly = (function(seggs)
	local x, y = circleRadius, circleRadius

	local cir = {}

	table.insert(cir, { x = x, y = y, u = 0.5, v = 0.5 })

	for i = 0, seggs do
		local a = math.rad((i / seggs) * -360)
		table.insert(cir, { x = x + math.sin(a) * circleRadius, y = y + math.cos(a) * circleRadius, u = math.sin(a) / 2 + 0.5, v = math.cos(a) / 2 + 0.5 })
	end

	local a = math.rad(0)
	table.insert(cir, { x = x + math.sin(a) * circleRadius, y = y + math.cos(a) * circleRadius, u = math.sin(a) / 2 + 0.5, v = math.cos(a) / 2 + 0.5 })

	return cir
end)(64)

local circleTranslation = Matrix()
circleTranslation:SetTranslation(Vector(-circleRadius, -circleRadius))

local circleDiameter = circleRadius * 2

--## Drawing ##--

local animStart
local distFrac
local dist2DFrac
local fadeFrac
local scaleFrac = 0
local HUDCracker
local x, y

local prevCracker, prevOptimizing
local scaleMatrix = Matrix()
local nextCheck
function bKeypads.Cracker:PostDrawTranslucentRenderables(bDrawingDepth, bDrawingSkybox)
	if bDrawingDepth or bDrawingSkybox or render.GetRenderTarget() ~= nil then return end
	if not bKeypads.Cracker.Config.SeeDroppedCrackerThroughWalls then return end

	if not nextCheck or SysTime() > nextCheck then
		nextCheck = SysTime() + .25

		HUDCracker = nil

		local HUDCrackerDist = math.huge
		for _, cracker in ipairs(bKeypads.Cracker.Dropped) do
			if not IsValid(cracker) or cracker.m_iAnimationStage ~= cracker.ANIM.FINISHED or cracker:GetDestroyed() then continue end
			
			local center = cracker:LocalToWorld(pivot)
			local screenPos = center:ToScreen()
			if not screenPos.visible then continue end

			local dist3D = center:DistToSqr(EyePos())
			local xDist = math.abs((ScrW() / 2) - screenPos.x)
			local yDist = math.abs((ScrH() / 2) - screenPos.y)

			local dist = (xDist + yDist) * dist3D
			if dist < HUDCrackerDist then
				HUDCracker, HUDCrackerDist = cracker, dist
			end
		end
	end

	if not IsValid(HUDCracker) or HUDCracker.m_iAnimationStage ~= HUDCracker.ANIM.FINISHED or HUDCracker:GetDestroyed() then
		HUDCracker = nil
		return
	end

	local needsRedraw = prevCracker ~= HUDCracker or prevOptimizing ~= bKeypads.Performance:Optimizing()
	if prevCracker ~= HUDCracker then
		animStart = CurTime()
	end
	
	local screenPos = HUDCracker:LocalToWorld(pivot):ToScreen()
	x, y = screenPos.x, screenPos.y

	local xDist = math.abs((ScrW() / 2) - screenPos.x)
	local yDist = math.abs((ScrH() / 2) - screenPos.y)
	dist2DFrac = ((xDist + yDist) - (fade2DDist / 2)) / fade2DDist

	local EyePos, WorldSpaceCenter = EyePos(), HUDCracker:WorldSpaceCenter()
	distFrac = math.Clamp((EyePos:DistToSqr(WorldSpaceCenter) - (fadeDist / 2)) / fadeDist, 0, 1)
	scaleFrac = math.min(bKeypads.ease.InOutSine(math.Clamp(math.TimeFraction(animStart, animStart + .5, CurTime()), 0, 1)), distFrac)
	fadeFrac = math.min(scaleFrac, dist2DFrac)

	if not needsRedraw or distFrac <= 0 then return end
	prevCracker = HUDCracker
	prevOptimizing = bKeypads.Performance:Optimizing()

	if distFrac == 1 and not HUDCracker.m_bESPSeen then
		HUDCracker:EmitSound(bKeypads.Cracker.Sounds["warning"].path, 511)
	end
	HUDCracker.m_bESPSeen = true

	if not RT then
		RT = GetRenderTarget("bKeypads_CrackerESPxxxxxxxxxxx", circleDiameter, circleDiameter)
		RTMat:SetTexture("$basetexture", RT:GetName())
		RTMat:Recompute()
	end

	local ang = (EyePos - WorldSpaceCenter):Angle()
	ang:RotateAroundAxis(ang:Right(), -90)
	ang:RotateAroundAxis(ang:Up(), 90)
	
	render.PushRenderTarget(RT)

		render.Clear(0, 0, 0, 0, true)
		render.OverrideAlphaWriteEnable(true, true)
		render.SetWriteDepthToDestAlpha(false)

		cam.Start2D()
			draw.NoTexture()
			surface.SetDrawColor(255, 255, 255)
			surface.DrawPoly(circlePoly)

			surface.SetMaterial(matRadial)
			surface.SetDrawColor(0, 0, 0, 200)
			surface.DrawPoly(circlePoly)

			if bKeypads.Performance:Optimizing() then
				local imgW, imgH = circleDiameter, (128 / 256) * circleDiameter
				surface.SetMaterial(matKeypadCracker)
				surface.SetDrawColor(255, 255, 255)
				surface.DrawTexturedRect((circleDiameter - imgW) / 2, circleRadius - ((128 / 256) * circleDiameter) / 1.5, imgW, imgH)
			end
		cam.End2D()

		if not bKeypads.Performance:Optimizing() then
			if not IsValid(bKeypads_ClientsideESPCracker) then
				bKeypads_ClientsideESPCracker = ClientsideModel("models/bkeypads/cracker.mdl", RENDERGROUP_OTHER)
				bKeypads_ClientsideESPCracker:SetNoDraw(true)
			end

			local FOV = 60
			local camPos = WorldSpaceCenter + HUDCracker:GetUp() * 10
			local camAng = HUDCracker:GetAngles()
			camAng:RotateAroundAxis(camAng:Right(), -90)

			cam.Start3D(camPos, camAng, FOV, 0, 0, circleDiameter, circleDiameter, 5, 4096)
				render.SuppressEngineLighting(true)
					bKeypads_ClientsideESPCracker:SetModelScale(HUDCracker:GetModelScale())
					bKeypads_ClientsideESPCracker:SetPos(HUDCracker:GetPos())
					bKeypads_ClientsideESPCracker:SetAngles(HUDCracker:GetAngles())
					bKeypads_ClientsideESPCracker:SetupBones()
					bKeypads_ClientsideESPCracker:DrawModel()
					HUDCracker.DrawWorldScreen(bKeypads_ClientsideESPCracker)
				render.SuppressEngineLighting(false)
			cam.End3D()
		end

		render.OverrideAlphaWriteEnable(false)

	render.PopRenderTarget()
end

function bKeypads.Cracker:PreDrawViewModel()
	if not RTMat or not IsValid(HUDCracker) then return end

	scaleMatrix:SetUnpacked(
		scaleFrac, 0, 0, (1 - scaleFrac) * x,
		0, scaleFrac, 0, (1 - scaleFrac) * y,
		0, 0, 0, 0,
		0, 0, 0, 1
	)
	
	cam.Start2D()
		cam.PushModelMatrix(scaleMatrix)
			surface.SetDrawColor(255, 255, 255, fadeFrac * 255)
			bKeypads:DrawSubpixelClippedMaterial(RTMat, x - (circleRadius), y - (circleRadius), circleDiameter, circleDiameter)
		cam.PopModelMatrix()
	cam.End2D()
end

if bKeypads.Cracker.Config and bKeypads.Cracker.Config.SeeDroppedCrackerThroughWalls then
	hook.Add("PreDrawViewModel", "bKeypads.Cracker.PreDrawViewModel", bKeypads.Cracker.PreDrawViewModel)
	hook.Add("PostDrawTranslucentRenderables", "bKeypads.Cracker.PostDrawTranslucentRenderables", bKeypads.Cracker.PostDrawTranslucentRenderables)
else
	hook.Remove("PreDrawViewModel", "bKeypads.Cracker.PreDrawViewModel")
	hook.Remove("PostDrawTranslucentRenderables", "bKeypads.Cracker.PostDrawTranslucentRenderables")
end

if IsValid(bKeypads_ClientsideESPCracker) then bKeypads_ClientsideESPCracker:Remove() end
--lua/autorun/asajj.lua:
player_manager.AddValidModel( "Asajj Ventress", "models/jellik/asajj/asajj.mdl");
list.Set( "PlayerOptionsModel", "Asajj Ventress", "models/jellik/asajj/asajj.mdl");
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )

bshields.lang = {
	["German"] = {
		["sec"] = "[RMB] Unsichtbar/Sichtbar",
		["dshieldprim"] = "[LMB] Platzieren",
		["hshieldprim"] = "[LMB] Schlagen",
		["rshieldprim"] = "[LMB] Schlagen",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	}
} 

if bshields.lang[bshields.config.language] == nil then
	bshields.config.language = "English"
end
--lua/autorun/bric.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Bric",		"models/player/tiki/bric.mdl" )

--lua/autorun/bx.lua:
player_manager.AddValidModel( "BX_droid", "models/sally/tkaro/bx_commando_droid.mdl" );
player_manager.AddValidHands( "BX_droid", "models/sally/tkaro/bx_commando_droid_hands.mdl",0 ,"00000000" );
--lua/autorun/cl_advert.lua:
 
-- This file is part of Adware Blocker.
--
--lua/autorun/durge.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel("Durge" ,"models/gonzo/durge/durge.mdl")
--lua/autorun/egm_187th.lua:
-- Register the tactical engineering battalion material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.187thTrooper", function()
	-- 187th Trooper Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_trooper", "187th Trooper - Armor", {
        ["body"] = "egm/187th/haupteinheit/body",
		["body_mirrored"] = "egm/187th/haupteinheit/body",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/187th/attachment/kama_arc",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_trooper", "187th Trooper - Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th Offizier Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_officer", "187th Officer - Armor", {
        ["body"] = "egm/187th/haupteinheit/body2",
		["body_mirrored"] = "egm/187th/haupteinheit/body2",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/187th/attachment/kama_arc",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_officer", "187th Officer - Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet2",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th Commander Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_cmd", "187th Commander - Armor", {
        ["body"] = "egm/187th/haupteinheit/body3",
		["body_mirrored"] = "egm/187th/haupteinheit/body3",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cmd",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_cmd", "187th Commander - Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet4",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th RMC Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_rmc", "187th RMC - Armor", {
        ["body"] = "egm/187th/haupteinheit/body4",
		["body_mirrored"] = "egm/187th/haupteinheit/body4",

        ["kama"] = "egm/187th/attachment/kama_rmc",
		["kama_arc"] = "egm/187th/attachment/kama_arc_rmc",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_rmc", "187th RMC - Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet5",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th TEB Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_teb", "187th TEB - Armor", {
        ["body"] = "egm/187th/haupteinheit/body5",
		["body_mirrored"] = "egm/187th/haupteinheit/body5",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/187th/attachment/kama_arc",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	-- 187th Alternative Helmet Haupteinheit
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_alt", "187th Alternative - Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet3",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th Airborne
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_airborne", "187th Airborne - Armor", {
        ["body"] = "egm/187th/haupteinheit/body_airborne",
		["body_mirrored"] = "egm/187th/haupteinheit/body_airborne",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/187th/attachment/kama_arc",

        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "187th_airborne", "187th Airborne - Helmet", {
		["helmet_airborne"] = "egm/187th/haupteinheit/helmet_airborne",
		["binoculars"] = "egm/187th/attachment/binoculars",
		["sunvisor"] = "egm/187th/attachment/sunvisor",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "187th_pilot", "187th Pilot - Helmet", {
		["helmet_pilot"] = "egm/187th/haupteinheit/helmet_pilot",
	})
	-- SF
	-- 187th SF Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thsf_trooper", "187th SF Trooper - Armor", {
        ["body"] = "egm/187th/sf/body",
		["body_mirrored"] = "egm/187th/sf/body",

        ["kama"] = "egm/187th/attachment/kama_sf",
		["kama_arc"] = "egm/187th/attachment/kama_arc_sf",

        ["pauldron"] = "egm/187th/attachment/pauldron_sf",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thsf_trooper", "187th SF Trooper - Helmet", {
		["helmet"] = "egm/187th/sf/helmet",

		["binoculars"] = "egm/187th/attachment/binoculars_sf",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th SF Officer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thsf_officer", "187th SF Officer - Armor", {
        ["body"] = "egm/187th/sf/body2",
		["body_mirrored"] = "egm/187th/sf/body2",

        ["kama"] = "egm/187th/attachment/kama_sf",
		["kama_arc"] = "egm/187th/attachment/kama_arc_sf",

        ["pauldron"] = "egm/187th/attachment/pauldron_sf",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thsf_officer", "187th SF Officer - Helmet", {
		["helmet"] = "egm/187th/sf/helmet2",

		["binoculars"] = "egm/187th/attachment/binoculars_sf",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th SF CMD
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thsf_cmd", "187th SF Commander - Armor", {
        ["body"] = "egm/187th/sf/body3",
		["body_mirrored"] = "egm/187th/sf/body3",

        ["kama"] = "egm/187th/attachment/kama_sf",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cmd",

        ["pauldron"] = "egm/187th/attachment/pauldron_sf",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thsf_cmd", "187th SF Commander - Helmet", {
		["helmet"] = "egm/187th/sf/helmet3",

		["binoculars"] = "egm/187th/attachment/binoculars_sf",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th SF RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thsf_rmc", "187th SF RMC - Armor", {
        ["body"] = "egm/187th/sf/body4",
		["body_mirrored"] = "egm/187th/sf/body4",

        ["kama"] = "egm/187th/attachment/kama_rmc",
		["kama_arc"] = "egm/187th/attachment/kama_arc_rmc",

        ["pauldron"] = "egm/187th/attachment/pauldron_sf",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thsf_rmc", "187th SF RMC - Helmet", {
		["helmet"] = "egm/187th/sf/helmet4",

		["binoculars"] = "egm/187th/attachment/binoculars_sf",

		["sunvisor"] = "egm/187th/attachment/sunvisor",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th SF TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thsf_teb", "187th SF TEB - Armor", {
        ["body"] = "egm/187th/sf/body5",
		["body_mirrored"] = "egm/187th/sf/body5",

        ["kama"] = "egm/187th/attachment/kama_sf",
		["kama_arc"] = "egm/187th/attachment/kama_arc_sf",

        ["pauldron"] = "egm/187th/attachment/pauldron_sf",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	-- CG
	-- 187th CG Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_trooper", "187th CG Trooper - Armor", {
        ["body"] = "egm/187th/cg/body",
		["body_mirrored"] = "egm/187th/cg/body",

        ["kama"] = "egm/187th/attachment/kama_cg",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cg",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thcg_trooper", "187th CG Trooper - Helmet", {
		["helmet"] = "egm/187th/cg/helmet",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th CG Officer 1
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_offic1", "187th CG Officer 1 - Armor", {
        ["body"] = "egm/187th/cg/body2",
		["body_mirrored"] = "egm/187th/cg/body2",

        ["kama"] = "egm/187th/attachment/kama_cg",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cg",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thcg_offic1", "187th CG Officer 1 - Helmet", {
		["helmet"] = "egm/187th/cg/helmet2",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th CG Officer 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_offic2", "187th CG Officer 2 - Armor", {
        ["body"] = "egm/187th/cg/body3",
		["body_mirrored"] = "egm/187th/cg/body3",

        ["kama"] = "egm/187th/attachment/kama_cg",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cg",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thcg_offic2", "187th CG Officer 2 - Helmet", {
		["helmet"] = "egm/187th/cg/helmet3",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- 187th CG RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_rmc", "187th CG RMC - Armor", {
        ["body"] = "egm/187th/cg/body4",
		["body_mirrored"] = "egm/187th/cg/body4",

        ["kama"] = "egm/187th/attachment/kama_rmc",
		["kama_arc"] = "egm/187th/attachment/kama_arc_rmc",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thcg_rmc", "187th CG RMC - Helmet", {
		["helmet"] = "egm/187th/cg/helmet4",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	--187th CG TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_teb", "187th CG TEB - Armor", {
        ["body"] = "egm/187th/cg/body5",
		["body_mirrored"] = "egm/187th/cg/body5",

        ["kama"] = "egm/187th/attachment/kama_rmc",
		["kama_arc"] = "egm/187th/attachment/kama_arc_rmc",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	-- 187th CG Special
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thcg_special", "187th CG Spezial - Armor", {
        ["body"] = "egm/187th/cg/body6",
		["body_mirrored"] = "egm/187th/cg/body6",

        ["kama"] = "egm/187th/attachment/kama_cg",
		["kama_arc"] = "egm/187th/attachment/kama_arc_cg",

        ["pauldron"] = "egm/187th/attachment/pauldron_cg",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thcg_special", "187th CG Spezial - Helmet", {
		["helmet"] = "egm/187th/cg/helmet5",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/187th/attachment/sunvisor_cg",
		["armor"] = "egm/187th/attachment/armor",
	})
	-- LoreChars
	-- 187th Law
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thlc_law", "187th Law - Armor", {
        ["body"] = "egm/187th/lc/body",
		["body_mirrored"] = "egm/187th/lc/body",

		["holsters"] = "egm/187th/attachment/holsters",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thlc_law", "187th Law - Helmet", {
		["helmet"] = "egm/187th/lc/helmet",

		["binoculars"] = "egm/187th/attachment/binoculars",

	})
	-- 187th Horns
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thlc_horns", "187th Horns - Armor", {
        ["body"] = "egm/187th/lc/body2",
		["body_mirrored"] = "egm/187th/lc/body2",

		["holsters"] = "egm/187th/attachment/holsters",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thlc_horns", "187th Horns - Helmet", {
		["helmet"] = "egm/187th/lc/helmet2",

		["binoculars"] = "egm/187th/attachment/binoculars",

	})
	-- 187th Glitch
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thlc_glitch", "187th Glitch - Armor", {
        ["body"] = "egm/187th/lc/body3",
		["body_mirrored"] = "egm/187th/lc/body3",

		["holsters"] = "egm/187th/attachment/holsters",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thlc_glitch", "187th Glitch - Helmet", {
		["helmet"] = "egm/187th/lc/helmet3",

		["binoculars"] = "egm/187th/attachment/binoculars",

	})
	-- 187th Cannon
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187thlc_cannon", "187th Cannon - Armor", {
        ["body"] = "egm/187th/lc/body4",
		["body_mirrored"] = "egm/187th/lc/body4",

		["holsters"] = "egm/187th/attachment/holsters",
    })
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187thlc_cannon", "187th Cannon - Helmet", {
		["helmet"] = "egm/187th/lc/helmet4",

		["binoculars"] = "egm/187th/attachment/binoculars",

	})
	-- Backpacks und Sidebags
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "187th_trooper", "187th Trooper - Backpack", {
		["backpack"] = "egm/187th/attachment/backpack",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "187th_sf", "187th SF - Backpack", {
		["backpack"] = "egm/187th/attachment/backpack_sf",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "187th_trooper", "187th Trooper - Sidebag", {
		["sidebag"] = "egm/187th/attachment/sidebag",
	})
end)
--lua/autorun/egm_212th_new.lua:
-- Register the 212th material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.212thTrooperNew", function()
	-- Base 212th Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_trooper", "212th - Trooper Armor", {
		["body"] = "egm/212th_new/trooper/body",
		["body_mirrored"] = "egm/212th_new/trooper/body",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_trooper", "212th - Trooper Helmet", {
		["helmet"] = "egm/212th_new/trooper/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

		["camera"] = "egm/212th_new/lore/cody/camera",
	})
	-- 212th Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "212th_trooper", "212th - Trooper Backpack", {
		["backpack"] = "egm/212th_new/shared/heavy",
	})
	-- 212th Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "212th_trooper", "212th - Jetpack", {
		["bp_jetpack"] = "egm/212th_new/shared/jetpack",
	})

	-- 212th Officer 1
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_cpt", "212th - CPT+ Armor", {
		["body"] = "egm/212th_new/trooper/body_cpt",
		["body_mirrored"] = "egm/212th_new/trooper/body_cpt",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th Officer 1 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_cpt", "212th - CPT+ Helmet", {
		["helmet"] = "egm/212th_new/trooper/helmet_cpt",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

		["camera"] = "egm/212th_new/lore/cody/camera",
	})

	-- 212th Officer 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_sgt", "212th - SGT+ Armor", {
		["body"] = "egm/212th_new/trooper/body_sgt",
		["body_mirrored"] = "egm/212th_new/trooper/body_sgt",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th Officer 2 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_sgt", "212th - SGT+ Helmet", {
		["helmet"] = "egm/212th_new/trooper/helmet_sgt",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

		["camera"] = "egm/212th_new/lore/cody/camera",
	})
	-- Base 212th Trooper RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_trooper_rmc", "212th - Trooper RMC Armor", {
		["body"] = "egm/212th_new/trooper/body_rmc",
		["body_mirrored"] = "egm/212th_new/trooper/body_rmc",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th Trooper Helmet RMC
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_trooper_rmc", "212th - Trooper RMC Helmet", {
		["helmet"] = "egm/212th_new/trooper/helmet_rmc",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",

		["camera"] = "egm/212th_new/lore/cody/camera",
	})

	-- Base 212th Trooper TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_trooper_teb", "212th - Trooper TEB Armor", {
		["body"] = "egm/212th_new/trooper/body_teb",
		["body_mirrored"] = "egm/212th_new/trooper/body_teb",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/212th_new/shared/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})

	-- 212th Trooper Helmet CTP
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "212th_trooper_ctp", "212th - Trooper CTP Helmet", {
		["helmet_pilot"] = "egm/212th_new/trooper/helmet_ctp",
	})

    -- 2nd Airborne --

	-- Base 212th 2nd Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_2nd", "212th - 2nd Armor", {
		["body"] = "egm/212th_new/2nd/body",
		["body_mirrored"] = "egm/212th_new/2nd/body_2",

		["kama"] = "egm/212th_new/2nd/heavy",
		["kama_arc"] = "egm/212th_new/2nd/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})

	-- Base 212th 2nd Trooper RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_2nd_rmc", "212th - 2nd RMC Armor", {
		["body"] = "egm/212th_new/2nd/body_rmc",
		["body_mirrored"] = "egm/212th_new/2nd/body_rmc",

		["kama"] = "egm/212th_new/2nd/heavy",
		["kama_arc"] = "egm/212th_new/2nd/kama_arc",
	
		["pauldron"] = "egm/212th_new/shared/specialist",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
		["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",
	
		["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})	

	-- Base 212th 2nd Trooper TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_2nd_teb", "212th - 2nd TEB Armor", {
		["body"] = "egm/212th_new/2nd/body_teb",
		["body_mirrored"] = "egm/212th_new/2nd/body_teb",

		["kama"] = "egm/212th_new/2nd/heavy",
		["kama_arc"] = "egm/212th_new/2nd/kama_arc",
	
		["pauldron"] = "egm/212th_new/shared/specialist",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
		["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",
	
		["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})	

	-- 212th 2nd Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "212th_2nd", "212th - 2nd Helmet", {
		["helmet_airborne"] = "egm/212th_new/2nd/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",
	})

	-- Base 212th 2nd Officer 1
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_2nd_officer", "212th - 2nd Officer 1 Armor", {
		["body"] = "egm/212th_new/2nd/body_offi",
		["body_mirrored"] = "egm/212th_new/2nd/body_2",

		["kama"] = "egm/212th_new/2nd/heavy",
		["kama_arc"] = "egm/212th_new/2nd/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th 2nd Trooper Officer 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "212th_2nd_officer", "212th - 2nd Officer 1 Helmet", {
		["helmet_airborne"] = "egm/212th_new/2nd/helmet_offi",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["camera"] = "egm/212th_new/lore/cody/camera",
	})
	-- 212th 2nd Trooper Officer 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "212th_2nd_officer_2", "212th - 2nd Officer 2 Helmet", {
		["helmet_airborne"] = "egm/212th_new/2nd/helmet_offi_2",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["camera"] = "egm/212th_new/lore/cody/camera",
	})

    -- Ghost Company --

	-- Base 212th GHC Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_ghc", "212th - ARF Camo Armor", {
		["body"] = "egm/212th_new/ghc/body_camo",
		["body_mirrored"] = "egm/212th_new/ghc/body_camo",

		["kama"] = "egm/212th_new/ghc/heavy_camo",
		["kama_arc"] = "egm/212th_new/ghc/kama_arc",

		["pauldron"] = "egm/212th_new/ghc/specialist_camo",
		["pauldron_simple"] = "egm/212th_new/ghc/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/heavy",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/ghc/heavy_camo",
		["strap_datapad"] = "egm/212th_new/ghc/heavy_camo",
		["strap_grenades"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double_datapad"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double_grenades"] = "egm/212th_new/ghc/heavy_camo",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th GHC Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "212th_ghc", "212th - ARF Camo Helmet", {
		["helmet_arf"] = "egm/212th_new/ghc/helmet_camo",
        ["armor"] = "egm/212th_new/ghc/helmet_parts_camo",
		["antenna_arf"] = "egm/212th_new/ghc/helmet_parts_camo",
	})

	-- 212th ARF White Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "212th_arf_white", "212th - ARF White Helmet", {
		["helmet_arf"] = "egm/212th_new/ghc/helmet_white",
        ["armor"] = "egm/212th_new/ghc/helmet_parts_white",
	})

	-- Base 212th GHC Officer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_ghc_officer", "212th - ARF Camo Officer Armor", {
		["body"] = "egm/212th_new/ghc/body_camo_offi",
		["body_mirrored"] = "egm/212th_new/ghc/body_camo_offi",

		["kama"] = "egm/212th_new/ghc/heavy_camo",
		["kama_arc"] = "egm/212th_new/ghc/kama_arc",

		["pauldron"] = "egm/212th_new/ghc/specialist_camo",
		["pauldron_simple"] = "egm/212th_new/ghc/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/ghc/shared/heavy",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/ghc/heavy_camo",
		["strap_datapad"] = "egm/212th_new/ghc/heavy_camo",
		["strap_grenades"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double_datapad"] = "egm/212th_new/ghc/heavy_camo",
		["straps_double_grenades"] = "egm/212th_new/ghc/heavy_camo",
		["holsters"] = "egm/212th_new/shared/gear",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th GHC Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "212th_ghc_officer", "212th - ARF Camo Officer Helmet", {
		["helmet_arf"] = "egm/212th_new/ghc/helmet_camo_offi",
        ["armor"] = "egm/212th_new/ghc/helmet_parts_camo",
		["antenna_arf"] = "egm/212th_new/ghc/helmet_parts_camo",
	})
	-- 212th GHC Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "212th_ghc", "212th - ARF Camo Backpack", {
		["backpack"] = "egm/212th_new/ghc/heavy_camo",
	})
	-- 212th GHC Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "212th_ghc", "212th - ARF Camo Jetpack", {
		["bp_jetpack"] = "egm/212th_new/ghc/bp_jetpack",
	})

    -- Lore-Chars --

	-- 212th Boil
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_boil", "212th - Boil Armor", {
		["body"] = "egm/212th_new/lore/boil/body",
		["body_mirrored"] = "egm/212th_new/lore/boil/body",

		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
	})
	-- 212th Boil Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_boil", "212th - Boil Helmet", {
		["helmet"] = "egm/212th_new/lore/boil/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
	})

	-- 212th Waxer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_waxer", "212th - Waxer Armor", {
		["body"] = "egm/212th_new/lore/waxer/body",
		["body_mirrored"] = "egm/212th_new/lore/waxer/body",

		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
	})
	-- 212th Waxer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_waxer", "212th - Waxer Helmet", {
		["helmet"] = "egm/212th_new/lore/waxer/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
	})

	-- 212th Crys
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_crys", "212th - Crys Armor", {
		["body"] = "egm/212th_new/lore/crys/body",
		["body_mirrored"] = "egm/212th_new/lore/crys/body",

		["pauldron"] = "egm/212th_new/lore/crys/specialist",
		["ammo_arm"] = "egm/212th_new/lore/crys/specialist",
        ["ammo_shoulder"] = "egm/212th_new/lore/crys/heavy",
        ["strap_datapad"] = "egm/212th_new/lore/crys/heavy",
	})
	-- 212th Crys Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_crys", "212th - Crys Helmet", {
		["helmet"] = "egm/212th_new/lore/crys/helmet",
		["binoculars"] = "egm/212th_new/lore/crys/specialist",
	})
	-- 212th Crys Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "212th_crys", "212th - Crys Backpack", {
		["backpack"] = "egm/212th_new/lore/crys/heavy",
	})
	-- 212th Peel
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_peel", "212th - Peel Armor", {
		["body"] = "egm/212th_new/lore/peel/body",
		["body_mirrored"] = "egm/212th_new/lore/peel/body",

		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
	})
	-- 212th Peel Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_peel", "212th - Peel Helmet", {
		["helmet"] = "egm/212th_new/lore/peel/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
	})

	-- 212th Wooley
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_wooley", "212th - Wooley Armor", {
		["body"] = "egm/212th_new/lore/wooley/body",
		["body_mirrored"] = "egm/212th_new/lore/wooley/body",

		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
	})
	-- 212th Wooley Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_wooley", "212th - Wooley Helmet", {
		["helmet"] = "egm/212th_new/lore/wooley/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
	})

	-- 212th Trapper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_trapper", "212th - Trapper Armor", {
		["body"] = "egm/212th_new/lore/trapper/body",
		["body_mirrored"] = "egm/212th_new/lore/trapper/body",

        ["ammo_shoulder"] = "egm/212th_new/ghc/heavy_camo",
	})
	-- 212th Trapper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_trapper", "212th - Trapper Helmet", {
		["helmet"] = "egm/212th_new/lore/trapper/helmet",
	})

	-- 212th Barlex
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_barlex", "212th - Barlex Armor", {
		["body"] = "egm/212th_new/lore/barlex/body",
		["body_mirrored"] = "egm/212th_new/lore/barlex/body",

		["kama"] = "egm/212th_new/shared/heavy",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",

        ["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- 212th Barlex Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "212th_barlex", "212th - Barlex Helmet", {
		["helmet_airborne"] = "egm/212th_new/lore/barlex/helmet",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["camera"] = "egm/212th_new/lore/cody/camera",
	})

	-- 212th Cody
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_cody", "212th - Cody Armor", {
		["body"] = "egm/212th_new/lore/cody/body_2",
		["body_mirrored"] = "egm/212th_new/lore/cody/body",

		["armor_shoulder"] = "egm/212th_new/lore/cody/shoulder_plate",
		["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
	})
	-- 212th Cody Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_cody", "212th - Cody Helmet", {
		["helmet"] = "egm/212th_new/lore/cody/helmet",
		["sunvisor"] = "egm/212th_new/lore/cody/heavy",
		["armor"] = "egm/212th_new/lore/cody/heavy",
		["antenna_ear_big"] = "egm/212th_new/lore/cody/attachment",
		["camera"] = "egm/212th_new/lore/cody/attachment",
		["antenna_big"] = "egm/212th_new/lore/cody/antenna_big",
	})

	-- 212th Cody Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "212th_cody", "212th - Cody Jumppack", {
		["bp_jumppack"] = "egm/212th_new/lore/cody/jumppack",
	})
end)
--lua/autorun/egm_501st_4er.lua:
-- Register the 501st material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.501st.4.0", function()
	
	-- 501st Base Trooper --
	
	-- 501st Base Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Base", "501st - Base Body", {
		["body"] = "egm/501st/bodys/base/body_base",
		["body_mirrored"] = "egm/501st/bodys/base/body_base",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Base Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Base", "501st - Base Helmet", {
		["helmet"] = "egm/501st/helmet_ph2/base/helmet_base",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
	-- 501st Base ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Base", "501st - Base ARF Helmet", {
		["helmet_arf"] = "egm/501st/helmet_arf/base/helmet_arf_base",
		["armor"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})
	-- 501st Base Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "501st_Base", "501st - Base Backpack", {
		["backpack"] = "egm/501st/attachments/backpack",
	})
	-- 501st Base Comms Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "501st_Base", "501st - Base Comms Backpack", {
		["bp_comms"] = "egm/501st/attachments/bp_comms",
	})
	-- 501st Base Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "501st_Base", "501st - Base Jetpack", {
		["bp_jetpack"] = "egm/501st/attachments/bp_jetpack",
	})
	-- 501st Base Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "501st_Base", "501st - Base Jumppack", {
		["bp_jumppack"] = "egm/501st/attachments/bp_jumppack",
	})





	-- 501st Heavy Trooper --

	-- 501st Heavy Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Heavy", "501st - Heavy Body", {
		["body"] = "egm/501st/bodys/heavy/body_heavy",
		["body_mirrored"] = "egm/501st/bodys/heavy/body_heavy",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})





	-- 501st Specialist Trooper --

	-- 501st Specialist Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Specialist", "501st - Specialist Body", {
		["body"] = "egm/501st/bodys/specialist/body_specialist",
		["body_mirrored"] = "egm/501st/bodys/specialist/body_specialist",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})





	-- 501st Officer Trooper --

	-- 501st Officer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Officer", "501st - Officer Body", {
		["body"] = "egm/501st/bodys/officer/body_officer",
		["body_mirrored"] = "egm/501st/bodys/officer/body_officer",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})





	-- 501st Medic Trooper --

	-- 501st Medic Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Medic", "501st - Medic Body", {
		["body"] = "egm/501st/bodys/medic/body_medic",
		["body_mirrored"] = "egm/501st/bodys/medic/body_medic",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_white",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Medic Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "501st_Medic", "501st - Medic Backpack", {
		["backpack"] = "egm/501st/attachments/backpack_rmc",
	})
	-- 501st Medic Sidebag
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "501st_Medic", "501st - Medic Sidebag", {
		["sidebag"] = "egm/501st/attachments/sidebag_rmc",
		["sidebag_grenades"] = "egm/501st/attachments/sidebag_rmc",
		["sidebag_grenades"] = "egm/501st/attachments/sidebag_rmc",
	})






	-- 501st TEB Trooper --

	-- 501st TEB Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_TEB", "501st - TEB Body", {
		["body"] = "egm/501st/bodys/teb/body_teb",
		["body_mirrored"] = "egm/501st/bodys/teb/body_teb",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st TEB Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "501st_TEB", "501st - TEB Backpack", {
		["backpack"] = "egm/501st/attachments/backpack_teb",
	})





	-- 501st Elite Trooper --

	-- 501st Elite Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Elite", "501st - Elite Body", {
		["body"] = "egm/501st/bodys/elite/body_elite",
		["body_mirrored"] = "egm/501st/bodys/elite/body_elite",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Elite Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Elite", "501st - Elite Helmet", {
		["helmet"] = "egm/501st/helmet_ph2/elite/helmet_elite",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
	-- 501st Elite ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Elite", "501st - Elite ARF Helmet", {
		["helmet_arf"] = "egm/501st/helmet_arf/elite/helmet_arf_elite",
		["armor"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})





	-- 501st Veteran Trooper --

	-- 501st Veteran Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Veteran", "501st - Veteran Body", {
		["body"] = "egm/501st/bodys/veteran/body_veteran",
		["body_mirrored"] = "egm/501st/bodys/veteran/body_veteran",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Veteran Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Veteran", "501st - Veteran Helmet", {
		["helmet"] = "egm/501st/helmet_ph2/veteran/helmet_veteran",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
	-- 501st Veteran ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Veteran", "501st - Veteran ARF Helmet", {
		["helmet_arf"] = "egm/501st/helmet_arf/veteran/helmet_arf_veteran",
		["armor"] = "egm/501st/attachments/armor_side",
        ["antenna_arf"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})





	-- 501st Ahsoka Trooper --

	-- 501st Ahsoka Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Ahsoka", "501st - Ahsoka Body", {
		["body"] = "egm/501st/bodys/ahsoka/body_ahsoka",
		["body_mirrored"] = "egm/501st/bodys/ahsoka/body_ahsoka",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Ahsoka Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Ahsoka", "501st - Ahsoka Helmet", {
		["helmet"] = "egm/501st/helmet_ph2/ahsoka/helmet_ahsoka",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
	-- 501st Ahsoka ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Ahsoka", "501st - Ahsoka ARF Helmet", {
		["helmet_arf"] = "egm/501st/helmet_arf/ahsoka/helmet_arf_ahsoka",
		["armor"] = "egm/501st/attachments/armor_side",
        ["antenna_arf"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})





	-- 501st Commander Trooper --

	-- 501st Commander Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Commander", "501st - Commander Body", {
		["body"] = "egm/501st/bodys/commander/body_commander",
		["body_mirrored"] = "egm/501st/bodys/commander/body_commander",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Commander Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Commander", "501st - Commander Helmet", {
		["helmet"] = "egm/501st/helmet_ph2/commander/helmet_commander",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
	-- 501st Commander ARF Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Commander", "501st - Commander ARF Helmet", {
		["helmet_arf"] = "egm/501st/helmet_arf/commander/helmet_arf_commander",
		["armor"] = "egm/501st/attachments/armor_side",
        ["antenna_arf"] = "egm/501st/attachments/armor_side",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})





	-- 501st Pilot Trooper --

	-- 501st Pilot Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "501st_Pilot", "501st - Pilot Helmet", {
		["helmet_pilot"] = "egm/501st/helmet_pilot/helmet_pilot",
		["helmet_pilot_breath"] = "egm/501st/helmet_pilot/helmet_pilot_breath",
	})










	---------------------------------------- Lore Chars ----------------------------------------

	-- 501st Appo --

	-- 501st Appo Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Appo", "501st - Appo Body", {
		["body"] = "egm/501st/bodys/base/body_base",
		["body_mirrored"] = "egm/501st/bodys/base/body_base",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Appo Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Appo", "501st - Appo Helmet", {
		["helmet"] = "egm/501st/lore/appo/helmet_appo",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
	})





	-- 501st Boomer --

	-- 501st Boomer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Boomer", "501st - Boomer Body", {
		["body"] = "egm/501st/lore/boomer/body_boomer",
		["body_mirrored"] = "egm/501st/lore/boomer/body_boomer",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Boomer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "501st_Boomer", "501st - Boomer Helmet", {
		["helmet_arf"] = "egm/501st/lore/boomer/helmet_boomer",
	})





	-- 501st Coric --

	-- 501st Coric Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Coric", "501st - Coric Body", {
		["body"] = "egm/501st/lore/coric/body_coric",
		["body_mirrored"] = "egm/501st/lore/coric/body_coric",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Coric Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Coric", "501st - Coric Helmet", {
		["helmet"] = "egm/501st/lore/coric/helmet_coric",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Dogma --

	-- 501st Dogma Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Dogma", "501st - Dogma Body", {
		["body"] = "egm/501st/lore/dogma/body_dogma",
		["body_mirrored"] = "egm/501st/lore/dogma/body_dogma",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Dogma Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Dogma", "501st - Dogma Helmet", {
		["helmet"] = "egm/501st/lore/dogma/helmet_dogma",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Hardcase --

	-- 501st Hardcase Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Hardcase", "501st - Hardcase Body", {
		["body"] = "egm/501st/lore/hardcase/body_hardcase",
		["body_mirrored"] = "egm/501st/lore/hardcase/body_hardcase",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Hardcase Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Hardcase", "501st - Hardcase Helmet", {
		["helmet"] = "egm/501st/lore/hardcase/helmet_hardcase",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Heater --

	-- 501st Heater Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Heater", "501st - Heater Body", {
		["body"] = "egm/501st/lore/heater/body_heater",
		["body_mirrored"] = "egm/501st/lore/heater/body_heater",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Heater Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "501st_Heater", "501st - Heater Helmet", {
		["helmet_p1"] = "egm/501st/lore/heater/helmet_heater",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Jesse --

	-- 501st Jesse Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Jesse", "501st - Jesse Body", {
		["body"] = "egm/501st/lore/jesse/body_jesse",
		["body_mirrored"] = "egm/501st/lore/jesse/body_jesse",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Jesse Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Jesse", "501st - Jesse Helmet", {
		["helmet"] = "egm/501st/lore/jesse/helmet_jesse",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Kano --

	-- 501st Kano Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Kano", "501st - Kano Body", {
		["body"] = "egm/501st/lore/kano/body_kano",
		["body_mirrored"] = "egm/501st/lore/kano/body_kano",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Kano Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "501st_Kano", "501st - Kano Helmet", {
		["helmet_p1"] = "egm/501st/lore/kano/helmet_kano",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Kix --

	-- 501st Kix Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Kix", "501st - Kix Body", {
		["body"] = "egm/501st/lore/kix/body2_kix",
		["body_mirrored"] = "egm/501st/lore/kix/body_kix",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Kix Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Kix", "501st - Kix Helmet", {
		["helmet"] = "egm/501st/lore/kix/helmet_kix",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Tup --

	-- 501st Tup Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Tup", "501st - Tup Body", {
		["body"] = "egm/501st/lore/tup/body_tup",
		["body_mirrored"] = "egm/501st/lore/tup/body_tup",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Tup Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Tup", "501st - Tup Helmet", {
		["helmet"] = "egm/501st/lore/tup/helmet_tup",
		["binoculars"] = "egm/501st/attachments/binoculars",
	})





	-- 501st Echo Trooper --
	
	-- 501st Echo Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Echo", "501st - Echo Body", {
		["body"] = "egm/501st/lore/echo/body_echo",
		["body_mirrored"] = "egm/501st/lore/echo/body_echo",

		["kama_arc"] = "egm/501st/lore/echo/kama_echo",

		["pauldron_big"] = "egm/501st/lore/echo/gear_echo",
		
		["arc_gear_body"] = "egm/501st/lore/echo/gear_echo",
		["arc_gear_legs"] = "egm/501st/lore/echo/gear_echo",
		["arc_gear_arms"] = "egm/501st/lore/echo/gear_echo",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Echo Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Echo", "501st - Echo Helmet", {
		["helmet"] = "egm/501st/lore/echo/helmet_echo",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})





	-- 501st Fives Trooper --
	
	-- 501st Fives Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Fives", "501st - Fives Body", {
		["body"] = "egm/501st/lore/fives/body_fives",
		["body_mirrored"] = "egm/501st/lore/fives/body_fives",

		["kama_arc"] = "egm/501st/lore/fives/kama_fives",

		["pauldron_big"] = "egm/501st/lore/fives/gear_fives",
		
		["arc_gear_body"] = "egm/501st/lore/fives/gear_fives",
		["arc_gear_legs"] = "egm/501st/lore/fives/gear_fives",
		["arc_gear_arms"] = "egm/501st/lore/fives/gear_fives",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Fives Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_Fives", "501st - Fives Helmet", {
		["helmet"] = "egm/501st/lore/fives/helmet_fives",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/fives/arc_crest",
	})





	-- 501st Rex Trooper --
	
	-- 501st Rex Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Rex", "501st - Rex Body", {
		["body"] = "egm/501st/lore/rex/body_rex",
		["body_mirrored"] = "egm/501st/lore/rex/body_rex",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",
		
		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",
		["pauldron_arc"] = "egm/501st/attachments/pauldron_arc",
		["pauldron_big"] = "egm/501st/attachments/pauldron_big",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",
	})
	-- 501st Rex Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_lore_rex/helmet_lore_rex.mdl", "501st_Rex", "501st - Rex Helmet", {
		["helmet_lore_rex"] = "egm/501st/lore/rex/helmet_rex",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
	})
end)
--lua/autorun/egm_aarc.lua:
-- Register the Alpha-Advanced Recon Commando material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.Alphaarc", function()
	-- A-ARC sgt
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_sergeant", "A-ARC - SGT Armor", {
		["body"] = "egm/aarc/trooper/sgt/body",
		["body_mirrored"] = "egm/aarc/trooper/sgt/body",

		["kama"] = "egm/aarc/trooper/sgt/heavy",

		["pauldron"] = "egm/aarc/trooper/sgt/specialist",
		["pauldron_arc"] = "egm/aarc/trooper/sgt/pauldron_aarc", 
		["ammo_arm"] = "egm/aarc/trooper/sgt/specialist",
				
		["straps_double"] = "egm/aarc/trooper/sgt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/sgt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/sgt/heavy",
		["strap"] = "egm/aarc/trooper/sgt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/sgt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/sgt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/sgt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	-- A-ARC lt
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_lieutenant", "A-ARC - LT Armor", {
		["body"] = "egm/aarc/trooper/lt/body",
		["body_mirrored"] = "egm/aarc/trooper/lt/body",

		["kama"] = "egm/aarc/trooper/lt/heavy",

		["pauldron"] = "egm/aarc/trooper/lt/specialist",
		["pauldron_arc"] = "egm/aarc/trooper/lt/pauldron_aarc",
		["ammo_arm"] = "egm/aarc/trooper/lt/specialist",
				
		["straps_double"] = "egm/aarc/trooper/lt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/lt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/lt/heavy",
		["strap"] = "egm/aarc/trooper/lt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/lt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/lt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/lt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	-- A-ARC cpt
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_captain", "A-ARC - CPT Armor", {
		["body"] = "egm/aarc/trooper/cpt/body",
		["body_mirrored"] = "egm/aarc/trooper/cpt/body",

		["kama"] = "egm/aarc/trooper/cpt/heavy",

		["pauldron"] = "egm/aarc/trooper/cpt/specialist",
		["pauldron_arc"] = "egm/aarc/trooper/cpt/pauldron_aarc",
		["ammo_arm"] = "egm/aarc/trooper/cpt/specialist",
		
		["straps_double"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/cpt/heavy",
		["strap"] = "egm/aarc/trooper/cpt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/cpt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/cpt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	-- A-ARC Helmet sgt Phase 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_sergeant", "A-ARC - SGT Helmet (Phase 1)", {
		["helmet_p1"] = "egm/aarc/trooper/sgt/helmet/helmet_p1",

		["binoculars"] = "egm/aarc/trooper/sgt/specialist",
		["rangefinder"] = "egm/aarc/trooper/sgt/rangefinder",
	})

	-- A-ARC Helmet sgt Phase 1 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_sergeant_jaig", "A-ARC - SGT Helmet (Phase 1 Jaig)", {
		["helmet_p1"] = "egm/aarc/trooper/sgt/helmet/helmet_p1_jaig",

		["binoculars"] = "egm/aarc/trooper/sgt/specialist",
		["rangefinder"] = "egm/aarc/trooper/sgt/rangefinder",
	})
	-- A-ARC Helmet lt Phase 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_lieutenant", "A-ARC - LT Helmet (Phase 1)", {
		["helmet_p1"] = "egm/aarc/trooper/lt/helmet/helmet_p1",

		["binoculars"] = "egm/aarc/trooper/lt/specialist",
		["rangefinder"] = "egm/aarc/trooper/lt/rangefinder",
	})
	-- A-ARC Helmet lt Phase 1 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_lieutenant_jaig", "A-ARC - LT Helmet (Phase 1 Jaig)", {
		["helmet_p1"] = "egm/aarc/trooper/lt/helmet/helmet_p1_jaig",

		["binoculars"] = "egm/aarc/trooper/lt/specialist",
		["rangefinder"] = "egm/aarc/trooper/lt/rangefinder",
	})
	-- A-ARC Helmet cpt Phase 1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_captain", "A-ARC - CPT Helmet (Phase 1)", {
		["helmet_p1"] = "egm/aarc/trooper/cpt/helmet/helmet_p1",

		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})
	-- A-ARC Helmet cpt Phase 1 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_captain_jaig", "A-ARC - CPT Helmet (Phase 1 Jaig)", {
		["helmet_p1"] = "egm/aarc/trooper/cpt/helmet/helmet_p1_jaig",

		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})

	-- A-ARC Helmet sgt Phase 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_sergeant", "A-ARC - SGT Helmet (Phase 2)", {
		["helmet"] = "egm/aarc/trooper/sgt/helmet/helmet_p2",

		["binoculars"] = "egm/aarc/trooper/sgt/specialist",
		["rangefinder"] = "egm/aarc/trooper/sgt/rangefinder",
	})
	-- A-ARC Helmet sgt Phase 2 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_sergeant_jaig", "A-ARC - SGT Helmet (Phase 2 Jaig)", {
		["helmet"] = "egm/aarc/trooper/sgt/helmet/helmet_p2_jaig",
		
		["binoculars"] = "egm/aarc/trooper/sgt/specialist",
		["rangefinder"] = "egm/aarc/trooper/sgt/rangefinder",
	})

	-- A-ARC Helmet lt Phase 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_lieutenant", "A-ARC - LT Helmet (Phase 2)", {
		["helmet"] = "egm/aarc/trooper/lt/helmet/helmet_p2",

		["binoculars"] = "egm/aarc/trooper/lt/specialist",
		["rangefinder"] = "egm/aarc/trooper/lt/rangefinder",
	})
	-- A-ARC Helmet lt Phase 2 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_lieutenant_jaig", "A-ARC - LT Helmet (Phase 2 Jaig)", {
		["helmet"] = "egm/aarc/trooper/lt/helmet/helmet_p2_jaig",

		["binoculars"] = "egm/aarc/trooper/lt/specialist",
		["rangefinder"] = "egm/aarc/trooper/lt/rangefinder",
	})

	-- A-ARC Helmet cpt Phase 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_captain", "A-ARC - CPT Helmet (Phase 2)", {
		["helmet"] = "egm/aarc/trooper/cpt/helmet/helmet_p2",
		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})
	-- A-ARC Helmet cpt Phase 2 Jaig
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_captain_jaig", "A-ARC - CPT Helmet (Phase 2 Jaig)", {
		["helmet"] = "egm/aarc/trooper/cpt/helmet/helmet_p2_jaig",
		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})
	
	-- A-ARC Pilot Helmet sgt 
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "aarc_sergeant", "A-ARC - SGT Pilot Helmet", {
		["helmet_pilot"] = "egm/aarc/trooper/sgt/helmet/helmet_pilot",
	})
	-- A-ARC Pilot Helmet lt 
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "aarc_lieutenant", "A-ARC - LT Pilot Helmet", {
		["helmet_pilot"] = "egm/aarc/trooper/lt/helmet/helmet_pilot",
	})
	-- A-ARC Pilot Helmet cpt 
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "aarc_captain", "A-ARC - CPT Pilot Helmet", {
		["helmet_pilot"] = "egm/aarc/trooper/cpt/helmet/helmet_pilot",
	})
	
	-- A-ARC Backpack sgt
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_sergeant", "A-ARC - SGT Backpack", {
		["backpack"] = "egm/aarc/trooper/sgt/heavy",
	})
	-- A-ARC Backpack lt
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_lieutenant", "A-ARC - LT Backpack", {
		["backpack"] = "egm/aarc/trooper/lt/heavy",
	})
	-- A-ARC Backpack cpt
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_captain", "A-ARC - CPT Backpack", {
		["backpack"] = "egm/aarc/trooper/cpt/heavy",
	})


	-- A-ARC Jetpack sgt
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_sergeant", "A-ARC - SGT Jetpack", {
		["bp_jetpack"] = "egm/aarc/trooper/sgt/jetpack",
	})
	-- A-ARC Jetpack lt
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_lieutenant", "A-ARC - LT Jetpack", {
		["bp_jetpack"] = "egm/aarc/trooper/lt/jetpack",
	})
	-- A-ARC Jetpack cpt
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_captain", "A-ARC - CPT Jetpack", {
		["bp_jetpack"] = "egm/aarc/trooper/cpt/jetpack",
	})
	-- A-ARC Sideback sgt
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "aarc_sergeant", "A-ARC - SGT Sideback", {
		["sidebag"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
	})
	-- A-ARC Sideback lt
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "aarc_lieutenant", "A-ARC - LT Sideback", {
		["sidebag"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
	})
	-- A-ARC Sideback cpt
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "aarc_captain", "A-ARC - CPT Sideback", {
		["sidebag"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["sidebag_grenades"] = "egm/aarc/trooper/cpt/heavy",
	})
	
-- LORE CHARAKTERE
	-- Alpha
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_alpha", "A-ARC - Alpha Armor", {
		["body"] = "egm/aarc/lore/alpha/body",
		["body_mirrored"] = "egm/aarc/lore/alpha/body",

		["kama"] = "egm/aarc/lore/alpha/heavy",

		["pauldron"] = "egm/aarc/lore/alpha/specialist",
		["pauldron_arc"] = "egm/aarc/lore/alpha/pauldron_aarc",
		["ammo_arm"] = "egm/aarc/lore/alpha/specialist",
		
		["straps_double"] = "egm/aarc/lore/alpha/heavy",
		["straps_double_grenades"] = "egm/aarc/lore/alpha/heavy",
		["straps_double_datapad"] = "egm/aarc/lore/alpha/heavy",
		["strap"] = "egm/aarc/lore/alpha/heavy",
		["strap_grenades"] = "egm/aarc/lore/alpha/heavy",
		["strap_datapad"] = "egm/aarc/lore/alpha/heavy",
		
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "aarc_alpha", "A-ARC - Alpha Helmet P2", {
		["helmet"] = "egm/aarc/lore/alpha/helmet_p2",
		["binoculars"] = "egm/aarc/lore/alpha/specialist",
		["rangefinder"] = "egm/aarc/lore/alpha/rangefinder",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_alpha", "A-ARC - Alpha Jetpack", {
		["bp_jetpack"] = "egm/aarc/lore/alpha/jetpack",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_alpha", "A-ARC - Alpha Backpack", {
		["backpack"] = "egm/aarc/lore/alpha/heavy",
	})
		-- Alpha P1
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_alpha_p1", "A-ARC - Alpha Helmet P1", {
		["helmet_p1"] = "egm/aarc/lore/alpha_p1/helmet",
		
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
	})
	
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_alpha_p1", "A-ARC - Alpha Armor P1", {
		["body"] = "egm/aarc/lore/alpha_p1/body",
		["body_mirrored"] = "egm/aarc/lore/alpha_p1/body2",
		
		["kama"] = "egm/aarc/trooper/cpt/heavy",

		["pauldron"] = "egm/aarc/trooper/cpt/specialist",
		["pauldron_arc"] = "egm/aarc/trooper/cpt/pauldron_aarc",
		
		["ammo_arm"] = "egm/aarc/trooper/cpt/specialist",
		
		["straps_double"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/cpt/heavy",
		["strap"] = "egm/aarc/trooper/cpt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/cpt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/cpt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	-- Fordo
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_fordo", "A-ARC - Fordo Armor", {
		["body"] = "egm/aarc/lore/fordo/body",
		["body_mirrored"] = "egm/aarc/lore/fordo/body",

		["kama"] = "egm/aarc/lore/fordo/heavy",

		["pauldron"] = "egm/aarc/trooper/cpt/specialist",
		["pauldron_arc"] = "egm/aarc/trooper/cpt/pauldron_aarc",
		["pauldron_simple"] = "egm/aarc/lore/fordo/pauldron_simple",
		
		["ammo_arm"] = "egm/aarc/trooper/cpt/specialist",
		["holsters"] = "egm/aarc/trooper/cpt/gear",
		
		["straps_double"] = "egm/aarc/lore/fordo/heavy",
		["straps_double_grenades"] = "egm/aarc/lore/fordo/heavy",
		["straps_double_datapad"] = "egm/aarc/lore/fordo/heavy",
		["strap"] = "egm/aarc/lore/fordo/heavy",
		["strap_grenades"] = "egm/aarc/lore/fordo/heavy",
		["strap_datapad"] = "egm/aarc/lore/fordo/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/cpt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "aarc_fordo", "A-ARC - Fordo Helmet", {
		["helmet_barc"] = "egm/aarc/lore/fordo/helmet_barc",

		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})

	-- Spots
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_spots", "A-ARC - Spots Helmet", {
		["helmet_p1"] = "egm/aarc/lore/spots/helmet",
		["binoculars"] = "egm/aarc/trooper/sgt/specialist",
		["rangefinder"] = "egm/aarc/trooper/sgt/rangefinder",
	})
	-- maze 
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_maze", "A-ARC - Maze Armor", {
		["body"] = "egm/aarc/lore/maze/body",
		["body_mirrored"] = "egm/aarc/lore/maze/body",
		
		["kama"] = "egm/aarc/lore/maze/heavy",

		["pauldron"] = "egm/aarc/trooper/cpt/specialist",
		["pauldron_arc"] = "egm/aarc/lore/maze/pauldron_aarc",
		
		["ammo_arm"] = "egm/aarc/trooper/cpt/specialist",
		
		["straps_double"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/cpt/heavy",
		["strap"] = "egm/aarc/trooper/cpt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/cpt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/cpt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})	
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_maze", "A-ARC - Maze Helmet", {
		["helmet_p1"] = "egm/aarc/trooper/cpt/helmet/helmet_p1",
		["binoculars"] = "egm/aarc/trooper/cpt/specialist",
		["rangefinder"] = "egm/aarc/trooper/cpt/rangefinder",
	})
	-- Muzzle
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_muzzle", "A-ARC - Muzzle Armor", {
		["body"] = "egm/aarc/lore/muzzle/body",
		["body_mirrored"] = "egm/aarc/lore/muzzle/body",
		
		["kama"] = "egm/aarc/lore/muzzle/heavy",
		
		["pauldron"] = "egm/aarc/lore/muzzle/specialist",
		["pauldron_arc"] = "egm/aarc/lore/muzzle/pauldron_aarc",
		
		["ammo_arm"] = "egm/aarc/lore/muzzle/specialist",
		
		["straps_double"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["straps_double_datapad"] = "egm/aarc/trooper/cpt/heavy",
		["strap"] = "egm/aarc/trooper/cpt/heavy",
		["strap_grenades"] = "egm/aarc/trooper/cpt/heavy",
		["strap_datapad"] = "egm/aarc/trooper/cpt/heavy",
		
		["pauldron_big"] = "egm/aarc/trooper/cpt/gear",
		["holsters"] = "egm/aarc/trooper/sgt/gear",
		["pockets"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_body"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_legs"] = "egm/aarc/trooper/sgt/gear",
		["arc_gear_arms"] = "egm/aarc/trooper/sgt/gear",
		["pauldron_arc_pockets"] = "egm/aarc/trooper/sgt/gear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_muzzle", "A-ARC - Muzzle Jetpack", {
		["bp_jetpack"] = "egm/aarc/lore/muzzle/jetpack",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_muzzle", "A-ARC - Muzzle Helmet P1", {
		["helmet_p1"] = "egm/aarc/lore/muzzle/helmet",
		
		["rangefinder"] = "egm/aarc/lore/muzzle/rangefinder",
		["binoculars"] = "egm/aarc/lore/muzzle/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_muzzle", "A-ARC - Muzzle Backpack", {
		["backpack"] = "egm/aarc/lore/muzzle/heavy",
	})
	
	-- Wrench
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_wrench", "A-ARC - Wrench Armor", {
		["body"] = "egm/aarc/lore/wrench/body",
		["body_mirrored"] = "egm/aarc/lore/wrench/body",
		
		["kama"] = "egm/aarc/lore/wrench/heavy",
		
		["pauldron"] = "egm/aarc/lore/wrench/specialist",
		["pauldron_arc"] = "egm/aarc/lore/wrench/pauldron_aarc",
		
		["ammo_arm"] = "egm/aarc/lore/wrench/specialist",
		
		["straps_double"] = "egm/aarc/lore/wrench/heavy",
		["straps_double_grenades"] = "egm/aarc/lore/wrench/heavy",
		["straps_double_datapad"] = "egm/aarc/lore/wrench/heavy",
		["strap"] = "egm/aarc/lore/wrench/heavy",
		["strap_grenades"] = "egm/aarc/lore/wrench/heavy",
		["strap_datapad"] = "egm/aarc/lore/wrench/heavy",
		
		["pauldron_big"] = "egm/aarc/lore/wrench/gear",
		["holsters"] = "egm/aarc/lore/wrench/gear",
		["pockets"] = "egm/aarc/lore/wrench/gear",
		["arc_gear_body"] = "egm/aarc/lore/wrench/gear",
		["arc_gear_legs"] = "egm/aarc/lore/wrench/gear",
		["arc_gear_arms"] = "egm/aarc/lore/wrench/gear",
		["pauldron_arc_pockets"] = "egm/aarc/lore/wrench/gear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_wrench", "A-ARC - Wrench Jetpack", {
		["bp_jetpack"] = "egm/aarc/lore/wrench/jetpack",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_wrench", "A-ARC - Wrench Helmet P1", {
		["helmet_p1"] = "egm/aarc/lore/wrench/helmet",
		
		["rangefinder"] = "egm/aarc/lore/wrench/rangefinder",
		["binoculars"] = "egm/aarc/lore/wrench/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_wrench", "A-ARC - Wrench Backpack", {
		["backpack"] = "egm/aarc/lore/wrench/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "aarc_wrench", "A-ARC - Wrench Sideback", {
		["sidebag"] = "egm/aarc/lore/wrench/heavy",
		["sidebag_grenades"] = "egm/aarc/lore/wrench/heavy",
		["sidebag_grenades"] = "egm/aarc/lore/wrench/heavy",
	})
end)
--lua/autorun/egm_basemodel_troopers.lua:
-- Register the clone trooper base models.
hook.Add("BaseModel.RegisterBaseModels", "EGM.CWRP.CloneTroopers", function()
	-- Base Clone Trooper Body
	player_manager.AddValidModel("Clone Armor", "models/egm/core/clone_armor/clone_armor.mdl")
	player_manager.AddValidHands("Clone Armor", "models/egm/core/clone_armor/hands_p2.mdl")
	BaseModel:RegisterBaseModel("models/egm/core/clone_armor/clone_armor.mdl", {
		["bodysuit"] = "egm/core/clone_armor/bodysuit",
		["body"] = "egm/core/clone_armor/body",
		["body_mirrored"] = "egm/core/clone_armor/body_mirrored",

		["kama"] = "egm/core/clone_armor/kama",

		["kama_arc"] = "egm/core/clone_armor/kama_arc",
		["pauldron_arc"] = "egm/core/clone_armor/pauldron_arc",
		["pauldron_simple"] = "egm/core/clone_armor/pauldron_simple",

		["armor_chest"] = "egm/core/clone_armor/armor_chest",
		["armor_shoulder"] = "egm/core/clone_armor/armor_shoulder",

		["antenna_shoulder"] = "egm/core/clone_armor/antenna_shoulder",
		["antenna_back"] = "egm/core/clone_armor/antenna_back",

		["datapad"] = "egm/core/clone_armor/datapad",

		["rank_tab"] = "egm/core/clone_armor/rank_tab",

		-- Symbols (Default Blank)
		["shoulder_symbol_left"] = "egm/core/clone_armor/shoulder_symbol_left",
		["shoulder_symbol_right"] = "egm/core/clone_armor/shoulder_symbol_right",

		-- Using the "Heavy" Texture
		["ammo_shoulder"] = "egm/core/clone_armor/ammo_shoulder",
		["straps_double"] = "egm/core/clone_armor/straps_double",
		["straps_double_grenades"] = "egm/core/clone_armor/straps_double_grenades",
		["straps_double_datapad"] = "egm/core/clone_armor/straps_double_datapad",
		["strap"] = "egm/core/clone_armor/strap",
		["strap_grenades"] = "egm/core/clone_armor/strap_grenades",
		["strap_datapad"] = "egm/core/clone_armor/strap_datapad",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/core/clone_armor/pauldron",
		["ammo_arm"] = "egm/core/clone_armor/ammo_arm",

		-- Using the "Gear" Texture
		["pauldron_big"] = "egm/core/clone_armor/pauldron_big",
		["holsters"] = "egm/core/clone_armor/holsters",
		["pockets"] = "egm/core/clone_armor/pockets",
		["arc_gear_body"] = "egm/core/clone_armor/arc_gear_body",
		["arc_gear_legs"] = "egm/core/clone_armor/arc_gear_legs",
		["arc_gear_arms"] = "egm/core/clone_armor/arc_gear_arms",
		["pauldron_arc_pockets"] = "egm/core/clone_armor/pauldron_arc_pockets",
	})

	-- Synthmesh Clone Trooper Body
	player_manager.AddValidModel("Clone Synthmesh Armor", "models/egm/core/clone_synthmesh/clone_synthmesh.mdl")
	player_manager.AddValidHands("Clone Synthmesh Armor", "models/egm/core/clone_synthmesh/hand_synth.mdl")
	BaseModel:RegisterBaseModel("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", {
		["bodysuit"] = "egm/core/clone_synthmesh/bodysuit",
		["body"] = "egm/core/clone_synthmesh/body",
		["synthmesh"] = "egm/core/clone_synthmesh/synthmesh",

		["antenna_back"] = "egm/core/clone_synthmesh/antenna_back",
		["antenna_shoulder"] = "egm/core/clone_synthmesh/antenna_shoulder",

		["kama"] = "egm/core/clone_synthmesh/kama",

		-- Using the "Heavy" Texture
		["ammo_shoulder"] = "egm/core/clone_synthmesh/ammo_shoulder",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/core/clone_synthmesh/pauldron",
		["ammo_chest"] = "egm/core/clone_synthmesh/ammo_chest",
		["ammo_arm"] = "egm/core/clone_synthmesh/ammo_arm",

		-- Using the "Gear" Texture
		["holsters"] = "egm/core/clone_synthmesh/holsters",
		["pockets"] = "egm/core/clone_synthmesh/pockets",
	})

	-- Clone Commando Body
	player_manager.AddValidModel("Republic Commando Armor", "models/egm/core/clone_commando/clone_commando.mdl")
	player_manager.AddValidHands("Republic Commando Armor", "models/egm/core/clone_commando/hands_rc.mdl")
	BaseModel:RegisterBaseModel("models/egm/core/clone_commando/clone_commando.mdl", {
		["bodysuit"] = "egm/core/clone_commando/bodysuit",
		["body"] = "egm/core/clone_commando/body",
		["gloves"] = "egm/core/clone_commando/gloves",
		["knife"] = "egm/core/clone_commando/knife",

		["explosives"] = "egm/core/clone_commando/explosives",
		["bacta"] = "egm/core/clone_commando/bacta",
		["rank_tab"] = "egm/core/clone_commando/rank_tab",
	})

	-- Clone Uniform
	player_manager.AddValidModel("Clone Uniform", "models/egm/core/uniform/uniform.mdl")
	player_manager.AddValidHands("Clone Uniform", "models/egm/core/uniform/hands_uniform.mdl")
	BaseModel:RegisterBaseModel("models/egm/core/uniform/uniform.mdl", {
		["body"] = "egm/core/uniform/body",
		["legs"] = "egm/core/uniform/legs",
		["gloves"] = "egm/core/uniform/gloves",

		-- Using the "Belt" Texture
		["belt"] = "egm/core/uniform/belt",
		["belt_armor"] = "egm/core/uniform/belt_armor",

		["rank"] = "egm/core/uniform/rank",
	})



	-- Phase 2 Clone Trooper Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_p2/helmet_p2.mdl", "Clone Helmet", {
		["helmet"] = "egm/core/helmet_p2/helmet",
		["flashlight"] = "egm/core/helmet_p2/flashlight",
		["arc_crest"] = "egm/core/helmet_p2/arc_crest",
		["antenna_big"] = "egm/core/helmet_p2/antenna_big",
		["antenna_ear"] = "egm/core/helmet_p2/antenna_ear",

		-- Using the "Specialist" Texture
		["binoculars"] = "egm/core/helmet_p2/binoculars",
		["rangefinder"] = "egm/core/helmet_p2/rangefinder",

		-- Using the "Heavy" Texture
		["sunvisor"] = "egm/core/helmet_p2/sunvisor",
		["armor"] = "egm/core/helmet_p2/armor",

		-- Using the "Helmet Equipment" Texture
		["camera"] = "egm/core/helmet_p2/camera",
		["antenna_back"] = "egm/core/helmet_p2/antenna_back",
		["antenna_ear_big"] = "egm/core/helmet_p2/antenna_ear_big",
	})

	-- Phase 1 Clone Trooper Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_p1/helmet_p1.mdl", "Clone Helmet - Phase 1", {
		["helmet_p1"] = "egm/core/helmet_p1/helmet_p1",
		["flashlight"] = "egm/core/helmet_p1/flashlight",
		["antenna_ear"] = "egm/core/helmet_p1/antenna_ear",

		-- Using the "Specialist" Texture
		["binoculars"] = "egm/core/helmet_p1/binoculars",
		["rangefinder"] = "egm/core/helmet_p1/rangefinder",

		-- Using the "Heavy" Texture
		["sunvisor"] = "egm/core/helmet_p1/sunvisor",
	})

	-- Clone Synthmesh Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "Clone Synthmesh Helmet", {
		["helmet_synthmesh"] = "egm/core/helmet_synthmesh/helmet_synthmesh",
		["flashlight"] = "egm/core/helmet_synthmesh/flashlight",

		-- Using the "Helmet Equipment" Texture
		["antenna_back"] = "egm/core/helmet_synthmesh/antenna_back",
		["antenna_ear_big"] = "egm/core/helmet_synthmesh/antenna_ear_big",
	})

	-- Clone Commando Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_commando/helmet_commando.mdl", "Clone Commando Helmet", {
		["helmet_commando"] = "egm/core/helmet_commando/helmet_commando",
		["helmet_commando_glass"] = "egm/core/helmet_commando/helmet_commando_glass",

		["headset"] = "egm/core/helmet_commando/headset",
	})

	-- Clone ARF Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_arf/helmet_arf.mdl", "Clone ARF Helmet", {
		["helmet_arf"] = "egm/core/helmet_arf/helmet_arf",
		["flashlight"] = "egm/core/helmet_arf/flashlight",

		-- Using the "Specialist" Texture
		["rangefinder"] = "egm/core/helmet_arf/rangefinder",

		-- Using the "Helmet Equipment" Texture
		["camera"] = "egm/core/helmet_arf/camera",

		-- Using the "Armor" Texture
		["armor"] = "egm/core/helmet_arf/armor",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",

	})

	-- Clone BARC Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_barc/helmet_barc.mdl", "Clone BARC Helmet", {
		["helmet_barc"] = "egm/core/helmet_barc/helmet_barc",
		["flashlight"] = "egm/core/helmet_barc/flashlight",
		["antenna_big"] = "egm/core/helmet_barc/antenna_big",
		["antenna_ear"] = "egm/core/helmet_barc/antenna_ear",

		-- Using the "Specialist" Texture
		["binoculars"] = "egm/core/helmet_barc/binoculars",
		["rangefinder"] = "egm/core/helmet_barc/rangefinder",

		-- Using the "Heavy" Texture
		["sunvisor"] = "egm/core/helmet_barc/sunvisor",
		["armor"] = "egm/core/helmet_barc/armor",

		-- Using the "Helmet Equipment" Texture
		["camera"] = "egm/core/helmet_barc/camera",
		["antenna_back"] = "egm/core/helmet_barc/antenna_back",
		["antenna_ear_big"] = "egm/core/helmet_barc/antenna_ear_big",
	})

	-- Clone Airborne Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_airborne/helmet_airborne.mdl", "Clone Airborne Helmet", {
		["helmet_airborne"] = "egm/core/helmet_airborne/helmet_airborne",
		["flashlight"] = "egm/core/helmet_airborne/flashlight",

		-- Using the "Specialist" Texture
		["binoculars"] = "egm/core/helmet_airborne/binoculars",
		["rangefinder"] = "egm/core/helmet_airborne/rangefinder",

		-- Using the "Heavy" Texture
		["sunvisor"] = "egm/core/helmet_airborne/sunvisor",

		-- Using the "Helmet Equipment" Texture
		["camera"] = "egm/core/helmet_airborne/camera",
		["antenna_back"] = "egm/core/helmet_airborne/antenna_back",
		["antenna_ear_big"] = "egm/core/helmet_airborne/antenna_ear_big",
	})

	-- Clone Pilot Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_pilot/helmet_pilot.mdl", "Clone Pilot Helmet", {
		["helmet_pilot"] = "egm/core/helmet_pilot/helmet_pilot",
		["helmet_pilot_pipe"] = "egm/core/helmet_pilot/helmet_pilot_pipe",
		["helmet_pilot_breath"] = "egm/core/helmet_pilot/helmet_pilot_breath",
	})

	-- Clone Spec Ops Helmet
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "Clone Spec Ops Helmet", {
		["helmet_spec_ops"] = "egm/core/helmet_spec_ops/helmet_spec_ops",
		["helmet_ear"] = "egm/core/helmet_spec_ops/helmet_ear",
		["antenna_spec_ops"] = "egm/core/helmet_spec_ops/antenna_spec_ops",

		-- Using the "Helmet Equipment" Texture
		["flashlight"] = "egm/core/helmet_spec_ops/flashlight",
		["camera"] = "egm/core/helmet_spec_ops/camera",
	})

	-- Lore Helmet: Rex
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_lore_rex/helmet_lore_rex.mdl", "Clone Helmet - Rex", {
		["helmet_lore_rex"] = "egm/core/helmet_lore_rex/helmet_lore_rex",

		-- Using the "Specialist" Texture
		["rangefinder"] = "egm/core/helmet_lore_rex/rangefinder",
	})

	-- Lore Helmet: Bacara
	InventoryBoneMerge:RegisterBaseModel("Helmet", "models/egm/core/helmet_lore_bacara/helmet_lore_bacara.mdl", "Clone Helmet - Bacara", {
		["helmet_lore_bacara"] = "egm/core/helmet_lore_bacara/helmet_lore_bacara",
		["helmet_lore_bacara_top"] = "egm/core/helmet_lore_bacara/helmet_lore_bacara_top",
		["antenna"] = "egm/core/helmet_lore_bacara/antenna",
	})



	-- Clone Backpack
	InventoryBoneMerge:RegisterBaseModel("Backpack", "models/egm/core/backpack/backpack.mdl", "Clone Backpack", {
		["backpack"] = "egm/core/backpack/backpack",
		["head_b1"] = "egm/core/backpack/head_b1",
		-- TODO: Add more Droid heads
	})

	-- Clone Utility Backpack
	InventoryBoneMerge:RegisterBaseModel("Backpack", "models/egm/core/bp_utility/bp_utility.mdl", "Clone Utility Backpack", {
		["bp_utility"] = "egm/core/bp_utility/bp_utility",
	})

	-- Clone Commando Backpack
	InventoryBoneMerge:RegisterBaseModel("Backpack", "models/egm/core/bp_commando/bp_commando.mdl", "Clone Commando Backpack", {
		["bp_commando"] = "egm/core/bp_commando/bp_commando",

		["bp_commando_antenna"] = "egm/core/bp_commando/bp_commando_antenna",
		["bp_commando_light"] = "egm/core/bp_commando/bp_commando_light",

		["bp_commando_tech"] = "egm/core/bp_commando/bp_commando_tech",
	})

	-- Clone ARC Backpack
	InventoryBoneMerge:RegisterBaseModel("Backpack", "models/egm/core/bp_arc/bp_arc.mdl", "Clone ARC Backpack", {
		["bp_arc"] = "egm/core/bp_arc/bp_arc",
	})

	-- Clone Comms Unit
	InventoryBoneMerge:RegisterBaseModel("Backpack", "models/egm/core/bp_comms/bp_comms.mdl", "Clone Comms Unit", {
		["bp_comms"] = "egm/core/bp_comms/bp_comms",
	})



	-- Clone Jetpack
	InventoryBoneMerge:RegisterBaseModel("Jetpack", "models/egm/core/bp_jetpack/bp_jetpack.mdl", "Clone Jetpack", {
		["bp_jetpack"] = "egm/core/bp_jetpack/bp_jetpack",
	})

	-- Clone Jumppack
	InventoryBoneMerge:RegisterBaseModel("Jetpack", "models/egm/core/bp_jumppack/bp_jumppack.mdl", "Clone Jumppack", {
		["bp_jumppack"] = "egm/core/bp_jumppack/bp_jumppack",
	})

	-- Jet Boots
	InventoryBoneMerge:RegisterBaseModel("Jetpack", "models/egm/core/jet_boots/jet_boots.mdl", "Jet Boots", {
		["jet_boots"] = "egm/core/jet_boots/jet_boots",
	})



	-- Sidebag
	InventoryBoneMerge:RegisterBaseModel("Sidebag", "models/egm/core/sidebag/sidebag.mdl", "Sidebag", {
		["sidebag"] = "egm/core/sidebag/sidebag",
		["sidebag_grenades"] = "egm/core/sidebag/sidebag_grenades",
		["sidebag_datapad"] = "egm/core/sidebag/sidebag_datapad",

		["datapad"] = "egm/core/sidebag/datapad",
		["datapad_screen"] = "egm/core/sidebag/datapad_screen",
	})
end)

-- Register the species headless models.
hook.Add("Species.RegisterModels", "EGM.CWRP.CloneTroopers", function()
	Species:RegisterHeadlessModel("models/egm/core/clone_armor/clone_armor.mdl", "Klon")
	Species:RegisterHeadlessModel("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "Klon")
	Species:RegisterHeadlessModel("models/egm/core/clone_commando/clone_commando.mdl", "Klon")
	Species:RegisterHeadlessModel("models/egm/core/uniform/uniform.mdl", "Klon")
end)
--lua/autorun/egm_ccdominik.lua:
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.501stDominik", function()
	-- 501st Dominik Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_Dominik", "501st Dominik - Armor", {

		["body"] = "egm/501st/bodys/officer/body_officer",
		["body_mirrored"] = "egm/501st/bodys/officer/body_officer",

		["kama"] = "egm/501st/attachments/kama_white",
		["kama_arc"] = "egm/custom_char/501st/dominik/attachment/kama_arc",
		
		["pauldron"] = "egm/custom_char/501st/dominik/attachment/specialist",
		["pauldron_simple"] = "egm/custom_char/501st/dominik/attachment/pauldron_simple",

		["ammo_arm"] = "egm/custom_char/501st/dominik/attachment/specialist",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",

		["rank_tab"] = "egm/501st/attachments/rank_tab",

		["holsters"] = "egm/custom_char/501st/dominik/attachment/gear",
		["pockets"] = "egm/custom_char/501st/dominik/attachment/gear",
	})
	-- 501st Dominik Comms Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "501st_Dominik", "501st - Dominik Comms Backpack", {
		["bp_comms"] = "egm/custom_char/501st/dominik/attachment/bp_comms",
	})
end)
--lua/autorun/egm_clone_trooper.lua:
-- Register the Clone Trooper material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.Clone Trooper", function()
	-- Auszeichnung 1 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_1", "Clone Trooper - Auszeichnung Armor 1", {
		["body"] = "egm/clone_trooper/body/body_1",
		["body_mirrored"] = "egm/clone_trooper/body/body_1",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})
	-- Auszeichnung 1 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_1", "Clone Trooper - Auszeichnung Helmet 1", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_1",
	})
	-- Auszeichnung Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "clone_trooper_1", "Clone Trooper - Auszeichnung Jetpack", {
		["bp_jetpack"] = "egm/clone_trooper/attachment/jetpack",
	})

	-- Auszeichnung 2 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_2", "Clone Trooper - Auszeichnung Armor 2", {
		["body"] = "egm/clone_trooper/body/body_2",
		["body_mirrored"] = "egm/clone_trooper/body/body_2",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})
	-- Auszeichnung 2 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_2", "Clone Trooper - Auszeichnung Helmet 2", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_2",
	})

	-- Auszeichnung 3 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_3", "Clone Trooper - Auszeichnung Armor 3", {
		["body"] = "egm/clone_trooper/body/body_3",
		["body_mirrored"] = "egm/clone_trooper/body/body_3",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})
	-- Auszeichnung 3 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_3", "Clone Trooper - Auszeichnung Helmet 3", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_3",
	})

	-- Auszeichnung 4 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_4", "Clone Trooper - Auszeichnung Armor 4", {
		["body"] = "egm/clone_trooper/body/body_4",
		["body_mirrored"] = "egm/clone_trooper/body/body_4",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})
	-- Auszeichnung 4 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_4", "Clone Trooper - Auszeichnung Helmet 4", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_4",
	})

	-- Auszeichnung 5 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_5", "Clone Trooper - Auszeichnung Armor 5", {
		["body"] = "egm/clone_trooper/body/body_5",
		["body_mirrored"] = "egm/clone_trooper/body/body_5",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- Auszeichnung 5 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_5", "Clone Trooper - Auszeichnung Helmet 5", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_5",
	})

	-- Auszeichnung 6 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_6", "Clone Trooper - Auszeichnung Armor 6", {
		["body"] = "egm/clone_trooper/body/body_6",
		["body_mirrored"] = "egm/clone_trooper/body/body_6",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- Auszeichnung 6 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_6", "Clone Trooper - Auszeichnung Helmet 6", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_6",
	})

	-- Auszeichnung ST Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_st", "Clone Trooper - Auszeichnung Armor 7", {
		["body"] = "egm/clone_trooper/body/body_st",
		["body_mirrored"] = "egm/clone_trooper/body/body_st",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- Auszeichnung ST Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_st", "Clone Trooper - Auszeichnung Helmet 7", {
		["helmet"] = "egm/clone_trooper/helmet/helmet_st",
	})

	-- RMC Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_rmc", "Clone Trooper - RMC Armor", {
		["body"] = "egm/clone_trooper/body/body_rmc",
		["body_mirrored"] = "egm/clone_trooper/body/body_rmc",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- RMC Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "clone_trooper_rmc", "Clone Trooper - RMC Backpack", {
		["backpack"] = "egm/clone_trooper/attachment/heavy_medic",
	})

	-- TEB Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_teb", "Clone Trooper - TEB Armor", {
		["body"] = "egm/clone_trooper/body/body_teb",
		["body_mirrored"] = "egm/clone_trooper/body/body_teb",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- TEB Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "clone_trooper_teb", "Clone Trooper - TEB Backpack", {
		["backpack"] = "egm/clone_trooper/attachment/heavy_teb",
	})

	-- Auszeichnung RMC Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_vet", "Clone Trooper - Auszeichnung RMC Armor", {
		["body"] = "egm/clone_trooper/body/body_rmc_vet",
		["body_mirrored"] = "egm/clone_trooper/body/body_rmc_vet",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- Auszeichnung TEB Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_teb_vet", "Clone Trooper - Auszeichnung TEB Armor", {
		["body"] = "egm/clone_trooper/body/body_teb_vet",
		["body_mirrored"] = "egm/clone_trooper/body/body_teb_vet",

		["kama"] = "egm/clone_trooper/attachment/heavy",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- RANCORS --

	-- Rancor Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_1", "Clone Trooper - Rancor Trooper 1", {
		["body"] = "egm/clone_trooper/arf/body_arf_1",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_1",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "clone_arf_1", "Clone Trooper - Rancor Helmet 1", {
		["helmet_arf"] = "egm/clone_trooper/arf/helmet_arf_1",
	})

	-- Rancor Trooper 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_2", "Clone Trooper - Rancor Trooper 2", {
		["body"] = "egm/clone_trooper/arf/body_arf_2",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_2",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Helmet 2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "clone_arf_2", "Clone Trooper - Rancor Helmet 2", {
		["helmet_arf"] = "egm/clone_trooper/arf/helmet_arf_2",
	})

	-- Rancor Trooper 3
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_3", "Clone Trooper - Rancor Trooper 3", {
		["body"] = "egm/clone_trooper/arf/body_arf_3",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_3",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Trooper 4
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_4", "Clone Trooper - Rancor Trooper 4", {
		["body"] = "egm/clone_trooper/arf/body_arf_4",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_4",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Trooper 5
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_5", "Clone Trooper - Rancor Trooper 5", {
		["body"] = "egm/clone_trooper/arf/body_arf_5",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_5",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Trooper RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_rmc", "Clone Trooper - Rancor Trooper RMC", {
		["body"] = "egm/clone_trooper/arf/body_arf_rmc",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_rmc",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Trooper TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_teb", "Clone Trooper - Rancor Trooper TEB", {
		["body"] = "egm/clone_trooper/arf/body_arf_teb",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_teb",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",
	})

	-- Rancor Trooper VET
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_arf_vet", "Clone Trooper - Rancor Trooper VET", {
		["body"] = "egm/clone_trooper/arf/body_arf_vet",
		["body_mirrored"] = "egm/clone_trooper/arf/body_arf_vet",

		["kama"] = "egm/clone_trooper/attachment/heavy1",
		["kama_arc"] = "egm/clone_trooper/attachment/kama_arc1",

		["pauldron"] = "egm/clone_trooper/attachment/specialist",
	})

	-- Rancor Helmet VET
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "clone_arf_vet", "Clone Trooper - Rancor Trooper VET", {
		["helmet_arf"] = "egm/clone_trooper/arf/helmet_arf_vet",
	})

	-- LORE CHARS --

	-- CT Blitz Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_lore_blitz", "Clone Trooper - Blitz", {
		["body"] = "egm/clone_trooper/rancor/blitz/body",
		["body_mirrored"] = "egm/clone_trooper/rancor/blitz/body",
		["kama_arc"] = "egm/clone_trooper/rancor/blitz/kama",
		["pauldron_big"] = "egm/clone_trooper/rancor/blitz/gear",
		["holsters"] = "egm/clone_trooper/rancor/blitz/gear",
		["pockets"] = "egm/clone_trooper/rancor/blitz/gears",
		["arc_gear_body"] = "egm/clone_trooper/rancor/blitz/gear",
		["arc_gear_legs"] = "egm/clone_trooper/rancor/blitz/gear",
		["arc_gear_arms"] = "egm/clone_trooper/rancor/blitz/gear",
		["pauldron_arc_pockets"] = "egm/clone_trooper/rancor/blitz/gear",
	})

	-- CT Blitz Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_lore_blitz", "Clone Trooper - Blitz", {
		["helmet"] = "egm/clone_trooper/rancor/blitz/helmet",
		["rangefinder"] = "egm/clone_trooper/rancor/blitz/rangefinder",
	})

	-- CT Colt Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_lore_colt", "Clone Trooper - Colt", {
		["body"] = "egm/clone_trooper/rancor/colt/body",
		["body_mirrored"] = "egm/clone_trooper/rancor/colt/body",
		["kama_arc"] = "egm/clone_trooper/rancor/colt/kama",
		["pauldron_big"] = "egm/clone_trooper/rancor/colt/gear",
		["holsters"] = "egm/clone_trooper/rancor/colt/gear",
		["pockets"] = "egm/clone_trooper/rancor/colt/gears",
		["arc_gear_body"] = "egm/clone_trooper/rancor/colt/gear",
		["arc_gear_legs"] = "egm/clone_trooper/rancor/colt/gear",
		["arc_gear_arms"] = "egm/clone_trooper/rancor/colt/gear",
		["pauldron_arc_pockets"] = "egm/clone_trooper/rancor/colt/gear",
	})
	-- CT Colt Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_lore_colt", "Clone Trooper - Colt", {
		["helmet"] = "egm/clone_trooper/rancor/colt/helmet",
		["rangefinder"] = "egm/clone_trooper/rancor/colt/rangefinder",
		["arc_crest"] = "egm/clone_trooper/rancor/colt/arc_crest",
	})

	-- CT Hammer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_lore_hammer", "Clone Trooper - Hammer", {
		["body"] = "egm/clone_trooper/rancor/hammer/body",
		["body_mirrored"] = "egm/clone_trooper/rancor/hammer/body",
		["kama_arc"] = "egm/clone_trooper/rancor/hammer/kama",
		["pauldron_big"] = "egm/clone_trooper/rancor/hammer/gear",
		["holsters"] = "egm/clone_trooper/rancor/hammer/gear",
		["pockets"] = "egm/clone_trooper/rancor/hammer/gears",
		["arc_gear_body"] = "egm/clone_trooper/rancor/hammer/gear",
		["arc_gear_legs"] = "egm/clone_trooper/rancor/hammer/gear",
		["arc_gear_arms"] = "egm/clone_trooper/rancor/hammer/gear",
		["pauldron_arc_pockets"] = "egm/clone_trooper/rancor/hammer/gear",
	})
	-- CT Hammer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_lore_hammer", "Clone Trooper - Hammer", {
		["helmet"] = "egm/clone_trooper/rancor/hammer/helmet",
		["rangefinder"] = "egm/clone_trooper/rancor/hammer/rangefinder",
	})

	-- CT Havoc Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "clone_trooper_lore_havoc", "Clone Trooper - Havoc", {
		["body"] = "egm/clone_trooper/rancor/havoc/body",
		["body_mirrored"] = "egm/clone_trooper/rancor/havoc/body",
		["kama_arc"] = "egm/clone_trooper/rancor/havoc/kama",
		["pauldron_big"] = "egm/clone_trooper/rancor/havoc/gear",
		["holsters"] = "egm/clone_trooper/rancor/havoc/gear",
		["pockets"] = "egm/clone_trooper/rancor/havoc/gears",
		["arc_gear_body"] = "egm/clone_trooper/rancor/havoc/gear",
		["arc_gear_legs"] = "egm/clone_trooper/rancor/havoc/gear",
		["arc_gear_arms"] = "egm/clone_trooper/rancor/havoc/gear",
		["pauldron_arc_pockets"] = "egm/clone_trooper/rancor/havoc/gear",
	})
	-- CT Havoc Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "clone_trooper_lore_havoc", "Clone Trooper - Havoc", {
		["helmet"] = "egm/clone_trooper/rancor/havoc/helmet",
		["rangefinder"] = "egm/clone_trooper/rancor/havoc/rangefinder",
	})
end)
--lua/autorun/egm_ctp.lua:
-- Register the Clone Trooper Pilots material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTPTrooper", function()
	-- CTP Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_trooper", "Clone Trooper Pilots - Trooper Armor", {
		["body"] = "egm/ctp/trooper/body_trooper",
		["body_mirrored"] = "egm/ctp/trooper/body_trooper",
	})
	-- CTP Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_trooper", "Clone Trooper Pilots - Trooper Helmet", {
		["helmet_pilot"] = "egm/ctp/trooper/helmet_trooper",
	})

	-- CTP Officer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_officer", "Clone Trooper Pilots - Officer Armor", {
		["body"] = "egm/ctp/trooper/body_officer",
		["body_mirrored"] = "egm/ctp/trooper/body_officer",
	})
	-- CTP Officer
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_officer", "Clone Trooper Pilots - Officer Helmet", {
		["helmet_pilot"] = "egm/ctp/trooper/helmet_officer",
	})

	-- Red Group --

	-- CTP Red Group Allrounder
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_rg_allrounder", "Clone Trooper Pilots - Red Group Allrounder Armor", {
		["body"] = "egm/ctp/red_group/body",
		["body_mirrored"] = "egm/ctp/red_group/body",
	})
	-- CTP Red Group Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_rg_veteran", "Clone Trooper Pilots - Red Group Veteran Armor", {
		["body"] = "egm/ctp/red_group/body_vet",
		["body_mirrored"] = "egm/ctp/red_group/body_vet",
	})
	-- CTP Red Group Leader
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_rg_lead", "Clone Trooper Pilots - Red Group Lead Armor", {
		["body"] = "egm/ctp/red_group/body_lead",
		["body_mirrored"] = "egm/ctp/red_group/body_lead",
	})
    -- CTP Red Group Helmet 1
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_1", "Clone Trooper Pilots - Red Group Helmet 1", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet",
    })
    -- CTP Red Group Helmet 2
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_2", "Clone Trooper Pilots - Red Group Helmet 2", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_6",
    })
    -- CTP Red Group Helmet 3
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_3", "Clone Trooper Pilots - Red Group Standard Helmet", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_7",
    })
    -- CTP Red Group Helmet 4
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_4", "Clone Trooper Pilots - Red Group Helmet 4", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_3",
    })
    -- CTP Red Group Helmet 5
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_5", "Clone Trooper Pilots - Red Group Helmet 5", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_4",
    })
    -- CTP Red Group Helmet 6
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_6", "Clone Trooper Pilots - Red Group Helmet 6", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_5",
    })
    -- CTP Red Group Helmet 7
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_7", "Clone Trooper Pilots - Red Group Helmet 7", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_8",
    })
    -- CTP Red Group Helmet 8
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_rg_helmet_8", "Clone Trooper Pilots - Red Group Helmet 8", {
        ["helmet_pilot"] = "egm/ctp/red_group/helmet_9",
    })


	-- Blue Group --

	-- CTP Blue Group Allrounder
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_bg_allrounder", "Clone Trooper Pilots - Blue Group Allrounder Armor", {
		["body"] = "egm/ctp/blue_group/body",
		["body_mirrored"] = "egm/ctp/blue_group/body",
	})
	-- CTP Blue Group Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_bg_veteran", "Clone Trooper Pilots - Blue Group Veteran Armor", {
		["body"] = "egm/ctp/blue_group/body_vet",
		["body_mirrored"] = "egm/ctp/blue_group/body_vet",
	})
	-- CTP Blue Group Leader
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_bg_lead", "Clone Trooper Pilots - Blue Group Lead Armor", {
		["body"] = "egm/ctp/blue_group/body_lead",
		["body_mirrored"] = "egm/ctp/blue_group/body_lead",
	})
    -- CTP Blue Group Helmet 1
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_1", "Clone Trooper Pilots - Blue Group Helmet 1", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet",
    })
    -- CTP Blue Group Helmet 2
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_2", "Clone Trooper Pilots - Blue Group Helmet 2", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_6",
    })
    -- CTP Blue Group Helmet 3
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_3", "Clone Trooper Pilots - Blue Group Standard Helmet", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_7",
    })
    -- CTP Blue Group Helmet 4
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_4", "Clone Trooper Pilots - Blue Group Helmet 4", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_3",
    })
    -- CTP Blue Group Helmet 5
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_5", "Clone Trooper Pilots - Blue Group Helmet 5", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_4",
    })
    -- CTP Blue Group Helmet 6
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_6", "Clone Trooper Pilots - Blue Group Helmet 6", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_5",
    })
    -- CTP Blue Group Helmet 7
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_7", "Clone Trooper Pilots - Blue Group Helmet 7", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_8",
    })
    -- CTP Blue Group Helmet 8
    BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_bg_helmet_8", "Clone Trooper Pilots - Blue Group Helmet 8", {
        ["helmet_pilot"] = "egm/ctp/blue_group/helmet_9",
    })

	-- Lore Chars --

	-- CTP Broadside Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_broadside", "Clone Trooper Pilots - Broadside Armor", {
		["body"] = "egm/ctp/lore/broadside/body",
		["body_mirrored"] = "egm/ctp/lore/broadside/body",
	})
	-- CTP Broadside Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_broadside", "Clone Trooper Pilots - Broadside Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/broadside/helmet",
	})

	-- CTP Contrail Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_contrail", "Clone Trooper Pilots - Contrail Armor", {
		["body"] = "egm/ctp/lore/contrail/body",
		["body_mirrored"] = "egm/ctp/lore/contrail/body",
	})
	-- CTP Contrail Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_contrail", "Clone Trooper Pilots - Contrail Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/contrail/helmet",
	})

	-- CTP Hawk Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_hawk", "Clone Trooper Pilots - Hawk Armor", {
		["body"] = "egm/ctp/lore/hawk/body",
		["body_mirrored"] = "egm/ctp/lore/hawk/body",
	})
	-- CTP Hawk Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_hawk", "Clone Trooper Pilots - Hawk Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/hawk/helmet",
	})

	-- CTP Jaigalaar Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_jaigalaar", "Clone Trooper Pilots - Jaigalaar Armor", {
		["body"] = "egm/ctp/lore/jaigalaar/body",
		["body_mirrored"] = "egm/ctp/lore/jaigalaar/body",
	})
	-- CTP Jaigalaar Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_jaigalaar", "Clone Trooper Pilots - Jaigalaar Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/jaigalaar/helmet",
	})

	-- CTP Sicko Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_sicko", "Clone Trooper Pilots - Sicko Armor", {
		["body"] = "egm/ctp/lore/sicko/body",
		["body_mirrored"] = "egm/ctp/lore/sicko/body_2",
		["kama_arc"] = "egm/ctp/lore/sicko/kama",
	})
	-- CTP Sicko Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_sicko", "Clone Trooper Pilots - Sicko Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/sicko/helmet",
	})

	-- CTP Warthog Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_warthog_helmet", "Clone Trooper Pilots - Warthog Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/warthog/helmet",
	})

	-- CTP Gaffa Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "ctp_gaffa_helmet", "Clone Trooper Pilots - Gaffa Helmet", {
		["helmet"] = "egm/ctp/lore/gaffa/helmet",
		["binoculars"] = "egm/ctp/lore/38th/specialist",
		["sunvisor"] = "egm/ctp/lore/38th/heavy",
		["armor"] = "egm/ctp/lore/38th/heavy",
	})


	-- Schattenstaffel --

	-- CTP SAS Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_sas_body_1", "Clone Trooper Pilots - SAS Armor 1", {
		["body"] = "egm/ctp/lore/sas/body",
		["body_mirrored"] = "egm/ctp/lore/sas/body",
	})

	-- CTP SAS Body Variante 1
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_sas_body_2", "Clone Trooper Pilots - SAS Armor 2", {
		["body"] = "egm/ctp/lore/sas/body_1",
		["body_mirrored"] = "egm/ctp/lore/sas/body_1",
	})

	-- CTP SAS Body Variante 2
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_sas_body_3", "Clone Trooper Pilots - SAS Armor 3", {
		["body"] = "egm/ctp/lore/sas/body_2",
		["body_mirrored"] = "egm/ctp/lore/sas/body_2",
	})
	-- CTP SAS Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_sas_helmet", "Clone Trooper Pilots - SAS Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/sas/helmet",
	})	

	-- CTP SAS Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "ctp_sas_body_1", "Clone Trooper Pilots - SAS Backpack", {
		["backpack"] = "egm/ctp/lore/sas/heavy",
	})

	-- 38th Armored Division --

	-- CTP 38th Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_38th", "Clone Trooper Pilots - 38th Armor", {
		["body"] = "egm/ctp/lore/38th/body",
		["body_mirrored"] = "egm/ctp/lore/38th/body",

		["kama"] = "egm/ctp/lore/38th/heavy",

		["kama_arc"] = "egm/ctp/lore/38th/kama_arc",
		["pauldron"] = "egm/ctp/lore/38th/specialist",
		["ammo_arm"] = "egm/ctp/lore/38th/specialist",
	})

	-- CTP 38th Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "ctp_38th", "Clone Trooper Pilots - 38th Helmet", {
		["helmet"] = "egm/ctp/lore/38th/helmet",
		["binoculars"] = "egm/ctp/lore/38th/specialist",
		["sunvisor"] = "egm/ctp/lore/38th/heavy",
		["armor"] = "egm/ctp/lore/38th/heavy",
	})

	-- CTP 38th Sidebag
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "ctp_38th", "Clone Trooper Pilots - 38th Sidebag", {
		["sidebag"] = "egm/ctp/lore/38th/heavy",
	})

	-- CTP 38th Rucksack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "ctp_38th", "Clone Trooper Pilots - 38th Backpack", {
		["backpack"] = "egm/ctp/lore/38th/heavy",
	})

	-- CTP 38th Pilot Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_38th_pilot", "Clone Trooper Pilots - 38th Pilot Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/38th/helmet_pilot",
	})

	-- Razor Squadron --

	-- CTP Razor Squadron Pilot Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_razor_squadron_helmet", "Clone Trooper Pilots - RS Pilot Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/razor_squadron/helmet",
	})

	-- CTP Razor Squadron Jaig Pilot Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_razor_squadron_jaig_helmet", "Clone Trooper Pilots - RS Jaig Pilot Helmet", {
		["helmet_pilot"] = "egm/ctp/lore/razor_squadron/helmet_jaig",
	})
end)
--lua/autorun/egm_grays.lua:
-- Register the Custom Char grays Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.104thgrays", function()
	-- grays Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_grays", "104th Grays - Armor", {
        ["body"] = "egm/custom_char/104th/grays/body",
		["body_mirrored"] = "egm/custom_char/104th/grays/body",
		
		["antenna_shoulder"] = "egm/custom_char/104th/grays/antenna_shoulder",

		["kama_arc"] = "egm/custom_char/104th/grays/kama_arc",
		
		["kama"] = "egm/104th/shared/heavy",		
		["straps_double"] = "egm/custom_char/104th/grays/heavy",
		["straps_double_grenades"] = "egm/custom_char/104th/grays/heavy",
		["straps_double_datapad"] = "egm/custom_char/104th/grays/heavy",
		["strap"] = "eegm/custom_char/104th/grays/heavy",
		["strap_grenades"] = "egm/custom_char/104th/grays/heavy",
		["strap_datapad"] = "egm/custom_char/104th/grays/heavy",
		
		["pauldron_big"] = "egm/custom_char/104th/grays/gear",
		["holsters"] = "egm/custom_char/104th/grays/gear",
		["pockets"] = "egm/custom_char/104th/grays/gear",
		["pauldron_arc_pockets"] = "egm/custom_char/104th/grays/gear",
		
		["ammo_arm"] = "egm/custom_char/104th/grays/specialist",
		["pauldron"] = "egm/custom_char/104th/grays/specialist",

	})
	
	-- Grays Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_grays", "104th Grays - Helmet", {
		["helmet"] = "egm/custom_char/104th/grays/helmet",
		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/custom_char/104th/grays/heavy",
		["binoculars"] = "egm/104th/shared/specialist",
		["antenna_ear"] = "egm/custom_char/104th/grays/antenna_ear",
	    ["rangefinder"] = "egm/104th/shared/rangefinder",
	})
	
	-- Grays Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "104th_grays", "104th Grays - Trooper Backpack", {
		["backpack"] = "egm/custom_char/104th/grays/heavy",
	})
	-- Grays Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "104th_grays", "104th Grays - Jumppack", {
		["bp_jumppack"] = "egm/custom_char/104th/grays/specialist",
	})
	-- Grays Sideback
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "104th_grays", "104th Grays - Sideback", {
		["sidebag"] = "egm/custom_char/104th/grays/heavy",
		["sidebag_grenades"] = "egm/custom_char/104th/grays/heavy",
		["sidebag_grenades"] = "egm/custom_char/104th/grays/heavy",
	})
end)
--lua/autorun/egm_jackal.lua:
-- Register the Custom Char jackal Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.RMCJackal", function()
	-- jackal Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "rmc_jackal", "jackal Body", {
		["body"] = "egm/custom_char/rmc/jackal/body",
		["synthmesh"] = "egm/custom_char/rmc/jackal/synthmesh",

		["kama"] = "egm/custom_char/rmc/jackal/kama",

		["pauldron"] = "egm/rmc/attachments/specialist",		
	})
	-- jackal Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "rmc_jackal", "jackal Helmet", {
		["helmet_synthmesh"] = "egm/custom_char/rmc/jackal/helmet",
	})
	-- jackal Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "rmc_jackal", "jackal Backpack", {
		["bp_utility"] = "egm/custom_char/rmc/jackal/backpack",
	})
end)
--lua/autorun/egm_nymphix.lua:
-- Register the CTP Custom Char Ventruss Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTPVentruss", function()
	-- Ventruss Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_ventruss", "CTP Ventruss - Armor", {
        ["body"] = "egm/custom_char/ctp/nymphix/body",
		["body_mirrored"] = "egm/custom_char/ctp/nymphix/body",

		["arc_gear_body"] = "egm/custom_char/ctp/nymphix/gear",
		["pauldron"] = "egm/custom_char/ctp/nymphix/specialist",

		["kama_arc"] = "egm/custom_char/ctp/nymphix/arc_kama",
		["kama"] = "egm/custom_char/ctp/nymphix/heavy",
    })
	-- Helmet P2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "ctp_ventruss", "CTP Ventruss P2 - Helmet", {
		["helmet"] = "egm/custom_char/ctp/nymphix/helmet",
		["arc_crest"] = "egm/custom_char/ctp/nymphix/arc_crest",
		["binoculars"] = "egm/custom_char/ctp/nymphix/specialist",
		["sunvisor"] = "egm/custom_char/ctp/nymphix/heavy",
	})
	-- Helmet Pilot
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_ventruss_pilot", "CTP Ventruss Pilot - Helmet", {
		["helmet_pilot"] = "egm/custom_char/ctp/nymphix/helmet_1",
	})
	-- Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "ctp_ventruss", "CTP Ventruss - Jumppack", {
		["bp_jumppack"] = "egm/custom_char/ctp/nymphix/specialist",
	})
end)
--lua/autorun/egm_ops2.lua:
-- Register the Custom Char Ops Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.212thOps", function()
	-- Ops Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "212th_ops2", "212th Ops - Body", {
		["body"] = "egm/custom_char/212th/ops2/body",
		["body_mirrored"] = "egm/custom_char/212th/ops2/body",

		["kama"] = "egm/212th_new/shared/heavy",
		["kama_arc"] = "egm/custom_char/212th/ops2/kama_arc",

		["pauldron"] = "egm/212th_new/shared/specialist",
		["pauldron_simple"] = "egm/212th_new/shared/pauldron_simple",
		["ammo_arm"] = "egm/212th_new/shared/specialist",
        ["ammo_shoulder"] = "egm/212th_new/shared/heavy",
		["strap"] = "egm/212th_new/trooper/heavy",
		
		["pauldron_big"] = "egm/custom_char/212th/ops2/gear",
		["holsters"] = "egm/custom_char/212th/ops2/gear",
		["arc_gear_body"] = "egm/custom_char/212th/ops2/gear",
		["arc_gear_legs"] = "egm/custom_char/212th/ops2/gear",
		["arc_gear_arms"] = "egm/custom_char/212th/ops2/gear",

		["antenna_shoulder"] = "egm/212th_new/shared/antenna_shoulder",
	})
	-- Ops Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "212th_ops2", "212th Ops - Helmet", {
		["helmet"] = "egm/custom_char/212th/ops2/helmet",
		
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["armor"] = "egm/212th_new/shared/heavy",
		
		["arc_crest"] = "egm/custom_char/212th/ops2/arc_crest",
	})
	-- Ops Airborne Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "212th_ops2", "212th Ops - Airborne Helmet", {
		["helmet_airborne"] = "egm/custom_char/212th/ops2/helmet_airborne",
		["binoculars"] = "egm/212th_new/shared/specialist",
		["rangefinder"] = "egm/212th_new/shared/rangefinder",

		["sunvisor"] = "egm/212th_new/shared/heavy",
		["camera"] = "egm/212th_new/lore/cody/camera",
	})
	-- Ops Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "212th_ops2", "212th Ops - Backpack", {
		["backpack"] = "egm/212th_new/shared/heavy",
	})
	-- Ops Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "212th_ops2", "212th Ops - Jetpack", {
		["bp_jetpack"] = "egm/custom_char/212th/ops2/bp_jetpack",
	})
end)
--lua/autorun/egm_rmc.lua:
-- Register the Republic Medical Corps material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.rmc", function()
	-- RMC Trooper Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_trooper", "RMC - Trooper Body", {
		["body"] = "egm/rmc/manschaftler/body",
		["body_mirrored"] = "egm/rmc/manschaftler/body",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
	-- RMC For Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_for", "RMC - FOR Body", {
		["body"] = "egm/rmc/manschaftler/body_for",
		["body_mirrored"] = "egm/rmc/manschaftler/body_for",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
	-- RMC OP Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_op", "RMC - OP Body", {
		["body"] = "egm/rmc/manschaftler/body_op",
		["body_mirrored"] = "egm/rmc/manschaftler/body_op",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
		-- RMC PSY Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_psy", "RMC - PSY Body", {
		["body"] = "egm/rmc/manschaftler/body_psy",
		["body_mirrored"] = "egm/rmc/manschaftler/body_psy",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
			-- RMC TEB Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_teb", "RMC - TEB Body", {
		["body"] = "egm/rmc/manschaftler/body_teb",
		["body_mirrored"] = "egm/rmc/manschaftler/body_teb",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
		-- RMC U-Officer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_u_officer", "RMC - U-Officer Body", {
		["body"] = "egm/rmc/trooper/body",
		["body_mirrored"] = "egm/rmc/trooper/body",

		["kama"] = "egm/rmc/attachments/heavy",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
			-- RMC Officer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_officer", "RMC - Officer Body", {
		["body"] = "egm/rmc/trooper/body_offi",
		["body_mirrored"] = "egm/rmc/trooper/body_offi",

		["kama"] = "egm/rmc/attachments/heavy",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
			-- RMC Veteran Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_veteran", "RMC - Veteran Body", {
		["body"] = "egm/rmc/trooper/body_vet",
		["body_mirrored"] = "egm/rmc/trooper/body_vet",

		["kama"] = "egm/rmc/attachments/heavy_red",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
			-- RMC Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_trooper", "RMC - Trooper Helmet", {
		["helmet"] = "egm/rmc/manschaftler/helmet",
		["sunvisor"] = "egm/rmc/attachments/heavy_red",
		["armor"] = "egm/rmc/attachments/heavy_red",

		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC U-Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_u_officer", "RMC - U-Officer Helmet", {
		["helmet"] = "egm/rmc/trooper/helmet",
		["sunvisor"] = "egm/rmc/attachments/heavy",
		["armor"] = "egm/rmc/attachments/heavy",

		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_officer", "RMC - Officer Helmet", {
		["helmet"] = "egm/rmc/trooper/helmet_offi",
		["sunvisor"] = "egm/rmc/attachments/heavy",
		["armor"] = "egm/rmc/attachments/heavy",

		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC Veteran Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_veteran", "RMC - Veteran Helmet", {
	 	["helmet"] = "egm/rmc/trooper/helmet_vet",
		["sunvisor"] = "egm/rmc/attachments/heavy_red",
		["armor"] = "egm/rmc/attachments/heavy_red",

		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC CTP Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "rmc_ctp", "RMC - Pilot Helmet", {
		["helmet_pilot"] = "egm/rmc/trooper/helmet_pilot",
	})
	-- RMC Jumptrooper Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_trooper_airborn", "RMC - Jumptrooper Body", {
		["body"] = "egm/rmc/jumptrooper/body",
		["body_mirrored"] = "egm/rmc/jumptrooper/body",

		["kama"] = "egm/rmc/attachments/heavy",
		["kama_arc"] = "egm/rmc/jumptrooper/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
			-- RMC Jumptrooper Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "rmc_trooper_airborn", "RMC - Jumptrooper Trooper Helmet", {
		["helmet_airborne"] = "egm/rmc/jumptrooper/helmet",
		["sunvisor"] = "egm/rmc/trooper/heavy_red",
		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC Jumptrooper Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "rmc_officer_airborn", "RMC - Jumptrooper Officer Helmet", {
		["helmet_airborne"] = "egm/rmc/jumptrooper/helmet_offi",
		["sunvisor"] = "egm/rmc/trooper/heavy",
		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
			-- RMC Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "rmc_trooper", "RMC - Trooper Backpack", {
		["backpack"] = "egm/rmc/attachments/heavy",
	})
			-- RMC Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "rmc_jumppack", "RMC - Jumppack", {
		["bp_jumppack"] = "egm/rmc/attachments/specialist",
	})
			-- RMC Synthmesh Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "rmc_synthmesh", "RMC - Synthmesh Body", {
		["synthmesh"] = "egm/rmc/synthmesh/synthmesh",

		["kama"] = "egm/rmc/synthmesh/heavy",
	})
			-- RMC Synthmesh Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "rmc_synthmesh", "RMC - Synthmesh Helmet", {
		["helmet_synthmesh"] = "egm/rmc/synthmesh/helmet",
	})
			-- RMC Synthmesh Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "rmc_synthmesh", "RMC - Synthmesh Backpack", {
		["bp_utility"] = "egm/rmc/synthmesh/bp_utility",
	})

	-- RMC Surgery Uniform
	BaseModel:RegisterMaterialSet("models/egm/core/uniform/uniform.mdl", "rmc_surgery", "RMC - Surgery Uniform", {
		["body"] = "egm/rmc/uniform/body",
		["legs"] = "egm/rmc/uniform/legs",
	})
end)

player_manager.AddValidModel( "Republic Medical Corps Surgery", "models/egm/rmc/surgery/surgery.mdl" )
list.Set( "PlayerOptionsModel",  "Republic Medical Corps Surgery", "models/egm/rmc/surgery/surgery.mdl" )
--lua/autorun/egm_rosph.lua:
-- Register the Custom Char Rosph Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SORosph", function()
	-- Rosph Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "so_rosph", "SO Rosph - Armor", {
		["body"] = "egm/custom_char/so/rosph/body",
		["body_mirrored"] = "egm/custom_char/so/rosph/body",

		["kama"] = "egm/custom_char/so/rosph/heavy",
		["kama_arc"] = "egm/specops/attachment/kama_arc",

		["pauldron"] = "egm/specops/attachment/specialist",
		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",
		["ammo_arm"] = "egm/specops/attachment/specialist",
		
		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",

		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",
	})
	-- Rosph Helmet Airborne
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "so_rosph", "SO Rosph - Helmet Airborne", {
		["helmet_airborne"] = "egm/custom_char/so/rosph/helmet_airborne",

		["flashlight"] = "egm/specops/trooper/helmet",
		["camera"] = "egm/specops/attachment/camera",
		["binoculars"] = "egm/specops/attachment/specialist",

		["sunvisor"] = "egm/specops/attachment/heavy",

		["rangefinder"] = "egm/specops/attachment/rangefinder",

		["antenna_back"] = "egm/specops/attachment/antenna_back",
	})
	-- Rosph Helmet Ear
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "so_rosph", "SO Rosph - Helmet SO", {
		["helmet_spec_ops"] = "egm/custom_char/so/rosph/helmet",
		["helmet_ear"] = "egm/custom_char/so/rosph/helmet_ear",
		["antenna_spec_ops"] = "egm/specops/attachment/antenna",
		["flashlight"] = "egm/specops/attachment/helmet",
		["camera"] = "egm/specops/attachment/camera",
	})
	-- Spec Ops Trooper Side Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "Specops_trooper", "Spec Ops - Trooper Sideback", {
		["sidebag"] = "egm/specops/attachment/heavy",
		["sidebag_datapad"] = "egm/specops/attachment/heavy",
	})
	-- Spec Ops Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "Specops_trooper", "Spec Ops - Trooper Backpack", {
		["backpack"] = "egm/specops/attachment/heavy",	
	})
end)
--lua/autorun/egm_st.lua:
-- Register the shock trooper material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.ShockTrooper", function()
	-- Shock Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_trooper", "ST - Trooper Armor", {
		["body"] = "egm/shock_trooper_refresh/trooper/body",
		["body_mirrored"] = "egm/shock_trooper_refresh/trooper/body",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_trooper", "ST - Trooper Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/trooper/helmet",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "st_trooper", "ST - Trooper Backpack", {
		["backpack"] = "egm/shock_trooper_refresh/trooper/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "st_trooper", "ST - Trooper Jetpack", {
		["bp_jetpack"] = "egm/shock_trooper_refresh/trooper/jetpack",
	})

	-- ST Pilot Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "st_trooper", "ST - Pilot Helmet", {
		["helmet_pilot"] = "egm/shock_trooper_refresh/trooper/helmet_pilot",
		["helmet_pilot_pipe"] = "egm/core/helmet_pilot/helmet_pilot_pipe",
		["helmet_pilot_breath"] = "egm/core/helmet_pilot/helmet_pilot_breath",
	})

	-- Shock Trooper Medic
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_medic", "ST - Medic Armor", {
		["body"] = "egm/shock_trooper_refresh/trooper/body_medic",
		["body_mirrored"] = "egm/shock_trooper_refresh/trooper/body_medic",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_medic", "ST - Medic Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/trooper/helmet_medic",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Shock Trooper TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_teb", "ST - TEB Armor", {
		["body"] = "egm/shock_trooper_refresh/trooper/body_teb",
		["body_mirrored"] = "egm/shock_trooper_refresh/trooper/body_teb",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_teb", "ST - TEB Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/trooper/helmet_teb",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Shock Trooper Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_veteran", "ST - Veteran Armor", {
		["body"] = "egm/shock_trooper_refresh/trooper/body_veteran",
		["body_mirrored"] = "egm/shock_trooper_refresh/trooper/body_veteran",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_veteran", "ST - Veteran Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/trooper/helmet_veteran",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Riot Control Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_riot", "ST - Riot Control Trooper Armor", {
		["body"] = "egm/shock_trooper_refresh/riot/body",
		["body_mirrored"] = "egm/shock_trooper_refresh/riot/body",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_riot", "ST - Riot Control Trooper Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/riot/helmet",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Riot Control Trooper Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_riot_veteran", "ST - Riot Control Veteran Armor", {
		["body"] = "egm/shock_trooper_refresh/riot/body_veteran",
		["body_mirrored"] = "egm/shock_trooper_refresh/riot/body_veteran",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_riot_veteran", "ST - Riot Control Veteran Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/riot/helmet_veteran",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- K9 Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_k9", "ST - K9 Trooper Armor", {
		["body"] = "egm/shock_trooper_refresh/k9/body",
		["body_mirrored"] = "egm/shock_trooper_refresh/k9/body",

		["kama"] = "egm/shock_trooper_refresh/k9/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_k9", "ST - K9 Trooper Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/k9/helmet",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "st_k9", "ST - K9 Trooper Helmet (ARF)", {
		["helmet_arf"] = "egm/shock_trooper_refresh/k9/helmet_arf",
		["armor"] = "egm/shock_trooper_refresh/k9/armor",
	})

	-- K9 Trooper Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_k9_veteran", "ST - K9 Veteran Armor", {
		["body"] = "egm/shock_trooper_refresh/k9/body_veteran",
		["body_mirrored"] = "egm/shock_trooper_refresh/k9/body_veteran",

		["kama"] = "egm/shock_trooper_refresh/k9/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_k9_veteran", "ST - K9 Veteran Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/k9/helmet_veteran",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "st_k9_veteran", "ST - K9 Veteran Helmet (ARF)", {
		["helmet_arf"] = "egm/shock_trooper_refresh/k9/helmet_arf_veteran",
		["armor"] = "egm/shock_trooper_refresh/k9/armor",
	})

	-- Lore: Fox
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_fox", "ST - Fox Armor", {
		["body"] = "egm/shock_trooper_refresh/lore/body_fox",
		["body_mirrored"] = "egm/shock_trooper_refresh/lore/body_fox",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",
		["kama_arc"] = "egm/shock_trooper_refresh/lore/kama_arc",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_fox", "ST - Fox Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/lore/helmet_fox",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/lore/sunvisor",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Lore: Thorn
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_thorn", "ST - Thorn Armor", {
		["body"] = "egm/shock_trooper_refresh/lore/body_thorn",
		["body_mirrored"] = "egm/shock_trooper_refresh/lore/body_thorn",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",
		["kama_arc"] = "egm/shock_trooper_refresh/lore/kama_arc",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_thorn", "ST - Thorn Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/lore/helmet_thorn",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/lore/sunvisor",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Lore: Stone
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_stone", "ST - Stone Armor", {
		["body"] = "egm/shock_trooper_refresh/lore/body_stone",
		["body_mirrored"] = "egm/shock_trooper_refresh/lore/body_stone",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",
		["kama_arc"] = "egm/shock_trooper_refresh/lore/kama_arc",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_stone", "ST - Stone Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/lore/helmet_stone",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Lore: Thire
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_thire", "ST - Thire Armor", {
		["body"] = "egm/shock_trooper_refresh/trooper/body",
		["body_mirrored"] = "egm/shock_trooper_refresh/trooper/body",

		["kama"] = "egm/shock_trooper_refresh/lore/kama_thire",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})

	-- Lore: Jek / Rys
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_jek", "ST - Jek/Rys Armor", {
		["body"] = "egm/shock_trooper_refresh/lore/body_jek",
		["body_mirrored"] = "egm/shock_trooper_refresh/lore/body_jek",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_jek", "ST - Jek/Rys Helmet", {
		["helmet"] = "egm/shock_trooper_refresh/lore/helmet_jek",

		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",

		["sunvisor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
	})

	-- Lore: Hound
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "st_hound", "ST - Hound Helmet", {
		["helmet_arf"] = "egm/shock_trooper_refresh/lore/helmet_hound",
		["armor"] = "egm/shock_trooper_refresh/lore/armor_hound",
	})
end)
--lua/autorun/egm_super.lua:
-- Register the DU Custom Charakter Super Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.DUSuper", function()
	-- Base Super Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "du_super", "DU - Super Armor", {
		["body"] = "egm/custom_char/du/super/body",
		["body_mirrored"] = "egm/custom_char/du/super/body",

		["kama"] = "egm/du/shared/heavy2", 
		["ammo_shoulder"] = "egm/du/shared/heavy2",
		["pauldron"] = "egm/du/shared/specialist",
		["ammo_arm"] = "egm/du/shared/heavy2",
	})
	-- DU Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "du_super", "DU - Super Helmet", {
		["helmet_arf"] = "egm/custom_char/du/super/helmet",
	})
end)
--lua/autorun/el-les.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "El-Les",		"models/player/tiki/el-les.mdl" )

--lua/autorun/embo.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Embo",		"models/player/tiki/embo.mdl" )

--lua/autorun/fire_creation.lua:
--[[-------------------------------------------------------------------------


vFire Creation Interface


---------------------------------------------------------------------------]]
if SERVER then
	--[[-------------------------------------------------------------------------
	In charge of creating a new fire in the world in appropriate positions/angles
	Attempts to create fire on a parent entity at a certain position
	Merges potentially new fires with existing ones if they're close enough
	---------------------------------------------------------------------------]]
	local mergeDistToSqr = 500
	local mergeDist = math.sqrt(mergeDistToSqr)
	function CreateVFire(parent, pos, normal, newFeed, spreader)

		-- Just to make sure
		if vFireIsVFireEnt(parent) then return end
		
		-- Handle information regarding our spreader
		local owner = parent
		local spreaderIsFire = false
		if IsValid(spreader) then
			if spreader:GetClass() == "vfire" then
				spreaderIsFire = true
			end
			owner = spreader:GetOwner()
		end

		-- Settle on our bone
		local bone
		if vFireIsCharacter(parent) then
			local boneCount = parent:GetBoneCount()
			-- Build a valid set of bones to attach to
			if !parent.vFireValidBones then
				parent.vFireValidBones = {}
				for b = 0, boneCount do
					if parent:BoneHasFlag(b, BONE_USED_BY_ATTACHMENT) then
						local bonePos = parent:GetBonePosition(b)
						-- Avoid bones with bad positions
						if bonePos:DistToSqr(pos) <= 10000000 then
							parent.vFireValidBones[b] = b
						end
					end
				end
			end
			-- Choose a random bone from the verified ones
			bone = table.Random(parent.vFireValidBones)
		end
		if bone == nil then
			bone = 0
		end

		if !parent.fires then parent.fires = {} end

		-- Use a table of close fires
		local closeEnts
		if parent:IsWorld() then
			closeEnts = ents.FindInSphere(pos, mergeDist)
		else
			closeEnts = {}
			local clustersTable = parent.fireClusters
			if clustersTable then
				for cluster, clusterPos in pairs(parent.fireClusters) do
					for k, fire2 in pairs(cluster.fires) do
						table.insert(closeEnts, fire2)
					end
				end
			end
		end

		-- Prevent fire entity spams by merging ourselves with existing neighbors
		for k, fire2 in pairs(closeEnts) do
			if !parent.fires[fire2] then continue end
			if vFireIsCharacter(parent) and fire2.bone != bone then continue end
			if IsValid(fire2) then
				-- Are we close enough?
				if pos:DistToSqr(fire2:GetPos()) <= mergeDistToSqr then
					
					if spreaderIsFire then -- We're spreading, give a random feed and life to the neighbor
						-- local spreaderGiveLife = math.Rand(spreader.life, spreader.life)
						-- spreader:GiveLife(fire2, spreaderGiveLife)
						spreader:GiveFeed(fire2, newFeed)
					else -- We're not spreading (we created a brand new fire) just add the new feed to the existing fire
						fire2.feed = fire2.feed + newFeed
					end

					-- Our neighbor will likely grow, prioritize it for responsiveness if the fire was made by a player
					if !spreaderIsFire then
						timer.Simple(0, function()
							if !IsValid(fire2) then return end
							fire2:Prioritize(5, true)
						end)
					end

					return
				end
			end
		end

		-- We didn't merge, create a new entity
		local fire = ents.Create("vfire")

		--[[-------------------------------------------------------------------------
		A WIP attempt to place fires with an angle that always faces a global wanted vector
		---------------------------------------------------------------------------
			   		local ang = normal:Angle()
			        -- local dot = ang:Up():Dot(Vector(1, 1, 0))
			        -- local rotate = 90 * dot

			        local forward = ang:Forward()
			        local up = ang:Up()

			        local wanted = Vector(0, 0, -1)
			        local flip = false
			        if forward.z != 0 then -- This happens when we aren't hitting a wall
			            local z2 = -forward.y/forward.z
			            wanted = Vector(0, 1, z2)
			            flip = (up.x < 0)
			        elseif forward.x != 0 then -- This happens when we are hitting a wall
			            local x2 = -forward.y/forward.x
			            wanted = Vector(x2, 1, 0)
			            flip = (forward.x > 0)
			        end
			        wanted:Normalize()
			        
			        local cos = math.Clamp(up:Dot(wanted), -1, 1) -- dot product = len1 * len2 * cos(angle between them), and both lengths are 1 in this case
			        local rollamount = math.deg(math.acos(cos))

			        -- Now we just need to figure out which way to rotate - left or right?
			        if flip then rollamount = 360 - rollamount end

			        -- ang:Add(Angle(0, 0, rollamount)) -- vector:Angle() always has roll = 0 so this is safe
			        ang:RotateAroundAxis(ang:Forward(), rollamount)

			        fire:SetAngles(ang)
        --[[-------------------------------------------------------------------------
        End of attempt
        ---------------------------------------------------------------------------]]

        fire:SetAngles(normal:Angle())



		-- Place our fire in respect to the parent
		if vFireIsCharacter(parent) then
			-- Fix position
			local bonePos = parent:GetBonePosition(bone)

			-- Parent is set internally through FollowBone
			fire:FollowBone(parent, bone)
			if bonePos then
				fire:SetPos(bonePos)
			else
				fire:SetPos(pos)
			end
		else
			fire:SetPos(pos)
			if IsValid(parent) then
				fire:SetParent(parent)
			end
		end

		-- Override some state limitations
		if vFireIsCharacter(parent) then
			local boneLen = parent:BoneLength(bone) or 1
			local maxState = math.Clamp(math.Round(boneLen / 8, 0), 2, 5)
			fire.stateDown = maxState
			fire.stateUp = maxState
		else
			-- Before we actually spawn, make sure we have the minimal placement requirement
			local canGrow, newPos = fire:ImprovePlacement(1, parent)
			if !canGrow then -- We're not worthy
				fire:Remove()
				return
			else
				fire:SetPos(newPos)
				fire.stateUp = 1
			end
		end

		-- Remember the bone for bone remembering purposes
		fire.bone = bone

		-- Initialize the owner as the parent or the spreader's owner
		fire:SetOwner(owner)

		fire:Spawn()

		-- Pass the new feed
		if spreaderIsFire then
			spreader:GiveFeed(fire, newFeed)
		else
			fire.feed = newFeed
		end

		-- Create a delayed decal
		if vFireEnableDecals then
			if math.Rand(0, 1) < vFireDecalProbability then
				timer.Simple(math.Rand(2, 15), function()
					if IsValid(fire) then
						local size = vFireStateToSize(fire:GetFireState())
						local scorch = "vScorch_"..size
						util.Decal(
							scorch,
							fire:GetPos() + fire:GetForward(),
							fire:GetPos() + fire:GetForward() * -15,
							fire
						)
					end
				end)
			end
		end

		return fire
	end





	--[[-------------------------------------------------------------------------
	In charge of creating a fire ball that sticks to surfaces
	---------------------------------------------------------------------------]]
	function CreateVFireBall(life, feedCarry, pos, vel, owner)
		local fireBall = ents.Create("vfire_ball")
			fireBall:SetPos(pos)
			if owner then
				fireBall:SetOwner(owner)
			end
		fireBall:Spawn()

		fireBall:GetPhysicsObject():AddVelocity(vel)
		fireBall:ChangeLife(life)
		fireBall.feedCarry = feedCarry

		return fireBall
	end





	function CreateVFireEntFires(ent, count)

		local phys = ent:GetPhysicsObject()
		if IsValid(phys) then

			if !ent.vFireIgnitePositions then ent.vFireIgnitePositions = {} end

			-- Increased scope to reduce recalls
			local meshConvexes
			local radius
			local center
			
			for i = 1, count do
				
				local pos = ent.vFireIgnitePositions[i]

				if pos then

					-- We have a position cached for this index, use it by translating the local position to a world position

					pos = ent:LocalToWorld(pos)
				
				else
					
					-- We don't have a position cached, calculate it using the mesh convexes

					if !meshConvexes then meshConvexes = phys:GetMeshConvexes() end
					if !meshConvexes then return false end

					local convexData = table.Random(meshConvexes)

					local sumVec = Vector()
					local sum = 0
					for k, posTable in pairs(convexData) do
						local weight = math.Rand(0, 1)
						sumVec = sumVec + ent:LocalToWorld(posTable.pos) * weight
						sum = sum + weight
					end
					sumVec = sumVec / sum

					-- Cache and set the position variable
					ent.vFireIgnitePositions[i] = ent:WorldToLocal(sumVec)
					pos = sumVec

				end

				if pos then

					if !radius then radius = ent:GetModelRadius() end
					if !center then center = ent:WorldSpaceCenter() end

					if radius and center then

						local vel = (center - pos) * radius
						local norm = -vel
						norm:Normalize()
						local life = math.Rand(5, 7)
						local feed = radius

						CreateVFireBall(life, feed, pos + norm * 25, vel)

					end
					
				end

			end

			return true
		end

		return false
	end
end


















--[[-------------------------------------------------------------------------
In charge of creating clientside effects for visual fidelity purposes
---------------------------------------------------------------------------]]
if CLIENT then

	local function physDummyValid(c)
		return IsValid(c.dummy)
	end
	local function physDummyStep(c)
		if CurTime() > c.endTime then
			c.dummy:Remove()
		end
	end
	function CreateCSVFirePhysDummy(pos, vel, lifeTime, nocollide)

		local colGroup = COLLISION_GROUP_IN_VEHICLE
		if !nocollide then colGroup = COLLISION_GROUP_WORLD end


		local dummy = ents.CreateClientProp()
			dummy:SetNoDraw(true)
			dummy:SetModel(vFireDummyModel)
			dummy:SetPos(pos)
			dummy:PhysicsInit(SOLID_VPHYSICS)
			dummy:SetMoveType(MOVETYPE_VPHYSICS)
			dummy:SetSolid(SOLID_VPHYSICS)
			dummy:SetCollisionGroup(colGroup)
			dummy:SetAngles(AngleRand())
		dummy:Spawn()

		local phys = dummy:GetPhysicsObject()
		phys:SetVelocity(vel)
		phys:SetMaterial("gmod_silent")

		local context = {
			IsValid = physDummyValid,
			dummy = dummy,
			endTime = CurTime() + lifeTime
		}

		hook.Add("Think", context, physDummyStep)

		return dummy
	end

	local function followForceValid(c)
		return c.isValid
	end
	local function followForceStep(c)
		local curTime = CurTime()
		if curTime < c.nextRun then return end
		c.nextRun = curTime + c.frequency

		if !IsValid(c.follower) then
			c.isValid = false
			return
		end

		if c.isEntity then
			if !IsValid(c.target) then c.isValid = false return end
		end

		if curTime > c.endTime then c.isValid = false return end

		local frac1to0 = (c.endTime - curTime) / (c.lifeTime)
		local strength = c.startStrength * frac1to0 + c.endStrength * (1 - frac1to0)

		local targetPos = c.target
		if isentity(c.target) then targetPos = targetPos:GetPos() end

		local diff = targetPos - c.follower:GetPos()
		if c.normalize then diff = diff:GetNormalized() end
		c.follower:GetPhysicsObject():AddVelocity(diff * strength)
	end
	function CreateVFireFollowForce(follower, target, lifeTime, frequency, startStrength, endStrength, normalize)
		
		local startTime = CurTime()
		local endTime = CurTime() + lifeTime
		local isEntity = isentity(target)
		
		local context = {
			IsValid = followForceValid,
			isValid = true,

			isEntity = isEntity,

			nextRun = 0,
			lifeTime = lifeTime,
			startTime = startTime,
			endTime = endTime,
			frequency = frequency,

			follower = follower,
			target = target,

			startStrength = startStrength,
			endStrength = endStrength,

			normalize = normalize
		}

		followForceStep(context)

		hook.Add("Think", context, followForceStep)
	end

	function CreateVFireFireHazeParticle(pos, vel, size, dieTime, gravity, resist, roll, brightness, alpha)
		local pe = ParticleEmitter(pos)
		if (pe) then

			local p = pe:Add("effects/muzzleflash3", pos)

			p:SetLifeTime(0)
			p:SetDieTime(dieTime)
			
			p:SetStartSize(0)
			p:SetEndSize(size)

			p:SetStartAlpha(math.random(alpha / 2, alpha))
			p:SetEndAlpha(0)

			p:SetColor(brightness, brightness, brightness)
			p:SetLighting(false)
			
			p:SetVelocity(vel)
			p:SetGravity(gravity * size)
			p:SetAirResistance(resist)

			p:SetCollide(false)

			p:SetRoll(math.Rand(0, 2 * math.pi))
			p:SetRollDelta(roll)

			pe:Finish()
		end
	end

	function CreateVFireDebrisSpurt(pos, count, minDieTime, maxDieTime, minSize, maxSize, roll, vel, spread, collide)
		local pe = ParticleEmitter(pos)
		if (pe) then
			for i = 1, count do
				local p = pe:Add(table.Random(list.Get("vFireDebris")), pos)

				p:SetLifeTime(0)
				p:SetDieTime(math.Rand(minDieTime, maxDieTime))
				
				local size = math.Rand(minSize, maxSize)
				p:SetStartSize(size)
				p:SetEndSize(size)

				p:SetStartAlpha(255)
				p:SetEndAlpha(255)

				p:SetColor(255, 255, 255)
				p:SetLighting(true)
				
				p:SetVelocity(vel * math.Rand(0.5, 1) + VectorRand() * spread)
				p:SetGravity(Vector(0, 0, -750))
				p:SetAirResistance(0)

				p:SetCollide(collide)
				p:SetBounce(0.15)

				p:SetRoll(math.Rand(0, 2 * math.pi))
				p:SetRollDelta(math.Rand(-roll, roll))
			end
			pe:Finish()
		end
	end

	function CreateVFireDirtSpurt(pos, count, minDieTime, maxDieTime, minSize, maxSize, roll, vel, spread, collide)
		local pe = ParticleEmitter(pos)
		if (pe) then
			for i = 1, count do
				local p = pe:Add(table.Random(list.Get("vFireDirt")), pos)

				p:SetLifeTime(0)
				p:SetDieTime(math.Rand(minDieTime, maxDieTime))
				
				local size = math.Rand(minSize, maxSize)
				p:SetStartSize(0)
				p:SetEndSize(size)

				p:SetStartAlpha(255)
				p:SetEndAlpha(0)

				p:SetColor(255, 255, 255)
				p:SetLighting(true)
				
				p:SetVelocity(vel * math.Rand(0.5, 1) + VectorRand() * spread)
				p:SetGravity(Vector(0, 0, -750))
				p:SetAirResistance(0)

				p:SetCollide(collide)
				p:SetBounce(0.15)

				p:SetRoll(math.Rand(0, 2 * math.pi))
				p:SetRollDelta(math.Rand(-roll, roll))
			end
			pe:Finish()
		end
	end

	function CreateVFireSparksSpurt(pos, count, minDieTime, maxDieTime, minSize, maxSize, roll, vel, spread, resistance)
		local pe = ParticleEmitter(pos)
		if (pe) then
			for i = 1, count do
				local p = pe:Add("effects/yellowflare", pos)

				p:SetLifeTime(0)
				p:SetDieTime(math.Rand(minDieTime, maxDieTime))
				
				local size = math.Rand(minSize, maxSize)
				p:SetStartSize(size)
				p:SetEndSize(0)

				p:SetStartAlpha(255)
				p:SetEndAlpha(255)

				p:SetColor(255, 255, 255)
				p:SetLighting(false)
				
				p:SetVelocity(vel * math.Rand(0.5, 1) + VectorRand() * spread)
				p:SetGravity(Vector(0, 0, -750))
				p:SetAirResistance(resistance)

				p:SetCollide(collide)

				p:SetRoll(math.Rand(0, 2 * math.pi))
				p:SetRollDelta(math.Rand(-roll, roll))
			end
			pe:Finish()
		end
	end

	function CreateVFireShockwave(pos, magnitude, particleCount)
		local pe = ParticleEmitter(pos)
		if (pe) then

			local bubble = pe:Add("particle/particle_ring_wave_8", pos)

			local dieTime = math.sqrt(magnitude * 0.01) / 2
			bubble:SetLifeTime(0)
			bubble:SetDieTime(dieTime)
			
			local endSize = dieTime * 36000
			bubble:SetStartSize(0)
			bubble:SetEndSize(endSize)

			local alpha = math.max(math.tanh((magnitude - 7) / 20) * 255, 0)
			bubble:SetStartAlpha(alpha)
			bubble:SetEndAlpha(0)

			bubble:SetColor(128, 128, 128)
			bubble:SetLighting(false)
			
			bubble:SetVelocity(Vector())
			bubble:SetGravity(Vector())
			bubble:SetAirResistance(10000)

			bubble:SetCollide(false)

			bubble:SetRoll(math.Rand(0, 2 * math.pi))
			local rollDelta = 10
			bubble:SetRollDelta(math.Rand(-rollDelta, rollDelta))

			local kick = pe:Add("particle/smokestack", pos)
			kick:SetLifeTime(0)
			kick:SetDieTime(dieTime * 1.5)
			
			kick:SetStartSize(0)
			kick:SetEndSize(endSize * 1.5)

			kick:SetStartAlpha(alpha * 0.75)
			kick:SetEndAlpha(0)

			kick:SetColor(128, 128, 128)
			kick:SetLighting(false)
			
			kick:SetVelocity(Vector())
			kick:SetGravity(Vector())
			kick:SetAirResistance(1)

			kick:SetCollide(false)

			kick:SetRoll(math.Rand(0, 2 * math.pi))
			kick:SetRollDelta(math.Rand(-rollDelta, rollDelta) * 0.5)

			pe:Finish()
		end
	end

	--[[-------------------------------------------------------------------------
	Creates a single smoke particle with some hardcoded behavior for consistency purposes
	---------------------------------------------------------------------------]]
	function CreateVFireSmokeParticle(pos, vel, size, dieTime, gravity, resist, roll, brightness, alpha)

		local pe = ParticleEmitter(pos)
		if (pe) then

			local p = pe:Add(table.Random(list.Get("vFireSmoke")), pos)

			p:SetLifeTime(0)
			p:SetDieTime(dieTime)
			
			p:SetStartSize(0)
			p:SetEndSize(size)

			p:SetStartAlpha(alpha)
			p:SetEndAlpha(0)

			p:SetColor(brightness, brightness, brightness)
			p:SetLighting(true)
			
			p:SetVelocity(vel)
			p:SetGravity(gravity * size)
			p:SetAirResistance(size * resist)

			p:SetCollide(false)

			p:SetRoll(math.Rand(0, 2 * math.pi))
			-- The bigger the size the less the roll delta
			p:SetRollDelta(roll * 900 / size)

			pe:Finish()
		end
	end

	--[[-------------------------------------------------------------------------
	Attaches an explosion trail to an entity/position (follow can either be an entity or a vector)
	---------------------------------------------------------------------------]]
	local function explosionTrailValid(c)
		if c.reps <= 0 then return false end
		if c.isEntity and !IsValid(c.follow) then return false end
		return true
	end
	local function explosionTrailStep(c)
		local curTime = CurTime()
		if curTime < c.nextRun then return end
		c.nextRun = curTime + c.interval

			local pos
			if c.isEntity then
				pos = c.follow:GetPos()
			else
				pos = c.follow
			end

			local radiusOffset = VectorRand() * math.Rand(c.minRadius or 0, c.maxRadius or 0)

			local particleString
			if c.bigBurst then
				particleString = "vFire_Burst_Main_Big"
			else
				particleString = "vFire_Burst_Main"
			end
			ParticleEffect(particleString, pos + radiusOffset, Angle())

		c.reps = c.reps - 1	
	end
	function CreateVFireExplosionTrail(follow, lifeTime, interval, bigBurst, minRadius, maxRadius)
		
		local isEntity = isentity(follow)

		if isEntity and !IsValid(follow) then return end

		local reps = math.floor(lifeTime / interval, 0)
		
		local context = {
			IsValid = explosionTrailValid,
			interval = interval,
			reps = reps,
			nextRun = 0,
			
			follow = follow,
			isEntity = isEntity,

			bigBurst = bigBurst,
			minRadius = minRadius,
			maxRadius = maxRadius
		}

		explosionTrailStep(context)

		hook.Add("Think", context, explosionTrailStep)
	end

	--[[-------------------------------------------------------------------------
	Attaches a smoke trail to an entity/position (follow can either be an entity or a vector)
	---------------------------------------------------------------------------]]
	local function smokeTrailValid(c)
		if c.reps <= 0 then return false end
		if c.isEntity and !IsValid(c.follow) then return false end
		return true
	end
	local function smokeTrailStep(c)
		local curTime = CurTime()
		if curTime < c.nextRun then return end
		c.nextRun = curTime + c.interval
		
			local size = c.startRadius * (1 - c.frac) + c.endRadius * c.frac

			-- Introduce noise to the die time value, this helps develop the trail into more interesting shapes
			local dieTime
			if c.dieTimeNoise then
				dNoise = math.Rand(-c.dieTimeNoise, c.dieTimeNoise)
				local dFrc = math.Clamp(c.frac + dNoise, 0, 1)
				dieTime = c.startLength * (1 - dFrc) + c.endLength * dFrc
			else
				dieTime = c.startLength * (1 - c.frac) + c.endLength * c.frac
			end
			
			local brightness = math.random(c.minBright, c.maxBright)
			local alpha = math.random(c.minAlpha, c.maxAlpha)
			local pos, vel
			if c.isEntity then
				vel = c.follow:GetVelocity()
				pos = c.follow:GetPos()
			else
				pos = c.follow
				vel = Vector()
			end

			c.frac = c.frac + c.fracAdd

			local roll = math.Rand(c.minRoll, c.maxRoll)

			CreateVFireSmokeParticle(pos, vel, size, dieTime, c.gravity, c.resist, roll, brightness, alpha)

		c.reps = c.reps - 1	
	end
	function CreateVFireSmokeTrail(follow, lifeTime, interval, startRadius, endRadius, startLength, endLength, gravity, resist, minRoll, maxRoll, minBright, maxBright, minAlpha, maxAlpha, dieTimeNoise, delay)
		
		local isEntity = isentity(follow)

		if isEntity and !IsValid(follow) then return end

		local reps = math.ceil(lifeTime / interval)
		local frac, fracAdd = 0, 1 / reps

		delay = delay or 0
		
		local context = {
			IsValid = smokeTrailValid,
			interval = interval,
			reps = reps,
			nextRun = CurTime() + delay,
			
			isEntity = isEntity,
			frac = frac,
			fracAdd = fracAdd,
			follow = follow,
			startRadius = startRadius,
			endRadius = endRadius,
			startLength = startLength,
			endLength = endLength,
			gravity = gravity,
			resist = resist,
			minRoll = minRoll,
			maxRoll = maxRoll,
			minBright = minBright,
			maxBright = maxBright,
			minAlpha = minAlpha,
			maxAlpha = maxAlpha,
			dieTimeNoise = dieTimeNoise
		}

		smokeTrailStep(context)

		hook.Add("Think", context, smokeTrailStep)
	end


	--[[-------------------------------------------------------------------------
	Attaches a fire trail to an entity/position (follow can either be an entity or a vector)
	---------------------------------------------------------------------------]]
	local function fireTrailValid(c)
		if c.reps <= -1 then return false end
		if c.isEntity and !IsValid(c.attach) then return false end
		return true
	end
	local function fireTrailStep(c)

		local curTime = CurTime()
		if curTime < c.nextRun then return end
		c.nextRun = curTime + c.interval

		if IsValid(c.trailFlames) then
			c.trailFlames:StopEmission()
		end

		if c.reps > 0 then
			c.trailFlames = CreateParticleSystem(
				c.attach,
				"vFire_Flames_"..vFireStateToSize(c.state)..c.LODStr,
				1,
				0,
				c.attachPos
			)

			if c.pullPos then
				vFirePullParticlesToPos(c.trailFlames, c.pullPos)
			end
		end

		c.reps = c.reps - 1
		c.state = c.state + c.add

	end
	function CreateVFireTrail(follow, startLife, endLife, lifeTime, canLOD, pullPos)

		local isEntity = isentity(follow) -- If we're not an entity we assume to be a position

		local LODStr = ""
		if canLOD == nil then -- We force LODs if we're neither false or true
			LODStr = "_LOD"
		else
			if canLOD and vFireGetLOD(follow) == 1 then
				LODStr = "_LOD"
			end
		end
		
		local state = vFireLifeToState(startLife)
		local targetState = vFireLifeToState(endLife)
		local reps = math.max(math.abs(state - targetState), 1) + 1 -- At least one rep
		local interval = lifeTime / reps

		local attach, attachPos
		if !isEntity then
			attach = game.GetWorld()
			attachPos = follow
		else
			attach = follow
			attachPos = Vector()
		end

		local add = 0
		if targetState < state then add = -1 end
		if targetState > state then add = 1 end

		local context = {
			IsValid = fireTrailValid,
			interval = interval,
			reps = reps,
			nextRun = 0,
			add = add,

			state = state,
			targetState = targetState,
			attach = attach,
			attachPos = attachPos,
			isEntity = isEntity,
			trailFlames = nil,
			LODStr = LODStr,
			pullPos = pullPos
		}

		fireTrailStep(context)

		hook.Add("Think", context, fireTrailStep)
	end

	--[[-------------------------------------------------------------------------
	Create a dynamic light attachment
	---------------------------------------------------------------------------]]
	local function dynamicLightValid(c)
		if CurTime() > c.endTime then return false end
		if c.isEntity and !IsValid(c.follow) then return false end
		return true
	end
	local function dynamicLightStep(c)

		local attachPos
		if !c.isEntity then
			attachPos = c.follow
		else
			attachPos = c.follow:GetPos()
		end

		local curTime = CurTime()
		local frac = (c.endTime - curTime) / (c.lifeTime)
		local fracRev = 1 - frac

		local yellowness = c.startYellowness * frac + c.endYellowness * fracRev
		local glowSize = c.startSize * frac + c.endSize * fracRev

		local d = DynamicLight(c.lightID)
		if d then
			d.pos = attachPos
			d.r = 255 * frac
			d.g = yellowness * frac
			d.b = c.blue * frac
			d.brightness = c.brightness
			d.decay = 0
			d.size = glowSize
			d.dietime = CurTime() + c.dieTime
		end
	end
	local vFireLightAttachID = 5000
	function CreateVFireDynamicLight(follow, lifeTime, brightness, startSize, endSize, dieTime, startYellowness, endYellowness, blue)

		local isEntity = isentity(follow) -- If we're not an entity we assume to be a position

		local startTime = CurTime()
		local endTime = startTime + lifeTime

		local context = {
			IsValid = dynamicLightValid,
			isEntity = isEntity,
			follow = follow,
			startTime = startTime,
			endTime = endTime,
			lifeTime = lifeTime,
			startSize = startSize,
			endSize = endSize,
			startYellowness = startYellowness,
			endYellowness = endYellowness,
			blue = blue,
			brightness = brightness,
			dieTime = dieTime,
			lightID = vFireLightAttachID
		}

		dynamicLightStep(context)

		hook.Add("Think", context, dynamicLightStep)

		vFireLightAttachID = vFireLightAttachID + 1
	end

	--[[-------------------------------------------------------------------------
	Create a glow sprite
	---------------------------------------------------------------------------]]
	local glowSpriteMat = Material("sprites/physg_glow1")
	local glowSpriteMatNoZ = Material("sprites/light_ignorez")
	local function glowSpriteValid(c)
		if CurTime() > c.endTime then return false end
		if c.isEntity and !IsValid(c.follow) then return false end
		return true
	end
	local function glowSpriteStep(c)

		local attachPos
		if !c.isEntity then
			attachPos = c.follow
		else
			attachPos = c.follow:GetPos()
		end

		local curTime = CurTime()
		local frac = (c.endTime - curTime) / (c.lifeTime)
		local fracRev = 1 - frac

		local alpha = c.startAlpha * frac + c.endAlpha * fracRev
		local yellowness = c.startYellowness * frac + c.endYellowness * fracRev
		local glowCol = Color(255, yellowness, c.blue, alpha)
		local glowSize = c.startSize * frac + c.endSize * fracRev

		if c.pixvis then
			local vis = util.PixelVisible(attachPos, 1, c.pixvis)
			if vis <= 0 then return end
			glowSize = glowSize * vis
			render.SetMaterial(glowSpriteMatNoZ)
		else
			render.SetMaterial(glowSpriteMat)
		end
		render.DrawSprite(attachPos, glowSize, glowSize, glowCol)
	end
	function CreateVFireGlowSprite(follow, lifeTime, startSize, endSize, startAlpha, endAlpha, startYellowness, endYellowness, blue, drawThroughEffects, usePixVis)

		local isEntity = isentity(follow) -- If we're not an entity we assume to be a position

		local startTime = CurTime()
		local endTime = startTime + lifeTime

		local pixvis
		if usePixVis then
			pixvis = util.GetPixelVisibleHandle()
		end

		local context = {
			IsValid = glowSpriteValid,
			isEntity = isEntity,
			follow = follow,
			startTime = startTime,
			endTime = endTime,
			lifeTime = lifeTime,
			startSize = startSize,
			endSize = endSize,
			startAlpha = startAlpha,
			endAlpha = endAlpha,
			startYellowness = startYellowness,
			endYellowness = endYellowness,
			blue = blue,
			pixvis = pixvis
		}

		if drawThroughEffects then
			hook.Add("PostDrawTranslucentRenderables", context, glowSpriteStep)
		else
			hook.Add("PreDrawTranslucentRenderables", context, glowSpriteStep)
		end
	end


	--[[-------------------------------------------------------------------------
	Creates a smoke ball
	---------------------------------------------------------------------------]]
	function CreateCSVFireSmokeBall(pos, vel, lifeTime, rate, startRadius, endRadius, startLength, endLength, gravity, resist, roll, minBright, maxBright, minAlpha, maxAlpha)
		local dummy = CreateCSVFirePhysDummy(pos, vel, lifeTime)
		
		CreateVFireSmokeTrail(
			dummy, -- Entity,
			lifeTime, -- Emission lifetime
			rate, -- Rate
			startRadius, -- Start radius
			endRadius,  -- End radius
			startLength, -- Length
			endLength,
			gravity, -- Gravity
			resist, -- Resistance
			roll,
			minBright,
			maxBright,
			minAlpha, -- Alpha
			maxAlpha
		)

		return dummy
	end

	--[[-------------------------------------------------------------------------
	Creates a fire ball
	---------------------------------------------------------------------------]]
	function CreateCSVFireBall(life, pos, vel, lifeTime, canLOD)

		local dummy = CreateCSVFirePhysDummy(pos, vel, lifeTime)

		-- Don't continue if we're underwater (if we can even tell at this point)
		if dummy:WaterLevel() > 0 then dummy:Remove() return end

		CreateVFireTrail(dummy, life, 0, lifeTime, canLOD)

		return dummy
	end


	--[[-------------------------------------------------------------------------
	Creates a non-physical mushroom explosion effect
	---------------------------------------------------------------------------]]
	local mushRoomID = 0
	function CreateVFireMushroom(pos, levels, ranDelay, spread, smokeFactor, startVel, span)

		if levels <= 0 then return end

		mushRoomID = mushRoomID + 1
		local timerID = "vFireMushroom"..mushRoomID

		if !startVel then startVel = VectorRand() end

		local follow = pos
		local startLife = vFireMaxLife
		local endLife = vFireMaxLife
		local lifeTime = 0.2 + math.Rand(0, ranDelay)
		local canLOD = true
		CreateVFireTrail(follow, startLife, endLife, lifeTime, canLOD)

		if math.Rand(0, 1) < smokeFactor / levels then
			CreateVFireSmokeTrail(
				follow, -- Entity,
				lifeTime, -- Emission lifetime (how long will we be emitting smoke?)
				1, -- Rate
				1000, -- Start radius
				100,  -- End radius
				lifeTime * 10, -- Start Length (what is the lifetime of new particles?)
				0.5, -- End Length (what is the lifetime of old particles?)
				vFireGetWindVector() * math.Rand(1, 5) + Vector(0, 0, math.Rand(2, 6)), -- Gravity
				1, -- Resistance
				0.5, -- Roll
				0, -- Brightness
				100,
				60, -- minAlpha
				255 -- maxAlpha
			)
		end

		levels = levels - 1
		if levels <= 0 then return end

		local size = 300 + 150 * levels
		timer.Simple(math.Rand(0, ranDelay), function()
			local newPos = follow + startVel * size
			local ranVector, ranVector2, newVel, newVel2
			if span then
				ranVector = Vector(span.x * math.Rand(-1, 1), span.y * math.Rand(-1, 1), span.z * math.Rand(-1, 1))
				ranVector2 = Vector(span.x * math.Rand(-1, 1), span.y * math.Rand(-1, 1), span.z * math.Rand(-1, 1))
				ranVector:Normalize()
				ranVector2:Normalize()
			else
				ranVector = VectorRand()
				ranVector2 = VectorRand()
			end
			local newVel = (startVel + ranVector * spread) / (1 + spread)
			local newVel2 = (startVel + ranVector2 * spread) / (1 + spread)
			local newSpread = spread * 0.9
			CreateVFireMushroom(newPos, levels, ranDelay, newSpread, smokeFactor, newVel, span)
			CreateVFireMushroom(newPos, levels - 1, ranDelay, newSpread, smokeFactor, newVel2, span)
		end)
	end

	-- Some old shit
	function CreateVFireExplosionEffect(pos, magnitude)

		local magnitudeSqrd = magnitude * magnitude

		local canLOD = true

		-- Radiating balls

		for i = 1, math.random(1, 4) * magnitude do
			local life = math.Rand(1, 5) * magnitudeSqrd
			local vel = VectorRand() * (50 + math.Rand(90, 325) * magnitude)
			local lifeTime = 0.3 + math.Rand(0.05, 0.3) * magnitude
			CreateCSVFireBall(life, pos, vel, lifeTime, canLOD)
		end

		-- Center explosion ball

		local life = magnitudeSqrd * math.Rand(40, 150)
		local vel = VectorRand() * math.Rand(0, 30)
		local lifeTime = math.Rand(0.6, 1.8) + 0.4 * magnitude
		CreateCSVFireBall(life, pos, vel, lifeTime, canLOD)


		-- Play a sound that reflects the stack
		-- local sndID = math.random(1, math.Min(6, magnitude))
		-- local sndStr = "ambient/explosions/explode_"..sndID..".wav"
		-- sound.Play(
		-- 	sndStr,								-- Sound
		-- 	pos,								-- Position
		-- 	90 + 5 * magnitude,					-- Level
		-- 	math.Max(140 - magnitude * 20, 40),	-- Pitch
		-- 	1									-- Volume
		-- )
	end

	--[[-------------------------------------------------------------------------
	In charge of creating smoke plume effects
	---------------------------------------------------------------------------]]
	function CreateVFireSmokePlume(pos, dir, magnitude, entity)
		local effectData = EffectData()
			effectData:SetOrigin(pos)
			effectData:SetNormal(dir)
			effectData:SetMagnitude(magnitude)
			effectData:SetEntity(entity)
		util.Effect("vfire_smoke_plume", effectData, true, true)
	end

end

--lua/autorun/fire_misc.lua:
--[[-------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		vFire by Vioxtar

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
---------------------------------------------------------------------------]]



--[[-------------------------------------------------------------------------
vFire Globals
---------------------------------------------------------------------------]]
vFireMaxState = 7

local lifeBase = 2.295 -- Originally 2.5
vFireMaxLife = lifeBase^vFireMaxState

vFireStatesLifeThresholds = {}
	vFireStatesLifeThresholds[1] = lifeBase^1 -- or lower is state 1 else
	vFireStatesLifeThresholds[2] = lifeBase^2 -- or lower is state 2 else
	vFireStatesLifeThresholds[3] = lifeBase^3 -- or lower is state 3 else
	vFireStatesLifeThresholds[4] = lifeBase^4 -- or lower is state 4 else
	vFireStatesLifeThresholds[5] = lifeBase^5 -- or lower is state 5 else
	vFireStatesLifeThresholds[6] = lifeBase^6 -- or lower is state 6 else
	vFireStatesLifeThresholds[7] = vFireMaxLife -- or lower is state 7

vFireStateToSizeTable = {}
	vFireStateToSizeTable[1] = "Tiny"
	vFireStateToSizeTable[2] = "Small"
	vFireStateToSizeTable[3] = "Medium"
	vFireStateToSizeTable[4] = "Big"
	vFireStateToSizeTable[5] = "Huge"
	vFireStateToSizeTable[6] = "Gigantic"
	vFireStateToSizeTable[7] = "Inferno"

vFireClusterSize = 400

vFireDummyModel = "models/hunter/plates/plate.mdl"
util.PrecacheModel(vFireDummyModel)

function vFireStateToSize(state)
	local size = vFireStateToSizeTable[state] or "Tiny"
	return size
end

function vFireLifeToState(life)
	local stateReturn = vFireMaxState
	for stateIndex, lifeThreshold in pairs(vFireStatesLifeThresholds) do
		if life <= lifeThreshold then
			stateReturn = stateIndex
			return stateReturn
		end
	end
	return stateReturn
end

function vFireStateToLife(state)
	return vFireStatesLifeThresholds[state]
end

-- Helper used to determine if we're burning a character or not
function vFireIsCharacter(ent)
	if !IsValid(ent) then return false end
	if ent.vFireIsCharacter != nil then return ent.vFireIsCharacter end
	local isCharacter = ent:IsRagdoll() or ent:IsNPC() or ent:IsPlayer()
	ent.vFireIsCharacter = isCharacter
end

function vFireIsMobile(ent)
	local parent = ent.parent
	if !IsValid(parent) then return false end
	return (parent == NULL or !parent:IsWorld())
end

-- Helper used to determine if an entity is ours or not
function vFireIsVFireEnt(ent)
	if !IsValid(ent) then return false end
	if ent.vFireIsVFireEnt != nil then return ent.vFireIsVFireEnt end
	
	local c = ent:GetClass()
	local isVFireEnt = c == "vfire" or c == "vfire_ball" or c == "vfire_cluster"
	ent.vFireIsVFireEnt = isVFireEnt
	return isVFireEnt
end

local baseRadius = {10, 30, 50, 80, 125, 230, 390}
function vFireBaseRadius(state)
	return baseRadius[state]
end

function vFireGetFires(ent)
	local fires = {}
	local firesTable = ent.fires
	if firesTable then
		for fire, lPos in pairs(firesTable) do 
			table.insert(fires, fire)
		end
	end
	return fires
end

--[[-------------------------------------------------------------------------
Burning Entities Tracking
---------------------------------------------------------------------------]]
local burningEntities = {}
function vFireGetBurningEntities()
	return table.Copy(burningEntities)
end
hook.Add("vFireEntityStartedBurning", "vFireAddBurningEntity", function(ent)
	burningEntities[ent] = ent
end)
hook.Add("vFireEntityStoppedBurning", "vFireRemBurningEntity", function(ent)
	if burningEntities[ent] then
		burningEntities[ent] = nil
	end
end)

--[[-------------------------------------------------------------------------
vFiresCount Tracking
---------------------------------------------------------------------------]]
vFiresCount = 0
hook.Add("vFireCreated", "vFiresCountIncrement", function(fire)
	-- Update vFiresCount
	vFiresCount = vFiresCount + 1

	-- Update whatever else we need to update
	vFireUpdateThinkThrottle()
	
	if SERVER then
		vFireUpdateLifeThrottle()
	end
end)

hook.Add("vFireRemoved", "vFiresCountDecrement", function(fire)
	-- Update vFiresCount
	vFiresCount = math.Max(vFiresCount - 1, 0)

	-- Update whatever else we need to update
	vFireUpdateThinkThrottle()
	
	if SERVER then
		vFireUpdateLifeThrottle()
	end
end)


--[[-------------------------------------------------------------------------
Tickrates Management
---------------------------------------------------------------------------]]
if CLIENT then
	vFireClusterThinkTickRate = 5
	vFireParticlesThinkTickRate = 1.15
	vFireAnimationThinkTickRate = 15
	
	vFireThrottleMultiplier = 0.01
	vFireThinkThrottle = 0
	function vFireUpdateThinkThrottle()
		vFireThinkThrottle = vFiresCount * vFireThrottleMultiplier
	end
end

if SERVER then
	vFireFuelThinkTickRate = 2
	vFireLifeThinkTickRate = 1.15
	vFireEatThinkTickRate = 2
	vFireBurnThinkTickRate = 1.5
	vFireDropThinkTickRate = 3
	vFireSpreadThinkTickRate = 2

	vFireThrottleMultiplier = 0.1
	vFireThinkThrottle = 0
	vFireMaxThinkThrottle = 30 -- Cap the throttling to avoid non-thinking fires (bad at performance heavy scenarios)
	function vFireUpdateThinkThrottle()
		vFireThinkThrottle = math.min(vFiresCount * vFireThrottleMultiplier, vFireMaxThinkThrottle)
	end
end













--[[-------------------------------------------------------------------------
ConVars
---------------------------------------------------------------------------]]
if CLIENT or SERVER then
	--[[-------------------------------------------------------------------------
	Wind functionalities
	---------------------------------------------------------------------------]]
	local windVec = Vector(0.7, -1, 0)
	windVec:Normalize()
	function vFireGetWindVector()
		return windVec
	end

	-- Used to calcualte the wind flow of a given position
	local windExposureCheckDist = 10000
	function vFireCalcWindExposure(pos, filter)
		-- Shoot out several traces to determine how 'outside' we are
		local traceDistSum = 0
		for i = 1, 3 do
			local dir = (VectorRand() * 0.35 - vFireGetWindVector() + Vector(0, 0, 0.05)) * windExposureCheckDist
			local tr = util.QuickTrace(pos, dir, filter)
			traceDistSum = traceDistSum + tr.Fraction * 2
			if traceDistSum >= 1 then
				return 1
			end
		end
		return math.min(traceDistSum, 1)
	end

	--[[-------------------------------------------------------------------------
	Smoke functionalities
	---------------------------------------------------------------------------]]
	local vFireEnableSmokeConVar = CreateConVar("vfire_enable_smoke", "1", FCVAR_REPLICATED + FCVAR_SERVER_CAN_EXECUTE, "Enables fire smoke.")
	vFireEnableSmoke = vFireEnableSmokeConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_smoke", function(convar, old, new)
		vFireEnableSmoke = vFireEnableSmokeConVar:GetBool()
	end)
end

if CLIENT then
	--[[-------------------------------------------------------------------------
	Toggle fire LODs
	---------------------------------------------------------------------------]]
	local vFireLODsConVar = CreateClientConVar("vfire_lod", "1", true, false, "Set to 0 to disable all fire LODs, 1 for automatic LODs, and 2 to force LODs on.")
	vFireLODs = vFireLODsConVar:GetInt()
	cvars.AddChangeCallback("vfire_lod", function(convar, old, new)
		vFireLODs = math.Clamp(vFireLODsConVar:GetInt(), 0, 2)
	end)

	
	--[[-------------------------------------------------------------------------
	Toggle fire glows
	---------------------------------------------------------------------------]]
	local vFireEnableGlowsConVar = CreateClientConVar("vfire_enable_glows", "1", true, false, "Set to 0 to disable fire glow effects.")
	vFireEnableGlows = vFireEnableGlowsConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_glows", function(convar, old, new)
		vFireEnableGlows = vFireEnableGlowsConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Toggle fire dynamic lights
	---------------------------------------------------------------------------]]
	local vFireEnableLightsConVar = CreateClientConVar("vfire_enable_lights", "1", true, false, "Set to 0 to disable all fire light effects for increased performance at the cost of visual fidelity.")
	vFireEnableLights = vFireEnableLightsConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_lights", function(convar, old, new)
		vFireEnableLights = vFireEnableLightsConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Set fire light brightness
	---------------------------------------------------------------------------]]
	local vFireLightMulConVar = CreateClientConVar("vfire_light_brightness", "0.4", true, false, "Set the fire light brightness multiplier.")
	vFireLightMul = vFireLightMulConVar:GetFloat()
	cvars.AddChangeCallback("vfire_light_brightness", function(convar, old, new)
		vFireLightMul = vFireLightMulConVar:GetFloat()
	end)




	--[[-------------------------------------------------------------------------
	Reset all ConVars
	---------------------------------------------------------------------------]]
	concommand.Add("vfire_default_visual_settings", function()
		vFireLODsConVar:SetBool(vFireLODsConVar:GetDefault())
		vFireEnableGlowsConVar:SetBool(vFireEnableGlowsConVar:GetDefault())
		vFireEnableLightsConVar:SetBool(vFireEnableLightsConVar:GetDefault())
		vFireLightMulConVar:SetFloat(vFireLightMulConVar:GetDefault())
		vFireMessage("vFire client settings reset to default!")
	end)
end

if SERVER then
	--[[-------------------------------------------------------------------------
	Set throttle multiplier
	---------------------------------------------------------------------------]]
	local vFireThrottleMultiplierConVar = CreateConVar("vfire_throttle_multiplier", tostring(vFireThrottleMultiplier), FCVAR_ARCHIVE, "Performance Warning: advanced setting, may result in unexpected behavior! Set the fire throttle multiplier - lower values will result in more responsive fires at the cost of performance.")
	vFireThrottleMultiplier = vFireThrottleMultiplierConVar:GetFloat()
	cvars.AddChangeCallback("vfire_throttle_multiplier", function(convar, old, new)
		vFireThrottleMultiplier = vFireThrottleMultiplierConVar:GetFloat()
		vFireUpdateThinkThrottle()
	end)


	--[[-------------------------------------------------------------------------
	Toggle fire damage
	---------------------------------------------------------------------------]]
	local vFireEnableDamageConVar = CreateConVar("vfire_enable_damage", "1", FCVAR_ARCHIVE, "Set to 0 to disable fire damage.")
	vFireEnableDamage = vFireEnableDamageConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_damage", function(convar, old, new)
		vFireEnableDamage = vFireEnableDamageConVar:GetBool()
	end)

	
	--[[-------------------------------------------------------------------------
	Toggle fire damage for players in vehicles
	---------------------------------------------------------------------------]]
	local vFireEnableDamageInVehiclesConVar = CreateConVar("vfire_enable_damage_in_vehicles", "0", FCVAR_ARCHIVE, "Set to 1 to enable fire damage to players inside vehicles.")
	vFireEnableDamageInVehicles = vFireEnableDamageInVehiclesConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_damage_in_vehicles", function(convar, old, new)
		vFireEnableDamageInVehicles = vFireEnableDamageInVehiclesConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Set fire damage multiplier
	---------------------------------------------------------------------------]]
	local vFireDamageMultiplierConVar = CreateConVar("vfire_damage_multiplier", "1", FCVAR_ARCHIVE, "Set the damage multiplier for fires, 0 disables all damage.")
	vFireDamageMultiplier = vFireDamageMultiplierConVar:GetFloat()
	cvars.AddChangeCallback("vfire_damage_multiplier", function(convar, old, new)
		vFireDamageMultiplier = vFireDamageMultiplierConVar:GetFloat()
	end)


	--[[-------------------------------------------------------------------------
	Toggle explosion fire balls
	---------------------------------------------------------------------------]]
	local vFireEnableExplosionFiresConVar = CreateConVar("vfire_enable_explosion_fires", "1", FCVAR_ARCHIVE, "Set to 0 to disable explosion fires.")
	vFireEnableExplosionFires = vFireEnableExplosionFiresConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_explosion_fires", function(convar, old, new)
		vFireEnableExplosionFires = vFireEnableExplosionFiresConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Toggle enhanced explosion effects
	---------------------------------------------------------------------------]]
	local vFireEnableExplosionEffectsConVar = CreateConVar("vfire_enable_explosion_effects", "1", FCVAR_ARCHIVE, "Set to 0 to disable fancy explosion effects.")
	vFireEnableExplosionEffects = vFireEnableExplosionEffectsConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_explosion_effects", function(convar, old, new)
		vFireEnableExplosionEffects = vFireEnableExplosionEffectsConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Toggle fire decals
	---------------------------------------------------------------------------]]
	local vFireEnableDecalsConVar = CreateConVar("vfire_enable_decals", "1", FCVAR_ARCHIVE, "Set to 0 to disable fire decals.")
	vFireEnableDecals = vFireEnableDecalsConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_decals", function(convar, old, new)
		vFireEnableDecals = vFireEnableDecalsConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Set fire decal probability
	---------------------------------------------------------------------------]]
	local vFireDecalProbabilityConVar = CreateConVar("vfire_decal_probability", "0.4", FCVAR_ARCHIVE, "Set the probability (a value between 0 and 1) of creating fire decals.")
	vFireDecalProbability = vFireDecalProbabilityConVar:GetFloat()
	cvars.AddChangeCallback("vfire_decal_probability", function(convar, old, new)
		vFireDecalProbability = vFireDecalProbabilityConVar:GetFloat()
	end)


	--[[-------------------------------------------------------------------------
	Toggle fire spread
	---------------------------------------------------------------------------]]
	local vFireEnableSpreadConVar = CreateConVar("vfire_enable_spread", "1", FCVAR_ARCHIVE, "Set to 0 to disable fire spread.")
	vFireEnableSpread = vFireEnableSpreadConVar:GetBool()
	cvars.AddChangeCallback("vfire_enable_spread", function(convar, old, new)
		vFireEnableSpread = vFireEnableSpreadConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Set fire spread rate
	---------------------------------------------------------------------------]]
	local vFireSpreadRateConVar = CreateConVar("vfire_spread_delay", tostring(vFireSpreadThinkTickRate), FCVAR_ARCHIVE, "Set fire spread delay in seconds - the smaller the number the faster fires will spread. Performance Warning: use this to limit spread, not increase it! If you want to increase spread, use vfire_spread_boost!")
	vFireSpreadThinkTickRate = math.Max(vFireSpreadRateConVar:GetFloat(), 0.0001)
	cvars.AddChangeCallback("vfire_spread_delay", function(convar, old, new)
		vFireSpreadThinkTickRate = math.Max(vFireSpreadRateConVar:GetFloat(), 0.0001)
	end)


	--[[-------------------------------------------------------------------------
	Set fire decay rate
	---------------------------------------------------------------------------]]
	local vFireDecayRateConVar = CreateConVar("vfire_decay_rate", "0.1", FCVAR_ARCHIVE, "Set fire decay rate, 1 is max decay rate, 0 is no decay rate. Performance Warning: removing decay entirely may increase load as fires accumulate.")
	vFireDecayRate = vFireDecayRateConVar:GetFloat()
	cvars.AddChangeCallback("vfire_decay_rate", function(convar, old, new)
		vFireDecayRate = math.Clamp(vFireDecayRateConVar:GetFloat(), 0, 1)
	end)


	--[[-------------------------------------------------------------------------
	Toggle custom NPC behavior
	---------------------------------------------------------------------------]]
	local vFireEnableNPCBehaviorConVar = CreateConVar("vfire_affect_npcs", "1", FCVAR_ARCHIVE, "Set to 0 to disable custom NPC behavior.")
	vFireEnableNPCBehavior = vFireEnableNPCBehaviorConVar:GetBool()
	cvars.AddChangeCallback("vfire_affect_npcs", function(convar, old, new)
		vFireEnableNPCBehavior = vFireEnableNPCBehaviorConVar:GetBool()
	end)


	--[[-------------------------------------------------------------------------
	Add cluster feed - in the 'prettified' name of spread boost
	---------------------------------------------------------------------------]]
	local vFireClusterFeedConVar = CreateConVar("vfire_spread_boost", "0", FCVAR_ARCHIVE, "Set the spread boost of new fires. Higher values will achieve faster, and stronger spread. Performance Warning: excessively high values may result in endless spreading.")
	vFireClusterFeed = vFireClusterFeedConVar:GetFloat()
	cvars.AddChangeCallback("vfire_spread_boost", function(convar, old, new)
		vFireClusterFeed = math.Max(vFireClusterFeedConVar:GetFloat(), 0)
	end)


	--[[-------------------------------------------------------------------------
	Remove all fires
	---------------------------------------------------------------------------]]
	concommand.Add("vfire_remove_all", function(ply)

		if IsValid(ply) and !ply:IsAdmin() then return end

		for k, fire in pairs(ents.FindByClass("vfire")) do
			fire:Remove()
		end
	end)




	--[[-------------------------------------------------------------------------
	Reset all ConVars
	---------------------------------------------------------------------------]]
	concommand.Add("vfire_default_settings", function(ply)

		if IsValid(ply) and !ply:IsAdmin() then return end

		vFireThrottleMultiplierConVar:SetFloat(vFireThrottleMultiplierConVar:GetDefault())
		vFireEnableDamageConVar:SetBool(vFireEnableDamageConVar:GetDefault())
		vFireDamageMultiplierConVar:SetFloat(vFireDamageMultiplierConVar:GetDefault())
		vFireEnableExplosionEffectsConVar:SetFloat(vFireEnableExplosionEffectsConVar:GetDefault())
		vFireEnableDecalsConVar:SetBool(vFireEnableDecalsConVar:GetDefault())
		vFireDecalProbabilityConVar:SetFloat(vFireDecalProbabilityConVar:GetDefault())
		vFireEnableSpreadConVar:SetBool(vFireEnableSpreadConVar:GetDefault())
		vFireSpreadRateConVar:SetFloat(vFireSpreadRateConVar:GetDefault())
		vFireDecayRateConVar:SetFloat(vFireDecayRateConVar:GetDefault())
		vFireEnableNPCBehaviorConVar:SetBool(vFireEnableNPCBehaviorConVar:GetDefault())
		vFireClusterFeedConVar:SetFloat(vFireClusterFeedConVar:GetDefault())
		
		vFireMessage("vFire settings reset to default!")
	end)
end
















--[[-------------------------------------------------------------------------
Life Throttle Calculation
---------------------------------------------------------------------------]]
if SERVER then
	vFireLifeThrottle = 0
	function vFireUpdateLifeThrottle()
		vFireLifeThrottle = math.Max(vFiresCount * 1.5, 10) * vFireDecayRate * vFireThrottleMultiplier
	end
end


if SERVER then
	--[[-------------------------------------------------------------------------
	How much fuel does each prop material give?
	We don't use material types here to give fueling mechanics more variation
	---------------------------------------------------------------------------]]
	local matsFuelAmount = {
		wood_crate = 40,
		wood = 40,
		plastic_barrel = 15,
		plastic = 10,
		wood_furniture = 40,
		rubbertire = 20,
		cardboard = 8,
		paper = 6,
		rubber = 18,
		alienflesh = 7,
		wood_solid = 40,
		tile = 1
	}

	--[[-------------------------------------------------------------------------
	How quickly does each material give fuel?
	---------------------------------------------------------------------------]]
	local matsFuelRate = {
		wood_crate = 0.5,
		wood = 0.5,
		plastic_barrel = 1.8,
		plastic = 1.8,
		wood_furniture = 0.5,
		rubbertire = 1.5,
		cardboard = 9,
		paper = 13,
		rubber = 0.6,
		alienflesh = 0.7,
		wood_solid = 0.5,
		tile = 0.2
	}
	
	local matTypesFuelRate = {}
		matTypesFuelRate[MAT_ANTLION] = 0.8
		matTypesFuelRate[MAT_BLOODYFLESH] = 0.4
		matTypesFuelRate[MAT_DIRT] = 0.3
		matTypesFuelRate[MAT_FLESH] = 0.45
		matTypesFuelRate[MAT_ALIENFLESH] = 0.8
		matTypesFuelRate[MAT_PLASTIC] = 0.7
		matTypesFuelRate[MAT_FOLIAGE] = 0.375
		matTypesFuelRate[MAT_GRASS] = 0.375
		matTypesFuelRate[MAT_WOOD] = 1.2

	function vFireMatToFuelRate(mat)
		return matsFuelRate[mat] or matTypesFuelRate[mat] or 0.5
	end


	--[[-------------------------------------------------------------------------
	Feeding materials - what feed will each material give?
	Used primarily for cluster feeds
	We use material types because that's all the information we've got when burning
	the world
	---------------------------------------------------------------------------]]
	local matTypesFeed = {}
		matTypesFeed[MAT_ANTLION] = 100
		matTypesFeed[MAT_BLOODYFLESH] = 40 
		matTypesFeed[MAT_DIRT] = 165
		matTypesFeed[MAT_FLESH] = 200
		matTypesFeed[MAT_ALIENFLESH] = 200
		matTypesFeed[MAT_PLASTIC] = 500
		matTypesFeed[MAT_FOLIAGE] = 575
		matTypesFeed[MAT_COMPUTER] = 40
		matTypesFeed[MAT_GRASS] = 300
		matTypesFeed[MAT_WOOD] = 4000

	function vFireMatToFeed(mat)
		return matTypesFeed[mat] or 0
	end

	--[[-------------------------------------------------------------------------
	Material damage multipliers - how much are we damaging each material?
	We need this for balancing purposes, for example: explosive barrels should take
	more damage so they explode faster, while burning wood should be kept alive
	longer so fires can grow off of it. Using material types because we don't really
	need to be more specific
	---------------------------------------------------------------------------]]
	local matTypesDamageMul = {}
		matTypesDamageMul[MAT_PLASTIC] = 2
		matTypesDamageMul[MAT_METAL] = 8
		matTypesDamageMul[MAT_COMPUTER] = 3
		matTypesDamageMul[MAT_SLOSH] = 2
		matTypesDamageMul[MAT_GLASS] = 2

	function vFireMatToDamageMultiplier(mat)
		return matTypesDamageMul[mat] or 1
	end

	--[[-------------------------------------------------------------------------
	Damage data cacher for fast damage info builds
	---------------------------------------------------------------------------]]
	function vFireSetDamageData(ent)
		if ent.IsPlayer() then
			ent.vFireDamageData = {dmgMul = 5, dmgType = DMG_BURN}
		elseif ent:IsNPC() then
			ent.vFireDamageData = {dmgMul = 5, dmgType = DMG_DIRECT}
		elseif string.StartWith(ent:GetClass(), "func") then
			ent.vFireDamageData = {dmgMul = vFireMatToDamageMultiplier(ent:GetMaterialType()), dmgType = DMG_BURN, inflict = true}
		elseif ent:IsVehicle() then
			if vFireEnableDamageInVehicles then
				ent.vFireDamageData = {dmgMul = 5, dmgType = DMG_BURN, inflict = true}
			else
				ent.vFireDamageData = {dmgMul = 5, dmgType = DMG_CRUSH, inflict = true}
			end
		else
			ent.vFireDamageData = {dmgMul = vFireMatToDamageMultiplier(ent:GetMaterialType()), dmgType = DMG_DIRECT, inflict = true}
		end
	end


	--[[-------------------------------------------------------------------------

	
	Main fuel taking function


	---------------------------------------------------------------------------]]
	function vFireTakeFuel(ent, fuelTake)

		-- Return no fuel if our entity isn't valid or is the world
		if !ent:IsValid() then return 0 end

		-- Return our cache if we have it
		if ent.vFireFuelAmount != nil and ent.vFireFuelRate != nil then
			local take = math.Min(fuelTake * ent.vFireFuelRate, ent.vFireFuelAmount)
			ent.vFireFuelAmount = ent.vFireFuelAmount - take
			return take
		end
		


		-- We don't have a fuel factor cached, initialize it
		ent.vFireFuelAmount = 0
		ent.vFireFuelRate = 0

		if vFireIsCharacter(ent) then

			if ent:IsPlayer() then
				ent.vFireFuelAmount = math.huge
			else
				ent.vFireFuelAmount = 50
			end
			ent.vFireFuelRate = 1.5

		elseif ent:IsVehicle() then

			ent.vFireFuelAmount = 1650
			ent.vFireFuelRate = 1

		elseif ent:GetClass() == "vfire_cluster" then

			
			local parent = ent.parent

			local feedMul -- Main purpose is to avoid feed cycles when clusters transition from entities that lost their fuel
			if parent:IsWorld() or !IsValid(parent) then
				feedMul = 1 -- We're probably the world, act normally
			else
				-- We're an entity, don't add any fuel if said entity is out of fuel
				feedMul = vFireTakeFuel(parent, 1)
			end

			-- Find out what feed we should be giving to the cluster
			local matFeed = vFireMatToFeed(ent.matType)
			
			-- Randomize the matFeed, multiply by our feed multiplier to avoid endless fuels, and add our cluster feed ConVar
			ent.vFireFuelAmount = matFeed * math.Rand(0.5, 1) * feedMul + vFireClusterFeed

			-- What is the fuel rate of this cluster?
			local fuelRate
			if IsValid(parent) then
				local phys = parent:GetPhysicsObject()
				if IsValid(phys) then
					-- We have access to a material string, use it to be more specific
					fuelRate = vFireMatToFuelRate(phys:GetMaterial())
				end
			end
			-- We couldn't find a material string, use the material type
			if !fuelRate then fuelRate = vFireMatToFuelRate(ent.matType) end

			ent.vFireFuelRate = fuelRate


		else


			local phys = ent:GetPhysicsObject()
			if IsValid(phys) then
				local mat = phys:GetMaterial()

				local volume = phys:GetVolume()
				if !isnumber(volume) then volume = 0 end

				local matGive = matsFuelAmount[mat] or 0
				local give = matGive * volume^0.5 / 5

				local fuelRate = vFireMatToFuelRate(mat)

				if give then
					ent.vFireFuelAmount = give
					ent.vFireFuelRate = fuelRate
				end
			end


		end

		-- We're done with initialization, don't forget to return a value
		local take = math.Min(fuelTake * ent.vFireFuelRate, ent.vFireFuelAmount)
		ent.vFireFuelAmount = ent.vFireFuelAmount - take
		return take

	end

end



































if CLIENT then

	--[[-------------------------------------------------------------------------
	LOD functionalities
	---------------------------------------------------------------------------]]

	-- The higher these values are, the closer fires will LODify
	vFireLODMaxDetailThreshold = 120 -- LOD level 2
	vFireLODMedDetailThreshold = 3 -- LOD level 1

	--[[-------------------------------------------------------------------------
	Returns:
		false for max detail
		2 for medium detail
		1 for minimum detail
	---------------------------------------------------------------------------]]
	function vFireGetLOD(data)

		-- Allow inputting both a position vector or an entity
		local pos
		if isvector(data) then
			pos = data
		else
			pos = data:GetPos()
		end

		-- Are we forcing our LOD settings via ConVars?
		if vFireLODs == 0 then
			-- All LODs are disabled
			return false
		elseif vFireLODs == 2 then
			-- All LODs are forced
			return 1
		end

		-- Proceed as normal
		local dist = GetViewEntity():GetPos():DistToSqr(pos)
		local fov = LocalPlayer():GetFOV()

		-- The higher LODVal the more detail we should see
		local LODVal = 1000000000 / (dist * fov)

		local LOD = false
		if LODVal < vFireLODMaxDetailThreshold then
			if LODVal < vFireLODMedDetailThreshold then
				LOD = 1
			else
				LOD = 2
			end
		end

		return LOD
	end






	--[[-------------------------------------------------------------------------
	Particle systems control point manipulation
	---------------------------------------------------------------------------]]
	vFirePullForceControlPointIndex = 2

	function vFirePullParticlesToPos(particles, pos)
		if IsValid(particles) then
			particles:SetControlPoint(vFirePullForceControlPointIndex, pos)
		end
	end
end






--[[-------------------------------------------------------------------------
Console notifications
---------------------------------------------------------------------------]]

function vFireMessage(string)
	if SERVER then
		MsgC(Color(250,115,35),"[vFire] ",Color(255,255,255), string, "\n")
	else
		MsgC(Color(250,175,75),"[vFire] ",Color(255,255,255), string, "\n")
	end
end

-- Fire performs best with multicore rendering, let clients know of this in case they have it disabled
if CLIENT then
	if GetConVar("gmod_mcore_test"):GetInt() == 0 then
		vFireMessage("vFire performs best with gmod_mcore_test set to 1, enable it and restart your game for changes to take effect.")
	end
end











--[[-------------------------------------------------------------------------
Content Loading
---------------------------------------------------------------------------]]

if SERVER then
	resource.AddWorkshop("1525218777")
end

game.AddParticles("particles/vFire_Base_Tiny.pcf")
game.AddParticles("particles/vFire_Base_Small.pcf")
game.AddParticles("particles/vFire_Base_Medium.pcf")
game.AddParticles("particles/vFire_Base_Big.pcf")
game.AddParticles("particles/vFire_Base_Huge.pcf")
game.AddParticles("particles/vFire_Base_Gigantic.pcf")
game.AddParticles("particles/vFire_Base_Inferno.pcf")

game.AddParticles("particles/vFire_Base_Tiny_LOD.pcf")
game.AddParticles("particles/vFire_Base_Small_LOD.pcf")
game.AddParticles("particles/vFire_Base_Medium_LOD.pcf")
game.AddParticles("particles/vFire_Base_Big_LOD.pcf")
game.AddParticles("particles/vFire_Base_Huge_LOD.pcf")
game.AddParticles("particles/vFire_Base_Gigantic_LOD.pcf")
game.AddParticles("particles/vFire_Base_Inferno_LOD.pcf")

game.AddParticles("particles/vFire_Flames_Tiny.pcf")
game.AddParticles("particles/vFire_Flames_Small.pcf")
game.AddParticles("particles/vFire_Flames_Medium.pcf")
game.AddParticles("particles/vFire_Flames_Big.pcf")
game.AddParticles("particles/vFire_Flames_Huge.pcf")
game.AddParticles("particles/vFire_Flames_Gigantic.pcf")
game.AddParticles("particles/vFire_Flames_Inferno.pcf")

game.AddParticles("particles/vFire_Flames_Tiny_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Small_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Medium_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Big_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Huge_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Gigantic_LOD.pcf")
game.AddParticles("particles/vFire_Flames_Inferno_LOD.pcf")


game.AddParticles("particles/vFire_Burst_Infant.pcf")
game.AddParticles("particles/vFire_Burst_Lines.pcf")
game.AddParticles("particles/vFire_Burst_Main.pcf")
game.AddParticles("particles/vFire_Burst_Main_Big.pcf")
game.AddParticles("particles/vFire_Burst_Plume.pcf")
game.AddParticles("particles/vFire_Burst_Trail.pcf")
game.AddParticles("particles/vFire_Burst_Trail_Plume.pcf")


PrecacheParticleSystem("vFire_Base_Tiny")
PrecacheParticleSystem("vFire_Base_Small")
PrecacheParticleSystem("vFire_Base_Medium")
PrecacheParticleSystem("vFire_Base_Big")
PrecacheParticleSystem("vFire_Base_Huge")
PrecacheParticleSystem("vFire_Base_Gigantic")
PrecacheParticleSystem("vFire_Base_Inferno")

PrecacheParticleSystem("vFire_Base_Tiny_LOD")
PrecacheParticleSystem("vFire_Base_Small_LOD")
PrecacheParticleSystem("vFire_Base_Medium_LOD")
PrecacheParticleSystem("vFire_Base_Big_LOD")
PrecacheParticleSystem("vFire_Base_Huge_LOD")
PrecacheParticleSystem("vFire_Base_Gigantic_LOD")
PrecacheParticleSystem("vFire_Base_Inferno_LOD")

PrecacheParticleSystem("vFire_Flames_Tiny")
PrecacheParticleSystem("vFire_Flames_Small")
PrecacheParticleSystem("vFire_Flames_Medium")
PrecacheParticleSystem("vFire_Flames_Big")
PrecacheParticleSystem("vFire_Flames_Huge")
PrecacheParticleSystem("vFire_Flames_Gigantic")
PrecacheParticleSystem("vFire_Flames_Inferno")

PrecacheParticleSystem("vFire_Flames_Tiny_LOD")
PrecacheParticleSystem("vFire_Flames_Small_LOD")
PrecacheParticleSystem("vFire_Flames_Medium_LOD")
PrecacheParticleSystem("vFire_Flames_Big_LOD")
PrecacheParticleSystem("vFire_Flames_Huge_LOD")
PrecacheParticleSystem("vFire_Flames_Gigantic_LOD")
PrecacheParticleSystem("vFire_Flames_Inferno_LOD")


PrecacheParticleSystem("vFire_Burst_Infant")
PrecacheParticleSystem("vFire_Burst_Lines")
PrecacheParticleSystem("vFire_Burst_Main")
PrecacheParticleSystem("vFire_Burst_Main_Big")
PrecacheParticleSystem("vFire_Burst_Plume")
PrecacheParticleSystem("vFire_Burst_Trail")
PrecacheParticleSystem("vFire_Burst_Trail_Plume")



--[[-------------------------------------------------------------------------
Loop sounds
---------------------------------------------------------------------------]]
list.Add("vFireLoopSounds", "ambient/fire/firebig.wav")
list.Add("vFireLoopSounds", "ambient/fire/fire_big_loop1.wav")
list.Add("vFireLoopSounds", "ambient/fire/fire_med_loop1.wav")
list.Add("vFireLoopSounds", "ambient/fire/fire_small1.wav")
list.Add("vFireLoopSounds", "ambient/fire/fire_small_loop2.wav")


--[[-------------------------------------------------------------------------
Decal loading
---------------------------------------------------------------------------]]

list.Add("VScorches_Tiny", "Decals/vFireScorch1_Tiny")
list.Add("VScorches_Tiny", "Decals/vFireScorch2_Tiny")
list.Add("VScorches_Tiny", "Decals/vFireScorch3_Tiny")
list.Add("VScorches_Tiny", "Decals/vFireScorch4_Tiny")
list.Add("VScorches_Tiny", "Decals/vFireScorch5_Tiny")
game.AddDecal("VScorch_Tiny", list.Get("VScorches_Tiny"))


list.Add("VScorches_Small", "Decals/vFireScorch1_Small")
list.Add("VScorches_Small", "Decals/vFireScorch2_Small")
list.Add("VScorches_Small", "Decals/vFireScorch3_Small")
list.Add("VScorches_Small", "Decals/vFireScorch4_Small")
list.Add("VScorches_Small", "Decals/vFireScorch5_Small")
game.AddDecal("VScorch_Small", list.Get("VScorches_Small"))


list.Add("VScorches_Medium", "Decals/vFireScorch1_Medium")
list.Add("VScorches_Medium", "Decals/vFireScorch2_Medium")
list.Add("VScorches_Medium", "Decals/vFireScorch3_Medium")
list.Add("VScorches_Medium", "Decals/vFireScorch4_Medium")
list.Add("VScorches_Medium", "Decals/vFireScorch5_Medium")
game.AddDecal("VScorch_Medium", list.Get("VScorches_Medium"))


list.Add("VScorches_Big", "Decals/vFireScorch1_Big")
list.Add("VScorches_Big", "Decals/vFireScorch2_Big")
list.Add("VScorches_Big", "Decals/vFireScorch3_Big")
list.Add("VScorches_Big", "Decals/vFireScorch4_Big")
list.Add("VScorches_Big", "Decals/vFireScorch5_Big")
game.AddDecal("VScorch_Big", list.Get("VScorches_Big"))


list.Add("VScorches_Huge", "Decals/vFireScorch1_Huge")
list.Add("VScorches_Huge", "Decals/vFireScorch2_Huge")
list.Add("VScorches_Huge", "Decals/vFireScorch3_Huge")
list.Add("VScorches_Huge", "Decals/vFireScorch4_Huge")
list.Add("VScorches_Huge", "Decals/vFireScorch5_Huge")
game.AddDecal("VScorch_Huge", list.Get("VScorches_Huge"))


list.Add("VScorches_Gigantic", "Decals/vFireScorch1_Gigantic")
list.Add("VScorches_Gigantic", "Decals/vFireScorch2_Gigantic")
list.Add("VScorches_Gigantic", "Decals/vFireScorch3_Gigantic")
list.Add("VScorches_Gigantic", "Decals/vFireScorch4_Gigantic")
list.Add("VScorches_Gigantic", "Decals/vFireScorch5_Gigantic")
game.AddDecal("VScorch_Gigantic", list.Get("VScorches_Gigantic"))


list.Add("VScorches_Inferno", "Decals/vFireScorch1_Inferno")
list.Add("VScorches_Inferno", "Decals/vFireScorch2_Inferno")
list.Add("VScorches_Inferno", "Decals/vFireScorch3_Inferno")
list.Add("VScorches_Inferno", "Decals/vFireScorch4_Inferno")
list.Add("VScorches_Inferno", "Decals/vFireScorch5_Inferno")
game.AddDecal("VScorch_Inferno", list.Get("VScorches_Inferno"))


-- Edit our decal materials through Lua because we have a lot of VMTs and I'm lazy
if CLIENT then
	hook.Add("InitPostEntity", "vFireEditDecals", function()
		for s = 1, vFireMaxState do
			local sizeStr = vFireStateToSize(s)
			for i = 1, 5 do
				local matName = "Decals/vFireScorch"..i.."_"..sizeStr
				local mat = Material(matName)
				-- Change our decal size to reflect the size of our fire
				mat:SetFloat("$decalscale", s * s * 0.04)

				-- -- Create a model material as well...

				-- -- Create the keyVal table
				-- local keyVals = mat:GetKeyValues()
				-- for k, v in pairs(keyVals) do
				-- 	if type(v) == "ITexture" then
				-- 		keyVals[k] = v:GetName()
				-- 	end
				-- 	if k == "$flags" or k == "$flags2" or k == "$flags_defined" or k == "$flags_defined2" then keyVals[k] = nil end
				-- end

				-- -- Create the material
				-- local modelMatName = matName.."_model"
				-- local modelMat = CreateMaterial(modelMatName, "VertexLitGeneric", keyVals)

				-- -- Form the link
				-- mat:SetTexture("$modelmaterial", modelMatName)
				
				-- Finalize the edit
				mat:Recompute()
				-- modelMat:Recompute()
			end
		end
	end)
end


list.Add("vFireSmoke", "particle/smokesprites_0001")
list.Add("vFireSmoke", "particle/smokesprites_0002")
list.Add("vFireSmoke", "particle/smokesprites_0003")
list.Add("vFireSmoke", "particle/smokesprites_0004")
list.Add("vFireSmoke", "particle/smokesprites_0005")
list.Add("vFireSmoke", "particle/smokesprites_0006")
list.Add("vFireSmoke", "particle/smokesprites_0007")
list.Add("vFireSmoke", "particle/smokesprites_0008")
list.Add("vFireSmoke", "particle/smokesprites_0009")
list.Add("vFireSmoke", "particle/smokesprites_0010")
list.Add("vFireSmoke", "particle/smokesprites_0011")
list.Add("vFireSmoke", "particle/smokesprites_0012")
list.Add("vFireSmoke", "particle/smokesprites_0013")
list.Add("vFireSmoke", "particle/smokesprites_0014")
list.Add("vFireSmoke", "particle/smokesprites_0015")
list.Add("vFireSmoke", "particle/smokesprites_0016")
list.Add("vFireSmoke", "particle/particle_smokegrenade1")
list.Add("vFireSmoke", "particle/particle_smokegrenade")

list.Add("vFireDebris", "effects/fleck_cement1")
list.Add("vFireDebris", "effects/fleck_cement2")
list.Add("vFireDebris", "effects/fleck_tile1")
list.Add("vFireDebris", "effects/fleck_tile2")

list.Add("vFireExplosionSounds", "weapons/explode3.wav")
list.Add("vFireExplosionSounds", "weapons/explode4.wav")
list.Add("vFireExplosionSounds", "weapons/explode5.wav")

list.Add("vFireDirt", "particle/particle_debris_01")
list.Add("vFireDirt", "particle/particle_debris_02")




--[[-------------------------------------------------------------------------
Create a refract material -- Unused for performance reasons
---------------------------------------------------------------------------]]
-- if CLIENT then

-- 	local newName = "vfire_refract_mat"
-- 	vFireRefractMatName = "!"..newName

-- 	local waterMat = Material("effects/water_warp01")
-- 	local keyVals = table.Copy(waterMat:GetKeyValues())
-- 	for k, v in pairs(keyVals) do
-- 		if type(v) == "ITexture" then
-- 			keyVals[k] = v:GetName()
-- 		end
-- 		if k == "$flags" or k == "$flags2" or k == "$flags_defined" or k == "$flags_defined2" then keyVals[k] = nil end
-- 	end
-- 	vFireRefractMat = CreateMaterial(newName, waterMat:GetShader(), {})
	
-- 	-- Edit the material
-- 	vFireRefractMat:SetFloat("$bluramount", 0)
-- 	vFireRefractMat:SetFloat("$refractamount", 0.025)

-- 	vFireRefractMat:Recompute()

-- end















--[[-------------------------------------------------------------------------


Specifics & External Support


---------------------------------------------------------------------------]]


	--[[-------------------------------------------------------------------------
	Make it easy for other addons to check if we're installed
	---------------------------------------------------------------------------]]
	vFireInstalled = true
	vFireVersion = 1


	--[[-------------------------------------------------------------------------
	Provide lower light brightness in HL2 maps
	---------------------------------------------------------------------------]]--
	if CLIENT then
		local map = game.GetMap()
		local isHL2Map = string.StartWith(map, "d1_") or string.StartWith(map, "d2_") or string.StartWith(map, "d3_")
		if isHL2Map then
			vFireLightMul = vFireLightMul * 0.165
		end
	end


	--[[-------------------------------------------------------------------------
	Soft extinguishing support for 'Fire Extinguisher' https://steamcommunity.com/sharedfiles/filedetails/?id=104607228
	---------------------------------------------------------------------------]]
	if SERVER then
		hook.Add("ExtinguisherDoExtinguish", "vFireSoftExtinguishFires", function(prop)
			if vFireIsVFireEnt(prop) then
				if prop:GetClass() == "vfire" then
					prop:SoftExtinguish(2)
					prop:Prioritize(2)
				end
				return true
			end
		end)
	end

	--[[-------------------------------------------------------------------------
	ULX Support
	---------------------------------------------------------------------------]]
	if SERVER or CLIENT then
		hook.Add("InitPostEntity", "vFireULXSupport", function()

			local ulxInstalled = istable(ulx)
			if !ulxInstalled then return end

			local CATEGORY = "vFire"

			
			--[[-------------------------------------------------------------------------
			Remove all fires the player is looking at
			---------------------------------------------------------------------------]]
			function ulx.vextinguish(ply)
				
				local lookedAt = ents.FindInCone(ply:EyePos(), ply:EyeAngles():Forward(), 30000, 0.9)
				local removeCount = 0
				for k, v in pairs(lookedAt) do
					local class = v:GetClass()
					if class == "vfire" or class == "vfire_ball" then
						v:Remove()
						removeCount = removeCount + 1
					end
				end

				ulx.fancyLogAdmin(ply, "#A extinguished "..removeCount.." fires.")
			end

			local vextinguish = ulx.command(CATEGORY, "ulx vextinguish", ulx.vextinguish, "!vextinguish")
			vextinguish:defaultAccess(ULib.ACCESS_ADMIN)
			vextinguish:help("Extinguish fires you're looking at.")

			
			--[[-------------------------------------------------------------------------
			Remove all fires
			---------------------------------------------------------------------------]]
			function ulx.vextinguishall(ply)
				local removeCount = 0
				for k, v in pairs(ents.FindByClass("vfire")) do
					v:Remove()
					removeCount = removeCount + 1
				end

				ulx.fancyLogAdmin(ply, "#A extinguished all "..removeCount.." fires.")
			end

			local vextinguishall = ulx.command(CATEGORY, "ulx vextinguishall", ulx.vextinguishall, "!vextinguishall")
			vextinguishall:defaultAccess(ULib.ACCESS_ADMIN)
			vextinguishall:help("Extinguish all fires.")


			--[[-------------------------------------------------------------------------
			Place fires
			---------------------------------------------------------------------------]]
			function ulx.vstartfire(ply, size)
				local tr = ply:GetEyeTrace()
				local life = size
				local feedCarry = size
				local pos = tr.HitPos - tr.Normal * 250
				local vel = tr.Normal * 1000
				local owner = ply
				CreateVFireBall(life, feedCarry, pos, vel, owner)

				ulx.fancyLogAdmin(ply, "#A started a fire.")
			end

			local vstartfire = ulx.command(CATEGORY, "ulx vstartfire", ulx.vstartfire, "!vstartfire")
			vstartfire:addParam{ type=ULib.cmds.NumArg, min=1, default=30, hint="size", ULib.cmds.optional, ULib.cmds.round }
			vstartfire:defaultAccess(ULib.ACCESS_ADMIN)
			vstartfire:help("Place a fire wherever you're looking at with a given size.")

		end)
	end

	--[[-------------------------------------------------------------------------
	StormFox "Support"
	---------------------------------------------------------------------------]]
	if SERVER then
		hook.Add("vFire - StormFox Handeshake", "vFire - StormFox Handeshake", function()
			vFireMessage("The same thing we do every night StormFox. Try to take over the world! >:D")
		end)
	end
--addons/fprofiler/lua/fprofiler/ui/model.lua:
--[[-------------------------------------------------------------------------
The model describes the data that the drives the UI
Loosely based on the Elm architecture
---------------------------------------------------------------------------]]

local model =
	{
		realm = "client", -- "client" or "server"
		serverAccess = false, -- Whether the player has access to profile the server
		frameVisible = false, -- Whether the frame is visible

		client = {
			status = "Stopped", -- Started or Stopped
			shouldReset = true, -- Whether profiling should start anew
			recordTime = 0, -- Total time spent on the last full profiling session
			sessionStart = nil, -- When the last profiling session was started
			sessionStartSysTime = nil, -- When the last profiling session was started, measured in SysTime
			bottlenecks = {}, -- The list of bottleneck functions
			topLagSpikes = {}, -- Top of lagging functions
			currentSelected = nil, -- Currently selected function

			focusObj = nil, -- The current function being focussed upon in profiling
			focusStr = "", -- The current function name being entered

			toConsole = nil, -- Any functions that should be printed to console

			sourceText = "", -- The text of the source function (if available)
		},

		server = {
			status = "Stopped", -- Started or Stopped
			shouldReset = true, -- Whether profiling should start anew
			bottlenecks = {}, -- The list of bottleneck functions
			recordTime = 0, -- Total time spent on the last full profiling session
			sessionStart = nil, -- When the last profiling session was started
			topLagSpikes = {}, -- Top of lagging functions
			currentSelected = nil, -- Currently selected function

			focusObj = nil, -- The current function being focussed upon in profiling
			focusStr = "", -- The current function name

			toConsole = nil, -- Any functions that should be printed to console

			sourceText = "", -- The text of the source function (if available)
			fromServer = false, -- Whether a change of the model came from the server.
		},
	}


local updaters = {}


--[[-------------------------------------------------------------------------
Update the model.
Automatically calls the registered update hook functions

e.g. updating the realm would be:
FProfiler.UI.updateModel("realm", "server")
---------------------------------------------------------------------------]]
function FProfiler.UI.updateModel(path, value)
	path = istable(path) and path or {path}

	local updTbl = updaters
	local mdlTbl = model
	local key = path[#path]

	for i = 1, #path - 1 do
		mdlTbl = mdlTbl[path[i]]
		updTbl = updTbl and updTbl[path[i]]
	end

	local oldValue = mdlTbl[key]
	mdlTbl[key] = value

	for _, updFunc in ipairs(updTbl and updTbl[key] or {}) do
		updFunc(value, oldValue)
	end
end

--[[-------------------------------------------------------------------------
Update the model of the current realm
---------------------------------------------------------------------------]]
function FProfiler.UI.updateCurrentRealm(path, value)
	path = istable(path) and path or {path}

	table.insert(path, 1, model.realm)

	FProfiler.UI.updateModel(path, value)
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model
---------------------------------------------------------------------------]]
function FProfiler.UI.getModelValue(path)
	path = istable(path) and path or {path}

	local mdlTbl = model
	local key = path[#path]

	for i = 1, #path - 1 do
		mdlTbl = mdlTbl[path[i]]
	end

	return mdlTbl[key]
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model regardless of realm
---------------------------------------------------------------------------]]
function FProfiler.UI.getCurrentRealmValue(path)
	path = istable(path) and path or {path}

	table.insert(path, 1, model.realm)

	return FProfiler.UI.getModelValue(path)
end

--[[-------------------------------------------------------------------------
Registers a hook that gets triggered when a certain part of the model is updated
e.g. FProfiler.UI.onModelUpdate("realm", print) prints when the realm is changed
---------------------------------------------------------------------------]]
function FProfiler.UI.onModelUpdate(path, func)
	path = istable(path) and path or {path}

	local updTbl = updaters
	local mdlTbl = model
	local key = path[#path]

	for i = 1, #path - 1 do
		mdlTbl = mdlTbl[path[i]]
		updTbl[path[i]] = updTbl[path[i]] or {}
		updTbl = updTbl[path[i]]
	end

	updTbl[key] = updTbl[key] or {}

	table.insert(updTbl[key], func)

	-- Call update with the initial value
	if mdlTbl[key] ~= nil then
		func(mdlTbl[key], mdlTbl[key])
	end
end

--[[-------------------------------------------------------------------------
Registers a hook to both realms
---------------------------------------------------------------------------]]
function FProfiler.UI.onCurrentRealmUpdate(path, func)
	path = istable(path) and path or {path}

	table.insert(path, 1, "client")
	FProfiler.UI.onModelUpdate(path, function(...)
		if FProfiler.UI.getModelValue("realm") == "server" then return end

		func(...)
	end)

	path[1] = "server"
	FProfiler.UI.onModelUpdate(path, function(...)
		if FProfiler.UI.getModelValue("realm") == "client" then return end

		func(...)
	end)
end

--[[-------------------------------------------------------------------------
When the realm is changed, all update functions of the new realm are to be called
---------------------------------------------------------------------------]]
FProfiler.UI.onModelUpdate("realm", function(new, old)
	if not updaters[new] then return end

	for k, funcTbl in pairs(updaters[new]) do
		for _, func in ipairs(funcTbl) do
			func(model[new][k], model[new][k])
		end
	end
end)


--lua/autorun/geonosianer.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end



AddPlayerModel( "Geonosian Drone1", 		         "models/swrp/swrp/geonosian_01.mdl" )
AddPlayerModel( "Geonosian Drone2", 		         "models/swrp/swrp/geonosian_02.mdl" )


--addons/gm_express/lua/gm_express/sh_init.lua:
AddCSLuaFile()

require( "pon" )
if SERVER then
    util.AddNetworkString( "express" )
    util.AddNetworkString( "express_proof" )
    util.AddNetworkString( "express_receivers_made" )
end

express = {}
express._receivers = {}
express._protocol = "https"
express._awaitingProof = {}
express._preDlReceivers = {}
express._maxDataSize = 24 * 1024 * 1024
express._jsonHeaders = { ["Content-Type"] = "application/json" }
express._bytesHeaders = { ["Accept"] = "application/octet-stream" }


-- Removes a receiver --
function express.ClearReceiver( message )
    message = string.lower( message )
    express._receivers[message] = nil
end


-- Registers a PreDownload receiver --
function express.ReceivePreDl( message, preDl )
    message = string.lower( message )
    express._preDlReceivers[message] = preDl
end


-- Retrieves and parses the data for given ID --
function express:Get( id, cb, _attempts )
    _attempts = _attempts or 0
    local url = self:makeAccessURL( "read", id )

    local success = function( code, body )
        if code == 404 then
            assert( _attempts <= 35, "express:Get() failed to retrieve data after 35 attempts: " .. id )
            timer.Simple( 0.125 * _attempts, function()
                self:Get( id, cb, _attempts + 1 )
            end )
            return
        end

        express._checkResponseCode( code )
        if _attempts > 0 then
            print( "express:Get() succeeded after " .. _attempts .. " attempts: " .. id )
        end

        if string.StartWith( body, "<enc>" ) then
            body = util.Decompress( string.sub( body, 6 ) )
            if ( not body ) or #body == 0 then
                error( "Express: Failed to decompress data for ID '" .. id .. "'." )
            end
        end

        local hash = util.SHA1( body )
        local decodedData = pon.decode( body )
        cb( decodedData, hash )
    end

    HTTP( {
        method = "GET",
        url = url,
        success = success,
        failed = error,
        headers = self._bytesHeaders,
        timeout = self:_getTimeout()
    } )
end


-- Asks the API for this ID's data's size --
function express:GetSize( id, cb )
    local url = self:makeAccessURL( "size", id )

    local success = function( code, body )
        express._checkResponseCode( code )

        local sizeHolder = util.JSONToTable( body )
        assert( sizeHolder, "Invalid JSON" )

        local size = sizeHolder.size
        if not size then
            print( "Express: Failed to get size for ID '" .. id .. "'.", code )
            print( body )
        end
        assert( size, "No size data" )

        cb( tonumber( size ) )
    end

    HTTP( {
        method = "GET",
        url = url,
        success = success,
        failed = error,
        headers = self._jsonHeaders,
        timeout = self:_getTimeout()
    } )
end


-- Given prepared data, sends it to the API --
function express:Put( data, cb )
    local success = function( code, body )
        express._checkResponseCode( code )

        local response = util.JSONToTable( body )
        assert( response, "Invalid JSON" )
        assert( response.id, "No ID returned" )

        cb( response.id )
    end

    HTTP( {
        method = "POST",
        url = self:makeAccessURL( "write" ),
        body = data,
        success = success,
        failed = error,
        headers = {
            ["Content-Length"] = #data,
            ["Accept"] = "application/json"
        },
        type = "application/octet-stream",
        timeout = CLIENT and 240 or 60
    } )
end


-- Runs the express receiver for the given message --
function express:Call( message, ply, data )
    local cb = self:_getReceiver( message )
    if not cb then return end

    if CLIENT then return cb( data ) end
    if SERVER then return cb( ply, data ) end
end


-- Runs the express pre-download receiver for the given message --
function express:CallPreDownload( message, ply, id, size, needsProof )
    local cb = self:_getPreDlReceiver( message )
    if not cb then return end

    if CLIENT then return cb( message, id, size, needsProof ) end
    if SERVER then return cb( message, ply, id, size, needsProof ) end
end


-- Handles a net message containing an ID to download from the API --
function express.OnMessage( _, ply )
    local message = net.ReadString()
    if not express:_getReceiver( message ) then
        error( "Express: Received a message that has no listener! (" .. message .. ")" )
    end

    local id = net.ReadString()
    local needsProof = net.ReadBool()

    local function makeRequest( size )
        if size then
            local check = express:CallPreDownload( message, ply, id, size, needsProof )
            if check == false then return end
        end

        express:_get( id, function( data, hash )
            express:Call( message, ply, data )

            if not needsProof then return end
            net.Start( "express_proof" )
            net.WriteString( hash )
            express.shSend( ply )
        end )
    end

    if express:_getPreDlReceiver( message ) then
        return express:_getSize( id, makeRequest )
    end

    makeRequest()
end


-- Handles a net message containing a proof of data download --
function express.OnProof( _, ply )
    -- Server prefixes the hash with the player's Steam ID
    local prefix = ply and ply:SteamID64() .. "-" or ""
    local hash = prefix .. net.ReadString()

    local cb = express._awaitingProof[hash]
    if not cb then return end

    cb( ply )
    express._awaitingProof[hash] = nil
end


net.Receive( "express", express.OnMessage )
net.Receive( "express_proof", express.OnProof )

include( "sh_helpers.lua" )

if SERVER then
    include( "sv_init.lua" )
    AddCSLuaFile( "cl_init.lua" )
else
    include( "cl_init.lua" )
end

hook.Add( "CreateTeams", "ExpressLoaded", function()
    hook.Run( "ExpressLoaded" )
end  )

--addons/gm_express/lua/includes/modules/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v
 - PhysObj - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = pon;

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		local entIndex = val == NULL and '#' or val:EntIndex();
		output[ #output + 1] = 'E'..entIndex..';';
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function( _, _, output )
		output[ #output + 1 ] = '?;';
	end

	setmetatable( encode, {
		__index = function( self, key )
			local val = rawget( self, key );
			if val then return val end
			ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
			return rawget( self, 'nil' );
		end
	});

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1;
		local segs = Explode( ',', vecStr, false );
		return index, Vector( segs[1], segs[2], segs[3] );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1;
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = sub( str, index, finish - 1 );
		index = finish + 1;
		return index, num == '#' and NULL or Entity( num );
	end
	-- PLAYER
	decode[ 'P' ] = decode[ 'E' ];
	-- NIL
	decode[ '?' ] = function( _, index )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[ sub( data, 1, 1 ) ]( decode, 2, data, {});
		return res;
	end
end

--lua/autorun/ig88.lua:
player_manager.AddValidModel( "IG-88", "models/player/ig88/ig88.mdl" );
list.Set( "PlayerOptionsModel", "IG-88", "models/player/ig88/ig88.mdl" );

--lua/autorun/init_improvedstacker.lua:
if ( SERVER ) then
	
	-- needed for custom vgui controls in the menu
	AddCSLuaFile( "vgui/stackercontrolpresets.lua" )
	AddCSLuaFile( "vgui/stackerdnumslider.lua" )
	AddCSLuaFile( "vgui/stackerpreseteditor.lua" )
	
	-- convenience modules
	AddCSLuaFile( "improvedstacker/improvedstacker.lua" )
	AddCSLuaFile( "improvedstacker/localify.lua" )
	
else

	-- needed for custom vgui controls in the menu
	include( "vgui/stackercontrolpresets.lua" )
	include( "vgui/stackerdnumslider.lua" )
	include( "vgui/stackerpreseteditor.lua" )

end
--lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--lua/autorun/isard_by_grady.lua:
list.Set( "Armand Isard", "models/player/armand_isard_grady/armand_isard_grady.mdl" )
player_manager.AddValidModel( "Armand Isard", "models/player/armand_isard_grady/armand_isard_grady.mdl" )

--lua/autorun/knightofren.lua:
player_manager.AddValidModel( "knightofren", "models/gonzo/knightofren/knightofren.mdl" ) 
list.Set( "PlayerOptionsModel",  "knightofren", "models/gonzo/knightofren/knightofren.mdl" )
--addons/lvs_starwars/lua/lvs_framework/autorun/sh_presets.lua:
local Unarmed = {
	Icon = Material("lvs/weapons/unarmed.png"),
	HeatRateUp = 0,
	HeatRateDown = 0,
	UseableByAI = false,
	Attack = function(ent)
	end,
	StartAttack = function(ent)
	end,
	FinishAttack = function(ent)
	end,
	OnSelect = function(ent)
	end,
	OnThink = function(ent, active)
	end,
	OnOverheat = function(ent) end,
}

LVS:AddWeaponPreset("UNARMED", Unarmed)

local Turbo = {
	Icon = Material("lvs/weapons/nos.png"),
	HeatRateUp = 0.1,
	HeatRateDown = 0.1,
	UseableByAI = false,
	Attack = function( ent )
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end,
	StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end,
	FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end,
	OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end,
	OnThink = function( ent, active )
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end,
	OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end,
}

LVS:AddWeaponPreset("TURBO", Turbo)
--addons/lvs_starwars/lua/lvs_framework/autorun/sh_starwars_keybinding.lua:

hook.Add( "LVS:Initialize", "[LVS] - Star Wars - Keys", function()
	local KEYS = {
		{
			name = "+THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Increase",
			default = "+forward",
			cmd = "lvs_starfighter_throttle_up"
		},
		{
			name = "-THRUST_SF",
			category = "LVS-Starfighter",
			name_menu = "Thrust Decrease",
			default = "+back",
			cmd = "lvs_starfighter_throttle_down"
		},
		{
			name = "+PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Up",
			default = "+speed",
			cmd = "lvs_starfighter_pitch_up"
		},
		{
			name = "-PITCH_SF",
			category = "LVS-Starfighter",
			name_menu = "Pitch Down",
			cmd = "lvs_starfighter_pitch_down"
		},
		{
			name = "-YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Left [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_left"
		},
		{
			name = "+YAW_SF",
			category = "LVS-Starfighter",
			name_menu = "Yaw Right [Roll in Direct Input]",
			cmd = "lvs_starfighter_yaw_right"
		},
		{
			name = "-ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Left [Yaw in Direct Input]",
			default = "+moveleft",
			cmd = "lvs_starfighter_roll_left"
		},
		{
			name = "+ROLL_SF",
			category = "LVS-Starfighter",
			name_menu = "Roll Right [Yaw in Direct Input]",
			default = "+moveright",
			cmd = "lvs_starfighter_roll_right"
		},
		{
			name = "+VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Up",
			cmd = "lvs_starfighter_vtol_up"
		},
		{
			name = "-VTOL_Z_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Down",
			cmd = "lvs_starfighter_vtol_dn"
		},
		{
			name = "-VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Right",
			cmd = "lvs_starfighter_vtol_right"
		},
		{
			name = "+VTOL_Y_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Left",
			cmd = "lvs_starfighter_vtol_left"
		},
		{
			name = "-VTOL_X_SF",
			category = "LVS-Starfighter",
			name_menu = "VTOL Reverse",
			default = "+back",
			cmd = "lvs_starfighter_vtol_reverse"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

if CLIENT then return end

resource.AddWorkshop("2919757295")
--lua/autorun/nm.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Neimoidian Viceroy",		"models/player/tiki/nm.mdl" )

--lua/autorun/particlecontrol_autorun.lua:
AddCSLuaFile()

ParticleListTable = {
	Games = {},
	Addons = {},
}

local doubleslash = "//"


local function AddToParticleListTable(filename,isaddon,icon)

	//Converts a list string, with one item per line, into a table, taking comments and empty strings into account. Returns nil if the table is empty.
	//The format of these tables is item1 = true, item2 = true, etc., not 1 = item1, 2 = item2, etc.; this is so we can use "if table["itemX"] then" to check if a value is inside of it.
	//
	//Instead of the arg being the string itself, the args are 1: the table containing the string, and 2: the key the string can be found at. 
	//This is so we can find continuations of the string, which'll be in the same table, but under separate keys.
	//
	local function ListStringToTable(listcontainer,listname)
		//Find the list string we're looking for inside the container, and explode it into its own table.
		local liststring = listcontainer[listname]
		if type(liststring) != "string" then MsgN("PARTICLE CONTROL ERROR: List string \"" .. listname .. "\" inside of \"" .. filename .. "\" doesn't seem to actually be a string! Check the file and make sure you've formatted everything correctly!") return end
		if #liststring == 4095 then MsgN("PARTICLE CONTROL ERROR: List string \"" .. listname .. "\" inside of \"" .. filename .. "\" is more than 4095 characters long - that's too long for the engine to read all of it! Split it up into multiple lists!") end
		local listtab = string.Explode("\n", liststring)

		//Also find any list strings that are continuations of our main list string, and explode them into the same table.
		for listname2, liststring2 in pairs (listcontainer) do
			if string.StartWith(listname2, listname .. "_cont") then
				if type(liststring) != "string" then MsgN("PARTICLE CONTROL ERROR: List string \"" .. listname2 .. "\" inside of \"" .. filename .. "\" doesn't seem to actually be a string! Check the file and make sure you've formatted everything correctly!") return end
				if #liststring2 == 4095 then MsgN("PARTICLE CONTROL ERROR: List string \"" .. listname2 .. "\" inside of \"" .. filename .. "\" is more than 4095 characters long - that's too long for the engine to read all of it! Split it up into multiple lists!") end
				table.Add(listtab, string.Explode("\n", liststring2) )
			end
		end

		//Finally, filter out any comments or blank spaces from the table.
		local listtabfiltered = {}
		for _, str in pairs (listtab) do
			//if there's a doubleslash in the string then remove it and everything after it
			local commentpos, _ = string.find(str, doubleslash)
			local resultstr = str
			if commentpos then
				resultstr = string.sub( str, 1, commentpos - 1 )
			end

			//trim any spaces from the string, and don't add it to the filtered table if it's just an empty string at this point
			resultstr = string.Trim(resultstr)
			if resultstr != "" then listtabfiltered[resultstr] = true end
		end
		if table.Count(listtabfiltered) > 0 then
			return listtabfiltered
		end
	end

	local filestr = file.Read(filename,"LUA")
	if !filestr then MsgN("PARTICLE CONTROL ERROR: Particle list file \"" .. filename .. "\" doesn't exist or isn't a readable file! Something went wrong!") return end
	local keyvalues = util.KeyValuesToTable( filestr, false, true )
	local resulttable = { Info = {}, Particles = {} }
	if !keyvalues or (table.Count(keyvalues) == 0) then MsgN("PARTICLE CONTROL ERROR: Particle list file \"" .. filename .. "\" isn't a valid keyvalue table and couldn't be read! Check the file and make sure you've formatted everything correctly!") return end
	if !keyvalues.Info then
		//On Mac/Linux systems, the keyvalues-to-table function messes up and returns the keyname "Info" as something else, like "inf", so it's possible that the info subtable is
		//still here, just under a different keyname. The info is the only thing in keyvalues that should be a table value, so we'll check for that:
		local foundinfo = false
		for k, v in pairs (keyvalues) do
			if type(v) == "table" then
				keyvalues.Info = v
				MsgN("(" .. filename .. ": Found Info table under keyname " .. tostring(k) .. ")")
				foundinfo = true
			end
		end
		//If there's no table value in keyvalues at all, then this is a probably a custom file where someone messed up the formatting.
		if !foundinfo then
			MsgN("PARTICLE CONTROL ERROR: Particle list file \"" .. filename .. "\" doesn't have an \"Info\" table that we can find! Check the file and make sure you've formatted everything correctly!")
			return
		end
	end
	if !keyvalues.Info.CategoryName then MsgN("PARTICLE CONTROL ERROR: Particle list file \"" .. filename .. "\"'s Info table doesn't have a \"CategoryName\" string that we can find! Check the file and make sure you've formatted everything correctly!") return end

	resulttable.Info.CategoryName = keyvalues.Info.CategoryName
	resulttable.Info.Icon = icon
	resulttable.Info.EffectOptions = {}
	if keyvalues.Info["EffectOptions"] then
		if keyvalues.Info.EffectOptions["Beams"] then
			resulttable.Info.EffectOptions["Beams"] = ListStringToTable(keyvalues.Info.EffectOptions, "Beams")
		end
		if keyvalues.Info.EffectOptions["Color1"] then
			resulttable.Info.EffectOptions["Color1"] = ListStringToTable(keyvalues.Info.EffectOptions, "Color1")
		end
		if keyvalues.Info.EffectOptions["Color255"] then
			resulttable.Info.EffectOptions["Color255"] = ListStringToTable(keyvalues.Info.EffectOptions, "Color255")
		end
		if keyvalues.Info.EffectOptions["Tracers"] then
			resulttable.Info.EffectOptions["Tracers"] = ListStringToTable(keyvalues.Info.EffectOptions, "Tracers")
		end
	end
	if keyvalues.Info["UtilEffects"] then
		resulttable.Info["UtilEffects"] = keyvalues.Info["UtilEffects"]
	end
	keyvalues.Info = nil


	for k, _ in pairs (keyvalues) do
		if !string.StartWith(k,doubleslash) and string.EndsWith(k, ".pcf") then   //ignore .pcf lists that start with a doubleslash; also ignore lists that don't end with .pcf since these are probably continuations
			local particlelist = ListStringToTable(keyvalues, k)
			if particlelist then
				game.AddParticles("particles/" .. k)
				resulttable.Particles[k] = particlelist
			end
		end
	end


	local subtablename = string.StripExtension( string.GetFileFromFilename(filename) )
	if isaddon then
		MsgN( "PARTICLE CONTROL: Added list for addon: " .. resulttable.Info.CategoryName )
		ParticleListTable.Addons[subtablename] = resulttable
	else
		MsgN( "PARTICLE CONTROL: Added list for game: " .. resulttable.Info.CategoryName )
		ParticleListTable.Games[subtablename] = resulttable
	end

end




//Source Engine / Garry's Mod
	AddToParticleListTable("particlelists/gmod.lua", false, "games/16/garrysmod.png")

//Team Fortress 2
if IsMounted("tf") then
	AddToParticleListTable("particlelists/tf2.lua", false, "games/16/tf.png") //TODO: currently causes a crash when loading updated pcfs, uncomment once fixed by devs
end

//Half-Life 2: Episode 1
if IsMounted("episodic") then
	AddToParticleListTable("particlelists/ep1.lua", false, "games/16/episodic.png")
end

//Half-Life 2: Episode 2
if IsMounted("ep2") then
	AddToParticleListTable("particlelists/ep2.lua", false, "games/16/ep2.png")
end

//Portal
if IsMounted("portal") then
	AddToParticleListTable("particlelists/portal.lua", false, "games/16/portal.png")
end

//Counter-Strike: Source
if IsMounted("cstrike") then
	AddToParticleListTable("particlelists/cstrike.lua", false, "games/16/cstrike.png")
end


//Find all list files in the particlelists/addons/ directory, and add them to their own section of the table
local alladdons, _ = file.Find( "lua/particlelists/addons/*.lua", "GAME" )
for _, filename in pairs (alladdons) do
	if !string.StartWith( filename, "_" ) then   //don't add files that start with an _, this is how we stop it from reading the example files
		AddToParticleListTable("particlelists/addons/" .. filename, true, "icon16/bricks.png")
	end
end




if CLIENT then

	//Favorites - this table is global because it's used by every Particle Browser panel on the client
	ParticleBrowserFavorites = {
		Effects = {},   //effects in the favorites list
		Children = {},  //all DTreeNode panels that are using this favorites list
	}

	local parctrlfavs_str = file.Read("particlecontrol_favorites.txt","DATA")
	if parctrlfavs_str then ParticleBrowserFavorites.Effects = util.JSONToTable(parctrlfavs_str) end


	function ParticleBrowserFavorites_UpdateEffect( effectdisplay, effectoptions )

		if effectoptions then
			//We're adding the effect
			ParticleBrowserFavorites.Effects[effectdisplay] = effectoptions
		else
			//We're removing the effect
			ParticleBrowserFavorites.Effects[effectdisplay] = nil
		end

		for _, panel in pairs (ParticleBrowserFavorites.Children) do
			if panel then
				ParticleBrowserFavorites_UpdateChildPanel( panel )
			end
		end

		file.Write( "particlecontrol_favorites.txt", util.TableToJSON(ParticleBrowserFavorites.Effects, true) )

	end


	function ParticleBrowserFavorites_UpdateChildPanel( panel )

		if !panel then return end

		if panel.FavoriteNodes then
			//Remove all of the nodes from the panel
			for k, node in pairs (panel.FavoriteNodes) do
				node:Remove()
				panel.FavoriteNodes[k] = nil
			end
		else
			panel.FavoriteNodes = {}
		end

		for effectdisplay, effectoptions in SortedPairs (ParticleBrowserFavorites.Effects) do
			local effect = effectoptions["InternalName"]

			panel.FavoriteNodes[effect] = panel:AddNode(effectdisplay)

			panel.FavoriteNodes[effect].EffectOptions = {}
			if effectoptions["Beam"] then 
				panel.FavoriteNodes[effect].EffectOptions["Beam"] = true 
			end
			if effectoptions["Colorable"] then 
				panel.FavoriteNodes[effect].EffectOptions["Colorable"] = true
			end
			if effectoptions["ColorOutOfOne"] then
				panel.FavoriteNodes[effect].EffectOptions["ColorOutOfOne"] = true
			end

			//Don't use the icons for features we're not using
			local beamicon = ( (panel.CommandInfo.mode_beam) and (panel.FavoriteNodes[effect].EffectOptions["Beam"] == true) )
			local coloricon = ( (panel.CommandInfo.color) and (panel.FavoriteNodes[effect].EffectOptions["Colorable"] == true) )
			//Set the effect icon:
			if beamicon and coloricon then
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire_line_rainbow.png")
			elseif beamicon then
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire_line.png")
			elseif coloricon then
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire_rainbow.png")
			else
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire.png")
			end

			panel.FavoriteNodes[effect].DoClick = function() 
				RunConsoleCommand( panel.CommandInfo.effectname, effect )

				if panel.CommandInfo.mode_beam then
					if panel.FavoriteNodes[effect].EffectOptions["Beam"] then
						RunConsoleCommand( panel.CommandInfo.mode_beam, "1" )
					else
						RunConsoleCommand( panel.CommandInfo.mode_beam, "0" )
					end
				end

				if panel.CommandInfo.color then
					if panel.FavoriteNodes[effect].EffectOptions["Colorable"] then
						RunConsoleCommand( panel.CommandInfo.color .. "_enabled", "1" )
					else
						RunConsoleCommand( panel.CommandInfo.color .. "_enabled", "0" )
					end

					if panel.FavoriteNodes[effect].EffectOptions["ColorOutOfOne"] then
						RunConsoleCommand( panel.CommandInfo.color .. "_outofone", "1" )
					else
						RunConsoleCommand( panel.CommandInfo.color .. "_outofone", "0" )
					end
				end
			end

			panel.FavoriteNodes[effect].DoRightClick = function()
				//We only need the remove option here, since it's already in the favorites list
				local menu = DermaMenu()

				local option = menu:AddOption( "Un-favorite \'\'" .. effectdisplay .. "\'\'", function()
					ParticleBrowserFavorites_UpdateEffect( effectdisplay )  //calling this function with no second arg tells it to remove this effect from the list
				end )
				option:SetImage("icon16/delete.png")

				menu:Open()
			end
		end

	end




	function AddParticleBrowser(panel,data)

		local self = {}

		//Data table contents:
		//{
		//name = "Effect" (name to show at the top of the panel)
		//commands =   (table of concommands that the panel uses)
		//	{
		//	effectname = "particlecontrol_effectname"
		//	mode_beam = "particlecontrol_mode_beam" (optional)
		//	color = "particlecontrol_color" (optional, assumes there are cvars derived from this name (X_enabled, X_r, X_g, X_b, X_outofone) )
		//	utileffect = "particlecontrol_utileffect" (optional, assumes there are cvars derived from this name (X_scale, X_magnitude, X_radius) )
		//
		//	enabled = "particlecontrol_enabled" (optional - toggles whether or not the panel is open using this cvar)
		//	}
		//}

		self.back = vgui.Create("DForm", panel)
		self.back:SetLabel(data.name)
		self.back.Paint = function()
			derma.SkinHook( "Paint", "CollapsibleCategory", self.back, self.back:GetWide(), self.back:GetTall() )
			surface.SetDrawColor( Color(0,0,0,70) )
    			surface.DrawRect( 0, 0, self.back:GetWide(), self.back:GetTall() )
		end
		self.back.Header:SetImage("icon16/fire.png")
		self.back.Header.DoClick = function() end
		panel:AddPanel(self.back)




		self.tree = vgui.Create("DTree", self.back)
		self.tree:SetHeight(400)
		self.back:AddItem(self.tree)
		self.tree:GetParent():DockPadding(5,5,5,0)

		local function PopulateEffectList(parent, effectstab, effectoptions)
			for k, v in SortedPairs (effectstab) do
				local effect = k
				local effectdisplay = k
				//if v is another string instead of just a filler "true" value, then that means k is the display name and v is the internal name
				if isstring(v) then
					effect = v
				end

				parent[effect] = parent:AddNode(effectdisplay)

				parent[effect].EffectOptions = {}
				if effectoptions["Beams"] and effectoptions["Beams"][effect] then 
					parent[effect].EffectOptions["Beam"] = true 
				end
				if effectoptions["Color1"] and effectoptions["Color1"][effect] then 
					parent[effect].EffectOptions["Colorable"] = true
					parent[effect].EffectOptions["ColorOutOfOne"] = true
				end
				if effectoptions["Color255"] and effectoptions["Color255"][effect] then
					parent[effect].EffectOptions["Colorable"] = true
					parent[effect].EffectOptions["ColorOutOfOne"] = false
				end

				//Don't use the icons for features we're not using
				local beamicon = ( (data.commands.mode_beam) and (parent[effect].EffectOptions["Beam"] == true) )
				local coloricon = ( (data.commands.color) and (parent[effect].EffectOptions["Colorable"] == true) )
				//Set the effect icon:
				if beamicon and coloricon then
					parent[effect].Icon:SetImage("icon16/fire_line_rainbow.png")
				elseif beamicon then
					parent[effect].Icon:SetImage("icon16/fire_line.png")
				elseif coloricon then
					parent[effect].Icon:SetImage("icon16/fire_rainbow.png")
				else
					parent[effect].Icon:SetImage("icon16/fire.png")
				end

				//Left Click: Select the effect by setting its concommands
				parent[effect].DoClick = function() 
					RunConsoleCommand( data.commands.effectname, effect )

					if data.commands.mode_beam then
						if parent[effect].EffectOptions["Beam"] then
							RunConsoleCommand( data.commands.mode_beam, "1" )
						else
							RunConsoleCommand( data.commands.mode_beam, "0" )
						end
					end

					if data.commands.color then
						if parent[effect].EffectOptions["Colorable"] then
							RunConsoleCommand( data.commands.color .. "_enabled", "1" )
						else
							RunConsoleCommand( data.commands.color .. "_enabled", "0" )
						end

						if parent[effect].EffectOptions["ColorOutOfOne"] then
							RunConsoleCommand( data.commands.color .. "_outofone", "1" )
						else
							RunConsoleCommand( data.commands.color .. "_outofone", "0" )
						end
					end
				end

				//Right Click: Display an option to add/remove the effect from favorites
				parent[effect].DoRightClick = function()
					local menu = DermaMenu()

					if !ParticleBrowserFavorites.Effects[effectdisplay] then
						local option = menu:AddOption( "Favorite \'\'" .. effectdisplay .. "\'\'", function()
							ParticleBrowserFavorites_UpdateEffect( effectdisplay, {
								["InternalName"] = effect,
								["Beam"] = tobool(parent[effect].EffectOptions["Beam"]),
								["Colorable"] = tobool(parent[effect].EffectOptions["Colorable"]),
								["ColorOutOfOne"] = tobool(parent[effect].EffectOptions["ColorOutOfOne"]),
							} )
						end )
						option:SetImage("icon16/add.png")
					else
						local option = menu:AddOption( "Un-favorite \'\'" .. effectdisplay .. "\'\'", function()
							ParticleBrowserFavorites_UpdateEffect( effectdisplay )  //calling this function with no second arg tells it to remove this effect from the list
						end )
						option:SetImage("icon16/delete.png")
					end

					menu:Open()
				end
			end
		end
		
		//Games
		self.tree.games = self.tree:AddNode("Games")
		self.tree.games.Icon:SetImage("icon16/folder_database.png")
		self.tree.games:SetExpanded(true)
		//
		for tabname, tab in SortedPairs (ParticleListTable.Games) do
			self.tree.games[tabname] = self.tree.games:AddNode(tab.Info.CategoryName)
			self.tree.games[tabname].Icon:SetImage(tab.Info.Icon)

			//Create the utilfx list
			if tab.Info.UtilEffects then
				self.tree.games[tabname].UtilEffects = self.tree.games[tabname]:AddNode("Scripted Effects")
				self.tree.games[tabname].UtilEffects.Icon:SetImage("icon16/page_gear.png")

				self.tree.games[tabname].UtilEffects.IsPopulated = false
				self.tree.games[tabname].UtilEffects.DoClick = function()
					if self.tree.games[tabname].UtilEffects.IsPopulated == true then return end

					PopulateEffectList(self.tree.games[tabname].UtilEffects, tab.Info.UtilEffects, tab.Info.EffectOptions)

					self.tree.games[tabname].UtilEffects.IsPopulated = true
					self.tree.games[tabname].UtilEffects:SetExpanded(true)
				end
			end

			//Create the .pcf lists
			for pcfname, particles in SortedPairs (tab.Particles) do
				local pcftabname = string.StripExtension(pcfname)  //just in case having a dot in the key name causes problems
				self.tree.games[tabname][pcftabname] = self.tree.games[tabname]:AddNode(pcfname)
				self.tree.games[tabname][pcftabname].Icon:SetImage("icon16/page.png")

				self.tree.games[tabname][pcftabname].IsPopulated = false
				self.tree.games[tabname][pcftabname].DoClick = function()
					if self.tree.games[tabname][pcftabname].IsPopulated == true then return end

					PopulateEffectList(self.tree.games[tabname][pcftabname], particles, tab.Info.EffectOptions)

					self.tree.games[tabname][pcftabname].IsPopulated = true
					self.tree.games[tabname][pcftabname]:SetExpanded(true)
				end
			end
		end

		//Addons
		self.tree.addons = self.tree:AddNode("Addons")
		self.tree.addons.Icon:SetImage("icon16/folder_database.png")
		self.tree.addons:SetExpanded(true)
		//
		for tabname, tab in SortedPairs (ParticleListTable.Addons) do
			self.tree.addons[tabname] = self.tree.addons:AddNode(tab.Info.CategoryName)
			self.tree.addons[tabname].Icon:SetImage(tab.Info.Icon)

			//Create the utilfx list
			if tab.Info.UtilEffects then
				self.tree.addons[tabname].UtilEffects = self.tree.addons[tabname]:AddNode("Scripted Effects")
				self.tree.addons[tabname].UtilEffects.Icon:SetImage("icon16/page_gear.png")

				self.tree.addons[tabname].UtilEffects.IsPopulated = false
				self.tree.addons[tabname].UtilEffects.DoClick = function()
					if self.tree.addons[tabname].UtilEffects.IsPopulated == true then return end

					PopulateEffectList(self.tree.addons[tabname].UtilEffects, tab.Info.UtilEffects, tab.Info.EffectOptions)

					self.tree.addons[tabname].UtilEffects.IsPopulated = true
					self.tree.addons[tabname].UtilEffects:SetExpanded(true)
				end
			end

			//Create the .pcf lists
			for pcfname, particles in SortedPairs (tab.Particles) do
				local pcftabname = string.StripExtension(pcfname)  //just in case having a dot in the key name causes problems
				self.tree.addons[tabname][pcftabname] = self.tree.addons[tabname]:AddNode(pcfname)
				self.tree.addons[tabname][pcftabname].Icon:SetImage("icon16/page.png")

				self.tree.addons[tabname][pcftabname].IsPopulated = false
				self.tree.addons[tabname][pcftabname].DoClick = function()
					if self.tree.addons[tabname][pcftabname].IsPopulated == true then return end

					PopulateEffectList(self.tree.addons[tabname][pcftabname], particles, tab.Info.EffectOptions)

					self.tree.addons[tabname][pcftabname].IsPopulated = true
					self.tree.addons[tabname][pcftabname]:SetExpanded(true)
				end
			end
		end

		//Favorites
		self.tree.favorites = self.tree:AddNode("Favorites")
		self.tree.favorites.Icon:SetImage("icon16/star.png")
		self.tree.favorites:SetExpanded(true)
		//
		table.insert( ParticleBrowserFavorites.Children, self.tree.favorites )   //Add it to the Favorites table's list of child panels and let it do the rest of the work
		self.tree.favorites.CommandInfo = data.commands				 //Store the console command info in the panel so the UpdateChildPanel function can access it
		ParticleBrowserFavorites_UpdateChildPanel( self.tree.favorites )




		self.effectnameentry = vgui.Create( "DTextEntry", self.back )
		self.effectnameentry:SetConVar( data.commands.effectname )
		self.back:AddItem(self.effectnameentry)
		self.effectnameentry:GetParent():DockPadding(5,5,5,10)




		if data.commands.mode_beam then
			self.beam = vgui.Create("DForm", self.back)
			self.beam.Paint = function()
				derma.SkinHook( "Paint", "CollapsibleCategory", self.beam, self.beam:GetWide(), self.beam:GetTall() )
				surface.SetDrawColor( Color(0,0,0,110) )
    				surface.DrawRect( 0, 0, self.beam:GetWide(), self.beam:GetTall() )
			end
			self.beam:Dock(TOP)
			self.back:AddItem(self.beam)
			self.beam:GetParent():DockPadding(5,0,5,0)

			//Modify the header and tweak things so it doesn't show up when the category is closed.
			self.beam.Header:SetText( "Beam" )
			self.beam.Header:SetImage("icon16/fire_line.png")
			self.beam.Header.DoClick = function() end
			self.beam.PerformLayout = function()
				local us = self.beam	//so when we copy this over to another dform we only have to change this one line
				local Padding = us:GetPadding() or 0
				if ( us.Contents ) then
					if ( us:GetExpanded() ) then
						us.Contents:InvalidateLayout( true )
						us.Contents:SetVisible( true )
					else
						us.Contents:SetVisible( false )
					end
				end
				if ( us:GetExpanded() ) then
					us:SizeToChildren( false, true )
				else
					us:SetTall(0)	//this is the only real change from the standard DForm:PerformLayout()
				end	
				-- Make sure the color of header text is set
				us.Header:ApplySchemeSettings()
				us.animSlide:Run()
				us:UpdateAltLines();
			end

			self.beam.text = vgui.Create("DLabel", self.beam)
			self.beam.text:SetColor( Color(60,60,60,255) )
			self.beam.text:SetText("This effect attaches to two points.")
			self.beam.text:SetWrap( true )
			self.beam.text:SetAutoStretchVertical( true )
			self.beam.text:Dock(TOP)
			self.beam.text:SizeToContents()
			self.beam:AddItem(self.beam.text)
			self.beam.text:GetParent():DockPadding( 15, 10, 15, 10 )
		end




		if data.commands.color then
			self.color = vgui.Create("DForm", self.back)
			self.color.Paint = function()
				derma.SkinHook( "Paint", "CollapsibleCategory", self.color, self.color:GetWide(), self.color:GetTall() )
				surface.SetDrawColor( Color(0,0,0,110) )
    				surface.DrawRect( 0, 0, self.color:GetWide(), self.color:GetTall() )
			end
			self.color:Dock(TOP)
			self.back:AddItem(self.color)
			self.color:GetParent():DockPadding(5,0,5,0)

			//Modify the header and tweak things so it doesn't show up when the category is closed.
			self.color.Header:SetText( "Colorable" )
			self.color.Header:SetImage("icon16/fire_rainbow.png")
			self.color.Header.DoClick = function() end
			self.color.PerformLayout = function()
				local us = self.color	//so when we copy this over to another dform we only have to change this one line
				local Padding = us:GetPadding() or 0
				if ( us.Contents ) then
					if ( us:GetExpanded() ) then
						us.Contents:InvalidateLayout( true )
						us.Contents:SetVisible( true )
					else
						us.Contents:SetVisible( false )
					end
				end
				if ( us:GetExpanded() ) then
					us:SizeToChildren( false, true )
				else
					us:SetTall(0)	//this is the only real change from the standard DForm:PerformLayout()
				end	
				-- Make sure the color of header text is set
				us.Header:ApplySchemeSettings()
				us.animSlide:Run()
				us:UpdateAltLines();
			end

			self.color.text = vgui.Create("DLabel", self.color)
			self.color.text:SetColor( Color(60,60,60,255) )
			self.color.text:SetText("This effect is colorable.")
			self.color.text:SetWrap( true )
			self.color.text:SetAutoStretchVertical( true )
			self.color.text:Dock(TOP)
			self.color.text:SizeToContents()
			self.color:AddItem(self.color.text)
			self.color.text:GetParent():DockPadding( 15, 10, 15, 10 )


			self.color.selection = vgui.Create( "CtrlColor", self.color )
			self.color.selection:SetLabel( "" )
			self.color.selection:SetConVarR( data.commands.color .. "_r" )
			self.color.selection:SetConVarG( data.commands.color .. "_g" )
			self.color.selection:SetConVarB( data.commands.color .. "_b" )
			self.color.selection:SetConVarA( nil )
			self.color.selection:Dock(TOP)
			self.color:AddItem(self.color.selection)
			self.color.selection:GetParent():DockPadding( 10, 0, 10, 10 )
		end




		if data.commands.utileffect then
			self.utilfx = vgui.Create("DForm", self.back)
			self.utilfx.Paint = function()
				derma.SkinHook( "Paint", "CollapsibleCategory", self.utilfx, self.utilfx:GetWide(), self.utilfx:GetTall() )
				surface.SetDrawColor( Color(0,0,0,110) )
    				surface.DrawRect( 0, 0, self.utilfx:GetWide(), self.utilfx:GetTall() )
			end
			self.utilfx:Dock(TOP)
			self.back:AddItem(self.utilfx)
			self.utilfx:GetParent():DockPadding(5,0,5,0)

			//Modify the header and tweak things so it doesn't show up when the category is closed.
			self.utilfx.Header:SetText( "Scripted Effect" )
			self.utilfx.Header:SetImage("icon16/cog.png")
			self.utilfx.Header.DoClick = function() end
			self.utilfx.PerformLayout = function()
				local us = self.utilfx	//so when we copy this over to another dform we only have to change this one line
				local Padding = us:GetPadding() or 0
				if ( us.Contents ) then
					if ( us:GetExpanded() ) then
						us.Contents:InvalidateLayout( true )
						us.Contents:SetVisible( true )
					else
						us.Contents:SetVisible( false )
					end
				end
				if ( us:GetExpanded() ) then
					us:SizeToChildren( false, true )
				else
					us:SetTall(0)	//this is the only real change from the standard DForm:PerformLayout()
				end	
				-- Make sure the color of header text is set
				us.Header:ApplySchemeSettings()
				us.animSlide:Run()
				us:UpdateAltLines();
			end

			self.utilfx.text = vgui.Create("DLabel", self.utilfx)
			self.utilfx.text:SetColor( Color(60,60,60,255) )
			self.utilfx.text:SetText("These options can be used to modify certain scripted effects in different ways depending on the effect being used.")
			self.utilfx.text:SetWrap( true )
			self.utilfx.text:SetAutoStretchVertical( true )
			self.utilfx.text:Dock(TOP)
			self.utilfx.text:SizeToContents()
			self.utilfx:AddItem(self.utilfx.text)
			self.utilfx.text:GetParent():DockPadding( 15, 10, 15, 5 )


			self.utilfx.slider1 = vgui.Create( "DNumSlider", self.utilfx )
			self.utilfx.slider1:SetText( "Util.Effect Scale" )
			self.utilfx.slider1:SetMinMax(0.2, 10)
			self.utilfx.slider1:SetDecimals(2)
			self.utilfx.slider1:SetConVar( data.commands.utileffect .. "_scale" )
			self.utilfx.slider1:SetHeight(15)
			self.utilfx.slider1:SizeToContents()
			self.utilfx.slider1:SetDark(true)
			self.utilfx:AddItem(self.utilfx.slider1)

			self.utilfx.slider2 = vgui.Create( "DNumSlider", self.utilfx )
			self.utilfx.slider2:SetText( "Util.Effect Magnitude" )
			self.utilfx.slider2:SetMinMax(1, 10)
			self.utilfx.slider2:SetDecimals(2)
			self.utilfx.slider2:SetConVar( data.commands.utileffect .. "_magnitude" )
			self.utilfx.slider2:SetHeight(15)
			self.utilfx.slider2:SizeToContents()
			self.utilfx.slider2:SetDark(true)
			self.utilfx:AddItem(self.utilfx.slider2)

			self.utilfx.slider3 = vgui.Create( "DNumSlider", self.utilfx )
			self.utilfx.slider3:SetText( "Util.Effect Radius" )
			self.utilfx.slider3:SetMinMax(10, 1000)
			self.utilfx.slider3:SetDecimals(2)
			self.utilfx.slider3:SetConVar( data.commands.utileffect .. "_radius" )
			self.utilfx.slider3:SetHeight(15)
			self.utilfx.slider3:SizeToContents()
			self.utilfx.slider3:SetDark(true)
			self.utilfx:AddItem(self.utilfx.slider3)
		end




		self.back.Think = function()
			if self.beam then
				if GetConVarNumber( data.commands.mode_beam ) > 0 then
					//expand it
					if self.beam:GetExpanded() == false then self.beam:Toggle() end
				else
					//contract it
					if self.beam:GetExpanded() == true then self.beam:Toggle() end
					self.beam:GetParent():SetTall(self.beam:GetTall())
				end
			end
			if self.color then
				if GetConVarNumber( data.commands.color .. "_enabled" ) > 0 then
					//expand it
					if self.color:GetExpanded() == false then self.color:Toggle() end
				else
					//contract it
					if self.color:GetExpanded() == true then self.color:Toggle() end
					self.color:GetParent():SetTall(self.color:GetTall())
				end
			end
			if self.utilfx then
				if string.StartWith( GetConVarString(data.commands.effectname), "!UTILEFFECT!" ) then
					//expand it
					if self.utilfx:GetExpanded() == false then self.utilfx:Toggle() end
				else
					//contract it
					if self.utilfx:GetExpanded() == true then self.utilfx:Toggle() end
					self.utilfx:GetParent():SetTall(self.utilfx:GetTall())
				end
			end


			if data.commands.enabled then
				if GetConVarNumber( data.commands.enabled ) > 0 then
					//expand it
					if self.back:GetExpanded() == false then self.back:Toggle() end
				else
					//contract it
					if self.back:GetExpanded() == true then self.back:Toggle() end
				end
			end
		end
		
	end













	//Favorites - this table is global too because this is all copied over from the standard Particle Browser, even though I don't suspect we'll ever have more than one of these
	ParticleBrowserTracerFavorites = {
		Effects = {},   //effects in the favorites list
		Children = {},  //all DTreeNode panels that are using this favorites list
	}

	local parctrltracerfavs_str = file.Read("particlecontrol_favorites_tracer.txt","DATA")
	if parctrltracerfavs_str then ParticleBrowserTracerFavorites.Effects = util.JSONToTable(parctrltracerfavs_str) end


	function ParticleBrowserTracerFavorites_UpdateEffect( effectdisplay, effectoptions )

		if effectoptions then
			//We're adding the effect
			ParticleBrowserTracerFavorites.Effects[effectdisplay] = effectoptions
		else
			//We're removing the effect
			ParticleBrowserTracerFavorites.Effects[effectdisplay] = nil
		end

		for _, panel in pairs (ParticleBrowserTracerFavorites.Children) do
			if panel then
				ParticleBrowserTracerFavorites_UpdateChildPanel( panel )
			end
		end

		file.Write( "particlecontrol_favorites_tracer.txt", util.TableToJSON(ParticleBrowserTracerFavorites.Effects, true) )

	end


	function ParticleBrowserTracerFavorites_UpdateChildPanel( panel )

		if !panel then return end

		if panel.FavoriteNodes then
			//Remove all of the nodes from the panel
			for k, node in pairs (panel.FavoriteNodes) do
				node:Remove()
				panel.FavoriteNodes[k] = nil
			end
		else
			panel.FavoriteNodes = {}
		end

		for effectdisplay, effectoptions in SortedPairs (ParticleBrowserTracerFavorites.Effects) do
			local effect = effectoptions["InternalName"]

			panel.FavoriteNodes[effect] = panel:AddNode(effectdisplay)

			panel.FavoriteNodes[effect].EffectOptions = {}
			if effectoptions["Colorable"] then 
				panel.FavoriteNodes[effect].EffectOptions["Colorable"] = true
			end
			if effectoptions["ColorOutOfOne"] then
				panel.FavoriteNodes[effect].EffectOptions["ColorOutOfOne"] = true
			end

			//Don't use the icons for features we're not using
			local coloricon = ( (panel.CommandInfo.color) and (panel.FavoriteNodes[effect].EffectOptions["Colorable"] == true) )
			//Set the effect icon:
			if coloricon then
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire_line_rainbow.png")
			else
				panel.FavoriteNodes[effect].Icon:SetImage("icon16/fire_line.png")
			end

			panel.FavoriteNodes[effect].DoClick = function() 
				RunConsoleCommand( panel.CommandInfo.effectname, effect )

				if panel.CommandInfo.color then
					if panel.FavoriteNodes[effect].EffectOptions["Colorable"] then
						RunConsoleCommand( panel.CommandInfo.color .. "_enabled", "1" )
					else
						RunConsoleCommand( panel.CommandInfo.color .. "_enabled", "0" )
					end

					if panel.FavoriteNodes[effect].EffectOptions["ColorOutOfOne"] then
						RunConsoleCommand( panel.CommandInfo.color .. "_outofone", "1" )
					else
						RunConsoleCommand( panel.CommandInfo.color .. "_outofone", "0" )
					end
				end
			end

			panel.FavoriteNodes[effect].DoRightClick = function()
				//We only need the remove option here, since it's already in the favorites list
				local menu = DermaMenu()

				local option = menu:AddOption( "Un-favorite \'\'" .. effectdisplay .. "\'\'", function()
					ParticleBrowserTracerFavorites_UpdateEffect( effectdisplay )  //calling this function with no second arg tells it to remove this effect from the list
				end )
				option:SetImage("icon16/delete.png")

				menu:Open()
			end
		end

	end




	function AddParticleBrowserTracer(panel,data)

		local self = {}

		//Data table contents:
		//{
		//name = "Effect" (name to show at the top of the panel)
		//commands =   (table of concommands that the panel uses)
		//	{
		//	effectname = "particlecontrol_effectname"
		//	color = "particlecontrol_color" (optional, assumes there are cvars derived from this name (X_enabled, X_r, X_g, X_b, X_outofone) )
		//	}
		//}

		self.back = vgui.Create("DForm", panel)
		self.back:SetLabel(data.name)
		self.back.Paint = function()
			derma.SkinHook( "Paint", "CollapsibleCategory", self.back, self.back:GetWide(), self.back:GetTall() )
			surface.SetDrawColor( Color(0,0,0,70) )
    			surface.DrawRect( 0, 0, self.back:GetWide(), self.back:GetTall() )
		end
		self.back.Header:SetImage("icon16/fire.png")
		self.back.Header.DoClick = function() end
		panel:AddPanel(self.back)




		self.tree = vgui.Create("DTree", self.back)
		self.tree:SetHeight(400)
		self.back:AddItem(self.tree)
		self.tree:GetParent():DockPadding(5,5,5,0)

		local function PopulateEffectList(parent, effectstab, effectoptions)
			for k, v in SortedPairs (effectstab) do
				local effect = k
				local effectdisplay = k
				//if v is another string instead of just a filler "true" value, then that means k is the display name and v is the internal name
				if isstring(v) then
					effect = v
				end

				parent[effect] = parent:AddNode(effectdisplay)

				parent[effect].EffectOptions = {}
				if effectoptions["Color1"] and effectoptions["Color1"][effect] then 
					parent[effect].EffectOptions["Colorable"] = true
					parent[effect].EffectOptions["ColorOutOfOne"] = true
				end
				if effectoptions["Color255"] and effectoptions["Color255"][effect] then
					parent[effect].EffectOptions["Colorable"] = true
					parent[effect].EffectOptions["ColorOutOfOne"] = false
				end

				//Don't use the icons for features we're not using
				local coloricon = ( (data.commands.color) and (parent[effect].EffectOptions["Colorable"] == true) )
				//Set the effect icon:
				if coloricon then
					parent[effect].Icon:SetImage("icon16/fire_line_rainbow.png")
				else
					parent[effect].Icon:SetImage("icon16/fire_line.png")
				end

				//Left Click: Select the effect by setting its concommands
				parent[effect].DoClick = function() 
					RunConsoleCommand( data.commands.effectname, effect )

					if data.commands.color then
						if parent[effect].EffectOptions["Colorable"] then
							RunConsoleCommand( data.commands.color .. "_enabled", "1" )
						else
							RunConsoleCommand( data.commands.color .. "_enabled", "0" )
						end

						if parent[effect].EffectOptions["ColorOutOfOne"] then
							RunConsoleCommand( data.commands.color .. "_outofone", "1" )
						else
							RunConsoleCommand( data.commands.color .. "_outofone", "0" )
						end
					end
				end

				//Right Click: Display an option to add/remove the effect from favorites
				parent[effect].DoRightClick = function()
					local menu = DermaMenu()

					if !ParticleBrowserTracerFavorites.Effects[effectdisplay] then
						local option = menu:AddOption( "Favorite \'\'" .. effectdisplay .. "\'\'", function()
							ParticleBrowserTracerFavorites_UpdateEffect( effectdisplay, {
								["InternalName"] = effect,
								["Colorable"] = tobool(parent[effect].EffectOptions["Colorable"]),
								["ColorOutOfOne"] = tobool(parent[effect].EffectOptions["ColorOutOfOne"]),
							} )
						end )
						option:SetImage("icon16/add.png")
					else
						local option = menu:AddOption( "Un-favorite \'\'" .. effectdisplay .. "\'\'", function()
							ParticleBrowserTracerFavorites_UpdateEffect( effectdisplay )  //calling this function with no second arg tells it to remove this effect from the list
						end )
						option:SetImage("icon16/delete.png")
					end

					menu:Open()
				end
			end
		end

		//Games
		self.tree.games = self.tree:AddNode("Games")
		self.tree.games.Icon:SetImage("icon16/folder_database.png")
		self.tree.games:SetExpanded(true)
		//
		for tabname, tab in SortedPairs (ParticleListTable.Games) do
			if tab.Info.EffectOptions.Tracers then
				self.tree.games[tabname] = self.tree.games:AddNode(tab.Info.CategoryName)
				self.tree.games[tabname].Icon:SetImage(tab.Info.Icon)

				//Create the utilfx list
				if tab.Info.UtilEffects then
					local tracerlist = {}
					for k, v in pairs (tab.Info.UtilEffects) do
						//in a utileffect table, the effect name is stored in the value
						if tab.Info.EffectOptions.Tracers[v] then tracerlist[k] = v end
					end
					if table.Count(tracerlist) > 0 then
						self.tree.games[tabname].UtilEffects = self.tree.games[tabname]:AddNode("Scripted Effects")
						self.tree.games[tabname].UtilEffects.Icon:SetImage("icon16/page_gear.png")

						self.tree.games[tabname].UtilEffects.IsPopulated = false
						self.tree.games[tabname].UtilEffects.DoClick = function()
							if self.tree.games[tabname].UtilEffects.IsPopulated == true then return end

							PopulateEffectList(self.tree.games[tabname].UtilEffects, tracerlist, tab.Info.EffectOptions)

							self.tree.games[tabname].UtilEffects.IsPopulated = true
							self.tree.games[tabname].UtilEffects:SetExpanded(true)
						end
					end
				end

				//Create the .pcf lists
				for pcfname, particles in SortedPairs (tab.Particles) do
					local tracerlist = {}
					for k, v in pairs (particles) do
						//in a particle table, the effect name is stored in the key
						if tab.Info.EffectOptions.Tracers[k] then tracerlist[k] = v end
					end
					if table.Count(tracerlist) > 0 then
						local pcftabname = string.StripExtension(pcfname)  //just in case having a dot in the key name causes problems
						self.tree.games[tabname][pcftabname] = self.tree.games[tabname]:AddNode(pcfname)
						self.tree.games[tabname][pcftabname].Icon:SetImage("icon16/page.png")

						self.tree.games[tabname][pcftabname].IsPopulated = false
						self.tree.games[tabname][pcftabname].DoClick = function()
							if self.tree.games[tabname][pcftabname].IsPopulated == true then return end

							PopulateEffectList(self.tree.games[tabname][pcftabname], tracerlist, tab.Info.EffectOptions)

							self.tree.games[tabname][pcftabname].IsPopulated = true
							self.tree.games[tabname][pcftabname]:SetExpanded(true)
						end
					end
				end
			end
		end

		//Addons
		self.tree.addons = self.tree:AddNode("Addons")
		self.tree.addons.Icon:SetImage("icon16/folder_database.png")
		self.tree.addons:SetExpanded(true)
		//
		for tabname, tab in SortedPairs (ParticleListTable.Addons) do
			if tab.Info.EffectOptions.Tracers then
				self.tree.addons[tabname] = self.tree.addons:AddNode(tab.Info.CategoryName)
				self.tree.addons[tabname].Icon:SetImage(tab.Info.Icon)

				//Create the utilfx list
				if tab.Info.UtilEffects then
					local tracerlist = {}
					for k, v in pairs (tab.Info.UtilEffects) do
						//in a utileffect table, the effect name is stored in the value
						if tab.Info.EffectOptions.Tracers[v] then tracerlist[k] = v end
					end
					if table.Count(tracerlist) > 0 then
						self.tree.addons[tabname].UtilEffects = self.tree.addons[tabname]:AddNode("Scripted Effects")
						self.tree.addons[tabname].UtilEffects.Icon:SetImage("icon16/page_gear.png")

						self.tree.addons[tabname].UtilEffects.IsPopulated = false
						self.tree.addons[tabname].UtilEffects.DoClick = function()
							if self.tree.addons[tabname].UtilEffects.IsPopulated == true then return end

							PopulateEffectList(self.tree.addons[tabname].UtilEffects, tracerlist, tab.Info.EffectOptions)

							self.tree.addons[tabname].UtilEffects.IsPopulated = true
							self.tree.addons[tabname].UtilEffects:SetExpanded(true)
						end
					end
				end

				//Create the .pcf lists
				for pcfname, particles in SortedPairs (tab.Particles) do
					local tracerlist = {}
					for k, v in pairs (particles) do
						//in a particle table, the effect name is stored in the key
						if tab.Info.EffectOptions.Tracers[k] then tracerlist[k] = v end
					end
					if table.Count(tracerlist) > 0 then
						local pcftabname = string.StripExtension(pcfname)  //just in case having a dot in the key name causes problems
						self.tree.addons[tabname][pcftabname] = self.tree.addons[tabname]:AddNode(pcfname)
						self.tree.addons[tabname][pcftabname].Icon:SetImage("icon16/page.png")

						self.tree.addons[tabname][pcftabname].IsPopulated = false
						self.tree.addons[tabname][pcftabname].DoClick = function()
							if self.tree.addons[tabname][pcftabname].IsPopulated == true then return end

							PopulateEffectList(self.tree.addons[tabname][pcftabname], tracerlist, tab.Info.EffectOptions)

							self.tree.addons[tabname][pcftabname].IsPopulated = true
							self.tree.addons[tabname][pcftabname]:SetExpanded(true)
						end
					end
				end
			end
		end

		//Favorites
		self.tree.favorites = self.tree:AddNode("Favorites (Tracers)")
		self.tree.favorites.Icon:SetImage("icon16/star.png")
		self.tree.favorites:SetExpanded(true)
		//
		table.insert( ParticleBrowserTracerFavorites.Children, self.tree.favorites )   //Add it to the Favorites table's list of child panels and let it do the rest of the work
		self.tree.favorites.CommandInfo = data.commands				       //Store the console command info in the panel so the UpdateChildPanel function can access it
		ParticleBrowserTracerFavorites_UpdateChildPanel( self.tree.favorites )




		self.effectnameentry = vgui.Create( "DTextEntry", self.back )
		self.effectnameentry:SetConVar( data.commands.effectname )
		self.back:AddItem(self.effectnameentry)
		self.effectnameentry:GetParent():DockPadding(5,5,5,10)




		if data.commands.color then
			self.color = vgui.Create("DForm", self.back)
			self.color.Paint = function()
				derma.SkinHook( "Paint", "CollapsibleCategory", self.color, self.color:GetWide(), self.color:GetTall() )
				surface.SetDrawColor( Color(0,0,0,110) )
    				surface.DrawRect( 0, 0, self.color:GetWide(), self.color:GetTall() )
			end
			self.color:Dock(TOP)
			self.back:AddItem(self.color)
			self.color:GetParent():DockPadding(5,0,5,0)

			//Modify the header and tweak things so it doesn't show up when the category is closed.
			self.color.Header:SetText( "Colorable" )
			self.color.Header:SetImage("icon16/fire_rainbow.png")
			self.color.Header.DoClick = function() end
			self.color.PerformLayout = function()
				local us = self.color	//so when we copy this over to another dform we only have to change this one line
				local Padding = us:GetPadding() or 0
				if ( us.Contents ) then
					if ( us:GetExpanded() ) then
						us.Contents:InvalidateLayout( true )
						us.Contents:SetVisible( true )
					else
						us.Contents:SetVisible( false )
					end
				end
				if ( us:GetExpanded() ) then
					us:SizeToChildren( false, true )
				else
					us:SetTall(0)	//this is the only real change from the standard DForm:PerformLayout()
				end	
				-- Make sure the color of header text is set
				us.Header:ApplySchemeSettings()
				us.animSlide:Run()
				us:UpdateAltLines();
			end

			self.color.text = vgui.Create("DLabel", self.color)
			self.color.text:SetColor( Color(60,60,60,255) )
			self.color.text:SetText("This effect is colorable.")
			self.color.text:SetWrap( true )
			self.color.text:SetAutoStretchVertical( true )
			self.color.text:Dock(TOP)
			self.color.text:SizeToContents()
			self.color:AddItem(self.color.text)
			self.color.text:GetParent():DockPadding( 15, 10, 15, 10 )


			self.color.selection = vgui.Create( "CtrlColor", self.color )
			self.color.selection:SetLabel( "" )
			self.color.selection:SetConVarR( data.commands.color .. "_r" )
			self.color.selection:SetConVarG( data.commands.color .. "_g" )
			self.color.selection:SetConVarB( data.commands.color .. "_b" )
			self.color.selection:SetConVarA( nil )
			self.color.selection:Dock(TOP)
			self.color:AddItem(self.color.selection)
			self.color.selection:GetParent():DockPadding( 10, 0, 10, 10 )
		end




		self.back.Think = function()
			if self.color then
				if GetConVarNumber( data.commands.color .. "_enabled" ) > 0 then
					//expand it
					if self.color:GetExpanded() == false then self.color:Toggle() end
				else
					//contract it
					if self.color:GetExpanded() == true then self.color:Toggle() end
					self.color:GetParent():SetTall(self.color:GetTall())
				end
			end
		end
		
	end
end
--lua/autorun/particlefiletest.lua:
AddCSLuaFile()
//MsgN("Added concommand for particle read test!")



function ParticleControl_FileReadTest()

	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("=====================================================")
	MsgN("STEP 1: Reading the file")
	MsgN("=====================================================")
	MsgN("")

	local filestr = file.Read("particlelists/particlefiletest.lua","LUA")
	if !filestr then
		MsgN("FAILURE! We tried to read the file (particlelists/particlefiletest.lua) and didn't get anything. The file can't be found, or it isn't readable, or something, which doesn't make any sense, since the actual tool got farther than this.")
		return
	end

	if type(filestr) != "string" then
		MsgN("FAILURE! We read the file but we got back a " .. type(filestr) .. "instead of a string. What!? Here's what we got:")
		MsgN("")
		MsgN(filestr)
		return
	end

	MsgN("SUCCESS! We read the file and got back a string. Here's its contents:")
	MsgN("")
	MsgN(filestr)


	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("=====================================================")
	MsgN("STEP 2: Converting it to a table")
	MsgN("=====================================================")
	MsgN("")

	local keyvalues = util.KeyValuesToTable( filestr, false, true )
	if !keyvalues then
		MsgN("FAILURE! We tried to convert it to a table, but we didn't get anything.")
		return
	end
	if (table.Count(keyvalues) == 0) then
		MsgN("FAILURE! We tried to convert it, but we got an empty table. Here's its contents, by which I mean a blank space unless something's weird here:")
		MsgN("")
		PrintTable(keyvalues)
		return
	end

	MsgN("SUCCESS! We converted it and got a table of stuff. Here's its contents:")
	MsgN("")
	PrintTable(keyvalues)


	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("")
	MsgN("=====================================================")
	MsgN("STEP 3: Reading the table")
	MsgN("=====================================================")
	MsgN("")

	if !keyvalues.Info then
		MsgN("FAILURE! We couldn't find a key called \"Info\" inside the table. Is something wrong with the table we got? Like some blank spaces in the key name, or weird capitalization, or something like that which means it's technically not called \"Info\"? Or is the table's formatting messed up? Here's all of the keys we COULD find inside the table, with and without quotes just in case there's weird spaces:")
		MsgN("")
		for k, v in pairs (keyvalues) do
			MsgN("\"" .. k .. "\"")
		end
		MsgN("")
		for k, v in pairs (keyvalues) do
			MsgN(k)
		end
		return
	end

	if type(keyvalues.Info) != "table" then
		MsgN("FAILURE! The key called \"Info\" inside the table was something other than a sub-table. It was a " .. type(keyvalues.Info) .. " instead. Something's wrong with the table we got. Here's what \"Info\" is:")
		MsgN("")
		MsgN(keyvalues.Info)
		return
	end

	MsgN("Found the sub-table called \"Info\" inside the table...")
	MsgN("")

	if !keyvalues.Info.CategoryName then
		MsgN("FAILURE! We couldn't find the \"CategoryName\" inside the \"Info\" subtable. Something's wrong with the table we got. Here's \"Info\"'s contents:")
		MsgN("")
		PrintTable(keyvalues.Info)
		return
	end

	if type(keyvalues.Info.CategoryName) != "string" then
		MsgN("FAILURE! The \"CategoryName\" inside the \"Info\" subtable was something other than a string. Something's wrong with the table we got. Here's \"Info\"'s contents:")
		MsgN("")
		PrintTable(keyvalues.Info)
		return
	end

	MsgN("SUCCESS! We read the table. It's for a category called " .. keyvalues.Info.CategoryName .. ", and everything else should be there too. The table contents are back up there in Step 2 and they should look normal. Congratulations, everything's working fine! If we were doing this same stuff in the actual tool, it'd use the table to make a list of particle effects. But if the tool was working perfectly for you, then you wouldn't be running this debug thing, now would you? Looks like we're back to square one here.")

end



if SERVER then
	concommand.Add("particlereadtest_server", function()
		MsgN("Beginning SERVERSIDE particle file read test!")
		ParticleControl_FileReadTest()
	end)
end

if CLIENT then
	concommand.Add("particlereadtest_client", function()
		MsgN("Beginning CLIENTSIDE particle file read test!")
		ParticleControl_FileReadTest()
	end)
end
--lua/autorun/policedroid.lua:
player_manager.AddValidModel( "policedroid", "models/player/valley/policedroid.mdl" ) 
list.Set( "PlayerOptionsModel",  "policedroid", "models/player/valley/policedroid.mdl" ) 

--lua/autorun/rb_lightsaber.lua:
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AdascorpPolesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AntiqueSocorroLightsaberBesh.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AntiqueSocorroLightsaberCresh.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AntiqueSocorroLightsaberDorn.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AntiqueSocorroSaberstaffAurek.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AntiqueSocorroSaberstaffDorn.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ArakydSaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ArdentDefender'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ArdentDefender'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ArtusianLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ArtusianSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Ashara'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/AttunedForceLord'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sAttenuatedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sAttenuatedSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sAttenuatedShoto.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Blademaster'sShoto.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Challenger'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ChrysopazLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ChrysopazSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Conqueror'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Conqueror'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/CoruscaLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/CoruscaSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Custom-BuiltDoubleBladedSaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DarkReverieDoubleBladedSaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DarkSeeker'sDoubleBladedSaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DauntlessAvenger'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Defender'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DefiantTechnographer'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DefiantTechnographer'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DefiantTechnographer'sShoto.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DerelictLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DerelictSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Descendant'sHeirloomDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Desolator'sStarforgedDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Despot'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Devastator'sDoubleBladedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DiabolistLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DragonPearlLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/DragonPearlSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ElegantModifiedDoubleBladedSaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/EtchedDuelerDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/EternalCommanderMK-14Saberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/EternalCommanderMk-4Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Exarch'sMk-1Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Exarch'sMk-2Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Executioner'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ExquisiteChampionDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/FearlessRetaliator'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/FearlessRetaliator'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/FireNodeLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/FrontierHunter'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/FrontierHunter'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/GeminiMk-4Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/GrantekF11-DDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/GrantekF11-DLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Herald'sPolesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Hermit'sPolesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/HiriduLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/HiriduSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Ice-JewelLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/IndomitableVanquisher'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/InscrutableDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/InscrutableLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Instigator'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/IokathMk-4Saberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/MytagLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/NovaLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Occultists'PolesaberMk1.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/OutlanderLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/OutlanderLightsaber2.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/OutlanderPolesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/OutlanderPolesaber2.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Overseer'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/PitilessRaiderLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Praetorian'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/PrismaticLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Prophet'sStarforgedDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Reckoning'sExposedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Reckoning'sExposedSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Redeemer'sStarforgedDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Retribution'sExposedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Retribution'sExposedSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Revanite'sMk-1Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Revanite'sMk-1Polesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Revanite'sMk-2Lightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Revanite'sMk-2Polesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/RighteousPrimevalLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Rishi'sLightsaberMk-1.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Rishi'sMk-1Polesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/SateleShan'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/SateleShan'sSparringLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Senya'sLightsaberPike.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/SenyaTirall'sLightsaber-Cartel.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/SenyaTirall'sLightsaber-Companion.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Serenity'sUnsealedSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/StrongholdDefender'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/StrongholdDefender'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/TemptedApprentice'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/TemptedApprentice'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ThermalLightsaberMk-3.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Thexan'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/TythianLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/TythianLightsaberPike.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/TythonianForce-Master'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/UnrelentingAggressorDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/UnstableArbiter'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/UnstableArbiter'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/UnstablePeacemaker'sDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/UnstablePeacemaker'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Vengeance'sUnsealedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Vengeance'sUnsealedSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/VigorousBattlerDualsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Vindicator'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Vindicator'sSaberstaff.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Warden'sLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Warmaster'sDoubleBladedLightsaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Zakuulan'sMk-1Polesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/Zakuulan'sMk-2Polesaber.mdl", {} )
list.Set( "LightsaberModels", "models/swtor/arsenic/lightsabers/ZiostGuardian'sLightsaber.mdl", {} )
--lua/autorun/saam.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Saam",		"models/player/tiki/saam.mdl" )

--addons/sam/lua/sam/libs/sh_pon.lua:
if SAM_LOADED then return end

--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  -		 k,v - pointers
 - strings -		 k,v - pointers
 - numbers -		k,v
 - booleans-		 k,v

 - Vectors -		 k,v
 - Angles  -		k,v
 - Entities-		 k,v
 - Players -		 k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]
local pon = {}
sam.pon = pon

do
	local type = sam.type
	local IsColor = IsColor
	local tonumber = tonumber
	local format = string.format
	local encode = {}
	local cacheSize = 0

	encode['table'] = function(self, tbl, output, cache)
		if cache[tbl] then
			output[#output + 1] = format('(%x)', cache[tbl])

			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl, nil)
		local predictedNumeric = 1

		-- starts with a numeric dealio
		if first == 1 then
			output[#output + 1] = '{'

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1
					local tv = type(v)

					if tv == 'string' then
						local pid = cache[v]

						if pid then
							output[#output + 1] = format('(%x)', pid)
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							self.string(self, v, output, cache)
						end
					elseif IsColor(v) then
						self.Color(self, v, output, cache)
					else
						self[tv](self, v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		if predictedNumeric == nil then
			output[#output + 1] = '[' -- no array component
		else
			output[#output + 1] = '~' -- array component came first so shit needs to happen
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)
			if not self[tk] or not self[tv] then continue end

			-- WRITE KEY
			if tk == 'string' then
				local pid = cache[k]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize
					self.string(self, k, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tk](self, k, output, cache)
			end

			-- WRITE VALUE
			if tv == 'string' then
				local pid = cache[v]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize
					self.string(self, v, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tv](self, v, output, cache)
			end
		end

		output[#output + 1] = '}'
	end

	--	ENCODE STRING
	local gsub = string.gsub

	encode['string'] = function(self, str, output)
		--if tryCache(str, output then return end
		local estr, count = gsub(str, ';', "\\;")

		if count == 0 then
			output[#output + 1] = '\'' .. str .. ';'
		else
			output[#output + 1] = '"' .. estr .. '";'
		end
	end

	--	ENCODE NUMBER
	encode['number'] = function(self, num, output)
		if num % 1 == 0 then
			if num < 0 then
				output[#output + 1] = format('x%x;', -num)
			else
				output[#output + 1] = format('X%x;', num)
			end
		else
			output[#output + 1] = tonumber(num) .. ';'
		end
	end

	--	ENCODE BOOLEAN
	encode['boolean'] = function(self, val, output)
		output[#output + 1] = val and 't' or 'f'
	end

	--	ENCODE VECTOR
	encode['Vector'] = function(self, val, output)
		output[#output + 1] = ('v' .. val.x .. ',' .. val.y) .. (',' .. val.z .. ';')
	end

	--	ENCODE ANGLE
	encode['Angle'] = function(self, val, output)
		output[#output + 1] = ('a' .. val.p .. ',' .. val.y) .. (',' .. val.r .. ';')
	end

	encode['Entity'] = function(self, val, output)
		output[#output + 1] = 'E' .. (IsValid(val) and (val:EntIndex() .. ';') or '#')
	end

	encode['Player'] = encode['Entity']
	encode['Vehicle'] = encode['Entity']
	encode['Weapon'] = encode['Entity']
	encode['NPC'] = encode['Entity']
	encode['NextBot'] = encode['Entity']
	encode['PhysObj'] = encode['Entity']

	encode['Color'] = function(self, val, output)
		output[#output + 1] = ('C' .. val.r .. ',' .. val.g .. ',' .. val.b) .. (',' .. val.a .. ';')
	end

	encode['console'] = function(self, val, output)
		output[#output + 1] = 's'
	end

	encode['nil'] = function(self, val, output)
		output[#output + 1] = '?'
	end

	encode.__index = function(key)
		ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')

		return encode['nil']
	end

	do
		local concat = table.concat

		function pon.encode(tbl)
			local output = {nil, nil, nil, nil, nil, nil, nil, nil}
			cacheSize = 0
			encode['table'](encode, tbl, output, {})

			return concat(output)
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity
	local decode = {}

	decode['{'] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tv = sub(str, index, index)

			if not tv or tv == '~' then
				index = index + 1
				break
			end

			if tv == '}' then return index + 1, cur end
			-- READ THE VALUE
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
			k = k + 1
		end

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	decode['['] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			if not k then continue end
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1

			if not self[tv] then
				print('did not find type: ' .. tv)
			end

			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	-- STRING
	decode['"'] = function(self, index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), '\\;', ';')
		index = finish + 2
		cache[#cache + 1] = res

		return index, res
	end

	-- STRING NO ESCAPING NEEDED
	decode['\''] = function(self, index, str, cache)
		local finish = find(str, ';', index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1
		cache[#cache + 1] = res

		return index, res
	end

	-- NUMBER
	decode['n'] = function(self, index, str)
		index = index - 1
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, num
	end

	decode['0'] = decode['n']
	decode['1'] = decode['n']
	decode['2'] = decode['n']
	decode['3'] = decode['n']
	decode['4'] = decode['n']
	decode['5'] = decode['n']
	decode['6'] = decode['n']
	decode['7'] = decode['n']
	decode['8'] = decode['n']
	decode['9'] = decode['n']
	decode['-'] = decode['n']

	-- positive hex
	decode['X'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- negative hex
	decode['x'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- POINTER
	decode['('] = function(self, index, str, cache)
		local finish = find(str, ')', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, cache[num]
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode['t'] = function(self, index) return index, true end
	decode['f'] = function(self, index) return index, false end

	-- VECTOR
	decode['v'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', vecStr, false)

		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ANGLE
	decode['a'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', angStr, false)

		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ENTITY
	decode['E'] = function(self, index, str)
		if str[index] == '#' then
			index = index + 1

			return index, NULL
		else
			local finish = find(str, ';', index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1

			return index, Entity(num)
		end
	end

	-- COLOR
	decode['C'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local colStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', colStr, false)

		return index, Color(segs[1], segs[2], segs[3], segs[4])
	end

	-- PLAYER
	decode['P'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, Entity(num) or NULL
	end

	-- NIL
	decode['?'] = function(self, index) return index + 1, nil end
	-- SAM CONSOLE
	decode['s'] = function(self, index) return index, sam.console end

	function pon.decode(data)
		local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})

		return res
	end
end
--addons/sam/lua/sam/libs/sh_mp.lua:
if SAM_LOADED then return end

local sam = sam
local mp = sam.load_file("sam/libs/message_pack/sh_messagepack.lua")
local EXT_VECTOR  = 1
local EXT_ANGLE   = 2
local EXT_ENTITY  = 3
local EXT_PLAYER  = 4
local EXT_COLOR   = 5
local EXT_CONSOLE = 6

mp.packers["Entity"] = function(buffer, ent)
	local buf = {}
	mp.packers["number"](buf, ent:EntIndex())
	mp.packers["ext"](buffer, EXT_ENTITY, buf[1])
end
mp.packers["Vehicle"] = mp.packers["Entity"]
mp.packers["Weapon"] = mp.packers["Entity"]
mp.packers["NPC"] = mp.packers["Entity"]
mp.packers["NextBot"] = mp.packers["Entity"]
mp.packers["PhysObj"] = mp.packers["Entity"]

mp.packers["Player"] = function(buffer, ply)
	local buf = {}
	mp.packers["number"](buf, ply:UserID())
	mp.packers["ext"](buffer, EXT_PLAYER, buf[1])
end

local VECTOR = {}
mp.packers["Vector"] = function(buffer, vec)
	VECTOR[1] = vec.x
	VECTOR[2] = vec.y
	VECTOR[3] = vec.z

	local buf = {}
	mp.packers["_table"](buf, VECTOR)
	mp.packers["ext"](buffer, EXT_VECTOR, table.concat(buf))
end

local ANGLE = {}
mp.packers["Angle"] = function(buffer, ang)
	ANGLE[1] = ang.p
	ANGLE[2] = ang.y
	ANGLE[3] = ang.r

	local buf = {}
	mp.packers["_table"](buf, ANGLE)
	mp.packers["ext"](buffer, EXT_ANGLE, table.concat(buf))
end

local COLOR = {}
mp.packers["Color"] = function(buffer, col)
	COLOR[1] = col.r
	COLOR[2] = col.g
	COLOR[3] = col.b
	COLOR[4] = col.a

	local buf = {}
	mp.packers["_table"](buf, COLOR)
	mp.packers["ext"](buffer, EXT_COLOR, table.concat(buf))
end

mp.packers["console"] = function(buffer)
	mp.packers["ext"](buffer, EXT_CONSOLE, "")
end

local Entity = Entity
local _Player
local Color = Color
local Vector = Vector
local Angle = Angle
local unpackers = {
	[EXT_ENTITY] = function(v)
		return Entity(v)
	end,
	[EXT_PLAYER] = function(v)
		return _Player(v)
	end,
	[EXT_VECTOR] = function(v)
		return Vector(v[1], v[2], v[3])
	end,
	[EXT_ANGLE] = function(v)
		return Angle(v[1], v[2], v[3])
	end,
	[EXT_COLOR] = function(v)
		return Color(v[1], v[2], v[3], v[4])
	end,
	[EXT_CONSOLE] = function(v)
		return sam.console
	end
}

local Player = Player
if CLIENT then
	local players = {}

	local Name = function(s)
		return s.name
	end

	_Player = function(id)
		local ply = Player(id)

		if not IsValid(ply) then
			local name = players[id]
			if name then
				return {
					name = name,
					Name = Name
				}
			end
		end

		return ply
	end

	hook.Add("OnEntityCreated", "SAM.GetPlayerName", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			ent.sam_userid = ent:UserID() -- userid is -1 in EntityRemoved?????
		end
	end)

	hook.Add("EntityRemoved", "SAM.GetPlayerName", function(ent)
		if not ent:IsPlayer() then return end

		local id = ent.sam_userid
		if not id then return end

		players[id] = ent:Name()

		timer.Simple(60, function()
			if not IsValid(ent) then
				players[id] = nil
			end
		end)
	end)
else
	_Player = Player
end

mp.build_ext = function(tag, data)
	local f = mp.unpacker(data)
	local _, v = f()
	return unpackers[tag](v)
end

sam.mp = mp
--addons/sam/lua/sam/libs/sh_promises.lua:
if SAM_LOADED then return end
-- not real promises, just really simple one

local isfunction = sam and sam.isfunction or isfunction

local null = {}

local Promise = {}

local PromiseMethods = {}
local Promise_meta = {__index = PromiseMethods}

function Promise.new()
	return setmetatable({
		value = null,
		null = null
	}, Promise_meta)
end

function Promise.IsPromise(v)
	return getmetatable(v) == Promise_meta
end

function PromiseMethods:resolve(v)
	if self.value ~= null then return end
	if self.done_callback then
		self.done_callback(v)
	else
		self.value = v
		self.callback = 0
	end
end

function PromiseMethods:reject(v)
	if self.value ~= null then return end
	if self.catch_callback then
		self.catch_callback(v)
	else
		self.value = v
		self.callback = 1
	end
end

function PromiseMethods:done(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 0 then
			func(self.value)
		else
			self.done_callback = func
		end
	end
	return self
end

function PromiseMethods:catch(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 1 then
			func(self.value)
		else
			self.catch_callback = func
		end
	end
	return self
end

return Promise
--addons/sam/lua/sam/sh_colors.lua:
if SAM_LOADED then return end

local colors = {
	Red   = Color(244, 67, 54),
	Blue  = Color(13, 130, 223),
	Green = Color(0, 230, 64),
	White = Color(236, 240, 241),
	Black = Color(10, 10, 10)
}

function sam.get_color(name)
	return colors[name]
end

function sam.add_color(name, color)
	if isstring(name) and IsColor(color) then
		colors[name] = color
	end
end
--addons/sam/lua/sam/sh_util.lua:
if SAM_LOADED then return end

local sam = sam

function sam.parse_args(str)
	local args = {}
	local tmp, in_quotes = "", false
	for i = 1, #str do
		local char = str:sub(i, i)
		if char == "\"" then
			-- i could use string.find to find the next double quotes but thats gonna be overkill
			in_quotes = not in_quotes
			if tmp ~= "" or not in_quotes then
				args[#args + 1], tmp = tmp, ""
			end
		elseif char ~= " " or in_quotes then
			tmp = tmp .. char
		elseif tmp ~= "" then
			args[#args + 1], tmp = tmp, ""
		end
	end
	if tmp ~= "" then
		args[#args + 1] = tmp
	end
	return args, #args
end

function sam.get_targets_list(targets)
	if sam.isstring(targets) then
		return {Color(244, 67, 54), targets}
	end

	local len = #targets

	if len == player.GetCount() and len > 1 then
		return {Color(244, 67, 54), sam.language.get("Everyone")}
	end

	local admin = targets.admin
	local result = {}
	local white = Color(236, 240, 241)
	for i = 1, len do
		local target = targets[i]

		if CLIENT and LocalPlayer() == target then
			table.insert(result, Color(255, 215, 0))
			if admin ~= LocalPlayer() then
				table.insert(result, sam.language.get("You"))
			else
				table.insert(result, sam.language.get("Yourself"))
			end
		elseif admin ~= target then
			local name
			if sam.isentity(target) and target.Name then
				name = target:Name()
			else
				name = "Unknown"
				table.insert(result, white)
				table.insert(result, "*")
			end

			table.insert(result, Color(244, 67, 54))
			table.insert(result, name)
		else
			table.insert(result, Color(255, 215, 0))
			table.insert(result, sam.language.get("Themself"))
		end

		if i ~= len then
			table.insert(result, white)
			table.insert(result, ",")
		end
	end

	return result
end

function sam.is_steamid(id, err) -- https://stackoverflow.com/questions/6724268/check-if-input-matches-steam-id-format
	if sam.isstring(id) and id:match("^STEAM_[0-5]:[0-1]:[0-9]+$") ~= nil then
		return true
	else
		return err and error("invalid steamid", 2) or false
	end
end

function sam.is_steamid64(id, err)
	if sam.isstring(id)
		and tonumber(id)
		and id:sub(1, 7) == "7656119"
		and (#id == 17 or #id == 18) then
		return true
	else
		return err and error("invalid steamid64", 2) or false
	end
end

do
	local console = {}

	do
		local return_console = function()
			return "Console"
		end
		for _, v in ipairs({"SteamID", "SteamID64", "Name", "Nick", "Name"}) do
			console[v] = return_console
		end
		setmetatable(console, {
			__tostring = return_console,
			MetaName = "console"
		})
	end

	function console.IsAdmin()
		return true
	end

	function console.IsSuperAdmin()
		return true
	end

	function console:IsUserGroup(name)
		return name == "superadmin"
	end

	function console.GetUserGroup()
		return "superadmin"
	end

	function console.sam_getrank()
		return "superadmin"
	end

	function console.HasPermission()
		return true
	end

	function console.CanTarget()
		return true
	end

	function console.CanTargetRank()
		return true
	end

	function console.GetBanLimit()
		return 0
	end

	function console.SetUserGroup()
	end

	function sam.isconsole(v)
		return v == console
	end

	sam.console = console
end

do
	local times = {
		"year"; 525600,
		"month"; 43800,
		"week"; 10080,
		"day"; 1440,
		"hour"; 60,
		"minute"; 1
	}

	for i = 1, #times, 2 do
		times[i] = " " .. times[i]
	end

	local floor = math.floor
	function sam.format_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "Indefinitely"
		elseif mins <= 1 then
			return "1 minute"
		end

		local str = ""
		for i = 1, #times, 2 do
			local n1, n2 = times[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					if mins == 0 then
						str = str .. " and "
					else
						str = str .. ", "
					end
				end
				str = str .. n2 .. times[i]
				if n2 > 1 then
					str = str .. "s"
				end
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	local times = {
		m = 1,
		h = 60,
		d = 1440,
		w = 10080,
		mo = 43800,
		y = 525600
	}

	function sam.parse_length(length)
		local time, found = tonumber(length), false
		if sam.isnumber(length) then
			time, found = length, true
		elseif time then
			found = true
		else
			time = 0
			for t, u in length:gmatch("(%d+)(%a+)") do
				u = times[u]
				if u then
					time = time + (u * t)
					found = true
				end
			end
		end
		if not found then return false end
		return math.Clamp(time, 0, 31536000)
	end

	local times2 = {}
	for k, v in SortedPairsByValue(times, true) do
		table.insert(times2, k)
		table.insert(times2, v)
	end

	local floor = math.floor
	function sam.reverse_parse_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2, 2 do
			local n1, n2 = times2[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	if SERVER then
		function sam.hook_call(event, ...)
			hook.Call(event, nil, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end

		function sam.client_hook_call(event, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end
	else
		local function hook_call(event, ...)
			hook.Call(event, nil, ...)
		end
		sam.netstream.Hook("HookCall", hook_call)
	end
end

if SERVER then
	local maps = {}

	for k, v in ipairs(file.Find("maps/*.bsp", "GAME")) do
		maps[k] = v:sub(1, -5):lower()
	end

	sam.set_global("Maps", maps)
end

function sam.is_valid_map(name)
	local maps = sam.get_global("Maps")
	if name:sub(-4) == ".bsp" then
		name = name:sub(1, -5)
	end
	name = name:lower()
	for i = 1, #maps do
		if maps[i] == name then
			return name
		end
	end
	return false
end

function sam.is_valid_gamemode(name)
	name = name:lower()
	local gamemodes = engine.GetGamemodes()
	for i = 1, #gamemodes do
		local gamemode = gamemodes[i]
		if sam.isstring(gamemode.name) and gamemode.name:lower() == name then
			return true
		end
	end
	return false
end

function sam.hook_first(event, name, func)
	if HOOK_HIGH then
		return hook.Add(event, name, func, HOOK_HIGH)
	end

	return hook.Add(event, name, func)
end

function sam.hook_last(event, name, func)
	if HOOK_LOW then
		return hook.Add(event, name, func, HOOK_LOW)
	end

	return hook.Add(event, name, func)
end
--addons/sam/lua/sam/ranks/sh_ranks.lua:
if SAM_LOADED then return end

SAM_IMMUNITY_SUPERADMIN = 100
SAM_IMMUNITY_ADMIN = 50
SAM_IMMUNITY_USER = 1

function sam.ranks.get_ranks()
	return sam.get_global("Ranks")
end

function sam.ranks.get_rank(rank)
	local ranks = sam.ranks.get_ranks()
	return ranks[rank]
end

function sam.ranks.is_rank(rank)
	if sam.ranks.get_rank(rank) then
		return true
	else
		return false
	end
end

function sam.ranks.is_default_rank(rank)
	return rank == "superadmin" or rank == "admin" or rank == "user"
end

function sam.ranks.inherits_from(rank, rank_2)
	if rank == rank_2 then
		return true
	end

	while true do
		rank = sam.ranks.get_rank(rank)

		if rank then
			local inherits_from = rank.inherit
			if inherits_from == rank_2 then
				return true
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.has_permission(rank, permission)
	while true do
		if rank == "superadmin" then
			return true
		end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local rank_permission = rank.data.permissions[permission]
			if rank_permission ~= nil then
				return rank_permission
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.get_limit(rank, limit_type)
	while true do
		if rank == "superadmin" then return -1 end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local limit = rank.data.limits[limit_type]
			if limit ~= nil then
				return limit
			end

			rank = rank.inherit
		else
			return cvars.Number("sbox_max" .. limit_type, 0)
		end
	end
end

function sam.ranks.get_immunity(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.immunity or false
end

function sam.ranks.can_target(rank_1, rank_2)
	rank_1, rank_2 = sam.ranks.get_rank(rank_1), sam.ranks.get_rank(rank_2)
	if not rank_1 or not rank_2 then
		return false
	end
	return rank_1.immunity >= rank_2.immunity
end

function sam.ranks.get_ban_limit(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.ban_limit or false
end

if CLIENT then
	hook.Add("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks", function(key, value)
		if key == "Ranks" then
			hook.Call("SAM.LoadedRanks", nil, value)
			hook.Remove("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks")
		end
	end)
end
--addons/sam/lua/sam/player/sh_player.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

do
	local _player = {}
	sam.player = setmetatable(sam.player, {
		__index = _player,
		__newindex = function(_, k, v)
			_player[k] = v
			if sam.isfunction(v) and debug.getlocal(v, 1) == "ply" then
				FindMetaTable("Player")["sam_" .. k] = v
				sam.console["sam_" .. k] = v
			end
		end
	})
end

function sam.player.find_by_name(name)
	name = name:lower()
	local current, players = nil, player.GetAll()
	for i = 1, #players do
		local ply = players[i]
		local found = ply:Name():lower():find(name, 1, true)
		if found then
			if current then
				if not sam.istable(current) then
					current = {current, ply}
				else
					table.insert(current, ply)
				end
			else
				current = ply
			end
		end
	end
	return current
end

do
	if CLIENT then
		config.add_menu_setting("Chat Prefix (Leave empty for no prefix)", function()
			local entry = vgui.Create("SAM.TextEntry")
			entry:SetPlaceholder("")
			entry:SetNoBar(true)
			entry:SetConfig("ChatPrefix", "")

			return entry
		end)
	end

	function sam.player.send_message(ply, msg, tbl)
		if SERVER then
			if sam.isconsole(ply) then
				local result = sam.format_message(msg, tbl)
				sam.print(unpack(result, 1, result.__cnt))
			else
				return sam.netstream.Start(ply, "send_message", msg, tbl)
			end
		else
			local prefix_result = sam.format_message(config.get("ChatPrefix", ""))
			local prefix_n = #prefix_result

			local result = sam.format_message(msg, tbl, prefix_result, prefix_n)
			chat.AddText(unpack(result, 1, result.__cnt))
		end
	end

	if SERVER then
		function sam.player.add_text(ply, ...)
			if sam.isconsole(ply) then
				sam.print(...)
			else
				sam.netstream.Start(ply, "add_text", ...)
			end
		end
	end

	if CLIENT then
		sam.netstream.Hook("send_message", function(msg, tbl)
			sam.player.send_message(nil, msg, tbl)
		end)

		sam.netstream.Hook("add_text", function(...)
			chat.AddText(...)
		end)
	end
end

do
	local PLAYER = FindMetaTable("Player")

	function PLAYER:IsAdmin()
		return self:CheckGroup("admin")
	end

	function PLAYER:IsSuperAdmin()
		return self:CheckGroup("superadmin")
	end

	local inherits_from = sam.ranks.inherits_from
	function PLAYER:CheckGroup(name)
		return inherits_from(self:sam_getrank(), name)
	end

	local has_permission = sam.ranks.has_permission
	function PLAYER:HasPermission(perm)
		return has_permission(self:sam_getrank(), perm)
	end

	local can_target = sam.ranks.can_target
	function PLAYER:CanTarget(ply)
		return can_target(self:sam_getrank(), ply:sam_getrank())
	end

	function PLAYER:CanTargetRank(rank)
		return can_target(self:sam_getrank(), rank)
	end

	local get_ban_limit = sam.ranks.get_ban_limit
	function PLAYER:GetBanLimit(ply)
		return get_ban_limit(self:sam_getrank())
	end

	function PLAYER:sam_get_play_time()
		return self:sam_get_nwvar("play_time", 0) + self:sam_get_session_time()
	end

	function PLAYER:sam_get_session_time()
		return os.time() - self:sam_get_nwvar("join_time", 0)
	end

	function PLAYER:sam_getrank()
		return self:sam_get_nwvar("rank", "user")
	end

	function PLAYER:sam_setrank(name)
		return self:sam_set_nwvar("rank", name)
	end

	if SERVER then
		function PLAYER:Ban(length)
			self:sam_ban(length)
		end

		hook.Remove("PlayerInitialSpawn", "PlayerAuthSpawn")
	end
end

do
	local set_cooldown = function(ply, name, time)
		if not ply.sam_cool_downs then
			ply.sam_cool_downs = {}
		end
		ply.sam_cool_downs[name] = SysTime() + time
		return true
	end

	function sam.player.check_cooldown(ply, name, time)
		if not ply.sam_cool_downs or not ply.sam_cool_downs[name] then
			return set_cooldown(ply, name, time)
		end

		local current_time = SysTime()
		local cool_down = ply.sam_cool_downs[name]
		if cool_down > current_time then
			return false, cool_down - current_time
		else
			return set_cooldown(ply, name, time)
		end
	end
end
--addons/sam/lua/sam/player/cl_player.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream

netstream.Hook("PlaySound", function(sound)
	surface.PlaySound(sound)
end)
--addons/sam/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--addons/sam/lua/sam/command/arguments/length.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_length = function(arg, input)
	if (input == "" or input == nil) and arg.optional then
		if arg.default ~= nil then
			return arg.default
		end

		return ""
	end

	return sam.parse_length(input)
end

command.new_argument("length")
	:OnExecute(function(arg, input, ply, _, result, i)
		local length = get_length(arg, input)
		if length == "" then
			result[i] = nil
		elseif not length then
			ply:sam_send_message("invalid", {
				S = "length", S_2 = input
			})
			return false
		else
			if arg.min and length ~= 0 then
				length = math.max(length, arg.min)
			end

			if arg.max then
				if length == 0 then
					length = arg.max
				else
					length = math.min(length, arg.max)
				end
			end

			result[i] = length
		end
	end)

	:Menu(function(set_result, body, buttons, argument)
		local length_input = buttons:Add("SAM.TextEntry")
		length_input:SetTall(25)

		length_input:SetCheck(function(new_limit)
			new_limit = get_length(argument, new_limit) or nil
			set_result(new_limit)
			return new_limit or false
		end)

		local hint = argument.hint or "length"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end

		length_input:SetPlaceholder(hint)
		return length_input
	end)
:End()
--addons/sam/lua/sam/command/arguments/map.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("map")
	:OnExecute(function(argument, input, ply, _, result)
		local map_name = sam.is_valid_map(input)
		if not map_name and not (argument.optional and input == "None") then
			ply:sam_send_message("invalid", {
				S = "map", S_2 = input
			})
			return false
		end

		table.insert(result, map_name)
	end)

	:Menu(function(set_result, _, buttons, argument)
		local maps = buttons:Add("SAM.ComboBox")
		maps:SetTall(25)

		if argument.optional then
			maps:AddChoice("None", nil, true)
		end

		for _, map_name in ipairs(sam.get_global("Maps")) do
			if not (argument.exclude_current and map_name == game.GetMap()) then
				maps:AddChoice(map_name)
			end
		end

		function maps:OnSelect(_, value)
			set_result(value)
		end

		local value = argument.optional and "None" or maps:GetOptionText(1)
		maps:SetValue(value)
		maps:OnSelect(nil, value)

		return maps
	end)

	:AutoComplete(function(_, result, name)
		for _, map_name in ipairs(sam.get_global("Maps")) do
			if map_name:lower():find(name, 1, true) then
				table.insert(result, map_name)
			end
		end
	end)
:End()
--addons/sam/lua/sam/command/arguments/player.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local can_target_player = function(arg, admin, target, cmd, input)
	if not IsValid(target) or not target:IsPlayer() or not target:sam_get_nwvar("is_authed") then
		if input then
			admin:sam_send_message("cant_find_target", {
				S = input
			})
		end
		return false
	end

	if not arg.allow_higher_target and not admin:CanTarget(target) then
		if cmd then
			admin:sam_send_message("cant_target_player", {
				S = target:Name()
			})
		end
		return false
	end

	if arg.cant_target_self and admin == target then
		if cmd then
			admin:sam_send_message("cant_target_self", {
				S = cmd.name
			})
		end
		return false
	end

	return true
end

local check_text_match = function(text, ply)
	if ply:Name():lower():find(text, 1, true) then return true end
	if ply:sam_getrank():lower():find(text, 1, true) then return true end
	if team.GetName(ply:Team()):lower():find(text, 1, true) then return true end

	if not ply:IsBot() then
		return ply:SteamID():lower():find(text, 1, true) or ply:SteamID64():lower():find(text, 1, true)
	end

	return false
end

command.new_argument("player")
	:OnExecute(function(arg, input, ply, cmd, result, n)
		if input == nil and arg.optional then
			if sam.isconsole(ply) then
				ply:sam_send_message("cant_target_self", {
					S = cmd.name
				})
				return false
			end
			result[n] = {ply, admin = ply, input = input}
			return
		end

		local single_target = arg.single_target
		local targets = {admin = ply, input = input}

		if input == "*" then
			if single_target then
				ply:sam_send_message("cant_target_multi_players")
				return false
			end
			local players = player.GetAll()
			for i = 1, #players do
				local v = players[i]
				if can_target_player(arg, ply, v) then
					table.insert(targets, v)
				end
			end
		elseif input:sub(1, 1) == "#" and not single_target then
			local tmp = {}
			for _, v in ipairs(input:sub(2):Trim():Split(",")) do
				v = tonumber(v)
				if not sam.isnumber(v) then continue end
				local target = Entity(v)
				if not tmp[target] and IsValid(target) and target:IsPlayer() then
					tmp[target] = true
					if can_target_player(arg, ply, target) then
						table.insert(targets, target)
					end
				end
			end
		else
			local target
			if input == "^" then
				target = ply
			elseif input == "@" and not sam.isconsole(ply) then
				target = ply:GetEyeTrace().Entity
			elseif sam.is_steamid(input) then
				target = player.GetBySteamID(input)
			elseif sam.is_steamid64(input) then
				target = player.GetBySteamID64(input)
			elseif input:sub(1, 1) == "#" then
				local index = input:sub(2):Trim()
				index = tonumber(index)

				if not isnumber(index) then
					ply:sam_send_message("invalid_id", {
						S = input
					})
					return false
				end

				target = Entity(index)

				if not IsValid(target) or not target:IsPlayer() then
					ply:sam_send_message("player_id_not_found", {
						S = index
					})
					return false
				end
			else
				if input:sub(1, 1) == "%" and #input > 1 then
					input = input:sub(2)
				end

				target = sam.player.find_by_name(input)
				if sam.istable(target) then
					if single_target then
						ply:sam_send_message("found_multi_players", {T = target})
						return false
					else
						for k, v in ipairs(target) do
							if can_target_player(arg, ply, v) then
								table.insert(targets, v)
							end
						end
						goto _end
					end
				end
			end

			if not can_target_player(arg, ply, target, cmd, input) then
				return false
			end

			table.insert(targets, target)
		end

		::_end::

		if #targets == 0 then
			ply:sam_send_message("cant_find_target", {
				S = input
			})
			return false
		end
		result[n] = targets
	end)

	-- Do NOT ask me about this code at all please because I feel shit about it but I'm not gonna make
	-- a file specially for this one
	:Menu(function(set_result, body, buttons, argument, childs)
		if body.ply_list then
			local ply_list = body.ply_list
			ply_list.argument = argument
			ply_list.set_result = set_result
			ply_list.multi_select = argument.single_target ~= true

			if argument.single_target == true and #ply_list:GetSelected() > 1 then
				ply_list:ClearSelection()
			end

			ply_list:OnRowSelected()
			ply_list:GetParent():Show()

			return
		end

		local SUI = sam.SUI

		local SetVisible = FindMetaTable("Panel").SetVisible

		local left_body = body:Add("SAM.Panel")
		left_body:Dock(LEFT)
		left_body:DockMargin(0, 0, 5, 0)
		left_body:SetWide(0)
		left_body.no_remove = true
		left_body.no_change = "player"

		SetVisible(left_body, false)
		left_body.SetVisible = function(s, visible)
			if visible == s:IsVisible() or visible == s.visible_state then return end

			if visible then
				SetVisible(s, true)
				s:InvalidateLayout(true)
			end

			s.visible_state = visible
			s:Stop()

			s:SizeTo(visible and SUI.Scale(320) or 0, -1, 0.2, 0, 0, function()
				SetVisible(s, visible)
				s:InvalidateParent(true)
			end)
		end
		left_body:Show()

		table.insert(childs, left_body)

		local ply_list = left_body:Add("SAM.ScrollPanel")
		ply_list:Dock(FILL)
		ply_list:Background(Color(34, 34, 34), 3)
		ply_list.argument = argument
		ply_list.set_result = set_result
		ply_list.multi_select = argument.single_target ~= true
		ply_list.Paint = function(s, w, h)
			s:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("text_entry_bg"))
		end

		local lines = {}
		function ply_list:OnClickLine(line, clear)
			local multi_select = ply_list.multi_select
			if not multi_select and not clear then return end

			if multi_select and input.IsKeyDown(KEY_LCONTROL) then
				if line.Selected then
					line.Selected = false
					self.main_selected_line = nil
					self:OnRowSelected()
					return
				end
				clear = false
			end

			if multi_select and input.IsKeyDown(KEY_LSHIFT) then
				local selected = self:GetSelectedLine()
				if selected then
					self.main_selected_line = self.main_selected_line or selected

					if clear then
						self:ClearSelection()
					end

					local first = math.min(self.main_selected_line.id, line.id)
					local last = math.max(self.main_selected_line.id, line.id)

					for id = first, last do
						local line_2 = lines[id]
						local was_selected = line_2.Selected

						line_2.Selected = true

						if not was_selected then
							self:OnRowSelected(line_2.id, line_2)
						end
					end

					return
				end
			end

			if not multi_select or clear then
				self:ClearSelection()
			end

			line.Selected = true

			self.main_selected_line = line
			self:OnRowSelected(line.id, line)
		end

		function ply_list:GetSelected()
			local ret = {}
			for _, v in ipairs(lines) do
				if v.Selected then
					table.insert(ret, v)
				end
			end
			return ret
		end

		function ply_list:GetSelectedLine()
			for _, line in ipairs(lines) do
				if line.Selected then return line end
			end
		end

		function ply_list:ClearSelection()
			for _, line in ipairs(lines) do
				line.Selected = false
			end
			self:OnRowSelected()
		end

		function ply_list:OnRowSelected()
			local plys = {}
			for k, v in ipairs(ply_list:GetSelected()) do
				plys[k] = v.ply:EntIndex()
			end
			if #plys == 0 then
				self.set_result(nil)
			else
				self.set_result("#" .. table.concat(plys, ","))
			end
		end

		function ply_list:OnRowRightClick(_, line)
			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetInternal(line)

			local name = line.ply:Name()
			dmenu:AddOption("Copy Name", function()
				SetClipboardText(name)
			end)

			dmenu:AddSpacer()

			local steamid = line.ply:SteamID()
			dmenu:AddOption("Copy SteamID", function()
				SetClipboardText(steamid)
			end)

			dmenu:AddOption("Copy SteamID64", function()
				SetClipboardText(util.SteamIDTo64(steamid))
			end)

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		local item_click = function(s)
			ply_list:OnClickLine(s, true)
		end

		local item_rightclick = function(s)
			if not s.Selected then
				ply_list:OnClickLine(s, true)
			end
			ply_list:OnRowRightClick(s.id, s)
		end

		local item_cursor = function(s)
			if input.IsMouseDown(MOUSE_LEFT) then
				ply_list:OnClickLine(s)
			end
		end

		local added_players = {}

		local add_player = function(ply, i)
			if can_target_player(ply_list.argument, LocalPlayer(), ply) then
				local player_button = ply_list:Add("SAM.Button")
				player_button:Dock(TOP)
				player_button:DockMargin(0, 0, 0, 2)
				player_button:DockPadding(4, 4, 4, 4)
				player_button:SetContained(false)
				player_button:SetText("")
				player_button:SetZPos(i)
				player_button.DoClick = item_click
				player_button.DoRightClick = item_rightclick
				player_button.OnCursorMoved = item_cursor

				local line = player_button:Add("SAM.PlayerLine")
				line:SetMouseInputEnabled(false)
				line:SetInfo({
					steamid = ply:IsBot() and "BOT" or ply:SteamID(),
					name = ply:Name(),
					rank = ply:sam_getrank()
				})

				player_button:InvalidateLayout(true)
				player_button:SizeToChildren(false, true)

				player_button.ply = ply
				player_button.line = line
				player_button.id = table.insert(lines, player_button)
				body.search_entry:OnValueChange()

				added_players[ply] = true
			end
		end

		ply_list:On("Think", function()
			local players = player.GetAll()
			for i = 1, #players do
				local ply = players[i]
				if not added_players[ply] then
					add_player(ply, i)
				end
			end

			local argument = ply_list.argument
			for i = 1, #lines do
				local line = lines[i]
				local ply = line.ply

				if not can_target_player(argument, LocalPlayer(), ply) then
					line:Remove()
					table.remove(lines, i)
					added_players[ply] = nil
					ply_list:OnRowSelected()
					break
				end

				line = line.line
				line:SetName(ply:Name())
				line:SetRank(ply:sam_getrank())
			end
		end)

		local search_entry = left_body:Add("SAM.TextEntry")
		search_entry:Dock(TOP)
		search_entry:DockMargin(0, 0, 0, 5)
		search_entry:SetPlaceholder("Search... (name/steamid/rank/job)")
		search_entry:SetBackground(Color(34, 34, 34))
		search_entry:SetTall(25)
		search_entry:SetNoBar(true)

		function search_entry:OnValueChange(text)
			if text == nil then
				text = self:GetValue()
			end
			if text ~= "" then
				ply_list:ClearSelection()
			end
			text = text:lower()
			for i, line in ipairs(lines) do
				local ply = line.ply
				if IsValid(ply) then
					line:SetVisible(check_text_match(text, ply))
				end
			end
			ply_list:GetCanvas():InvalidateLayout(true)
		end

		body.ply_list = ply_list
		body.search_entry = search_entry
	end)

	:AutoComplete(function(arg, result, name)
		local ply = LocalPlayer()
		for k, v in ipairs(player.GetAll()) do
			if can_target_player(arg, ply, v) and v:Name():lower():find(name, 1, true) then
				table.insert(result, "%" .. v:Name())
			end
		end
	end)
:End()
--addons/sam/lua/sam/command/arguments/steamid.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local cached_ranks = {}
local targeting_offline = {}

local check_steamid = function(steamid)
	if not sam.is_steamid(steamid) then
		if sam.is_steamid64(steamid) then
			return util.SteamIDFrom64(steamid)
		else
			return nil
		end
	end

	return steamid
end

local can_target_steamid_callback = function(data, promise)
	local ply, steamid = promise.ply, promise.steamid

	if not data or sam.ranks.can_target(promise.rank, data.rank) then
		promise:resolve({steamid})
	elseif IsValid(ply) then
		ply:sam_send_message("cant_target_player", {
			S = steamid
		})
	end

	targeting_offline[ply] = nil
	cached_ranks[steamid] = data ~= nil and data or false
end

command.new_argument("steamid")
	:OnExecute(function(argument, input, ply, _, result, i)
		local steamid = check_steamid(input)
		if not steamid then
			ply:sam_send_message("invalid", {
				S = "steamid/steamid64", S_2 = input
			})
			return false
		end

		if argument.allow_higher_target then
			result[i] = steamid
			return
		end

		local promise = sam.Promise.new()
		promise.ply = ply
		promise.rank = ply:sam_getrank()
		promise.steamid = steamid

		local target = player.GetBySteamID(steamid)
		if sam.isconsole(ply) then
			promise:resolve({steamid})
		elseif target then
			if ply:CanTarget(target) then
				promise:resolve({steamid, target})
			else
				ply:sam_send_message("cant_target_player", {
					S = steamid
				})
			end
		elseif cached_ranks[steamid] ~= nil then
			can_target_steamid_callback(cached_ranks[steamid], promise)
		else
			targeting_offline[ply] = true

			sam.SQL.FQuery([[
				SELECT
					`rank`
				FROM
					`sam_players`
				WHERE
					`steamid` = {1}
			]], {steamid}, can_target_steamid_callback, true, promise)
		end

		result[i] = promise
	end)
	:Menu(function(set_result, body, buttons, argument)
		local steamid_entry = buttons:Add("SAM.TextEntry")
		steamid_entry:SetTall(25)
		steamid_entry:SetUpdateOnType(true)
		steamid_entry:SetPlaceholder("steamid/steamid64")

		steamid_entry:SetCheck(function(steamid)
			steamid = check_steamid(steamid)
			set_result(steamid)
			return steamid or false
		end)

		return steamid_entry
	end)
:End()

timer.Create("SAM.ClearCachedRanks", 60 * 2.5, 0, function()
	table.Empty(cached_ranks)
end)

hook.Add("SAM.ChangedSteamIDRank", "RemoveIfCached", function(steamid)
	cached_ranks[steamid] = nil
end)

hook.Add("SAM.CanRunCommand", "StopIfTargetingOffline", function(ply)
	if targeting_offline[ply] then
		return false
	end
end)
--addons/sam/lua/sam/command/arguments/text.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("text")
	:OnExecute(function(argument, input, ply, _, result, i)
		if sam.isstring(input) then
			input = input:sub(1, 255)
		end

		local invalid = false
		if input == nil then
			if not argument.optional then
				invalid = true
			end
		elseif argument.check and not argument.check(input, ply) then
			invalid = true
		end

		if invalid then
			ply:sam_send_message("invalid", {
				S = argument.hint or "text", S_2 = input
			})
			return false
		end

		result[i] = input
	end)
	:Menu(function(set_result, body, buttons, argument)
		local text_entry = buttons:Add("SAM.TextEntry")
		text_entry:SetTall(25)

		local default = argument.default
		text_entry:SetCheck(function(text)
			local valid = true
			if text == "" then
				if default then
					text = default
				elseif not argument.optional then
					valid = false
				end
			elseif argument.check and not argument.check(text, LocalPlayer()) then
				valid = false
			end

			set_result(valid and text or nil)

			return valid
		end)

		local hint = argument.hint or "text"
		if default then
			hint = hint .. " = " .. tostring(default)
		end

		text_entry:SetPlaceholder(hint)

		return text_entry
	end)
:End()
--addons/sui/lua/sui/libs/bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("sui_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("sui_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "SUI.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("sui_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("sui_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

sui.BSHADOWS = BSHADOWS
--addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--addons/sam/lua/sam/modules/darkrp.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

add("PostGamemodeLoaded", "SAM.DarkRP", function()
	if not DarkRP then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("DarkRP")

	command.new("arrest")
		:SetPermission("arrest", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "time", optional = true, min = 0, default = 0, round = true})

		:Help("arrest_help")

		:OnExecute(function(ply, targets, time)
			if time == 0 then
				time = math.huge
			end

			for i = 1, #targets do
				local v = targets[i]
				if v:isArrested() then
					v:unArrest()
				end
				v:arrest(time, ply)
			end

			if time == math.huge then
				sam.player.send_message(nil, "arrest", {
					A = ply, T = targets
				})
			else
				sam.player.send_message(nil, "arrest2", {
					A = ply, T = targets, V = time
				})
			end
		end)
	:End()

	command.new("unarrest")
		:SetPermission("unarrest", "superadmin")

		:AddArg("player", {optional = true})

		:Help("unarrest_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:unArrest()
			end

			sam.player.send_message(nil, "unarrest", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setmoney")
		:SetPermission("setmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("setmoney_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]

			amount = hook.Call("playerWalletChanged", GAMEMODE, target, amount - target:getDarkRPVar("money"), target:getDarkRPVar("money")) or amount

			DarkRP.storeMoney(target, amount)
			target:setDarkRPVar("money", amount)

			sam.player.send_message(nil, "setmoney", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("addmoney")
		:SetPermission("addmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("addmoney_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:addMoney(amount)

			sam.player.send_message(nil, "addmoney", {
				A = ply, T = targets, V = DarkRP.formatMoney(amount)
			})
		end)
	:End()

	command.new("selldoor")
		:SetPermission("selldoor", "superadmin")

		:Help("selldoor_help")

		:OnExecute(function(ply)
			local ent = ply:GetEyeTrace().Entity
			if not IsValid(ent) or not ent.keysUnOwn then
				return ply:sam_send_message("door_invalid")
			end
			local door_owner = ent:getDoorOwner()
			if not IsValid(door_owner) then
				return ply:sam_send_message("door_no_owner")
			end
			ent:keysUnOwn(ply)

			sam.player.send_message(nil, "selldoor", {
				A = ply, T = {door_owner, admin = ply}
			})
		end)
	:End()

	command.new("sellall")
		:SetPermission("sellall", "superadmin")

		:AddArg("player", {single_target = true})

		:Help("sellall_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:keysUnOwnAll()

			sam.player.send_message(nil, "sellall", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setjailpos")
		:SetPermission("setjailpos", "superadmin")

		:Help("setjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, false)

			sam.player.send_message(nil, "s_jail_pos", {
				A = ply
			})
		end)
	:End()

	command.new("addjailpos")
		:SetPermission("addjailpos", "superadmin")

		:Help("addjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, true)

			sam.player.send_message(nil, "a_jail_pos", {
				A = ply
			})
		end)
	:End()

	local RPExtraTeams = RPExtraTeams
	local job_index = nil

	command.new("setjob")
		:SetPermission("setjob", "admin")

		:AddArg("player")
		:AddArg("text", {hint = "job", check = function(job)
			job = job:lower()

			for i = 1, #RPExtraTeams do
				local v = RPExtraTeams[i]
				if v.name:lower() == job or v.command:lower() == job then
					job_index = v.team
					return true
				end
			end

			return false
		end})

		:Help("setjob_help")

		:OnExecute(function(ply, targets, job)
			for i = 1, #targets do
				targets[i]:changeTeam(job_index, true, true, true)
			end

			sam.player.send_message(nil, "setjob", {
				A = ply, T = targets, V = job
			})
		end)
	:End()

	do
		local get_shipment = function(name)
			local found, key = DarkRP.getShipmentByName(name)
			if found then return found, key end

			name = name:lower()

			local shipments = CustomShipments
			for i = 1, #shipments do
				local shipment = shipments[i]
				if shipment.entity == name then
					return DarkRP.getShipmentByName(shipment.name)
				end
			end

			return false
		end

		local place_entity = function(ent, tr, ply)
			local ang = ply:EyeAngles()
			ang.pitch = 0
			ang.yaw = ang.yaw - 90
			ang.roll = 0
			ent:SetAngles(ang)

			local flush_point = tr.HitPos - (tr.HitNormal * 512)
			flush_point = ent:NearestPoint(flush_point)
			flush_point = ent:GetPos() - flush_point
			flush_point = tr.HitPos + flush_point
			ent:SetPos(flush_point)
		end

		command.new("shipment")
			:SetPermission("shipment", "superadmin")

			:AddArg("text", {hint = "weapon", check = get_shipment})

			:Help("shipment_help")

			:OnExecute(function(ply, weapon_name)
				local trace = {}
				trace.start = ply:EyePos()
				trace.endpos = trace.start + ply:GetAimVector() * 85
				trace.filter = ply
				local tr = util.TraceLine(trace)

				local shipment_info, shipment_key = get_shipment(weapon_name)

				local crate = ents.Create(shipment_info.shipmentClass or "spawned_shipment")
				crate.SID = ply.SID

				crate:Setowning_ent(ply)
				crate:SetContents(shipment_key, shipment_info.amount)

				crate:SetPos(Vector(tr.HitPos.x, tr.HitPos.y, tr.HitPos.z))

				crate.nodupe = true
				crate.ammoadd = shipment_info.spareammo
				crate.clip1 = shipment_info.clip1
				crate.clip2 = shipment_info.clip2

				crate:Spawn()
				crate:SetPlayer(ply)

				place_entity(crate, tr, ply)

				local phys = crate:GetPhysicsObject()
				phys:Wake()

				if shipment_info.weight then
					phys:SetMass(shipment_info.weight)
				end

				sam.player.send_message(nil, "shipment", {
					A = ply, V = weapon_name
				})
			end)
		:End()
	end

	sam.command.new("forcename")
		:SetPermission("forcename", "superadmin")

		:AddArg("player")
		:AddArg("text", {hint = "name"})

		:Help("forcename_help")

		:OnExecute(function(ply, targets, name)
			local target = targets[1]

			DarkRP.retrieveRPNames(name, function(taken)
				if not IsValid(target) then return end

				if taken then
					ply:sam_send_message("forcename_taken", {
						V = name
					})
					return
				end

				sam.player.send_message(nil, "forcename", {
					A = ply, T = targets, V = name
				})

				DarkRP.storeRPName(target, name)
				target:setDarkRPVar("rpname", name)
			end)
		end)
	:End()
end)
--addons/sam/lua/sam/modules/user.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("User Management")

command.new("setrank")
	:Aliases("adduser", "changerank", "giverank")

	:SetPermission("setrank")

	:AddArg("player", {single_target = true})
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrank_help")

	:OnExecute(function(ply, targets, rank, length)
		targets[1]:sam_set_rank(rank, length)

		sam.player.send_message(nil, "setrank", {
			A = ply, T = targets, V = rank, V_2 = sam.format_length(length)
		})
	end)
:End()

command.new("setrankid")
	:Aliases("adduserid", "changerankid", "giverankid")

	:SetPermission("setrankid")

	:AddArg("steamid")
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrankid_help")

	:OnExecute(function(ply, promise, rank, length)
		local a_name = ply:Name()

		promise:done(function(data)
			local steamid, target = data[1], data[2]
			if target then
				target:sam_set_rank(rank, length)

				sam.player.send_message(nil, "setrank", {
					A = ply, T = {target, admin = ply}, V = rank, V_2 = sam.format_length(length)
				})
			else
				sam.player.set_rank_id(steamid, rank, length)

				sam.player.send_message(nil, "setrank", {
					A = a_name, T = steamid, V = rank, V_2 = sam.format_length(length)
				})
			end
		end)
	end)
:End()

command.new("addrank")
	:SetPermission("manage_ranks")

	:AddArg("text", {hint = "rank name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})
	:AddArg("rank", {hint = "inherit from"})
	:AddArg("number", {hint = "immunity", min = 2, max = 99, optional = true})
	:AddArg("length", {hint = "ban limit", optional = true})

	:Help("addrank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit, immunity, ban_limit)
		sam.ranks.add_rank(rank, inherit, immunity, ban_limit)

		sam.player.send_message(ply, "addrank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("removerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})

	:Help("removerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank)
		sam.ranks.remove_rank(rank)

		sam.player.send_message(ply, "removerank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("renamerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})
	:AddArg("text", {hint = "new name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})

	:Help("renamerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_name)
		sam.ranks.rename_rank(rank, new_name)

		sam.player.send_message(ply, "renamerank", {
			A = ply, T = rank, V = new_name
		})
	end)
:End()

command.new("changeinherit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("rank", {hint = "inherits from"})

	:Help("changeinherit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit)
		if rank == inherit then return end

		sam.ranks.change_inherit(rank, inherit)

		sam.player.send_message(ply, "changeinherit", {
			A = ply, T = rank, V = inherit
		})
	end)
:End()

command.new("changerankimmunity")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("number", {hint = "new immunity", min = 2, max = 99})

	:Help("changerankimmunity_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_immunity)
		sam.ranks.change_immunity(rank, new_immunity)

		sam.player.send_message(ply, "rank_immunity", {
			A = ply, T = rank, V = new_immunity
		})
	end)
:End()

command.new("changerankbanlimit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "superadmin"
	end})
	:AddArg("length")

	:Help("changerankbanlimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_limit)
		sam.ranks.change_ban_limit(rank, new_limit)

		sam.player.send_message(ply, "rank_ban_limit", {
			A = ply, T = rank, V = sam.format_length(new_limit)
		})
	end)
:End()

command.new("givepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("givepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.give_permission(rank, permission)

		sam.player.send_message(ply, "giveaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("takepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("takepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.take_permission(rank, permission)

		sam.player.send_message(ply, "takeaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("changeranklimit")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "limit"})
	:AddArg("number", {hint = "value"})

	:Help("changeranklimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, limit, value)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.set_limit(rank, limit, value)

		sam.player.send_message(ply, "changeranklimit", {
			A = ply, T = rank, V = limit, V_2 = value
		})
	end)
:End()
--addons/sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--addons/sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--addons/sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--addons/sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--addons/sui/lua/sui/vgui/sui_number_slider.lua:
local surface = surface

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)

function Panel:Init()
	self:ScaleInit()

	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob.circle = {}
	self.Knob.Paint = self.KnobPaint
	self:SetTrapInside(true)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	self.Knob:SetSize(SUI.Scale(12), SUI.Scale(12))
	DSlider.PerformLayout(self, w, h)
end

sui.register("Slider", Panel, "DSlider")
--addons/sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--addons/scb_chatbox/lua/scb/cl_chatbox.lua:
if SCB_LOADED then return end

local draw = draw
local surface = surface
local math = math
local hook = hook
local gui = gui
local net = net

local IsValid = IsValid
local ipairs = ipairs

local color_white = color_white

local scb = scb
local sui = sui
local SUI = scb.SUI
local utf8 = sui.utf8
local language = scb.language

for k, v in ipairs({18, 16, 14}) do
	_G["SCB_" .. v] = SUI.CreateFont(tostring(v), "Roboto", v)
end

scb.pattern = "%{ *([%w_%#%$@%*!]+)([^%{}]-) *%}"

local SetVisible = FindMetaTable("Panel").SetVisible

function scb.open_parsers_menu()
	if IsValid(scb.parsers_menu) then
		return scb.parsers_menu:Remove()
	end

	local text_entry = scb.chatbox.text_entry

	local parsers_menu = vgui.Create("SCB.Frame")
	scb.parsers_menu = parsers_menu

	parsers_menu:Center()
	parsers_menu:MakePopup()
	parsers_menu:SetTitle("SCB | Chat Parsers")
	parsers_menu:AddAnimations(320, 340)

	local parsers_list = parsers_menu:Add("SCB.ScrollPanel")
	parsers_list:Dock(FILL)
	parsers_list:DockMargin(4, 4, 4, 4)
	parsers_list:InvalidateParent(true)
	parsers_list:InvalidateLayout(true)

	for k, v in ipairs(scb.chat_parsers) do
		local parser = parsers_list:Add("DButton")
		parser:Dock(TOP)
		parser:DockMargin(2, 2, 2, 2)
		parser:DockPadding(2, 2, 2, 2)
		parser:InvalidateParent(true)
		parser:SetText("")

		parser:SUI_TDLib()
		parser:ClearPaint()
		parser:Background(SUI.GetColor("on_sheet"), 3)
		parser:FadeHover(SUI.GetColor("on_sheet_hover"), _, 3)

		function parser:DoClick()
			parsers_menu:Remove()
			scb.chatbox:MoveToFront()
			text_entry:RequestFocus()
			text_entry:AddValue(v[3] .. " ")
		end

		local title = parser:Add("SCB.Label")
		title:Dock(TOP)
		title:SetAutoStretchVertical(true)
		title:SetWrap(true)
		title:SetFont(SCB_16)
		title:SetText(v[1])
		title:InvalidateParent(true)

		local example = parser:Add("SCB.ChatLine")
		example:Dock(TOP)
		example:DockMargin(0, 1, 0, 0)
		example:InvalidateParent(true)
		example:InvalidateLayout(true)
		example:Parse(v[2])
		example:SetMouseInputEnabled(false)

		function parser:PerformLayout()
			self:SizeToChildren(false, true)
		end
	end
end

local function invalidate_children(self, recursive)
	local children = self:GetChildren()
	for i = 1, #children do
		if recursive then
			invalidate_children(children[i])
		else
			children[i]:InvalidateLayout(true)
		end
	end
	self:InvalidateLayout(true)
end

function scb.create_chatbox()
	if scb.chatbox then return end

	sui.TDLib.Start()

	local frame = vgui.Create("SCB.Frame", nil, "SCB")
	scb.chatbox = frame

	local c_x = CreateClientConVar("scb_x", sui.scale(18), true, false, "")
	local c_y = CreateClientConVar("scb_y", ScrH() - SUI.Scale(220) - sui.scale(170), true, false, "")
	local c_w = CreateClientConVar("scb_w", 480, true, false, "")
	local c_h = CreateClientConVar("scb_h", 220, true, false, "")

	frame.SetSize = frame.RealSetSize
	-- remove scaling for chatbox
	SUI.RemoveScaleHook(frame)

	frame:SetSizable(true)
	frame:SetMinWidth(SUI.Scale(300))
	frame:SetMinHeight(SUI.Scale(160))
	frame:SetSize(c_w:GetInt(), c_h:GetInt())
	frame:SetPos(c_x:GetInt(), c_y:GetInt())
	frame:ParentToHUD()
	frame:MakePopup()

	frame.title.background_color = true

	local chatbox_title = scb.config.chatbox_title
	frame:SetTitle(chatbox_title)
	if chatbox_title:find("SERVER_NAME") or chatbox_title:find("PLAYER_COUNT") then
		local delay = 2
		local next_run = UnPredictedCurTime()

		frame:On("Think", function(s)
			if UnPredictedCurTime() < next_run then return end
			next_run = UnPredictedCurTime() + delay

			s:SetTitle(chatbox_title:gsub("SERVER_NAME", GetHostName()):gsub("PLAYER_COUNT", player.GetCount()))
		end)
	end

	function frame:OnPosChanged()
		c_x:SetInt(self.x)
		c_y:SetInt(self.y)
	end

	function frame:OnSizeChanged(w, h)
		c_w:SetInt(w)
		c_h:SetInt(h)
	end

	function frame:AddPanelToHide(panel)
		if not self.panels_to_hide then
			self.panels_to_hide = {self}
		end
		table.insert(self.panels_to_hide, panel)
	end

	function frame:SetVisible(visible)
		self.hidden = not visible
		local panels_to_hide = self.panels_to_hide
		for i = 1, #panels_to_hide do
			local v = panels_to_hide[i]
			v.Paint, v.oldPaint = visible and (v.oldPaint or v.Paint) or nil, not visible and v.Paint or nil
			if v.background_color or v.old_bg_color then
				v.background_color, v.old_bg_color = visible and (v.old_bg_color or v.background_color) or nil, not visible and v.background_color or nil
				v:SetBGColor(v.background_color)
			end
		end
		return self.hidden
	end

	function frame:IsVisible()
		return not self.hidden
	end

	frame.close.DoClick = chat.Close

	local scroll_panel = frame:Add("SCB.ScrollPanel")
	scroll_panel:Dock(FILL)
	scroll_panel:DockMargin(4, 4, 4, 0)
	scroll_panel:SetFromBottom(true)

	function scroll_panel:ScrollToBottom()
		self:GetParent():InvalidateLayout(true)
		invalidate_children(self)

		local vbar = self.VBar
		vbar:SetScroll(vbar.CanvasSize)
	end

	local canvas = scroll_panel:GetCanvas()
	canvas:DockPadding(2, 2, 2, 2)

	function scroll_panel:ShouldScrollDown()
		local vbar = self.VBar
		local canvas_size = vbar.CanvasSize
		return frame.hidden or canvas_size == 1 or canvas_size <= vbar.scroll_target
	end

	local count = 0
	local max_messages_convar = GetConVar("scb_max_messages")
	local fixed_width = false
	function scroll_panel:ChildAdded()
		local vbar = self.VBar
		if vbar.Enabled then
			if not fixed_width then
				for k, v in ipairs(canvas.children) do
					if v.ScaleChanged then
						v:ScaleChanged()
					end
				end
				fixed_width = true
				return self:ChildAdded()
			end
		else
			fixed_width = nil
		end

		count = count + 1

		local max = max_messages_convar:GetInt()
		if count <= max then return end

		local down = self:ShouldScrollDown()

		local full_h = 0
		local children = canvas.children
		for i = count, max + 1, -1 do
			local child = children[i - max]
			if not child.being_removed then
				child.being_removed = true
				full_h = full_h + child:GetTotalH()
				child:Remove()

				count = count - 1
			end
		end

		local scroll = vbar.Scroll
		if down then
			vbar.Scroll = scroll - full_h
		else
			vbar.Scroll = scroll - full_h
			vbar.scroll_target = scroll
		end
	end

	frame:InvalidateLayout(true)
	invalidate_children(frame, true)

	local preview = vgui.Create("Panel")
	preview:SetMouseInputEnabled(false)
	preview:ParentToHUD()

	local preview_bg = vgui.Create("Panel")
	preview_bg:ParentToHUD()
	preview_bg:MoveToBack()
	SetVisible(preview_bg, false)

	preview_bg:Blur()
		:Background(Color(50, 50, 50, 200))

	frame:On("PerformLayout", function(s, w, h)
		local f_x, f_y = s:GetPos()
		local new_x, new_y = f_x + ((w / 2) - ((preview.w or 0) / 2)), f_y + h + 4
		preview:SetPos(new_x, new_y)
		preview_bg:SetPos(new_x - 4, new_y - 4)
	end)

	local text_entry = frame:Add("SCB.TextEntry")
	text_entry:Dock(BOTTOM)
	text_entry:DockMargin(4, 4, 4, 4)
	text_entry:SetTall(24)
	text_entry:SetPlaceholder(language.type_something)
	text_entry:SetFont(SCB_18)
	text_entry:SetMultiline(true)
	text_entry:SetVerticalScrollbarEnabled(true)
	text_entry:InvalidateParent(true)
	text_entry:SetMaxChars(512)
	text_entry:SetNoBar(true)
	text_entry.no_scale = true

	if scb.config.hide_language_sign then
		text_entry:SetDrawLanguageID(false)
	end

	function text_entry:OnEnter()
		local txt = self:GetValue()
		if txt == "" then chat.Close() return end
		local length = #txt
		net.Start(frame.bteam ~= 1 and "SCB.SendMessageTeam" or "SCB.SendMessage")
			net.WriteUInt(length, 16)
			net.WriteData(txt, length)
		net.SendToServer()
		self:AddHistory(txt)
		chat.Close()
	end

	local old_Paint = text_entry.Paint
	function text_entry:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function text_entry:OnValueChange(value)
		local down = scroll_panel:ShouldScrollDown()

		-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L3790
		self:SetTall(self:GetNumLines() * (SUI.Scale(18) --[[font size]] + 1) + 1 + 2)

		if down then
			scroll_panel:ScrollToBottom()
		end

		if value == "" then
			gui.InternalKeyCodeTyped(KEY_LEFT)
		end

		hook.Run("ChatTextChanged", value)
	end
	text_entry:OnValueChange("")

	do
		local emojis_table = {
			"grinning", "grin", "joy",
			"smiley", "smile", "sweat_smile",
			"laughing", "innocent", "smiling_imp",
			"wink", "blush", "yum", "relieved",
			"heart_eyes", "sunglasses", "smirk",
			"neutral_face", "expressionless", "unamused",
			"sweat", "pensive", "confused",
			"rage", "partying_face", "cold_face",
			"hot_face", "face_with_cowboy_hat"
		}

		local real_size = 0
		local mat, padding = SUI.Material("scb/emojis/flushed.png"), 3

		local emojis_button = text_entry:Add("DButton")
		emojis_button:SetText("")
		emojis_button:SetMouseInputEnabled(true)
		emojis_button:NoClipping(true)

		function emojis_button:IsActive()
			return self:IsHovered() or IsValid(scb.emojis_menu)
		end

		local inactive_col = Color(175, 175, 175)
		function emojis_button:Paint(w, h)
			surface.SetDrawColor(self:IsActive() and color_white or inactive_col)
			surface.SetMaterial(mat)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, real_size, real_size, 0)
		end

		function emojis_button:OnCursorEntered()
			if not IsValid(scb.emojis_menu) then
				mat = SUI.Material("scb/emojis/" .. emojis_table[math.random(1, #emojis_table)] .. ".png")
			end
		end

		function emojis_button:Think()
			self:MoveToFront()
			real_size = Lerp(RealFrameTime() * 15, real_size, self:IsActive() and SUI.Scale(22) or SUI.Scale(18))
		end

		function emojis_button:DoClick()
			if IsValid(scb.emojis_menu) then
				return self:OnRemove()
			end

			local emojis_menu = vgui.Create("SCB.EmojiList")
			emojis_menu.button = self
			emojis_menu:FixPos()

			scb.emojis_menu = emojis_menu
		end

		function emojis_button:OnRemove()
			if IsValid(scb.emojis_menu) then
				scb.emojis_menu:Remove()
			end
		end

		text_entry:On("PerformLayout", function(s, w, h)
			local size = SUI.ScaleEven(18)
			emojis_button:SetSize(size, size)
			emojis_button:SetPos(w - (size + padding), h / 2 - size / 2)

			local vbar = s:GetChildren()[1]
			if vbar then
				vbar:Hide()
				vbar:SetWide(math.Round(size + padding))
			end
		end)

		frame.emojis_button = emojis_button
		frame:AddPanelToHide(emojis_button)
	end

	-- Message Preview
	text_entry:On("OnValueChange", function(self, value)
		preview:SetWide(SUI.Scale(340))
		preview:Clear()
		SetVisible(preview_bg, false)

		if value == "" then return end

		local line = preview:Add("SCB.ChatLine")
		line:SetPlayer(LocalPlayer())
		line:SetAlpha(255)
		line:Parse(value)
		line:SizeToChildren(true, true)

		preview:SizeToChildren(false, true)
		preview:SetWide(line:GetMessageW())
		preview.w = line:GetMessageW()
		preview_bg:SetSize(preview.w + 8, preview:GetTall() + 8)
		SetVisible(preview_bg, true)
	end)
	--

	-- Emoji Select
	local emoji_list

	local open_emojis_list = function(emoji_name, start, _end)
		local selected_text
		if IsValid(emoji_list) then
			selected_text = emoji_list.selected_emoji and emoji_list.selected_emoji.name
			emoji_list:Remove()
		end

		local emojis = scb.search_emojis(emoji_name)
		if #emojis == 0 then return end

		emoji_list = frame:Add("SCB.EmojisSelect")
		emoji_list:SetWide(text_entry:GetWide())
		emoji_list:SetTextEntry(text_entry)
		emoji_list:SetStartEnd(start, _end)

		for _, v in ipairs(emojis) do
			local emoji = emoji_list:AddEmoji(v.name)
			if emoji.name == selected_text then
				emoji_list.selected_emoji = emoji
			end

			if #emoji_list.emojis == math.floor(SUI.Scale(120) / SUI.Scale(22)) then
				break
			end
		end

		emoji_list:SetPos(text_entry.x, text_entry.y - emoji_list:GetTall())
	end

	local typing_emoji = function()
		local value = text_entry:GetValue()
		local start, _end, emoji_name = 0
		while true do
			start, _end, emoji_name = value:find("%:([%w_]+)", _end)
			if not start then break end
			if utf8.len(value:sub(1, _end)) == text_entry:GetCaretPos() and not value:sub(_end + 1, _end + 1):match("%S") then
				return open_emojis_list(emoji_name:lower(), start, _end)
			end
			_end = _end + 1
		end

		if IsValid(emoji_list) then
			emoji_list:Remove()
		end
	end

	local old = text_entry.OnKeyCodeTyped
	function text_entry:OnKeyCodeTyped(code)
		if frame.hidden then return end

		if code == KEY_BACKQUOTE then
			gui.HideGameUI()
		elseif emoji_list and emoji_list[code] then
			return emoji_list[code](emoji_list)
		elseif code == KEY_ESCAPE then
			gui.HideGameUI()
			chat.Close()
			return
		elseif code == KEY_TAB then
			local text = hook.Run("OnChatTab", self:GetValue())
			if scb.isstring(text) then
				self:SetValue(text)
			end
			self:SetCaretPos(#self:GetValue())
			self:RequestFocus()
			return true
		end

		return old(self, code)
	end

	text_entry:On("OnValueChange", typing_emoji)
	text_entry:On("OnKeyCodeReleased", function(_, code)
		if code == KEY_LEFT or code == KEY_RIGHT then
			typing_emoji()
		end
	end)

	SUI.OnScaleChanged("EmojisListRemove", function()
		if IsValid(emoji_list) then
			emoji_list:Remove()
		end

		timer.Simple(0, function()
			text_entry:OnValueChange(text_entry:GetValue())
		end)
	end)
	--

	local settings = frame:AddHeaderButton("scb/settings.png", "settings", function()
		scb.open_settings()
	end)
	local parsers = frame:AddHeaderButton("scb/mind.png", "settings", function()
		scb.open_parsers_menu()
	end)

	frame:AddPanelToHide(frame.header)
	frame:AddPanelToHide(frame.title)
	frame:AddPanelToHide(frame.close)
	frame:AddPanelToHide(frame.close.image)
	frame:AddPanelToHide(settings)
	frame:AddPanelToHide(settings.image)
	frame:AddPanelToHide(parsers)
	frame:AddPanelToHide(parsers.image)
	frame:AddPanelToHide(scroll_panel)
	frame:AddPanelToHide(scroll_panel.VBar)
	frame:AddPanelToHide(scroll_panel.VBar.btnGrip)
	frame:AddPanelToHide(text_entry)

	frame.scroll_panel = scroll_panel
	frame.text_entry = text_entry

	sui.TDLib.End()
end

SUI.RemoveTheme("Light")

SUI.AddToTheme("Dark", {
	settings = Color(255, 255, 255, 133),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(18, 18, 18),
	emoji_select_menu_selected = Color(200, 200, 200, 1),
})

SUI.AddToTheme("Blur", {
	settings = Color(200, 200, 200),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(50, 50, 50, 230),
	emoji_select_menu_selected = Color(40, 40, 40),
})
--addons/scb_chatbox/lua/scb/cl_overrides.lua:
if SCB_LOADED then return end

local table = table
local gui = gui
local team = team
local chat = chat
local hook = hook

local tonumber = tonumber
local Color = Color
local SetClipboardText = SetClipboardText
local IsValid = IsValid
local date = os.date
local team_GetColor = team.GetColor

local scb = scb
local config = scb.config
local language = scb.language

chat.OldOpen = chat.OldOpen or chat.Open
chat.OldClose = chat.OldClose or chat.Close

-- sometimes default chatbox prevents opening the console???
chat.OldClose()

local TEAM = "(" .. language.team .. ") "

function chat.Open(mode)
	mode = tonumber(mode)

	local dont_open = hook.Run("StartChat", mode ~= 1)
	if dont_open == true then return end

	scb.create_chatbox()

	local chatbox = scb.chatbox
	if chatbox.hidden == false then return end

	chatbox.bteam = mode
	chatbox.text_entry:SetPlaceholder((mode ~= 1 and TEAM or "") .. language.type_something)

	chatbox:SetVisible(true)
	chatbox.text_entry:RequestFocus()
	chatbox.text_entry:InvalidateLayout()
	chatbox:MakePopup()

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		v:Stop()
		v:AlphaTo(255, 0)
	end

	net.Start("SCB.IsTyping")
		net.WriteBool(true)
	net.SendToServer()
end

function chat.Close()
	local chatbox = scb.chatbox
	if not chatbox then return end

	if IsValid(scb.emojis_menu) then
		scb.emojis_menu:Remove()
	end

	chatbox.text_entry:SetValue("")
	chatbox.text_entry:OnTextChanged() -- reset chat history

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		if v.can_hide == nil then
			v:Stop()
			v:AlphaTo(0, 0)
		end
	end

	chatbox:SetVisible(false)
	chatbox:SetMouseInputEnabled(false)
	chatbox:SetKeyboardInputEnabled(false)

	chatbox.scroll_panel:ScrollToBottom()

	hook.Run("FinishChat")

	net.Start("SCB.IsTyping")
		net.WriteBool(false)
	net.SendToServer()
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
function chat.GetChatBoxPos()
	if scb.chatbox then
		return scb.chatbox:GetPos()
	end
	return chat.OldGetChatBoxPos()
end

chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
function chat.GetChatBoxSize()
	if scb.chatbox then
		return scb.chatbox:GetSize()
	end
	return chat.OldGetChatBoxSize()
end

local fade_out_time = GetConVar("scb_message_fade_out_time"):GetFloat()
cvars.AddChangeCallback("scb_message_fade_out_time", function(_, _, value_new)
	fade_out_time = value_new
end)

chat.OldAddText = chat.OldAddText or chat.AddText
local AddText_queue = {}
local allow_parsing = config.parse_in_chat
function chat.AddText(...)
	local args
	if AddText_queue == true then
		args = ...
	else
		chat.OldAddText(...)
		args = {n = select("#", ...), ...}
	end

	if not scb.chatbox then
		table.insert(AddText_queue, args)
		return
	end

	local scroll_panel = scb.chatbox.scroll_panel
	local down = scroll_panel:ShouldScrollDown()

	local line = scroll_panel:Add("SCB.ChatLine")
	line:HideAfterTime(fade_out_time)

	line.parsing = true

	local current_color = line.text_color
	for i = 1, args.n do
		local v = args[i]
		local t = scb.type(v)
		if t == "Color" then
			current_color = v
		elseif t == "string" then
			if allow_parsing then
				line:Parse(v, current_color)
			else
				line:NewLabel(v, current_color)
			end
		elseif scb.isentity(v) and not IsValid(v) and not v:IsWorld() then
			line:NewLabel("NULL", current_color)
		elseif t == "Player" then
			line:NewLabel(v:Name(), team_GetColor(v:Team()))
		elseif t == "Entity" then
			line:NewLabel(v:GetClass(), current_color)
		end
	end

	line.parsing = nil

	line:SizeToChildren(false, true)

	if down then
		scroll_panel:ScrollToBottom()
	end
end

local gamemodes_OnPlayerChat = {}
do
	local add_say = function(key, func)
		gamemodes_OnPlayerChat[key] = func
	end

	local line_DoRightClick = function(s)
		local d_menu = DermaMenu()

		local text = s.text
		d_menu:AddOption(language.copy_text, function()
			SetClipboardText(text)
		end)

		local message = s.message
		d_menu:AddOption(language.copy_message, function()
			SetClipboardText(message)
		end)

		local steamid = s.steamid
		if steamid then
			d_menu:AddSpacer()

			d_menu:AddOption(language.copy_steamid, function()
				SetClipboardText(util.SteamIDFrom64(steamid))
			end)

			d_menu:AddOption(language.copy_steamid64, function()
				SetClipboardText(steamid)
			end)

			d_menu:AddOption(language.show_profile, function()
				gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid)
			end)
		end

		d_menu:AddSpacer()
		local time = s.time
		d_menu:AddOption(language.copy_time, function()
			SetClipboardText(time)
		end)

		d_menu:Open()
		d_menu:MakePopup()
	end

	local show_timestamps = GetConVar("scb_show_timestamps"):GetBool()
	cvars.AddChangeCallback("scb_show_timestamps", function(_, _, value_new)
		show_timestamps = tobool(value_new)
	end)

	local show_avatars = config.enable_avatars and GetConVar("scb_show_avatars"):GetBool() or false
	cvars.AddChangeCallback("scb_show_avatars", function(_, _, value_new)
		show_avatars = tobool(value_new)
	end)

	local default_say = function(ply, text, bteam, is_dead, name_replacement, name_color_replacement, text_color)
		local is_console = not ply:IsValid()

		local scroll_panel = scb.chatbox.scroll_panel
		local down = scroll_panel:ShouldScrollDown()

		local line = scroll_panel:Add("SCB.ChatLine")
		line:HideAfterTime(fade_out_time)

		line.parsing = true
		line.time = date(config.timestamps_format)

		if show_timestamps then
			line:SetFont(SCB_16)
			line:NewLabel(line.time .. " ", Color(164, 164, 164))
			line:SetFont(SCB_18)
		end

		local name, name_color
		if not is_console then
			if show_avatars then
				line:NewAvatar(ply)
			end

			if is_dead then
				line:NewLabel(language.dead, Color(244, 67, 54))
			end

			if bteam then
				line:NewLabel(TEAM, Color(76, 175, 80))
			end

			local tag = ply:SCB_GetTag()
			if tag then
				line.emoji_size = 18
				line:Parse(tag .. " ")
				line.emoji_size = 24
			end

			if name_replacement then
				name = name_replacement
			else
				name = ply:Name()
			end

			if name_color_replacement then
				name_color = name_color_replacement
			else
				name_color = team_GetColor(ply:Team())
			end

			line.steamid = ply:SteamID64()
		else
			line:NewLabel("*")
			name, name_color = language.console, Color(13, 130, 223)
		end

		line:NewLabel(name, name_color)
		line:NewLabel(": ")
		line:SetPlayer(ply)
		line:Parse(text, text_color)

		line.message = text
		line.DoRightClick = line_DoRightClick

		if down then
			scroll_panel:ScrollToBottom()
		end

		chat.OldAddText(Color(164, 164, 164), line.time .. " - ", name_color, name, line.text_color, ": ", text_color, text)

		return true
	end
	add_say(1, default_say)

	add_say("darkrp", function(ply, text, _, is_dead, prefix, col1, col2)
		return default_say(ply, text, false, is_dead, prefix, col1, col2 ~= color_white and col2 or nil)
	end)

	add_say("terrortown", function(ply, text, bteam, is_dead)
		if not IsValid(ply) then
			return default_say(ply, text, bteam, is_dead)
		end

		local is_spec = ply:Team() == TEAM_SPEC
		if is_spec then
			is_dead = true
		end

		if bteam and ((not is_spec and not ply:IsSpecial()) or is_spec) then
			bteam = false
		end

		local name_color
		if ply:GetTraitor() then
			name_color = Color(244, 67, 54)
		elseif ply:GetDetective() then
			name_color = Color(13, 130, 223)
		end

		return default_say(ply, text, bteam, is_dead, nil, name_color)
	end)
end

local OnPlayerChat_queue = {}
hook.Add("OnPlayerChat", "SCB", function(...)
	table.insert(OnPlayerChat_queue, {n = select("#", ...), ...})
	return true
end)

local OnPlayerChat
hook.Add("HUDPaint", "SCB", function()
	chat.Open(1)

	for _, v in ipairs(AddText_queue) do
		AddText_queue = true
		chat.AddText(v)
	end
	AddText_queue = nil

	hook.Remove("OnPlayerChat", "SCB")
	OnPlayerChat = gamemodes_OnPlayerChat[engine.ActiveGamemode()] or gamemodes_OnPlayerChat[1]
	function GAMEMODE:OnPlayerChat(...)
		return OnPlayerChat(...)
	end
	for _, v in ipairs(OnPlayerChat_queue) do
		OnPlayerChat(unpack(v, 1, v.n))
	end
	OnPlayerChat_queue = nil

	chat.Close()
	hook.Remove("HUDPaint", "SCB")
end)

hook.Add("PlayerButtonDown", "SCB", function()
	local chatbox = scb.chatbox
	if chatbox and not chatbox.hidden then
		chatbox.text_entry:RequestFocus()
	end
end)

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/game/client/clientmode_shared.cpp#L651
timer.Simple(5, function()
	local binds = {
		messagemode = 1,
		say = 1,

		messagemode2 = 0,
		say_team = 0
	}

	local old_PlayerBindPress = GAMEMODE.PlayerBindPress
	function GAMEMODE:PlayerBindPress(ply, bind, pressed)
		if old_PlayerBindPress(self, ply, bind, pressed) == true then
			return true
		end

		local team_mode = binds[bind]
		if team_mode then
			if pressed then
				chat.Open(team_mode)
			end
			return true
		end
	end
end)

timer.Simple(5, function()
	local types = {
		namechange = 1,
		servermsg = 1,
		teamchange = 1,
		none = 1,
	}

	if not config.enable_custom_join_messages and not config.enable_custom_leave_messages then
		types.joinleave = 1
	end

	local old_ChatText = GAMEMODE.ChatText
	function GAMEMODE:ChatText(index, name, text, type, ...)
		if old_ChatText(self, index, name, text, type) == true then
			return true
		end

		if types[type] then
			chat.AddText(text)
			return true
		end

		if type == "joinleave" then
			return true
		end
	end
end)

if config.enable_custom_join_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_join = {}
	gameevent.Listen("player_connect_client")
	hook.Add("player_connect_client", "SCB.JoinMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_joined:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_join[steamid] then
			printed_join[steamid] = true

			timer.Simple(4, function()
				printed_join[steamid] = nil
			end)

			chat.AddText((
				language.player_connecting:gsub("NAME", scb.escape(data.name)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

if config.enable_custom_leave_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_left = {}
	gameevent.Listen("player_disconnect")
	hook.Add("player_disconnect", "SCB.LeaveMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_left:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_left[steamid] then
			printed_left[steamid] = true

			timer.Simple(4, function()
				printed_left[steamid] = nil
			end)

			chat.AddText((
				language.player_left:gsub("NAME", scb.escape(data.name)):gsub("REASON", scb.escape(data.reason)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

hook.Add("HUDShouldDraw", "SCB", function(name)
	if name == "CHudChat" then
		return false
	end
end)

net.Receive("SCB.TTTRadio", function()
	local sender = net.ReadEntity()
	local msg = net.ReadString()
	local param = net.ReadString()
	if not IsValid(sender) and sender:IsPlayer() then return end

	GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

	local lang_param = LANG.GetNameParam(param)
	if lang_param then
		if lang_param == "quick_corpse_id" then
			param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
		else
			param = LANG.GetTranslation(lang_param)
		end
	end

	local text = LANG.GetParamTranslation(msg, {player = param})

	if lang_param then
		text = util.Capitalize(text)
	end

	OnPlayerChat(sender, text, false, false)
end)
--lua/autorun/setup_clparticles.lua:


PrecacheParticleSystem("har_explosion_a")
PrecacheParticleSystem("har_explosion_b")
PrecacheParticleSystem("har_explosion_c")
PrecacheParticleSystem("har_explosion_a_air")
PrecacheParticleSystem("har_explosion_b_air")
PrecacheParticleSystem("har_explosion_c_air")



if (CLIENT) then 
	game.AddParticles( "particles/harry_explosion.pcf" )

end


if (SERVER) then 

	TRACKING_EXPLOSIVES_GLOBAL = {} 
	TRACKING_CB_GLOBAL = {} 
	TRACKING_DYNAMITES_GLOBAL = {}
--


	function CreateCBExplosion(pos, timelapsed)
	
	
		
		
		ParticleEffect(table.Random({"har_cb_explosion_a","har_cb_explosion_b"}), pos, Angle(0,0,0), nil)

		sound.Play( "hd/new_grenadeexplo.mp3", pos, 100, math.random(250,255), 1)
		
		for i=0, 9 do 
			timer.Simple(i/8 + (math.random() * 0.1), function()
				sound.Play("ambient/energy/newspark0"..i..".wav", pos, 100, math.random(250,255), 1)

			end)
		end
		
	end
	
	function CreateGrenadeExplosion(pos, elapsed_time)
		--if elapsed_time <= 2 then this check is invalid because we now have grenades, rpgs and other shit 

		local tr = util.TraceLine( {
			start  = pos,
			endpos = pos - Vector(0,0,60),
			mask   = MASK_SOLID_BRUSHONLY
		} )

		if tr.HitWorld then 
			ParticleEffect(table.Random({"har_explosion_a","har_explosion_b","har_explosion_c"}), pos, Angle(0,math.random(0,360),0), nil)

		else
			ParticleEffect(table.Random({"har_explosion_a_air","har_explosion_b_air","har_explosion_c"}), pos, Angle(0,math.random(0,360),0), nil)

		end
		
		sound.Play( "hd/new_grenadeexplo.mp3", pos, 100, math.random(90,110), 1)
		
	
		
	end
	
	function CheckForDynamite()
		
		local dynamites = ents.FindByClass("gmod_dynamite") 
	
		for k, v in pairs(dynamites) do 
			if not(TRACKING_DYNAMITES_GLOBAL[v]) then 
				TRACKING_DYNAMITES_GLOBAL[v] = {true, v:GetPos(), CurTime()}
				-- print("grenade spawned, time to overwrite its explode function")
				
				local ent = v 
				
								
				function ent:Explode( delay, ply )

					if ( !IsValid( self ) ) then return end

					ply = ply or self.Entity

					local _delay = delay or self:GetDelay()
					
					
					
					if ( _delay == 0 ) then

						local radius = 300
						CreateGrenadeExplosion(self:GetPos(), -1)
						util.BlastDamage( self, ply, self:GetPos(), radius, math.Clamp( self:GetDamage(), 0, 1500 ) )
					
						

						if ( self:GetShouldRemove() ) then self:Remove() return end
						if ( self:GetMaxHealth() > 0 && self:Health() <= 0 ) then self:SetHealth( self:GetMaxHealth() ) end

					else

						timer.Simple( _delay, function() if ( !IsValid( self ) ) then return end self:Explode( 0, ply ) end )

					end

				end
				
			else 
				-- nope, grenade is still in the table, but let's still update whatever shit needs to be updated
				TRACKING_DYNAMITES_GLOBAL[v][1] = true
				TRACKING_DYNAMITES_GLOBAL[v][2] = v:GetPos()
				

				
			end
		end
		
		for k, v in pairs(TRACKING_DYNAMITES_GLOBAL) do 
			if not(k:IsValid()) then				
				TRACKING_DYNAMITES_GLOBAL[k] = nil 		
			else
				-- send nudes 
			end
		end
	
	end
	
	
	function CheckForCB()
		
		local cb = ents.FindByClass("prop_combine_ball") 

		
		
		
		for k, v in pairs(cb) do 
			if not(TRACKING_CB_GLOBAL[v]) then 
				TRACKING_CB_GLOBAL[v] = {true, v:GetPos(), CurTime()}
				-- print("grenade spawned")
			else 
				-- nope, grenade is still in the table, but let's still update whatever shit needs to be updated
				TRACKING_CB_GLOBAL[v][1] = true
				TRACKING_CB_GLOBAL[v][2] = v:GetPos()
				

				
			end
		end
		
		for k, v in pairs(TRACKING_CB_GLOBAL) do 
			if not(k:IsValid()) then 
				print("it's not valid, prob gone")
				
				local pos, elapsed_time = v[2], (CurTime() - v[3])
				CreateCBExplosion(pos, elapsed_time)
				
				
				TRACKING_CB_GLOBAL[k] = nil 
				
			else
				-- send nudes 
			end
		end
	
	end
	
	
	function CheckForGrenadesAndRockets()
		
		local grenades = ents.FindByClass("npc_grenade_frag") 
		local rpgs     = ents.FindByClass("rpg_missile")
		
		table.Merge(grenades, rpgs)
		
		for k, v in pairs(grenades) do 
			if not(TRACKING_EXPLOSIVES_GLOBAL[v]) then 
				TRACKING_EXPLOSIVES_GLOBAL[v] = {true, v:GetPos(), CurTime()}
				-- print("grenade spawned")
			else 
				-- nope, grenade is still in the table, but let's still update whatever shit needs to be updated
				TRACKING_EXPLOSIVES_GLOBAL[v][1] = true
				TRACKING_EXPLOSIVES_GLOBAL[v][2] = v:GetPos()
				

				
			end
		end
		
		for k, v in pairs(TRACKING_EXPLOSIVES_GLOBAL) do 
			if not(k:IsValid()) then 
				print("it's not valid, prob gone")
				
				local pos, elapsed_time = v[2], (CurTime() - v[3])
				CreateGrenadeExplosion(pos, elapsed_time)
				
				
				TRACKING_EXPLOSIVES_GLOBAL[k] = nil 
				
			else
				-- send nudes 
			end
		end
	
	end
	
	if file.Exists( "autorun/gexplo_autorun.lua", "LUA" ) then 
	
	else
		
		hook.Add("Tick", "CheckForDynamite", CheckForDynamite)
		hook.Add("Think", "CheckForGrenadesAndRockets", CheckForGrenadesAndRockets)
	
	end
	
	hook.Add("Tick", "CheckForCB", CheckForCB)

	
end

--lua/autorun/sh_addmaterials.lua:
list.Add( "OverrideMaterials", "ace/sw/holoproj" )
list.Add( "OverrideMaterials", "ace/sw/hologram" )
list.Add( "OverrideMaterials","ace/sw/holobarrier" )
--lua/autorun/sh_chissmodel.lua:
if SERVER then AddCSLuaFile("lua/autorun/sh_chissmodel.lua") end

list.Set("PlayerOptionsModel", "Nuru Kungurama", "models/summe/nuru_chiss.mdl")
player_manager.AddValidModel("Nuru Kungurama", "models/summe/nuru_chiss.mdl")
--lua/autorun/sh_includepcf.lua:
game.AddParticles("particles/env_sprinkler.pcf")
game.AddParticles("particles/particles/c2a2c_rocketeffects.pcf")
game.AddParticles("particles/c2a2b_silo.pcf")

if CLIENT then
	PrecacheParticleSystem("Fire Sprinkler")
	PrecacheParticleSystem("rocketsteam_engine")
	PrecacheParticleSystem("c2a2c_rocket_engine_core")
end




--addons/animations/lua/autorun/sh_index_animations.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Jedi Bow            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        SH Index | Jedi Bow        --
---------------------------------------

Animations = Animations or {}

hook.Add("EGMRP.Loaded", "Animations.Load", function()
	if SERVER then
		AddCSLuaFile("animations/sh_config.lua")
		AddCSLuaFile("animations/cl_animations.lua")

		include("animations/sh_config.lua")
		include("animations/sv_animations.lua")
	end

	if CLIENT then
		include("animations/sh_config.lua")
		include("animations/cl_animations.lua")
	end
end)
--lua/autorun/sh_legs_compat.lua:
--[[
	   ______                    __   __                   
	  / ____/___ ___  ____  ____/ /  / /   ___  ____ ______
	 / / __/ __ `__ \/ __ \/ __  /  / /   / _ \/ __ `/ ___/
	/ /_/ / / / / / / /_/ / /_/ /  / /___/  __/ /_/ (__  ) 
	\____/_/ /_/ /_/\____/\__,_/  /_____/\___/\__, /____/  
	                                         /____/        
	@Valkyrie, @blackops7799
]]--
    
if (SERVER) then
    AddCSLuaFile("sh_legs.lua")
end

if (CLIENT) then
    hook.Add("ShouldDisableLegs", "GML::Support::Prone", function()
        if (!LocalPlayer().IsProne) then
            return
        end

        if (LocalPlayer():IsProne()) then
            return true
        end
    end)

    hook.Add("ShouldDisableLegs", "GML::Support::MorphMod", function()
        if (!pk_pills) then
            return
        end

        if (pk_pills.getMappedEnt(LocalPlayer())) then
            return true
        end
    end)

	hook.Add("ShouldDisableLegs", "GML::Support::VWallrun", function()
        if (VWallrunning) then
            return true
        end
    end)
    
    hook.Add("ShouldDisableLegs", "GML::Support::Mantle", function()
        if (inmantle) then
            return true
        end
	end)
end

--lua/autorun/sh_rp_gozanti_cruiser_swu_config.lua:
hook.Add("SWU_LoadCustomMapConfig", "rp_gozanti_cruiser", function (mapName, configuration)
    configuration["rp_gozanti_cruiser"] = {
        skyboxReference = Vector(244, -38, -14398), -- Some random point in the skybox
        controllerPos = Vector(8, 232, -14848), -- Position of where the ship is in the skybox
        disableFog = true, -- Disables distance fog, recommended to be kept on true
        disableSun = true, -- Disables the sun, recommended to be kept on true
        shipOffsetRotation = Angle(180,0,0), -- Optionaly used to correct the direction in which the ship should fly
        scale = 500, -- Scales the distance in the skybox, currently a bit buggy recommended to be kept on 500 for now
        collisionRange = 115, -- Distance of when the ship crashes into a planet
        hyperspace = {
            tunnel = "models/kingpommes/starwars/venator/hypertunnel.mdl", -- Model of the hyperspace tunnel, recommended to be kept as is
            stars = "models/kingpommes/starwars/venator/lightspeed_stars.mdl" -- Model of the hyperspace transition model, recommended to be kept as is
        },
        skyboxBoundaries = { -- Boundaries of the skybox will normaly be calculated automatically, if you have props in your skybox it might be necessary to do manually
            min = Vector(),
            max = Vector(),
            center = Vector()
        },
        controls = {
            {
                -- Position and angle of the navigation computer
                ent = "swu_navigation_computer",
                pos = Vector(224, -88, 0),
                ang = Angle(0, 90, 0)
            },
            {
                -- Position and angle of the rotation controller
                ent = "swu_rotation_controller",
                pos = Vector(-376, 10, 0),
                ang = Angle(0, 0, 0)
            },
            {
                -- Position and angle of the speed controller
                ent = "swu_speed_controller",
                pos = Vector(-376, -82, 0),
                ang = Angle(0, 0, 0)
            },
            {
                -- Position and angle of the star map
                ent = "swu_map",
                pos = Vector(224, -95, 85),
                ang = Angle(90, 90, 0),
                scale = 0.8
            }
        },        
        -- Positions where map native hyperdrive stuff should be removed
        blockPos = {
            Vector(-8751, -386, 737),
            Vector(-8739, -356, 782)
        }
    }
end)
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_basepanel.lua:
local adraw = include("libs/advanceddraw.lua")
local PANEL = {}

function PANEL:Paint()
    if (self:GetPaintBackground()) then
        adraw.Derma_DrawPanelBlur(self, self:GetBackgroundColor())
    end
end

vgui.Register("swu_basepanel", PANEL, "DPanel")
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_header.lua:
local PANEL = {}

surface.CreateFont("SwuHeader", {
    font = "Saira",
    size = 40,
    weight = 500,
    antialias = true,
    shadow = false
})

function PANEL:Init()
    self:Dock(TOP)

    self:SetSize(self:GetParent():GetWide(), 40)
    self:DockMargin(0,0,0,10)
end

function PANEL:SetText(text)
    self.Text = text
end

function PANEL:GetText()
    return self.Text
end

function PANEL:Paint(w,h)
    local textW, textH = draw.SimpleText(self.Text, "SwuHeader", 0, 0)

    local lineHeight = h * 0.05
    draw.RoundedBox(0,textW + w * 0.01,(h - lineHeight) * 0.5,w,lineHeight, Color(255,255,255))
end

vgui.Register("swu_header", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_icon.lua:
local PANEL = {}

function PANEL:Init()
    self:SetBackgroundColor(Color(10,10,10,200))
end

function PANEL:SetMaterial(mat)
    self.mat = isstring(mat) and Material(mat, "smooth") or mat
end

function PANEL:GetMaterial()
    return self.mat
end

function PANEL:SetColor(color)
    self.color = color
end

function PANEL:GetColor()
    return self.color or Color(255,255,255)
end

function PANEL:SetPadding(padding)
    self.padding = padding
end

function PANEL:GetPadding()
    return self.padding or 0
end

function PANEL:SetOnClick(onclick, hoverColor, clickColor)
    if (not isfunction(onclick)) then
        self:SetCursor("arrow")
        return
    end

    self:SetCursor("hand")
    self.onClick = onclick
    self.hoverColor = hoverColor or self:GetColor()
    self.clickColor = clickColor or self:GetColor()
end

function PANEL:OnMouseReleased(keyCode)
    if (keyCode ~= MOUSE_LEFT or not isfunction(self.onClick)) then return end

    self:onClick()
end

function PANEL:PaintOver(w,h)
    local color = self:GetColor()
    if (isfunction(self.onClick) and self:IsHovered()) then
        color = input.IsMouseDown(MOUSE_LEFT) and self.clickColor or self.hoverColor
    end

    surface.SetDrawColor(color)
    surface.SetMaterial(self.mat)
    surface.DrawTexturedRect(0 + self:GetPadding(),0 + self:GetPadding(),w - self:GetPadding() * 2,h - self:GetPadding() * 2)
end


vgui.Register("swu_icon", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_inputfield.lua:
local PANEL = {}

function PANEL:Init()
    self:SetBackgroundColor(Color(10,10,10,200))

    self.barHeight = self:GetTall() * 0.04

    self.inputField = self:Add("swu_internal_inputfield")
end

function PANEL:OnSizeChanged(w,h)
    self.barHeight = h * 0.04

    self:UpdateIconRightSize()

    local inputFieldWidth = self:GetWide() - self.barHeight * 4

    if (IsValid(self:GetIconRight())) then
        inputFieldWidth = inputFieldWidth - self:GetIconRight():GetWide()
    end

    self.inputField:SetSize(inputFieldWidth, self:GetTall() - self.barHeight * 2)
    self.inputField:SetPos(self.barHeight * 2, self.barHeight)
end

function PANEL:SetIconRight(mat, backgroundColor, onClick, hoverColor, clickColor)
    self.iconRight = self:Add("swu_icon")
    if (IsColor(backgroundColor)) then
        self.iconRight:SetBackgroundColor(backgroundColor)
    else
        self.iconRight:SetPaintBackground(false)
    end
    self.iconRight:SetMaterial(mat)
    self.iconRight:SetOnClick(onClick, hoverColor, clickColor)

    self:UpdateIconRightSize()
    self:OnSizeChanged(self:GetWide(), self:GetTall())
end

function PANEL:UpdateIconRightSize()
    if (not IsValid(self:GetIconRight())) then return end

    self:GetIconRight():SetSize(self:GetTall(), self:GetTall())
    self:GetIconRight():SetPos(self:GetWide() - self:GetTall(), 0)
    self:GetIconRight():SetPadding(self:GetTall() * 0.2)
end

function PANEL:GetIconRight()
    return self.iconRight
end

function PANEL:PaintOver(w,h)
    local barColor = self.inputField:IsEditing() and SWU.Colors.Default.accent or SWU.Colors.Default.passive

    draw.RoundedBox(0,0,h - self.barHeight,w, self.barHeight, barColor)
end

function PANEL:GetValue()
    return self.inputField:GetValue()
end

function PANEL:SetOnEnter(onEnter)
    self.inputField.OnEnter = function ()
        if (isfunction(onEnter)) then
            onEnter()
        end
    end
end

function PANEL:RequestFocus()
    self.inputField:RequestFocus()
end

vgui.Register("swu_inputfield", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_navigationentry.lua:
local PANEL = {}
local adraw = include("libs/advanceddraw.lua")


surface.CreateFont("SwuNavigationEntry", {
    font = "Saira",
    size = 40,
    weight = 100,
    antialias = true,
    shadow = false
})

function PANEL:Init()
    self:SetSize(self:GetParent():GetWide(), ScrH() * 0.05)

    self:SetPaintBackground(false)
    self:SetCursor("hand")
end

function PANEL:SetOnClick(onClick)
    self.onClick = onClick
end

function PANEL:OnMouseReleased(keyCode)
    if (keyCode ~= MOUSE_LEFT or not isfunction(self.onClick)) then return end

    self.onClick()
end

function PANEL:SetText(text)
    self.Text = text
end

function PANEL:GetText()
    return self.Text or ""
end

function PANEL:SetActive(active)
    self.Active = active
    self:SetPaintBackground(active)
end

function PANEL:IsActive()
    return self.Active
end

function PANEL:SetId(id)
    self.id = id
end

function PANEL:GetId()
    return self.id
end

function PANEL:PaintOver()
    local color = self:IsActive() and SWU.Colors.Default.accent or (self:IsHovered() and SWU.Colors.Default.primary or SWU.Colors.Default.passive)
    draw.SimpleText(self:GetText(), "SwuNavigationEntry", self:GetWide() * 0.05, self:GetTall() * 0.5, color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("swu_navigationentry", PANEL, "swu_basepanel")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_switch.lua:
local PANEL = {}

function PANEL:Init()
    self:SetBackgroundColor(Color(10,10,10,200))

    self:SetCursor("hand")

    self.Color = {
        Deactivated = Color(200,20,20),
        Activated = Color(122, 201, 67)
    }
end

function PANEL:SetMaterial(mat)
    self.mat = isstring(mat) and Material(mat, "smooth") or mat
end

function PANEL:GetMaterial()
    return self.mat
end

function PANEL:SetHeightMultiplier(multiplier)
    self.HeightMultiplier = multiplier
end
function PANEL:GetHeightMultiplier()
    return self.HeightMultiplier or 1
end

function PANEL:OnChange(newValue)
end

function PANEL:GetValue()
    return self.Value
end

function PANEL:SetValue(value)
    self.Value = value
end

function PANEL:GetConVar()
    return self.ConVar
end

function PANEL:SetConVar(conVarName)
    if (not ConVarExists(conVarName)) then return end

    self.ConVar = conVarName

    self:SetValue(SWU.Configuration:GetConVar(self.ConVar):GetBool())
end

function PANEL:Paint(w,h)
    local oHeight = h
    h = h * self:GetHeightMultiplier()
    local y = (oHeight - h) * 0.5

    local circleX = self:GetValue() and w - h or 0

    draw.RoundedBox(h * 0.5,0,y,w,h, self:GetBackgroundColor())

    draw.RoundedBox(h * 0.5,circleX,y,h,h, self:GetValue() and self.Color.Activated or self.Color.Deactivated)
end

function PANEL:OnMouseReleased(keyCode)
    if (keyCode ~= MOUSE_LEFT) then return end

    self:SetValue(not self:GetValue())
    self:OnChange(self:GetValue())
end

vgui.Register("swu_switch", PANEL, "swu_basepanel")

--addons/egm_tfa_weapons_zdisabled/lua/autorun/snx_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSNX = {}
GMSNX.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("snx_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SNXStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SNXStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SNXStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("snx_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("snx_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSNX:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSNX.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--lua/autorun/specops.lua:
-- Register the Special Ops material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SOTrooper", function()
	-- Spec Ops Trooper Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_trooper", "Spec Ops - Trooper Armor", {
		["body"] = "egm/specops/trooper/body",
		["body_mirrored"] = "egm/specops/trooper/body2",

		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["kama_arc"] = "egm/specops/attachment/kama_arc",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		-- Using the "Heavy" Texture
		["kama"] = "egm/specops/attachment/heavy",
		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		-- Using the "Gear" Texture
		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})
	-- Spec Ops Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "Specops_trooper", "Spec Ops - Trooper Helmet", {
		["helmet"] = "egm/specops/trooper/helmet",
		["flashlight"] = "egm/specops/trooper/helmet",
		["camera"] = "egm/specops/attachment/camera",
		["binoculars"] = "egm/specops/attachment/specialist",

		["sunvisor"] = "egm/specops/attachment/heavy",
		["armor"] = "egm/specops/attachment/heavy",

		["rangefinder"] = "egm/specops/attachment/rangefinder",

		["antenna_big"] = "egm/specops/attachment/antenna_big",
		["antenna_ear"] = "egm/specops/attachment/antenna_ear",

		["antenna_back"] = "egm/specops/attachment/antenna_back",

	})
	-- Spec Ops Trooper Helmet Ear
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "Specops_trooper", "Spec Ops - Helmet", {
		["helmet_spec_ops"] = "egm/specops/trooper/helmet",
		["helmet_ear"] = "egm/specops/trooper/helmet_ear",
		["antenna_spec_ops"] = "egm/specops/attachment/antenna",
		["flashlight"] = "egm/specops/attachment/helmet",
		["camera"] = "egm/specops/attachment/camera",
	})
	-- Spec Ops Trooper Leader Helmet Ear
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "Specops_helmet_leader", "Spec Ops - Helmet Lead", {
		["helmet_spec_ops"] = "egm/specops/trooper/helmet",
		["helmet_ear"] = "egm/specops/trooper/helmet_ear_lead",
		["antenna_spec_ops"] = "egm/specops/attachment/antenna",
		["flashlight"] = "egm/specops/attachment/helmet",
		["camera"] = "egm/specops/attachment/camera",
	})


	-- Spec Ops BSQ Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_bsq", "Spec Ops - Trooper Armor BSQ", {
		["body"] = "egm/specops/trooper/body_bsq",
		["body_mirrored"] = "egm/specops/trooper/body2_bsq",

		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["kama_arc"] = "egm/specops/attachment/kama_arc",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		-- Using the "Heavy" Texture
		["kama"] = "egm/specops/attachment/heavy",
		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		-- Using the "Gear" Texture
		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})


	-- Spec Ops RMC Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_rmc", "Spec Ops - Trooper Armor RMC", {
		["body"] = "egm/specops/trooper/body_rmc",
		["body_mirrored"] = "egm/specops/trooper/body2_rmc",

		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["kama_arc"] = "egm/specops/attachment/kama_arc",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		-- Using the "Heavy" Texture
		["kama"] = "egm/specops/attachment/heavy",
		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		-- Using the "Gear" Texture
		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})


	-- Flametrooper Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "Specops_flametrooper", "Spec Ops - Flametrooper Body", {
		["body"] = "egm/specops/flametrooper/body",
		["synthmesh"] = "egm/specops/flametrooper/synthmesh",

		["kama"] = "egm/specops/flametrooper/kama",

		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_chest"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})
	-- Flametrooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "Specops_flametrooper", "Spec Ops - Flametrooper Helmet", {
		["helmet_synthmesh"] = "egm/specops/flametrooper/helmet",
		["flashlight"] = "egm/specops/lore/jet/helmet",
		["antenna_back"] = "egm/specops/lore/jet/antenna_back",
		["antenna_ear_big"] = "egm/specops/lore/jet/antenna_big",
	})
	-- Flametrooper Helmet Leader
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "Specops_flametrooper_Helmet_leader", "Spec Ops - Flametrooper Helmet lead", {
		["helmet_synthmesh"] = "egm/specops/flametrooper/helmet_lead",
		["flashlight"] = "egm/specops/lore/jet/helmet",
		["antenna_back"] = "egm/specops/lore/jet/antenna_back",
		["antenna_ear_big"] = "egm/specops/lore/jet/antenna_big",
	})


	-- Flametrooper RMC Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "Specops_flametrooper_rmc", "Spec Ops - Flametrooper RMC Body", {
		["body"] = "egm/specops/flametrooper/body_rmc",
		["synthmesh"] = "egm/specops/flametrooper/synthmesh",

		["kama"] = "egm/specops/flametrooper/kama",

		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_chest"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})


	-- Spec Ops Pilot
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "Specops_pilot", "Spec Ops Pilot - Helmet", {
		["helmet_pilot"] = "egm/specops/trooper/helmet_pilot",
		["helmet_pilot_breath"] = "egm/specops/trooper/helmet_pilot_breath",
	})
	-- Lore Chars

	-- Spec Ops Chatter Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_chatter", "Spec Ops - Chatter Armor", {
		["body"] = "egm/specops/lore/chatter/body",
		["body_mirrored"] = "egm/specops/lore/chatter/body",

		["kama_arc"] = "egm/specops/lore/chatter/kama",
		["kama"] = "egm/specops/lore/chatter/heavy",

		["pauldron"] = "egm/specops/lore/chatter/specialist",
		["ammo_arm"] = "egm/specops/lore/chatter/specialist",
	})
	-- Spec Ops Chatter Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "Specops_chatter", "Spec Ops - Chatter Helmet", {
		["helmet_spec_ops"] = "egm/specops/lore/chatter/helmet",
		["antenna_spec_ops"] = "egm/specops/lore/chatter/antenna",
		["helmet_ear"] = "egm/specops/lore/chatter/helmet_ear",
	})


	-- Spec Ops Corr Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_corr", "Spec Ops - Corr Armor", {
		["body"] = "egm/specops/lore/corr/body",
		["body_mirrored"] = "egm/specops/lore/corr/body",

		["kama_arc"] = "egm/specops/lore/corr/kama_arc",
		["kama"] = "egm/specops/lore/corr/heavy",

		["pauldron"] = "egm/specops/lore/corr/specialist",
		["ammo_arm"] = "egm/specops/lore/corr/specialist",
		["holsters"] = "egm/specops/attachment/gear",
	})
	-- Spec Ops Corr Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "Specops_corr", "Spec Ops - Corr Helmet", {
		["helmet"] = "egm/specops/lore/corr/helmet",

        ["binoculars"] = "egm/specops/lore/corr/specialist",

		["sunvisor"] = "egm/specops/lore/corr/heavy",
		["armor"] = "egm/specops/lore/corr/heavy",

		["rangefinder"] = "egm/specops/lore/corr/rangefinder",
	})


	-- Spec Ops jet Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "Specops_jet", "Spec Ops - Jet Armor", {
		["body"] = "egm/specops/lore/jet/body",
		["body_mirrored"] = "egm/specops/lore/jet/body",

		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["kama_arc"] = "egm/specops/attachment/kama_arc",

		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",

		-- Using the "Heavy" Texture
		["kama"] = "egm/specops/attachment/heavy",
		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",

		-- Using the "Specialist" Texture
		["pauldron"] = "egm/specops/attachment/specialist",
		["ammo_arm"] = "egm/specops/attachment/specialist",

		-- Using the "Gear" Texture
		["holsters"] = "egm/specops/attachment/gear",
		["pockets"] = "egm/specops/attachment/gear",
	})
	-- Spec Ops jet Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "Specops_jet", "Spec Ops - Jet Helmet", {
		["helmet_spec_ops"] = "egm/specops/lore/jet/helmet",
		["helmet_ear"] = "egm/specops/lore/jet/helmet_ear",
		["antenna_spec_ops"] = "egm/specops/attachment/antenna",
		["flashlight"] = "egm/specops/attachment/helmet",
		["camera"] = "egm/specops/attachment/camera",
	})

	-- Spec Ops Trooper Side Backpack
		BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "Specops_trooper", "Spec Ops - Trooper Sideback", {
		["sidebag"] = "egm/specops/attachment/heavy",
		["sidebag_grenades"] = "egm/specops/attachment/heavy",
	})
	-- Spec Ops Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "Specops_trooper", "Spec Ops - Trooper Backpack", {
		["backpack"] = "egm/specops/attachment/heavy",
	})
	-- Flametrooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "Specops_flametrooper", "Spec Ops - Flametrooper Backpack", {
		["bp_utility"] = "egm/specops/flametrooper/backpack",
	})
	-- Flametrooper Backpack RMC
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "Specops_flametrooper_rmc", "Spec Ops - Flametrooper RMC Backpack", {
		["bp_utility"] = "egm/specops/flametrooper/backpack_rmc",
	})
	-- Spec Ops Chatter Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "Specops_chatter", "Spec Ops - Chatter Backpack", {
		["backpack"] = "egm/specops/lore/chatter/heavy",
	})
	-- Spec Ops Corr Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "Specops_corr", "Spec Ops - Corr Backpack", {
		["backpack"] = "egm/specops/lore/corr/heavy",
	})
	-- Spec Ops Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "Specops_trooper", "Spec Ops - Jumppack", {
		["bp_jumppack"] = "egm/specops/attachment/specialist",
	})
	-- Spec Ops Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "Specops_trooper", "Spec Ops - Jetpack", {
		["bp_jetpack"] = "egm/specops/attachment/jetpack",
	})
end)
--lua/autorun/steela.lua:
player_manager.AddValidModel( "Steela Gerrera", "models/player/TCW/human/steela_gerrera.mdl" );
--addons/tfa_base/lua/tfa/enums/locomotion.lua:
--LOCOMOTION ENUM
TFA.Enum.LOCOMOTION_LUA = 0
TFA.Enum.LOCOMOTION_HYBRID = 1
TFA.Enum.LOCOMOTION_ANI = 2
--addons/tfa_base/lua/tfa/modules/tfa_attachments.lua:
TFA.Attachments = TFA.Attachments or {}
TFA.Attachments.Atts = {}

TFA.Attachments.Colors = {
	["active"] = Color(252, 151, 50, 255),
	["error"] = Color(225, 0, 0, 255),
	["error_attached"] = Color(140, 80, 30, 255),
	["background"] = Color(15, 15, 15, 64),
	["primary"] = Color(245, 245, 245, 255),
	["secondary"] = Color(153, 253, 220, 255),
	["+"] = Color(128, 255, 128, 255),
	["-"] = Color(255, 128, 128, 255),
	["="] = Color(192, 192, 192, 255)
}

TFA.Attachments.UIPadding = 2
TFA.Attachments.IconSize = 64
TFA.Attachments.CategorySpacing = 128

if SERVER then
	util.AddNetworkString("TFA_Attachment_Set")
	util.AddNetworkString("TFA_Attachment_SetStatus")
	util.AddNetworkString("TFA_Attachment_Reload")
	util.AddNetworkString("TFA_Attachment_Request")

	local function UpdateWeapon(wep, ply)
		for category, data in pairs(wep.Attachments or {}) do
			if type(category) ~= "string" then
				net.Start("TFA_Attachment_Set")
				net.WriteEntity(wep)

				net.WriteUInt(category, 8)
				if data.atts and data.atts[data.sel] then
					net.WriteString(data.atts[data.sel])
				else
					net.WriteString("")
				end

				net.Send(ply)
			end
		end
	end

	net.Receive("TFA_Attachment_Request", function(len, ply)
		if not IsValid(ply) then return end
		local wep = net.ReadEntity()
		if not IsValid(wep) or not wep.IsTFAWeapon or not wep.HasInitAttachments or wep.AttachmentCount < 1 then return end
		local ctime = SysTime()

		local currentScheduleRequest = ply.__TFA_Base_Next_Attachment_Request or ctime
		local nextScheduleRequest = math.max(ctime + 0.2, currentScheduleRequest + 0.2)
		ply.__TFA_Base_Next_Attachment_Request = nextScheduleRequest

		-- Temp Fix
		UpdateWeapon(wep, ply)
	end)

	net.Receive("TFA_Attachment_Set", function(len, ply)
		local wep = ply:GetWeapon(net.ReadString())
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()
		local status = wep:SetTFAAttachment(cat, ind, ply)

		net.Start("TFA_Attachment_SetStatus")
		net.WriteEntity(wep)
		net.WriteBool(status)

		if not status then
			if wep.Attachments and wep.Attachments[cat] then
				local data = wep.Attachments[cat]
				net.WriteUInt(cat, 8)

				if data.atts and data.atts[data.sel] then
					net.WriteString(data.atts[data.sel])
				else
					net.WriteString("")
				end
			end
		end

		net.Send(ply)
	end)
else
	sql.Query([[
		CREATE TABLE IF NOT EXISTS tfa_savedattachments (
			class VARCHAR(80) NOT NULL,
			atts TEXT NOT NULL,
			PRIMARY KEY (class)
		)
	]])

	net.Receive("TFA_Attachment_Set", function(len)
		local wep = net.ReadEntity()

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()

		if IsValid(wep) and wep.SetTFAAttachment then
			wep:SetTFAAttachment(cat, ind, false)
		end
	end)

	net.Receive("TFA_Attachment_Reload", function(len)
		TFAUpdateAttachments()
	end)

	net.Receive("TFA_Attachment_SetStatus", function(len)
		local weapon = net.ReadEntity()
		if not IsValid(weapon) then return end
		local status = net.ReadBool()

		if status then
			weapon:SaveAttachments()
			return
		end
		surface.PlaySound("buttons/button2.wav")

		local cat = net.ReadUInt(8)
		local ind = net.ReadString()
		weapon:SetTFAAttachment(cat, ind, false)
	end)

	local function request(self)
		if self._TFA_Attachment_Request then return end
		if not self.HasInitAttachments or self.AttachmentCount < 1 then return end
		net.Start("TFA_Attachment_Request")
		net.WriteEntity(self)
		net.SendToServer()
		self._TFA_Attachment_Request = true
	end

	hook.Add("NotifyShouldTransmit", "TFA_AttachmentsRequest", function(self, notDormant)
		if not self.IsTFAWeapon or not notDormant then return end
		request(self)
	end)

	hook.Add("NetworkEntityCreated", "TFA_AttachmentsRequest", function(self)
		timer.Simple(0, function()
			if not IsValid(self) or not self.IsTFAWeapon then return end
			request(self)
		end)
	end)

	hook.Add("OnEntityCreated", "TFA_AttachmentsRequest", function(self)
		timer.Simple(0, function()
			if not IsValid(self) or not self.IsTFAWeapon then return end
			request(self)
		end)
	end)

	local LoadQuery = [[SELECT atts FROM tfa_savedattachments WHERE class = '%s']]
	function TFA.GetSavedAttachments(Weapon)
		if not IsValid(Weapon) or not Weapon.IsTFAWeapon then return end

		local data = sql.QueryRow(string.format(LoadQuery, sql.SQLStr(Weapon:GetClass(), true)))

		if data and data.atts then
			return util.JSONToTable(data.atts)
		end
	end

	local SaveQuery = [[REPLACE INTO tfa_savedattachments (class, atts) VALUES ('%s', '%s');]]
	function TFA.SetSavedAttachments(Weapon)
		if not IsValid(Weapon) or not Weapon.IsTFAWeapon or not next(Weapon.Attachments or {}) then return end

		local seltbl = {}
		for cat, catTbl in pairs(Weapon.Attachments or {}) do
			if cat ~= "BaseClass" and catTbl.atts then
				seltbl[cat] = catTbl.atts[catTbl.sel or -1] or ""
			end
		end

		return sql.Query(string.format(SaveQuery, sql.SQLStr(Weapon:GetClass(), true), sql.SQLStr(util.TableToJSON(seltbl), true)))
	end
end

local function basefunc(t, k)
	if k == "Base" then return end

	if t.Base then
		local bt = TFA.Attachments.Atts[t.Base]
		if bt then return bt[k] end
	end
end

function TFA.Attachments.SetupBaseTable(id, path)
	local ATTACHMENT = {}

	setmetatable(ATTACHMENT, {
		__index = basefunc
	})

	ATTACHMENT.ID = id

	ProtectedCall(function()
		hook.Run("TFABase_PreBuildAttachment", id, path, ATTACHMENT)
	end)

	return ATTACHMENT
end

function TFA.Attachments.Register(id, ATTACHMENT, path)
	if istable(id) then
		ATTACHMENT = id
		id = ATTACHMENT.ID
	end

	assert(istable(ATTACHMENT), "Invalid attachment argument provided")
	assert(isstring(id), "Invalid attachment ID provided")
	local size = table.Count(ATTACHMENT)

	if size == 0 or size == 1 and ATTACHMENT.ID ~= nil then
		local id2 = id or ATTACHMENT.ID

		if id2 then
			ErrorNoHalt("[TFA Base] Attempt to register an empty attachment " .. id2 .. "\n")
		else
			ErrorNoHalt("[TFA Base] Attempt to register an empty attachment\n")
		end

		ErrorNoHalt(debug.traceback() .. "\n")
		MsgC("\n")
		return
	end

	ProtectedCall(function()
		hook.Run("TFABase_BuildAttachment", id, path, ATTACHMENT)
	end)

	ATTACHMENT.ID = ATTACHMENT.ID or id

	if ATTACHMENT.ID and ATTACHMENT.ID ~= "base" then
		ATTACHMENT.Base = ATTACHMENT.Base or "base"
	end

	--[[if not TFA_ATTACHMENT_ISUPDATING and istable(ATTACHMENT.WeaponTable) then
		TFA.MigrateStructure(ATTACHMENT, ATTACHMENT.WeaponTable, id or "<attachment>", false)
	end]]

	ProtectedCall(function()
		hook.Run("TFABase_RegisterAttachment", id, ATTACHMENT)
	end)

	TFA.Attachments.Atts[ATTACHMENT.ID or ATTACHMENT.Name] = ATTACHMENT
end

function TFA.Attachments.RegisterFromTable(id, tbl, path)
	local status

	ProtectedCall(function()
		status = hook.Run("TFABase_ShouldLoadAttachment", id, path)
	end)

	if status == false then return end

	local ATTACHMENT = TFA.Attachments.SetupBaseTable(id)

	for k, v in pairs(tbl) do
		ATTACHMENT[k] = v
	end

	TFA.Attachments.Register(id, ATTACHMENT)
end

TFARegisterAttachment = TFA.Attachments.Register
TFA.Attachments.Path = "tfa/att/"
TFA.Attachments.Path_Batch = "tfa/attbatch/"
TFA_ATTACHMENT_ISUPDATING = false

local inheritanceCached = {}
local missingBaseWarningShown = {}

local function patchInheritance(t, basetbl)
	if t.Base and t.Base ~= "base" and not TFA.Attachments.Atts[t.Base] then
		if t.ID and not missingBaseWarningShown[t.ID] then
			missingBaseWarningShown[t.ID] = true

			print("[TFA Base] [!] Attachment '" .. t.ID .. "' depends on unknown attachment '" .. t.Base .. "'!")
		end

		t.Base = "base"
	end

	if not basetbl and t.Base then
		basetbl = TFA.Attachments.Atts[t.Base]

		if basetbl and istable(basetbl) and basetbl.ID and not inheritanceCached[basetbl.ID] then
			inheritanceCached[basetbl.ID] = true
			patchInheritance(basetbl)
		end
	end

	if not (basetbl and istable(basetbl)) then return end

	for k, v in pairs(t) do
		local baseT = basetbl[k]

		if istable(v) and baseT then
			patchInheritance(v, baseT)
		end
	end

	for k, v in pairs(basetbl) do
		if rawget(t, k) == nil then
			t[k] = v
		end
	end
end

function TFAUpdateAttachments(network)
	if SERVER and network ~= false then
		net.Start("TFA_Attachment_Reload")
		net.Broadcast()
	end

	TFA.AttachmentColors = TFA.Attachments.Colors --for compatibility
	TFA.Attachments.Atts = {}
	TFA_ATTACHMENT_ISUPDATING = true
	local tbl = file.Find(TFA.Attachments.Path .. "*base*", "LUA")
	local addtbl = file.Find(TFA.Attachments.Path .. "*", "LUA")

	for _, v in ipairs(addtbl) do
		if not string.find(v, "base") then
			table.insert(tbl, #tbl + 1, v)
		end
	end

	table.sort(tbl)

	for _, fname in ipairs(tbl) do
		local path = TFA.Attachments.Path .. fname
		local id = fname:lower():Replace(".lua", "")

		local status

		ProtectedCall(function()
			status = hook.Run("TFABase_ShouldLoadAttachment", id, path)
		end)

		if status ~= false then
			ATTACHMENT = TFA.Attachments.SetupBaseTable(id, path)

			if SERVER then
				AddCSLuaFile(path)
				include(path)
			else
				include(path)
			end

			TFA.Attachments.Register(id, ATTACHMENT, path)
			ATTACHMENT = nil
		end
	end

	local tbl2 = file.Find(TFA.Attachments.Path_Batch .. "*", "LUA")

	for _, fname in ipairs(tbl2) do
		local path = TFA.Attachments.Path_Batch .. fname

		if SERVER then
			AddCSLuaFile(path)
			include(path)
		else
			include(path)
		end
	end

	ProtectedCall(function()
		hook.Run("TFAAttachmentsLoaded")
	end)

	for _, v in pairs(TFA.Attachments.Atts) do
		patchInheritance(v)

		--[[if istable(v.WeaponTable) then
			TFA.MigrateStructure(v, v.WeaponTable, v.ID or "<attachment>", false)
		end]]
	end

	ProtectedCall(function()
		hook.Run("TFAAttachmentsInitialized")
	end)

	TFA_ATTACHMENT_ISUPDATING = false

	TFA.ATTACHMENTS_LOADED = true
end

if not VLL2_FILEDEF and TFA.ATTACHMENTS_LOADED then
	TFAUpdateAttachments(false)
end

concommand.Add("sv_tfa_attachments_reload", function(ply, cmd, args, argStr)
	if SERVER and (not IsValid(ply) or ply:IsAdmin()) then
		TFAUpdateAttachments()
	end
end, function() end, "Reloads all TFA Attachments", {FCVAR_SERVER_CAN_EXECUTE})

--addons/tfa_base/lua/tfa/modules/tfa_effects.lua:
TFA.Effects = TFA.Effects or {}
local Effects = TFA.Effects

Effects.Overrides = Effects.Overrides or {}
local Overrides = Effects.Overrides

function Effects.AddOverride(target, override)
	assert(type(target) == "string", "No target effect name or not a string")
	assert(type(override) == "string", "No override effect name or not a string")

	Overrides[target] = override
end

function Effects.GetOverride(target)
	if Overrides[target] then
		return Overrides[target]
	end

	return target
end

local util_Effect = util.Effect

function Effects.Create(effectName, effectData, allowOverride, ignorePredictionOrRecipientFilter)
	effectName = Effects.GetOverride(effectName)

	util_Effect(effectName, effectData, allowOverride, ignorePredictionOrRecipientFilter)
end

if SERVER then
	AddCSLuaFile("tfa/muzzleflash_base.lua")
end

--addons/tfa_base/lua/tfa/modules/cl_tfa_attachment_panel.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local dimensions, padding
local tooltip_mincount = 1

local PANEL = {}

PANEL.HasInitialized = false
PANEL.Wep = nil
PANEL.Att = nil
PANEL.x = -1
PANEL.y = -1
PANEL.AttachmentTable = {}
PANEL.AttachmentIcons = {}
PANEL.VAtt = 0

function PANEL:Init()
	self.HasInitialized = false
	self.Wep = nil
	self.Att = nil
	self.x = -1
	self.y = -1
	self.AttachmentTable = {}
	self.AttachmentIcons = {}
	self:SetMouseInputEnabled(true)
end

function PANEL:Initialize()
	if not IsValid(self.Wep) then return false end

	if not self.Att then return end

	self.AttachmentTable = self.Wep.Attachments[ self.VAtt ]
	self.VGUIAttachmentTable = self.Wep.VGUIAttachments[ self.VAtt ]

	dimensions = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	padding = math.Round(TFA.ScaleH(TFA.Attachments.UIPadding))

	local attCnt = #self.VGUIAttachmentTable.atts
	local truewidth = dimensions * attCnt + padding * ( math.max(0,attCnt-1) + 2 )
	local finalwidth = math.max( truewidth, dimensions * tooltip_mincount + padding * ( math.max(0,tooltip_mincount-1) + 2 ) )

	self:SetSize( finalwidth, dimensions + padding * 2 ) --+ tooltipheightmax + padding * 2 )
	self:DockPadding( 0, 0, 0, 0 )

	local toppanel = self:Add("DPanel")

	--toppanel:Dock( FILL )
	--toppanel:Dock(TOP)

	toppanel:SetWidth( finalwidth )
	toppanel:SetHeight( self:GetTall() )
	toppanel:DockPadding( padding,padding, padding, padding )
	toppanel.Paint = function(myself,w,h)
		if not IsValid(self.Wep) then return end
		draw.RoundedBox( 0, 0, 0, w, h, ColorAlpha( TFA.Attachments.Colors["secondary"], ( self.Wep:GetInspectingProgress() or 0 ) * 128 ) )
	end

	self.FinalWidth = finalwidth
	self.TopDockPanel = toppanel

	--self:InitializeTooltip()

	--[[

	local tooltip = self:Add("TFAAttachmentTip")
	tooltip:SetWeapon( self.Wep )
	tooltip:SetAttachment( self.Att )
	--tooltip:SetHeight( tooltipheightmax + padding * 2 )
	tooltip:SetSize( finalwidth, tooltipheightmax + padding * 2 )
	tooltip:SetPos(0, toppanel:GetTall() )
	self.ToolTip = tooltip

	]]--

	--local keyz = table.GetKeys( self.AttachmentTable.atts )
	--table.sort(keyz)
	--PrintTable(keyz)
	--for _,k in ipairs(keyz) do
	--	local v = self.AttachmentTable.atts[k]

	self.HasInitialized = true
	return true
end

function PANEL:PopulateIcons()
	dimensions = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	padding = math.Round(TFA.ScaleH(TFA.Attachments.UIPadding))

	local i = 0

	for k,v in ipairs( self.VGUIAttachmentTable.atts ) do
		local p = self.TopDockPanel:Add("TFAAttachmentIcon")

		p:SetWeapon( self.Wep )
		p:SetGunAttachment( self.Att )
		p:SetAttachment( v[1] )
		p:SetID( v[2] )

		p:SetName("Attachment Icon: " .. v[1])

		p:SetSize(dimensions, dimensions)
		p:SetPos(dimensions * i + padding * ( i + 1 ), padding)

		i = i + 1
		--p:SetPos(0,0)
		--p:DockMargin( 0,0, padding, 0 )
		--p:Dock(LEFT)
		self.AttachmentIcons[k] = p
	end

	return self
end

function PANEL:InitializeTooltip()
	local tooltip = vgui.Create("TFAAttachmentTip")
	tooltip.Anchor = self
	tooltip:SetWeapon(self.Wep)
	tooltip:SetAttachment(self.Att)
	tooltip:SetWidth(self.FinalWidth)
	tooltip:SetPos(0, self.TopDockPanel:GetTall())
	self.ToolTip = tooltip
	tooltip.LastTouched = 0
	tooltip.LastFrameAffectedImportant = 0

	return tooltip
end

function PANEL:OnRemove()
	if IsValid(self.ToolTip) then
		self.ToolTip:Remove()
	end
end

function PANEL:SetupTooltip(tooltip)
	tooltip.Anchor = self
	tooltip:SetWidth(math.max(self.FinalWidth, tooltip:GetWide()))
	tooltip:SetPos(0, self.TopDockPanel:GetTall())
	self.ToolTip = tooltip

	return tooltip
end

--[[
function PANEL:CalcVAtt()
	if not self.VAtt then
		self.VAtt = 0
		local keyz = table.GetKeys( self.Wep.Attachments or {} )
		table.RemoveByValue( keyz, "BaseClass" )
		table.sort( keyz, function(a,b)
			--A and B are keys
			local v1 = self.Wep.Attachments[a]
			local v2 = self.Wep.Attachments[b]
			if v1 and v2 and v1.order then
				return v1.order < ( v2.order or math.huge )
			else
				return a < b
			end
		end)
		for k,v in ipairs(keyz) do
			if self.Att == v then
				self.VAtt = k
			end
		end
		--self:SetZPos( 100 - self.VAtt )
	end
end
]]--

function PANEL:Think()
	if not IsValid(self.ToolTip) then return end

	--self:CalcVAtt()

	local header
	local texttable

	for _,v in pairs( self.AttachmentIcons ) do
		if v:IsHovered() then
			header = TFA.Attachments.Atts[v.Attachment].Name
			texttable = TFA.Attachments.Atts[v.Attachment].Description
			break
		end
	end

	if not header then
		for _,v in pairs( self.AttachmentIcons ) do
			if v:GetSelected() then
				header = TFA.Attachments.Atts[v.Attachment].Name
				texttable = {}--TFA.Attachments.Atts[v.Attachment].Description
				break
			end
		end
	end

	if header and header ~= "" or self.ToolTip.LastTouched < RealTime() then
		if texttable and #texttable == 0 and self.ToolTip.LastFrameAffectedImportant > RealTime() then
			return
		end

		self.ToolTip:SetHeader(header)
		self.ToolTip:SetTextTable(texttable)
		self.ToolTip:SetActive( texttable and #texttable > 0 )
		self.ToolTip:SetContentPanel( self.ContentPanel )
		self.ToolTip.LastTouched = RealTime() + 0.1

		if texttable and #texttable ~= 0 then
			self.ToolTip.LastFrameAffectedImportant = RealTime() + 0.1
		end
	end
end

function PANEL:SetContentPanel( p )
	if IsValid(p) then
		self.ContentPanel = p
	else
		self.ContentPanel = nil
	end
end

function PANEL:SetWeapon( wepv )
	if IsValid(wepv) then
		self.Wep = wepv
	end
end

function PANEL:SetAttachment( att )
	if att ~= nil then
		self.VAtt = att
	end
end

function PANEL:SetCategory( att )
	if att ~= nil then
		self.Att = att
	end
end

function PANEL:GetAnchoredH()
	return true
end

-- @Deprecated
function PANEL:Position()
	-- self:SetPos( math.floor( self:GetParent():GetWide() - 32 - self:GetWide() ), math.max( self.VAtt - 1, 0 ) * dimensions + math.max( self.VAtt - 1, 0 ) * padding * 4 + math.max( self.VAtt - 1, 0 ) * spacing )
	-- self.HAnchored = true
end

function PANEL:Paint( w, h )
	if not self.HasInitialized then return false end

	if not IsValid(self.Wep)
		or not IsValid(self.Wep:GetOwner())
		or not self.Wep:GetOwner():IsPlayer()
		or self.Wep:GetOwner():GetActiveWeapon() ~= self.Wep
		or (self.Wep:GetInspectingProgress() or 0) < 0.01 then
		if IsValid(self.ToolTip) then
			self.ToolTip:Remove()
		end

		self:Remove()
	end
end

vgui.Register( "TFAAttachmentPanel", PANEL, "Panel" )
--addons/tfa_base/lua/tfa/modules/cl_tfa_attachment_tip.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local padding = TFA.Attachments.UIPadding
local PANEL = {}

PANEL.Wep = nil
PANEL.Header = nil
PANEL.TextTable = {}
PANEL.DefaultWidth = 0
PANEL.DefaultHeight = 0

function PANEL:SetWidthNeue( val )
	self.DefaultWidth = val
end

function PANEL:SetHeightNeue( val )
	self.DefaultHeight = val
end

function PANEL:Init()
	self.Wep = nil
	self.Header = nil
	self.TextTable = {}
	self.DefaultHeight = 0
	self.DefaultWidth = 0
	self:SetMouseInputEnabled(false)
	self:SetZPos(0)
	self.SetWidthOld = self.SetWidthOld or self.SetWidth
	self.SetWidth = self.SetWidthNeue
	self.SetHeightOld = self.SetHeightOld or self.SetHeight
	self.SetHeight = self.SetHeightNeue
end

function PANEL:SetWeapon( wepv )
	if IsValid(wepv) then
		self.Wep = wepv
	end
end

function PANEL:SetAttachment( att )
	if att ~= nil then
		self:SetZPos( 200 - att )
	end
end

function PANEL:SetHeader( h )
	self.Header = h
end

function PANEL:SetTextTable( t )
	self.TextTable = t or {}
end

PANEL.HeaderFont = "TFAAttachmentTTHeader"
PANEL.BodyFont = "TFAAttachmentTTBody"

function PANEL:GetHeaderHeight()
	if not IsValid(self.Wep) then return 0 end
	if not self.Header then return 0 end
	surface.SetFont(self.HeaderFont)
	local _, th = surface.GetTextSize( language.GetPhrase(self.Header) )
	return th + padding * 2
end

function PANEL:GetHeaderSize()
	if not IsValid(self.Wep) then return 0, 0 end
	if not self.Header then return 0, 0 end
	surface.SetFont(self.HeaderFont)
	local tw, th = surface.GetTextSize( language.GetPhrase(self.Header) )
	return tw + padding * 2, th + padding * 2
end

function PANEL:GetTextTableHeight()
	if not self.TextTable or #self.TextTable <= 0 then return 0 end
	local hv = padding
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local _, th = surface.GetTextSize( v )
			hv = hv + th
		end
	end
	hv = hv + padding
	return hv
end

function PANEL:GetTextTableSize(  )
	if not self.TextTable or #self.TextTable <= 0 then return 0, 0 end
	local mw = 0
	local hv = padding
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local tw, th = surface.GetTextSize( v )
			hv = hv + th
			mw = math.max( mw, tw )
		end
	end
	hv = hv + padding
	return mw + padding * 2, hv
end

function PANEL:DrawHeader( w, h )
	if not self.Header then return 0 end
	surface.SetFont(self.HeaderFont)

	local header = language.GetPhrase(self.Header)
	local _, th = surface.GetTextSize( header )
	draw.RoundedBox( 0, 0, 0, w, th + padding * 2, ColorAlpha( TFA.Attachments.Colors["background"], self.Wep:GetInspectingProgress() * 192 ) )
	if self.AnchoredH then
		draw.DrawText( header, self.HeaderFont, self:GetWide() / 2 , padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, w / 2 - tw / 2, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )

		--draw.DrawText( header, self.HeaderFont, self:GetWide() - padding, padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, w - padding - tw, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )
	else
		draw.DrawText( header, self.HeaderFont, padding, padding, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		--draw.RoundedBox( 0, padding, padding + th + padding / 4, tw, padding / 2, ColorAlpha( TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * 225 ) )
	end
	return th + padding * 2
end

function PANEL:DrawTextTable( x, y )
	if not self.TextTable then return 0 end
	--y = y + padding
	local hv = padding
	local acol = TFA.Attachments.Colors["primary"]
	surface.SetFont(self.BodyFont)
	for _,v in pairs(self.TextTable) do
		if type(v) == "table" or type(v) == "vector" then
			if v.r then
				acol = Color( v.r or 0, v.g or 0, v.b or 0, v.a or 255 )
			elseif v.x then
				acol = Color( v.x or 0, v.y or 0, v.z or 0, v.a or 255 )
			end
		end
		if type(v) == "string" then
			v = language.GetPhrase(v)
			local _, th = surface.GetTextSize( v )
			if self.AnchoredH then
				--draw.DrawText( v, self.BodyFont, x + self:GetWide() - padding, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
				draw.DrawText( v, self.BodyFont, x + padding * 2, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			else
				draw.DrawText( v, self.BodyFont, x + padding * 2, y + hv, ColorAlpha( acol, self.Wep:GetInspectingProgress() * 225 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end
			hv = hv + th
		end
	end
	hv = hv + padding
	return hv
end

function PANEL:CalcSize()
	local header_w, header_h = self:GetHeaderSize()
	local text_w, text_h = self:GetTextTableSize()
	self:SetWidthOld( math.max( self.DefaultWidth, math.max( header_w, text_w ) + padding * 2 ))
	local h = header_h + text_h
	if text_h > 0 then
		h = h + padding * 2
	end
	if IsValid( self.ContentPanel ) and not self:GetActive() then
		local _, cph = self.ContentPanel:LocalToScreen(0,self.ContentPanel:GetTall())
		local _, yy = self:LocalToScreen(0,0)
		h = math.min( h, cph - yy )
	end
	self:SetHeightOld( h )
end

function PANEL:CalcPos()
	if IsValid(self.Anchor) then
		local x,y = self.Anchor:LocalToScreen(0,0)
		y = y
		if self.Anchor:GetAnchoredH() then
			self.AnchoredH = true
			if IsValid( self.ContentPanel ) and self:GetActive() then
				local _, cph = self.ContentPanel:LocalToScreen(0,self.ContentPanel:GetTall())
				self:SetPos( x + self.Anchor:GetWide() - self:GetWide() , math.min( y + self.Anchor:GetTall(), cph - self:GetTall() ) )
			else
				self:SetPos( x + self.Anchor:GetWide() - self:GetWide() , math.min( y + self.Anchor:GetTall(), ScrH() - self:GetTall() ) )
			end
		else
			self.AnchoredH = false
			self:SetPos( x, y + self.Anchor:GetTall() )
		end
	end
end

function PANEL:Think()
	self:CalcSize()
	self:CalcPos()
end

function PANEL:SetContentPanel( p )
	if IsValid(p) then
		self.ContentPanel = p
	else
		self.ContentPanel = nil
	end
end

function PANEL:Paint( w, h )
	if not IsValid(self.Wep) then return end
	if ( self.Wep:GetInspectingProgress() or 0 ) < 0.01 then self:Remove() end
	if IsValid( self.ContentPanel ) and not self:GetActive() then
		local _, cph = self.ContentPanel:LocalToScreen(0,math.max(self.ContentPanel:GetTall(),32))
		local _, yy = self:LocalToScreen(0,0)
		if  cph - yy <= 0 then
			return
		end
	end
	draw.RoundedBox( 0, 0, 0, w, h, ColorAlpha( TFA.Attachments.Colors["background"], self.Wep:GetInspectingProgress() * 192 ) )
	local hh = self:DrawHeader( w, h )
	self:DrawTextTable( 0, hh )
	render.SetScissorRect(0,0,ScrW(),ScrH(),false)
end

function PANEL:SetActive( a )
	self.Active = a
end

function PANEL:GetActive( a )
	return self.Active
end

vgui.Register( "TFAAttachmentTip", PANEL, "Panel" )
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1, band(rshift(state, 30), 1) == 0 and 0 or 1, band(rshift(state, 31), 1) == 0 and 0 or 1		end
	
--addons/tfa_base/lua/tfa/modules/cl_tfa_projtex.lua:
local ply = LocalPlayer()
local LocalPlayer = LocalPlayer

hook.Add("PreRender", "TFACleanupProjectedTextures", function()
	if not IsValid(ply) then
		ply = LocalPlayer()
		if not IsValid(ply) then return end
	end

	local wep = ply:GetActiveWeapon()

	if not IsValid(wep) or not wep.IsTFAWeapon then
		if IsValid(ply.TFAFlashlightGun) then
			ply.TFAFlashlightGun:Remove()
		end

		if IsValid(ply.TFALaserDot) then
			ply.TFALaserDot:Remove()
		end
	end
end)

hook.Add("PrePlayerDraw", "TFACleanupProjectedTextures", function(plyv)
	local wep = plyv:GetActiveWeapon()

	if not IsValid(wep) or not wep.IsTFAWeapon then
		if IsValid(plyv.TFAFlashlightGun) then
			plyv.TFAFlashlightGun:Remove()
		end

		if IsValid(plyv.TFALaserDot) then
			plyv.TFALaserDot:Remove()
		end
	end
end)

--addons/tfa_base/lua/tfa/modules/cl_tfa_vm_blur.lua:
local supports
local cl_tfa_fx_dof, cl_tfa_fx_dof_hd
local fmat = CreateMaterial("TFA_DOF_Material4", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "1.5",
	["$nofog"] = "1"
})

local fmat2 = CreateMaterial("TFA_DOF_Material5", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "0.9",
	["$nofog"] = "1"
})

local fmat3 = CreateMaterial("TFA_DOF_Material16", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "0.8",
	["$nofog"] = "1"
})

local white = CreateMaterial("TFA_DOF_White", "UnlitGeneric", {
	["$alpha"] = "0",
	["$basetexture"] = "models/debug/debugwhite"
})

TFA.LastRTUpdate = TFA.LastRTUpdate or UnPredictedCurTime()

hook.Add("PreDrawViewModel", "TFA_DrawViewModel", function(vm, plyv, wep)
	if not vm or not plyv or not wep then return end
	if not wep.IsTFAWeapon then return end

	if supports == nil then
		supports = render.SupportsPixelShaders_1_4() and render.SupportsPixelShaders_2_0() and render.SupportsVertexShaders_2_0()

		if not supports then
			print("[TFA] Your videocard does not support pixel shaders! DoF of Iron Sights is disabled!")
		end
	end

	if not supports then return end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then return end
	if not wep.AllowIronSightsDoF then return end
	local aimingDown = wep:GetIronSightsProgress() > 0.4
	local scoped = TFA.LastRTUpdate > UnPredictedCurTime() or wep:GetStatL("Scoped")

	if aimingDown and not scoped then
		if hook.Run("TFA_AllowDoFDraw", wep, plyv, vm) == false then return end
		wep.__TFA_AimDoFFrame = FrameNumber()
		render.ClearStencil()
		render.SetStencilEnable(true)
		render.SetStencilTestMask(0)
		render.SetStencilWriteMask(1)
		render.SetStencilReferenceValue(1)
		render.SetStencilCompareFunction(STENCIL_ALWAYS)
		render.OverrideColorWriteEnable(true, true)
		render.SetStencilZFailOperation(STENCIL_KEEP)
		render.SetStencilPassOperation(STENCIL_REPLACE)
		render.SetStencilFailOperation(STENCIL_KEEP)
	end
end)

local transparent = Color(0, 0, 0, 0)
local color_white = Color(255, 255, 255)
local STOP = false

local function DrawDOF(muzzledata,fwd2)
	local w, h = ScrW(), ScrH()
	render.SetMaterial(fmat)
	cam.Start2D()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(fmat)
	surface.DrawTexturedRect(0, 0, w, h)
	cam.End2D()

	if muzzledata then
		-- :POG:
		render.SetMaterial(fmat2)

		for i = 28, 2, -1 do
			render.UpdateScreenEffectTexture()
			render.DrawSprite(muzzledata.Pos - fwd2 * i * 3, 200, 200, color_white)
		end
	end

	render.SetMaterial(fmat3)
	cam.Start2D()
	surface.SetMaterial(fmat3)

	for i = 0, 32 do
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(0, h / 1.6 + h / 2 * i / 32, w, h / 2)
	end

	cam.End2D()
end

hook.Add("PostDrawViewModel", "TFA_DrawViewModel", function(vm, plyv, wep)
	if not wep.IsTFAWeapon then return end

	if not supports then
		wep:ViewModelDrawnPost()
		return
	end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof_hd then
		cl_tfa_fx_dof_hd = GetConVar("cl_tfa_fx_ads_dof_hd")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then
		wep:ViewModelDrawnPost()
		return
	end

	if not wep:GetStatL("AllowIronSightsDoF") then
		wep:ViewModelDrawnPost()
		return
	end

	local aimingDown = wep:GetIronSightsProgress() > 0.4
	local eangles = EyeAngles()
	local fwd2 = vm:GetAngles():Forward()
	local scoped = TFA.LastRTUpdate > UnPredictedCurTime()

	if aimingDown and not scoped and wep.__TFA_AimDoFFrame == FrameNumber() then
		fmat:SetFloat("$alpha", wep:GetIronSightsProgress())

		local muzzle = wep:GetStatL("IronSightsDoF_FocusAttachment")
		if not muzzle then
			wep:UpdateMuzzleAttachment()
			wep:SetStatRawL("IronSightsDoF_FocusAttachment", wep.MuzzleAttachmentRaw)

			muzzle = wep:GetStatL("IronSightsDoF_FocusAttachment")
		end

		muzzle = hook.Run("TFA_GetDoFMuzzleAttachmentID", wep, plyv, vm, muzzle) or muzzle

		local muzzledata
		if muzzle and muzzle ~= 0 then
			muzzledata = vm:GetAttachment(muzzle)
		end

		local hands = plyv:GetHands()

		if IsValid(hands) and wep.UseHands then
			render.OverrideColorWriteEnable(true, false)
			STOP = true
			local candraw = hook.Run("PreDrawPlayerHands", hands, vm, plyv, wep)
			STOP = false
			if candraw ~= true then
				if wep.ViewModelFlip then
					render.CullMode(MATERIAL_CULLMODE_CW)
				end

				hands:DrawModel()

				if wep.ViewModelFlip then
					render.CullMode(MATERIAL_CULLMODE_CCW)
				end
			end

			render.OverrideColorWriteEnable(false, false)
		end

		if muzzledata then
			render.SetStencilPassOperation(STENCIL_ZERO)
			render.SetMaterial(white)
			render.DrawSprite(muzzledata.Pos - fwd2 * 6 + eangles:Up() * 4, 30, 30, transparent)
			render.SetStencilPassOperation(STENCIL_REPLACE)
		end

		render.SetStencilTestMask(1)
		render.SetStencilWriteMask(2)
		render.SetStencilCompareFunction(STENCIL_EQUAL)
		render.SetStencilPassOperation(STENCIL_REPLACE)
		render.UpdateScreenEffectTexture()
		render.PushFilterMin(TEXFILTER.ANISOTROPIC)
		render.PushFilterMag(TEXFILTER.ANISOTROPIC)
		if cl_tfa_fx_dof_hd and cl_tfa_fx_dof_hd:GetBool() then
			DrawDOF(muzzledata,fwd2)
		else
			DrawToyTown(3,ScrH() * 2 / 3 )
		end
		render.PopFilterMin()
		render.PopFilterMag()
		--render.PopRenderTarget()
		render.SetStencilEnable(false)
	end

	wep:ViewModelDrawnPost()
end)

hook.Add("PreDrawPlayerHands", "TFA_DrawViewModel", function(hands, vm, plyv, wep)
	if STOP then return end
	if not wep.IsTFAWeapon then return end
	if not supports then return end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then return end
	if not wep.AllowIronSightsDoF then return end
	if TFA.LastRTUpdate > UnPredictedCurTime() then return end
	if wep:GetIronSightsProgress() > 0.4 then return true end
end)

hook.Add("PostDrawPlayerHands", "TFA_DrawViewModel", function(hands, vm, plyv, wep)
	if not wep.IsTFAWeapon then return end

	wep:ViewModelDrawnPostFinal()
end)

--addons/egm_tfa_weapons/lua/tfa/att/rocket_mod_control.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Steuerungsmodus"
ATTACHMENT.ShortName = "S.M"
ATTACHMENT.Icon = "entities/atts/rctm_control.png"
ATTACHMENT.Description = {
	TFA.AttachmentColors["="], "Du kannst die Rakete steuern.",
	TFA.AttachmentColors["="], "10 Sekunden Lebensdauer.",
	TFA.AttachmentColors["="], "Geschwindigkeit von 100m/s.",
}

ATTACHMENT.WeaponTable = {
	["VElements"] = {},
	["WElements"] = {
		["laser_beam"] = {["active"] = false},
		["laser_beam_control"] = {["active"] = true},
	},
	["Primary"] = {},
}

function ATTACHMENT:Attach(wep)
	wep.data.ironsights = 0
	wep:Unload()
end

function ATTACHMENT:Detach(wep)
	wep.data.ironsights = 1
	wep:Unload()
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--addons/tfa_base/lua/tfa/att/si_rt_base.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "RT Scope Base"
ATTACHMENT.Description = {}

ATTACHMENT.WeaponTable = {
	["RTDrawEnabled"] = true,

	-- ["RTScopeFOV"] = 90 / 1 / 2, -- Default FOV / Scope Zoom / screenscale
	-- ["RTScopeAttachment"] = -1,

	-- ["RTReticleMaterial"] = Material("scope/gdcw_acog"),
	-- ["RTReticleColor"] = color_white,
	-- ["RTReticleScale"] = 1,

	-- ["RTShadowMaterial"] = Material("vgui/scope_shadowmask_test"),
	-- ["RTShadowColor"] = color_white,
	-- ["RTShadowScale"] = 2,
}

local cd = {}

local fallbackReticle = Material("scope/gdcw_scopesightonly")
local fallbackShadow = Material("vgui/scope_shadowmask_test")

local flipcv = GetConVar("cl_tfa_viewmodel_flip")

function ATTACHMENT:RTCode(wep, rt, scrw, scrh)
	if not wep.OwnerIsValid or not wep:VMIV() then return end

	local rtw, rth = rt:Width(), rt:Height()

	-- clearing view
	render.OverrideAlphaWriteEnable(true, true)
	surface.SetDrawColor(color_white)
	surface.DrawRect(-rtw, -rth, rtw * 2, rth * 2)

	local vm = wep.OwnerViewModel

	local ang = vm:GetAngles()

	local isang = wep:GetStatL("IronSightsAngle") * wep:GetIronSightsProgress()

	ang:RotateAroundAxis(ang:Forward(), -isang.z)
	ang:RotateAroundAxis(ang:Right(), -isang.x)
	ang:RotateAroundAxis(ang:Up(), -isang.y)

	ang:RotateAroundAxis(ang:Forward(), isang.z)

	local scopeAtt = wep:GetStatL("RTScopeAttachment", -1)

	if scopeAtt > 0 then
		local AngPos = vm:GetAttachment(scopeAtt)

		if AngPos then
			ang = AngPos.Ang

			if flipcv:GetBool() then
				ang.y = -ang.y
			end
		end
	end

	cd.angles = ang
	cd.origin = wep:GetOwner():GetShootPos()
	cd.x = 0
	cd.y = 0
	cd.w = rtw
	cd.h = rth
	cd.fov = wep:GetStatL("RTScopeFOV", 90 / wep:GetStatL("ScopeZoom", 1) / 2)
	cd.drawviewmodel = false
	cd.drawhud = false

	-- main RT render view
	render.Clear(0, 0, 0, 255, true, true)
	render.SetScissorRect(0, 0, rtw, rth, true)

	if wep:GetIronSightsProgress() > 0.005 then
		render.RenderView(cd)
	end

	render.SetScissorRect(0, 0, rtw, rth, false)
	render.OverrideAlphaWriteEnable(false, true)

	cam.Start2D()

	-- ADS transition darkening
	draw.NoTexture()
	surface.SetDrawColor(ColorAlpha(color_black, 255 * (1 - wep:GetIronSightsProgress())))
	surface.DrawRect(0, 0, rtw, rth)

	surface.SetMaterial(wep:GetStatL("RTReticleMaterial", fallbackReticle))
	surface.SetDrawColor(wep:GetStatL("RTReticleColor", color_white))
	local retScale = wep:GetStatL("RTReticleScale", 1)
	surface.DrawTexturedRect(rtw / 2 - rtw * retScale / 2, rth / 2 - rth * retScale / 2, rtw * retScale, rth * retScale)

	surface.SetMaterial(wep:GetStatL("RTShadowMaterial", fallbackShadow))
	surface.SetDrawColor(wep:GetStatL("RTShadowColor", color_white))
	local shadScale = wep:GetStatL("RTShadowScale", 2)
	surface.DrawTexturedRect(rtw / 2 - rtw * shadScale / 2, rth / 2 - rth * shadScale / 2, rtw * shadScale, rth * shadScale)

	cam.End2D()
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--addons/egm_tfa_weapons/lua/tfa/att/swrp_am_dumb_fire.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Dumb Fire Mode"
ATTACHMENT.ShortName = "DUMB"
ATTACHMENT.Description = {
	TFA.AttachmentColors["-"],"Disables the target locking.",
}
ATTACHMENT.Icon = "entities/icon/mod_stun10.png"

ATTACHMENT.WeaponTable = {
	["GuidedThinkBlock"] = function( wep, stat ) return true end
}

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_dc17m_sniper.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Sniper Module"
ATTACHMENT.ShortName = "S.M."
ATTACHMENT.Icon = "entities/dc17m_sniper.png"
ATTACHMENT.Description = {
	TFA.AttachmentColors["="], "Wechsel zum Sniper Aufsatz",
	TFA.AttachmentColors["+"], "150 Damage",
}

ATTACHMENT.WeaponTable = {
	["FireModes"] = {
		"Single"
	},
	["VElements"] = {
		["rifle_module"] = {["active"] = false},
		["rifle_mag"] = {["active"] = false},
		["sniper_module"] = {["active"] = true},
		["sniper_module_scope"] = {["active"] = true},
		["sniper_module_hp1"] = {["active"] = true},
		["sniper_module_hp2"] = {["active"] = true},
		["sniper_mag"] = {["active"] = true},
	},
	["WElements"] = {
		["rifle_module"] = {["active"] = false},
		["rifle_mag"] = {["active"] = false},
		["sniper_module"] = {["active"] = true},
		["sniper_module_scope"] = {["active"] = true},
		["sniper_module_hp1"] = {["active"] = true},
		["sniper_module_hp2"] = {["active"] = true},
		["sniper_mag"] = {["active"] = true},
	},

	["Primary"] = {
		["Sound"] = "w/dc17msniper.wav",
		["KickUp"] = function(wep,stat) return stat * 2 end,
		["KickDown"] = function(wep,stat) return stat * 2 end,
		["ClipSize"] = 5,
		["RPM"] = 350,
		["Damage"] = 150,
		["IronAccuracy"] = 0,
		["Range"] = nil
	},
	["IronSightsPos"] = function(wep, val) return wep.Scope1Pos or val, true end,
	["IronSightTime"] = function(wep, stat) return stat * 1.5 end,
	["IronSightMoveSpeed"] = function(stat) return stat * 0.8 end,
	["RTOpaque"] = true,
	["RTMaterialOverride"] = -1,
	["RTScopeAttachment"] = -1,
	["IronSightsSensitivity"] = 0.25,
	["HeatPerShot"] = 0,
	["RTBGBlur"] = true,
}

function ATTACHMENT:Attach(wep)
	wep:Unload()
end

function ATTACHMENT:Detach(wep)
	wep:Unload()

	timer.Simple(1, function()
		wep:SetFireMode(1)
		wep:CycleSafety()
		wep.IronSightsSensitivity = 0.25
	end)
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--lua/autorun/tfa_srv_rp_utils.lua:
--[[
Coded by TFA ( http://steamcommunity.com/profiles/76561198161775645 )
Commissioned by Servius ( http://steamcommunity.com/profiles/76561198036188853/ )
Written: 1/19/2017
Begun: 9:52 PM CDT
Draft 1 Finished: 11:49 PM CDT
]]--

--[[Documentation]]--

--[[Stunning]]--

--For GENERAL USAGE, use TFA_RP_Stun( ply, duration, effect )
--ply is the player to stun, duration is the length to stun, and effect is the Lua effect to use
--Leaving the effect to nil will give it a pronounced lightning effect.  Or, setting it to "BGOLightning" will give it a nice lightning effect which lasts for a set length of 5 seconds.
--Example: TFA_RP_Stun( Entity(1), 5, "TeslaHitBoxes" )

--For SWEPs, use TFA_RP_StunEasy( a,b,c, length, effect )
--This function is easily placed in a bullet callback; length and effect are optional, but not required.  Length will default to 3.
--TFA Base example:
--SWEP.CustomBulletCallback = function(a,b,c)
--	TFA_RP_StunEasy(a,b,c)
--end

--[[Melting]]--

--For GENERAL USAGE, use TFA_RP_Melt( ent, fade, duration, recovery, fx, snd, col  )
--ent is the entity to melt ( please use carefully ), fade is the "fade-in" of the melting animation, duration is the recovery to remain melted, and recovery is the "fade-out" of the melting animation
--optionally: fx is the Lua effect to use, snd is the melt sound, and col is the melt color ( defined as a Color(r,g,b,a) )
--Example:  TFA_RP_Melt( Entity(1):GetEyeTrace().Entity, 1, 15, 1, "Explosion", "misc/bomb.wav", Color(255,0,0,255)  )

--For SWEPs, use TFA_RP_MeltEasy( a,b,c, duration, fx, snd, col )
--This function is easily placed in a bullet callback; Duration is optional, but not required, and will default to 15.
--TFA Base example:
--SWEP.CustomBulletCallback = function(a,b,c)
--	TFA_RP_MeltEasy(a,b,c)
--end

--[[ Important Funcs/Vars ]]--

local wrongsound = "common/warning.wav" --Error sound for easy SWEP accessors
local MeltColor = Color( 0,0,0, 255 ) --Default melt color

function TFA_RP_StunEasy( a,b,c, length, effect )
	if IsValid(b.Entity) and b.Entity:IsPlayer() then
		TFA_RP_Stun( b.Entity, length or 3, effect or "BGOLightning" )
	elseif IsValid(b.Entity) and ( not b.Entity:IsWorld() ) and surface then
		surface.PlaySound( wrongsound )
	end
end

function TFA_RP_Stun( ent, duration, effect )
	ent:SetNW2Float("TFA_RP_StunEnd", CurTime() + duration )
	if ent.GetActiveWeapon and IsValid( ent:GetActiveWeapon() ) then
		local wep = ent:GetActiveWeapon()
		wep:SetNextPrimaryFire( math.max( wep:GetNextPrimaryFire(), CurTime() + duration ) )
		wep:SetNextSecondaryFire(wep:GetNextPrimaryFire() )
	end
	effect = effect or "TeslaHitBoxes"
	if effect == "BGOLightning" then
		ent.NextBGOLightning = ent.NextBGOLightning  or 0
		if CurTime() > ent.NextBGOLightning then
			ParticleEffectAttach("tfa_lightning_model", PATTACH_ABSORIGIN_FOLLOW, ent, 0)
			ent.NextBGOLightning  = CurTime() + 1
		end
		ent:SetNW2String("TFA_RP_StunFX","")
	else
		local fx = EffectData()
		fx:SetOrigin( ent:GetShootPos() )
		fx:SetNormal( Vector(0,0,1) )
		fx:SetEntity(ent)
		fx:SetScale(1)
		fx:SetMagnitude(1)
		util.Effect(effect,fx)
		ent:SetNW2String("TFA_RP_StunFX",effect)
	end
end

function TFA_RP_MeltEasy( a,b,c, duration, ... )
	duration = duration or 15
	if IsValid(b.Entity) and b.Entity:GetClass() == "prop_physics" then
		TFA_RP_Melt( b.Entity, 1, duration, 1, ... )
	elseif IsValid(b.Entity) and ( not b.Entity:IsWorld() ) and b.Entity:GetClass() ~= "prop_physics" and surface then
		surface.PlaySound( wrongsound )
	end
end

function TFA_RP_Melt( ent, fade, duration, recovery, fx, snd, col  )
	if not SERVER then return end
	local ct = CurTime()
	ent.Melt_FadeStart = ent.Melt_FadeStart or ct
	local fade2 = fade - ( ct - ent.Melt_FadeStart )
	ent.Melt_PreMeltColor = ent.Melt_PreMeltColor or ent:GetColor()
	ent.Melt_HideStart = ct + fade2
	ent.Melt_RecoverStart = ct + fade2 + duration
	ent.Melt_RecoverEnd = ct + fade2 + duration + recovery
	ent.Melt_FinishEffect = fx or "ManhackSparks"
	ent.Melt_FinishSound = snd or "Explosion"
	ent.Melt_FinishColor = col or MeltColor
	local hkid = ent:EntIndex() .. "melt"
	hook.Add("Tick",hkid, function()
		local mt = TFA_RP_MeltThink(ent)
		if not mt then
			hook.Remove( "Tick", hkid )
		end
	end)
end

--[[ Acid ]]--

local l_Lerp = Lerp
local l_Clamp = math.Clamp
local tmpcol = Color(0,0,0,255)

local function MixCol(fac, from, to)
	tmpcol.r = l_Lerp(fac, from.r, to.r)
	tmpcol.g = l_Lerp(fac, from.g, to.g)
	tmpcol.b = l_Lerp(fac, from.b, to.b)
	tmpcol.a = l_Lerp(fac, from.a, to.a)

	return tmpcol
end

local function CalcFac( t, startv, endv )
	return l_Clamp( ( t - startv ) / ( endv - startv ), 0, 1 )
end

local upvec = Vector(0,0,1)

local function MeltEnt( ent )
	if not IsValid(ent) then return end
	if ent.IsMelted then return end
	ent.IsMelted = true
	local fx = EffectData()
	fx:SetOrigin(ent:GetPos())
	fx:SetEntity(ent)

	util.Effect( ent.Melt_FinishEffect or "ManhackSparks", fx)
	fx:SetScale(0.1)
	fx:SetMagnitude(0.1)
	fx:SetNormal( upvec )
	if ent.Melt_FinishSound and ent.Melt_FinishSound == "Explosion" then
		util.Effect("Explosion", fx)
	elseif ent.Melt_FinishSound then
		ent:EmitSound( ent.Melt_FinishSound )
	end
	if not ent.GetPhysicsObject then return end
	local phys = ent:GetPhysicsObject()

	if IsValid(phys) and IsValid(ent) then
		ent.Melt_OldMotion = ent.Melt_OldMotion or phys:IsMotionEnabled()
		ent.Melt_OldCollisions = ent.Melt_OldCollisions or phys:IsCollisionEnabled()
		ent.Melt_OldCollisionGroup = ent.Melt_OldCollisionGroup or ent:GetCollisionGroup()
		phys:EnableMotion(false)
		phys:EnableCollisions(false)
		ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		ent.Melt_OldRenderMode = ent.Melt_OldRenderMode or ent:GetRenderMode()
		ent:SetRenderMode(RENDERMODE_TRANSALPHA)
	end
end

local function UnMeltEnt( ent )
	if not IsValid(ent) then return end
	if not ent.IsMelted then return end
	if not ent.GetPhysicsObject then return end
	local phys = ent:GetPhysicsObject()
	if IsValid(phys) then
		phys:EnableMotion( ent.Melt_OldMotion )
		phys:EnableCollisions( ent.Melt_OldCollisions )
		ent:SetCollisionGroup( ent.Melt_OldCollisionGroup or COLLISION_GROUP_NONE)
		ent:SetRenderMode( ent.Melt_OldRenderMode or RENDERMODE_NORMAL)
		ent.Melt_OldCollisions = nil
		ent.Melt_OldCollisionGroup = nil
		ent.Melt_OldRenderMode = nil
		ent.Melt_OldMotion = nil
	end
	ent.IsMelted = false
end

function TFA_RP_MeltThink( ent )
	if not IsValid(ent) then return false end
	if not ent.Melt_FadeStart then return false end
	if not ent.Melt_HideStart then return false end
	if not ent.Melt_RecoverStart then return false end
	if not ent.Melt_RecoverEnd then return false end
	local color_begin = ent.Melt_PreMeltColor or color_white
	local color_end = ent.Melt_FinishColor or MeltColor
	local ct = CurTime()
	if ct > ent.Melt_RecoverEnd then
		ent.Melt_FadeStart = nil
		ent.Melt_HideStart = nil
		ent.Melt_RecoverStart = nil
		ent.Melt_RecoverEnd = nil
		ent.Melt_PreMeltColor = nil
		ent.IsMelted = false
		ent:SetColor( color_begin )
	elseif ct > ent.Melt_RecoverStart then
		local fac = CalcFac( CurTime(), ent.Melt_RecoverStart, ent.Melt_RecoverEnd )
		ent:SetColor( MixCol( fac, color_end, color_begin ) )
		UnMeltEnt( ent )
	elseif ct > ent.Melt_HideStart then
		MeltEnt( ent )
		ent:SetColor( ColorAlpha( color_end, 50 ) )
	elseif ct > ent.Melt_FadeStart then
		local fac = CalcFac( CurTime(), ent.Melt_FadeStart, ent.Melt_HideStart )
		ent:SetColor( MixCol( fac, color_begin, color_end ) )
	end
	return true
end

--[[ Stunning! ]]--

game.AddParticles("particles/sv_tfa_lightningfx.pcf")
PrecacheParticleSystem("tfa_lightning_model")

hook.Add("Move","TFA_RPStun_Move",function(ent,mv,cmd) end)
hook.Add("SetupMove","TFA_RPStun_Move",function(ent,mv,cmd)
	if CurTime() < ( ent:GetNW2Float("TFA_RP_StunEnd",-1) or -1 ) then
		mv:SetMaxSpeed(0.01)
		mv:SetMaxClientSpeed(0.01)
		mv:SetButtons(0)
		cmd:RemoveKey( IN_ATTACK )
		cmd:RemoveKey( IN_ATTACK2 )
		cmd:RemoveKey( IN_ZOOM )
		--if SERVER then
		local str = ent:GetNW2String("TFA_RP_StunFX")
		if str and str ~= "" then
			local fx = EffectData()
			fx:SetOrigin( ent:GetShootPos() )
			fx:SetNormal( Vector(0,0,1) )
			fx:SetEntity(ent)
			fx:SetScale(1)
			fx:SetMagnitude(1)
			util.Effect(str,fx)
		end
		--end
	end
end)
hook.Add("PlayerSwitchWeapon","TFA_RPStun_PSW",function(ply,owp,nwp)
	if CurTime() < ( ply:GetNW2Float("TFA_RP_StunEnd",-1) or -1 ) then
		return true
	end
end)
--lua/autorun/tschubaki.lua:
list.Set( "Navy Officer 1", "models/navy_officer_1/navy_officer_1.mdl" )

player_manager.AddValidModel( "Navy Officer 1", "models/navy_officer_1/navy_officer_1.mdl" )
list.Set( "Navy Officer 2", "models/navy_officer_2/navy_officer_2.mdl" )

player_manager.AddValidModel( "Navy Officer 2", "models/navy_officer_2/navy_officer_2.mdl" )
list.Set( "Navy Officer 3", "models/navy_officer_3/navy_officer_3.mdl" )

player_manager.AddValidModel( "Navy Officer 3", "models/navy_officer_3/navy_officer_3.mdl" )
list.Set( "Navy Officer 4", "models/navy_officer_4/navy_officer_4.mdl" )

player_manager.AddValidModel( "Navy Officer 4", "models/navy_officer_4/navy_officer_4.mdl" )
list.Set( "Navy Officer 5", "models/navy_officer_5/navy_officer_5.mdl" )

player_manager.AddValidModel( "Navy Officer 5", "models/navy_officer_5/navy_officer_5.mdl" )

list.Set( "Navy Officer 6", "models/navy_officer_6/navy_officer_6.mdl" )
player_manager.AddValidModel( "Navy Officer 6", "models/navy_officer_6/navy_officer_6.mdl" )

list.Set( "Navy Officer 7", "models/navy_officer_7/navy_officer_7.mdl" )
player_manager.AddValidModel( "Navy Officer 7", "models/navy_officer_7/navy_officer_7.mdl" )

list.Set( "Navy Tarkin", "models/navy_tarkin/navy_tarkin.mdl" )
player_manager.AddValidModel( "Navy Tarkin", "models/navy_tarkin/navy_tarkin.mdl" )

list.Set( "Navy Krennic", "models/navy_krennic/navy_krennic.mdl" )
player_manager.AddValidModel( "Navy Krennic", "models/navy_krennic/navy_krennic.mdl" )

--addons/vyhub-gmod/lua/vyhub/config/sh_config.lua:
-- Language used. Currently only languages in the "lang" directory are supported.
VyHub.Config.lang = "de"

-- Enable chat tags, not working together with DarkRP
VyHub.Config.chat_tags = false

-- Date format to use (for example in ban message)
-- See https://tieske.github.io/date/#dateObject.fmt
VyHub.Config.date_format = "%Y-%m-%d %H:%M:%S %z"
-- Time offset from UTC (+00:00)
-- Uses the timezone of the GMOD server when set to nil
-- Example: 2 for CEST, -5 for EST
VyHub.Config.time_offset = nil

-- Debug mode. Enable to see all API requests and responses
VyHub.Config.debug = false
--addons/vyhub-gmod/lua/vyhub/shared/sh_util.lua:
local f = string.format
local date = VyHub.Lib.date

VyHub.Util = VyHub.Util or {}
VyHub.Util.chat_commands = VyHub.Util.chat_commands or {}

if SERVER then
	util.AddNetworkString("vyhub_print_chat")
	util.AddNetworkString("vyhub_play_sound")
	util.AddNetworkString("vyhub_open_url")
end

function VyHub.Util:format_datetime(unix_timestamp)
    unix_timestamp = unix_timestamp or os.time()

    local tz_wrong = os.date("%z", unix_timestamp)
    local timezone = f("%s:%s", string.sub(tz_wrong, 1, 3), string.sub(tz_wrong, 4, 5))

    return os.date("%Y-%m-%dT%H:%M:%S" .. timezone, unix_timestamp)
end

function VyHub.Util:is_server(obj)
	if type(obj) == "Entity" and (obj.EntIndex and obj:EntIndex() == 0) and !IsValid(obj) then
		return true
	else
		return false
	end
end

function VyHub.Util:iso_to_unix_timestamp(datetime)
	if datetime == nil then return nil end

	local pd = date(datetime)

	if pd == nil then return nil end

	local time = os.time(
		{
			year = pd:getyear(),
			month = pd:getmonth(),
			day = pd:getday(),
			hour = pd:gethours(),
			minute = pd:getminutes(),
			second = pd:getseconds(),
		}
	)

	return time
end

function VyHub.Util:get_ply_by_nick(nick)
	nick = string.lower(nick);
	
	for _, v in ipairs(player.GetHumans()) do
		if(string.find(string.lower(v:Name()), nick, 1, true) != nil)
			then return v;
		end
	end
end

function VyHub.Util:register_chat_command(strCommand, Func)
	if !strCommand || !Func then return end
	
	for k, v in pairs( VyHub.Util.chat_commands ) do
		if( strCommand == k ) then
			return
		end
	end
	
	VyHub.Util.chat_commands[ tostring( strCommand ) ] = Func;
end

function VyHub.Util:concat_args(args, pos)
	local toconcat = {}

	if pos > 1 then
		for i = pos, #args, 1 do
			toconcat[#toconcat+1] = args[i]
		end
	end

	return string.Implode(" ", toconcat)
end


if SERVER then
	hook.Add("PlayerSay", "vyhub_util_PlayerSay", function(ply, message)
		if VyHub.ready then
			local chat_string = string.Explode(" ", message)
			local ret = nil
		
			for k, v in pairs( VyHub.Util.chat_commands ) do
				if( string.lower(chat_string[1]) == string.lower(k) ) then
					table.remove(chat_string, 1)
					ret = v(ply, chat_string)
					break
				end
			end
		
			if ret != nil then
				return ret
			end
		end	
	end)
end

local colors = {
	red = Color(255, 24, 35),
	green = Color(45, 170, 0),
	blue = Color(0, 115, 204),
	yellow = Color(229, 221, 0),
	pink = Color(229, 0, 218),
}

-- Takes a str message with colors and returns a table
function VyHub.Util:replace_colors(message, no_color)
    local resultTable = {}
    local currentIndex = 1

    local function getColor(colorName)
        if colors[colorName] then
            return colors[colorName]
        else
            return no_color
        end
    end

    local function addStringToTable(str, color)
        table.insert(resultTable, color)
        table.insert(resultTable, str)
    end

    local tags = {}

    -- Extract all color tags and their corresponding content
    for tag, content in string.gmatch(message, "<([%l]+)>([^<]+)</%1>") do
        table.insert(tags, {tag = tag, content = content})
    end

    -- Process the string, splitting it based on the color tags
    for _, tagData in ipairs(tags) do
        local startIndex, endIndex = string.find(message, f("<(%s)>[^<]+</%s>", string.PatternSafe(tagData.tag), string.PatternSafe(tagData.tag)), currentIndex, false)

        if startIndex then
            local str = string.sub(message, currentIndex, startIndex - 1)

            addStringToTable(str, no_color)
            addStringToTable(tagData.content, getColor(tagData.tag))

            currentIndex = endIndex + 1
        end
    end

    -- Append any remaining part of the string
    local str = string.sub(message, currentIndex)
    if str != "" then
        addStringToTable(str, no_color)
    end

    return resultTable
end

local color_tag = Color(0, 187, 255)

function VyHub.Util:print_chat(ply, message, tag, color)
	color = color or color_white
	
	if SERVER then
		if IsValid(ply) then
			if not VyHub.Config.chat_tag then
				VyHub.Config.chat_tag = "[VyHub] "
			end

			if not tag then
				tag = VyHub.Config.chat_tag
			end

			message = string.Replace(message, '\r', '')
			message = string.Replace(message, '\n', '')

			net.Start("vyhub_print_chat")
				net.WriteString(message)
				net.WriteString(tag)
				net.WriteColor(color)
			net.Send(ply)
		end
	elseif CLIENT then
		msg_table = VyHub.Util:replace_colors(message, color)

		chat.AddText(color_tag, tag, color_white, unpack(msg_table))
	end
end

function VyHub.Util:print_chat_steamid(steamid, message, tag, color)
	if steamid != nil and steamid != false then
		local ply = player.GetBySteamID64(steamid)
	
		if IsValid(ply) then
			VyHub.Util:print_chat(ply, message, tag, color)
		end
	end
end

function VyHub.Util:play_sound_steamid(steamid, url)
	if steamid then
		local ply = player.GetBySteamID64(steamid)
	
		if IsValid(ply) then
			return VyHub.Util:play_sound(ply, url)
		end
	end
end

function VyHub.Util:play_sound(ply, url)
	if SERVER then
		if IsValid(ply) then
			net.Start("vyhub_play_sound")
				net.WriteString(url)
			net.Send(ply)
		end
	elseif CLIENT then
		sound.PlayURL ( url, "", function() end)
	end
end

function VyHub.Util:open_url(ply, url)
	if SERVER then
		if IsValid(ply) then
			net.Start("vyhub_open_url")
				net.WriteString(url)
			net.Send(ply)
		end
	elseif CLIENT then
		gui.OpenURL(url)
	end
end

function VyHub.Util:print_chat_all(message, tag, color)
	for _, ply in ipairs(player.GetHumans()) do
		VyHub.Util:print_chat(ply, message, tag, color)
	end
end


function VyHub.Util:get_player_by_nick(nick)
	nick = string.lower(nick);
	
	for _,v in ipairs(player.GetHumans()) do
		if(string.find(string.lower(v:Name()), nick, 1, true) != nil)
			then return v;
		end
	end
end


function VyHub.Util:hex2rgb(hex)
    hex = hex:gsub("#","")
    if(string.len(hex) == 3) then
        return Color(tonumber("0x"..hex:sub(1,1)) * 17, tonumber("0x"..hex:sub(2,2)) * 17, tonumber("0x"..hex:sub(3,3)) * 17)
    elseif(string.len(hex) == 6) then
        return Color(tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6)))
    else
    	return color_white
    end
end

function VyHub.Util:iso_ts_to_local_str(iso_ts)
	local bias = VyHub.Config.time_offset != nil and -math.Round(VyHub.Config.time_offset * 60 * 60) or nil

	return date(iso_ts):setbias(bias):tolocal():fmt(VyHub.Config.date_format)
end


function VyHub.Util:invalid_str(str_list)
	for _, str in ipairs(str_list) do
		if str == nil or string.Trim(str) == "" then
			return true
		end
	end

	return false
end

function VyHub.Util:escape_concommand_str(str)
	str = string.Replace(str, '"', "'")

	return str
end



if CLIENT then
	net.Receive("vyhub_print_chat", function ()
		local message = net.ReadString()
		local tag = net.ReadString()
		local color = net.ReadColor()

		VyHub.Util:print_chat(nil, message, tag, color)
	end)

	net.Receive("vyhub_play_sound", function ()
		local url = net.ReadString()

		VyHub.Util:play_sound(nil, url)
	end)

	net.Receive("vyhub_open_url", function ()
		local url = net.ReadString()

		VyHub.Util:open_url(nil, url)
	end)
end

--addons/wiltos_animation_base/lua/wos/anim_extension/extensions/wos_riddick.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Riddick" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Riddick\n" )
--lua/advdupe2/file_browser.lua:
--[[
	Title: Adv. Dupe 2 File Browser

	Desc: Displays and interfaces with duplication files.

	Author: TB

	Version: 1.0
]]

local History = {}
local Narrow = {}

local switch = true
local count = 0

local function AddHistory(txt)
	txt = string.lower(txt)
	local char1 = txt[1]
	local char2
	for i = 1, #History do
		char2 = History[i][1]
		if (char1 == char2) then
			if (History[i] == txt) then
				return
			end
		elseif (char1 < char2) then
			break
		end
	end

	table.insert(History, txt)
	table.sort(History, function(a, b) return a < b end)
end

local function NarrowHistory(txt, last)
	txt = string.lower(txt)
	local temp = {}
	if (last <= #txt and last ~= 0 and #txt ~= 1) then
		for i = 1, #Narrow do
			if (Narrow[i][last + 1] == txt[last + 1]) then
				table.insert(temp, Narrow[i])
			elseif (Narrow[i][last + 1] ~= '') then
				break
			end
		end
	else
		local char1 = txt[1]
		local char2
		for i = 1, #History do
			char2 = History[i][1]
			if (char1 == char2) then
				if (#txt > 1) then
					for k = 2, #txt do
						if (txt[k] ~= History[i][k]) then
							break
						end
						if (k == #txt) then
							table.insert(temp, History[i])
						end
					end
				else
					table.insert(temp, History[i])
				end
			elseif (char1 < char2) then
				break
			end
		end
	end

	Narrow = temp
end

local function tableSortNodes(tbl)
    for k, v in ipairs(tbl) do tbl[k] = {string.lower(v.Label:GetText()), v} end
    table.sort(tbl, function(a,b) return a[1]<b[1] end)
    for k, v in ipairs(tbl) do tbl[k] = v[2] end
end

local BROWSERPNL = {}
AccessorFunc(BROWSERPNL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(BROWSERPNL, "m_bgColor", "BackgroundColor")
Derma_Hook(BROWSERPNL, "Paint", "Paint", "Panel")
Derma_Hook(BROWSERPNL, "PerformLayout", "Layout", "Panel")

local setbrowserpnlsize
local function SetBrowserPnlSize(self, x, y)
	setbrowserpnlsize(self, x, y)
	self.pnlCanvas:SetWide(x)
	self.pnlCanvas.VBar:SetUp(y, self.pnlCanvas:GetTall())
end

function BROWSERPNL:Init()
	setbrowserpnlsize = self.SetSize
	self.SetSize = SetBrowserPnlSize
	self.pnlCanvas = vgui.Create("advdupe2_browser_tree", self)

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(self:GetSkin().text_bright)
end

function BROWSERPNL:OnVScroll(iOffset)
	self.pnlCanvas:SetPos(0, iOffset)
end

derma.DefineControl("advdupe2_browser_panel", "AD2 File Browser", BROWSERPNL, "Panel")

local BROWSER = {}
AccessorFunc(BROWSER, "m_pSelectedItem", "SelectedItem")
Derma_Hook(BROWSER, "Paint", "Paint", "Panel")

local origSetTall
local function SetTall(self, val)
	origSetTall(self, val)
	self.VBar:SetUp(self:GetParent():GetTall(), self:GetTall())
end

function BROWSER:Init()
	self:SetTall(0)
	origSetTall = self.SetTall
	self.SetTall = SetTall

	self.VBar = vgui.Create("DVScrollBar", self:GetParent())
	self.VBar:Dock(RIGHT)
	self.Nodes = 0
	self.ChildrenExpanded = {}
	self.ChildList = self
	self.m_bExpanded = true
	self.Folders = {}
	self.Files = {}
	self.LastClick = CurTime()
end

local function GetNodePath(node)
	local path = node.Label:GetText()
	local area = 0
	local name = ""
	node = node.ParentNode
	if (not node.ParentNode) then
		if (path == "-Public-") then
			area = 1
		elseif (path == "-Advanced Duplicator 1-") then
			area = 2
		end
		return "", area
	end

	while (true) do

		name = node.Label:GetText()
		if (name == "-Advanced Duplicator 2-") then
			break
		elseif (name == "-Public-") then
			area = 1
			break
		elseif (name == "-Advanced Duplicator 1-") then
			area = 2
			break
		end
		path = name .. "/" .. path
		node = node.ParentNode
	end

	return path, area
end

function BROWSER:DoNodeLeftClick(node)
	if (self.m_pSelectedItem == node and CurTime() - self.LastClick <= 0.25) then -- Check for double click
		if (node.Derma.ClassName == "advdupe2_browser_folder") then
			if (node.Expander) then
				node:SetExpanded() -- It's a folder, expand/collapse it
			end
		else
			AdvDupe2.UploadFile(GetNodePath(node))
		end
	else
		self:SetSelected(node) -- A node was clicked, select it
	end
	self.LastClick = CurTime()
end

local function AddNewFolder(node)
	local Controller = node.Control:GetParent():GetParent()
	local name = Controller.FileName:GetValue()
	local char = string.match(name, "[^%w_ ]")
	if char then
		AdvDupe2.Notify("Name contains invalid character ("..char..")!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	if (name == "" or name == "Folder_Name...") then
		AdvDupe2.Notify("Name is blank!", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/" .. name
	elseif (area == 1) then
		path = AdvDupe2.DataFolder .. "/=Public=/" .. path .. "/" .. name
	else
		path = "adv_duplicator/" .. path .. "/" .. name
	end

	if (file.IsDir(path, "DATA")) then
		AdvDupe2.Notify("Folder name already exists.", NOTIFY_ERROR)
		Controller.FileName:SelectAllOnFocus(true)
		Controller.FileName:OnGetFocus()
		Controller.FileName:RequestFocus()
		return
	end
	file.CreateDir(path)

	local Folder = node:AddFolder(name)
	node.Control:Sort(node)

	if (not node.m_bExpanded) then
		node:SetExpanded()
	end

	node.Control:SetSelected(Folder)
	if (Controller.Expanded) then
		AdvDupe2.FileBrowser:Slide(false)
	end
end

local function CollapseChildren(node)
	node.m_bExpanded = false
	if (node.Expander) then
		node.Expander:SetExpanded(false)
		node.ChildList:SetTall(0)
		for i = 1, #node.ChildrenExpanded do
			CollapseChildren(node.ChildrenExpanded[i])
		end
		node.ChildrenExpanded = {}
	end
end

local function CollapseParentsComplete(node)
	if (not node.ParentNode.ParentNode) then
		node:SetExpanded(false)
		return
	end
	CollapseParentsComplete(node.ParentNode)
end

function AdvDupe2.GetFilename(path, overwrite)
	if not overwrite and file.Exists(path .. ".txt", "DATA") then
		for i = 1, AdvDupe2.FileRenameTryLimit do
			local p = string.format("%s_%03d.txt", path, i)
			if not file.Exists(p, "DATA") then
				return p
			end
		end
		return false
	end
	return path .. ".txt"
end

local function GetFullPath(node)
	local path, area = GetNodePath(node)
	if (area == 0) then
		path = AdvDupe2.DataFolder .. "/" .. path .. "/"
	elseif (area == 1) then

	else
		path = "adv_duplicator/" .. path .. "/"
	end
	return path
end

local function GetNodeRoot(node)
	local Root
	while (true) do
		if (not node.ParentNode.ParentNode) then
			Root = node
			break
		end
		node = node.ParentNode
	end
	return Root
end

local function RenameFileCl(node, name)
	local path, area = GetNodePath(node)
	local File, FilePath, tempFilePath = "", "", ""
	if (area == 0) then
		tempFilePath = AdvDupe2.DataFolder .. "/" .. path
	elseif (area == 1) then
		tempFilePath = AdvDupe2.DataFolder .. "/=Public=/" .. path
	elseif (area == 2) then
		tempFilePath = "adv_duplicator/" .. path
	end

	File = file.Read(tempFilePath .. ".txt")
	FilePath = AdvDupe2.GetFilename(
		string.sub(tempFilePath, 1, #tempFilePath - #node.Label:GetText()) .. name)

	if (not FilePath) then
		AdvDupe2.Notify("Rename limit exceeded, could not rename.", NOTIFY_ERROR)
		return
	end
	file.Write(FilePath, File)
	if (file.Exists(FilePath, "DATA")) then
		file.Delete(tempFilePath .. ".txt")
		local NewName = string.Explode("/", FilePath)
		NewName = string.sub(NewName[#NewName], 1, -5)
		node.Label:SetText(NewName)
		node.Label:SizeToContents()
		AdvDupe2.Notify("File renamed to " .. NewName)
	else
		AdvDupe2.Notify("File was not renamed.", NOTIFY_ERROR)
	end

	node.Control:Sort(node.ParentNode)
end

local function MoveFileClient(node)
	if (not node) then
		AdvDupe2.Notify("Select a folder to move the file to.", NOTIFY_ERROR)
		return
	end
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		AdvDupe2.Notify("You muse select a folder as a destination.", NOTIFY_ERROR)
		return
	end
	local base = AdvDupe2.DataFolder
	local ParentNode

	local node2 = node.Control.ActionNode
	local path, area = GetNodePath(node2)
	local path2, area2 = GetNodePath(node)

	if (area ~= area2 or path == path2) then
		AdvDupe2.Notify("Cannot move files between these directories.", NOTIFY_ERROR)
		return
	end
	if (area == 2) then base = "adv_duplicator" end

	local savepath = AdvDupe2.GetFilename(
						 base .. "/" .. path2 .. "/" .. node2.Label:GetText())
	local OldFile = base .. "/" .. path .. ".txt"

	local ReFile = file.Read(OldFile)
	file.Write(savepath, ReFile)
	file.Delete(OldFile)
	local name2 = string.Explode("/", savepath)
	name2 = string.sub(name2[#name2], 1, -5)
	node2.Control:RemoveNode(node2)
	node2 = node:AddFile(name2)
	node2.Control:Sort(node)
	AdvDupe2.FileBrowser:Slide(false)
	AdvDupe2.FileBrowser.Info:SetVisible(false)
end

local function DeleteFilesInFolders(path)
	local files, folders = file.Find(path .. "*", "DATA")

	for k, v in pairs(files) do file.Delete(path .. v) end

	for k, v in pairs(folders) do DeleteFilesInFolders(path .. v .. "/") end

	file.Delete(path)
end

local function SearchNodes(node, name)
	local tab = {}
	for k, v in pairs(node.Files) do
		if (string.find(string.lower(v.Label:GetText()), name)) then
			table.insert(tab, v)
		end
	end

	for k, v in pairs(node.Folders) do
		for i, j in pairs(SearchNodes(v, name)) do
			table.insert(tab, j)
		end
	end

	return tab
end

local function Search(node, name)
	local pnFileBr = AdvDupe2.FileBrowser
	pnFileBr.Search = vgui.Create("advdupe2_browser_panel", pnFileBr)
	pnFileBr.Search:SetPos(pnFileBr.Browser:GetPos())
	pnFileBr.Search:SetSize(pnFileBr.Browser:GetSize())
	pnFileBr.Search.pnlCanvas.Search = true
	pnFileBr.Browser:SetVisible(false)
	local Files = SearchNodes(node, name)
	tableSortNodes(Files)
	for k, v in pairs(Files) do
		pnFileBr.Search.pnlCanvas:AddFile(v.Label:GetText()).Ref = v
	end
end

function BROWSER:DoNodeRightClick(node)
	self:SetSelected(node)

	local parent = self:GetParent():GetParent()
	parent.FileName:KillFocus()
	parent.Desc:KillFocus()
	local Menu = DermaMenu()
	local root = GetNodeRoot(node).Label:GetText()
	if (node.Derma.ClassName == "advdupe2_browser_file") then
		if (node.Control.Search) then
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node.Ref))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node.Ref)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
		else
			Menu:AddOption("Open", function()
				AdvDupe2.UploadFile(GetNodePath(node))
			end)
			Menu:AddOption("Preview", function()
				local ReadPath, ReadArea = GetNodePath(node)
				if (ReadArea == 0) then
					ReadPath = AdvDupe2.DataFolder .. "/" .. ReadPath .. ".txt"
				elseif (ReadArea == 1) then
					ReadPath = AdvDupe2.DataFolder .. "/-Public-/" .. ReadPath .. ".txt"
				else
					ReadPath = "adv_duplicator/" .. ReadPath .. ".txt"
				end
				if (not file.Exists(ReadPath, "DATA")) then
					AdvDupe2.Notify("File does not exist", NOTIFY_ERROR)
					return
				end

				local read = file.Read(ReadPath)
				local name = string.Explode("/", ReadPath)
				name = name[#name]
				name = string.sub(name, 1, #name - 4)
				local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
				if (success) then
					AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, true)
				end
			end)
			Menu:AddSpacer()
			Menu:AddOption("Rename", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_edit.png")
				parent.Submit:SetTooltip("Rename File")
				parent.Desc:SetVisible(false)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SetText(node.Label:GetText())
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					AddHistory(name)
					RenameFileCl(node, name)
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter = parent.Submit.DoClick
			end)
			Menu:AddOption("Move File", function()
				parent.Submit:SetMaterial("icon16/page_paste.png")
				parent.Submit:SetTooltip("Move File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				parent.Info:SetText(
					"Select the folder you want to move \nthe File to.")
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				node.Control.ActionNode = node
				parent.Submit.DoClick = function()
					MoveFileClient(node.Control.m_pSelectedItem)
				end
			end)
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete File")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FILE, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. ".txt"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. ".txt"
					end
					node.Control:RemoveNode(node)
					file.Delete(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	else
		if (root ~= "-Advanced Duplicator 1-") then
			Menu:AddOption("Save", function()
				if (parent.Expanding) then return end
				parent.Submit:SetMaterial("icon16/page_save.png")
				parent.Submit:SetTooltip("Save Duplication")
				if (parent.FileName:GetValue() == "Folder_Name...") then
					parent.FileName:SetText("File_Name...")
				end
				parent.Desc:SetVisible(true)
				parent.Info:SetVisible(false)
				parent.FileName.FirstChar = true
				parent.FileName.PrevText = parent.FileName:GetValue()
				parent.FileName:SetVisible(true)
				parent.FileName:SelectAllOnFocus(true)
				parent.FileName:OnMousePressed()
				parent.FileName:RequestFocus()
				node.Control.ActionNode = node
				parent.Expanding = true
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local name = parent.FileName:GetValue()
					if (name == "" or name == "File_Name...") then
						AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
						parent.FileName:SelectAllOnFocus(true)
						parent.FileName:OnGetFocus()
						parent.FileName:RequestFocus()
						return
					end
					local desc = parent.Desc:GetValue()
					if (desc == "Description...") then
						desc = ""
					end
					AdvDupe2.SavePath = GetFullPath(node) .. name
					AddHistory(name)
					if (game.SinglePlayer()) then
						RunConsoleCommand("AdvDupe2_SaveFile", name, desc, GetNodePath(node))
					else
						RunConsoleCommand("AdvDupe2_SaveFile", name)
					end
					AdvDupe2.FileBrowser:Slide(false)
				end
				parent.FileName.OnEnter =
					function()
						parent.FileName:KillFocus()
						parent.Desc:SelectAllOnFocus(true)
						parent.Desc.OnMousePressed()
						parent.Desc:RequestFocus()
					end
				parent.Desc.OnEnter = parent.Submit.DoClick
			end)
		end
		Menu:AddOption("New Folder", function()
			if (parent.Expanding) then return end
			parent.Submit:SetMaterial("icon16/folder_add.png")
			parent.Submit:SetTooltip("Add new folder")
			if (parent.FileName:GetValue() == "File_Name...") then
				parent.FileName:SetText("Folder_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function() AddNewFolder(node) end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		Menu:AddOption("Search", function()
			parent.Submit:SetMaterial("icon16/find.png")
			parent.Submit:SetTooltip("Search Files")
			if (parent.FileName:GetValue() == "Folder_Name...") then
				parent.FileName:SetText("File_Name...")
			end
			parent.Desc:SetVisible(false)
			parent.Info:SetVisible(false)
			parent.FileName.FirstChar = true
			parent.FileName.PrevText = parent.FileName:GetValue()
			parent.FileName:SetVisible(true)
			parent.FileName:SelectAllOnFocus(true)
			parent.FileName:OnMousePressed()
			parent.FileName:RequestFocus()
			parent.Expanding = true
			AdvDupe2.FileBrowser:Slide(true)
			parent.Submit.DoClick = function()
				Search(node, string.lower(parent.FileName:GetValue()))
				AddHistory(parent.FileName:GetValue())
				parent.FileName:SetVisible(false)
				parent.Submit:SetMaterial("icon16/arrow_undo.png")
				parent.Submit:SetTooltip("Return to Browser")
				parent.Info:SetVisible(true)
				parent.Info:SetText(#parent.Search.pnlCanvas.Files ..
										' files found searching for, "' ..
										parent.FileName:GetValue() .. '"')
				parent.Info:SizeToContents()
				parent.Submit.DoClick = function()
					parent.Search:Remove()
					parent.Search = nil
					parent.Browser:SetVisible(true)
					AdvDupe2.FileBrowser:Slide(false)
					parent.Cancel:SetVisible(true)
				end
				parent.Cancel:SetVisible(false)
			end
			parent.FileName.OnEnter = parent.Submit.DoClick
		end)
		if (node.Label:GetText()[1] ~= "-") then
			Menu:AddOption("Delete", function()
				parent.Submit:SetMaterial("icon16/bin_empty.png")
				parent.Submit:SetTooltip("Delete Folder")
				parent.FileName:SetVisible(false)
				parent.Desc:SetVisible(false)
				if (#node.Label:GetText() > 22) then
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" \nfrom your CLIENT?')
				else
					parent.Info:SetText(
						'Are you sure that you want to delete \nthe FOLDER, "' ..
							node.Label:GetText() .. '" from your CLIENT?')
				end
				parent.Info:SizeToContents()
				parent.Info:SetVisible(true)
				AdvDupe2.FileBrowser:Slide(true)
				parent.Submit.DoClick = function()
					local path, area = GetNodePath(node)
					if (area == 1) then
						path = "-Public-/" .. path
					end
					if (area == 2) then
						path = "adv_duplicator/" .. path .. "/"
					else
						path = AdvDupe2.DataFolder .. "/" .. path .. "/"
					end
					node.Control:RemoveNode(node)
					DeleteFilesInFolders(path)
					AdvDupe2.FileBrowser:Slide(false)
				end
			end)
		end
	end
	if (not node.Control.Search) then
		Menu:AddSpacer()
		Menu:AddOption("Collapse Folder", function()
			if (node.ParentNode.ParentNode) then
				node.ParentNode:SetExpanded(false)
			end
		end)
		Menu:AddOption("Collapse Root", function() CollapseParentsComplete(node) end)
		if (parent.Expanded) then
			Menu:AddOption("Cancel Action", function() parent.Cancel:DoClick() end)
		end
	end

	Menu:Open()
end

local function CollapseParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() - val)
	CollapseParents(node.ParentNode, val)
end

function BROWSER:RemoveNode(node)
	local parent = node.ParentNode
	parent.Nodes = parent.Nodes - 1
	if (node.IsFolder) then
		if (node.m_bExpanded) then
			CollapseParents(parent, node.ChildList:GetTall() + 20)
			for i = 1, #parent.ChildrenExpanded do
				if (node == parent.ChildrenExpanded[i]) then
					table.remove(parent.ChildrenExpanded, i)
					break
				end
			end
		elseif (parent.m_bExpanded) then
			CollapseParents(parent, 20)
		end
		for i = 1, #parent.Folders do
			if (node == parent.Folders[i]) then
				table.remove(parent.Folders, i)
			end
		end
		node.ChildList:Remove()
		node:Remove()
	else
		for i = 1, #parent.Files do
			if (node == parent.Files[i]) then
				table.remove(parent.Files, i)
			end
		end
		CollapseParents(parent, 20)
		node:Remove()
		if (#parent.Files == 0 and #parent.Folders == 0) then
			parent.Expander:Remove()
			parent.Expander = nil
			parent.m_bExpanded = false
		end
	end
	if (self.VBar.Scroll > self.VBar.CanvasSize) then
		self.VBar:SetScroll(self.VBar.Scroll)
	end
	if (self.m_pSelectedItem) then
		self.m_pSelectedItem = nil
	end
end

function BROWSER:OnMouseWheeled(dlta)
	return self.VBar:OnMouseWheeled(dlta)
end

function BROWSER:AddFolder(text)
	local node = vgui.Create("advdupe2_browser_folder", self)
	node.Control = self

	node.Offset = 0
	node.ChildrenExpanded = {}
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	node.IsFolder = true
	self.Nodes = self.Nodes + 1
	node.Folders = {}
	node.Files = {}
	table.insert(self.Folders, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:AddFile(text)
	local node = vgui.Create("advdupe2_browser_file", self)
	node.Control = self
	node.Offset = 0
	node.Icon:SetPos(18, 1)
	node.Label:SetPos(44, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.ParentNode = self
	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)
	self:SetTall(self:GetTall() + 20)

	return node
end

function BROWSER:Sort(node)
	tableSortNodes(node.Folders)
	tableSortNodes(node.Files)

	for i = 1, #node.Folders do
		node.Folders[i]:SetParent(nil)
		node.Folders[i]:SetParent(node.ChildList)
		node.Folders[i].ChildList:SetParent(nil)
		node.Folders[i].ChildList:SetParent(node.ChildList)
	end
	for i = 1, #node.Files do
		node.Files[i]:SetParent(nil)
		node.Files[i]:SetParent(node.ChildList)
	end
end

function BROWSER:SetSelected(node)
	if (IsValid(self.m_pSelectedItem)) then
		self.m_pSelectedItem:SetSelected(false)
	end
	self.m_pSelectedItem = node
	if (node) then node:SetSelected(true) end
end

local function ExpandParents(node, val)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + val)
	ExpandParents(node.ParentNode, val)
end

function BROWSER:Expand(node)
	node.ChildList:SetTall(node.Nodes * 20)
	table.insert(node.ParentNode.ChildrenExpanded, node)
	ExpandParents(node.ParentNode, node.Nodes * 20)
end

local function ExtendParents(node)
	if (not node) then return end
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Extend(node)
	node.ChildList:SetTall(node.ChildList:GetTall() + 20)
	ExtendParents(node.ParentNode)
end

function BROWSER:Collapse(node)
	CollapseParents(node.ParentNode, node.ChildList:GetTall())

	for i = 1, #node.ParentNode.ChildrenExpanded do
		if (node.ParentNode.ChildrenExpanded[i] == node) then
			table.remove(node.ParentNode.ChildrenExpanded, i)
			break
		end
	end
	CollapseChildren(node)
end

function BROWSER:RenameNode(name)
	self.ActionNode.Label:SetText(name)
	self.ActionNode.Label:SizeToContents()
	self:Sort(self.ActionNode.ParentNode)
end

function BROWSER:MoveNode(name)
	self:RemoveNode(self.ActionNode)
	self.ActionNode2:AddFile(name)
	self:Sort(self.ActionNode2)
end

function BROWSER:DeleteNode()
	self:RemoveNode(self.ActionNode)
end

derma.DefineControl("advdupe2_browser_tree", "AD2 File Browser", BROWSER, "Panel")

local FOLDER = {}

AccessorFunc(FOLDER, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FOLDER, "m_bgColor", "BackgroundColor")

Derma_Hook(FOLDER, "Paint", "Paint", "Panel")

function FOLDER:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/folder.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self.m_bExpanded = false
	self.Nodes = 0
	self.ChildrenExpanded = {}

	self:Dock(TOP)

	self.ChildList = vgui.Create("Panel", self:GetParent())
	self.ChildList:Dock(TOP)
	self.ChildList:SetTall(0)
end

local function ExpandNode(self)
	self:GetParent():SetExpanded()
end

function FOLDER:AddFolder(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_folder", self.ChildList)
	node.Control = self.Control

	node.Offset = self.Offset + 20

	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self
	node.IsFolder = true
	node.Folders = {}
	node.Files = {}

	self.Nodes = self.Nodes + 1
	table.insert(self.Folders, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:AddFile(text)
	if (self.Nodes == 0) then
		self.Expander = vgui.Create("DExpandButton", self)
		self.Expander.DoClick = ExpandNode
		self.Expander:SetPos(self.Offset, 2)
	end

	local node = vgui.Create("advdupe2_browser_file", self.ChildList)
	node.Control = self.Control
	node.Offset = self.Offset + 20
	node.Icon:SetPos(18 + node.Offset, 1)
	node.Label:SetPos(44 + node.Offset, 0)
	node.Label:SetText(text)
	node.Label:SizeToContents()
	node.Label:SetDark(true)
	node.ParentNode = self

	self.Nodes = self.Nodes + 1
	table.insert(self.Files, node)

	if (self.m_bExpanded) then
		self.Control:Extend(self)
	end

	return node
end

function FOLDER:SetExpanded(bool)
	if (not self.Expander) then return end
	if (bool == nil) then
		self.m_bExpanded = not self.m_bExpanded
	else
		self.m_bExpanded = bool
	end
	self.Expander:SetExpanded(self.m_bExpanded)
	if (self.m_bExpanded) then
		self.Control:Expand(self)
	else
		self.Control:Collapse(self)
	end
end

function FOLDER:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FOLDER:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_folder", "AD2 Browser Folder node", FOLDER, "Panel")

local FILE = {}

AccessorFunc(FILE, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(FILE, "m_bgColor", "BackgroundColor")
Derma_Hook(FILE, "Paint", "Paint", "Panel")

function FILE:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(20)
	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
	self:SetBackgroundColor(Color(0, 0, 0, 0))

	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage("icon16/page.png")

	self.Icon:SizeToContents()

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetDark(true)

	self:Dock(TOP)
end

function FILE:SetSelected(bool)
	if (bool) then
		self:SetBackgroundColor(self:GetSkin().bg_color_bright)
	else
		self:SetBackgroundColor(Color(0, 0, 0, 0))
	end
end

function FILE:OnMousePressed(code)
	if (code == 107) then
		self.Control:DoNodeLeftClick(self)
	elseif (code == 108) then
		self.Control:DoNodeRightClick(self)
	end
end

derma.DefineControl("advdupe2_browser_file", "AD2 Browser File node", FILE, "Panel")

local PANEL = {}
AccessorFunc(PANEL, "m_bBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(PANEL, "m_bgColor", "BackgroundColor")
Derma_Hook(PANEL, "Paint", "Paint", "Panel")
Derma_Hook(PANEL, "PerformLayout", "Layout", "Panel")

function PANEL:PerformLayout()
	if (self:GetWide() == self.LastX) then return end
	local x = self:GetWide()

	if (self.Search) then
		self.Search:SetWide(x)
	end

	self.Browser:SetWide(x)
	local x2, y2 = self.Browser:GetPos()
	local BtnX = x - self.Help:GetWide() - 5
	self.Help:SetPos(BtnX, 3)
	BtnX = BtnX - self.Refresh:GetWide() - 5
	self.Refresh:SetPos(BtnX, 3)

	BtnX = x - self.Submit:GetWide() - 15
	self.Cancel:SetPos(BtnX, self.Browser:GetTall() + 20)
	BtnX = BtnX - self.Submit:GetWide() - 5
	self.Submit:SetPos(BtnX, self.Browser:GetTall() + 20)

	self.FileName:SetWide(BtnX - 10)
	self.FileName:SetPos(5, self.Browser:GetTall() + 20)
	self.Desc:SetWide(x - 10)
	self.Desc:SetPos(5, self.Browser:GetTall() + 39)
	self.Info:SetPos(5, self.Browser:GetTall() + 20)

	self.LastX = x
end

local pnlorigsetsize
local function PanelSetSize(self, x, y)
	if (not self.LaidOut) then
		pnlorigsetsize(self, x, y)

		self.Browser:SetSize(x, y - 20)
		self.Browser:SetPos(0, 20)

		if (self.Search) then
			self.Search:SetSize(x, y - 20)
			self.Search:SetPos(0, 20)
		end

		self.LaidOut = true
	else
		pnlorigsetsize(self, x, y)
	end

end

local function PurgeFiles(path, curParent)
	local files, directories = file.Find(path .. "*", "DATA")
	if (directories) then
		for k, v in pairs(directories) do
			curParent = curParent:AddFolder(v)
			PurgeFiles(path .. v .. "/", curParent)
			curParent = curParent.ParentNode
		end
	end

	if (files) then
		for k, v in pairs(files) do
			curParent:AddFile(string.sub(v, 1, #v - 4))
		end
	end
end

local function UpdateClientFiles()

	local pnlCanvas = AdvDupe2.FileBrowser.Browser.pnlCanvas

	for i = 1, 2 do
		if (pnlCanvas.Folders[1]) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[1])
		end
	end

	PurgeFiles("advdupe2/", pnlCanvas:AddFolder("-Advanced Duplicator 2-"))

	PurgeFiles("adv_duplicator/", pnlCanvas:AddFolder("-Advanced Duplicator 1-"))

	if (pnlCanvas.Folders[2]) then
		if (#pnlCanvas.Folders[2].Folders == 0 and #pnlCanvas.Folders[2].Files == 0) then
			pnlCanvas:RemoveNode(pnlCanvas.Folders[2])
		end

		pnlCanvas.Folders[1]:SetParent(nil)
		pnlCanvas.Folders[1]:SetParent(pnlCanvas.ChildList)
		pnlCanvas.Folders[1].ChildList:SetParent(nil)
		pnlCanvas.Folders[1].ChildList:SetParent(pnlCanvas.ChildList)
	end

end

function PANEL:Init()

	AdvDupe2.FileBrowser = self
	self.Expanded = false
	self.Expanding = false
	self.LastX = 0
	self.LastY = 0
	pnlorigsetsize = self.SetSize
	self.SetSize = PanelSetSize

	self:SetPaintBackground(true)
	self:SetPaintBackgroundEnabled(false)
	self:SetBackgroundColor(self:GetSkin().bg_color_bright)

	self.Browser = vgui.Create("advdupe2_browser_panel", self)
	UpdateClientFiles()
	self.Refresh = vgui.Create("DImageButton", self)
	self.Refresh:SetMaterial("icon16/arrow_refresh.png")
	self.Refresh:SizeToContents()
	self.Refresh:SetTooltip("Refresh Files")
	self.Refresh.DoClick = function(button) UpdateClientFiles() end

	self.Help = vgui.Create("DImageButton", self)
	self.Help:SetMaterial("icon16/help.png")
	self.Help:SizeToContents()
	self.Help:SetTooltip("Help Section")
	self.Help.DoClick = function(btn)
		local Menu = DermaMenu()
		Menu:AddOption("Bug Reporting", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/issues")
		end)
		Menu:AddOption("Controls", function()
			gui.OpenURL("https://github.com/wiremod/advdupe2/wiki/Controls")
		end)
		Menu:AddOption("Commands", function()
			gui.OpenURL(
				"https://github.com/wiremod/advdupe2/wiki/Server-settings")
		end)
		Menu:Open()
	end

	self.Submit = vgui.Create("DImageButton", self)
	self.Submit:SetMaterial("icon16/page_save.png")
	self.Submit:SizeToContents()
	self.Submit:SetTooltip("Confirm Action")
	self.Submit.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.Cancel = vgui.Create("DImageButton", self)
	self.Cancel:SetMaterial("icon16/cross.png")
	self.Cancel:SizeToContents()
	self.Cancel:SetTooltip("Cancel Action")
	self.Cancel.DoClick = function()
		self.Expanding = true
		AdvDupe2.FileBrowser:Slide(false)
	end

	self.FileName = vgui.Create("DTextEntry", self)
	self.FileName:SetAllowNonAsciiCharacters(true)
	self.FileName:SetText("File_Name...")
	self.FileName.Last = 0

	self.FileName.OnEnter = function()
		self.FileName:KillFocus()
		self.Desc:SelectAllOnFocus(true)
		self.Desc.OnMousePressed()
		self.Desc:RequestFocus()
	end
	self.FileName.OnMousePressed = function()
		self.FileName:OnGetFocus()
		if (self.FileName:GetValue() == "File_Name..." or
			self.FileName:GetValue() == "Folder_Name...") then
			self.FileName:SelectAllOnFocus(true)
		end
	end
	self.FileName:SetUpdateOnType(true)
	self.FileName.OnTextChanged = function()

		if (self.FileName.FirstChar) then
			if (string.lower(self.FileName:GetValue()[1] or "") == string.lower(input.LookupBinding("menu") or "q")) then
				self.FileName:SetText(self.FileName.PrevText)
				self.FileName:SelectAll()
				self.FileName.FirstChar = false
			else
				self.FileName.FirstChar = false
			end
		end

		local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
		if changed > 0 then
			self.FileName:SetText(new)
			self.FileName:SetCaretPos(#new)
		end
		if (#self.FileName:GetValue() > 0) then
			NarrowHistory(self.FileName:GetValue(), self.FileName.Last)
			local options = {}
			if (#Narrow > 4) then
				for i = 1, 4 do table.insert(options, Narrow[i]) end
			else
				options = Narrow
			end
			if (#options ~= 0 and #self.FileName:GetValue() ~= 0) then
				self.FileName.HistoryPos = 0
				self.FileName:OpenAutoComplete(options)
				self.FileName.Menu.Attempts = 1
				if (#Narrow > 4) then
					self.FileName.Menu:AddOption("...", function() end)
				end
			elseif (IsValid(self.FileName.Menu)) then
				self.FileName.Menu:Remove()
			end
		end
		self.FileName.Last = #self.FileName:GetValue()
	end
	self.FileName.OnKeyCodeTyped = function(txtbox, code)
		txtbox:OnKeyCode(code)

		if (code == KEY_ENTER and not txtbox:IsMultiline() and txtbox:GetEnterAllowed()) then
			if (txtbox.HistoryPos == 5 and txtbox.Menu:ChildCount() == 5) then
				if ((txtbox.Menu.Attempts + 1) * 4 < #Narrow) then
					for i = 1, 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				else
					txtbox.Menu:GetChild(5):Remove()
					for i = 4, (txtbox.Menu.Attempts * 4 - #Narrow) * -1 + 1, -1 do
						txtbox.Menu:GetChild(i):Remove()
					end

					for i = 1, #Narrow - txtbox.Menu.Attempts * 4 do
						txtbox.Menu:GetChild(i):SetText(Narrow[i + txtbox.Menu.Attempts * 4])
					end
				end
				txtbox.Menu:ClearHighlights()
				txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(1))
				txtbox.HistoryPos = 1
				txtbox.Menu.Attempts = txtbox.Menu.Attempts + 1
				return true
			end

			if (IsValid(txtbox.Menu)) then
				txtbox.Menu:Remove()
			end
			txtbox:FocusNext()
			txtbox:OnEnter()
			txtbox.HistoryPos = 0
		end

		if (txtbox.m_bHistory or IsValid(txtbox.Menu)) then
			if (code == KEY_UP) then
				txtbox.HistoryPos = txtbox.HistoryPos - 1;
				if (txtbox.HistoryPos ~= -1 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
					txtbox.HistoryPos = 5
				end
			end
			if (code == KEY_DOWN or code == KEY_TAB) then
				txtbox.HistoryPos = txtbox.HistoryPos + 1;
				if (txtbox.HistoryPos ~= 5 or txtbox.Menu:ChildCount() ~= 5) then
					txtbox:UpdateFromHistory()
				else
					txtbox.Menu:ClearHighlights()
					txtbox.Menu:HighlightItem(txtbox.Menu:GetChild(5))
				end
			end

		end
	end
	self.FileName.OnValueChange = function()
		if (self.FileName:GetValue() ~= "File_Name..." and
			self.FileName:GetValue() ~= "Folder_Name...") then
			local new, changed = self.FileName:GetValue():gsub("[^%w_ ]", "")
			if changed > 0 then
				self.FileName:SetText(new)
				self.FileName:SetCaretPos(#new)
			end
		end
	end

	self.Desc = vgui.Create("DTextEntry", self)
	self.Desc.OnEnter = self.Submit.DoClick
	self.Desc:SetText("Description...")
	self.Desc.OnMousePressed = function()
		self.Desc:OnGetFocus()
		if (self.Desc:GetValue() == "Description...") then
			self.Desc:SelectAllOnFocus(true)
		end
	end

	self.Info = vgui.Create("DLabel", self)
	self.Info:SetVisible(false)

end

function PANEL:Slide(expand)
	if (expand) then
		if (self.Expanded) then
			self:SetTall(self:GetTall() - 40)
			self.Expanded = false
		else
			self:SetTall(self:GetTall() + 5)
		end
	else
		if (not self.Expanded) then
			self:SetTall(self:GetTall() + 40)
			self.Expanded = true
		else
			self:SetTall(self:GetTall() - 5)
		end
	end
	count = count + 1
	if (count < 9) then
		timer.Simple(0.01, function() self:Slide(expand) end)
	else
		if (expand) then
			self.Expanded = true
		else
			self.Expanded = false
		end
		self.Expanding = false
		count = 0
	end
end

function PANEL:GetFullPath(node)
	return GetFullPath(node)
end

function PANEL:GetNodePath(node)
	return GetNodePath(node)
end

if (game.SinglePlayer()) then
	net.Receive("AdvDupe2_AddFile", function()
		local asvNode = AdvDupe2.FileBrowser.AutoSaveNode
		local actNode = AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode
		if (net.ReadBool()) then
			if (IsValid(asvNode)) then
				local name = net.ReadString()
				for iD = 1, #asvNode.Files do
					if (name == asvNode.Files[i]) then return end
				end
				asvNode:AddFile(name)
				asvNode.Control:Sort(asvNode)
			end
		else
			actNode:AddFile(net.ReadString())
			actNode.Control:Sort(actNode)
		end
	end)
end

vgui.Register("advdupe2_browser", PANEL, "Panel")

--lua/advdupe2/cl_file.lua:
local function AdvDupe2_ReceiveFile(len, ply)
	local AutoSave = net.ReadUInt(8) == 1

	net.ReadStream(nil, function(data)
		AdvDupe2.RemoveProgressBar()
		if(!data)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		local path
		if AutoSave then
			if(LocalPlayer():GetInfo("advdupe2_auto_save_overwrite")~="0")then
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath, true)
			else
				path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath)
			end
		else
			path = AdvDupe2.GetFilename(AdvDupe2.SavePath)
		end

		local dupefile = file.Open(path, "wb", "DATA")
		if(!dupefile)then
			AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
			return
		end
		dupefile:Write(data)
		dupefile:Close()
		
		local errored = false
		if(LocalPlayer():GetInfo("advdupe2_debug_openfile")=="1")then
			if(not file.Exists(path, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
			
			local readFile = file.Open(path, "rb", "DATA")
			if not readFile then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
			local readData = readFile:Read(readFile:Size())
			readFile:Close()
			local success,dupe,info,moreinfo = AdvDupe2.Decode(readData)
			if(success)then
				AdvDupe2.Notify("DEBUG CHECK: File successfully opens. No EOF errors.")
			else
				AdvDupe2.Notify("DEBUG CHECK: " .. dupe, NOTIFY_ERROR)
				errored = true
			end
		end
		
		local filename = string.StripExtension(string.GetFileFromFilename( path ))
		if(AutoSave)then
			if(IsValid(AdvDupe2.FileBrowser.AutoSaveNode))then
				local add = true
				for i=1, #AdvDupe2.FileBrowser.AutoSaveNode.Files do
					if(filename==AdvDupe2.FileBrowser.AutoSaveNode.Files[i].Label:GetText())then
						add=false
						break
					end
				end
				if(add)then
					AdvDupe2.FileBrowser.AutoSaveNode:AddFile(filename)
					AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.AutoSaveNode)
				end
			end
		else
			AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode:AddFile(filename)
			AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode)
		end
		if(!errored)then
			AdvDupe2.Notify("File successfully saved!",NOTIFY_GENERIC, 5)
		end
	end)
end
net.Receive("AdvDupe2_ReceiveFile", AdvDupe2_ReceiveFile)

local uploading = nil
function AdvDupe2.UploadFile(ReadPath, ReadArea)
	if uploading then AdvDupe2.Notify("Already opening file, please wait.", NOTIFY_ERROR) return end
	if(ReadArea==0)then
		ReadPath = AdvDupe2.DataFolder.."/"..ReadPath..".txt"
	elseif(ReadArea==1)then
		ReadPath = AdvDupe2.DataFolder.."/-Public-/"..ReadPath..".txt"
	else
		ReadPath = "adv_duplicator/"..ReadPath..".txt"
	end
	
	if(not file.Exists(ReadPath, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end
	
	local read = file.Read(ReadPath)
	if not read then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
	local name = string.Explode("/", ReadPath)
	name = name[#name]
	name = string.sub(name, 1, #name-4)
	
	local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
	if(success)then
		net.Start("AdvDupe2_ReceiveFile")
		net.WriteString(name)
		uploading = net.WriteStream(read, function()
			uploading = nil
			AdvDupe2.File = nil
			AdvDupe2.RemoveProgressBar()
		end)
		net.SendToServer()
		
		AdvDupe2.LoadGhosts(dupe, info, moreinfo, name)
	else
		AdvDupe2.Notify("File could not be decoded. ("..dupe..") Upload Canceled.", NOTIFY_ERROR)
	end
end

--lua/autorun/client/cl_navaattach.lua:


--hook.Add("think", "setnavachemlightattachmodel2", function(ply, mvd, cmd)
	
	--if GetGlobalBool( "global_Cheml_oldmodel" ) then 
		--navaattachchemlightmodel = ClientsideModel("models/glowstick/chemstick_antic.mdl") 
		--SetGlobal2String( "chemlattachmodel", "models/glowstick/chemstick_antic.mdl" )
	--elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
		--navaattachchemlightmodel = ClientsideModel("models/glowstick/chemstick.mdl") 
		--SetGlobal2String( "chemlattachmodel", "models/glowstick/chemstick.mdl" ) 
	--else SetGlobal2String( "chemlattachmodel", "models/props_interiors/pot01a.mdl" ) end
	--setnavachemlightattachmodel()
	--end)

--function setnavachemlightattachmodel()
	--navaattachchemlightmodel = ClientsideModel(GetGlobal2String( "chemlattachmodel", "models/gibs/hgibs.mdl" )) 
	----local navaattachchemlightmodel = ClientsideModel("models/glowstick/chemstick.mdl")
	--navaattachchemlightmodel:SetColor( Color(255, 0, 0, 255) )
	--navaattachchemlightmodel:SetRenderMode( RENDERMODE_TRANSCOLOR )
	--navaattachchemlightmodel:SetNoDraw( true )
--end

hook.Add( "PostPlayerDraw" , "chemlightattachmenthook" , function( ply )

	if not IsValid(ply) or not ply:Alive() then return end
	if ply:GetNW2Bool( "chemlightattachmentusage", false ) != true then return end
	
	local attach_id = ply:LookupAttachment('chest')
	if not attach_id then return end
			
	local attach = ply:GetAttachment(attach_id)
			
	if not attach then return end
			
	local pos = attach.Pos
	local ang = attach.Ang
	
	if GetGlobalBool( "global_Cheml_oldmodel" ) then 
		navaattachchemlightmodel = ClientsideModel(GetGlobal2String( "chemlattachmodel", "models/glowstick/chemstick_antic.mdl" )) 
	elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
		navaattachchemlightmodel = ClientsideModel(GetGlobal2String( "chemlattachmodel", "models/glowstick/chemstick.mdl" )) 
	else navaattachchemlightmodel = ClientsideModel(GetGlobal2String( "chemlattachmodel", "models/gibs/hgibs.mdl" ))  end
	--setnavachemlightattachmodel()
		--navaattachchemlightmodel = ClientsideModel(GetGlobal2String( "chemlattachmodel", "models/gibs/hgibs.mdl" )) 
		navaattachchemlightmodel:SetRenderMode( RENDERMODE_TRANSCOLOR )
		navaattachchemlightmodel:SetModelScale(0.75, 0)
		navaattachchemlightmodel:SetNoDraw( true )
		
	pos = pos + (ang:Forward() * 4.5)
	pos = pos + (ang:Up() * 5.5)
	pos = pos + (ang:Right() * -4.5)
	ang:RotateAroundAxis(ang:Right(), -75)
	ang:RotateAroundAxis(ang:Up(), 10)
	navaattachchemlightmodel:SetPos(pos)
	navaattachchemlightmodel:SetAngles(ang)

	navaattachchemlightmodel:SetRenderOrigin(pos)
	navaattachchemlightmodel:SetRenderAngles(ang)
	navaattachchemlightmodel:SetupBones()
	local OldR, OldG, OldB = render.GetColorModulation()
	render.SetColorModulation( ply:GetNW2Int( "chemlightattachmenRGB_R", 0 )/255, ply:GetNW2Int( "chemlightattachmenRGB_G", 0 )/255, ply:GetNW2Int( "chemlightattachmenRGB_B", 0 )/255 )
	navaattachchemlightmodel:DrawModel()
	render.SetColorModulation(OldR, OldG, OldB)
	navaattachchemlightmodel:SetRenderOrigin()
	navaattachchemlightmodel:SetRenderAngles()
	navaattachchemlightmodel:Remove()


end ) 

--self.Owner:SetNW2Bool( "chemlightattachmentusage", true )
--self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
--self.Owner:GetNW2Bool( "chemlightattachmentusage", false )
--self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
--self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )
			--glow:SetModelScale( 0.75, 0 )
			--glow:FollowBone( self.Owner, 3 )
			--glow:SetLocalPos(Vector(10,10,3))
			--glow:SetLocalAngles(Angle(-15,180,0))
--self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 255 )
--self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 )
--self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 255 )
--self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 )
--self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 255 )
--self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 )
--addons/hbombs_base/lua/autorun/client/hb_particles.lua:
AddCSLuaFile()
game.AddParticles( "particles/gb5_emp.pcf") 

game.AddParticles( "particles/hbomb.pcf")
game.AddParticles( "particles/hbomb-underwater.pcf")
game.AddParticles( "particles/hbomb-small.pcf")
game.AddParticles( "particles/h-nuke.pcf")
game.AddParticles( "particles/h-nuke2.pcf")
game.AddParticles( "particles/h-nuke3.pcf")
game.AddParticles( "particles/h-ionbomb.pcf")
game.AddParticles( "particles/h-rktboom.pcf")
game.AddParticles( "particles/h-spacenuke.pcf")
game.AddParticles( "particles/hnuke2.pcf")
game.AddParticles( "particles/hnuke1.pcf")
game.AddParticles( "particles/h-v2.pcf")
game.AddParticles( "particles/h-volcano.pcf")
game.AddParticles( "particles/h-1000lb.pcf")
game.AddParticles( "particles/h-waterexplosions.pcf")
game.AddParticles( "particles/hbomb-micro.pcf")
game.AddParticles( "particles/h-propellant.pcf")
game.AddParticles( "particles/combine_explo.pcf")
game.AddParticles( "particles/h-500lb.pcf")
game.AddParticles( "particles/h-shockwave.pcf")
game.AddParticles( "particles/h-nuke4.pcf")
game.AddParticles( "particles/h_grenade.pcf")
game.AddParticles( "particles/h-fab.pcf")
game.AddParticles( "particles/h-2000lb.pcf")
game.AddParticles( "particles/h-slownuke.pcf")
game.AddParticles( "particles/h-nuke5.pcf")
game.AddParticles( "particles/h-fireball.pcf")
game.AddParticles( "particles/h-implosion.pcf")
game.AddParticles( "particles/h-explos.pcf")
game.AddParticles( "particles/h-moab.pcf")
game.AddParticles( "particles/laser.pcf")
game.AddParticles( "particles/h_rustracers_cardamage.pcf")
game.AddParticles( "particles/h-blu82.pcf")
game.AddParticles( "particles/h-fusionbomb.pcf")
game.AddParticles( "particles/h-gasbomb.pcf")
game.AddParticles( "particles/hnuke3.pcf")
--addons/prop_list/lua/autorun/client/schrott.lua:
hook.Add("PopulatePropMenu", "Details", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Schrott"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_gib1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p1c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p1d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p2c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box_p2d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_gib3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01_p7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p8.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_gib1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kirillotron/rc ships/laat_cr.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/atte_crash.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/atat_wreck01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/atat_wreck02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/atat_wreck03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/tie_wreck_body.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/tie_wreck_wing.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/xwing_wreck.mdl"
	} )

	spawnmenu.AddPropCategory( "14", "Schrott", contents, "icon16/brick.png" )
end )
--addons/wos-grandmaster-einf/lua/autorun/client/wos_advswl_loader.lua:

--[[-------------------------------------------------------------------
	The Advanced Lightsaber Combat System:
		Skill based combat, inspired by Blade Symphony, KOTOR, and SWTOR
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--

wOS = wOS or {}
wOS.Lightsaber = wOS.Lightsaber or {}

include( "wos/advswl/loader/loader.lua" )
--addons/wos-alcs-custom/lua/wos/advswl/config/lightsaber/cl_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}

/* 
	What Lightsaber HUD do we want to use?
	Options:
		WOS_ALCS.HUD.NEWAGE			--The newest standard. Circle Icons, slot-base, gradients, and more
		WOS_ALCS.HUD.CLASSIC		--Classic Rubat design with box focus
		WOS_ALCS.HUD.FORCEMENU		--Simpler design with force menu for changing force powers
		WOS_ALCS.HUD.HYBRID			--New age slot design with draggable force powers from the force menu for assignment
*/
wOS.ALCS.Config.LightsaberHUD = WOS_ALCS.HUD.HYBRID

/* 
	What is the maximum number of force power slots in the hybrid menu?
	MUST USE | 		WOS_ALCS.HUD.HYBRID		| FOR IT TO FUNCTION
*/
wOS.ALCS.Config.MaximumForceSlots = 9

/* 
	Should we enable the stamina mod?
	This will only work for lightsabers!
*/
wOS.ALCS.Config.EnableStamina = true

/* 
	How much stamina should we lose when performing basic or aerial attacks?
	MUST USE | 		wOS.ALCS.Config.EnableStamina		| FOR IT TO FUNCTION	
	Try to keep this below 100
*/
wOS.ALCS.Config.StaminaAttackCost = 4

/* 
	How much stamina should we lose when performing a heavy attack?
	MUST USE | 		wOS.ALCS.Config.EnableStamina		| FOR IT TO FUNCTION
	Try to keep this below 100	
*/
wOS.ALCS.Config.StaminaHeavyCost = 15
--addons/wos-alcs-custom/lua/wos/advswl/config/storage/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.Storage = wOS.ALCS.Config.Storage or {}

--[[
	What is the default amount of space someone should have when they first join?
]]--
wOS.ALCS.Config.Storage.StartingSpace = 20

--[[
	How much should it cost to upgrade your storage space?
]]--
wOS.ALCS.Config.Storage.ExpansionCost = 15000

--[[
	How much slots should be given to the player when they purchase an expansion?
]]--
wOS.ALCS.Config.Storage.ExpansionAmount = 10

--[[
	What is the maximum amount of space someone should be able to upgrade their storage space to?
	Note that this is maximum PURCHASED upgrade size.
	You can still set the storage space over this through other means.
	
	Example: 
	wOS.ALCS.Config.Storage.MaxInventorySlots = 100
	
	Set this to false for no limit:
	wOS.ALCS.Config.Storage.MaxInventorySlots = false
]]--
wOS.ALCS.Config.Storage.MaxInventorySlots = 100
--addons/wos-alcs-custom/lua/wos/advswl/config/dueling/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.Dueling = wOS.ALCS.Config.Dueling or {}

/* 
	How much sacrifice energy must be gained from items before a spirit can be rolled?
*/
wOS.ALCS.Config.Dueling.SacrificeRoll = 100

/* 
	How long should duel requests last before they are expired and cycled?
*/
wOS.ALCS.Config.Dueling.DuelExpirationTime = 10

/* 
	How far away does a player have to be from a dueling station in order be considered ready for dueling?
	Set to FALSE for infinite distance
*/
wOS.ALCS.Config.Dueling.StationDistance = 450
--addons/wos-grandmaster-einf/lua/wos/advswl/anim/cl_forcesequence.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

wOS.ALCS.PortalCache = wOS.ALCS.PortalCache or {}

hook.Add( "CalcMainActivity", "wOS.ALCS.ClientAnimations", function( ply, velocity )
	
	if wOS.ALCS.PortalCache[ ply ] then
		wOS.ALCS.PortalCache[ ply ] = nil
		ply.SeqOverride = -1
		ply.SeqOverrideRate = nil
		return
	end
	
	if ply:InVehicle() then return end
	
	local act, seq = hook.Call( "wOS.ALCS.GetSequenceOverride", nil, ply, velocity )
	if act and seq then
		return act, seq
	end
	
	if ply.SeqOverride and ply.SeqOverride >= 0 then 
		return -1, ply.SeqOverride
	end
	
	local wep = ply:GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end
	
	if wep:GetMeditateMode() == 1 then
        return -1, ply:LookupSequence( "sit_zen" )
    end
	
	if wep:GetMeditateMode() == 2  then
		return -1, ply:LookupSequence( "idle_dual" )
	end
	
	if not wep.GetEnabled then return end
	if not wep:GetEnabled() then return end
	if not wep:GetAnimEnabled() then return end
	
	local len2d = velocity:Length2DSqr()
	local stance = wep:GetStance()
	local form = wOS.Form.LocalizedForms[ wep:GetForm() ]																																																																																
	local seq = ""
	
	if wep:GetDualMode() then
		local formdata = wOS.Form.Duals[ form ][ stance ]
		if ( len2d > 0.25 ) then
			if wep:GetBlocking() then 
				seq = "walk_slam"
			else 
				seq = formdata[ "run" ]
			end
		else
			if wep:GetBlocking() then 
				seq = "judge_b_block"
			else 
				seq = formdata[ "idle" ]
			end
		end	
	else
		local formdata = wOS.Form.Singles[ form ][ stance ]
		if ( len2d > 0.25 ) then
			if wep:GetBlocking() then 
				seq = "walk_melee2"
			else 
				seq = formdata[ "run" ]
			end
		else
			if wep:GetBlocking() then 
				seq = "judge_b_block"
			else 
				seq = formdata[ "idle" ]
			end
		end	
	end
	
	if ply:Crouching() then
		seq = "cwalk_knife"
	end		
	
	if ply:GetNW2Float( "wOS.ForceAnim", 0 ) >= CurTime() then
		seq = "walk_magic"
	end
	
	if not ply:IsOnGround() then 
		seq = "balanced_jump"
	end
	
	seq = ply:LookupSequence( seq )
	
	if seq <= 0 then return end
	
	return -1, seq
	
end )										
--addons/wos-grandmaster-einf/lua/wos/advswl/core/cl_form_menu.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

local w,h = ScrW(), ScrH()

surface.CreateFont( "wOS.ALCS.Form.TitleFont", {
	font = "Roboto Cn",
	extended = false,
	size = 24 * (h / 1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

function wOS.ALCS:OpenFormMenu( dual )
	if self.FormMenu then return end

	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end

	local forms = {}
	local group = LocalPlayer():GetUserGroup()
	local dual = wep:GetDualMode()

	if not wep.UseSkills then
		if wep.UseForms then
			for fr, _ in pairs( wep.UseForms ) do
				table.insert( forms, fr )
			end
		else
			if table.HasValue( wOS.ALCS.Config.AllAccessForms, group ) then
				if dual then
					for form, _ in pairs( wOS.DualForms ) do
						table.insert( forms, form )
					end
				else
					for form, _ in pairs( wOS.Forms ) do
						table.insert( forms, form )
					end
				end
			else
				if dual then
					for form, _ in pairs( wOS.DualForms ) do
						if wOS.DualForms[ form ][ group ] then
							table.insert( forms, form )
						end
					end
				else
					for form, _ in pairs( wOS.Forms ) do
						if wOS.Forms[ form ][ group ] then
							table.insert( forms, form )
						end
					end
				end
			end
		end
	else
		local dat = ( dual and wOS.DualForms ) or wOS.Forms
		if wep.Forms then
			for _, form in pairs( wep.Forms ) do
				if dat[ form ] then
					table.insert( forms, form )
				end
			end
		end
	end

	if table.Count( forms ) < 1 then return end

	gui.EnableScreenClicker( true )
	self.FormMenu = vgui.Create( "DPanel" )
	self.FormMenu:SetSize( w * 0.33, h * 0.5 )
	self.FormMenu:SetPos( w * 0.5 - w * 0.33 / 2, h * 0.25 )
	self.FormMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		draw.SimpleText( "Form Select Menu", "wOS.ALCS.Form.TitleFont", ww / 2, hh * 0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local fw, fh = self.FormMenu:GetSize()

	local mw, mh = fw * 0.9, fh * 0.8

	local formlist = vgui.Create("DScrollPanel", self.FormMenu )
	formlist:SetPos( fw * 0.05, fh * 0.1 )
	formlist:SetSize( mw, mh )
	formlist.Paint = function( pan, ww, hh )
	end
	formlist.VBar.Paint = function() end
	formlist.VBar.btnUp.Paint = function() end
	formlist.VBar.btnDown.Paint = function() end
	formlist.VBar.btnGrip.Paint = function() end

	local offsety = 0
	local pady = mh * 0.01

	local button = vgui.Create( "DButton", self.FormMenu )
	button:SetSize( fw * 0.05, fw * 0.05 )
	button:SetPos( fw * 0.94, fw * 0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.FormMenu:Remove()
		self.FormMenu = nil
		gui.EnableScreenClicker( false )
	end

	local button1 = vgui.Create( "DButton", self.FormMenu )
	button1:SetSize( fw, fh * 0.1 )
	button1:SetPos( 0, fh * 0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.ALCS.Form.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.ALCS.Form.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "www.wiltostech.com" )
	end

	for _, form in pairs( forms ) do
		local button = vgui.Create( "DButton", formlist )
		button:SetSize( mw, mh * 0.1 )
		button:SetPos( 0, offsety )
		button:SetText( "" )
		button.Form = form
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.Form, "wOS.ALCS.Form.TitleFont", ww * 0.05, hh / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		button.DoClick = function()
			self.FormMenu:Remove()
			self.FormMenu = nil
			net.Start( "wOS.ALCS.SendFormSelect" )
			net.WriteString( button.Form )
			net.SendToServer()
			gui.EnableScreenClicker( false )
		end

		offsety = offsety + mh * 0.1 + pady
	end
end
--addons/wos-grandmaster-einf/lua/wos/advswl/forcesys/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.AvailablePowers = wOS.AvailablePowers or {}
wOS.ForceIcons = wOS.ForceIcons or {}

net.Receive( "wOS.Lightsabers.SendAllForceData", function()
	wOS.AvailablePowers = net.ReadTable()
	for name, data in pairs( wOS.AvailablePowers ) do
		if data.image then
			wOS.ForceIcons[ name ] = Material( data.image, "unlitgeneric" )
		end
	end
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}

--This order may look completely stupid, and you'd ask why I wouldn't just cluster them all together
--Well, load orders are very important, and this is the best way to control it

if SERVER then

	AddCSLuaFile( "wos/advswl/crafting/core/sh_enums.lua" )
	AddCSLuaFile( "wos/advswl/crafting/core/cl_core.lua" )	
	AddCSLuaFile( "wos/advswl/crafting/core/cl_net.lua" )
	AddCSLuaFile( "wos/advswl/crafting/inventory/cl_core.lua" )
	AddCSLuaFile( "wos/advswl/crafting/core/sh_core.lua" )
	
end

include( "wos/advswl/crafting/core/sh_enums.lua" )
include( "wos/advswl/crafting/core/sh_core.lua" )
 

if SERVER then

	if wOS.ALCS.Config.Crafting.ShouldCraftingUseMySQL then
		include( "wos/advswl/crafting/wrappers/sv_mysql.lua" )
	else
		include( "wos/advswl/crafting/wrappers/sv_data.lua" )
	end
	
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/core/sv_core.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/core/sv_item_register.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/core/sv_net.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/core/sv_concommands.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/inventory/sv_core.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/crafting/core/sv_craft_meta.lua" )
	
else
	include( "wos/advswl/crafting/core/cl_core.lua" )
	include( "wos/advswl/crafting/core/cl_net.lua" )
	include( "wos/advswl/crafting/inventory/cl_core.lua" )
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/skills/core/sh_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
																																																																																																																																																						

local meta = FindMetaTable( "Player" )

----GET FUNCTIONS

function meta:GetSkillPoints()
	return self:GetNW2Int( "wOS.SkillPoints", 0 )
end

function meta:GetSkillLevel()
	return self:GetNW2Int( "wOS.SkillLevel", 0 )
end

function meta:GetSkillXP()
	return self:GetNW2Int( "wOS.SkillExperience", 0 )
end

function meta:GetSkillRequiredXP()
	local level = self:GetSkillLevel()
	return wOS.ALCS.Config.Skills.XPScaleFormula( level )
end

function meta:HasSkillEquipped( tree, tier, skill )

	if not self.EquippedSkills[ name ] then return false end
	if not self.EquippedSkills[ name ][ tier ] then return false end
	
	return self.EquippedSkills[ name ][ tier ][ skill ]
	
end

function meta:CanEquipSkill( tree, tier, skill )

	local skilldata = wOS.SkillTrees[ name ][ tier ][ skill ]
	
	if not skilldata then return false end
	
	if table.Count( skilldata.Requirements ) < 1 then return true end
	
	for num, skills in pairs( skilldata.Requirements ) do
		if not self:HasSkillEquipped( tree, skills[1], skills[2] ) then return false end
	end
	
	if self:GetSkillPoints() < skilldata.PointsRequired then return false end
	
	return true
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/skills/core/cl_classic_ui.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--









































































if wOS.ALCS.Config.Skills.MenuSchema != WOS_ALCS.SKILLMENU.CLASSIC then return end

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}

local w,h = ScrW(), ScrH()	
local PLAYER = LocalPlayer()																																																																																																																												
local SkillColor = Color( 0, 0, 0, 155 )

local blur = Material 'pp/blurscreen'
local function blurpanel (panel, amount )
    local x, y = panel:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat('$blur', (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    end
end

surface.CreateFont( "wOS.SkillTreeMain", {
	font = "Roboto Cn",
	extended = false,
	size = 32*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.SkillHelpFont", {
	font = "Roboto Cn",
	extended = false,
	size = 28*(h/1200),
	weight = 600,
	blursize = 0,
	scanlines = 1,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local HELP_TEXT = [[This is your Character Development menu, powered by wiltOS Technologies. Here, you can build into a particular skill set as you gain experience in the field.

You will notice your character progress on the bottom of the menu. As you level up you will get skill points to spend in a respective tree.

Choose a skill tree on the left side of the screen to see the skills. Hover over a skill icon to find out information about it.

Skills can affect various things including your personal lightsaber, so make sure you read about them carefully.

Some skills in a tree require previous skills to obtain. You can see the pre-requisite skills by following the white line between them.

Red lines between skills mean that owning one will lock you out of the other. So choose wisely.
]]

function wOS.ALCS.Skills:OpenClassicTreeMenu()

	if self.ClassicMenu then
		self.ClassicMenu:Remove()
		self.ClassicMenu = nil
	end
	
	gui.EnableScreenClicker( true )

	self.ClassicMenu = vgui.Create( "DFrame" )
	self.ClassicMenu:SetDraggable( true )
	self.ClassicMenu:ShowCloseButton( false )
	self.ClassicMenu:SetTitle( "" )
	local sx, sy = wOS.ALCS.Skills.Menu:GetSize()
	self.ClassicMenu:SetSize( sx, sy )
	local px, py = wOS.ALCS.Skills.Menu:GetPos()
	self.ClassicMenu:SetPos( px, py )
	self.ClassicMenu.Paint = function( pan, ww, hh )
		draw.RoundedBox( 0, 0, 0, ww*0.985, hh*0.02, Color( 255, 255, 255, 155 ) )
		draw.RoundedBox( 0, ww*0.985, 0, ww*0.015, hh*0.02, Color( 255, 0, 0 ) )
	end	

	local mw, mh = self.ClassicMenu:GetSize()

	local button = vgui.Create( "DButton", self.ClassicMenu )
	button:SetSize( mw*0.015, mh*0.02 )
	button:SetPos( mw*0.985, 0 )
	button:SetText( "" )
	button.DoClick = function()
		wOS.ALCS.Skills:CleanAllMenus()
		self.ClassicMenu:Remove()
		self.ClassicMenu = nil
	end	
	button.Paint = nil

	local p_think = self.ClassicMenu.Think
	self.ClassicMenu.Think = function( pan )
		p_think( pan )
		if not vgui.CursorVisible() then
			gui.EnableScreenClicker( true )
		end
		if not LocalPlayer():Alive() then
			button:DoClick()
			return
		end
	end

	SkillColor = Color( 25, 25, 25, 155 )

	self.DataTab = vgui.Create( "DPanel", self.ClassicMenu )
	self.DataTab:SetPos( 0, mh*0.02 )
	self.DataTab:SetSize( mw, mh*0.98 )
	self.DataTab.Color = SkillColor
	self.DataTab.Paint = function( pan, ww, hh )
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
	end
	
	gui.EnableScreenClicker( true )
	
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local sw, sh = mw - cw - 3*padx, ch
	local skw, skh = sw - 2*padx, sh*0.65
	
	self.DataTab.Think = function( pan )
		pan.Color.r = ( pan.Color.r == SkillColor.r and SkillColor.r ) or Lerp( 0.1, pan.Color.r, SkillColor.r )
		pan.Color.g = ( pan.Color.g == SkillColor.g and SkillColor.g ) or Lerp( 0.1, pan.Color.g, SkillColor.g )
		pan.Color.b = ( pan.Color.b == SkillColor.b and SkillColor.b ) or Lerp( 0.1, pan.Color.b, SkillColor.b )
		pan.Color.a = ( pan.Color.a == SkillColor.a and SkillColor.a ) or Lerp( 0.1, pan.Color.a, SkillColor.a )
		
		local button = vgui.GetHoveredPanel() 
		if not button then self.SkillInfoPanel:SetVisible( false ) return end
		if button.Data then
			if button.Data.Tree then
				self.SkillInfoPanel:SetVisible( true )
				self.SkillInfoPanel.Data = button.Data		
			end
		else
			self.SkillInfoPanel:SetVisible( false )
		end
	end
	
	local categories = vgui.Create( "DScrollPanel", self.DataTab )
	categories:SetSize( cw, ch*0.93 )
	categories:SetPos( padx, pady )
	categories.Paint = function( pan, ww, hh )	
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
	end
	categories.VBar.Paint = function() end
	categories.VBar.btnUp.Paint = function() end
	categories.VBar.btnDown.Paint = function() end
	categories.VBar.btnGrip.Paint = function() end
	
	local skilltrees = {}
	skilltrees[ "Help Menu" ] = { BackgroundColor = Color( 25, 25, 25, 155 ), Name = "Help Menu", Description = "Learn how to decide your fate", Help = "" }
	for name, data in pairs( wOS.SkillTrees ) do
		if data.UserGroups then
			if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
		end
		skilltrees[ name ] = data
	end
	
	local icon = 128*(h/1200)
	
	local main_frame = vgui.Create( "DPanel", self.DataTab )
	main_frame:SetPos( padx*2 + cw, pady )
	main_frame:SetSize( sw, sh )
	main_frame.CurrentTree = "Help Menu"
	main_frame.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )	
		
		draw.NoTexture()
		surface.SetDrawColor( color_white )
		surface.SetMaterial( wOS.TreeIcons[ pan.CurrentTree ].MainIcon )
		surface.DrawTexturedRect( ( ww - icon )*0.5, pady, icon, icon )
		
		local tx, ty = draw.SimpleText( skilltrees[ pan.CurrentTree ].Name, "wOS.SkillTreeMain", ww/2, pady + icon + bpady, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		local txx, tyy = draw.SimpleText( skilltrees[ pan.CurrentTree ].Description, "wOS.TitleFont", ww/2, pady + icon + 2*bpady + ty, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )		
		surface.DrawLine( ww*0.25, 2*pady + icon + 2*bpady + ty + tyy, ww*0.75, 2*pady + icon + 2*bpady + ty + tyy )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		local level = LocalPlayer():GetNW2Int( "wOS.SkillLevel", 0 )
		local xp = LocalPlayer():GetNW2Int( "wOS.SkillExperience", 0 )
		local reqxp = wOS.ALCS.Config.Skills.XPScaleFormula( level )
		local lastxp = 0
		if level > 0 then
			lastxp = wOS.ALCS.Config.Skills.XPScaleFormula( level - 1 )
		end
		local rat = ( xp - lastxp )/( reqxp - lastxp )
		if level == wOS.ALCS.Config.Skills.SkillMaxLevel then
			rat = 1
		end
		surface.DrawOutlinedRect( ww*0.33, hh*0.965, ww*0.33, hh*0.02 )
		surface.DrawRect( ww*0.33, hh*0.965, ww*0.33*rat, hh*0.02 )
		draw.SimpleText( ( level == wOS.ALCS.Config.Skills.SkillMaxLevel and "MAX" ) or lastxp, "wOS.DescriptionFont", ww*0.325, hh*0.974, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		draw.SimpleText( ( level == wOS.ALCS.Config.Skills.SkillMaxLevel and "LEVEL" ) or reqxp, "wOS.DescriptionFont", ww*0.665, hh*0.974, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		draw.SimpleText( xp, "wOS.DescriptionFont", ww*0.5, hh*0.974, Color( 0, 128, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		draw.SimpleText( "Combat Level: " .. level, "wOS.TitleFont", padx, hh - pady, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )		
		draw.SimpleText( "Skill Points: " .. LocalPlayer():GetNW2Int( "wOS.SkillPoints", 0 ), "wOS.TitleFont", ww - padx, hh - pady, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )		
	end
	
	local skills_window = vgui.Create( "DPanel", main_frame )
	skills_window:SetSize( skw, skh )
	skills_window:SetPos( padx, sh*0.3 )
	skills_window.Paint = function( pan, ww, hh )
		draw.RoundedBox( 0, 0, 0, ww, hh, Color( 25, 25, 25, 155 ) )
		if pan.Buttons then
			for tier, bdata in pairs( pan.Buttons ) do
				for skill, button in pairs( bdata ) do
					local data = button.Data
					if data.DummySkill then continue end
					if table.Count( data.Requirements ) > 0 then
						local sx, sy = button:GetCenter()
						for treq, rdata in pairs( data.Requirements ) do
							for _, sreq in pairs( rdata ) do
								local dx, dy = pan.Buttons[ treq ][ sreq ]:GetCenter()
								surface.SetDrawColor( color_white )
								surface.DrawLine( sx, sy, dx, dy )
							end
						end
					end

					if data.LockOuts and table.Count( data.LockOuts ) > 0 then
						local sx, sy = button:GetCenter()
						for treq, rdata in pairs( data.LockOuts ) do
							for _, sreq in pairs( rdata ) do
								local dx, dy = pan.Buttons[ treq ][ sreq ]:GetCenter()
								surface.SetDrawColor( Color( 255, 0, 0 ) )
								surface.DrawLine( sx, sy, dx, dy )
							end
						end
					end
				end
			end
		end
	end
	
	local offsety = pady

	for name, data in pairs( skilltrees ) do
		local can_view = hook.Call( "wOS.ALCS.Skill.CanViewTree", nil, LocalPlayer(), name, data )
		if can_view != nil then
			if not can_view then continue end
		end
		if ( not wOS.SkillTreeWhitelists[ name ] ) and !can_view then
			if data.UserGroups then
				if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
			end
			if data.JobRestricted then
				local found = false
				for _, job in pairs( data.JobRestricted ) do
					if _G[ job ] == LocalPlayer():Team() then 
						found = true
						break 
					end
				end
				if not found then continue end
			end
		end

		local button = vgui.Create( "DButton", categories )
		button:SetSize( cw - 2*pady, ch/10 )
		button:SetPos( pady, offsety )
		button:SetText( "" )
		button.Data = data
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.Data.Name, "wOS.TitleFont", hh, hh*0.33, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( button.Data.Description, "wOS.DescriptionFont", hh, hh*0.66, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			local image = wOS.TreeIcons[ button.Data.Name ].MainIcon
			if image then
				surface.SetMaterial( image )
				surface.SetDrawColor( Color(255, 255, 255, 255) );
				surface.DrawTexturedRect( hh*0.025, hh*0.025, hh*0.95, hh*0.95 )
			end
		end
		button.DoClick = function()
			main_frame.CurrentTree = name
			SkillColor = data.BackgroundColor
			main_frame:RefreshTree()
		end
		
		offsety = offsety + mh*0.1 + bpady		
		
	end
	
	main_frame.RefreshTree = function( pan )
	
		skills_window:Clear()
		skills_window.Buttons = false
		local lw, lh = skills_window:GetSize()
		local name = pan.CurrentTree
		
		if name == "Help Menu" then 
			local infotext = vgui.Create( "RichText", skills_window )
			infotext:SetSize( lw, lh )
			infotext:SetVerticalScrollbarEnabled( false ) 
			infotext.Paint = function()
				infotext.m_FontName = "wOS.SkillHelpFont"
				infotext:SetFontInternal( "wOS.SkillHelpFont" )	
				infotext:SetBGColor(Color(0,0,0,0))		
				infotext.Paint = nil
			end
			infotext:AppendText( HELP_TEXT )
			return 
		end
		skills_window.Buttons = {}
		local data = skilltrees[ name ]
		local icon = 64*(h/1200)
		local spady = ( lh - 4*pady*( data.MaxTiers + 1 ) )/data.MaxTiers
		local offsety = pady
		for i = 1, data.MaxTiers do
			local tier = data.MaxTiers - i + 1
			local skilltable = data.Tier[ tier ]
			local spadx = ( lw - icon*( #skilltable ) - 2*padx )/#skilltable
			local offsetx = lw/2 - ( #skilltable - 1 )*spadx/2 - icon/2
			skills_window.Buttons[ tier ] = {}
			for skill, skilldata in pairs( skilltable ) do
				if !skilldata.DummySkill then
					skills_window.Buttons[ tier ][ skill ] = vgui.Create( "DImageButton", skills_window )
					skills_window.Buttons[ tier ][ skill ]:SetImage( skilldata.Icon )
				else
					skills_window.Buttons[ tier ][ skill ] = vgui.Create( "DPanel", skills_window )				
				end
				skills_window.Buttons[ tier ][ skill ]:SetSize( icon, icon )
				skills_window.Buttons[ tier ][ skill ]:SetPos( offsetx, offsety )
				skills_window.Buttons[ tier ][ skill ].Data = skilldata
				skills_window.Buttons[ tier ][ skill ].Data.Tier = tier
				skills_window.Buttons[ tier ][ skill ].Data.Skill = skill	
				skills_window.Buttons[ tier ][ skill ].Data.Tree = name				
				skills_window.Buttons[ tier ][ skill ].GetCenter = function( pan )
					local x, y = pan:GetPos()
					return x + pan:GetWide()/2, y + pan:GetTall()/2
				end
				local _buttonpaint = skills_window.Buttons[ tier ][ skill ].Paint
				skills_window.Buttons[ tier ][ skill ].Paint = function( pan, ww, hh )
					if pan.Data.DummySkill then return end
					if not wOS:HasSkillEquipped( name, tier, skill ) or not wOS:CanEquipSkill( name, tier, skill ) then
						draw.RoundedBox( 5, 0, 0, ww, hh, Color( 35, 35, 35, 155 ) )
					else
						draw.RoundedBox( 5, 0, 0, ww, hh, Color( 0, 128, 255, 55 ) )					
					end
				end
				skills_window.Buttons[ tier ][ skill ].DoClick = function( pan )
					if pan.Data.DummySkill then return end
					if wOS:HasSkillEquipped( name, tier, skill ) or !wOS:CanEquipSkill( name, tier, skill ) then return end
					net.Start( "wOS.SkillTree.ChooseSkill" )
						net.WriteString( name )
						net.WriteInt( tier, 32 )
						net.WriteInt( skill, 32 )
					net.SendToServer()
				end
				offsetx = offsetx + spadx
			end
			offsety = offsety + 4*pady + spady
		end
		
	end		
		
	
	main_frame:RefreshTree()
	
	self.SkillInfoPanel = vgui.Create( "DPanel" )
	self.SkillInfoPanel:SetSize( mw*0.26, mh*0.08 )
	self.SkillInfoPanel:SetPos( w, h )
	self.SkillInfoPanel.Data = false
	self.SkillInfoPanel:SetVisible( false )
	self.SkillInfoPanel.Paint = function( pan, ww, hh )	
		if not ww or not hh then return end
		if self.SkillInfoPanel.Data then
			if self.SkillInfoPanel.Data.DummySkill then return end
			draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 255 ) )
			surface.SetDrawColor( color_white )
			surface.DrawOutlinedRect( ww*0.01, hh*0.01, ww*0.98, hh*0.98 )
			draw.SimpleText( pan.Data.Name, "wOS.TitleFont", ww*0.04, hh*0.25, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( pan.Data.Description, "wOS.DescriptionFont", ww*0.04, hh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if not wOS:HasSkillEquipped( pan.Data.Tree, pan.Data.Tier, pan.Data.Skill ) then
				if wOS:CanEquipSkill( pan.Data.Tree, pan.Data.Tier, pan.Data.Skill ) then
					draw.SimpleText( "Requires " .. pan.Data.PointsRequired .. " skill point(s)", "wOS.DescriptionFont", ww*0.04, hh*0.75, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( "UNAVAILABLE", "wOS.DescriptionFont", ww*0.04, hh*0.75, Color( 255, 0, 0, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
				end
			else
				draw.SimpleText( "EQUIPPED", "wOS.DescriptionFont", ww*0.04, hh*0.75, Color( 0, 128, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
			end
		end
		
	end
	self.SkillInfoPanel.Think = function( pan )
		pan:SetPos( gui.MouseX() + 15, gui.MouseY() + 15 )
	end

	local reset = vgui.Create( "DButton", self.ClassicMenu )
	reset:SetPos( padx, ch*0.93 + 2*pady )
	reset:SetSize( cw, ch*0.07 - pady )
	reset:SetText( "" )
	reset.Paint = function( pan, ww, hh )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		local color = color_white
		if pan:IsHovered() then
			color = Color( 0, 155, 255, 255 )
		end
		draw.SimpleText( "GO BACK", "wOS.SkillTreeMain", ww/2, hh/2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	reset.DoClick = function()
		wOS.ALCS.Skills.SkillInfoPanel:Remove()
		wOS.ALCS.Skills.SkillInfoPanel = nil
		wOS.ALCS.Skills.Menu:SetVisible( true )
		self.ClassicMenu:Remove()
		self.ClassicMenu = nil
	end
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/lightsaber/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































local SWEP = {}

SWEP.Vars = {}

SWEP.PrintName = "Lightsaber Base"
SWEP.Author = "Robotboy655 + King David"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "robotboy655@gmail.com"
SWEP.Purpose = "To slice off each others limbs and heads."
SWEP.Instructions = "Use the force, Luke."
SWEP.RenderGroup = RENDERGROUP_BOTH

SWEP.LoadDelay = 0
SWEP.RegendSpeed = 1
SWEP.MaxForce = 100
SWEP.ForcePowerList = {}
SWEP.DevestatorList = {}

SWEP.Slot = 0
SWEP.SlotPos = 4

SWEP.Spawnable = false
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false

SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55

SWEP.AlwaysRaised = true

SWEP.BlockInvincibility = false
SWEP.Stance = 1
SWEP.Enabled = false
SWEP.PlayerStances = {}
SWEP.IsLightsaber = true
SWEP.CurStance = 1
SWEP.FPCamTime = 0
SWEP.BlockDrainRate = 0.1
SWEP.DevestatorTime = 0
SWEP.UltimateCooldown = 0
SWEP.StaminaRegenSpeed = 1
SWEP.Cooldowns = {}

killicon.Add( "weapon_lightsaber_wos", "lightsaber/lightsaber_killicon", color_white )

local WepSelectIcon = Material( "lightsaber/selection.png" )
local Size = 96

function SWEP:SetupDataTables()

	self:NetworkVar( "Float", 0, "BladeLength" )
	self:NetworkVar( "Float", 1, "MaxLength" )
	self:NetworkVar( "Float", 2, "BladeWidth" )
	self:NetworkVar( "Float", 3, "Force" )
	self:NetworkVar( "Float", 5, "SecBladeLength" )
	self:NetworkVar( "Float", 6, "SecMaxLength" )
	self:NetworkVar( "Float", 7, "SecBladeWidth" )
	self:NetworkVar( "Float", 8, "DevEnergy" )
	self:NetworkVar( "Float", 9, "FPCamTime" )
	self:NetworkVar( "Float", 10, "Delay" )
	self:NetworkVar( "Float", 11, "BlockDrain" )
	self:NetworkVar( "Float", 12, "ForceCooldown" )
	self:NetworkVar( "Float", 13, "Stamina" )	
	self:NetworkVar( "Float", 14, "AttackDelay" )	
	
	self:NetworkVar( "Bool", 0, "DarkInner" )
	self:NetworkVar( "Bool", 1, "SecDarkInner" )
	self:NetworkVar( "Bool", 2, "Enabled" )
	self:NetworkVar( "Bool", 3, "WorksUnderwater" )
	self:NetworkVar( "Bool", 4, "AnimEnabled" )
	self:NetworkVar( "Bool", 5, "Cloaking" )
	self:NetworkVar( "Bool", 6, "DualMode" )
	self:NetworkVar( "Bool", 7, "Blocking" )
	self:NetworkVar( "Bool", 8, "HonorBound" )
	
	self:NetworkVar( "Int", 0, "ForceType" )
	self:NetworkVar( "Int", 1, "DevestatorType" )
	self:NetworkVar( "Int", 3, "Stance" )
	self:NetworkVar( "Int", 4, "Form" )
	self:NetworkVar( "Int", 5, "MaxForce" )
	self:NetworkVar( "Int", 6, "MaxStamina" )
	self:NetworkVar( "Int", 7, "HiltHoldtype" )
	self:NetworkVar( "Int", 8, "MeditateMode" )
	
	self:NetworkVar( "Vector", 0, "CrystalColor" )
	self:NetworkVar( "Vector", 1, "SecCrystalColor" )
	self:NetworkVar( "Vector", 2, "InnerColor" )
	self:NetworkVar( "Vector", 3, "SecInnerColor" )		
	
	self:NetworkVar( "String", 0, "WorldModel" )
	self:NetworkVar( "String", 1, "SecWorldModel" )
	self:NetworkVar( "String", 2, "OnSound" )
	self:NetworkVar( "String", 3, "OffSound" )
	
	self:NetworkVar( "Entity", 0, "ForceTarget" )
	
end

function SWEP:GenerateThinkFunctions()
	self.ThinkFunctions = {}

end

function SWEP:GenerateAttackFunctions()
	self.AttackFunctions = {}

end

function SWEP:PrimaryAttack()
	if ( !IsValid( self.Owner ) ) then return end
	if self:GetBlocking() then return end
	if self.HeavyCharge then 
		if self.HeavyCharge >= CurTime() then return end
	end
	if ( prone and self.Owner:IsProne() ) then self.Owner:SetAnimation( PLAYER_ATTACK1 ); return end
	
	if not self:GetAnimEnabled() then self.Owner:SetAnimation( PLAYER_ATTACK1 ); return end
end

function SWEP:SecondaryAttack()

end

function SWEP:Reload()

end

function SWEP:GetSaberPosAng( num, side, model )

	num = num or 1
	model = model or self
	local dual = false
	if ( IsValid( self.Owner ) ) then
		local bone = self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" )
		if self.LeftHilt then
			if model == self.LeftHilt then
				bone = self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" )
				dual = true
			end
		end
		local attachment = model:LookupAttachment( "blade" .. num )
		if ( side ) then
			attachment = model:LookupAttachment( "quillon" .. num )
		end

		if ( !bone ) then

		end

		if ( attachment && attachment > 0 ) then
			local PosAng = model:GetAttachment( attachment )

			if ( !bone ) then
				PosAng.Pos = PosAng.Pos + Vector( 0, 0, 36 )
				if ( IsValid( self.Owner ) && self.Owner:IsPlayer() && self.Owner:Crouching() ) then PosAng.Pos = PosAng.Pos - Vector( 0, 0, 18 ) end
				PosAng.Ang.p = 0
			end

			return PosAng.Pos, PosAng.Ang:Forward()
		end

		if ( bone ) then
		
			local pos, ang = self.Owner:GetBonePosition( bone )
			if ( pos == self.Owner:GetPos() ) then
				local matrix = self.Owner:GetBoneMatrix( bone )
				if ( matrix ) then
					pos = matrix:GetTranslation()
					ang = matrix:GetAngles()
				end
			end
		
			if !dual then
				ang:RotateAroundAxis( ang:Forward(), 180 )
				ang:RotateAroundAxis( ang:Up(), 30 )
				ang:RotateAroundAxis( ang:Forward(), -5.7 )
				ang:RotateAroundAxis( ang:Right(), 92 )

				pos = pos + ang:Up() * -3.3 + ang:Right() * 0.8 + ang:Forward() * 5.6
				
			else
				ang:RotateAroundAxis( ang:Forward(), -180 )
				ang:RotateAroundAxis( ang:Up(), 0 )
				ang:RotateAroundAxis( ang:Forward(), -5 )
				ang:RotateAroundAxis( ang:Right(), -86 )

				pos = pos - ang:Up() * -3.6 - ang:Right() * 1.1 + ang:Forward() * 6.2			
			end
			
			return pos, ang:Forward()
		end
	end

	local defAng = model:GetAngles()
	defAng.p = 0

	local defPos = model:GetPos() + defAng:Right() * 0.6 - defAng:Up() * 0.2 + defAng:Forward() * 0.8
	defPos = defPos + Vector( 0, 0, 36 )
	if ( IsValid( self.Owner ) && self.Owner:Crouching() ) then defPos = defPos - Vector( 0, 0, 18 ) end

	return defPos, -defAng:Forward()
	
end

function SWEP:GetTargetEntity( dist, num )

	local dsqr = dist*dist
	local t = {}
	local group = player.GetAll()
	table.Add( group, ents.FindByClass( "npc_*" ) )
	local p = {}
	for id, ply in pairs( group ) do
		if ( !ply:GetModel() or ply:GetModel() == "" or ply == self.Owner or ply:Health() < 1 ) then continue end
		
		local wep = ply:GetActiveWeapon()
		if IsValid( wep ) then
			if wep.IsLightsaber then
				if wep:GetCloaking() then continue end
			end
		end
		
		local tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = (ply.GetShootPos && ply:GetShootPos() or ply:GetPos()),
			filter = self.Owner,
		} )

		if ( tr.Entity != ply && IsValid( tr.Entity ) or tr.Entity == game.GetWorld() ) then continue end

		local pos1 = self.Owner:GetPos() + self.Owner:GetAimVector() * dist
		local pos2 = ply:GetPos()

		if ( pos1:DistToSqr( pos2 ) <= dsqr && ply:EntIndex() > 0 ) then
			table.insert( p, { ply = ply, dist = tr.HitPos:DistToSqr( pos2 ) } )
		end
	end

	for id, ply in SortedPairsByMemberValue( p, "dist" ) do
		table.insert( t, ply.ply )
		if ( #t >= num ) then return t end
	end

	return t
	
end

function SWEP:TargetThoughts()

	local target = self:GetForceTarget()
	if not IsValid( target ) then return end
	
	local diff = target:GetPos() - self.Owner:GetPos()
	local ang = ( diff ):Angle()
	local tang = LocalPlayer():EyeAngles()
	tang.y = ang.y
	
	LocalPlayer():SetEyeAngles( tang )
	
end

function SWEP:Holster()

	if self:GetEnabled() then return false end
	if self:GetHonorBound() then return false end
	
	if IsValid( self.LeftHilt ) then
		self.LeftHilt:Remove()
		self.LeftHilt = nil
	end
	
	return true
end

function SWEP:OnRemove()
	if IsValid( self.LeftHilt ) then
		self.LeftHilt:Remove()
		self.LeftHilt = nil
	end	
	return true
end

function SWEP:Deploy()

end


function SWEP:Think()
	--self:TargetThoughts()
end

----OTHER STUFF

function SWEP:GetTargetHoldType()
	--if ( !self:GetEnabled() ) then return "normal" end
	if ( self:GetWorldModel() == "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" ) then return "knife" end
	if ( self:LookupAttachment( "blade2" ) && self:LookupAttachment( "blade2" ) > 0 ) then return "knife" end

	return ( self:GetDualMode() and "knife" ) or "melee2"
end

function SWEP:GetActiveForcePowerType( id )
	local ForcePowers = self.ForcePowers
	return ForcePowers[ id ]
end

function SWEP:GetActiveForcePowers()
	return self.ForcePowers
end

function SWEP:Initialize()
	self.IsLightsaber = true
	self.LoopSound = self.LoopSound or "lightsaber/saber_loop" .. math.random( 1, 8 ) .. ".wav"
	self.SwingSound = self.SwingSound or "lightsaber/saber_swing" .. math.random( 1, 2 ) .. ".wav"
	self:SetWeaponHoldType( self:GetTargetHoldType() )
	
	self.ForcePowers = {}
	self.AvailablePowers = table.Copy( wOS.AvailablePowers )
	local breakoff = wOS.ALCS.Config.LightsaberHUD == WOS_ALCS.HUD.HYBRID
	for _, force in pairs( self.ForcePowerList ) do
		if not self.AvailablePowers[ force ] then continue end
		self.ForcePowers[ #self.ForcePowers + 1 ] = self.AvailablePowers[ force ]
		if not breakoff then continue end
		if #self.ForcePowers >= wOS.ALCS.Config.MaximumForceSlots then break end
	end
	
	self.Devestators = {}
	self.AvailableDevestators = table.Copy( wOS.AvailableDevestators )
	for _, dev in pairs( self.DevestatorList ) do
		if not self.AvailableDevestators[ dev ] then continue end
		self.Devestators[ #self.Devestators + 1 ] = self.AvailableDevestators[ dev ]
	end
	
	self:GenerateThinkFunctions()
	
end

function SWEP:GetActiveDevestators()
	local Devestators = {}
	for id, t in pairs( self.Devestators ) do
		table.insert( Devestators, t )
	end
	return Devestators
end

function SWEP:GetActiveDevestatorType( id )
	local Devestators = self:GetActiveDevestators()
	return Devestators[ id ]
end

function SWEP:DrawWeaponSelection( x, y, w, h, a )
	surface.SetDrawColor( 255, 255, 255, a )
	surface.SetMaterial( WepSelectIcon )

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	surface.DrawTexturedRect( x + ( ( w - Size ) / 2 ), y + ( ( h - Size ) / 2.5 ), Size, Size )

	render.PopFilterMag()
	render.PopFilterMin()
end

function SWEP:DrawWorldModel(flags)
	self:DrawModel( flags )
end

function SWEP:DrawWorldModelTranslucent()
	
	--Prevents flickering!!
	self.WorldModel = self:GetWorldModel()
	self:SetModel( self:GetWorldModel() )
	
	self:DrawPrimarySaber()
	if self:GetDualMode() and LocalPlayer():HasWeapon(self:GetClass()) then
		self:DrawSecondarySaber()
	end
	
end

function SWEP:DrawPrimarySaber()
	if ( !IsValid( self:GetOwner() ) or halo.RenderedEntity() == self ) then return end
	
	if self:GetCloaking() then 
		local vel = self.Owner:GetVelocity():Length()
		if vel < 130 then return end
		self:SetMaterial("models/shadertest/shader3")
		self:DrawModel()
		return
	end
	
	self:SetMaterial( "" )
	self:DrawModel()

	if self.NoBlade then return end

	local clr = self:GetCrystalColor()
	clr = Color( clr.x, clr.y, clr.z )
	
	local clr_inner = self:GetInnerColor()
	clr_inner = Color( clr_inner.x, clr_inner.y, clr_inner.z )

	local bladesFound = false
	local blades = 0

	for id, t in pairs( self:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && self:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( bladeNum )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, false, blades, self.CustomSettings )
			bladesFound = true
		end

		if ( quillonNum && self:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( quillonNum, true )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, true, blades, self.CustomSettings )
		end

	end

	if ( !bladesFound ) then
		local pos, dir = self:GetSaberPosAng()
		rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, nil, nil, self.CustomSettings )
	end
	
end

function SWEP:DrawSecondarySaber()

	if !IsValid( self.LeftHilt ) and self:GetDualMode() then
		self.LeftHilt = ents.CreateClientProp()
		self.LeftHilt:SetModel( self:GetSecWorldModel() )
		self.LeftHilt:Spawn()
		self.LeftHilt:SetNoDraw( true )
	end

	if not self.Owner then return end

	local bone = self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" )
	local pos, ang = self.Owner:GetBonePosition( bone )
	if ( pos == self.Owner:GetPos() ) then
		local matrix = self.Owner:GetBoneMatrix( 16 )
		if ( matrix ) then
			pos = matrix:GetTranslation()
			ang = matrix:GetAngles()
		end
	end
	
	if self.LeftHilt:GetModel() == "models/donation gauntlet/donation gauntlet.mdl" then	

		ang:RotateAroundAxis( ang:Forward(), 180 )
		ang:RotateAroundAxis( ang:Up(), 30 )
		ang:RotateAroundAxis( ang:Forward(), -5.7 )
		ang:RotateAroundAxis( ang:Right(), -92 )
		pos = pos + ang:Up() * 3.3 + ang:Right() * 0.4 + ang:Forward() * -7

	else
	
		ang:RotateAroundAxis( ang:Forward(), 180 )
		ang:RotateAroundAxis( ang:Up(), 30 )
		ang:RotateAroundAxis( ang:Forward(), -5.7 )
		ang:RotateAroundAxis( ang:Right(), 92 )
		if not self:GetAnimEnabled() then
			ang:RotateAroundAxis( ang:Up(), 180 )
			pos = pos + ang:Up() * -5 + ang:Right() * -1 + ang:Forward() * -7	
		else
			pos = pos + ang:Up() * -3.3 + ang:Right() * 0.4 + ang:Forward() * -7	
		end
	end

	self.LeftHilt:SetPos( pos )
	self.LeftHilt:SetAngles( ang )
	
	local clr = self:GetSecCrystalColor()
	clr = Color( clr.x, clr.y, clr.z )
	
	local clr_inner = self:GetSecInnerColor()
	clr_inner = Color( clr_inner.x, clr_inner.y, clr_inner.z )

	if self:GetCloaking() then
		if self.Owner:GetVelocity():Length() < 130 then
			self.LeftHilt:SetMaterial("models/effects/vol_light001")
			self.LeftHilt:SetColor( Color( 0, 0, 0, 0 ) )
		else
			self.LeftHilt:SetMaterial("models/shadertest/shader3")
			self.LeftHilt:SetColor( Color( 255, 255, 255, 255 ) )
		end	
		return
	end

	self.LeftHilt:DrawModel()
	self.LeftHilt:SetMaterial( "" )
	self.LeftHilt:SetColor( Color( 255, 255, 255, 255 ) )

	if self.SecNoBlade then return end
	
	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0

	for id, t in pairs( self.LeftHilt:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && self.LeftHilt:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( bladeNum, false, self.LeftHilt )
			rb655_RenderBlade_wos( pos, dir, self:GetSecBladeLength(), self:GetSecMaxLength(), self:GetSecBladeWidth(), clr, self:GetSecDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, false, blades, self.SecCustomSettings, true )
			bladesFound = true
		end

		if ( quillonNum && self.LeftHilt:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( quillonNum, true, self.LeftHilt )
			rb655_RenderBlade_wos( pos, dir, self:GetSecBladeLength(), self:GetSecMaxLength(), self:GetSecBladeWidth(), clr, self:GetSecDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, true, blades, self.SecCustomSettings, true )
		end

	end

	if ( !bladesFound ) then
		local pos, dir = self:GetSaberPosAng( nil, nil, self.LeftHilt )
		if not self:GetAnimEnabled() then
			dir = dir*-1
			pos = pos + dir*12 - dir:Angle():Right()*0.8 - dir:Angle():Up()*1.5
		end
		rb655_RenderBlade_wos( pos, dir, self:GetSecBladeLength(), self:GetSecMaxLength(), self:GetSecBladeWidth(), clr, self:GetSecDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, nil, nil, self.SecCustomSettings, true )
	end
	
end

surface.CreateFont( "SelectedForceType", {
	font	= "Roboto Cn",
	size	= ScreenScale( 16 ),
	weight	= 600
} )

surface.CreateFont( "SelectedForceHUD", {
	font	= "Roboto Cn",
	size	= ScreenScale( 6 )
} )

SWEP.Vars.grad = Material( "gui/gradient_up" )
SWEP.Vars.matBlurScreen = Material( "pp/blurscreen" )
SWEP.Vars.matBlurScreen:SetFloat( "$blur", 3 )
SWEP.Vars.matBlurScreen:Recompute()

function SWEP.Vars:DrawHUDBox( x, y, w, h, b )

	x = math.floor( x )
	y = math.floor( y )
	w = math.floor( w )
	h = math.floor( h )
	
	surface.SetMaterial( self.matBlurScreen )
	surface.SetDrawColor( 255, 255, 255, 255 )


	render.SetScissorRect( x, y, w + x, h + y, true )
		for i = 0.33, 1, 0.33 do
			self.matBlurScreen:SetFloat( "$blur", 5 * i )
			self.matBlurScreen:Recompute()
			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
		end
	render.SetScissorRect( 0, 0, 0, 0, false )


	surface.SetDrawColor( Color( 0, 0, 0, 128 ) )
	surface.DrawRect( x, y, w, h )

	if ( b ) then
		surface.SetMaterial( self.grad )
		surface.SetDrawColor( Color( 0, 128, 255, 4 ) )
		surface.DrawTexturedRect( x, y, w, h )
	end

end


function SWEP:ViewModelDrawn()

end

function SWEP:DrawHUDTargetSelection()
	local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
	if ( !selectedForcePower ) then return end

	local isTarget = selectedForcePower.target
	local dist = selectedForcePower.distance
	if ( isTarget ) then
		for id, ent in pairs( self:SelectTargets( isTarget, dist ) ) do
			if ( !IsValid( ent ) ) then continue end
			local maxs = ent:OBBMaxs()
			local p = ent:GetPos()
			p.z = p.z + maxs.z

			local pos = p:ToScreen()
			local x, y = pos.x, pos.y
			local size = 16

			surface.SetDrawColor( 255, 0, 0, 255 )
			draw.NoTexture()
			surface.DrawPoly( {
				{ x = x - size, y = y - size },
				{ x = x + size, y = y - size },
				{ x = x, y = y }
			} )
		end
	end
end

SWEP.Vars.ForceBar = 100
SWEP.Vars.StaminaBar = 100
SWEP.Vars.DevBar = 0

function SWEP:DrawHUD()
	if ( !IsValid( self.Owner ) or self.Owner:GetViewEntity() != self.Owner or self.Owner:InVehicle() ) then return end
	
	wOS.ALCS.LightsaberBase:HandleHUD( self )
	self:TargetThoughts()
	//self:DrawHUDTargetSelection()

end

wOS.ALCS.LightsaberBase:AddClientWeapon( SWEP, "wos_adv_single_lightsaber_base" )
wOS.ALCS.LightsaberBase:AddClientWeapon( SWEP, "wos_adv_dual_lightsaber_base" )

--addons/wos-grandmaster-einf/lua/wos/advswl/character/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Combat = wOS.ALCS.Combat or {}

local dir = "wos/advswl/character"
	
include( dir .. "/core/cl_net.lua" )
include( dir .. "/core/cl_menu_library.lua" )

--addons/wos-grandmaster-einf/lua/wos/advswl/prestige/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Prestige = wOS.ALCS.Prestige or {}
wOS.ALCS.Prestige.MapData = wOS.ALCS.Prestige.MapData or {}																
net.Receive( "wOS.ALCS.Prestige.SendPlayerData", function()

	wOS.ALCS.Prestige.Data = net.ReadTable()
	
end )

net.Receive( "wOS.ALCS.Prestige.SendMapData", function()

	wOS.ALCS.Prestige.MapData = net.ReadTable()
	
	for slot, dat in pairs( wOS.ALCS.Prestige.MapData.Paths ) do
		if dat.Icon then
			dat.Icon = wOS.ALCS.Skills:PrecacheIcon( "wos-alcs-prestigemap-" .. slot, dat.Icon )
		end
	end
	
end )
--addons/wos-alcs-darkaspp/lua/wos/advswl/addon-loader/da_mod_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.Lightsaber = wOS.Lightsaber or {}

if SERVER then
	
	AddCSLuaFile( "wos/advswl/dark-ascension-files/loader/loader.lua" )
	
end

include( "wos/advswl/dark-ascension-files/loader/loader.lua" )
--addons/wos-alcs-darkaspp/lua/wos/advswl/dark-ascension-files/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.Lightsaber = wOS.Lightsaber or {}

local string = string
local file = file

if SERVER then	
	
	AddCSLuaFile( "wos/advswl/dark-ascension-files/core/cl_core.lua" )
	
else
	include( "wos/advswl/dark-ascension-files/core/cl_core.lua" )
	
end
--addons/wos-alcs-icefusepp/lua/wos/advswl/icefuse/wos_blink_extension.lua:


--[[-------------------------------------------------------------------

	Lightsaber Blink SWEP Hooks:

		We need this to get the Blink SWEP properly working as a force ability

			Powered by

						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
 _____         _                 _            _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             

----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[

							  

	Lua Developer: King David

	Contact: http://steamcommunity.com/groups/wiltostech

		

-- Copyright 2017, David "King David" Wiltos ]]--



local mat = CreateMaterial("wOS.blinkGlow7", "UnlitGeneric", {

	["$basetexture"] = "particle/particle_glow_05",

	["$basetexturetransform"] = "center .5 .5 scale 1 1 rotate 0 translate 0 0",

	["$additive"] = 1,

	["$translucent"] = 1,

	["$vertexcolor"] = 1,

	["$vertexalpha"] = 1,

	["$ignorez"] = 0

});



local mat2 = CreateMaterial("wOS.blinkBottom", "UnlitGeneric", {

	["$basetexture"] = "particle/particle_glow_05",

	["$basetexturetransform"] = "center .5 .5 scale 1 1 rotate 0 translate 0 0",

	["$additive"] = 1,

	["$translucent"] = 1,

	["$vertexcolor"] = 1,

	["$vertexalpha"] = 1,

	["$ignorez"] = 1

});



local cyan = Color(150, 210, 255);

local globalbotvis, globaltopvis



hook.Add( "PostDrawOpaqueRenderables", "wOS.BlinkCamHook", function()

	if LocalPlayer():GetNW2Float( "wOS.ShowBlink", 0 ) < CurTime() then return end;

			local bFoundEdge = false;



			local hullTrace = util.TraceHull({

				start = LocalPlayer():EyePos(),

				endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 4000,

				filter = LocalPlayer(),

				mins = Vector(-16, -16, 0),

				maxs = Vector(16, 16, 9)

			});



			local groundTrace = util.TraceHull({

				start = hullTrace.HitPos + Vector(0, 0, 1),

				endpos = hullTrace.HitPos - Vector(0, 0, 1000),

				filter = LocalPlayer(),

				mins = Vector(-16, -16, 0),

				maxs = Vector(16, 16, 1)

			});



			local edgeTrace;



			if (hullTrace.Hit and hullTrace.HitNormal.z <= 0) then

				local ledgeForward = Angle(0, hullTrace.HitNormal:Angle().y, 0):Forward();

				edgeTrace = util.TraceEntity({

					start = hullTrace.HitPos - ledgeForward * 33 + Vector(0, 0, 40),

					endpos = hullTrace.HitPos - ledgeForward * 33,

					filter = LocalPlayer()

				}, LocalPlayer());



				if (edgeTrace.Hit and !edgeTrace.AllSolid) then

					local clearTrace = util.TraceHull({

						start = hullTrace.HitPos,

						endpos = hullTrace.HitPos + Vector(0, 0, 35),

						mins = Vector(-16, -16, 0),

						maxs = Vector(16, 16, 1),

						filter = LocalPlayer()

					});



					if (!clearTrace.Hit) then

						groundTrace.HitPos = edgeTrace.HitPos;

						bFoundEdge = true;

					end;

				end;

			end;



			local distToGround = math.abs(hullTrace.HitPos.z - groundTrace.HitPos.z);

			local upDist = vector_up * 1.1;

			local quadPos = groundTrace.HitPos + upDist;



			local quadTrace = util.TraceLine({

				start = EyePos(),

				endpos = quadPos,

				filter = LocalPlayer()

			});



			local bottomVis = util.PixelVisible(quadPos, 3, util.GetPixelVisibleHandle());



			local visAlpha = math.Clamp(255, 0, 255);



			if (visAlpha > 0 and !quadTrace.Hit) then

				render.SetMaterial(mat2);

				render.DrawSprite(quadPos, 150, 150, ColorAlpha(cyan, visAlpha), bottomVis);

			end;



			render.SetMaterial(mat);

			render.DrawQuadEasy(quadPos, vector_up, 150, 150, cyan, 0);

			render.DrawQuadEasy(quadPos + upDist, -vector_up, 150, 150, cyan, 0);



			if (distToGround >= 10 and !bFoundEdge) then

				local mappedAlpha = math.Remap(distToGround, 0, 400, 255, 0);

				local mappedUV = math.max(math.Remap(distToGround - 100, 0, 700, 0.5, 1), 0);

				local midPoint = LerpVector(0.5, hullTrace.HitPos, quadPos);



				render.DrawBeam(hullTrace.HitPos, midPoint, 50, 0.5, mappedUV, ColorAlpha(cyan, math.Clamp(mappedAlpha, 0, 255)));

				render.DrawBeam(midPoint, quadPos, 50, mappedUV, 0.5, ColorAlpha(cyan, math.Clamp(mappedAlpha, 0, 255)));



				local visAlpha = math.Clamp(255, 0, 255);



				if (visAlpha > 0) then

					local newCol = ColorAlpha(cyan, visAlpha);

					render.SetMaterial(mat2);

					render.DrawSprite(hullTrace.HitPos, 100, 100, newCol);

					render.DrawSprite(hullTrace.HitPos, 100, 100, newCol);

				end;



			else

				render.SetMaterial(mat);

				render.DrawBeam(quadPos, groundTrace.HitPos + Vector(0, 0, 300), 50, 0.5, 1, cyan);

			end;

end )


hook.Add( "RenderScreenspaceEffects", "wOS.DisorientForEmerald2", function()
	if LocalPlayer():GetNW2Float( "wOS.DisorientTime", 0 ) < CurTime() then return end
	local compare = LocalPlayer():GetNW2Float( "wOS.DisorientTime", 0 ) - CurTime()
	
	DrawMotionBlur( 1 - 1/7*compare, 1.0, 0.0 )
	
	local ColorModify = {}
	ColorModify[ "$pp_colour_addr" ] 		= 0
	ColorModify[ "$pp_colour_addg" ] 		= 0
	ColorModify[ "$pp_colour_addb" ] 		= 0
	ColorModify[ "$pp_colour_mulr" ] 		= 0
	ColorModify[ "$pp_colour_mulg" ] 		= 0
	ColorModify[ "$pp_colour_mulb" ] 		= 0
	ColorModify[ "$pp_colour_brightness" ] 	= -0.1*compare
	ColorModify[ "$pp_colour_contrast" ] 	= 1 + 1.3*compare
	ColorModify[ "$pp_colour_colour" ] 		= 1 - 0.1*compare
	
	DrawColorModify( ColorModify )
	
end )

hook.Add( "RenderScreenspaceEffects", "wOS.BlindScreenFuck", function()
	if LocalPlayer():GetNW2Float( "wOS.BlindTime", 0 ) < CurTime() then return end
	local compare = ( LocalPlayer():GetNW2Float( "wOS.BlindTime", 0 ) - CurTime() )/15
	
	local ColorModify = {}
	ColorModify[ "$pp_colour_addr" ] 		= 0
	ColorModify[ "$pp_colour_addg" ] 		= 0
	ColorModify[ "$pp_colour_addb" ] 		= 0
	ColorModify[ "$pp_colour_mulr" ] 		= 0
	ColorModify[ "$pp_colour_mulg" ] 		= 0
	ColorModify[ "$pp_colour_mulb" ] 		= 0	
	ColorModify[ "$pp_colour_brightness" ] 	= -1.2*compare
	ColorModify[ "$pp_colour_contrast" ] 	= 1 + 1.3*compare
	ColorModify[ "$pp_colour_colour" ] 		= 1 - 1*compare
	
	DrawColorModify( ColorModify )
	
end )
--addons/xeon-drm-dll/lua/autorun/client/xeon-drm-auth.lua:
local domain = CreateConVar("xeon_dev", 0, bit.bor(FCVAR_REPLICATED, FCVAR_UNREGISTERED, FCVAR_UNLOGGED, FCVAR_DONTRECORD), nil, 0, 1):GetInt() == 1 and "http://gmod.sneed" or "https://xeon.network"

local XEON_AUTH
net.Receive("XEON.Auth", function(len)
	if net.ReadBool() then
		if IsValid(XEON_AUTH) then
			XEON_AUTH:Linked()
		end
		return
	end

	net.Start("XEON.Auth")
	net.SendToServer()

	if IsValid(XEON_AUTH) then return end

	XEON_AUTH = vgui.Create("DFrame")
	XEON_AUTH:SetSize(ScrW() * .8, ScrH() * .8)
	XEON_AUTH:SetTitle("XEON DRM by Billy - Server Linking")
	XEON_AUTH:Center()
	XEON_AUTH:MakePopup()
	XEON_AUTH:SetRenderInScreenshots(false)

	local html = vgui.Create("DHTML", XEON_AUTH)
	html:Dock(FILL)
	html:OpenURL(domain .. "/link/" .. (LocalPlayer():IsSuperAdmin() and "1" or "0"))
	html:AddFunction("XEON", "Auth", function(token_bytes)
		local token_bytes = string.Explode(", ", token_bytes:sub(2, -2), false)
		local token = {}
		for i = 1, 32 do
			token[i] = string.char(token_bytes[i])
		end
		token = table.concat(token)

		net.Start("XEON.Auth")
			net.WriteData(token, 32)
		net.SendToServer()
	end)
	html:AddFunction("XEON", "ReloadMap", function()
		net.Start("XEON.ReloadMap")
		net.SendToServer()

		if IsValid(XEON_AUTH) then
			XEON_AUTH:Close()
			XEON_AUTH = nil
		end
	end)
	local RunJS = html.RunJavascript
	function XEON_AUTH:Linked()
		RunJS(html, "LINKED()")
	end
	html.QueueJavascript = nil
	html.RunJavascript = nil
end)

local function openErrors(errors)
	if IsValid(XEON_ERRORS) then
		XEON_ERRORS:Update(errors)
		return
	end

	XEON_ERRORS = vgui.Create("DFrame")
	XEON_ERRORS:SetSize(ScrW() * .8, ScrH() * .8)
	XEON_ERRORS:SetTitle("XEON DRM by Billy - Error!")
	XEON_ERRORS:Center()
	XEON_ERRORS:MakePopup()

	local html = vgui.Create("DHTML", XEON_ERRORS)
	html:Dock(FILL)
	html:OpenURL(domain .. "/errors")
	html:AddFunction("XEON", "ScriptSupport", function()
		gui.OpenURL("https://support.billy.enterprises")
	end)

	function XEON_ERRORS:Update(errors)
		print("XEON Errors: " .. #errors)
		PrintTable(errors)

		html:QueueJavascript("ShowNetworkedErrors(" .. util.TableToJSON(errors) .. ")")
	end
	function html:OnDocumentReady()
		XEON_ERRORS:Update(errors)
		self.OnDocumentReady = nil
	end
	XEON_ERRORS:Update(errors)

	sound.PlayURL("https://xeon.network/static/media/oof.mp3", "", function() end)
end

net.Receive("XEON.Error", function()
	local errors = {}
	for i = 1, net.ReadUInt(16) do
		errors[i] = net.ReadString()
	end
	openErrors(errors)
end)

hook.Add("InitPostEntity", "XEON.Error", function()
	timer.Simple(2, function()
		net.Start("XEON.Error")
		net.SendToServer()
	end)
end)
--lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--addons/bkeypads_cracker/lua/weapons/bkeypads_cracker/cl_init.lua:
include("shared.lua")

function SWEP:SetFace(face)
	self.Face = bKeypads.Emotes[face]
end

function SWEP:SetScreenText(text)
	self.ScreenText = text
end

function SWEP:Emote(face, time, text)
	self.EmoteFace = bKeypads.Emotes[face]
	self.EmoteEnd = CurTime() + time
	self.EmoteText = text
end

local scale_3d2d = 0.005

local viewScreenPos = Vector(2.33, -1.7, 3.65)
local viewScreenW, viewScreenH = 810, 400

local worldScreenPos = Vector(-9.29, -3.75, 1.5)
local worldScreenW, worldScreenH = 670, 280

local faceSize = .6
local textSpacing = 24
local fontOffsetX = 9

function SWEP:DrawScreen(pos, ang, w, h, world)
	local isEmoting = self.EmoteEnd and CurTime() <= self.EmoteEnd
	
	local isMainView = render.GetRenderTarget() == nil

	cam.Start3D2D(pos, ang, scale_3d2d)
		if isMainView then bKeypads:TVAnimation(self, 0.15, w, h) end

		if self.m_iPlantingStage == self.PLANT.CRACKING then
			self:DrawCrackingScreen(w, h)
		else
			if self.m_fErrorScreenEnd and CurTime() < self.m_fErrorScreenEnd then
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_RED)
			elseif self.m_fSuccessScreenEnd and CurTime() < self.m_fSuccessScreenEnd then
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_GREEN)
			else
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_BLUE)
			end
			surface.SetDrawColor(255, 255, 255)
			surface.DrawTexturedRect(0, 0, w, h)

			if self:GetCracking() or self.m_bCanCrack then
				self:DrawMatrix(w, h)
			end

			local ScreenText = isEmoting and self.EmoteText or self.ScreenText
		
			surface.SetFont("bKeypads.Cracker" .. (world and ".Small" or ""))
			surface.SetTextColor(bKeypads.COLOR.SLATE)
			local txtW, txtH = surface.GetTextSize(ScreenText)
			txtW = txtW - fontOffsetX

			local faceSize = h * faceSize
			local contentSize = faceSize + textSpacing + txtH
			local y = (h - contentSize) / 2

			surface.SetDrawColor(bKeypads.COLOR.SLATE)
			surface.SetMaterial(isEmoting and self.EmoteFace or self.Face)
			surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)

			if bKeypads.Cracker.Config.SpecialSunglasses and self:GetSpecialCrackTime() then
				surface.SetMaterial(bKeypads.Sunglasses)
				surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)
			end

			surface.SetTextPos((w - txtW) / 2, y + faceSize + textSpacing)
			surface.DrawText(ScreenText)
		end

		if isMainView then bKeypads:TVAnimation(self) end
	cam.End3D2D()
end

function SWEP:DrawCrackingScreen(w, h)
	if not self.m_fNextCrackingFace or CurTime() > self.m_fNextCrackingFace then
		self.m_fNextCrackingFace = CurTime() + math.Rand(0.5, 1)
		while true do
			local newFace = bKeypads.Emotes[bKeypads.Cracker.CrackingEmotes[math.random(1, #bKeypads.Cracker.CrackingEmotes)]]
			if #bKeypads.Emotes <= 1 or self.CrackingFace ~= newFace then
				self.CrackingFace = newFace
				break
			end
		end
	end

	self.m_fCrackStart = self.m_fCrackStart or CurTime()
	local crackProgress = bKeypads.ease.InOutSine(math.Clamp(math.TimeFraction(self.m_fCrackStart, self:GetCrackCompleteTime(), CurTime()), 0, 1))

	surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_RED)
	surface.SetDrawColor(255, 255, 255)
	surface.DrawTexturedRect(0, 0, w, h)

	surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_GREEN)
	surface.SetDrawColor(255, 255, 255, crackProgress * 255)
	surface.DrawTexturedRect(0, 0, w, h)

	self:DrawMatrix(w, h)

	surface.SetFont("bKeypads.Cracker" .. (world and ".Small" or ""))
	local txtW, txtH = surface.GetTextSize("CRACKING")
	txtW = txtW - fontOffsetX

	local faceSize = h * faceSize
	local contentSize = faceSize + textSpacing + txtH
	local y = (h - contentSize) / 2

	surface.SetDrawColor(bKeypads.COLOR.SLATE)
	surface.SetMaterial(self.CrackingFace or bKeypads.Emotes["default"])
	surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)

	if bKeypads.Cracker.Config.SpecialSunglasses and self:GetSpecialCrackTime() then
		surface.SetMaterial(bKeypads.Sunglasses)
		surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)
	end

	local paddingW = 175
	local x, y = paddingW / 2, y + faceSize + textSpacing
	local fullProgressW = w - paddingW
	local progressW = fullProgressW * crackProgress
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawRect(x + progressW, y, fullProgressW - progressW, txtH)

	surface.SetDrawColor((1 - crackProgress) * 255, crackProgress * 255, 0, 100)
	surface.DrawRect(x, y, progressW, txtH)
end

function SWEP:PostDrawViewModel(vm)
	if not self.m_bDeployed or not IsValid(vm) then return end

	local bone = vm:LookupBone("v_weapon.c4")
	if not bone then return end

	local pos, ang = vm:GetBonePosition(bone)
	if not pos then return end
	
	ang:RotateAroundAxis(ang:Right(), 180)
	ang:RotateAroundAxis(ang:Forward(), -90)

	pos:Add(ang:Forward() * viewScreenPos.x)
	pos:Add(ang:Right() * viewScreenPos.y)
	pos:Add(ang:Up() * viewScreenPos.z)

	self:DrawScreen(pos, ang, viewScreenW, viewScreenH)
end

function SWEP:PreDrawViewModel(vm)
	if not self.m_bDeployed or not IsValid(vm) or self.m_iPlantingStage ~= self.PLANT.CRACKING or not IsValid(self:GetCrackingKeypad()) then return end

	local bone = vm:LookupBone("v_weapon.c4")
	if not bone then return end

	local pos, ang = vm:GetBonePosition(bone)
	if not pos then return end

	pos:Add(ang:Forward() * -viewScreenPos.x)
	pos:Add(ang:Right() * -viewScreenPos.y)
	pos:Add(ang:Up() * -viewScreenPos.z)

	self:DrawCable(pos, true)
end

do
	local forward = Vector(worldScreenPos.x, worldScreenPos.x, worldScreenPos.x)
	local right = Vector(worldScreenPos.y, worldScreenPos.y, worldScreenPos.y)
	local up = Vector(worldScreenPos.z, worldScreenPos.z, worldScreenPos.z)
	function SWEP:DrawWorldModel(flags)
		self:DrawModel(flags)

		if not IsValid(self:GetOwner()) or bKeypads.Performance:Optimizing() then return end

		local bone = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Hand")
		if not bone then return end

		local pos, ang = self:GetOwner():GetBonePosition(bone)
		if not pos or not ang then return end

		ang:RotateAroundAxis(ang:Up(), -248)
		ang:RotateAroundAxis(ang:Right(), -10)
		ang:RotateAroundAxis(ang:Forward(), -120)

		pos:Add(ang:Up() * up)
		pos:Add(ang:Right() * right)
		pos:Add(ang:Forward() * forward)

		self:DrawCable(pos)
		self:DrawScreen(pos, ang, worldScreenW, worldScreenH, true)
	end
end

do
	local matCable = Material("cable/cable2")
	function SWEP:DrawCable(origin, vm)
		if self.m_iPlantingStage ~= self.PLANT.CRACKING then return end

		local keypad = self:GetCrackingKeypad()
		if not IsValid(keypad) then return end

		if bKeypads.Performance:Optimizing() then return end

		local pos = keypad:OBBCenter()
		pos.z = pos.z - keypad:OBBMaxs().z

		local seg1 = origin
		local seg4 = keypad:LocalToWorld(pos)

		local seg2
		local seg3

		local cableDir = seg1 - seg4
		local cableLength = cableDir:Length()
		local cableAngle = cableDir:Angle():Forward()
		
		for i = 1, 2 do
			local cableFrac = i * (1 / 3)
			local cablePoint = origin - (cableAngle * cableLength * cableFrac)
			cablePoint.z = cablePoint.z - (math.abs(cablePoint.z - seg4.z) * cableFrac)
			if i == 1 then
				seg2 = cablePoint
			else
				seg3 = cablePoint
			end
		end

		render.SetMaterial(matCable)
		render.StartBeam(4)
			if vm then
				render.AddBeam(bKeypads:TranslateViewModelPosition(self.ViewModelFOV or 62, seg1), 0.5, 0, color_white)
				render.AddBeam(bKeypads:TranslateViewModelPosition(self.ViewModelFOV or 62, seg2), 0.5, 0, color_white)
				render.AddBeam(bKeypads:TranslateViewModelPosition(self.ViewModelFOV or 62, seg3), 0.5, 0, color_white)
				render.AddBeam(bKeypads:TranslateViewModelPosition(self.ViewModelFOV or 62, seg4), 0.5, 0, color_white)
			else
				render.AddBeam(seg1, 0.5, 0, color_white)
				render.AddBeam(seg2, 0.5, 0, color_white)
				render.AddBeam(seg3, 0.5, 0, color_white)
				render.AddBeam(seg4, 0.5, 0, color_white)
			end
		render.EndBeam()

		if vm then render.ClearDepth() end
	end
end

function SWEP:ClientThink()
	if self.m_bPlayHello then
		self:PlaySound("hello", .25)
		self.m_bPlayHello = nil

		self.m_bDeployed = true
	end

	if self.m_iPlantingStage > self.PLANT.IDLE then
		if bKeypads.Cracker.Config.Deployed and not self.m_CrackingText then
			self.m_CrackingText = bKeypads.Cracker:GetCrackingPhrase()
			self:SetFace("happy")
			self:SetScreenText(self.m_CrackingText)
		end
	elseif self.m_iPlantingStage ~= self.PLANT.CRACKING and (not self.m_fSuccessScreenEnd or CurTime() > self.m_fSuccessScreenEnd) then
		self.m_CrackingText = nil

		if self.m_bIsKeypad then
			if not self.m_bIsWithinDist then
				self:SetFace("confused")
				self:SetScreenText(bKeypads.L"CrackerTooFar")
				self:PlaySound("alarm", .25)
			elseif not self.m_bIsLinked then
				self:SetFace("confused")
				self:SetScreenText(bKeypads.L"CrackerNotLinked")
				self:PlaySound("alarm", .25)
			elseif self.m_bCanCrack then
				self:SetFace("evil")
				self:SetScreenText(bKeypads.L"CrackerReady")
				self:PlaySound("success", .25)
			else
				self:SetFace("neutral")
				self:SetScreenText(bKeypads.L"CrackerCantCrack")
				self:PlaySound("warning", .25)
			end
		else
			self:SetFace("default")
			self:SetScreenText(bKeypads.L"CrackerWaiting")
			self.m_sPlayedSound = nil
		end
	end
end

function SWEP:CantCrack()
	self:EmitSound(bKeypads.Cracker.Sounds["alarm"].path, 75, 100, .25, CHAN_WEAPON)
	self.m_fErrorScreenEnd = CurTime() + .165
end

function SWEP:OnCrackTimeDataReceived(_, __, completeTime)
	self.m_iPlantingStage = self.PLANT.CRACKING
	self.m_iPlantingNextStage = math.huge
end
function SWEP:OnCrackingKeypadSet(_, __, crackingKeypad)
	if IsValid(crackingKeypad) then
		self.m_bCrackingKeypadSet = true
	else
		self.m_bCrackingKeypadSet = nil
	end
end

if IsValid(bKeypads_CrackerMatrix) then bKeypads_CrackerMatrix:Remove() end
function SWEP:DrawMatrix(w, h)
	if render.GetRenderTarget() ~= nil or bKeypads.Performance:Optimizing() then return end
	if not IsValid(bKeypads_CrackerMatrix) then
		bKeypads_CrackerMatrix = vgui.Create("bKeypads.Matrix")
		bKeypads_CrackerMatrix:SetMatrixID("Cracker")
		bKeypads_CrackerMatrix:SetRainSize(20)
		bKeypads_CrackerMatrix:SetPaintedManually(true)
	end
	bKeypads_CrackerMatrix:SetSize(w, h)
	bKeypads_CrackerMatrix:PaintAt(0, 0)
end

--lua/weapons/gmod_tool/stools/advdupe2.lua:
--[[
	Title: Adv. Dupe 2 Tool

	Desc: Defines the AD2 tool and assorted functionalities.

	Author: TB

	Version: 1.0
]]

TOOL.Category = "Construction"
TOOL.Name = "#Tool.advdupe2.name"
cleanup.Register( "AdvDupe2" )
require( "controlpanel" )

if(SERVER) then
	CreateConVar("sbox_maxgmod_contr_spawners",5)

	local phys_constraint_system_types = {
		Weld          = true,
		Rope          = true,
		Elastic       = true,
		Slider        = true,
		Axis          = true,
		AdvBallsocket = true,
		Motor         = true,
		Pulley        = true,
		Ballsocket    = true,
		Winch         = true,
		Hydraulic     = true,
		WireMotor     = true,
		WireHydraulic = true
	}
	--Orders constraints so that the dupe uses as little constraint systems as possible
	local function GroupConstraintOrder( ply, constraints )
		--First separate the nocollides, sorted, and unsorted constraints
		local sorted, unsorted = {}, {}
		for k, v in pairs(constraints) do
			if phys_constraint_system_types[v.Type] then
				sorted[#sorted+1] = v
			else
				unsorted[#unsorted+1] = v
			end
		end

		local sortingSystems = {}
		local fullSystems = {}
		local function buildSystems(input)
			while next(input) ~= nil do
				for k, v in pairs(input) do
					for systemi, system in pairs(sortingSystems) do
						for _, target in pairs(system) do
							for x = 1, 4 do
								if v.Entity[x] then
									for y = 1, 4 do
										if target.Entity[y] and v.Entity[x].Index == target.Entity[y].Index then
											system[#system + 1] = v
											if #system == 100 then
												fullSystems[#fullSystems + 1] = system
												table.remove(sortingSystems, systemi)
											end
											input[k] = nil
											goto super_loopbreak
										end
									end
								end
							end
						end
					end
				end

				--Normally skipped by the goto unless no cluster is found. If so, make a new one.
				local k = next(input)
				sortingSystems[#sortingSystems + 1] = {input[k]}
				input[k] = nil

				::super_loopbreak::
			end
		end
		buildSystems(sorted)

		local ret = {}
		for _, system in pairs(fullSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for _, system in pairs(sortingSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for k, v in pairs(unsorted) do
			ret[#ret + 1] = v
		end

		if #fullSystems ~= 0 then
			ply:ChatPrint("DUPLICATOR: WARNING, Number of constraints exceeds 100: (".. #ret .."). Constraint sorting might not work as expected.")
		end

		return ret
	end

	local function CreationConstraintOrder( constraints )
		local ret = {}
		for k, v in pairs( constraints ) do
			ret[#ret + 1] = k
		end
		table.sort(ret)
		for i = 1, #ret do
			ret[i] = constraints[ret[i]]
		end
		return ret
	end

	local function GetSortedConstraints( ply, constraints )
		if ply:GetInfo("advdupe2_sort_constraints") ~= "0" then
			return GroupConstraintOrder( ply, constraints )
		else
			return CreationConstraintOrder( constraints )
		end
	end

	local areacopy_classblacklist = {
		gmod_anchor = true
	}

	local function PlayerCanDupeCPPI(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end
		return ent:CPPIGetOwner()==ply
	end

	-- Code from WireLib.CanTool
	local zero = Vector(0, 0, 0)
	local norm = Vector(1, 0, 0)

	local tr = { ---@type TraceResult
		Hit = true, HitNonWorld = true, HitNoDraw = false, HitSky = false, AllSolid = true,
		HitNormal = zero, Normal = norm,

		Fraction = 1, FractionLeftSolid = 0,
		HitBox = 0, HitGroup = 0, HitTexture = "**studio**",
		MatType = 0, PhysicsBone = 0, SurfaceProps = 0, DispFlags = 0, Contents = 0,

		Entity = NULL, HitPos = zero, StartPos = zero,
	}

	local function PlayerCanDupeTool(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end

		local pos = ent:GetPos()
		tr.Entity, tr.HitPos, tr.StartPos = ent, pos, pos

		return hook.Run( "CanTool", ply, tr, "advdupe2" ) ~= false
	end

	--Find all the entities in a box, given the adjacent corners and the player
	local function FindInBox(min, max, ply)
		local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and ply.CPPIGetOwner~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
		local EntTable = {}
		for _, ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and
				 (pos.Y>=min.Y) and (pos.Y<=max.Y) and
				 (pos.Z>=min.Z) and (pos.Z<=max.Z) and PPCheck( ply, ent ) then
				EntTable[ent:EntIndex()] = ent
			end
		end

		return EntTable
	end

	--[[
		Name: GetDupeAngleOffset
		Desc: Retrieves duplication angle offsets from player
		Returns: <angle> Created angle
	]]
	local function GetDupeAngleOffset(ply)
		local p = math.Clamp(ply:GetInfoNum("advdupe2_offset_pitch", 0), -180, 180)
		local y = math.Clamp(ply:GetInfoNum("advdupe2_offset_yaw"  , 0), -180, 180)
		local r = math.Clamp(ply:GetInfoNum("advdupe2_offset_roll" , 0), -180, 180)
		return Angle(p, y, r)
	end

	--[[
		Name: GetDupeElevation
		Desc: Retrieves duplication Z elevation
		Returns: <number> Dupe elevation
	]]
	local function GetDupeElevation(ply)
		local con = ply:GetInfoNum("advdupe2_offset_z", 0)
		local enz = (tonumber(ply.AdvDupe2.HeadEnt.Z) or 0)
		return math.Clamp(con + enz, -32000, 32000)
	end

	--[[
		Name: LeftClick
		Desc: Defines the tool's behavior when the player left-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:LeftClick( trace )
		if(not trace) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not (dupe and dupe.Entities) then return false end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.",NOTIFY_ERROR)
			return false
		end

		dupe.Angle = GetDupeAngleOffset(ply)
		dupe.Position = Vector(trace.HitPos)
		dupe.Position.z = dupe.Position.z + GetDupeElevation(ply)

		if(tobool(ply:GetInfo("advdupe2_offset_world"))) then
			dupe.Angle = dupe.Angle - dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Angle
		end

		dupe.Pasting = true
		AdvDupe2.Notify(ply,"Pasting...")
		local origin
		if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
			origin = dupe.HeadEnt.Pos
		end

		AdvDupe2.InitPastingQueue(ply, dupe.Position, dupe.Angle, origin,
			tobool(ply:GetInfo("advdupe2_paste_constraints")),
			tobool(ply:GetInfo("advdupe2_paste_parents")),
			tobool(ply:GetInfo("advdupe2_paste_disparents")),
			tobool(ply:GetInfo("advdupe2_paste_protectoveride")))

		return true
	end

	--[[
		Name: RightClick
		Desc: Defines the tool's behavior when the player right-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:RightClick( trace )
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.", NOTIFY_ERROR)
			return false
		end

		--Set Area Copy on or off
		if( ply:KeyDown(IN_SPEED) and not ply:KeyDown(IN_WALK) ) then
			if(self:GetStage()==0) then
				AdvDupe2.DrawSelectBox(ply)
				self:SetStage(1)
				return false
			elseif(self:GetStage()==1) then
				AdvDupe2.RemoveSelectBox(ply)
				self:SetStage(0)
				return false
			end
		end

		if(not trace or not trace.Hit) then return false end

		local Entities, Constraints, AddOne
		local HeadEnt = {}
		--If area copy is on
		if(self:GetStage()==1) then
			local area_size = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			local Pos = trace.HitNonWorld and trace.Entity:GetPos() or trace.HitPos
			local T = (Vector(area_size,area_size,area_size)+Pos)
			local B = (Vector(-area_size,-area_size,-area_size)+Pos)

			local Ents = FindInBox(B,T, ply)
			local _, Ent = next(Ents)
			if not Ent then
				self:SetStage(0)
				AdvDupe2.RemoveSelectBox(ply)
				return true
			end

			Ent = trace.HitNonWorld and trace.Entity or Ent
			HeadEnt.Index = Ent:EntIndex()
			HeadEnt.Pos = Ent:GetPos()

			Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Ents, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))

			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
		elseif trace.HitNonWorld then	--Area Copy is off
			-- Filter duplicator blocked entities out.
			if not AdvDupe2.duplicator.IsCopyable( trace.Entity ) then
				return false
			end

			--If Alt is being held, add a prop to the dupe
			if(ply:KeyDown(IN_WALK) and dupe.Entities~=nil and next(dupe.Entities)~=nil) then
				Entities = dupe.Entities
				Constraints = dupe.Constraints
				HeadEnt = dupe.HeadEnt

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, HeadEnt.Pos)

				--Only add the one ghost
				AddOne = Entities[trace.Entity:EntIndex()]
			else
				Entities = {}
				Constraints = {}
				HeadEnt.Index = trace.Entity:EntIndex()
				HeadEnt.Pos = trace.HitPos

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, trace.HitPos )
			end
		else --Non valid entity or clicked the world
			if dupe.Entities then
				--clear the dupe
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
				dupe.Entities = nil
				dupe.Constraints = nil
				net.Start("AdvDupe2_ResetDupeInfo")
				net.Send(ply)
				AdvDupe2.ResetOffsets(ply)
				return true
			else
				--select all owned props
				Entities = {}
				local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and CPPI~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
				for _, ent in ents.Iterator() do
					if PPCheck( ply, ent ) then
						Entities[ent:EntIndex()] = ent
					end
				end

				local _, Ent = next(Entities)
				if not Ent then
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
					return true
				end

				HeadEnt.Index = Ent:EntIndex()
				HeadEnt.Pos = Ent:GetPos()

				Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))
			end
		end

		if not HeadEnt.Z then
			local WorldTrace = util.TraceLine({
				mask   = MASK_NPCWORLDSTATIC,
				start  = HeadEnt.Pos + Vector(0,0,1),
				endpos = HeadEnt.Pos-Vector(0,0,50000)
			})

			HeadEnt.Z = WorldTrace.Hit and math.abs(HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		end

		dupe.HeadEnt = HeadEnt
		dupe.Entities = Entities
		dupe.Constraints = GetSortedConstraints(ply, Constraints)
		dupe.Revision = AdvDupe2.CodecRevision

		net.Start("AdvDupe2_SetDupeInfo")
			net.WriteString("")
			net.WriteString(ply:Nick())
			net.WriteString(os.date("%d %B %Y"))
			net.WriteString(os.date("%I:%M %p"))
			net.WriteString("")
			net.WriteString("")
			net.WriteString(table.Count(dupe.Entities))
			net.WriteString(#dupe.Constraints)
		net.Send(ply)

		if AddOne then
			AdvDupe2.SendGhost(ply, AddOne)
		else
			AdvDupe2.SendGhosts(ply)
		end

		AdvDupe2.ResetOffsets(ply)

		return true
	end

	--Checks table, re-draws loading bar, and recreates ghosts when tool is pulled out
	function TOOL:Deploy()
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(not dupe.Entities) then return end

		net.Start("AdvDupe2_StartGhosting")
		net.Send(ply)

		if(dupe.Queued) then
			AdvDupe2.InitProgressBar(ply, "Queued: ")
			return
		end

		if(dupe.Pasting) then
			AdvDupe2.InitProgressBar(ply, "Pasting: ")
			return
		else
			if(dupe.Uploading) then
				AdvDupe2.InitProgressBar(ply, "Opening: ")
				return
			elseif(dupe.Downloading) then
				AdvDupe2.InitProgressBar(ply, "Saving: ")
				return
			end
		end

	end

	--Removes progress bar
	function TOOL:Holster()
		AdvDupe2.RemoveProgressBar(self:GetOwner())
	end

	--[[
		Name: Reload
		Desc: Creates an Advance Contraption Spawner.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:Reload( trace )
		if(not trace.Hit) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(self:GetStage()==1) then
			local areasize = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteVector(trace.HitPos)
				net.WriteFloat(areasize)
				if(trace.Entity) then
					net.WriteUInt(trace.Entity:EntIndex(), 16)
				else
					net.WriteUInt(0, 16)
				end
			net.Send(ply)
			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
			dupe.TempAutoSavePos = trace.HitPos
			dupe.TempAutoSaveSize = areasize
			dupe.TempAutoSaveOutSide = tobool(ply:GetInfo("advdupe2_copy_outside"))
			return true
		end

		--If a contraption spawner was clicked then update it with the current settings
		if(trace.Entity:GetClass()=="gmod_contr_spawner") then
			local delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_delay"))
			local undo_delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay"))
			local min
			local max
			if(not delay) then
				delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
					if (delay < min) then
						delay = min
					end
				elseif(delay<0) then
					delay = 0
				end
			end

			if(not undo_delay) then
				undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
					max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
					if(undo_delay < min) then
						undo_delay = min
					elseif(undo_delay > max) then
						undo_delay = max
					end
				elseif(undo_delay < 0) then
					undo_delay = 0
				end
			end

			trace.Entity:GetTable():SetOptions(
				ply, delay, undo_delay,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1 )

			return true
		end

		--Create a contraption spawner
		if dupe and dupe.Entities then
			local headent = dupe.Entities[dupe.HeadEnt.Index]
			local Pos, Ang

			if(headent) then
				if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
					Pos = dupe.HeadEnt.Pos + headent.PhysicsObjects[0].Pos
					Ang = headent.PhysicsObjects[0].Angle
				else
					local EntAngle = headent.PhysicsObjects[0].Angle
					if(tobool(ply:GetInfo("advdupe2_offset_world"))) then EntAngle = Angle(0,0,0) end
					trace.HitPos.Z = trace.HitPos.Z + GetDupeElevation(ply)
					Pos, Ang = LocalToWorld(headent.PhysicsObjects[0].Pos, EntAngle, trace.HitPos, GetDupeAngleOffset(ply))
				end
			else
				AdvDupe2.Notify(ply, "Invalid head entity to spawn contraption spawner.")
				return false
			end

			if(headent.Class=="gmod_contr_spawner") then
				AdvDupe2.Notify(ply, "Cannot make a contraption spawner from a contraption spawner.")
				return false
			end


			local spawner = MakeContraptionSpawner(
				ply, Pos, Ang, dupe.HeadEnt.Index,
				table.Copy(dupe.Entities),
				table.Copy(dupe.Constraints),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_delay")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay")), headent.Model,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_hideprops")) or 0)

			ply:AddCleanup( "AdvDupe2", spawner )
			undo.Create("gmod_contr_spawner")
				undo.AddEntity( spawner )
				undo.SetPlayer( ply )
			undo.Finish()

			return true
		end
	end

	--Called to clean up the tool when pasting is finished or undo during pasting
	function AdvDupe2.FinishPasting(Player, Paste)
		Player.AdvDupe2.Pasting=false
		AdvDupe2.RemoveProgressBar(Player)
		if(Paste) then AdvDupe2.Notify(Player,"Finished Pasting!") end
	end

	--function for creating a contraption spawner
	function MakeContraptionSpawner( ply, Pos, Ang, HeadEnt, EntityTable, ConstraintTable, delay, undo_delay, model, key, undo_key, disgrav, disdrag, addvel, hideprops)

		if not ply:CheckLimit("gmod_contr_spawners") then return nil end

		if(not game.SinglePlayer()) then
			if(table.Count(EntityTable)>tonumber(GetConVarString("AdvDupe2_MaxContraptionEntities"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionEntities").." entities for a spawner!",NOTIFY_ERROR)
				return false
			end
			if(#ConstraintTable>tonumber(GetConVarString("AdvDupe2_MaxContraptionConstraints"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionConstraints").." constraints for a spawner!",NOTIFY_ERROR)
				return false
			end
		end

		local spawner = ents.Create("gmod_contr_spawner")
		if not IsValid(spawner) then return end

		spawner:SetPos(Pos)
		spawner:SetAngles(Ang)
		spawner:SetModel(model)
		spawner:SetRenderMode(RENDERMODE_TRANSALPHA)
		spawner:SetCreator(ply)
		spawner:Spawn()

		duplicator.ApplyEntityModifiers(ply, spawner)

		if IsValid(spawner:GetPhysicsObject()) then
			spawner:GetPhysicsObject():EnableMotion(false)
		end

		local min
		local max
		if(not delay) then
			delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
				if (delay < min) then
					delay = min
				end
			elseif(delay<0) then
				delay = 0
			end
		end

		if(not undo_delay) then
			undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
				max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
				if(undo_delay < min) then
					undo_delay = min
				elseif(undo_delay > max) then
					undo_delay = max
				end
			elseif(undo_delay < 0) then
				undo_delay = 0
			end
		end

		-- Set options
		spawner:SetPlayer(ply)
		spawner:GetTable():SetOptions(ply, delay, undo_delay, key, undo_key, disgrav, disdrag, addvel, hideprops)

		local tbl = {
			ply        = ply,
			delay      = delay,
			undo_delay = undo_delay,
			disgrav    = disgrav,
			disdrag    = disdrag,
			addvel     = addvel,
			hideprops  = hideprops
		}
		table.Merge(spawner:GetTable(), tbl)
		spawner:SetDupeInfo(HeadEnt, EntityTable, ConstraintTable)
		spawner:AddGhosts(ply)

		ply:AddCount("gmod_contr_spawners", spawner)
		ply:AddCleanup("gmod_contr_spawner", spawner)
		return spawner
	end

	duplicator.RegisterEntityClass("gmod_contr_spawner", MakeContraptionSpawner,
		"Pos", "Ang", "HeadEnt", "EntityTable", "ConstraintTable", "delay",
		"undo_delay", "model", "key", "undo_key", "disgrav", "disdrag", "addvel", "hideprops")

	function AdvDupe2.InitProgressBar(ply,label)
		net.Start("AdvDupe2_InitProgressBar")
			net.WriteString(label)
		net.Send(ply)
	end

	function AdvDupe2.DrawSelectBox(ply)
		net.Start("AdvDupe2_DrawSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.RemoveSelectBox(ply)
		net.Start("AdvDupe2_RemoveSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.UpdateProgressBar(ply,percent)
		net.Start("AdvDupe2_UpdateProgressBar")
			net.WriteFloat(percent)
		net.Send(ply)
	end

	function AdvDupe2.RemoveProgressBar(ply)
		net.Start("AdvDupe2_RemoveProgressBar")
		net.Send(ply)
	end

	--Reset the offsets of height, pitch, yaw, and roll back to default
	function AdvDupe2.ResetOffsets(ply, keep)

		if(not keep) then
			ply.AdvDupe2.Name = nil
		end
		net.Start("AdvDupe2_ResetOffsets")
		net.Send(ply)
	end

	net.Receive("AdvDupe2_CanAutoSave", function(len, ply, len2)

		local desc = net.ReadString()
		local ent = net.ReadInt(16)
		local dupe = ply.AdvDupe2

		if(ent~=0) then
			dupe.AutoSaveEnt = ent
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				dupe.AutoSaveEnt = ents.GetByIndex( dupe.AutoSaveEnt )
			end
		else
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				AdvDupe2.Notify(ply, "No entity selected to auto save contraption.", NOTIFY_ERROR)
				return
			end
			dupe.AutoSaveEnt = nil
		end

		dupe.AutoSavePos = dupe.TempAutoSavePos
		dupe.AutoSaveSize = dupe.TempAutoSaveSize
		dupe.AutoSaveOutSide = dupe.TempAutoSaveOutSide
		dupe.AutoSaveContr = ply:GetInfo("advdupe2_auto_save_contraption")=="1"
		dupe.AutoSaveDesc = desc

		local time = math.Clamp(tonumber(ply:GetInfo("advdupe2_auto_save_time")) or 2, 2, 30)
		if(game.SinglePlayer()) then
			dupe.AutoSavePath = net.ReadString()
		end

		AdvDupe2.Notify(ply, "Your area will be auto saved every "..(time*60).." seconds.")
		local name = "AdvDupe2_AutoSave_"..ply:UniqueID()
		if(timer.Exists(name)) then
			timer.Adjust(name, time*60, 0)
			return
		end
		timer.Create(name, time*60, 0, function()
			if(not IsValid(ply)) then
				timer.Remove(name)
				return
			end

			local dupe = ply.AdvDupe2
			if(dupe.Downloading) then
				AdvDupe2.Notify(ply, "Skipping auto save, tool is busy.", NOTIFY_ERROR)
				return
			end

			local Tab = {Entities={}, Constraints={}, HeadEnt={}}

			if(dupe.AutoSaveContr) then
				if(not IsValid(dupe.AutoSaveEnt)) then
					timer.Remove(name)
					AdvDupe2.Notify(ply, "Head entity for auto save no longer valid; stopping auto save.", NOTIFY_ERROR)
					return
				end

				Tab.HeadEnt.Index = dupe.AutoSaveEnt:EntIndex()
				Tab.HeadEnt.Pos = dupe.AutoSaveEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				AdvDupe2.duplicator.Copy( ply, dupe.AutoSaveEnt, Tab.Entities, Tab.Constraints, Tab.HeadEnt.Pos )
			else
				local i = dupe.AutoSaveSize
				local Pos = dupe.AutoSavePos
				local T = Vector( i, i, i); T:Add(Pos)
				local B = Vector(-i,-i,-i); B:Add(Pos)

				local Entities = FindInBox(B,T, ply)
				local _, HeadEnt = next(Entities)
				if not HeadEnt then
					AdvDupe2.Notify(ply, "Area Auto Save copied 0 entities; be sure to turn it off.", NOTIFY_ERROR)
					return
				end

				if(dupe.AutoSaveEnt and Entities[dupe.AutoSaveEnt]) then
					Tab.HeadEnt.Index = dupe.AutoSaveEnt
				else
					Tab.HeadEnt.Index = HeadEnt:EntIndex()
				end
				Tab.HeadEnt.Pos = HeadEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, dupe.AutoSaveOutSide)
			end
			Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)
			Tab.Description = dupe.AutoSaveDesc

			AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
				AdvDupe2.SendToClient(ply, data, 1)
			end)
			dupe.FileMod = CurTime()+tonumber(GetConVarString("AdvDupe2_FileModificationDelay"))
		end)
		timer.Start(name)
	end)

	concommand.Add("AdvDupe2_SetStage", function(ply, cmd, args)
		ply:GetTool("advdupe2"):SetStage(1)
	end)

	concommand.Add("AdvDupe2_RemoveAutoSave", function(ply, cmd, args)
		timer.Remove("AdvDupe2_AutoSave_"..ply:UniqueID())
	end)

	concommand.Add("AdvDupe2_SaveMap", function(ply, cmd, args)
		if(not ply:IsAdmin()) then
			AdvDupe2.Notify(ply, "You do not have permission to this function.", NOTIFY_ERROR)
			return
		end

		local Entities = {}
		for _, v in ents.Iterator() do
			if not v:CreatedByMap() and AdvDupe2.duplicator.IsCopyable(v) then
				Entities[v:EntIndex()] = v
			end
		end

		local _, HeadEnt = next(Entities)
		if not HeadEnt then return end

		local Tab = {Entities={}, Constraints={}, HeadEnt={}, Description=""}
		Tab.HeadEnt.Index = HeadEnt:EntIndex()
		Tab.HeadEnt.Pos = HeadEnt:GetPos()

		local WorldTrace = util.TraceLine({
			mask   = MASK_NPCWORLDSTATIC,
			start  = Tab.HeadEnt.Pos + Vector(0,0,1),
			endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
		})

		Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, true)
		Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)

		Tab.Map = true
		AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
			if #data > AdvDupe2.MaxDupeSize then
				AdvDupe2.Notify(ply, "Copied duplicator filesize is too big!",NOTIFY_ERROR)
				return 
			end
			if(not file.IsDir("advdupe2_maps", "DATA")) then
				file.CreateDir("advdupe2_maps")
			end
			file.Write("advdupe2_maps/"..args[1]..".txt", data)
			AdvDupe2.Notify(ply, "Map save, saved successfully.")
		end)
	end)
end

if(CLIENT) then

	function TOOL:LeftClick(trace)
		if(trace and AdvDupe2.HeadGhost) then
			return true
		end
		return false
	end

	function TOOL:RightClick(trace)
		if( self:GetOwner():KeyDown(IN_SPEED) and not self:GetOwner():KeyDown(IN_WALK) ) then
			return false
		end
		return true
	end

	--Removes progress bar and removes ghosts when tool is put away
	function TOOL:ReleaseGhostEntity()
		AdvDupe2.RemoveGhosts()
		AdvDupe2.RemoveSelectBox()
		if(AdvDupe2.Rotation) then
			hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
			hook.Remove("CreateMove", "AdvDupe2_MouseControl")
		end
		return
	end

	function TOOL:Reload( trace )
		if(trace and (AdvDupe2.HeadGhost or self:GetStage() == 1)) then
			return true
		end
		return false
	end

	--Take control of the mouse wheel bind so the player can modify the height of the dupe
	local function MouseWheelScrolled(ply, bind, pressed)

		if(bind == "invprev") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.min(tonumber(ply:GetInfo("advdupe2_area_copy_size")) + 25, 30720)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) + 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		elseif(bind == "invnext") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.max(tonumber(ply:GetInfo("advdupe2_area_copy_size")) - 25, 25)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) - 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		end

		GAMEMODE:PlayerBindPress(ply, bind, pressed)
	end

	local YawTo = 0
	local BsAng = Angle()

	local function GetRotationSign(ply)
		local VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
		BsAng:Zero(); BsAng:RotateAroundAxis(BsAng:Up(), VY)
		local PR = ply:GetRight()
		local DP = BsAng:Right():Dot(PR)
		local DR = BsAng:Forward():Dot(PR)
		if(math.abs(DR) > math.abs(DP)) then -- Roll priority
			if(DR >= 0) then return -1, 1 else return  1, -1 end
		else -- Pitch axis takes priority. Normal X-Y map
			if(DP >= 0) then return  1, 1 else return -1, -1 end
		end
	end

	local function MouseControl( cmd )
		local ply = LocalPlayer()
		local X =  cmd:GetMouseX() / 20
		local Y = -cmd:GetMouseY() / 20
		local ru = ply:KeyDown(IN_SPEED)
		local mm = input.IsMouseDown(MOUSE_MIDDLE)

		if(mm) then
			if(ru) then
				YawTo = 0 -- Reset total integrated yaw
				RunConsoleCommand("advdupe2_offset_pitch", 0)
				RunConsoleCommand("advdupe2_offset_yaw"  , 0)
				RunConsoleCommand("advdupe2_offset_roll" , 0)
			else
				if(Y ~= 0) then
					local VR = tonumber(ply:GetInfo("advdupe2_offset_roll"))  or 0
					local VP = tonumber(ply:GetInfo("advdupe2_offset_pitch")) or 0
					local SP, SR, P, R = GetRotationSign(ply)
					if(SP ~= SR) then
						P = math.NormalizeAngle(VP + X * SR)
						R = math.NormalizeAngle(VR + Y * SP)
					else
						P = math.NormalizeAngle(VP + Y * SP)
						R = math.NormalizeAngle(VR + X * SR)
					end
					RunConsoleCommand("advdupe2_offset_pitch", P)
					RunConsoleCommand("advdupe2_offset_roll" , R)
				end
			end
		else
			if(X ~= 0) then
				VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
				if(ru) then
					YawTo = YawTo + X -- Integrate the mouse on the X value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.SnapTo(math.NormalizeAngle(YawTo), 45))
				else
					YawTo = VY + X -- Update the last yaw with the current value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.NormalizeAngle(YawTo))
				end
			end
		end
	end

	--Checks binds to modify dupes position and angles
	function TOOL:Think()

		if AdvDupe2.HeadGhost then
			AdvDupe2.UpdateGhosts()
		end

		if(LocalPlayer():KeyDown(IN_USE)) then
			if(not AdvDupe2.Rotation) then
				hook.Add("PlayerBindPress", "AdvDupe2_BindPress", MouseWheelScrolled)
				hook.Add("CreateMove", "AdvDupe2_MouseControl", MouseControl)
				AdvDupe2.Rotation = true
			end
		else
			if(AdvDupe2.Rotation) then
				AdvDupe2.Rotation = false
				hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
				hook.Remove("CreateMove", "AdvDupe2_MouseControl")
			end
		end
	end

	--Hinder the player from looking to modify offsets with the mouse
	function TOOL:FreezeMovement()
		return AdvDupe2.Rotation
	end

	language.Add( "Tool.advdupe2.name",	"Advanced Duplicator 2" )
	language.Add( "Tool.advdupe2.desc",	"Duplicate things." )
	language.Add( "Tool.advdupe2.0",	"Primary: Paste, Secondary: Copy, Secondary+World: Select/Deselect All, Secondary+Shift: Area copy." )
	language.Add( "Tool.advdupe2.1",	"Primary: Paste, Secondary: Copy an area, Reload: Autosave an area, Secondary+Shift: Cancel." )
	language.Add( "Undone_AdvDupe2",	"Undone AdvDupe2 paste" )
	language.Add( "Cleanup_AdvDupe2",	"AdvDupe2 Duplications" )
	language.Add( "Cleaned_AdvDupe2",	"Cleaned up all AdvDupe2 Duplications" )
	language.Add( "SBoxLimit_AdvDupe2",	"You've reached the AdvDupe2 Duplicator limit!" )

	CreateClientConVar("advdupe2_offset_world", 0, false, true)
	CreateClientConVar("advdupe2_offset_z", 0, false, true)
	CreateClientConVar("advdupe2_offset_pitch", 0, false, true)
	CreateClientConVar("advdupe2_offset_yaw", 0, false, true)
	CreateClientConVar("advdupe2_offset_roll", 0, false, true)
	CreateClientConVar("advdupe2_original_origin", 0, false, true)
	CreateClientConVar("advdupe2_paste_constraints", 1, false, true)
	CreateClientConVar("advdupe2_sort_constraints", 1, true, true)
	CreateClientConVar("advdupe2_paste_parents", 1, false, true)
	CreateClientConVar("advdupe2_paste_unfreeze", 0, false, true)
	CreateClientConVar("advdupe2_preserve_freeze", 0, false, true)
	CreateClientConVar("advdupe2_copy_outside", 0, false, true)
	CreateClientConVar("advdupe2_copy_only_mine", 1, false, true)
	CreateClientConVar("advdupe2_limit_ghost", 100, false, true)
	CreateClientConVar("advdupe2_area_copy_size", 300, false, true)
	CreateClientConVar("advdupe2_auto_save_contraption", 0, false, true)
	CreateClientConVar("advdupe2_auto_save_overwrite", 1, false, true)
	CreateClientConVar("advdupe2_auto_save_time", 2, false, true)

	--Contraption Spawner
	CreateClientConVar("advdupe2_contr_spawner_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_delay", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_delay", 10, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disgrav", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disdrag", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_addvel", 1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_hideprops", 0, false, true)

	--Experimental
	CreateClientConVar("advdupe2_paste_disparents", 0, false, true)
	CreateClientConVar("advdupe2_paste_protectoveride", 1, false, true)
	CreateClientConVar("advdupe2_debug_openfile", 1, false, true)

	local function BuildCPanel(CPanel)
		CPanel:ClearControls()

		local FileBrowser = vgui.Create("advdupe2_browser")
		CPanel:AddItem(FileBrowser)
		FileBrowser:SetSize(CPanel:GetWide(), 405)
		AdvDupe2.FileBrowser = FileBrowser

		local Check = vgui.Create("DCheckBoxLabel")

		Check:SetText( "Paste at original position" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_original_origin" )
		Check:SetValue( 0 )
		Check:SetToolTip("Paste at the position originally copied")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with constraints" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_constraints" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without constraints")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with parenting" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_parents" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without parenting")
		CPanel:AddItem(Check)

		local Check_1 = vgui.Create("DCheckBoxLabel")
		local Check_2 = vgui.Create("DCheckBoxLabel")

		Check_1:SetText( "Unfreeze all after paste" )
		Check_1:SetDark(true)
		Check_1:SetConVar( "advdupe2_paste_unfreeze" )
		Check_1:SetValue( 0 )
		Check_1.OnChange = function()
			if(Check_1:GetChecked() and Check_2:GetChecked()) then
				Check_2:SetValue(0)
			end
		end
		Check_1:SetToolTip("Unfreeze all props after pasting")
		CPanel:AddItem(Check_1)

		Check_2:SetText( "Preserve frozen state after paste" )
		Check_2:SetDark(true)
		Check_2:SetConVar( "advdupe2_preserve_freeze" )
		Check_2:SetValue( 0 )
		Check_2.OnChange = function()
			if(Check_2:GetChecked() and Check_1:GetChecked()) then
				Check_1:SetValue(0)
			end
		end
		Check_2:SetToolTip("Makes props have the same frozen state as when they were copied")
		CPanel:AddItem(Check_2)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Area copy constrained props outside of box" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_outside" )
		Check:SetValue( 0 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "World/Area copy only your own props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_only_mine" )
		Check:SetValue( 1 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Sort constraints by their connections" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_sort_constraints" )
		Check:SetValue( GetConVarNumber("advdupe2_sort_constraints") )
		Check:SetToolTip( "Orders constraints so that they build a rigid constraint system." )
		CPanel:AddItem(Check)

		local NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Ghost Percentage:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 100 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_limit_ghost" )
		NumSlider:SetToolTip("Change the percent of ghosts to spawn")
		--If these funcs are not here, problems occur for each
		local func = NumSlider.Slider.OnMouseReleased
		NumSlider.Slider.OnMouseReleased = function(self, mcode) func(self, mcode) AdvDupe2.StartGhosting() end
		local func2 = NumSlider.Slider.Knob.OnMouseReleased
		NumSlider.Slider.Knob.OnMouseReleased = function(self, mcode) func2(self, mcode) AdvDupe2.StartGhosting() end
		local func3 = NumSlider.Wang.Panel.OnLoseFocus
		NumSlider.Wang.Panel.OnLoseFocus = function(txtBox) func3(txtBox) AdvDupe2.StartGhosting() end
		CPanel:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Area Copy Size:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 30720 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_area_copy_size" )
		NumSlider:SetToolTip("Change the size of the area copy")
		CPanel:AddItem(NumSlider)

		local Category1 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category1)
		Category1:SetLabel("Offsets")
		Category1:SetExpanded(0)

		local parent = FileBrowser:GetParent():GetParent():GetParent():GetParent()
		--[[Offsets]]--
		local CategoryContent1 = vgui.Create( "DPanelList" )
		CategoryContent1:SetAutoSize( true )
		CategoryContent1:SetDrawBackground( false )
		CategoryContent1:SetSpacing( 1 )
		CategoryContent1:SetPadding( 2 )
		CategoryContent1.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end		--Fix the damned mouse not scrolling when it's over the catagories

		Category1:SetContents( CategoryContent1 )

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Height Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -2500 )
		NumSlider:SetMax( 2500 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetConVar("advdupe2_offset_z")
		NumSlider:SetToolTip("Changes the dupe Z offset")
		CategoryContent1:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Use World Angles" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_offset_world" )
		Check:SetValue( 0 )
		Check:SetToolTip("Use world angles for the offset instead of the main entity")
		CategoryContent1:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Pitch Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe pitch offset")
		NumSlider:SetConVar("advdupe2_offset_pitch")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Yaw Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe yaw offset")
		NumSlider:SetConVar("advdupe2_offset_yaw")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Roll Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe roll offset")
		NumSlider:SetConVar("advdupe2_offset_roll")
		CategoryContent1:AddItem(NumSlider)

		local Btn = vgui.Create("DButton")
		Btn:SetText("Reset")
		Btn.DoClick = function()
			RunConsoleCommand("advdupe2_offset_z", 0)
			RunConsoleCommand("advdupe2_offset_pitch", 0)
			RunConsoleCommand("advdupe2_offset_yaw", 0)
			RunConsoleCommand("advdupe2_offset_roll", 0)
		end
		CategoryContent1:AddItem(Btn)


		--[[Dupe Information]]--
		local Category2 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category2)
		Category2:SetLabel("Dupe Information")
		Category2:SetExpanded(0)

		local CategoryContent2 = vgui.Create( "DPanelList" )
		CategoryContent2:SetAutoSize( true )
		CategoryContent2:SetDrawBackground( false )
		CategoryContent2:SetSpacing( 3 )
		CategoryContent2:SetPadding( 2 )
		Category2:SetContents( CategoryContent2 )
		CategoryContent2.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		AdvDupe2.Info = {}

		local lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.File or "File: ")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.File = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Creator or "Creator:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Creator = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Date or "Date:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Date = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Time or "Time:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Time = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Size or "Size:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Size = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Desc or "Desc:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Desc = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Entities or "Entities:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Entities = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Constraints or "Constraints:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Constraints = lbl

	--[[Contraption Spawner]]--
		local Category3 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category3)
		Category3:SetLabel("Contraption Spawner")
		Category3:SetExpanded(0)

		local CategoryContent3 = vgui.Create( "DPanelList" )
		CategoryContent3:SetAutoSize( true )
		CategoryContent3:SetDrawBackground( false )
		CategoryContent3:SetSpacing( 3 )
		CategoryContent3:SetPadding( 2 )
		Category3:SetContents( CategoryContent3 )
		CategoryContent3.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		local ctrl = vgui.Create( "CtrlNumPad" )
		ctrl:SetConVar1( "advdupe2_contr_spawner_key" )
		ctrl:SetConVar2( "advdupe2_contr_spawner_undo_key" )
		ctrl:SetLabel1( "Spawn Key")
		ctrl:SetLabel2( "Undo Key" )
		CategoryContent3:AddItem(ctrl)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Spawn Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_delay"))<min) then
				RunConsoleCommand("advdupe2_contr_spawner_delay", tostring(min))
			end
			NumSlider:SetMin( min )
		end
		NumSlider:SetMax(60)
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_delay")
		CategoryContent3:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Undo Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
			NumSlider:SetMax( 60 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 10
			local max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) < min) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(min))
			elseif(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) > max) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(max))
			end
			NumSlider:SetMin( min )
			NumSlider:SetMax( max )
		end
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_undo_delay")
		CategoryContent3:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable gravity for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disgrav" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drag for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disdrag" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Add spawner's velocity to contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_addvel" )
		Check:SetValue( 1 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drawing spawner props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_hideprops" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		--[[Area Auto Save]]--
		local Category4 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category4)
		Category4:SetLabel("Area Auto Save")
		Category4:SetExpanded(0)

		local CategoryContent4 = vgui.Create( "DPanelList" )
		CategoryContent4:SetAutoSize( true )
		CategoryContent4:SetDrawBackground( false )
		CategoryContent4:SetSpacing( 3 )
		CategoryContent4:SetPadding( 2 )
		Category4:SetContents( CategoryContent4 )
		CategoryContent4.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Only copy contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_contraption" )
		Check:SetValue( 0 )
		Check:SetToolTip("Only copy a contraption instead of an area")
		CategoryContent4:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Overwrite File" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_overwrite" )
		Check:SetValue( 1 )
		Check:SetToolTip("Overwrite the file instead of creating a new one everytime")
		CategoryContent4:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Minutes to Save:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 2 )
		NumSlider:SetMax( 30 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_auto_save_time" )
		NumSlider:SetToolTip("Interval time to save in minutes")
		CategoryContent4:AddItem(NumSlider)

		local pnl = vgui.Create("Panel")
		pnl:SetWide(CPanel:GetWide()-40)
		pnl:SetTall(75)
		pnl:SetPos(0, 50)
		CategoryContent4:AddItem(pnl)

		local label = vgui.Create("DLabel", pnl)
		label:SetText("Directory: ")
		label:SizeToContents()
		label:SetDark(true)
		label:SetPos(5,7)

		AdvDupe2.AutoSavePath = ""
		local txtbox = vgui.Create("DTextEntry", pnl)
		txtbox:SetWide(pnl:GetWide()-100)
		txtbox:SetPos(60, 5)
		txtbox:SetUpdateOnType(true)
		txtbox.OnTextChanged = function(self)
			self:SetValue(AdvDupe2.AutoSavePath)
		end

		local btn = vgui.Create("DImageButton", pnl)
		local x, y = txtbox:GetPos()
		btn:SetPos(x + txtbox:GetWide() + 5, 7)
		btn:SetMaterial("icon16/folder_explore.png")
		btn:SizeToContents()
		btn:SetToolTip("Browse")
		btn.DoClick = function()
			local ScrollBar = parent.VBar
			ScrollBar:AnimateTo(0, 1, 0, 0.2)

			FileBrowser.Submit:SetMaterial("icon16/disk.png")
			FileBrowser.Submit:SetTooltip("Directory for Area Auto Save")
			if(FileBrowser.FileName:GetValue()=="Folder_Name...") then
				FileBrowser.FileName:SetValue("File_Name...")
			end
			FileBrowser.Desc:SetVisible(true)
			FileBrowser.Info:SetVisible(false)
			FileBrowser.FileName:SetVisible(true)
			FileBrowser.FileName:SelectAllOnFocus(true)
			FileBrowser.FileName:OnMousePressed()
			FileBrowser.FileName:RequestFocus()
			FileBrowser.Expanding=true
			FileBrowser:Slide(true)
			FileBrowser.Submit.DoClick = function()
				local name = FileBrowser.FileName:GetValue()
				if(name=="" or name=="File_Name...") then
					AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
					FileBrowser.FileName:SelectAllOnFocus(true)
					FileBrowser.FileName:OnGetFocus()
					FileBrowser.FileName:RequestFocus()
					return
				end
				local desc = FileBrowser.Desc:GetValue()
				if(desc=="Description...") then desc="" end

				if(not IsValid(FileBrowser.Browser.pnlCanvas.m_pSelectedItem) or FileBrowser.Browser.pnlCanvas.m_pSelectedItem.Derma.ClassName~="advdupe2_browser_folder") then
					AdvDupe2.Notify("Folder to save Area Auto Save not selected.", NOTIFY_ERROR)
					return
				end

				FileBrowser.AutoSaveNode = FileBrowser.Browser.pnlCanvas.m_pSelectedItem
				txtbox:SetValue(FileBrowser:GetFullPath(FileBrowser.Browser.pnlCanvas.m_pSelectedItem)..name)
				AdvDupe2.AutoSavePath = txtbox:GetValue()
				txtbox:SetToolTip(txtbox:GetValue())
				AdvDupe2.AutoSaveDesc = desc

				FileBrowser:Slide(false)
				ScrollBar:AnimateTo(ScrollBar.CanvasSize, 1, 0, 0.2)

				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
			FileBrowser.FileName.OnEnter = function()
				FileBrowser.FileName:KillFocus()
				FileBrowser.Desc:SelectAllOnFocus(true)
				FileBrowser.Desc.OnMousePressed()
				FileBrowser.Desc:RequestFocus()
			end
			FileBrowser.Desc.OnEnter = FileBrowser.Submit.DoClick
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos(pnl:GetWide()/4-10, 30)
		btn:SetText("Show")
		btn.DoClick = function()
			if(AdvDupe2.AutoSavePos) then
				RunConsoleCommand("advdupe2_area_copy_size", AdvDupe2.AutoSaveSize)
				LocalPlayer():SetEyeAngles( (AdvDupe2.AutoSavePos - LocalPlayer():GetShootPos()):Angle() )
				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos((pnl:GetWide()/4)*3-40, 30)
		btn:SetText("Turn Off")
		btn:SetDisabled(true)
		btn.DoClick = function(self)
			RunConsoleCommand("AdvDupe2_RemoveAutoSave")
			self:SetDisabled(true)
			AdvDupe2.AutoSavePos = nil
		end
		AdvDupe2.OffButton = btn


		--[[Experimental Section]]--
		local Category5 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category5)
		Category5:SetLabel("Experimental Section")
		Category5:SetExpanded(0)

		local CategoryContent5 = vgui.Create( "DPanelList" )
		CategoryContent5:SetAutoSize( true )
		CategoryContent5:SetDrawBackground( false )
		CategoryContent5:SetSpacing( 3 )
		CategoryContent5:SetPadding( 2 )
		Category5:SetContents( CategoryContent5 )
		CategoryContent5.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable parented props physics interaction" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_disparents" )
		Check:SetValue( 0 )
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable Dupe Spawn Protection" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_protectoveride" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you things don't look right after pasting.")
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Open file after Saving" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_debug_openfile" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you want your files to be opened after saving them.")
		CategoryContent5:AddItem(Check)

		--[[Save Map]]--
		if(LocalPlayer():IsAdmin()) then
			local Category6 = vgui.Create("DCollapsibleCategory")
			CPanel:AddItem(Category6)
			Category6:SetLabel("Save Map")
			Category6:SetExpanded(0)

			local CategoryContent6 = vgui.Create( "DPanelList" )
			CategoryContent6:SetAutoSize( true )
			CategoryContent6:SetDrawBackground( false )
			CategoryContent6:SetSpacing( 3 )
			CategoryContent6:SetPadding( 2 )
			Category6:SetContents( CategoryContent6 )
			CategoryContent6.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

			pnl = vgui.Create("Panel")
			pnl:SetWide(CPanel:GetWide()-40)
			pnl:SetTall(75)
			pnl:SetPos(0, 50)
			CategoryContent6:AddItem(pnl)

			label = vgui.Create("DLabel", pnl)
			label:SetText("File Name: ")
			label:SizeToContents()
			label:SetDark(true)
			label:SetPos(5,7)

			AdvDupe2.AutoSavePath = ""

			local txtbox2 = vgui.Create("DTextEntry", pnl)
			txtbox2:SetWide(pnl:GetWide()-100)
			txtbox2:SetPos(60, 5)

			local btn2 = vgui.Create("DImageButton", pnl)
			x, y = txtbox2:GetPos()
			btn2:SetPos(x + txtbox2:GetWide() + 5, 7)
			btn2:SetMaterial("icon16/disk.png")
			btn2:SizeToContents()
			btn2:SetToolTip("Save Map")
			btn2.DoClick = 	function()
				if(txtbox2:GetValue()=="") then return end
				RunConsoleCommand("AdvDupe2_SaveMap", txtbox2:GetValue())
			end
			txtbox2.OnEnter = function()
				btn2:DoClick()
			end
		end
	end

	function TOOL.BuildCPanel(panel)
		panel:ClearControls()
		panel:AddControl("Header", {
			Text = "Advanced Duplicator 2",
			Description = "Duplicate stuff."
		})
		local function tryToBuild()
			local CPanel = controlpanel.Get("advdupe2")
			if CPanel and CPanel:GetWide()>16 then
				BuildCPanel(CPanel)
			else
				timer.Simple(0.1,tryToBuild)
			end
		end
		tryToBuild()
	end

	local StColor  = {r=130, g=25, b=40, a=255}
	local NoColor  = {r=25, g=100, b=40, a=255}
	local CurColor = {r=25, g=100, b=40, a=255}
	local CWhite   = Color(255,255,255,255)
	surface.CreateFont ("AD2Font", {font="Arial", size=40, weight=1000}) ---Remember to use gm_clearfonts
	surface.CreateFont ("AD2TitleFont", {font="Arial", size=24, weight=1000})

	function TOOL:DrawToolScreen()
		if(not AdvDupe2) then return true end

		local text = "Ready"
		local state, co = false
		local ply = LocalPlayer()

		if(AdvDupe2.Preview) then
			text = "Preview"
		end
		if(AdvDupe2.ProgressBar.Text) then
			state = true
			text = AdvDupe2.ProgressBar.Text
		end

		cam.Start2D()

			surface.SetDrawColor(32, 32, 32, 255)
			surface.DrawRect(0, 0, 256, 256)

			if(state) then
				co = StColor
			else
				co = NoColor
			end

			local rate = FrameTime() * 160
			CurColor.r = math.Approach( CurColor.r, co.r, rate )
			CurColor.g = math.Approach( CurColor.g, co.g, rate )

			surface.SetDrawColor(CurColor)
			surface.DrawRect(13, 13, 230, 230)

			surface.SetTextColor( 255, 255, 255, 255 )

			draw.SimpleText("Advanced Duplicator 2", "AD2TitleFont", 128, 50, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(text, "AD2Font", 128, 128, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			if(state) then
				draw.RoundedBox( 6, 32, 178, 192, 28, Color( 255, 255, 255, 150 ) )
				draw.RoundedBox( 6, 34, 180, 188*(AdvDupe2.ProgressBar.Percent / 100), 24, Color( 0, 255, 0, 255 ) )
			elseif(ply:KeyDown(IN_USE)) then
				local font, align = "AD2TitleFont", TEXT_ALIGN_BOTTOM
				draw.SimpleText("H: "..ply:GetInfo("advdupe2_offset_z")    , font, 20,  210, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("P: "..ply:GetInfo("advdupe2_offset_pitch"), font, 236, 210, CWhite, TEXT_ALIGN_RIGHT, align)
				draw.SimpleText("Y: "..ply:GetInfo("advdupe2_offset_yaw")  , font, 20 , 240, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("R: "..ply:GetInfo("advdupe2_offset_roll") , font, 236, 240, CWhite, TEXT_ALIGN_RIGHT, align)
			end

		cam.End2D()
	end


	local function FindInBox(min, max, ply)
		local EntTable = {}
		for _,ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and (pos.Y>=min.Y) and (pos.Y<=max.Y) and (pos.Z>=min.Z) and (pos.Z<=max.Z) then
				--if(ent:GetClass()~="C_BaseFlexclass") then
					EntTable[ent:EntIndex()] = ent
				--end
			end
		end

		return EntTable
	end


	local GreenSelected = Color(0, 255, 0, 255)
	function AdvDupe2.DrawSelectionBox()

		local TraceRes = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		local i = math.Clamp(tonumber(LocalPlayer():GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)

		--Bottom Points
		local B1 = (Vector(-i,-i,-i) + TraceRes.HitPos)
		local B2 = (Vector(-i, i,-i) + TraceRes.HitPos)
		local B3 = (Vector( i, i,-i) + TraceRes.HitPos)
		local B4 = (Vector( i,-i,-i) + TraceRes.HitPos)

		--Top Points
		local T1 = (Vector(-i,-i, i) + TraceRes.HitPos):ToScreen()
		local T2 = (Vector(-i, i, i) + TraceRes.HitPos):ToScreen()
		local T3 = (Vector( i, i, i) + TraceRes.HitPos):ToScreen()
		local T4 = (Vector( i,-i, i) + TraceRes.HitPos):ToScreen()

		if(not AdvDupe2.LastUpdate or CurTime()>=AdvDupe2.LastUpdate) then

			if AdvDupe2.ColorEntities then
				for k,v in pairs(AdvDupe2.EntityColors)do
					local ent = AdvDupe2.ColorEntities[k]
					if(IsValid(ent)) then
						AdvDupe2.ColorEntities[k]:SetColor(v)
					end
				end
			end

			local Entities = FindInBox(B1, (Vector(i,i,i)+TraceRes.HitPos), LocalPlayer())
			AdvDupe2.ColorEntities = Entities
			AdvDupe2.EntityColors = {}
			for k,v in pairs(Entities)do
				AdvDupe2.EntityColors[k] = v:GetColor()
				v:SetColor(GreenSelected)
			end
			AdvDupe2.LastUpdate = CurTime()+0.25

		end

		local tracedata = {}
		tracedata.mask = MASK_NPCWORLDSTATIC
		local WorldTrace

		tracedata.start = B1+Vector(0,0,i*2)
		tracedata.endpos = B1
		WorldTrace = util.TraceLine( tracedata )
		B1 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B2+Vector(0,0,i*2)
		tracedata.endpos = B2
		WorldTrace = util.TraceLine( tracedata )
		B2 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B3+Vector(0,0,i*2)
		tracedata.endpos = B3
		WorldTrace = util.TraceLine( tracedata )
		B3 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B4+Vector(0,0,i*2)
		tracedata.endpos = B4
		WorldTrace = util.TraceLine( tracedata )
		B4 = WorldTrace.HitPos:ToScreen()

		surface.SetDrawColor( 0, 255, 0, 255 )

		--Draw Sides
		surface.DrawLine(B1.x, B1.y, T1.x, T1.y)
		surface.DrawLine(B2.x, B2.y, T2.x, T2.y)
		surface.DrawLine(B3.x, B3.y, T3.x, T3.y)
		surface.DrawLine(B4.x, B4.y, T4.x, T4.y)

		--Draw Bottom
		surface.DrawLine(B1.x, B1.y, B2.x, B2.y)
		surface.DrawLine(B2.x, B2.y, B3.x, B3.y)
		surface.DrawLine(B3.x, B3.y, B4.x, B4.y)
		surface.DrawLine(B4.x, B4.y, B1.x, B1.y)

		--Draw Top
		surface.DrawLine(T1.x, T1.y, T2.x, T2.y)
		surface.DrawLine(T2.x, T2.y, T3.x, T3.y)
		surface.DrawLine(T3.x, T3.y, T4.x, T4.y)
		surface.DrawLine(T4.x, T4.y, T1.x, T1.y)

	end

	net.Receive("AdvDupe2_DrawSelectBox", function()
		hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
	end)

	function AdvDupe2.RemoveSelectBox()
		hook.Remove("HUDPaint", "AdvDupe2_DrawSelectionBox")
		if AdvDupe2.ColorEntities then
			for k,v in pairs(AdvDupe2.EntityColors)do
				if(not IsValid(AdvDupe2.ColorEntities[k])) then
					AdvDupe2.ColorEntities[k]=nil
				else
					AdvDupe2.ColorEntities[k]:SetColor(v)
				end
			end
			AdvDupe2.ColorEntities={}
			AdvDupe2.EntityColors={}
		end
	end
	net.Receive("AdvDupe2_RemoveSelectBox",function()
		AdvDupe2.RemoveSelectBox()
	end)

	function AdvDupe2.InitProgressBar(label)
		AdvDupe2.ProgressBar = {}
		AdvDupe2.ProgressBar.Text = label
		AdvDupe2.ProgressBar.Percent = 0
		AdvDupe2.BusyBar = true
	end
	net.Receive("AdvDupe2_InitProgressBar", function()
		AdvDupe2.InitProgressBar(net.ReadString())
	end)

	net.Receive("AdvDupe2_UpdateProgressBar", function()
		AdvDupe2.ProgressBar.Percent = net.ReadFloat()
	end)

	function AdvDupe2.RemoveProgressBar()
		AdvDupe2.ProgressBar = {}
		AdvDupe2.BusyBar = false
		if(AdvDupe2.Ghosting) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost/AdvDupe2.TotalGhosts*100
		end
	end
	net.Receive("AdvDupe2_RemoveProgressBar", function()
		AdvDupe2.RemoveProgressBar()
	end)

	net.Receive("AdvDupe2_ResetOffsets", function()
		RunConsoleCommand("advdupe2_original_origin", "0")
		RunConsoleCommand("advdupe2_paste_constraints","1")
		RunConsoleCommand("advdupe2_offset_z","0")
		RunConsoleCommand("advdupe2_offset_pitch","0")
		RunConsoleCommand("advdupe2_offset_yaw","0")
		RunConsoleCommand("advdupe2_offset_roll","0")
		RunConsoleCommand("advdupe2_paste_parents","1")
		RunConsoleCommand("advdupe2_paste_disparents","0")
	end)

	net.Receive("AdvDupe2_ReportModel", function()
		print("Advanced Duplicator 2: Invalid Model: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ReportClass", function()
		print("Advanced Duplicator 2: Invalid Class: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ResetDupeInfo", function()
		if not AdvDupe2.Info then return end
		AdvDupe2.Info.File:SetText("File:")
		AdvDupe2.Info.Creator:SetText("Creator:")
		AdvDupe2.Info.Date:SetText("Date:")
		AdvDupe2.Info.Time:SetText("Time:")
		AdvDupe2.Info.Size:SetText("Size:")
		AdvDupe2.Info.Desc:SetText("Desc:")
		AdvDupe2.Info.Entities:SetText("Entities:")
		AdvDupe2.Info.Constraints:SetText("Constraints:")
	end)

	net.Receive("AdvDupe2_CanAutoSave", function()
		if(AdvDupe2.AutoSavePath~="") then
			AdvDupe2.AutoSavePos = net.ReadVector()
			AdvDupe2.AutoSaveSize = net.ReadFloat()
			local ent = net.ReadUInt(16)
			AdvDupe2.OffButton:SetDisabled(false)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteString(AdvDupe2.AutoSaveDesc)
				net.WriteInt(ent, 16)
				if(game.SinglePlayer()) then
					net.WriteString(string.sub(AdvDupe2.AutoSavePath, 10, #AdvDupe2.AutoSavePath))
				end
			net.SendToServer()
		else
			AdvDupe2.Notify("Select a directory for the Area Auto Save.", NOTIFY_ERROR)
		end
	end)

	net.Receive("AdvDupe2_SetDupeInfo", function(len, ply, len2)
		if AdvDupe2.Info then
			AdvDupe2.Info.File:SetText("File: "..net.ReadString())
			AdvDupe2.Info.Creator:SetText("Creator: "..net.ReadString())
			AdvDupe2.Info.Date:SetText("Date: "..net.ReadString())
			AdvDupe2.Info.Time:SetText("Time: "..net.ReadString())
			AdvDupe2.Info.Size:SetText("Size: "..net.ReadString())
			AdvDupe2.Info.Desc:SetText("Desc: "..net.ReadString())
			AdvDupe2.Info.Entities:SetText("Entities: "..net.ReadString())
			AdvDupe2.Info.Constraints:SetText("Constraints: "..net.ReadString())
		else
			AdvDupe2.InfoText.File = "File: "..net.ReadString()
			AdvDupe2.InfoText.Creator = "Creator: "..net.ReadString()
			AdvDupe2.InfoText.Date = "Date: "..net.ReadString()
			AdvDupe2.InfoText.Time = "Time: "..net.ReadString()
			AdvDupe2.InfoText.Size = "Size: "..net.ReadString()
			AdvDupe2.InfoText.Desc = "Desc: "..net.ReadString()
			AdvDupe2.InfoText.Entities = "Entities: "..net.ReadString()
			AdvDupe2.InfoText.Constraints = "Constraints: "..net.ReadString()
		end
	end)
end

--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads_admin_tool.lua:
local AdminMenus = {}

TOOL.Category = "Billy's Keypads"
TOOL.Name = "#tool.bkeypads_admin_tool.name"
TOOL.AddToMenu = false

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "focus", icon = "gui/lmb.png", op = 0, stage = 0 },
		{ name = "unfocus", icon = "gui/rmb.png", op = 0, stage = 1 },
		{ name = "menu", icon = "gui/r.png", op = 0 }
	}
end

function TOOL:LeftClick(tr)
	if (SERVER or IsFirstTimePredicted()) and IsValid(tr.Entity) and tr.Entity.bKeypad then
		if IsValid(self.m_eFocusKeypad) and tr.Entity == self.m_eFocusKeypad then
			self.m_eFocusKeypad = nil
			self:SetStage(0)
		elseif bKeypads.Permissions:Check(self:GetOwner(), "tools/admin_tool") then
			self.m_eFocusKeypad = tr.Entity
			self:SetStage(1)
		else
			return false
		end
		return true
	end

	return false
end

function TOOL:RightClick(tr)
	if (SERVER or IsFirstTimePredicted()) and IsValid(self.m_eFocusKeypad) then
		self.m_eFocusKeypad = nil
		self:SetStage(0)
		return true
	end

	return false
end

function TOOL:Reload(tr)
	if CLIENT and not IsFirstTimePredicted() then return end
	if not bKeypads.Permissions:Check(self:GetOwner(), "tools/admin_tool") then
		return false
	elseif SERVER then
		return true
	end

	local keypad = (IsValid(tr.Entity) and tr.Entity.bKeypad == true and tr.Entity) or (IsValid(self.m_eFocusKeypad) and self.m_eFocusKeypad)
	if not IsValid(keypad) then return false end

	local L = bKeypads.L

	local AdminMenu = vgui.Create("DFrame")
	AdminMenus[keypad] = AdminMenu
	AdminMenu:SetIcon("icon16/shield.png")
	AdminMenu:SetTitle("Billy's Keypads - " .. L"AdminMenu")
	AdminMenu:SetSize(500, 600)
	AdminMenu:SetSizable(true)
	AdminMenu:MakePopup()

	AdminMenu:SetPos((ScrW() - AdminMenu:GetWide()) / 2, ScrH())

	local y = (ScrH() + AdminMenu:GetTall()) / 2
	AdminMenu:NewAnimation(1, 0, .5).Think = function(_, pnl, f)
		local f = bKeypads.ease.OutBack(f)

		local x = pnl:GetPos()
		pnl:SetPos(x, ScrH() - (y * f))

		pnl:SetAlpha(f * 255)
	end

	local Tabs = vgui.Create("DPropertySheet", AdminMenu)
	Tabs:Dock(FILL)

	--## Properties ##--

	local PropertiesPanel = vgui.Create("DPanel", Tabs)
	PropertiesPanel.Paint = nil

		keypad.m_pKeypadProperties = (IsValid(keypad.m_pKeypadProperties) and keypad.m_pKeypadProperties) or self:CreatePropertiesPanel(keypad)
		keypad.m_pKeypadProperties:SetAlpha(255)
		keypad.m_pKeypadProperties:Dock(FILL)
		keypad.m_pKeypadProperties:SetPaintedManually(false)
		keypad.m_pKeypadProperties:SetParent(PropertiesPanel)
		keypad.m_pKeypadProperties.PerformLayout = DProperties.PerformLayout
		keypad.m_pKeypadProperties.m_b3D2D = nil
		
	--## Access Matrix ##--

	local AccessMatrixPanel = vgui.Create("DPanel", Tabs)
	AccessMatrixPanel.Paint = nil

		local owner = keypad:GetKeypadOwner()

		if IsValid(owner) and owner:IsPlayer() then
			local OwnedBy = vgui.Create("DLabel", AccessMatrixPanel)
			OwnedBy:Dock(TOP)
			OwnedBy:DockMargin(0, 0, 0, 10)
			OwnedBy:SetFont("DermaDefaultBold")
			OwnedBy:SetTextColor(bKeypads.COLOR.WHITE)
			OwnedBy:SetContentAlignment(4)
			OwnedBy:SetText(bKeypads.L"OwnedBy")
			OwnedBy:SizeToContentsY()

			local CreatorRow = vgui.Create("DPanel", AccessMatrixPanel)
			CreatorRow:Dock(TOP)
			CreatorRow:SetTall(32)
			CreatorRow:DockMargin(0, 0, 0, 10)
			CreatorRow.OnMousePressed = function(self, m)
				if m == MOUSE_LEFT then
					self._m = true
				end
			end
			CreatorRow.OnMouseReleased = function(self, m)
				if m == MOUSE_LEFT and self._m then
					self._m = nil
					surface.PlaySound("garrysmod/balloon_pop_cute.wav")
					gui.OpenURL("https://steamcommunity.com/profiles/" .. owner:SteamID64())
				end
			end

			CreatorRow.Paint = nil

				local CreatorAvatar = vgui.Create("AvatarImage", CreatorRow)
				CreatorAvatar:Dock(LEFT)
				CreatorAvatar:SetWide(32)
				CreatorAvatar:DockMargin(0, 0, 10, 0)
				CreatorAvatar:SetSteamID(owner:SteamID64(), 64)
				CreatorAvatar:SetMouseInputEnabled(false)
				
				local CreatorName = vgui.Create("DLabel", CreatorRow)
				CreatorName:Dock(FILL)
				CreatorName:SetTextColor(bKeypads.COLOR.WHITE)
				CreatorName:SetContentAlignment(4)
				CreatorName:SetText(owner:Nick() .. "\n" .. owner:SteamID())
		end

		AccessMatrixPanel.AccessTable = vgui.Create("bKeypads.AccessMatrix", AccessMatrixPanel)
		AccessMatrixPanel.AccessTable.OnRowRightClick = bKeypads.noop
		AccessMatrixPanel.AccessTable:Dock(FILL)
		function AdminMenu:SetAccessMatrix(accessMatrix)
			AccessMatrixPanel.AccessTable.AccessMatrix = accessMatrix
			AccessMatrixPanel.AccessTable:Populate()
		end

	--## Access Logs ##--

	local AccessLogsPanel = vgui.Create("DPanel", Tabs)
	AccessLogsPanel.Paint = nil

		bKeypads.AccessLogs:OpenUI(keypad, false, AccessLogsPanel)

	--## Tabs ##--
	
	Tabs:AddSheet(L"Properties", PropertiesPanel, "icon16/application_view_gallery.png")
	Tabs:AddSheet(L"AccessTable", AccessMatrixPanel, "icon16/group_key.png")
	Tabs:AddSheet(L"AccessLogs", AccessLogsPanel, "icon16/chart_curve.png")

	AdminMenu.OnClose = function()
		if not IsValid(keypad) then return end

		AdminMenus[keypad] = nil
		if IsValid(keypad.m_pKeypadProperties) then
			keypad.m_pKeypadProperties:Dock(NODOCK)
			keypad.m_pKeypadProperties:SetPaintedManually(true)
			keypad.m_pKeypadProperties:SetParent(vgui.GetWorldPanel())
		end
	end

	net.Start("bKeypads.AdminTool.Fetch")
		net.WriteEntity(keypad)
	net.SendToServer()

	return true
end

function TOOL:Deploy()
	self:SetStage(0)
	self.m_eFocusKeypad = nil
end
function TOOL:Holster()
	self:SetStage(0)
	self.m_eFocusKeypad = nil
end

if CLIENT then
	function TOOL:Deployed()
		bKeypads.ESP:Activate()
		
		hook.Add("PostDrawTranslucentRenderables", "bKeypads.AdminTool.DrawProperties", self.DrawProperties)
	end
	
	function TOOL:Holstered()
		bKeypads.ESP:Deactivate()

		hook.Remove("PostDrawTranslucentRenderables", "bKeypads.AdminTool.DrawProperties")

		for _, keypad in ipairs(bKeypads.Keypads) do
			if not IsValid(keypad) then continue end

			if IsValid(keypad.m_pKeypadProperties) then
				keypad.m_pKeypadProperties:Remove()
			end
			keypad.m_pKeypadProperties = nil
		end
	end
end
bKeypads_Prediction(TOOL)

if CLIENT then
	function TOOL:GetFocusKeypad()
		if IsValid(self.m_eFocusKeypad) then
			return self.m_eFocusKeypad
		else
			local nearestDist, nearestX, nearestY, nearestKeypad = math.huge
			for _, keypad in ipairs(bKeypads.Keypads) do
				if not IsValid(keypad) then continue end

				local ScreenPos = keypad:LocalToWorld(keypad:OBBCenter()):ToScreen()
				if not ScreenPos.visible then continue end

				local dist3D = keypad:GetPos():DistToSqr(EyePos())
				
				local xDist = (ScrW() / 2) - ScreenPos.x
				local yDist = (ScrH() / 2) - ScreenPos.y
				local perceivedDist = (math.abs(xDist) + math.abs(yDist)) * dist3D
				if perceivedDist < nearestDist then
					nearestDist, nearestX, nearestY = perceivedDist, xDist, yDist
					nearestKeypad = keypad
				end
			end

			return nearestKeypad, nearestX, nearestY
		end
	end

	local gmod_toolmode

	function TOOL.BuildCPanel(CPanel)
		bKeypads:InjectSmoothScroll(CPanel)
		
		local L = bKeypads.L

		bKeypads:STOOLMatrix(CPanel)

		local Help = vgui.Create("DForm", CPanel)
			Help:SetExpanded(true)
			Help:SetLabel(L"Help")
			local label = Help:Help("#tool.bkeypads_admin_tool.help")
			label:GetParent():DockMargin(0, 0, 0, 8)
			label:DockMargin(0, 0, 0, 0)
		CPanel:AddItem(Help)
		
		hook.Run("bKeypads.BuildCPanel", CPanel)
	end
	bKeypads_AdminTool_BuildCPanel = TOOL.BuildCPanel

	local matAdminTool = Material("bkeypads/admin_tool")
	function TOOL:DrawToolScreen(w,h)
		surface.SetDrawColor(0,150,255)
		surface.DrawRect(0,0,w,h)

		if not self.Matrix then
			self.Matrix = bKeypads_Matrix("STOOL_Screen", w, h)
		end
		self.Matrix:Draw(w,h)

		surface.SetMaterial(matAdminTool)
		surface.DrawTexturedRect(0, 0, w, h)

		if not bKeypads.Permissions:Cached(LocalPlayer(), "tools/admin_tool") then
			bKeypads:ToolScreenNoPermission(w,h)
		end
	end

	local propertiesW, propertiesPadding, propertiesScale = 300, 25, 0.05

	local function propertiesH(keypad)
		return keypad.m_pKeypadProperties:GetTall()
	end

	local keypad_w, keypad_h
	local function FindDirection(keypad, ang, x, y, isBehind)
		local center = keypad:LocalToWorld(keypad:OBBCenter())

		local propertiesH = propertiesH(keypad)

		local origin, directionID

		if x and y then
			local mins, maxs = keypad:OBBMins(), keypad:OBBMaxs()

			if not keypad_w then
				keypad_w = (maxs.y - mins.y) / propertiesScale / 2
			end
			if not keypad_h then
				keypad_h = (maxs.z - mins.z) / propertiesScale / 2
			end

			if y >= keypad_h then
				--print("bottom")

				origin = center + (ang:Right() * (keypad_h + propertiesPadding) * propertiesScale)
				directionID = 0
			elseif y < -keypad_h then
				--print("top")

				origin = center - (ang:Right() * (keypad_h + propertiesPadding + propertiesH) * propertiesScale)
				directionID = 1
			elseif x * (isBehind and -1 or 1) >= keypad_w then
				--print("right")

				origin = center + (ang:Forward() * (keypad_w + propertiesPadding + (propertiesW * .5)) * propertiesScale) - (ang:Right() * propertiesH * .5 * propertiesScale)
				directionID = 2
			elseif x * (isBehind and -1 or 1) < -keypad_w then
				--print("left")

				origin = center - (ang:Forward() * (keypad_w + propertiesPadding + (propertiesW * .5)) * propertiesScale) - (ang:Right() * propertiesH * .5 * propertiesScale)
				directionID = 3
			end
		end

		if not origin then
			--print("center")
		
			origin = center - (ang:Right() * propertiesH * .5 * propertiesScale)
			directionID = 4
		end

		return origin, directionID
	end
	
	local UNSET = 42069
	local fadeAnimStart, slideAnimStart, slideAnimFrom
	local prevKeypad, prevDirectionID, prevOrigin = UNSET, UNSET
	local sizeChanges
	local function KeypadPropertiesPerformLayout(self, w, h)
		DProperties.PerformLayout(self, w, h)

		if self:GetCanvas():GetVBar():IsVisible() then
			self:GetCanvas():SizeToChildren(false, true)
			self:SizeToChildren(false, true)
		end

		if sizeChanges == nil then
			sizeChanges = true
		end
	end

	function TOOL.DrawProperties(bDrawingDepth, bDrawingSkybox)
		if bDrawingSkybox then return end
		if not bKeypads.Permissions:Cached(LocalPlayer(), "tools/admin_tool") then return end
		if render.GetRenderTarget() ~= nil then return end

		local self = LocalPlayer():GetTool("bkeypads_admin_tool")
		if not self then return end
		
		gmod_toolmode = gmod_toolmode or GetConVar("gmod_toolmode")

		local wep = LocalPlayer():GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" or gmod_toolmode:GetString() ~= "bkeypads_admin_tool" then
			self.LinkingKeypad = nil
			return
		end

		local nearestKeypad, nearestX, nearestY = self:GetFocusKeypad()
		if nearestKeypad ~= nil and halo.RenderedEntity() == nearestKeypad then return end

		self.LinkingKeypad = nearestKeypad

		if nearestKeypad ~= prevKeypad then
			slideAnimStart = SysTime()
			prevDirectionID = nil
			if prevKeypad ~= UNSET then
				sizeChanges = false
			end
		end

		if nearestKeypad then
			local keypad = nearestKeypad

			keypad.m_pKeypadProperties = bKeypads.Properties:Update(keypad)

			local isInWorldSpace = keypad.m_pKeypadProperties:GetParent() == vgui.GetWorldPanel()
			if isInWorldSpace then
				keypad.m_pKeypadProperties.PerformLayout = KeypadPropertiesPerformLayout

				bKeypads.cam.IgnoreZ(true)
					
					local isBehind = keypad:IsPlayerBehind(LocalPlayer())

					local ang = keypad:GetAngles()
					ang:RotateAroundAxis(keypad:GetUp(), 90)
					ang:RotateAroundAxis(keypad:GetRight(), -90)
					if keypad:GetBroken() and keypad.HackedAngle then
						ang:RotateAroundAxis(keypad:GetRight(), -keypad.HackedAngle)
						ang:RotateAroundAxis(keypad:GetForward(), -keypad.HackedAngle)
					end

					local origin, directionID = FindDirection(keypad, ang, nearestX, nearestY, isBehind)

					if IsValid(self.m_eFocusKeypad) and IsValid(keypad.m_pKeypadProperties) then
						local viewDelta = (keypad:GetPos() - EyePos()):Angle() - keypad:GetAngles()
						ang:RotateAroundAxis(ang:Right(), -viewDelta.y - 180)
					elseif isBehind then
						ang:RotateAroundAxis(ang:Right(), 180)
					end

					origin = origin - (ang:Forward() * propertiesW * .5 * propertiesScale)

					local slideAnimFrac = 1
					fadeAnimStart = fadeAnimStart or SysTime()

					if bKeypads.Performance:Optimizing() then
						keypad.m_pKeypadProperties:SetAlpha(255)

						prevOrigin = origin
					else

						local fadeAnimFrac = bKeypads.ease.OutQuint(math.min(math.TimeFraction(fadeAnimStart, fadeAnimStart + 1, SysTime()), 1))
						keypad.m_pKeypadProperties:SetAlpha(255 * fadeAnimFrac)

						if directionID ~= prevDirectionID or not slideAnimFrom then
							slideAnimStart = SysTime()
							slideAnimFrom = prevOrigin or origin
						end

						slideAnimFrac = bKeypads.ease.OutQuint(math.min(math.TimeFraction(slideAnimStart, slideAnimStart + 1, SysTime()), 1))
						if sizeChanges then
							if keypad == prevKeypad then
								slideAnimFrom = origin
								sizeChanges = nil
							else
								sizeChanges = false
							end
						end

						prevOrigin = LerpVector(slideAnimFrac, slideAnimFrom, origin)
					end

					cam.Start3D2D(prevOrigin, ang, propertiesScale)
						keypad.m_pKeypadProperties:PaintManual()
					cam.End3D2D()

					prevDirectionID = directionID

				bKeypads.cam.IgnoreZ(false)

				if directionID == 4 or slideAnimFrac ~= 1 then
					render.SetBlend(.25)
					surface.SetAlphaMultiplier(0)
						keypad:DrawModel()
					surface.SetAlphaMultiplier(1)
				end
			end
		end

		prevKeypad = nearestKeypad
	end

	if hook.GetTable()["PostDrawTranslucentRenderables"] and hook.GetTable()["PostDrawTranslucentRenderables"]["bKeypads.AdminTool.DrawProperties"] then
		hook.Remove("PostDrawTranslucentRenderables", "bKeypads.AdminTool.DrawProperties")
		hook.Add("PostDrawTranslucentRenderables", "bKeypads.AdminTool.DrawProperties", TOOL.DrawProperties)
	end
end

if SERVER then
	util.AddNetworkString("bKeypads.AdminTool.Fetch")
	
	net.Receive("bKeypads.AdminTool.Fetch", function(_, ply)
		local keypad = net.ReadEntity()
		if not bKeypads.Permissions:Check(ply, "tools/admin_tool") or not IsValid(keypad) then return end
		
		net.Start("bKeypads.AdminTool.Fetch")
			net.WriteEntity(keypad)
			bKeypads.KeypadData.Net:Serialize(keypad.AccessMatrix or bKeypads.KeypadData:AccessMatrix())
		net.Send(ply)
	end)
else
	net.Receive("bKeypads.AdminTool.Fetch", function(_, ply)
		local keypad = net.ReadEntity()
		if not IsValid(keypad) or not IsValid(AdminMenus[keypad]) then return end

		local accessMatrix = bKeypads.KeypadData.Net:Deserialize()
		AdminMenus[keypad]:SetAccessMatrix(accessMatrix)
	end)
end
--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads_persistence.lua:
TOOL.Category = "Billy's Keypads"
TOOL.Name = "#tool.bkeypads_persistence.name"
TOOL.AddToMenu = false

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "make_persistent", icon = "gui/lmb.png", op = 0 },
		{ name = "delete", icon = "gui/rmb.png", op = 0 },
		{ name = "update", icon = "gui/r.png", op = 0 }
	}
end

local function NoneProfileActive()
	if CLIENT then
		return bKeypads.PersistenceProfile == "none"
	else
		return bKeypads.Persistence.Profile == "none"
	end
end

function TOOL:LeftClick(tr)
	if NoneProfileActive() then
		if CLIENT and IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L"NoneProfileError", NOTIFY_ERROR, 2)
			surface.PlaySound("buttons/button8.wav")
		end
		return
	end
	if not IsValid(self:GetOwner()) or not bKeypads.Permissions:Check(self:GetOwner(), "persistence/manage_persistent_keypads") then return false end

	if IsValid(tr.Entity) and tr.Entity.bKeypad and not tr.Entity:GetPersist() then
		if SERVER then
			bKeypads.Persistence:SaveKeypad(tr.Entity)
		elseif IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.created"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_GENERIC, 2)
		end
		return true
	end

	return false
end

function TOOL:RightClick(tr)
	if NoneProfileActive() then return end
	if not IsValid(self:GetOwner()) or not bKeypads.Permissions:Check(self:GetOwner(), "persistence/manage_persistent_keypads") then return false end

	if IsValid(tr.Entity) and tr.Entity.bKeypad and tr.Entity:GetPersist() then
		if SERVER then
			local fx = EffectData()
				fx:SetOrigin(tr.Entity:GetPos())
				fx:SetEntity(tr.Entity)
			util.Effect("entity_remove", fx, true, true)

			bKeypads.Persistence:ForgetKeypad(tr.Entity)
		elseif IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.deleted"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_GENERIC, 2)
		end
		return true
	end

	return false
end

function TOOL:Reload(tr)
	if NoneProfileActive() then return end
	if not IsValid(self:GetOwner()) or not bKeypads.Permissions:Check(self:GetOwner(), "persistence/manage_persistent_keypads") then return false end

	if IsValid(tr.Entity) and tr.Entity.bKeypad and tr.Entity:GetPersist() then
		if SERVER then
			bKeypads.Persistence:CommitKeypad(tr.Entity)
			bKeypads.Persistence:WriteToFile()
		elseif IsFirstTimePredicted() then
			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.updated"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_GENERIC, 2)
		end
		return true
	end

	return false
end

function TOOL:Deploy()
	if CLIENT and not self.m_Deployed then
		net.Start("bKeypads.Persistence.FetchProfiles")
			net.WriteBool(false)
		net.SendToServer()
	end

	self.m_Deployed = true
	if CLIENT then bKeypads.ESP:Activate() end

	self:SetStage(0)
	self:SetOperation(0)
end

function TOOL:Holster()
	self.m_Deployed = nil
	if CLIENT then bKeypads.ESP:Deactivate() end

	self:SetStage(0)
	self:SetOperation(0)
end

if CLIENT then
	function TOOL:Think()
		if not self.m_Deployed then
			self:Deploy()
		end
	end
	
	local matPadlockPNG = Material("bkeypads/padlock.png", "smooth")
	local matPadlock

	function TOOL:DrawToolScreen(w,h)
		if not matPadlock then
			matPadlock = CreateMaterial("bkeypads_persistence", "UnlitGeneric", {
				["$ignorez"] = 1,
				["$vertexalpha"] = 1,
				["$vertexcolor"] = 1,
				["$translucent"] = 1
			})
			matPadlock:SetTexture("$basetexture", matPadlockPNG:GetTexture("$basetexture"))
			matPadlock:Recompute()
		end

		surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
		surface.DrawRect(0,0,w,h)

		if not self.Matrix then
			self.Matrix = bKeypads_Matrix("STOOL_Screen", w, h)
		end
		self.Matrix:Draw(w,h)

		surface.SetDrawColor(bKeypads.COLOR.SLATE)
		surface.SetMaterial(matPadlock)
		surface.DrawTexturedRect((w - (w * .6)) / 2, (h - (h * .6)) / 2, w * .6, h * .6)

		if not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_persistent_keypads") then
			bKeypads:ToolScreenNoPermission(w, h)
		elseif NoneProfileActive() then
			bKeypads:ToolScreenWarning(bKeypads.L"NoneProfileToolscreen", w, h)
		end
	end
	
	do
		local function DrawLine(y, line)
			local w,h = surface.GetTextSize(line)
			y = y + h + 5

			surface.SetTextPos((ScrW() - w) / 2, y)
			surface.DrawText(line)

			return y
		end
		function TOOL:DrawHUD()
			if
				not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_persistent_keypads") and
				not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/switch_profile") and
				not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_profiles")
			then return end

			surface.SetFont("BudgetLabel")
			surface.SetTextColor(bKeypads.COLOR.GMODBLUE)

			local y = ScrH() / 2

			local tr = LocalPlayer():GetEyeTrace()
			if IsValid(tr.Entity) and tr.Entity.bKeypad then
				y = DrawLine(y, tr.Entity:GetKeypadName() == "" and bKeypads.L"Unnamed" or tr.Entity:GetKeypadName())
				if tr.Entity:GetPersist() then
					y = DrawLine(y, bKeypads.L"Persistent")
				else
					y = DrawLine(y, bKeypads.L"NotPersistent")
				end
			end

			if not NoneProfileActive() then
				if bKeypads.PersistenceProfileLastSaved then
					y = DrawLine(y, bKeypads.L("LastSaved"):format(bKeypads:FormatTimeDelta(os.time(), bKeypads.PersistenceProfileLastSaved)))
				end
				y = DrawLine(y, game.GetMap() .. "/profiles/" .. (bKeypads.PersistenceProfile or "UNKNOWN") .. ".json")
			end
		end
	end

	local matCheck = Material("icon16/accept.png")
	local function ProfilesPaintSelected(self)
		if not bKeypads.PersistenceProfile then return end
		for _, line in ipairs(self:GetLines()) do
			local profile = line:GetColumnText(2)
			if profile == bKeypads.PersistenceProfile then
				local x, y = self:ScreenToLocal(line:LocalToScreen(0, 0))
				surface.SetMaterial(matCheck)
				surface.DrawTexturedRect(x, y, 16, 16)
				break
			end
		end
	end

	function TOOL.BuildCPanel(CPanel)
		local L = bKeypads._L

		bKeypads:InjectSmoothScroll(CPanel)
		bKeypads:STOOLMatrix(CPanel)

		local Help = vgui.Create("DForm", CPanel)
			Help:SetExpanded(true)
			Help:SetLabel(L"Help")
			Help:Help(L"PersistenceHelp"):DockMargin(0, 0, 0, 0)
		CPanel:AddItem(Help)

		local Profiles
		local Profile = vgui.Create("DForm", CPanel)
			Profile:SetExpanded(true)
			Profile:SetLabel(L"Profile")

				local Save = vgui.Create("DButton", BtnContainer)
				Save:SetIcon("icon16/disk.png")
				Save:SetText(L"SavePersistentKeypads")
				Save.DoClick = function()
					if not bKeypads.Permissions:Check(LocalPlayer(), "persistence/manage_persistent_keypads") then return end

					surface.PlaySound("garrysmod/content_downloaded.wav")

					bKeypads.PersistenceProfileLastSaved = os.time()

					for i, line in ipairs(Profiles:GetLines()) do
						if line:GetColumnText(2) == bKeypads.PersistenceProfile then
							line:SetColumnText(3, os.date("%c"))
							break
						end
					end

					net.Start("bKeypads.Persistence.SaveProfile")
					net.SendToServer()
				end

			Profile:AddItem(Save)

				Profiles = vgui.Create("DListView", Profile)
				Profiles:SetTall(300)
				local checkedColumn = Profiles:AddColumn("") checkedColumn:SetMinWidth(16) checkedColumn:SetMaxWidth(16)
				Profiles:AddColumn(L"Profile")
				Profiles:AddColumn(L"LastUpdated")
				Profiles:SetMultiSelect(false)
				Profiles:SelectItem(Profiles:AddLine("", "default"))
				Profiles:AddLine("", "none")
				Profiles.PaintOver = ProfilesPaintSelected

			Profile:AddItem(Profiles)

				local BtnContainer = vgui.Create("DPanel", Profile)
				BtnContainer.Paint = nil

				local Switch = vgui.Create("DButton", BtnContainer)
				Switch:Dock(LEFT)
				Switch:DockMargin(0, 0, 10, 0)
				Switch:SetIcon("icon16/arrow_refresh.png")
				Switch:SetText(L"Switch")
				Switch:SetDisabled(true)
				Switch.DoClick = function()
					if not bKeypads.Permissions:Check(LocalPlayer(), "persistence/switch_profile") then return end

					surface.PlaySound("garrysmod/save_load" .. math.random(1,4) .. ".wav")

					net.Start("bKeypads.Persistence.SwitchProfile")
						net.WriteString(Profiles:GetLine(Profiles:GetSelectedLine()):GetColumnText(2))
					net.SendToServer()
				end

				local Delete = vgui.Create("DButton", BtnContainer)
				Delete:Dock(LEFT)
				Delete:SetIcon("icon16/delete.png")
				Delete:SetText(L"Delete")
				Delete:SetDisabled(true)
				Delete.DoClick = function()
					if not bKeypads.Permissions:Check(LocalPlayer(), "persistence/manage_profiles") then return end

					surface.PlaySound("friends/friend_join.wav")

					local profile = Profiles:GetLine(Profiles:GetSelectedLine()):GetColumnText(2)

					if profile ~= "default" then
						Profiles:RemoveLine(Profiles:GetSelectedLine())
					else
						Profiles:GetLine(1):SetColumnText(3, "")
					end

					if profile == bKeypads.PersistenceProfile then
						Profiles:SetSelected(Profiles:GetLine(1))
					end

					net.Start("bKeypads.Persistence.DeleteProfile")
						net.WriteString(profile)
					net.SendToServer()
				end

				BtnContainer.PerformLayout = function(self, w)
					local btn_w = (w - 10) / 2
					Switch:SetWide(btn_w)
					Delete:SetWide(btn_w)
				end
				
			Profile:AddItem(BtnContainer)
			BtnContainer:SetTall(25)

		CPanel:AddItem(Profile)

		CPanel._Think = CPanel.Think
		CPanel.Think = function(self)
			CPanel._Think(self)

			Save:SetDisabled(not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_persistent_keypads") or bKeypads.PersistenceProfile == "none")
			Delete:SetDisabled(not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_profiles") or Profiles:GetSelectedLine() == 2)
			Switch:SetDisabled(not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/switch_profile"))
		end

		hook.Add("bKeypads.Persistence.ProfileSwitched", "bKeypads.Persistence.CPanel", function(profile, time)
			local found = false
			local lines = Profiles:GetLines()
			for i, line in ipairs(lines) do
				if line:GetColumnText(2) == profile then
					found = true
					
					Profiles:SelectItem(line)
					if time then line:SetColumnText(3, os.date("%c", time)) end

					break
				end
			end
			
			if not found then
				Profiles:SelectItem(Profiles:AddLine("", profile, time and os.date("%c", time) or nil))
			end
		end)

		net.Receive("bKeypads.Persistence.DeleteProfile", function()
			if not IsValid(Profiles) then return end

			local profile = net.ReadString()
			if profile == "default" then
				Profiles:GetLine(1):SetColumnText(3, "")
				return
			end

			local lines = Profiles:GetLines()
			for i = 3, #lines, 1 do
				if lines[i]:GetColumnText(2) == profile then
					if Profiles:GetSelectedLine() == i then
						Profiles:SelectItem(Profiles:GetLine(1))
					end
					Profiles:RemoveLine(i)
					break
				end
			end
		end)

		net.Receive("bKeypads.Persistence.FetchProfiles", function()
			bKeypads.PersistenceProfile = net.ReadString()
			if net.ReadBool() then
				bKeypads.PersistenceProfileLastSaved = net.ReadUInt(32)
			end

			while net.ReadBool() do
				local profile = net.ReadString()
				if profile == "default" then
					Profiles:GetLine(1):SetColumnText(3, os.date("%c", net.ReadUInt(32)))
					Profiles:SelectItem(Profiles:GetLine(1))
				else
					local line = Profiles:AddLine("", profile, os.date("%c", net.ReadUInt(32)))
					if profile == bKeypads.PersistenceProfile then
						Profiles:SelectItem(line)
					end
				end
			end
		end)

		net.Start("bKeypads.Persistence.FetchProfiles")
			net.WriteBool(true)
		net.SendToServer()
		
		hook.Run("bKeypads.BuildCPanel", CPanel)
	end
	bKeypads_Persistence_BuildCPanel = TOOL.BuildCPanel

	net.Receive("bKeypads.Persistence.FetchProfiles", function()
		bKeypads.PersistenceProfile = net.ReadString()
		if net.ReadBool() then
			bKeypads.PersistenceProfileLastSaved = net.ReadUInt(32)
		end
	end)

	net.Receive("bKeypads.Persistence.SwitchProfile", function()
		local profile = net.ReadString()

		bKeypads.PersistenceProfile = profile

		local time
		if profile ~= "none" then
			time = net.ReadUInt(32)
			if time == 0 then time = nil end
		end
		hook.Run("bKeypads.Persistence.ProfileSwitched", profile, time)
		bKeypads.PersistenceProfileLastSaved = time
	end)

	hook.Add("bKeypads.Persistence.ProfileSwitched", "bKeypads.Persistence.ProfileSwitched.ChatMsg", function(profile)
		if (
			bKeypads.Permissions:Check(LocalPlayer(), "persistence/manage_persistent_keypads") or
			bKeypads.Permissions:Check(LocalPlayer(), "persistence/switch_profile") or
			bKeypads.Permissions:Check(LocalPlayer(), "persistence/manage_profiles")
		) then
			bKeypads:chat(bKeypads.L("ProfileSwitchedChat"):format(profile), bKeypads.PRINT_TYPE_SPECIAL, "PERSISTENCE")
		end
	end)
end

do
	if SERVER then
		util.AddNetworkString("bKeypads.PermaProps.No")
	else
		net.Receive("bKeypads.PermaProps.No", function()
			surface.PlaySound("common/warning.wav")
			Derma_Message(bKeypads.L"PermaProps_AlreadySaved", "Billy's Keypads", bKeypads.L"Dismiss")
		end)
	end

	local function Switch()
		surface.PlaySound("npc/combine_soldier/gear5.wav")
		RunConsoleCommand("gmod_tool", "bkeypads_persistence")
	end
	hook.Add("CanTool", "bKeypads.CanTool.Persistence", function(ply, tr, tool)
		if tool == "bkeypads_persistence" then
			return bKeypads.Permissions:Check(ply, "persistence/manage_persistent_keypads")
		elseif tool == "permaprops" then
			if IsValid(tr.Entity) then
				if tr.Entity.bKeypad or bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then
					if CLIENT and IsFirstTimePredicted() and ply == LocalPlayer() then
						surface.PlaySound("common/warning.wav")
						Derma_Query(bKeypads.L"PermaProps", "Billy's Keypads", bKeypads.L"Switch", Switch, bKeypads.L"Nevermind")
					end
					return false
				elseif SERVER and bKeypads_Persistence_SaveEntities[tr.Entity] then
					net.Start("bKeypads.PermaProps.No")
					net.Send(ply)
					return false
				end
			end
		end
	end)
end

hook.Add("CanProperty", "bKeypads.Persistentence.BlockSandbox", function(ply, prop, ent)
	if ent.bKeypad and (prop == "persist" or prop == "persist_end") then
		return false
	end
end)

do
	local persistence = bKeypads.ContextMenu:AddMember("#bKeypads_Persistence", "icon16/disk.png", function(self, ent, ply)
		if not IsValid(ent) or not ent.bKeypad then return false end

		local tr = util.TraceLine(util.GetPlayerTrace(ply))
		tr.Entity = ent
		if not gamemode.Call("CanTool", ply, tr, "bkeypads_persistence") then return false end

		return true
	end)

	local function PersistentKeypadOnly(self, ent, ply)
		return ent:GetPersist() == true
	end

	local function NonPersistentKeypadOnly(self, ent, ply)
		return ent:GetPersist() == false
	end

	persistence:AddMember("#tool.bkeypads_persistence.update", "icon16/arrow_refresh.png", PersistentKeypadOnly, function(self, ent, ply)
		if CLIENT then
			self:Network() self:Network()

			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.updated"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_GENERIC, 2)
			surface.PlaySound("garrysmod/ui_click.wav")
		else
			bKeypads.Persistence:CommitKeypad(ent)
			bKeypads.Persistence:WriteToFile()
		end
	end, true)

	persistence:AddMember("#stoppersisting", "icon16/lock_delete.png", PersistentKeypadOnly, function(self, ent, ply)
		if CLIENT then
			self:Network() self:Network()

			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.deleted"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_ERROR, 2)
			surface.PlaySound("friends/friend_join.wav")
		else
			bKeypads.Persistence:ForgetKeypad(ent)
		end
	end, true)

	persistence:AddMember("#makepersistent", "icon16/lock_add.png", NonPersistentKeypadOnly, function(self, ent, ply)
		if CLIENT then
			self:Network() self:Network()

			notification.AddLegacy(bKeypads.L("tool.bkeypads_persistence.notification.created"):format(bKeypads.PersistenceProfile or "UNKNOWN"), NOTIFY_GENERIC, 2)
			surface.PlaySound("garrysmod/ui_click.wav")
		else
			bKeypads.Persistence:SaveKeypad(ent)
		end
	end, true)
end
--lua/weapons/gmod_tool/stools/npctool_relationships.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Relationships"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	local D_HT = 1
	local D_FR = 2
	local D_LI = 3
	local D_NU = 4
	TOOL.ClientConVar["disposition"] = D_HT
	TOOL.ClientConVar["revert"] = 1
	language.Add("tool.npctool_relationships.name","NPC Relationships")
	language.Add("tool.npctool_relationships.desc","Change an NPC's relationship to another NPC or player")
	language.Add("tool.npctool_relationships.0","Left-Click to select a source NPC or player, Right-Click to apply the relationship to the target you're looking at, Reload to set yourself as target.")
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Relationships",Description = [[Left-Click to select a source NPC or player.
		Right-Click to apply the relationship to the target you're looking at.
		Reload to set yourself as target.
		]]})
		local lbl = vgui.Create("DLabel",pnl)
		lbl:SetColor(Color(0,0,0,255))
		lbl:SetText("Disposition:")
		
		local pCBox = vgui.Create("DComboBox",pnl)
		pCBox:AddChoice("Hate",D_HT,true)
		pCBox:AddChoice("Fear",D_FR)
		pCBox:AddChoice("Like",D_LI)
		pCBox:AddChoice("Neutral",D_NU)
		pCBox.OnSelect = function(pCBox,idx,val,data) RunConsoleCommand("npctool_relationships_disposition",data) end
		pCBox:SetWide(130)
		pnl:AddItem(lbl,pCBox)
		pnl:AddControl("CheckBox",{Label = "Revert",Command = "npctool_relationships_revert"})
	end
	local tbSelected = {}
	net.Receive("npctool_rel_add",function(len)
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local bSelected = net.ReadUInt(1) == 1
		if(!bSelected) then
			ent:StopParticles()
			for _,entTgt in ipairs(tbSelected) do
				if(entTgt == ent) then
					table.remove(tbSelected,_)
					break
				end
			end
		else
			ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
			table.insert(tbSelected,ent)
		end
	end)
	net.Receive("npctool_rel_set",function(len)
		local bMultiple = net.ReadUInt(1) == 1
		local src
		if(!bMultiple) then
			src = net.ReadEntity()
			if(!src:IsValid()) then return end
		end
		local tgt = net.ReadEntity()
		if(!tgt:IsValid()) then return end
		surface.PlaySound("buttons/button14.wav")
		local nameSrc
		if(!bMultiple) then nameSrc = language.GetPhrase("#" .. src:GetClass())
		else nameSrc = "Source NPCs" end
		local nameTgt
		if(tgt:IsPlayer()) then nameTgt = tgt:GetName()
		else nameTgt = language.GetPhrase("#" .. tgt:GetClass()) end
		local cvDisp = GetConVar("npctool_relationships_disposition")
		local cvRevert = GetConVar("npctool_relationships_revert")
		local disp = cvDisp:GetInt()
		local bRevert = cvRevert:GetBool()
		if(disp == D_HT) then disp = "Hate"
		elseif(disp == D_FR) then disp = "Fear"
		elseif(disp == D_LI) then disp = "Like"
		else disp = "Neutral" end
		notification.AddLegacy("Set disposition from " .. nameSrc .. " to " .. nameTgt .. " to '" .. disp .. "'.",0,8)
		if(bRevert && !tgt:IsPlayer()) then notification.AddLegacy("Set disposition from " .. nameTgt .. " to " .. nameSrc .. " to '" .. disp .. "'.",0,8) end
	end)
	net.Receive("npctool_relationships_deploy",function(len)
		for _,ent in ipairs(tbSelected) do
			if(ent:IsValid()) then
				ParticleEffectAttach("plate_green",PATTACH_ABSORIGIN_FOLLOW,ent,0)
			end
		end
	end)
	net.Receive("npctool_relationships_holster",function(len)
		for _,ent in ipairs(tbSelected) do
			if(ent:IsValid()) then ent:StopParticles() end
		end
	end)
else
	util.AddNetworkString("npctool_rel_add")
	util.AddNetworkString("npctool_rel_set")
	util.AddNetworkString("npctool_relationships_holster")
	util.AddNetworkString("npctool_relationships_deploy")
	function TOOL:Deploy()
		net.Start("npctool_relationships_deploy")
		net.Send(self:GetOwner())
	end
	function TOOL:ApplyDisposition(ent)
		local disp = self:GetClientNumber("disposition")
		local revert = self:GetClientNumber("revert")
		for _,src in ipairs(self.m_tbSelected) do
			src:AddEntityRelationship(ent,disp,100)
			if(revert != 0 && ent:IsNPC()) then
				ent:AddEntityRelationship(src,disp,100)
			end
		end
		local num = #self.m_tbSelected
		net.Start("npctool_rel_set")
			net.WriteUInt(num > 1 && 1 || 0,1)
			if(num == 1) then net.WriteEntity(self.m_tbSelected[1]) end
			net.WriteEntity(ent)
		net.Send(self:GetOwner())
	end
	function TOOL:CheckSource()
		if(!self.m_tbSelected) then return false end
		for i = #self.m_tbSelected,1,-1 do
			if(!self.m_tbSelected[i]:IsValid()) then
				table.remove(self.m_tbSelected,i)
			end
		end
		if(#self.m_tbSelected == 0) then
			local l = "notification.AddLegacy(\"No source NPCs selected.\",1,8);"
			l = l .. "surface.PlaySound(\"buttons/button10.wav\")"
			self:GetOwner():SendLua(l)
			return false
		end
		return true
	end
end

function TOOL:LeftClick(tr)
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		if(CLIENT) then return true end
		self.m_tbSelected = self.m_tbSelected || {}
		net.Start("npctool_rel_add")
		net.WriteEntity(tr.Entity)
		for _,ent in ipairs(self.m_tbSelected) do
			if(ent == tr.Entity) then
				self:GetOwner():SendLua("notification.AddLegacy(language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\") .. \" deselected.\",0,8)")
				table.remove(self.m_tbSelected,_)
				net.WriteUInt(0,1)
				net.Send(self:GetOwner())
				return
			end
		end
		self:GetOwner():SendLua("notification.AddLegacy(language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\") .. \" selected.\",0,8)")
		table.insert(self.m_tbSelected,tr.Entity)
		net.WriteUInt(1,1)
		net.Send(self:GetOwner())
		return true
	end
	return false
end

function TOOL:RightClick(tr)
	if(!tr.Entity:IsValid() || (!tr.Entity:IsNPC() && !tr.Entity:IsPlayer())) then return false end
	if(CLIENT) then return true end
	if(!self:CheckSource()) then return false end
	self:ApplyDisposition(tr.Entity)
	return true
end

function TOOL:Reload(tr)
	if(CLIENT) then return true end
	if(!self:CheckSource()) then return false end
	self:ApplyDisposition(self:GetOwner())
end

function TOOL:Holster()
	if(CLIENT) then return end
	net.Start("npctool_relationships_holster")
	net.Send(self:GetOwner())
end
--lua/weapons/gmod_tool/stools/teleporter_adv.lua:
-- Teleporter STool
-- By Anya O'Quinn / Slade Xanthas

AddCSLuaFile()

if SERVER then
	CreateConVar("sbox_maxteleporters_adv", 10)
end

if CLIENT then
    language.Add("tool.teleporter_adv.name", 	"Teleporter")
    language.Add("tool.teleporter_adv.desc", 	"Spawn a Teleporter")
    language.Add("tool.teleporter_adv.0", 		"Primary: Create/Update Teleporter you're looking at.  Spawn two teleporters to make a set.")
	language.Add("Cleanup_teleporters_adv", 	"Teleporters")
	language.Add("Cleaned_teleporters_adv", 	"Cleaned up all Teleporters")
	language.Add("Undone_teleporter_adv", 		"Undone Teleporter")
	language.Add("SBoxLimit_teleporters_adv", 	"You've hit Teleporter limit!")
end

TOOL.Name							= "#tool.teleporter_adv.name"
TOOL.Category						= "Construction"
TOOL.ConfigName						= ""
TOOL.ClientConVar["model"] 			= "models/Items/combine_rifle_ammo01.mdl"
TOOL.ClientConVar["sound"] 			= "ambient/levels/citadel/weapon_disintegrate2.wav"
TOOL.ClientConVar["effect"] 		= "sparks"
TOOL.ClientConVar["radius"] 		= "100"
TOOL.ClientConVar["height"] 		= "50"
TOOL.ClientConVar["ontouch"] 		= "0"
TOOL.ClientConVar["onuse"] 			= "0"
TOOL.ClientConVar["showbeam"] 		= "1"
TOOL.ClientConVar["showradius"] 	= "1"
TOOL.ClientConVar["key"] 			= "1"

cleanup.Register("teleporters_adv")

list.Set("TeleporterModels", "models/Items/combine_rifle_ammo01.mdl", {})
list.Set("TeleporterModels", "models/props_c17/clock01.mdl", {})
list.Set("TeleporterModels", "models/props_junk/sawblade001a.mdl", {})
list.Set("TeleporterModels", "models/props_combine/combine_mine01.mdl", {})
list.Set("TeleporterModels", "models/props_wasteland/prison_toilet01.mdl", {})
list.Set("TeleporterModels", "models/props_lab/teleplatform.mdl", {})

list.Set("TeleporterSounds", "None", 				{teleporter_adv_sound = ""})
list.Set("TeleporterSounds", "Teleport 1", 			{teleporter_adv_sound = "ambient/machines/teleport1.wav"})
list.Set("TeleporterSounds", "Teleport 2", 			{teleporter_adv_sound = "ambient/machines/teleport3.wav"})
list.Set("TeleporterSounds", "Teleport 3", 			{teleporter_adv_sound = "ambient/machines/teleport4.wav"})
list.Set("TeleporterSounds", "Zap 1", 				{teleporter_adv_sound = "ambient/machines/zap1.wav"})
list.Set("TeleporterSounds", "Zap 2", 				{teleporter_adv_sound = "ambient/machines/zap2.wav"})
list.Set("TeleporterSounds", "Zap 3", 				{teleporter_adv_sound = "ambient/machines/zap3.wav"})
list.Set("TeleporterSounds", "Disintegrate 1", 		{teleporter_adv_sound = "ambient/levels/citadel/weapon_disintegrate1.wav"})
list.Set("TeleporterSounds", "Disintegrate 2", 		{teleporter_adv_sound = "ambient/levels/citadel/weapon_disintegrate2.wav"})
list.Set("TeleporterSounds", "Disintegrate 3", 		{teleporter_adv_sound = "ambient/levels/citadel/weapon_disintegrate3.wav"})
list.Set("TeleporterSounds", "Disintegrate 4", 		{teleporter_adv_sound = "ambient/levels/citadel/weapon_disintegrate4.wav"})

list.Set("TeleporterEffects", "Prop Spawn", 		{teleporter_adv_effect = "propspawn"})
list.Set("TeleporterEffects", "Explosion", 			{teleporter_adv_effect = "explosion"})
list.Set("TeleporterEffects", "Sparks", 			{teleporter_adv_effect = "sparks"})
list.Set("TeleporterEffects", "None", 				{teleporter_adv_effect = ""})

local function MakeTeleporter(ply, pos, Ang, model, sound, effect, radius, height, ontouch, onuse, showbeam, showradius, key)

	if not SERVER or not IsValid(ply) then return end
	if not ply:CheckLimit("teleporters_adv") then return false end

	local teleporter = ents.Create("gmod_advteleporter")
	if not IsValid(teleporter) then return false end	

	teleporter:SetAngles(Ang)
	teleporter:SetPos(pos)
	teleporter:SetModel(Model(model))
	teleporter:Spawn()	
	teleporter.Owner = ply
	teleporter:Setup(model, sound, effect, radius, height, ontouch, onuse, showbeam, showradius, key)
	
	numpad.OnDown(ply, key, "Teleporter_On", teleporter)
	numpad.OnUp(ply, key, "Teleporter_Off", teleporter)

	local ttable = {
		model = model,
		sound = sound,
		effect = effect,
		radius = radius,
		height = height,
		ontouch = ontouch,
		onuse = onuse,
		showbeam = showbeam,
		showradius = showradius,
		key = key,
	}
	
	table.Merge(teleporter:GetTable(), ttable)
	ply:AddCount("teleporters_adv", teleporter)
	DoPropSpawnedEffect(teleporter)

	return teleporter

end

duplicator.RegisterEntityClass("gmod_advteleporter", MakeTeleporter, "pos", "ang", "model", "sound", "effect", "radius", "height", "ontouch", "onuse", "showbeam", "showradius", "key")

function TOOL:LeftClick(trace)

	if not trace.Hit then return false end
	
	local ent = trace.Entity

	if IsValid(ent) and ent:IsPlayer() then return false end
	if SERVER and not util.IsValidPhysicsObject(ent,trace.PhysicsBone) then return false end
	if CLIENT then return true end
	
	local ply = self:GetOwner()
	local model = self:GetClientInfo("model")
	local sound = self:GetClientInfo("sound")
	local effect = self:GetClientInfo("effect")
	local radius = math.Clamp(self:GetClientNumber("radius"),16,512)
	local height = math.Clamp(self:GetClientNumber("height"),1,100)
	local ontouch = (self:GetClientNumber("ontouch") == 1)
	local onuse = (self:GetClientNumber("onuse") == 1)
	local showbeam = (self:GetClientNumber("showbeam") == 1)
	local showradius = (self:GetClientNumber("showradius") == 1)
	local key = self:GetClientNumber("key")
	
	if IsValid(ent) and ent:GetClass() == "gmod_advteleporter" then
	
		ent:Setup(model, sound, effect, radius, height, ontouch, onuse, showbeam, showradius, key)
		
		local ttable = {
			model = model,
			sound = sound,
			effect = effect,
			radius = radius,
			height = height,
			ontouch = ontouch,
			onuse = onuse,
			showbeam = showbeam,
			showradius = showradius,
			key = key,
		}
		
		table.Merge(ent:GetTable(), ttable)
		return true
		
	end
	
	if not self:GetSWEP():CheckLimit("teleporters_adv") then return false end
	
	local pos = trace.HitPos
	local ang = trace.HitNormal:Angle()
	ang.pitch = ang.pitch + 90
	
	local teleporter = MakeTeleporter(ply, pos, ang, model, sound, effect, radius, height, ontouch, onuse, showbeam, showradius, key)
	
	if not IsValid(teleporter) then return end

	local min = teleporter:OBBMins()
	teleporter:SetPos(trace.HitPos - trace.HitNormal * min.z)
	
	if not teleporter:IsInWorld() then 
		teleporter:Remove() 
		return false 
	end

	if trace.HitWorld then teleporter:GetPhysicsObject():EnableMotion(false) end
	
	if IsValid(ent) then
		local const = constraint.Weld(teleporter, ent, trace.PhysicsBone, 0, 0)
		local nocollide = constraint.NoCollide(teleporter, ent, 0, trace.PhysicsBone)
		ent:DeleteOnRemove(teleporter)
	end

	undo.Create("teleporter_adv")
		undo.AddEntity(teleporter)
		undo.AddEntity(const)
		undo.AddEntity(nocollide)
		undo.SetPlayer(ply)
	undo.Finish()

	ply:AddCleanup("teleporters_adv", teleporter)
	ply:AddCleanup("teleporters_adv", const)
	ply:AddCleanup("teleporters_adv", nocollide)
	
	return true
	
end

function TOOL:RightClick(trace)
	return false
end

function TOOL:Reload(trace)
	return false
end

function TOOL:UpdateGhostEntity(ent, ply)

	if not IsValid(ent) then return end

	local tr = ply:GetEyeTrace()

	if not tr.Hit or IsValid(tr.Entity) and tr.Entity:GetClass() == "gmod_advteleporter" or tr.Entity:IsPlayer() then
		ent:SetNoDraw(true)
		return
	end

	local ang = tr.HitNormal:Angle()
	ang.pitch = ang.pitch + 90

	local min = ent:OBBMins()
	ent:SetPos(tr.HitPos - tr.HitNormal * min.z)
	ent:SetAngles(ang)

	ent:SetNoDraw(false)
	
end

function TOOL:Think()

	if not IsValid(self.GhostEntity) or (IsValid(self.GhostEntity) and self.GhostEntity:GetModel() ~= self:GetClientInfo("model")) then
		self:MakeGhostEntity(self:GetClientInfo("model"), Vector(0,0,0), Angle(0,0,0))
	end
	
	self:UpdateGhostEntity(self.GhostEntity, self:GetOwner())
	
end

function TOOL.BuildCPanel(CPanel)

	CPanel:AddControl("Header", {Text = "#Tool.teleporter_adv.name", Description = "#Tool.teleporter_adv.desc"})

	local Options = {
		Default = {
			teleporter_adv_model 		= "models/Items/combine_rifle_ammo01.mdl",
			teleporter_adv_sound 		= 0,
			teleporter_adv_ontouch		= 0,
			teleporter_adv_onuse 		= 0,
			teleporter_adv_key 			= 1
		}
	}
	
	local CVars = {
		"teleporter_adv_model",
		"teleporter_adv_sound",
		"teleporter_adv_effect",
		"teleporter_adv_radius",
		"teleporter_adv_height",
		"teleporter_adv_ontouch",
		"teleporter_adv_onuse",
		"teleporter_adv_showbeam",
		"teleporter_adv_showradius",
		"teleporter_adv_key"
	}
		
	CPanel:AddControl("ComboBox",
		{
			Label = "#Presets", 
			MenuButton = 1, 
			Folder = "teleporter_adv", 
			Options = Options, 
			CVars = CVars
		} 
	)

	CPanel:AddControl("PropSelect",
		{
			Label = "Model:",
			ConVar = "teleporter_adv_model",
			Category = "Teleporters",
			Models = list.Get("TeleporterModels")
		}
	)			
	
	CPanel:AddControl("Numpad",
		{
			Label = "Key:",
			Command = "teleporter_adv_key",
			ButtonSize = 22
		}
	)

 	CPanel:AddControl("Slider",
		{
			Label = "Teleport Radius:",
			Command = "teleporter_adv_radius",
			min = 16,
			max = 512
		}
	)

	CPanel:AddControl("Slider",
	{
		Label = "Teleport Height:",
		Command = "teleporter_adv_height",
		min = 1,
		max = 100
	}
)
	
	CPanel:AddControl("Label", {Text = "Teleport Sound:"})
	
 	CPanel:AddControl("ComboBox",
		{
			Label = "Teleport Sound:",
			MenuButton = 0,
			Command = "teleporter_adv_sound",
			Options = list.Get("TeleporterSounds")
		}
	)		

	CPanel:AddControl("Label", {Text = "Teleport Effect:"})
	
 	CPanel:AddControl("ComboBox",
		{
			Label = "Teleport Effect:",
			MenuButton = 0,
			Command = "teleporter_adv_effect",
			Options = list.Get("TeleporterEffects")
		}
	)

	CPanel:AddControl("CheckBox",
		{
			Label = "Teleport On Touch",
			Command = "teleporter_adv_ontouch"
		}
	)	
	
	CPanel:AddControl("CheckBox",
		{
			Label = "Teleport On Use",
			Command = "teleporter_adv_onuse"
		}
	)
	
	CPanel:AddControl("CheckBox",
		{
			Label = "Show Beam",
			Command = "teleporter_adv_showbeam"
		}
	)
	
	CPanel:AddControl("CheckBox",
		{
			Label = "Show Teleport Radius",
			Command = "teleporter_adv_showradius"
		}
	)

end

-- 37062385
--addons/ballistic_shields/lua/weapons/heavy_shield_dooms/shared.lua:
SWEP.Base = "heavy_shield"
SWEP.PrintName = "Schweres Schild (DU)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Angreifen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild_hit.mdl", skin = 0, bodygroup = {} }
}

SWEP.shieldEnt = "bs_hshield_dooms"
--addons/ballistic_shields/lua/weapons/heavy_shield_senat/shared.lua:
SWEP.Base = "heavy_shield"
SWEP.PrintName = "Schweres Schild (Senat)"
SWEP.Category = "SW:RP Shields"

SWEP.Author	= "GangsterDom, Deltaa"
SWEP.Instructions = "LMB - Angreifen | RMB - Sichtbarkeit ein- und ausschalten"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/egm_schild.mdl"

SWEP.WElements = {
	["placeholder"] = { type = "Model", model = "models/bshields/egm_schild_hit.mdl", skin = 2, bodygroup = {} }
}

SWEP.shieldEnt = "bs_hshield_senat"
--addons/mortar/lua/weapons/mortar_constructor_dark.lua:
-- Disabled
--addons/greifhaken/lua/weapons/realistic_hook.lua:
// A more realistic grappling hook

if SERVER then
	AddCSLuaFile()
	util.AddNetworkString( "realistic_hook BreakFree" )
end

SWEP.Base = "weapon_base"

SWEP.PrintName = "Grappling Hook"
SWEP.Category = "_Hat's Weapons"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Fire to launch the hook"

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModelFOV = 80
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.ViewModelFlip   = false

SWEP.WorldModel = "models/weapons/w_alyx_gun.mdl"
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.CanDrop = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.05

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1
SWEP.Secondary.Delay = 0.5

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "pistol"

---- For TTT
SWEP.Kind = WEAPON_EQUIP
SWEP.AutoSpawnable      = false
SWEP.AmmoEnt = "none"
SWEP.NoSights = true
SWEP.EquipMenuData = {
	type = "item_weapon",
	desc = "A grappling hook.\n\nScale walls or grab things from afar."
};

SWEP.Icon = "entities/realistic_hook"
if SERVER then resource.AddFile( "materials/"..SWEP.Icon..".vmt" ) end
----

--Standard swep functions--
---------------------------
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Hook" )
	
	self:NetworkVar( "Int", 0, "Cooldown" )
end

function SWEP:Initialize()
	hook.Add( "SetupMove", self, self.PlayerMove )
	--hook.Add( "Tick", self, self.Tick )
	
	if CLIENT then
		self.VElements = table.FullCopy( self.VElements )
		self:CreateModels(self.VElements) // create viewmodels

		hook.Add( "PostDrawOpaqueRenderables", self, self.VMDraw )
	end
	
	if SERVER then
		local timerName = tostring(self).." Hook Broken Cooldown"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetCooldown( math.Approach(self:GetCooldown(), 0, 2) )
		end)
	end
	
	return self.BaseClass.Initialize( self )
end
function SWEP:PrimaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT and (not IsFirstTimePredicted()) then return end
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( math.Approach( hk:GetDist(), 0, 10 ) ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:SecondaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( hk:GetDist() + 10 ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:Reload()
	if SERVER and IsValid(self:GetHook()) then
		if self:GetHook():GetDurability()>0 then
			self:SetCooldown( self:GetHook():GetDurability()+20 )
		else
			self:SetCooldown(10)
		end
		self:GetHook():Remove()
	end
end

-- Handling the hook entity --
------------------------------
function SWEP:LaunchHook()
	if not cvars.Bool( "hatshook_physics" ) then return self:LaunchInstant() end
	if not IsValid( self.Owner ) then return end
	
	//self:EmitSound( "physics/metal/metal_box_impact_bullet"..math.random(1,3)..".wav" )
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", self.Owner:GetShootPos(), 75, 100, 0.5 )
	self.Owner:ViewPunch( Angle( math.Rand(-5,-2.5), math.Rand(-2,2), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( self.Owner:GetShootPos() - self.Owner:GetAimVector()*10 )
	local ang = self.Owner:EyeAngles()
	ang:RotateAroundAxis( ang:Up(), 90 )
	hk:SetAngles( ang )
	hk.FireVelocity = self.Owner:GetAimVector() * 500
	hk:SetOwner( self.Owner )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
end

function SWEP:GetFilter()
	return cvars.Bool( "hatshook_hookplayers" ) and {self.Owner} or player.GetAll()
end
function SWEP:LaunchInstant()
	if not IsValid( self.Owner ) then return end
	
	local tr = util.TraceLine({
		start=self.Owner:GetShootPos(),
		endpos=self.Owner:GetShootPos()+(self.Owner:GetAimVector()*cvars.Number("hatshook_speed")),
		filter=self:GetFilter()
	})
	if tr.HitSky or not tr.Hit then return end
	
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", self.Owner:GetShootPos(), 75, 100, 0.5 )
	self.Owner:ViewPunch( Angle( math.Rand(-10,-5), math.Rand(-4,4), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( tr.HitPos )
	hk:SetAngles( tr.Normal:Angle() )
	hk.FireVelocity = Vector(0,0,0)
	hk:SetOwner( self.Owner )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
	
	hk:PhysicsCollide( {HitEntity=tr.Entity, HitPos=tr.HitPos, HitNormal=tr.Normal} )
end

local HookCable = Material( "cable/cable2" )
function SWEP:DrawRope( attPos )
	if not attPos then return end
	
	
	local hk = self:GetHook()
	if not IsValid(hk) then return end
	
	if self.Owner~=LocalPlayer() or hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return hk:Draw() end
	
	if IsValid( hk:GetTargetEnt() ) then
		local bpos, bang = hk:GetTargetEnt():GetBonePosition( hk:GetFollowBone() )
		local npos, nang = hk:GetFollowOffset(), hk:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			hk:SetPos( npos )
			hk:SetAngles( nang )
		end
	end
	
	render.SetMaterial( HookCable )
	render.DrawBeam( hk:GetPos(), attPos, 1, 0, 2, Color(255,255,255,255) )
end
function SWEP:DrawWorldModel()
	self:DrawModel()
	local att = self:GetAttachment( 1 )
	self:DrawRope( att.Pos )
end
function SWEP:VMDraw()
	if not (self.Owner==LocalPlayer() and self.Owner:GetActiveWeapon()==self and hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner)~=false) then return end
	
	local vm = IsValid( self.Owner ) and self.Owner:GetViewModel()
	local pos = self:GetPos()
	if IsValid(vm) and vm:GetAttachment( 1 ) then pos = vm:GetAttachment( 1 ).Pos end
	
	self:DrawRope( pos )
end

-- HUD Stuff --
---------------
local function ShadowText( txt, x, y )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
function SWEP:DrawHUD()
	if IsValid( self:GetHook() ) and self:GetHook():GetHasHit() then
		ShadowText( "Rope length: "..tostring(self:GetHook():GetDist()), ScrW()/2, ScrH()/2+40 )
		ShadowText( (input.LookupBinding("+attack") or "[PRIMARY FIRE]"):upper() .. " - Retract rope", ScrW()/2, ScrH()/2+70 )
		ShadowText( (input.LookupBinding("+attack2") or "[SECONDARY FIRE]"):upper() .. " - Extend rope", ScrW()/2, ScrH()/2+85 )
		ShadowText( (input.LookupBinding("+reload") or "[RELOAD]"):upper() .. " - Break rope", ScrW()/2, ScrH()/2+100 )
		
		if IsValid( self:GetHook():GetTargetEnt() ) and self:GetHook():GetTargetEnt():IsPlayer() then
			DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)+20, 140, 15, self:GetHook():GetDurability() )
		else
			ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Jump off", ScrW()/2, ScrH()/2+115 )
		end
	elseif self:GetCooldown()>0 then
		DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)+20, 140, 15, self:GetCooldown() )
	end
	
	return self.BaseClass.DrawHUD( self ) // TTT Crosshair is drawn here, we have to call it
end

-- Movement Handling --
-----------------------
local function ValidPullEnt(ent)
	if (not IsValid(ent)) or ent:IsPlayer() then return false end
	local phys = ent:GetPhysicsObject()
	
	return (not IsValid(phys)) or ((not phys:HasGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)) and (phys:GetMass()<=50) and (ent.CanPickup!=false) and phys:IsMotionEnabled())
end

function SWEP:PlayerMove( ply, mv, cmd )
	if not (IsValid(self:GetHook()) and self:GetHook().GetHasHit and self:GetHook():GetHasHit()) then return end
	if not (IsValid(self.Owner) and IsValid(ply) and self.Owner:Alive() and ply:Alive()) then return end
	
	local hk = self:GetHook()
	
	if (IsValid(hk:GetTargetEnt()) and hk:GetTargetEnt()~=self and ply~=hk:GetTargetEnt() and (hk:GetTargetEnt():IsPlayer() or ValidPullEnt(hk:GetTargetEnt()))) then return end
	if (hk:GetTargetEnt()==hk or (not (ValidPullEnt(hk:GetTargetEnt()) or hk:GetTargetEnt():IsPlayer()))) and ply~=self.Owner then return end
	
	if not (ply.InVehicle and self.Owner.InVehicle) then hk:Remove() self:SetCooldown(10) return end // What
	if ply:InVehicle() or self.Owner:InVehicle() or (not ply:Alive()) then hk:Remove() self:SetCooldown(10) return end
	
	if ply~=self.Owner then
		ply.was_pushed = {t=CurTime(),att=self.Owner}
	end
	
	if ply:KeyPressed( IN_USE ) and ply==self.Owner then
		if hk:GetPos()[3] > ply:GetShootPos()[3] then
			mv:SetVelocity( mv:GetVelocity() + Vector(0,0,300) )
		end
		
		if SERVER then self:SetCooldown(10) hk:Remove() end
	end
	
	local TargetPoint = hk:GetPos()
	local ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
	local ShootPos = self.Owner:GetShootPos() + (Vector(0,0, (self.Owner:Crouching() and 0) or (hk:GetUp()[1]>0.9 and -45) or 0))
	local Distance = hk:GetDist()
	
	if ply~=self.Owner then // Swap direction
		TargetPoint = ShootPos
		ShootPos = ply:GetShootPos() + (Vector(0,0, (ply:Crouching() and 0) or (hk:GetUp()[1]>0.9 and -45) or 0))
		ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
	end
	
	local DistFromTarget = ShootPos:Distance( TargetPoint )
	if DistFromTarget<(Distance+5) then return end // 5 units off actual distance
	local TargetPos = TargetPoint - (ApproachDir*Distance)
	
	local xDif = math.abs(ShootPos[1] - TargetPos[1])
	local yDif = math.abs(ShootPos[2] - TargetPos[2])
	local zDif = math.abs(ShootPos[3] - TargetPos[3])
	
	--local speedMult = ((DistFromTarget*0.01)^1.1)
	local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
	local vertMult = math.max((math.Max(300-(xDif + yDif), -10)*0.08)^1.01  + (zDif/2),0)
	if ply~=self.Owner and self.Owner:GetGroundEntity()==ply then vertMult = -vertMult end
	
	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1] = TargetVel[1]*speedMult
	TargetVel[2] = TargetVel[2]*speedMult
	TargetVel[3] = TargetVel[3]*vertMult
	local dir = mv:GetVelocity()
	
	local clamp = 50
	local vclamp = 20
	local accel = 200
	local vaccel = 30*(vertMult/50)
	
	dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
	dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
	
	if ShootPos[3]<TargetPos[3] then
		dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		
		if vertMult>0 then self.ForceJump=ply end
	end
	
	mv:SetVelocity( dir )
	//return mv
end

local function ForceJump( ply )
	if not (IsValid(ply) and ply:IsPlayer()) then return end
	if not ply:OnGround() then return end
	
	local tr = util.TraceLine( {start = ply:GetPos(), endpos = ply:GetPos()+Vector(0,0,20), filter = ply} )
	if tr.Hit then return end
	
	ply:SetPos(ply:GetPos()+Vector(0,0,5) )
end
function SWEP:Think()
	if self.ForceJump then
		if IsValid(self.Owner) and self.ForceJump==self.Owner then
			ForceJump( self.Owner )
		elseif IsValid( self:GetHook() ) and IsValid( self:GetHook():GetTargetEnt() ) and self.ForceJump == self:GetHook():GetTargetEnt() then
			ForceJump( self.ForceJump )
		end
		self.ForceJump = nil
	end
	if SERVER then self:EntityPull() end
end

function SWEP:EntityPull() // For pulling entities
	local hk = self:GetHook()
	if IsValid(self.Owner) and IsValid(hk) and hk.GetTargetEnt and IsValid(hk:GetTargetEnt()) and ValidPullEnt(hk:GetTargetEnt()) then
		local ply = hk:GetTargetEnt()
		local phys = ply:GetPhysicsObject()
		if ply:IsPlayer() or (not IsValid(phys)) then return end
		
		local TargetPoint = self.Owner:GetShootPos()
		local ShootPos = ply:GetPos()
		local ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
		local Distance = hk:GetDist()
		
		local DistFromTarget = ShootPos:Distance( TargetPoint )
		if DistFromTarget<(Distance+5) then return end
		local TargetPos = TargetPoint - (ApproachDir*Distance)
		
		local xDif = math.abs(ShootPos[1] - TargetPos[1])
		local yDif = math.abs(ShootPos[2] - TargetPos[2])
		local zDif = math.abs(ShootPos[3] - TargetPos[3])
		
		--local speedMult = ((DistFromTarget*0.01)^1.1)
		local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
		local vertMult = math.max((math.Max(100-(xDif + yDif), -10)*0.1)^1.01  + (zDif/2), 0)
		if self.Owner:GetGroundEntity()==ply then vertMult = -vertMult end
		
		local TargetVel = (TargetPos - ShootPos):GetNormal() * 6 * (1 - (phys:GetMass()/50))
		TargetVel[1] = TargetVel[1]*speedMult
		TargetVel[2] = TargetVel[2]*speedMult
		TargetVel[3] = TargetVel[3]*vertMult
		local dir = ply:GetVelocity()
		
		local clamp = 50
		local vclamp = 20
		local accel = 200
		local vaccel = 40*(vertMult/50)
		
		dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
		dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
		
		if ShootPos[3]<TargetPos[3] and vertMult~=0 then
			dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		end
		
		phys:SetVelocity( dir )
	end
end


SWEP.VElements = {
	["gun"] = { type = "Model", model = "models/weapons/w_alyx_gun.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(1.1, -1.1, -1.4), angle = Angle(-100, 146, 68), size = Vector(1,1,1), color = Color(255, 255, 255, 255) }
}
-- SWEP Construction Kit code by Clavus, removed everything I don't need. http://facepunch.com/threads/1032378 --
-----------------------------------------------------------------------------------------------------------------
function SWEP:ViewModelDrawn()
	if not IsValid( self.Owner ) then return end
	local vm = self.Owner:GetViewModel()
	if !IsValid(vm) then return end
	
	if (!self.VElements) then return end
	for k, v in pairs( self.VElements ) do
		if not file.Exists( v.model, "GAME" ) then continue end
		local model = v.modelEnt
		
		if (!v.bone) then continue end
		
		local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
		if (!pos) then continue end
		
		if IsValid(model) then
			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix( "RenderMultiply", matrix )
			
			model:SetMaterial("")
			
			render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
			render.SetBlend(v.color.a/255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)
		end
	end
end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
	local bone, pos, ang
	bone = ent:LookupBone(bone_override or tab.bone)
	
	if (!bone) then return end
	
	pos, ang = Vector(0,0,0), Angle(0,0,0)
	local m = ent:GetBoneMatrix(bone)
	if (m) then pos, ang = m:GetTranslation(), m:GetAngles() end
	
	if (IsValid(self.Owner) and self.Owner:IsPlayer() and ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
		ang.r = -ang.r // Fixes mirrored models
	end
	
	return pos, ang
end

function SWEP:CreateModels( tab )
	if (!tab) then return end
	for k, v in pairs( tab ) do
		if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and  string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
			v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
			if (IsValid(v.modelEnt)) then
				v.modelEnt:SetPos(self:GetPos())
				v.modelEnt:SetAngles(self:GetAngles())
				v.modelEnt:SetParent(self)
				v.modelEnt:SetNoDraw(true)
				v.createdModel = v.model
			else
				v.modelEnt = nil
			end
		end
	end
end

function table.FullCopy( tab )
	if (!tab) then return nil end
	local res = {}
	for k, v in pairs( tab ) do
		if (type(v) == "table") then res[k] = table.FullCopy(v)
		elseif (type(v) == "Vector") then res[k] = Vector(v.x, v.y, v.z)
		elseif (type(v) == "Angle") then res[k] = Angle(v.p, v.y, v.r)
		else res[k] = v end
	end
	return res
end

// Make a TTT Swep from what we've got
local TTTSwep = table.Copy( SWEP ) // It's the same as the normal swep, copy over the table
TTTSwep.Base = "weapon_tttbase" // Using TTT weapon base
TTTSwep.Slot = 6 // Put it in the proper slot

TTTSwep.Spawnable = false // Make the TTT version hidden, so people don't accidentally spawn it
TTTSwep.AdminOnly = false
TTTSwep.AdminSpawnable = false

TTTSwep.CanBuy = {ROLE_TRAITOR, ROLE_DETECTIVE} // Make it buyable
weapons.Register( TTTSwep, "ttt_realistic_hook" ) // Register the new weapon

--addons/ballistic_shields/lua/weapons/riot_shield/shared.lua:
if SERVER then 
	include( "ballistic_shields/sh_bs_util.lua" ) 
	include( "ballistic_shields/sv_bs_util.lua" ) 
end
include( "bs_config.lua" ) 
include( "ballistic_shields/sh_bs_lang.lua" ) 

SWEP.PrintName = "Riot shield"
SWEP.Author	= "D3G"
SWEP.Instructions = "LMB - Attack | RMB - Toggle visibility"
SWEP.Spawnable = false
SWEP.AdminOnly = true

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/rshield.mdl"

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 5
SWEP.SlotPos = 0
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = "SW:RP Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55

local SwingSound = Sound( "WeaponFrag.Throw" )
local HitSound = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()
	self:SetHoldType("melee2")
end

function SWEP:DrawWorldModel()
	self:SetNoDraw( true ) 
end

local function bsGetHoldType(ply)
	if (ply:LookupAttachment( "anim_attachment_RH" )>0) then return {1,"anim_attachment_RH"} end
	if (ply:LookupAttachment( "forward" )>0) then return {2,"forward"} end
	return {3, "anim_attachment_head"}
end

local ShieldIcon = Material("bshields/ui/riot_shield", "smooth")
local BackgroundIcon = Material("bshields/ui/background")
function SWEP:DrawHUD()
	if(bshields.config.disablehud) then return end
	surface.SetDrawColor(255,255,255,200)	
	surface.SetMaterial(BackgroundIcon)
	surface.DrawTexturedRect( ScrW()/2-ScrH()/10, ScrH()/2-ScrH()/30+ScrH()/3, ScrH()/5, ScrH()/15)
	surface.SetDrawColor(255,255,255,125)
	draw.SimpleTextOutlined( bshields.lang[bshields.config.language].rshieldprim, "bshields.HudFont", ScrW()/2-ScrH()/32, ScrH()/2-ScrH()/28+ScrH()/3+ScrH()/22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255)) 
	surface.SetMaterial(ShieldIcon)
	surface.DrawTexturedRect( ScrW()/2-ScrH()/10.2, ScrH()/2-ScrH()/32+ScrH()/3, ScrH()/16, ScrH()/16) 
	if(self.VisToggle) then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW()/2-ScrH()/32, ScrH()/2-ScrH()/28+ScrH()/3+ScrH()/48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255)) 
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW()/2-ScrH()/32, ScrH()/2-ScrH()/28+ScrH()/3+ScrH()/48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255)) 
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false
	if SERVER then
		local owner = self.Owner
		local holdtype = bsGetHoldType(owner)
		bshield_remove(owner)
		owner.bs_type = 2
		owner.bs_shield = ents.Create("bs_rshield")
		owner.bs_shield:SetCollisionGroup( COLLISION_GROUP_DEBRIS  )
		owner.bs_shield:SetMoveType( MOVETYPE_NONE ) 
		owner.bs_shield:SetPos(owner:GetPos())
		owner.bs_shield:SetParent( owner, owner:LookupAttachment(holdtype[2])) 
		owner.bs_shield:SetLocalAngles( bshields.shields[holdtype[1]][3].angles ) 
		owner.bs_shield:SetLocalPos( bshields.shields[holdtype[1]][3].position ) 
		owner.bs_shield:Spawn()
	   	net.Start( "bs_shield_info" )
	   		net.WriteUInt( owner.bs_shield:EntIndex(), 16 ) 
		net.Send( owner )
	end
end

function SWEP:PrimaryAttack()
	local owner = self.Owner
	if(owner:LookupAttachment( "anim_attachment_RH" )>0) then owner:SetAnimation( PLAYER_ATTACK1 ) end
	owner:LagCompensation( true )
	local shield
	if SERVER then shield = owner.bs_shield else shield = Entity(LocalPlayer().bs_shieldIndex) end

	self:EmitSound( SwingSound )

	if SERVER then
		if(owner:LookupAttachment( "anim_attachment_RH" )>0) then
			owner.bs_shield:SetLocalAngles( Angle(6,-34,-12) ) 
			owner.bs_shield:SetLocalPos( Vector(4,8,-1) ) 
			timer.Simple(0.4,function()
				owner.bs_shield:SetLocalAngles( bshields.shields[1][3].angles ) 
				owner.bs_shield:SetLocalPos( bshields.shields[1][3].position ) 
			end)
		end
	end

	local tr = util.TraceLine( {
		start = owner:GetShootPos(),
		endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		mask = MASK_SHOT_HULL,
		filter = {owner, shield}
	} )

	if ( !IsValid( tr.Entity ) ) then
		tr = util.TraceHull( {
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
			mins = Vector( -10, -10, -8 ),
			maxs = Vector( 10, 10, 8 ),
			mask = MASK_SHOT_HULL,
			filter = {owner, shield}
		} )
	end

	if ( tr.Hit && !( game.SinglePlayer() && CLIENT ) ) then
		self:EmitSound( HitSound )
	end

	local hit = false

	if ( SERVER && IsValid( tr.Entity ) && ( tr.Entity:IsNPC() || tr.Entity:IsPlayer() || tr.Entity:Health() > 0 ) ) then
		local dmginfo = DamageInfo()

		local attacker = owner
		if ( !IsValid( attacker ) ) then attacker = self end
		dmginfo:SetAttacker( attacker )

		dmginfo:SetInflictor( self )
		dmginfo:SetDamage( math.random( bshields.config.rshielddmgmin, bshields.config.rshielddmgmax ) )

		tr.Entity:TakeDamageInfo( dmginfo )
		hit = true

	end

	if ( SERVER && IsValid( tr.Entity ) ) then
		local phys = tr.Entity:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:ApplyForceOffset( owner:GetAimVector() * 80 * phys:GetMass(), tr.HitPos )
		end
	end

	owner:LagCompensation( false )
	self:SetNextPrimaryFire( CurTime() + 0.7 )
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if(!self.CanVisToggle) then return end
		if(!IsValid(Entity(LocalPlayer().bs_shieldIndex))) then return end
		surface.PlaySound( "weapons/smg1/switch_single.wav" )
		if(!self.VisToggle) then
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 0, 0, 0, 125 ))
			self.VisToggle = true
		else
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 255, 255, 255 ))
			self.VisToggle = false
		end
		self.CanVisToggle = false
		timer.Simple(0.1, function()
			self.CanVisToggle = true
		end)
	end
end

if CLIENT then return end

function SWEP:Holster()
	bshield_remove(self.Owner)
	return true
end
function SWEP:OnRemove()
	bshield_remove(self.Owner)
	return true
end
function SWEP:OnDrop()
	bshield_remove(self.Owner)
	return true
end

--addons/mobile_ammunition/lua/weapons/rw_ammo_distributor_explosives.lua:
SWEP.Gun							= ("gun_base")
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "tfa_blacklisted" SWEP.PrintName = SWEP.Gun return end
end

SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"


SWEP.PrintName						= "Versorgungskit - Explosives"
SWEP.Type							= "This is a WIP swep, so you can throw 5 (default) crate of 750 (default) ammo and the swep will be deleted"
SWEP.Slot							= 3
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 90, 0),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -06),
		angle = Angle(180, -05, -4),
		size = Vector(0.6, 0.6, 0.6),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {} }
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

function SWEP:Think()
	if (self:Clip1() <= 0) then
		if IsValid(self) and self:OwnerIsValid() and SERVER then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.DefaultClip			= GetConVar("rw_sw_dispencer_ammo_crate_number"):GetInt()
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "ammo_chargepack_explosives"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.RunSpeed						= 0.9
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= ""
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}
if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end
DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_dioxis_stun.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Releasing dioxis"
SWEP.PrintName					= "Symoxin Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 7
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_poison_stun")
SWEP.Primary.Range 					= 900
SWEP.Velocity = 900
SWEP.Velocity_Underhand = 350
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/forrezzur/dioxisgrenade.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.7, 0.2, 01.1), angle = Angle(10, -90, 90), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/forrezzur/dioxisgrenade.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03, 02, 0), angle = Angle(10, 30, 260), size = Vector(0.9, 0.9, 0.9), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_smoke.lua:
SWEP.Base					= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author					= "Gorka(Strasser) & ChanceSphere574"
SWEP.Type						= "Explode and create a smoke zone"
SWEP.PrintName					= "Smoke Grenade"
SWEP.Slot					= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox					= false
SWEP.BounceWeaponIcon   				= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                                  = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 0
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_smoke")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_smoke.mdl", bone = "Weapon_F1", rel = "", pos = Vector(0.5, 01.3, 1.5), angle = Angle(0, 20+150, 80), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_smoke.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03, 01.5, -0.75), angle = Angle(-50, 15, 90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
	Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/system_entities/lua/weapons/sh_fixingtool.lua:
--[[------------------------------------------------------------
	____________										   ___
	|		   |   									 	  |	  |
	|___	___|	__________   	__________			  |	  |
		|	|	   /		  \	   /		  \		   	  |	  |
		|	|	  |			   |  |			   |	  ____|   |
		|	|	  |			   |  |			   |	 / 		  |
		|	|	  |			   |  |			   |	|		  |
		|___|	   \__________/    \__________/		 \________|

	Author: Tood/The Toodster.
	Contact: Discord - The Toodster#0001 || Steam - https://steamcommunity.com/id/freelancertood/
--]]------------------------------------------------------------

AddCSLuaFile()

SWEP.PrintName = "System Repairing Tool"
SWEP.Slot = 2
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.Instructions = "Dieses Tool ist zum Reparieren der System-Tools gedacht!"
SWEP.Author = "Summe"
SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.Category = "SW:RP (Sonstiges)"

SWEP.ViewModelFOV = 65
SWEP.ViewModelFlip = false
SWEP.UseHands = false
SWEP.ViewModel = "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

-----------------------------------------

local RepairableEnts = {
	["commsarray"] = true,
	["lifesupport"] = true,
	["gravgen"] = true,
	["powerstation"] = true,
}

local CooldownActive = false
function SWEP:PrimaryAttack()
local ply = self.Owner
local PTrace = ply:GetEyeTrace().Entity
local PTHealth = PTrace:Health()
local PTMHealth = PTrace:GetMaxHealth()
	if IsValid( ply ) && ply:IsPlayer() then
		if PTrace:GetPos():DistToSqr( ply:EyePos() ) < 150 * 150 then
			if !ply.CooldownActive || ply.CooldownActive < CurTime() then
				if PTHealth >= PTMHealth then
					PTrace:SetPlayerRepairing( false )
					return
				else
					if RepairableEnts[PTrace:GetClass()] then
						PTrace:SetHealth( math.Clamp( PTHealth + math.Rand( 1, 2 ), 0, PTMHealth ) )
						PTrace:SetPlayerRepairing( true )
					end
				end
				ply.CooldownActive = CurTime() + 0.1
			end
		end
	end
	return true
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

--addons/tfa_base/lua/weapons/tfa_bash_base.lua:
if SERVER then
	AddCSLuaFile()
end

DEFINE_BASECLASS("tfa_gun_base")
SWEP.Secondary.BashDamage = 25
SWEP.Secondary.BashSound = Sound("TFA.Bash")
SWEP.Secondary.BashHitSound = Sound("TFA.BashWall")
SWEP.Secondary.BashHitSound_Flesh = Sound("TFA.BashFlesh")
SWEP.Secondary.BashLength = 54
SWEP.Secondary.BashDelay = 0.2
SWEP.Secondary.BashDamageType = DMG_SLASH
SWEP.Secondary.BashEnd = nil --Override bash sequence length easier
SWEP.Secondary.BashInterrupt = false --Do you need to be in a "ready" status to bash?
SWEP.BashBase = true

function SWEP:BashForce(ent, force, pos, now)
	if not IsValid(ent) or not ent.GetPhysicsObjectNum then return end

	if now then
		if ent.GetRagdollEntity then
			ent = ent:GetRagdollEntity() or ent
		end

		local phys = ent:GetPhysicsObjectNum(0)

		if IsValid(phys) then
			if ent:IsPlayer() or ent:IsNPC() then
				ent:SetVelocity( force * 0.1)
				phys:SetVelocity(phys:GetVelocity() + force * 0.1)
			else
				phys:ApplyForceOffset(force, pos)
			end
		end
	else
		timer.Simple(0, function()
			if IsValid(self) and self:OwnerIsValid() and IsValid(ent) then
				self:BashForce(ent, force, pos, true)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_melee_doordestruction")

function SWEP:HandleDoor(slashtrace)
	if CLIENT or not IsValid(slashtrace.Entity) then return end

	if not cv_doordestruction:GetBool() then return end

	if slashtrace.Entity:GetClass() == "func_door_rotating" or slashtrace.Entity:GetClass() == "prop_door_rotating" then
		slashtrace.Entity:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(80, 120))

		local newname = "TFABash" .. self:EntIndex()
		self.PreBashName = self:GetName()
		self:SetName(newname)

		slashtrace.Entity:SetKeyValue("Speed", "500")
		slashtrace.Entity:SetKeyValue("Open Direction", "Both directions")
		slashtrace.Entity:SetKeyValue("opendir", "0")
		slashtrace.Entity:Fire("unlock", "", .01)
		slashtrace.Entity:Fire("openawayfrom", newname, .01)

		timer.Simple(0.02, function()
			if not IsValid(self) or self:GetName() ~= newname then return end

			self:SetName(self.PreBashName)
		end)

		timer.Simple(0.3, function()
			if IsValid(slashtrace.Entity) then
				slashtrace.Entity:SetKeyValue("Speed", "100")
			end
		end)
	end
end

local l_CT = CurTime
local sp = game.SinglePlayer()

function SWEP:AltAttack()
	local time = l_CT()

	if
		self:GetStatL("Secondary.CanBash") == false or
		not self:OwnerIsValid() or
		time < self:GetNextSecondaryFire()
	then return end

	local stat = self:GetStatus()
	if not TFA.Enum.ReadyStatus[stat] and not self:GetStatL("Secondary.BashInterrupt") or
		stat == TFA.Enum.STATUS_BASHING and self:GetStatL("Secondary.BashInterrupt") then return end

	if self:IsSafety() or self:GetHolding() then return end

	local retVal = hook.Run("TFA_CanBash", self)
	if retVal == false then return end

	local enabled, tanim, ttype = self:ChooseBashAnim()
	if not enabled then return end

	hook.Run("TFA_Bash", self)

	if self:GetOwner().Vox and IsFirstTimePredicted() then
		self:GetOwner():Vox("bash", 0)
	end

	self:BashAnim()
	if sp and SERVER then self:CallOnClient("BashAnim", "") end

	local bashend = self:GetStatL("Secondary.BashEnd")
	local nextTime = time + (bashend or self:GetActivityLength(tanim, false, ttype))

	self:SetNextPrimaryFire(nextTime)
	self:SetNextSecondaryFire(nextTime)

	self:EmitSoundNet(self:GetStatL("Secondary.BashSound"))

	self:ScheduleStatus(TFA.Enum.STATUS_BASHING, self:GetStatL("Secondary.BashDelay"))

	hook.Run("TFA_PostBash", self)
end

function SWEP:BashAnim()
	if not IsFirstTimePredicted() then return end
	local ht = self.DefaultHoldType or self.HoldType
	local altanim = false

	if ht == "ar2" or ht == "shotgun" or ht == "crossbow" or ht == "physgun" then
		altanim = true
	end

	self:GetOwner():AnimRestartGesture(0, altanim and ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND or ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE2, true)
end

local ttime = -1

function SWEP:HandleBashAttack()
	local ply = self:GetOwner()
	local pos = ply:GetShootPos()
	local av = ply:GetAimVector()

	local slash = {}
	slash.start = pos
	slash.endpos = pos + (av * self:GetStatL("Secondary.BashLength"))
	slash.filter = ply
	slash.mins = Vector(-10, -5, 0)
	slash.maxs = Vector(10, 5, 5)
	local slashtrace = util.TraceHull(slash)

	local pain = self:GetStatL("Secondary.BashDamage")

	if not slashtrace.Hit then return end
	self:HandleDoor(slashtrace)

	if not (sp and CLIENT) then
		self:EmitSound(
			(slashtrace.MatType == MAT_FLESH or slashtrace.MatType == MAT_ALIENFLESH) and
			self:GetStatL("Secondary.BashHitSound_Flesh") or
			self:GetStatL("Secondary.BashHitSound"))
	end

	if CLIENT then return end

	local dmg = DamageInfo()
	dmg:SetAttacker(ply)
	dmg:SetInflictor(self)
	dmg:SetDamagePosition(pos)
	dmg:SetDamageForce(av * pain)
	dmg:SetDamage(pain)
	dmg:SetDamageType(self:GetStatL("Secondary.BashDamageType"))

	if IsValid(slashtrace.Entity) and slashtrace.Entity.TakeDamageInfo then
		slashtrace.Entity:TakeDamageInfo(dmg)
	end

	local ent = slashtrace.Entity
	if not IsValid(ent) or not ent.GetPhysicsObject then return end

	local phys

	if ent:IsRagdoll() then
		phys = ent:GetPhysicsObjectNum(slashtrace.PhysicsBone or 0)
	else
		phys = ent:GetPhysicsObject()
	end

	if IsValid(phys) then
		if ent:IsPlayer() or ent:IsNPC() then
			ent:SetVelocity(av * self:GetStatL("Secondary.BashDamage") * 0.5)
			phys:SetVelocity(phys:GetVelocity() + av * self:GetStatL("Secondary.BashDamage") * 0.5)
		else
			phys:ApplyForceOffset(av * self:GetStatL("Secondary.BashDamage") * 0.5, slashtrace.HitPos)
		end
	end
end

function SWEP:Think2(...)
	if self:GetStatus() == TFA.Enum.STATUS_BASHING and self:GetStatusEnd() < l_CT() then
		self:SetStatus(TFA.Enum.STATUS_BASHING_WAIT, self:GetNextSecondaryFire())

		if IsFirstTimePredicted() then
			self:HandleBashAttack()
		end
	end

	BaseClass.Think2(self, ...)
end

function SWEP:SecondaryAttack()
	if not self:GetStatL("Secondary.IronSightsEnabled", false) then
		self:AltAttack()
		return
	end

	BaseClass.SecondaryAttack(self)
end

function SWEP:GetBashing()
	local stat = self:GetStatus()

	if not self:VMIV() then
		return stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT
	end

	return (stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT) and self.OwnerViewModel:GetCycle() > 0 and self.OwnerViewModel:GetCycle() < 0.65
end

function SWEP:GetBashingStrict()
	local stat = self:GetStatus()
	return stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT
end

TFA.FillMissingMetaValues(SWEP)

--addons/tfa_base/lua/weapons/tfa_gun_base/common/ai_translations.lua:
local HoldTypeTable = {
	["melee"] = {
		[ACT_IDLE] = ACT_IDLE_MELEE,
		[ACT_IDLE_ANGRY] = ACT_IDLE_MELEE,
		[ACT_IDLE_RELAXED] = ACT_IDLE_MELEE,
		[ACT_IDLE_STIMULATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AGITATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_RELAXED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_STIMULATED] = ACT_IDLE_MELEE,
		[ACT_IDLE_AIM_AGITATED] = ACT_IDLE_MELEE,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_SPECIAL_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_RANGE_AIM_LOW] = ACT_IDLE_MELEE,
		[ACT_COVER_LOW] = ACT_IDLE_MELEE,
		[ACT_WALK] = ACT_WALK_SUITCASE,
		[ACT_WALK_RELAXED] = ACT_WALK_SUITCASE,
		[ACT_WALK_STIMULATED] = ACT_WALK_SUITCASE,
		[ACT_WALK_AGITATED] = ACT_WALK_SUITCASE,
		[ACT_RUN_CROUCH] = ACT_RUN_CROUCH,
		[ACT_RUN_CROUCH_AIM] = ACT_RUN_CROUCH,
		[ACT_RUN] = ACT_RUN,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN,
		[ACT_RUN_AIM] = ACT_RUN,
		[ACT_SMALL_FLINCH] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_BIG_FLINCH] = ACT_RANGE_ATTACK_PISTOL
	},
	["melee2"] = {
		[ACT_IDLE] = ACT_IDLE_ANGRY_MELEE,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_MELEE,
		[ACT_IDLE_RELAXED] = ACT_IDLE,
		[ACT_IDLE_STIMULATED] = ACT_IDLE,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_MELEE,
		[ACT_MP_RUN] = ACT_HL2MP_RUN_SUITCASE,
		[ACT_RUN] = ACT_RUN,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN,
		[ACT_RUN_AIM] = ACT_RUN,
		[ACT_WALK] = ACT_WALK_SUITCASE,
		[ACT_MELEE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_RANGE_ATTACK1] = ACT_MELEE_ATTACK_SWING,
		[ACT_MELEE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_RANGE_ATTACK2] = ACT_MELEE_ATTACK_SWING,
		[ACT_SPECIAL_ATTACK1] = ACT_RANGE_ATTACK_THROW,
		[ACT_SMALL_FLINCH] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_BIG_FLINCH] = ACT_RANGE_ATTACK_PISTOL
	},
	["pistol"] = {
		[ACT_IDLE] = ACT_IDLE_PISTOL,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_PISTOL,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_PISTOL,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_RELOAD] = ACT_RELOAD_PISTOL,
		[ACT_WALK] = ACT_WALK_PISTOL,
		[ACT_WALK_AIM] = ACT_WALK_AIM_PISTOL,
		[ACT_RUN] = ACT_RUN_PISTOL,
		[ACT_RUN_AIM] = ACT_RUN_AIM_PISTOL,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_PISTOL,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_PISTOL,
		[ACT_RELOAD_LOW] = ACT_RELOAD_PISTOL_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_PISTOL_LOW,
		[ACT_COVER_LOW] = ACT_COVER_PISTOL_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_PISTOL_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_PISTOL
	},
	["ar2"] = {
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_AR2,
		[ACT_RELOAD] = ACT_RELOAD_SMG1,
		[ACT_IDLE] = ACT_IDLE_SMG1,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK] = ACT_WALK_RIFLE,
		[ACT_IDLE_RELAXED] = ACT_IDLE_SMG1_RELAXED,
		[ACT_IDLE_STIMULATED] = ACT_IDLE_SMG1_STIMULATED,
		[ACT_IDLE_AGITATED] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK_RELAXED] = ACT_WALK_RIFLE_RELAXED,
		[ACT_WALK_STIMULATED] = ACT_WALK_RIFLE_STIMULATED,
		[ACT_WALK_AGITATED] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_RELAXED] = ACT_RUN_RIFLE_RELAXED,
		[ACT_RUN_STIMULATED] = ACT_RUN_RIFLE_STIMULATED,
		[ACT_RUN_AGITATED] = ACT_RUN_AIM_RIFLE,
		[ACT_IDLE_AIM_RELAXED] = ACT_IDLE_SMG1_RELAXED,
		[ACT_IDLE_AIM_STIMULATED] = ACT_IDLE_AIM_RIFLE_STIMULATED,
		[ACT_IDLE_AIM_AGITATED] = ACT_IDLE_ANGRY_SMG1,
		[ACT_WALK_AIM_RELAXED] = ACT_WALK_RIFLE_RELAXED,
		[ACT_WALK_AIM_STIMULATED] = ACT_WALK_AIM_RIFLE_STIMULATED,
		[ACT_WALK_AIM_AGITATED] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_AIM_RELAXED] = ACT_RUN_RIFLE_RELAXED,
		[ACT_RUN_AIM_STIMULATED] = ACT_RUN_AIM_RIFLE_STIMULATED,
		[ACT_RUN_AIM_AGITATED] = ACT_RUN_AIM_RIFLE,
		[ACT_WALK_AIM] = ACT_WALK_AIM_RIFLE,
		[ACT_WALK_CROUCH] = ACT_WALK_CROUCH_RIFLE,
		[ACT_WALK_CROUCH_AIM] = ACT_WALK_CROUCH_AIM_RIFLE,
		[ACT_RUN] = ACT_RUN_RIFLE,
		[ACT_RUN_AIM] = ACT_RUN_AIM_RIFLE,
		[ACT_RUN_CROUCH] = ACT_RUN_CROUCH_RIFLE,
		[ACT_RUN_CROUCH_AIM] = ACT_RUN_CROUCH_AIM_RIFLE,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_AR2,
		[ACT_COVER_LOW] = ACT_COVER_SMG1_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_AR2_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_SMG1_LOW,
		[ACT_RELOAD_LOW] = ACT_RELOAD_SMG1_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_SMG1
	},
	["smg"] = {
		[ACT_IDLE] = ACT_IDLE_SMG1,
		[ACT_IDLE_ANGRY] = ACT_IDLE_ANGRY_SMG1,
		[ACT_RANGE_ATTACK1] = ACT_RANGE_ATTACK_SMG1,
		[ACT_RELOAD] = ACT_RELOAD_SMG1,
		[ACT_WALK_AIM] = ACT_WALK_AIM_RIFLE,
		[ACT_RUN_AIM] = ACT_RUN_AIM_RIFLE,
		[ACT_GESTURE_RANGE_ATTACK1] = ACT_GESTURE_RANGE_ATTACK_SMG1,
		[ACT_RELOAD_LOW] = ACT_RELOAD_SMG1_LOW,
		[ACT_RANGE_ATTACK1_LOW] = ACT_RANGE_ATTACK_SMG1_LOW,
		[ACT_COVER_LOW] = ACT_COVER_SMG1_LOW,
		[ACT_RANGE_AIM_LOW] = ACT_RANGE_AIM_SMG1_LOW,
		[ACT_GESTURE_RELOAD] = ACT_GESTURE_RELOAD_SMG1
	}
}

function SWEP:SetupWeaponHoldTypeForAI(t)
	local usedT = HoldTypeTable[t or "ar2"] or HoldTypeTable["ar2"]
	self.ActivityTranslateAI = table.Copy(usedT)
end

function SWEP:TranslateActivity(act)
	if (self:GetOwner():IsNPC()) then
		if (self.ActivityTranslateAI[act]) then return self.ActivityTranslateAI[act] end

		return -1
	end

	if (self.ActivityTranslate[act] ~= nil) then return self.ActivityTranslate[act] end

	return -1
end

function SWEP:GetCapabilities()
	local ht = self.DefaultHoldType or self.HoldType or "pistol"

	if ht == "melee" or ht == "melee2" or ht == "knife" or self.IsKnife then
		return CAP_WEAPON_MELEE_ATTACK1
	else
		return bit.bor(CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1)
	end
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/stat.lua:
local tableCopy = table.Copy

function SWEP:GetStatRecursive(srctbl, stbl, ...)
	stbl = tableCopy(stbl)

	for _ = 1, #stbl do
		if #stbl > 1 then
			if srctbl[stbl[1]] then
				srctbl = srctbl[stbl[1]]
				table.remove(stbl, 1)
			else
				return true, ...
			end
		end
	end

	local val = srctbl[stbl[1]]

	if val == nil then
		return true, ...
	end

	if istable(val) and val.functionTable then
		local currentStat, isFinal, nocache, nct
		nocache = false

		for i = 1, #val do
			local v = val[i]

			if isfunction(v) then
				if currentStat == nil then
					currentStat, isFinal, nct = v(self, ...)
				else
					currentStat, isFinal, nct = v(self, currentStat)
				end

				nocache = nocache or nct

				if isFinal then break end
			elseif v then
				currentStat = v
			end
		end

		if currentStat ~= nil then
			return false, currentStat, nocache
		end

		return true, ...
	end

	return false, val
end

SWEP.StatCache_Blacklist = {
	["ViewModelBoneMods"] = true,
	["WorldModelBoneMods"] = true,
	["MaterialTable"] = true,
	["MaterialTable_V"] = true,
	["MaterialTable_W"] = true,
	["ViewModelBodygroups"] = true,
	["Bodygroups_V"] = true,
	["WorldModelBodygroups"] = true,
	["Skin"] = true
}

SWEP.StatCache = {}
SWEP.StatCache2 = {}
SWEP.StatStringCache = {}

SWEP.LastClearStatCache = 0
SWEP.ClearStatCacheWarnCount = 0
SWEP.ClearStatCacheWarned = false

local IdealCSCDeltaTime = engine.TickInterval() * 2

local LatestDataVersion = TFA.LatestDataVersion

function SWEP:ClearStatCache(vn)
	return self:ClearStatCacheVersioned(vn, 0)
end

function SWEP:ClearStatCacheL(vn)
	return self:ClearStatCacheVersioned(vn, LatestDataVersion)
end

local trigger_lut_rebuild = {
	FalloffMetricBased = true,
	Range = true,
	RangeFalloff = true,
}

function SWEP:ClearStatCacheVersioned(vn, path_version)
	local self2 = self:GetTable()
	self2.ignore_stat_cache = true
	local getpath, getpath2

	if isstring(vn) then
		vn = TFA.RemapStatPath(vn, path_version, self.TFADataVersion)
	end

	if not vn and not self2.ClearStatCacheWarned then
		local ct = CurTime()
		local delta = ct - self2.LastClearStatCache

		if delta < IdealCSCDeltaTime and debug.traceback():find("Think2") then
			self2.ClearStatCacheWarnCount = self2.ClearStatCacheWarnCount + 1

			if self2.ClearStatCacheWarnCount >= 5 then
				self2.ClearStatCacheWarned = true

				print(("[TFA Base] Weapon %s (%s) is abusing ClearStatCache function from Think2! This will lead to really bad performance issues, tell weapon's author to fix it ASAP!"):format(self2.PrintName, self:GetClass()))
			end
		elseif self2.ClearStatCacheWarnCount > 0 then
			self2.ClearStatCacheWarnCount = 0
		end

		self2.LastClearStatCache = ct
	end

	if vn then
		local list = TFA.GetStatPathChildren(vn, path_version, self.TFADataVersion)

		for i = 1, #list do
			self2.StatCache[list[i]] = nil
			self2.StatCache2[list[i]] = nil
		end

		getpath2 = self2.GetStatPath(self, vn)
		getpath = getpath2[1]
	else
		table.Empty(self2.StatCache)
		table.Empty(self2.StatCache2)
	end

	if vn == "Primary" or not vn then
		table.Empty(self2.Primary)

		local temp = {}

		setmetatable(self2.Primary, {
			__index = function(self3, key)
				return self2.GetStatVersioned(self, "Primary." .. key, self2.TFADataVersion)
			end,

			__newindex = function() end
		})

		for k in pairs(self2.Primary_TFA) do
			if isstring(k) then
				temp[k] = self2.GetStatVersioned(self, "Primary." .. k, self2.TFADataVersion)
			end
		end

		setmetatable(self2.Primary, nil)

		for k, v in pairs(temp) do
			self2.Primary[k] = v
		end

		if self2.Primary_TFA.RangeFalloffLUT_IsConverted then
			self2.Primary_TFA.RangeFalloffLUT = nil
			self2.AutoDetectRange(self)
		end

		local getLUT = self2.GetStatL(self, "Primary.RangeFalloffLUT", nil, true)

		if getLUT then
			self2.Primary.RangeFalloffLUTBuilt = self:BuildFalloffTable(getLUT)
		end

		if self2.Primary_TFA.RecoilLUT then
			if self2.Primary_TFA.RecoilLUT["in"] then
				self2.Primary_TFA.RecoilLUT["in"].points_p = {0}
				self2.Primary_TFA.RecoilLUT["in"].points_y = {0}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["in"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["in"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["in"].points_y, point.y)
				end
			end

			if self2.Primary_TFA.RecoilLUT["loop"] then
				self2.Primary_TFA.RecoilLUT["loop"].points_p = {}
				self2.Primary_TFA.RecoilLUT["loop"].points_y = {}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["loop"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_y, point.y)
				end

				table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_p, self2.Primary_TFA.RecoilLUT["loop"].points[1].p)
				table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_y, self2.Primary_TFA.RecoilLUT["loop"].points[1].y)
			end

			if self2.Primary_TFA.RecoilLUT["out"] then
				self2.Primary_TFA.RecoilLUT["out"].points_p = {0}
				self2.Primary_TFA.RecoilLUT["out"].points_y = {0}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["out"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["out"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["out"].points_y, point.y)
				end

				table.insert(self2.Primary_TFA.RecoilLUT["out"].points_p, 0)
				table.insert(self2.Primary_TFA.RecoilLUT["out"].points_y, 0)
			end
		end
	elseif getpath == "Primary_TFA" and isstring(getpath2[2]) then
		if trigger_lut_rebuild[getpath2[2]] and self2.Primary_TFA.RangeFalloffLUT_IsConverted then
			self2.Primary_TFA.RangeFalloffLUT = nil
			self2.AutoDetectRange(self)
		end

		self2.Primary[getpath[2]] = self2.GetStatVersioned(self, vn, path_version)
	end

	if vn == "Secondary" or not vn then
		table.Empty(self2.Secondary)

		local temp = {}

		setmetatable(self2.Secondary, {
			__index = function(self3, key)
				return self2.GetStatVersioned(self, "Secondary." .. key, self2.TFADataVersion)
			end,

			__newindex = function() end
		})

		for k in pairs(self.Secondary_TFA) do
			if isstring(k) then
				temp[k] = self2.GetStatVersioned(self, "Secondary." .. k, self2.TFADataVersion)
			end
		end

		setmetatable(self2.Secondary, nil)

		for k, v in pairs(temp) do
			self2.Secondary[k] = v
		end
	elseif getpath == "Secondary_TFA" and isstring(getpath2[2]) then
		self2.Secondary[getpath[2]] = self2.GetStatVersioned(self, vn, path_version)
	end

	if CLIENT then
		self:RebuildModsRenderOrder()
	end

	self2.ignore_stat_cache = false
	hook.Run("TFA_ClearStatCache", self)
end

local ccv = GetConVar("cl_tfa_debug_cache")

function SWEP:GetStatPath(stat, path_version)
	return TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion)
end

function SWEP:RemapStatPath(stat, path_version)
	return TFA.RemapStatPath(stat, path_version or 0, self.TFADataVersion)
end

function SWEP:GetStatPathRaw(stat)
	return TFA.GetStatPathRaw(stat)
end

function SWEP:GetStatRaw(stat, path_version)
	local path = TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion, not IsValid(self))
	local value = self[path[1]]

	for i = 2, #path do
		if not istable(value) then return end
		value = value[path[i]]
	end

	return value
end

function SWEP:GetStatRawL(stat)
	return self:GetStatRaw(stat, LatestDataVersion)
end

function SWEP:SetStatRaw(stat, path_version, _value)
	local path = TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion, not IsValid(self))

	if #path == 1 then
		self[path[1]] = _value
		return self
	end

	local value = self[path[1]]

	for i = 2, #path - 1 do
		if not istable(value) then return self end
		value = value[path[i]]
	end

	if istable(value) then
		value[path[#path]] = _value
	end

	return self
end

function SWEP:SetStatRawL(stat, _value)
	return self:SetStatRaw(stat, LatestDataVersion, _value)
end

function SWEP:GetStat(stat, default, dontMergeTables)
	return self:GetStatVersioned(stat, 0, default, dontMergeTables)
end

function SWEP:GetStatL(stat, default, dontMergeTables)
	return self:GetStatVersioned(stat, LatestDataVersion, default, dontMergeTables)
end

function SWEP:GetStatVersioned(stat, path_version, default, dontMergeTables)
	local self2 = self:GetTable()
	local statPath, currentVersionStat, translate = self2.GetStatPath(self, stat, path_version)

	if self2.StatCache2[currentVersionStat] ~= nil then
		local finalReturn

		if self2.StatCache[currentVersionStat] ~= nil then
			finalReturn = self2.StatCache[currentVersionStat]
		else
			local isDefault, retval = self2.GetStatRecursive(self, self2, statPath)

			if retval ~= nil then
				if not isDefault then
					self2.StatCache[currentVersionStat] = retval
				end

				finalReturn = retval
			else
				finalReturn = istable(default) and tableCopy(default) or default
			end
		end

		local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, finalReturn)
		if getstat ~= nil then return translate(getstat) end

		return translate(finalReturn)
	end

	if not self2.OwnerIsValid(self) then
		local finalReturn = default

		if IsValid(self) then
			local _
			_, finalReturn = self2.GetStatRecursive(self, self2, statPath, istable(default) and tableCopy(default) or default)
		end

		local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, finalReturn)
		if getstat ~= nil then return translate(getstat) end

		return translate(finalReturn)
	end

	local isDefault, statSelf = self2.GetStatRecursive(self, self2, statPath, istable(default) and tableCopy(default) or default)
	local isDefaultAtt, statAttachment, noCache = self2.GetStatRecursive(self, self2.AttachmentTableCache, statPath, istable(statSelf) and tableCopy(statSelf) or statSelf)
	local shouldCache = not noCache and
		not (self2.StatCache_Blacklist_Real or self2.StatCache_Blacklist)[currentVersionStat] and
		not (self2.StatCache_Blacklist_Real or self2.StatCache_Blacklist)[statPath[1]] and
		not (ccv and ccv:GetBool())

	if istable(statAttachment) and istable(statSelf) and not dontMergeTables then
		statSelf = table.Merge(tableCopy(statSelf), statAttachment)
	else
		statSelf = statAttachment
	end

	if shouldCache and not self2.ignore_stat_cache then
		if not isDefault or not isDefaultAtt then
			self2.StatCache[currentVersionStat] = statSelf
		end

		self2.StatCache2[currentVersionStat] = true
	end

	local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, statSelf)
	if getstat ~= nil then return translate(getstat) end

	return translate(statSelf)
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/attachments.lua:
local ATT_DIMENSION
local ATT_MAX_SCREEN_RATIO = 1 / 3
local tableCopy = table.Copy

SWEP.Attachments = {} --[MDL_ATTACHMENT] = = { offset = { 0, 0 }, atts = { "sample_attachment_1", "sample_attachment_2" }, sel = 1, order = 1 } --offset will move the offset the display from the weapon attachment when using CW2.0 style attachment display --atts is a table containing the visible attachments --sel allows you to have an attachment pre-selected, and is used internally by the base to show which attachment is selected in each category. --order is the order it will appear in the TFA style attachment menu
SWEP.AttachmentCache = {} --["att_name"] = true
SWEP.AttachmentTableCache = {}
SWEP.AttachmentCount = 0
SWEP.AttachmentDependencies = {} --{["si_acog"] = {"bg_rail"}}
SWEP.AttachmentExclusions = {} --{ ["si_iron"] = {"bg_heatshield"} }
SWEP.AttachmentTableOverride = {}

local att_enabled_cv = GetConVar("sv_tfa_attachments_enabled")

function SWEP:RemoveUnusedAttachments()
	for k, v in pairs(self.Attachments) do
		if v.atts then
			local t = {}
			local i = 1

			for _, b in pairs(v.atts) do
				if TFA.Attachments.Atts[b] then
					t[i] = b
					i = i + 1
				end
			end

			v.atts = tableCopy(t)
		end

		if #v.atts <= 0 then
			self.Attachments[k] = nil
		end
	end
end

local function select_function_table(target)
	-- idk
	local found_table

	for i_index, base_value in pairs(target) do
		if istable(base_value) then
			found_table = base_value
		end
	end

	if not found_table then
		found_table = {}
		table.insert(target, found_table)
	end

	return found_table
end

local function get(path, target)
	if #path == 1 then
		return target[path[1]]
	end

	local _target = target[path[1]]

	if _target == nil then
		target[path[1]] = {}
		_target = target[path[1]]
	end

	for i = 2, #path do
		if not istable(_target) then
			return
		end

		if _target[path[i]] == nil then _target[path[i]] = {} end

		if istable(_target[path[i]]) and _target[path[i]].functionTable and i ~= #path then
			_target = select_function_table(_target[path[i]])
		else
			_target = _target[path[i]]
		end
	end

	return _target
end

local function set(path, target, value)
	if #path == 1 then
		target[path[1]] = value
		return value
	end

	local _target = target[path[1]]

	if _target == nil then
		target[path[1]] = {}
		_target = target[path[1]]
	end

	for i = 2, #path - 1 do
		if not istable(_target) then
			return value
		end

		if _target[path[i]] == nil then _target[path[i]] = {} end

		if _target[path[i]].functionTable then
			_target = select_function_table(_target[path[i]])
		else
			_target = _target[path[i]]
		end
	end

	if istable(_target) then
		if istable(_target[path[#path]]) and _target[path[#path]].functionTable then
			table.insert(select_function_table(_target[path[#path]]), value)
		else
			_target[path[#path]] = value
		end
	end

	return value
end

local function CloneTableRecursive(source, target, root, source_version, target_version)
	for index, value in pairs(source) do
		local _root = root == "" and index or (root .. "." .. index)

		-- merge two tables
		if istable(value) then
			local baseTable = get(TFA.GetStatPath(_root, source_version, target_version), target)

			-- target is a function table
			if istable(baseTable) and baseTable.functionTable then
				local found_table

				for i_index, base_value in pairs(baseTable) do
					if istable(base_value) then
						found_table = base_value
					end
				end

				if not found_table then
					found_table = {}
					table.insert(baseTable, 1, found_table)
				end

				CloneTableRecursive(value, target, _root, source_version, target_version)
			-- target is a regular table
			else
				if not istable(baseTable) then
					set(TFA.GetStatPath(_root, source_version, target_version), target, {})
				end

				CloneTableRecursive(value, target, _root, source_version, target_version)
			end
		-- final value is determined by function
		elseif isfunction(value) then
			local temp
			local get_path = TFA.GetStatPath(_root, source_version, target_version)
			local get_table = get(get_path, target)

			if get_table ~= nil and not istable(get_table) then
				temp = get_table
			end

			local get_value = not istable(get_table) and set(get_path, target, {}) or get_table

			-- mark this table as function based
			get_value.functionTable = true

			if temp ~= nil then
				-- insert variable that was there before
				table.insert(get_value, temp)
			end

			-- insert function
			table.insert(get_value, value)
		-- final value is a scalar
		else
			local get_table = get(TFA.GetStatPath(_root, source_version, target_version), target)

			if istable(get_table) and get_table.functionTable then
				table.insert(get_table, 1, value)
			else
				set(TFA.GetStatPath(_root, source_version, target_version), target, value)
			end
		end
	end
end

function SWEP:BuildAttachmentCache()
	self.AttachmentCount = 0

	for k, v in pairs(self.Attachments) do
		if v.atts then
			for l, b in pairs(v.atts) do
				self.AttachmentCount = self.AttachmentCount + 1
				self.AttachmentCache[b] = (v.sel == l) and k or false
			end
		end
	end

	table.Empty(self.AttachmentTableCache)

	for attName, sel in pairs(self.AttachmentCache) do
		if not sel then goto CONTINUE end
		if not TFA.Attachments.Atts[attName] then goto CONTINUE end

		local srctbl = TFA.Attachments.Atts[attName].WeaponTable

		if istable(srctbl) then
			CloneTableRecursive(srctbl, self.AttachmentTableCache, "", TFA.Attachments.Atts[attName].TFADataVersion or 0, self.TFADataVersion or 0)
		end

		if istable(self.AttachmentTableOverride[attName]) then
			CloneTableRecursive(self.AttachmentTableOverride[attName], self.AttachmentTableCache, "", self.TFADataVersion or 0, self.TFADataVersion or 0)
		end

		::CONTINUE::
	end

	self:ClearStatCache()
	self:ClearMaterialCache()

	if CLIENT then
		self:ResetKeyBindHintAlpha(true)
	end
end

function SWEP:IsAttached(attn)
	return isnumber(self.AttachmentCache[attn])
end

local tc

function SWEP:CanAttach(attn, detaching)
	local retVal

	if detaching then
		retVal = hook.Run("TFA_PreCanDetach", self, attn)
	else
		retVal = hook.Run("TFA_PreCanAttach", self, attn)
	end

	if retVal ~= nil then return retVal end

	local self2 = self:GetTable()

	if not self2.HasBuiltMutualExclusions then
		tc = tableCopy(self2.AttachmentExclusions)

		for k, v in pairs(tc) do
			if k ~= "BaseClass" then
				for _, b in pairs(v) do
					self2.AttachmentExclusions[b] = self2.AttachmentExclusions[b] or {}

					if not table.HasValue(self2.AttachmentExclusions[b]) then
						self2.AttachmentExclusions[b][#self2.AttachmentExclusions[b] + 1] = k
					end
				end
			end
		end

		self2.HasBuiltMutualExclusions = true
	end

	if att_enabled_cv and not att_enabled_cv:GetBool() then return false end

	if self2.AttachmentExclusions[attn] then
		for _, v in pairs(self2.AttachmentExclusions[attn]) do
			if not detaching and self2.IsAttached(self, v) then
				return false
			end
		end
	end

	if not detaching and self2.AttachmentDependencies[attn] then
		local t = self2.AttachmentDependencies[attn]

		if isstring(t) then
			if t ~= "BaseClass" and not self2.IsAttached(self, t) then return false end
		elseif istable(t) then
			t.type = t.type or "OR"

			if t.type == "AND" then
				for k, v in pairs(self.AttachmentDependencies[attn]) do
					if k ~= "BaseClass" and k ~= "type" and not self2.IsAttached(self, v) then return false end
				end
			else
				local cnt = 0

				for k, v in pairs(self.AttachmentDependencies[attn]) do
					if k ~= "BaseClass" and k ~= "type" and self2.IsAttached(self, v) then
						cnt = cnt + 1
					end
				end

				if cnt == 0 then return false end
			end
		end
	end

	local atTable = TFA.Attachments.Atts[attn]

	if atTable then
		if detaching then
			if atTable.CanDetach and not atTable.CanDetach(self) then return false end
		else
			if not atTable:CanAttach(self) then return false end
		end
	end

	local retVal2

	if detaching then
		retVal2 = hook.Run("TFA_CanDetach", self, attn)
	else
		retVal2 = hook.Run("TFA_CanAttach", self, attn)
	end

	if retVal2 ~= nil then return retVal2 end
	return true
end

local ATTACHMENT_SORTING_DEPENDENCIES = false

function SWEP:ForceAttachmentReqs(attn)
	if not ATTACHMENT_SORTING_DEPENDENCIES then
		ATTACHMENT_SORTING_DEPENDENCIES = true
		local related = {}

		for k, v in pairs(self.AttachmentDependencies) do
			if istable(v) then
				for _, b in pairs(v) do
					if k == attn then
						related[b] = true
					elseif b == attn then
						related[k] = true
					end
				end
			elseif isstring(v) then
				if k == attn then
					related[v] = true
				elseif v == attn then
					related[k] = true
				end
			end
		end

		for k, v in pairs(self.AttachmentExclusions) do
			if istable(v) then
				for _, b in pairs(v) do
					if k == attn then
						related[b] = true
					elseif b == attn then
						related[k] = true
					end
				end
			elseif isstring(v) then
				if k == attn then
					related[v] = true
				elseif v == attn then
					related[k] = true
				end
			end
		end

		for k, v in pairs(self.AttachmentCache) do
			if v and related[k] and not self:CanAttach(k) then
				self:SetTFAAttachment(v, 0, true, true)
			end
		end

		ATTACHMENT_SORTING_DEPENDENCIES = false
	end
end

do
	local self3, att_neue, att_old

	local function attach()
		att_neue:Attach(self3)
	end

	local function detach()
		att_old:Detach(self3)
	end

	function SWEP:SetTFAAttachment(cat, id, nw, force)
		self3 = self
		local self2 = self:GetTable()

		if not self2.Attachments[cat] then return false end

		if isstring(id) then
			if id == "" then
				id = -1
			else
				id = table.KeyFromValue(self2.Attachments[cat].atts, id)
				if not id then return false end
			end
		end

		if id <= 0 and self2.Attachments[cat].default and type(self2.Attachments[cat].default) == "string" and self2.Attachments[cat].default ~= "" then
			return self2.SetTFAAttachment(self, cat, self2.Attachments[cat].default, nw, force)
		end

		local attn = self2.Attachments[cat].atts[id] or ""
		local attn_old = self2.Attachments[cat].atts[self2.Attachments[cat].sel or -1] or ""
		if SERVER and id > 0 and not (force or self2.CanAttach(self, attn)) then return false end
		if SERVER and id <= 0 and not (force or self2.CanAttach(self, attn_old, true)) then return false end

		if id ~= self2.Attachments[cat].sel then
			att_old = TFA.Attachments.Atts[self2.Attachments[cat].atts[self2.Attachments[cat].sel] or -1]
			local detach_status = att_old == nil

			if att_old then
				detach_status = ProtectedCall(detach)

				if detach_status then
					hook.Run("TFA_Attachment_Detached", self, attn_old, att_old, cat, id, force)
				end
			end

			att_neue = TFA.Attachments.Atts[self2.Attachments[cat].atts[id] or -1]
			local attach_status = att_neue == nil

			if detach_status then
				if att_neue then
					attach_status = ProtectedCall(attach)

					if attach_status then
						hook.Run("TFA_Attachment_Attached", self, attn, att_neue, cat, id, force)
					end
				end
			end

			if detach_status and attach_status then
				if id > 0 then
					self2.Attachments[cat].sel = id
				else
					self2.Attachments[cat].sel = nil
				end
			end
		end

		self2.BuildAttachmentCache(self)
		self2.ForceAttachmentReqs(self, (id > 0) and attn or attn_old)

		if nw and (not isentity(nw) or SERVER) then
			net.Start("TFA_Attachment_Set")
			if SERVER then net.WriteEntity(self) elseif CLIENT then net.WriteString(self:GetClass()) end
			net.WriteUInt(cat, 8)
			net.WriteString(attn)

			if SERVER then
				if isentity(nw) then
					local filter = RecipientFilter()
					filter:AddPVS(self:GetPos())
					filter:RemovePlayer(nw)
					net.Send(filter)
				else
					net.SendPVS(self:GetPos())
				end
			elseif CLIENT then
				net.SendToServer()
			end
		end

		return true
	end
end

function SWEP:Attach(attname, force)
	if not attname or not IsValid(self) then return false end
	if self.AttachmentCache[attname] == nil then return false end

	for cat, tbl in pairs(self.Attachments) do
		local atts = tbl.atts

		for id, att in ipairs(atts) do
			if att == attname then return self:SetTFAAttachment(cat, id, true, force) end
		end
	end

	return false
end

function SWEP:Detach(attname, force)
	if not attname or not IsValid(self) then return false end
	local cat = self.AttachmentCache[attname]
	if not cat then return false end

	return self:SetTFAAttachment(cat, 0, true, force)
end

function SWEP:RandomizeAttachments(force)
	for key, slot in pairs(self.AttachmentCache) do
		if slot then
			self:Detach(key)
		end
	end

	for category, def in pairs(self.Attachments) do
		if istable(def) and istable(def.atts) and #def.atts > 0 then
			if math.random() > 0.3 then
				local randkey = math.random(1, #def.atts)
				self:SetTFAAttachment(category, randkey, true, force)
			end
		end
	end
end

local attachments_sorted_alphabetically = GetConVar("sv_tfa_attachments_alphabetical")

function SWEP:InitAttachments()
	if self.HasInitAttachments then return end
	hook.Run("TFA_PreInitAttachments", self)
	self.HasInitAttachments = true

	for k, v in pairs(self.Attachments) do
		if type(k) == "string" then
			local tatt = self:VMIV() and self.OwnerViewModel:LookupAttachment(k) or self:LookupAttachment(k)

			if tatt > 0 then
				self.Attachments[tatt] = v
			end

			self.Attachments[k] = nil
		elseif (not attachments_sorted_alphabetically) and attachments_sorted_alphabetically:GetBool() then
			local sval = v.atts[v.sel]

			table.sort(v.atts, function(a, b)
				local aname = ""
				local bname = ""
				local att_a = TFA.Attachments.Atts[a]

				if att_a then
					aname = att_a.Name or a
				end

				local att_b = TFA.Attachments.Atts[b]

				if att_b then
					bname = att_b.Name or b
				end

				return aname < bname
			end)

			if sval then
				v.sel = table.KeyFromValue(v.atts, sval) or v.sel
			end
		end
	end

	for k, v in pairs(self.Attachments) do
		if v.sel then
			local vsel = v.sel
			v.sel = nil

			if type(vsel) == "string" then
				vsel = table.KeyFromValue(v.atts, vsel) or tonumber(vsel)

				if not vsel then goto CONTINUE end
			end

			timer.Simple(0, function()
				if IsValid(self) and self.SetTFAAttachment then
					self:SetTFAAttachment(k, vsel, false)
				end
			end)
		end

		::CONTINUE::
	end

	hook.Run("TFA_PostInitAttachments", self)
	self:RemoveUnusedAttachments()
	self:BuildAttachmentCache()
	hook.Run("TFA_FinalInitAttachments", self)

	self:RestoreAttachments()
end

local cv_persist_enable = GetConVar("cl_tfa_attachments_persist_enabled")

function SWEP:SaveAttachments()
	if not CLIENT or not cv_persist_enable:GetBool() then return end

	TFA.SetSavedAttachments(self)
end

function SWEP:RestoreAttachments()
	if not CLIENT or not cv_persist_enable:GetBool() then return end

	for cat, id in pairs(TFA.GetSavedAttachments(self) or {}) do
		self:SetTFAAttachment(cat, id, true, true)
	end
end

function SWEP:GenerateVGUIAttachmentTable()
	self.VGUIAttachments = {}
	local keyz = table.GetKeys(self.Attachments)
	table.RemoveByValue(keyz, "BaseClass")

	table.sort(keyz, function(a, b)
		--A and B are keys
		local v1 = self.Attachments[a]
		local v2 = self.Attachments[b]

		if v1 and v2 and (v1.order or v2.order) then
			return (v1.order or a) < (v2.order or b)
		else
			return a < b
		end
	end)

	for _, k in ipairs(keyz) do
		local v = self.Attachments[k]

		if not v.hidden then
			local aTbl = tableCopy(v)

			aTbl.cat = k
			aTbl.offset = nil
			aTbl.order = nil

			table.insert(self.VGUIAttachments, aTbl)
		end
	end

	ATT_DIMENSION = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	local max_row_atts = math.floor(ScrW() * ATT_MAX_SCREEN_RATIO / ATT_DIMENSION)
	local i = 1

	while true do
		local v = self.VGUIAttachments[i]
		if not v then break end
		i = i + 1

		for l, b in pairs(v.atts) do
			if not istable(b) then
				v.atts[l] = {b, l} --name, ID
			end
		end

		if (#v.atts > max_row_atts) then
			while (#v.atts > max_row_atts) do
				local t = tableCopy(v)

				for _ = 1, max_row_atts do
					table.remove(t.atts, 1)
				end

				for _ = 1, #v.atts - max_row_atts do
					table.remove(v.atts)
				end

				table.insert(self.VGUIAttachments, i, t)
			end
		end
	end
end

local bgt = {}
SWEP.ViewModelBodygroups = {}
SWEP.WorldModelBodygroups = {}

function SWEP:IterateBodygroups(entity, tablename, version)
	local self2 = self:GetTable()

	bgt = self2.GetStatVersioned(self, tablename, version or 0, self2[tablename])

	for k, v in pairs(bgt) do
		if isnumber(k) then
			local bgn = entity:GetBodygroupName(k)

			if bgt[bgn] then
				v = bgt[bgn]
			end

			if entity:GetBodygroup(k) ~= v then
				entity:SetBodygroup(k, v)
			end
		end
	end
end

function SWEP:ProcessBodygroups()
	local self2 = self:GetTable()
	local ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups")
	local WorldModelBodygroups = self:GetStatRawL("WorldModelBodygroups")

	if not self2.HasFilledBodygroupTables then
		if self2.VMIV(self) then
			for i = 0, #(self2.OwnerViewModel:GetBodyGroups() or ViewModelBodygroups) do
				ViewModelBodygroups[i] = ViewModelBodygroups[i] or 0
			end
		end

		for i = 0, #(self:GetBodyGroups() or WorldModelBodygroups) do
			WorldModelBodygroups[i] = WorldModelBodygroups[i] or 0
		end

		self2.HasFilledBodygroupTables = true
	end

	if self2.VMIV(self) then
		self2.IterateBodygroups(self, self2.OwnerViewModel, "ViewModelBodygroups", TFA.LatestDataVersion)
	end

	self2.IterateBodygroups(self, self, "WorldModelBodygroups", TFA.LatestDataVersion)
end

function SWEP:CallAttFunc(funcName, ...)
	for attName, sel in pairs(self.AttachmentCache or {}) do
		if not sel then goto CONTINUE end

		local att = TFA.Attachments.Atts[attName]
		if not att then goto CONTINUE end

		local attFunc = att[funcName]
		if attFunc and type(attFunc) == "function" then
			local _ret1, _ret2, _ret3, _ret4, _ret5, _ret6, _ret7, _ret8, _ret9, _ret10 = attFunc(att, self, ...)

			if _ret1 ~= nil then
				return _ret1, _ret2, _ret3, _ret4, _ret5, _ret6, _ret7, _ret8, _ret9, _ret10
			end
		end

		::CONTINUE::
	end

	return nil
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/effects.lua:
local fx, sp = nil, game.SinglePlayer()
local shelltype

function SWEP:PCFTracer(bul, hitpos, ovrride)
	if bul.PCFTracer then
		self:UpdateMuzzleAttachment()
		local mzp = self:GetMuzzlePos()
		if bul.PenetrationCount > 0 and not ovrride then return end --Taken care of with the pen effect

		if (CLIENT or game.SinglePlayer()) and self.Scoped and self:IsCurrentlyScoped() and self:IsFirstPerson() then
			TFA.ParticleTracer(bul.PCFTracer, self:GetOwner():GetShootPos() - self:GetOwner():EyeAngles():Up() * 5, hitpos, false, 0, -1)
		else
			local vent = self

			if (CLIENT or game.SinglePlayer()) and self:IsFirstPerson() then
				vent = self.OwnerViewModel
			end

			if sp and not self:IsFirstPerson() then
				TFA.ParticleTracer(bul.PCFTracer, self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 32, hitpos, false)
			else
				TFA.ParticleTracer(bul.PCFTracer, mzp.Pos, hitpos, false, vent, self.MuzzleAttachmentRaw or 1)
			end
		end
	end
end

function SWEP:EventShell()
	if SERVER and self.processing_events and sp then return end

	if SERVER then
		net.Start("tfaBaseShellSV", true)
		net.WriteEntity(self)

		if self:GetOwner():IsPlayer() then
			if sp then
				net.Broadcast()
			else
				net.SendOmit(self:GetOwner())
			end
		else
			net.SendPVS(self:GetPos())
		end

		return
	end

	self:MakeShellBridge()
end

function SWEP:MakeShellBridge(ifp)
	if ifp == false then return end

	if self.LuaShellEjectDelay > 0 then
		self.LuaShellRequestTime = CurTime() + self.LuaShellEjectDelay / self:GetAnimationRate(ACT_VM_PRIMARYATTACK)
	else
		self:MakeShell()
	end
end

SWEP.ShellEffectOverride = nil -- ???
SWEP.ShellEjectionQueue = 0

function SWEP:GetShellAttachmentID(ent, isVM)
	local raw = self:GetStatL("ShellAttachmentRaw")
	local israw = false
	local attid

	if raw and ent:GetAttachment(raw) then
		attid = raw
		israw = true
	else
		attid = ent:LookupAttachment(self:GetStatL("ShellAttachment"))
	end

	if self:GetStatL("IsAkimbo") and not israw then
		return 3 + self:GetAnimCycle()
	end

	if attid and attid <= 0 then attid = 2 end

	attid = math.Clamp(attid and attid or 2, 1, 127)

	return attid
end

function SWEP:GetShellEjectPosition(ent, isVM)
	local attid = self:GetShellAttachmentID(ent, isVM)

	local angpos = ent:GetAttachment(attid)

	if angpos then
		return angpos.Pos, angpos.Ang, attid
	end
end

function SWEP:MakeShell(eject_now)
	if not self:IsValid() then return end -- what
	if self.current_event_iftp == false then return end

	local retVal = hook.Run("TFA_MakeShell", self)

	if retVal ~= nil then
		return retVal
	end

	if self:GetStatL("ShellEffectOverride") then
		shelltype = self:GetStatL("ShellEffectOverride")
	elseif TFA.GetLegacyShellsEnabled() then
		shelltype = "tfa_shell_legacy"
	else
		shelltype = "tfa_shell"
	end

	local ent = self
	local isVM = false

	if self:IsFirstPerson() then
		if not eject_now and CLIENT then
			self.ShellEjectionQueue = self.ShellEjectionQueue + 1
			return
		end

		ent = self.OwnerViewModel or self
		isVM = ent == self.OwnerViewModel
	end

	self:EjectionSmoke(true)

	if not isstring(shelltype) or shelltype == "" then return end -- allows to disable shells by setting override to "" - will shut up all rp fags

	if not IsValid(ent) then return end
	local pos, ang, attid = self:GetShellEjectPosition(ent, isVM)

	if not pos then return end

	fx = EffectData()
	fx:SetEntity(self)
	fx:SetAttachment(attid)
	fx:SetMagnitude(1)
	fx:SetScale(1)
	fx:SetOrigin(pos)
	fx:SetNormal(ang:Forward())
	TFA.Effects.Create(shelltype, fx)
end

--[[
Function Name:  CleanParticles
Syntax: self:CleanParticles().
Returns:  Nothing.
Notes:  Cleans up particles.
Purpose:  FX
]]
--
function SWEP:CleanParticles()
	if not IsValid(self) then return end

	if self.StopParticles then
		self:StopParticles()
	end

	if self.StopParticleEmission then
		self:StopParticleEmission()
	end

	if not self:VMIV() then return end
	local vm = self.OwnerViewModel

	if IsValid(vm) then
		if vm.StopParticles then
			vm:StopParticles()
		end

		if vm.StopParticleEmission then
			vm:StopParticleEmission()
		end
	end
end

--[[
Function Name:  EjectionSmoke
Syntax: self:EjectionSmoke().
Returns:  Nothing.
Notes:  Puff of smoke on shell attachment.
Purpose:  FX
]]
--
function SWEP:EjectionSmoke(ovrr)
	local retVal = hook.Run("TFA_EjectionSmoke",self)
	if retVal ~= nil then
		return retVal
	end
	if TFA.GetEJSmokeEnabled() and (self:GetStatL("EjectionSmokeEnabled") or ovrr) then
		local vm = self:IsFirstPerson() and self.OwnerViewModel or self

		if IsValid(vm) then
			local att = vm:LookupAttachment(self:GetStatL("ShellAttachment"))

			if not att or att <= 0 then
				att = 2
			end

			local oldatt = att
			att = self:GetStatL("ShellAttachmentRaw", att)
			local angpos = vm:GetAttachment(att)

			if not angpos then
				att = oldatt
				angpos = vm:GetAttachment(att)
			end

			if angpos then
				fx = EffectData()
				fx:SetEntity(self)
				fx:SetOrigin(angpos.Pos)
				fx:SetAttachment(att)
				fx:SetNormal(angpos.Ang:Forward())
				TFA.Effects.Create("tfa_shelleject_smoke", fx)
			end
		end
	end
end

--[[
Function Name:  ShootEffectsCustom
Syntax: self:ShootEffectsCustom().
Returns:  Nothing.
Notes:  Calls the proper muzzleflash, muzzle smoke, muzzle light code.
Purpose:  FX
]]
--
function SWEP:MuzzleSmoke(spv)
	local retVal = hook.Run("TFA_MuzzleSmoke",self)
	if retVal ~= nil then
		return retVal
	end
	if self.SmokeParticle == nil then
		self.SmokeParticle = self.SmokeParticles[self.DefaultHoldType or self.HoldType]
	end

	if self:GetStatL("SmokeParticle") and self:GetStatL("SmokeParticle") ~= "" then
		self:UpdateMuzzleAttachment()
		local att = self:GetMuzzleAttachment()
		fx = EffectData()
		fx:SetOrigin(self:GetOwner():GetShootPos())
		fx:SetNormal(self:GetOwner():EyeAngles():Forward())
		fx:SetEntity(self)
		fx:SetAttachment(att)
		TFA.Effects.Create("tfa_muzzlesmoke", fx)
	end
end

function SWEP:MuzzleFlashCustom(spv)
	local retVal = hook.Run("TFA_MuzzleFlash",self)
	if retVal ~= nil then
		return retVal
	end
	local att = self:GetMuzzleAttachment()
	fx = EffectData()
	fx:SetOrigin(self:GetOwner():GetShootPos())
	fx:SetNormal(self:GetOwner():EyeAngles():Forward())
	fx:SetEntity(self)
	fx:SetAttachment(att)
	local mzsil = self:GetStatL("MuzzleFlashEffectSilenced")

	if (self:GetSilenced() and mzsil and mzsil ~= "") then
		TFA.Effects.Create(mzsil, fx)
	else
		TFA.Effects.Create(self:GetStatL("MuzzleFlashEffect", self.MuzzleFlashEffect or ""), fx)
	end
end

function SWEP:ShootEffectsCustom(ifp)
	if self.DoMuzzleFlash ~= nil then
		self.MuzzleFlashEnabled = self.DoMuzzleFlash
		self.DoMuzzleFlash = nil
	end

	if not self.MuzzleFlashEnabled then return end
	if self:IsFirstPerson() and not self:VMIV() then return end
	if not self:GetOwner().GetShootPos then return end
	ifp = ifp or IsFirstTimePredicted()

	if (SERVER and sp and self.ParticleMuzzleFlash) or (SERVER and not sp) then
		net.Start("tfa_base_muzzle_mp", true)
		net.WriteEntity(self)

		if sp or not self:GetOwner():IsPlayer() then
			net.SendPVS(self:GetPos())
		else
			net.SendOmit(self:GetOwner())
		end

		return
	end

	if (CLIENT and ifp and not sp) or (sp and SERVER) then
		self:UpdateMuzzleAttachment()
		self:MuzzleFlashCustom(sp)
		self:MuzzleSmoke(sp)
	end
end

--[[
Function Name:  CanDustEffect
Syntax: self:CanDustEffect( concise material name ).
Returns:  True/False
Notes:  Used for the impact effect.  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
local DustEffects = {
	[MAT_DIRT] = true,
	[MAT_CONCRETE] = true,
	[MAT_PLASTIC] = true,
	[MAT_WOOD] = true
}
function SWEP:CanDustEffect(matv)
	if DustEffects[matv] then return true end

	return false
end

--[[
Function Name:  CanSparkEffect
Syntax: self:CanSparkEffect( concise material name ).
Returns:  True/False
Notes:  Used for the impact effect.  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
local SparkEffects = {
	[MAT_METAL] = true,
	[MAT_GRATE] = true,
	[MAT_VENT] = true
}
function SWEP:CanSparkEffect(matv)
	if SparkEffects[matv] then return true end

	return false
end

-- Returns muzzle attachment position for HL2 tracers
function SWEP:GetTracerOrigin(...)
	local att = self:GetMuzzleAttachment()

	local attpos = (self:IsFirstPerson() and self.OwnerViewModel or self):GetAttachment(att)

	if attpos and attpos.Pos then
		return attpos.Pos
	end
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/viewbob.lua:
SWEP.SprintBobMult = 1.5 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this > 1 probably for sprinting.
SWEP.IronBobMult = 0.0 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.IronBobMultWalk = 0.2 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.WalkBobMult = 1 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You may want to disable it when using animated walk.
SWEP.SprintViewBobMult = 4
--[[
Function Name:  CalcView
Syntax: Don't ever call this manually.
Returns:  Nothing.
Notes:  Used to calculate view angles.
Purpose:  Feature
]]
--"
--[[

local ta = Angle()
local v = Vector()

local m_AD = math.AngleDifference
local m_NA = math.NormalizeAngle

local l_LA = function(t,a1,a2)
	ta.p = m_NA( a1.p + m_AD(a2.p,a1.p)  * t )
	ta.y = m_NA( a1.y + m_AD(a2.y,a1.y)  * t )
	ta.r = m_NA( a1.r + m_AD(a2.r,a1.r)  * t )
	return ta
end

local l_LV = function(t,v1,v2)
	v = v1  + ( v2 - v1 ) * t
	return v * 1
end
]]
--
SWEP.ViewHolProg = 0
SWEP.AttachmentViewOffset = Angle(0, 0, 0)
SWEP.ProceduralViewOffset = Angle(0, 0, 0)
--local procedural_fadeout = 0.6
local procedural_vellimit = 5
local l_Lerp = Lerp
local l_mathApproach = math.Approach
local l_mathClamp = math.Clamp
local viewbob_intensity_cvar, viewbob_animated_cvar
viewbob_intensity_cvar = GetConVar("cl_tfa_viewbob_intensity")
viewbob_animated_cvar = GetConVar("cl_tfa_viewbob_animated")
local oldangtmp
local mzang_fixed
local mzang_fixed_last
local mzang_velocity = Angle()
local progress = 0
local targint, targbool

SWEP.ViewBob_Bash = true
SWEP.ViewBob_Draw = true
SWEP.ViewBob_Holster = true
SWEP.ViewBob_Inspect = true
SWEP.ViewBob_Pump = true
SWEP.ViewBob_Reload = true
SWEP.ViewBob_Shoot = false

SWEP.ViewBob_DontFadeOutStatus = {
	[TFA.Enum.STATUS_RELOADING_LOOP_START] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP] = true,
}

SWEP.ViewBob_DontFadeOutShootStatus = {
	[TFA.Enum.SHOOT_START] = true,
	[TFA.Enum.SHOOT_LOOP] = true,
	[TFA.Enum.SHOOT_CHECK] = true,
} -- looped fire ends on TFA.Enum.SHOOT_IDLE so we include anything but that

function SWEP:CalcView(ply, pos, ang, fov)
	if not ang then return end
	if ply ~= GetViewEntity() then return end

	local self2 = self:GetTable()

	local vm = self2.OwnerViewModel
	if not IsValid(vm) then return end

	local ftv = FrameTime()
	local viewbobintensity = viewbob_intensity_cvar:GetFloat()
	local holprog = TFA.Enum.HolsterStatus[self2.GetStatus(self)] and 1 or 0
	self2.ViewHolProg = math.Approach(self2.ViewHolProg, holprog, ftv / 5)

	oldangtmp = ang * 1

	local stat = self:GetStatus()

	local ibash = stat == TFA.Enum.STATUS_BASHING or stat == TFA.Enum.STATUS_BASHING_WAIT and self2.GetStatL(self, "ViewBob_Bash")
	local idraw = stat == TFA.Enum.STATUS_DRAW and self2.GetStatL(self, "ViewBob_Draw")
	local ihols = TFA.Enum.HolsterStatus[stat] and self2.GetStatL(self, "ViewBob_Holster")
	local ifidget = stat == TFA.Enum.STATUS_FIDGET and self2.GetStatL(self, "ViewBob_Inspect")
	local ipump = stat == TFA.Enum.STATUS_PUMP and self2.GetStatL(self, "ViewBob_Pump")
	local ireload = TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "ViewBob_Reload")
	local ishoot = stat == TFA.Enum.STATUS_SHOOTING and self2.GetStatL(self, "ViewBob_Shoot") and not self:CanInterruptShooting()

	targbool = idraw or ireload or ibash or ishoot or ipump or ifidget or (ihols and not self2.GetStatL(self, "ProceduralHolsterEnabled"))
	targint = targbool and 1 or 0

	if not self2.ViewBob_DontFadeOutStatus[stat] and not self2.ViewBob_DontFadeOutShootStatus[self:GetShootStatus()] then
		targint = math.min(targint, 1 - math.pow(math.max(vm:GetCycle() - 0.5, 0) * 2, 2))
	end

	progress = l_Lerp(ftv * 20, progress, targint)

	if self2.CameraAngCache and viewbob_animated_cvar:GetBool() then
		self2.CameraAttachmentScale = self2.CameraAttachmentScale or 1
		ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, (self2.CameraAngCache.p + self2.CameraOffset.p) * viewbobintensity * -self2.CameraAttachmentScale) * viewbobintensity)
		ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, (self2.CameraAngCache.y + self2.CameraOffset.y) * viewbobintensity * self2.CameraAttachmentScale) * viewbobintensity)
		ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, (self2.CameraAngCache.r + self2.CameraOffset.r) * viewbobintensity * self2.CameraAttachmentScale) * viewbobintensity)
		-- - self2.MZReferenceAngle--WorldToLocal( angpos.Pos, angpos.Ang, angpos.Pos, oldangtmp + self2.MZReferenceAngle )
		--* progress )
		--self2.ProceduralViewOffset.p = l_mathApproach(self2.ProceduralViewOffset.p, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.p ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
		--self2.ProceduralViewOffset.y = l_mathApproach(self2.ProceduralViewOffset.y, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.y ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
		--self2.ProceduralViewOffset.r = l_mathApproach(self2.ProceduralViewOffset.r, 0 , l_mathClamp( procedural_pitchrestorefac - math.min( math.abs( self2.ProceduralViewOffset.r ), procedural_pitchrestorefac ) ,1,procedural_pitchrestorefac)*ftv/5 )
	else
		local mul = 1
		if ifidget then
			mul = -1
		end

		local att = self2.MuzzleAttachmentRaw or vm:LookupAttachment(self2.MuzzleAttachment)
		if not att then
			att = 1
		end

		local angpos = vm:GetAttachment(att)
		if angpos and angpos.Ang then
			mzang_fixed = vm:WorldToLocalAngles(angpos.Ang)
			mzang_fixed:Normalize()
		end

		self2.ProceduralViewOffset:Normalize()

		if mzang_fixed_last then
			local delta = mzang_fixed - mzang_fixed_last
			delta:Normalize()
			mzang_velocity = mzang_velocity + delta * (2 * (1 - self2.ViewHolProg))

			mzang_velocity.p = math.Approach(mzang_velocity.p, -self2.ProceduralViewOffset.p * 2, ftv * 20)
			mzang_velocity.p = math.Clamp(mzang_velocity.p, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.p = self2.ProceduralViewOffset.p + mzang_velocity.p * ftv * mul
			self2.ProceduralViewOffset.p = math.Clamp(self2.ProceduralViewOffset.p, -90, 90)

			mzang_velocity.y = math.Approach(mzang_velocity.y, -self2.ProceduralViewOffset.y * 2, ftv * 20)
			mzang_velocity.y = math.Clamp(mzang_velocity.y, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.y = self2.ProceduralViewOffset.y + mzang_velocity.y * ftv * mul
			self2.ProceduralViewOffset.y = math.Clamp(self2.ProceduralViewOffset.y, -90, 90)

			mzang_velocity.r = math.Approach(mzang_velocity.r, -self2.ProceduralViewOffset.r * 2, ftv * 20)
			mzang_velocity.r = math.Clamp(mzang_velocity.r, -procedural_vellimit, procedural_vellimit)
			self2.ProceduralViewOffset.r = self2.ProceduralViewOffset.r + mzang_velocity.r * ftv * mul
			self2.ProceduralViewOffset.r = math.Clamp(self2.ProceduralViewOffset.r, -90, 90)
		end
		mzang_fixed_last = mzang_fixed

		self2.ProceduralViewOffset.p = math.Approach(self2.ProceduralViewOffset.p, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.p * 20)
		self2.ProceduralViewOffset.y = math.Approach(self2.ProceduralViewOffset.y, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.y * 20)
		self2.ProceduralViewOffset.r = math.Approach(self2.ProceduralViewOffset.r, 0, (1 - progress) * ftv * -self2.ProceduralViewOffset.r * 20)

		local ints = viewbobintensity * 1.25
		ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, -self2.ProceduralViewOffset.p) * ints)
		ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, self2.ProceduralViewOffset.y / 2) * ints)
		ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, self2.ProceduralViewOffset.r / 3) * ints)
	end

	return pos, LerpAngle(math.pow(self2.ViewHolProg, 2), ang, oldangtmp), fov
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/viewmodel.lua:
local vector_origin = Vector()
local angle_zero = Angle()

local Vector = Vector
local Angle = Angle
local math = math
local LerpVector = LerpVector

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local cv_fov = GetConVar("fov_desired")
local cl_vm_nearwall = GetConVar("cl_tfa_viewmodel_nearwall")

local cl_tfa_viewmodel_offset_x = GetConVar("cl_tfa_viewmodel_offset_x")
local cl_tfa_viewmodel_offset_y = GetConVar("cl_tfa_viewmodel_offset_y")
local cl_tfa_viewmodel_offset_z = GetConVar("cl_tfa_viewmodel_offset_z")
local cl_tfa_viewmodel_centered = GetConVar("cl_tfa_viewmodel_centered")

local cl_tfa_viewmodel_vp_enabled = GetConVar("cl_tfa_viewmodel_vp_enabled")
local cl_tfa_viewmodel_vp_pitch = GetConVar("cl_tfa_viewmodel_vp_pitch")
local cl_tfa_viewmodel_vp_pitch_is = GetConVar("cl_tfa_viewmodel_vp_pitch_is")
local cl_tfa_viewmodel_vp_vertical = GetConVar("cl_tfa_viewmodel_vp_vertical")
local cl_tfa_viewmodel_vp_vertical_is = GetConVar("cl_tfa_viewmodel_vp_vertical_is")
local cl_tfa_viewmodel_vp_max_vertical = GetConVar("cl_tfa_viewmodel_vp_max_vertical")
local cl_tfa_viewmodel_vp_max_vertical_is = GetConVar("cl_tfa_viewmodel_vp_max_vertical_is")
local cl_tfa_viewmodel_vp_yaw = GetConVar("cl_tfa_viewmodel_vp_yaw")
local cl_tfa_viewmodel_vp_yaw_is = GetConVar("cl_tfa_viewmodel_vp_yaw_is")

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

local cv_customgunbob = GetConVar("cl_tfa_gunbob_custom")

local function Lerp(t, a, b)
	return a + (b - a) * t
end

local function Clamp(a, b, c)
	if a < b then return b end
	if a > c then return c end
	return a
end

local function GetClampedCVarFloat(cvar)
	return Clamp(cvar:GetFloat(), cvar:GetMin(), cvar:GetMax())
end

local math_max = math.max

local cl_vm_flip_cv = GetConVar("cl_tfa_viewmodel_flip")
local fovmod_add = GetConVar("cl_tfa_viewmodel_offset_fov")
local fovmod_mult = GetConVar("cl_tfa_viewmodel_multiplier_fov")

function SWEP:AirWalkScale()
	return (self:OwnerIsValid() and self:GetOwner():IsOnGround()) and 1 or 0.2
end

SWEP.OldPos = Vector(0, 0, 0)
SWEP.OldAng = Angle(0, 0, 0)

function SWEP:GetViewModelPosition(opos, oang, ...)
	local self2 = self:GetTable()

	if not self2.pos_cached then return opos, oang end

	local npos, nang = opos * 1, oang * 1

	nang:RotateAroundAxis(nang:Right(), self2.ang_cached.p)
	nang:RotateAroundAxis(nang:Up(), self2.ang_cached.y)
	nang:RotateAroundAxis(nang:Forward(), self2.ang_cached.r)
	npos:Add(nang:Right() * self2.pos_cached.x)
	npos:Add(nang:Forward() * self2.pos_cached.y)
	npos:Add(nang:Up() * self2.pos_cached.z)

	if cv_customgunbob:GetBool() then
		npos, nang = self:Sway(npos, nang)
		npos, nang = self:SprintBob(npos, nang, Lerp(self2.SprintProgressUnpredicted3 or self2.SprintProgressUnpredicted or self:GetSprintProgress(), 0, self2.SprintBobMult))
	end

	local pos, ang = self2.SightsAttPos, Angle(self2.SightsAttAng)
	if not pos or not ang then return npos, nang end

	local ofpos, ofang = WorldToLocal(npos, nang, opos, oang)

	self2.OldPos = npos
	self2.OldAng = nang

	if self.IronSightsProgressUnpredicted > 0.005 then
		local _opos, _oang = opos * 1, oang * 1

		-- tfa base vm offset
		local right, up, fwd = _oang:Right(), _oang:Up(), _oang:Forward()

		_opos = _opos - ofpos.y * right + ofpos.x * fwd + ofpos.z * up
		_oang:RotateAroundAxis(fwd, ofang.r)
		_oang:RotateAroundAxis(right, -ofang.p)
		_oang:RotateAroundAxis(up, ofang.y)

		-- sight offset

		_oang:RotateAroundAxis(_oang:Forward(), -ang.r)
		_oang:RotateAroundAxis(_oang:Right(), ang.p)
		_oang:RotateAroundAxis(_oang:Up(), -ang.y)

		right, up, fwd = _oang:Right(), _oang:Up(), _oang:Forward()

		_opos = _opos - pos.x * fwd + pos.y * right - pos.z * up

		self2.OldPos = LerpVector(self2.IronSightsProgressUnpredicted, npos, _opos)
		self2.OldAng = LerpAngle(self2.IronSightsProgressUnpredicted, nang, _oang)
	end

	return self2.OldPos, self2.OldAng
end

function SWEP:CalculateViewModelFlip()
	local self2 = self:GetTable()

	if self2.ViewModelFlipDefault == nil then
		self2.ViewModelFlipDefault = self2.ViewModelFlip
	end

	local righthanded = true

	if cl_vm_flip_cv:GetBool() then
		righthanded = false
	end

	local shouldflip = self2.ViewModelFlipDefault

	if not righthanded then
		shouldflip = not self2.ViewModelFlipDefault
	end

	if self2.ViewModelFlip ~= shouldflip then
		self2.ViewModelFlip = shouldflip
	end

	self2.ViewModelFOV_OG = self2.ViewModelFOV_OG or self2.ViewModelFOV

	local cam_fov = self2.LastTranslatedFOV or cv_fov:GetInt() or 90
	local iron_add = cam_fov * (1 - 90 / cam_fov) * math.max(1 - self2.GetStatL(self, "Secondary.OwnerFOV", 90) / 90, 0)

	local ironSightsProgress = TFA.Cosine(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress())
	self2.ViewModelFOV = Lerp(ironSightsProgress, self2.ViewModelFOV_OG, self2.GetStatL(self, "Secondary.ViewModelFOV", self2.ViewModelFOV_OG)) * GetClampedCVarFloat(fovmod_mult) + GetClampedCVarFloat(fovmod_add) + iron_add * ironSightsProgress
end

function SWEP:UpdateWeaponLength()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end
	local vm = self2.OwnerViewModel
	local mzpos = self:GetMuzzlePos()
	if not mzpos then return end
	if not mzpos.Pos then return end
	if GetViewEntity and GetViewEntity() ~= self:GetOwner() then return end
	local mzVec = vm:WorldToLocal(mzpos.Pos)
	self2.WeaponLength = math.abs(mzVec.x)
end

function SWEP:CalculateNearWall(p, a)
	local self2 = self:GetTable()
	if not self:OwnerIsValid() then return p, a end

	if not cl_vm_nearwall:GetBool() then return p, a end

	local ply = self:GetOwner()

	local sp = ply:GetShootPos()
	local ea = ply:EyeAngles()
	local et = util.QuickTrace(sp,ea:Forward()*128,{self,ply})--self:GetOwner():GetEyeTrace()
	local dist = et.HitPos:Distance(sp)

	if dist<1 then
		et=util.QuickTrace(sp,ea:Forward()*128,{self,ply,et.Entity})
		dist = et.HitPos:Distance(sp)
	end

	self:UpdateWeaponLength()

	local nw_offset_vec = LerpVector(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress(), self2.NearWallVector, self2.NearWallVectorADS)
	local off = self2.WeaponLength - dist
	self2.LastNearWallOffset = self2.LastNearWallOffset or 0

	local ft = RealFrameTime() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if off > self2.LastNearWallOffset then
		self2.LastNearWallOffset = math.min(self2.LastNearWallOffset + math.max(ft * 66, off * 0.1), off, 34)
	elseif off < self2.LastNearWallOffset then
		self2.LastNearWallOffset = math.max(self2.LastNearWallOffset - ft * 66, off, 0)
	end

	off = TFA.Cosine(self2.LastNearWallOffset / 34) * 34

	if off > 0 then
		p = p + nw_offset_vec * off / 2
		local posCompensated = sp * 1
		posCompensated:Add(ea:Right() * nw_offset_vec.x * off / 2 * (self2.ViewModelFlip and -1 or 1))
		posCompensated:Add(ea:Forward() * nw_offset_vec.y * off / 2)
		posCompensated:Add(ea:Up() * nw_offset_vec.z * off / 2)
		local angleComp = (et.HitPos - posCompensated):Angle()
		a.x = a.x - math.AngleDifference(angleComp.p, ea.p) / 2
		a.y = a.y + math.AngleDifference(angleComp.y, ea.y) / 2
	end

	return p, a
end

local centered_sprintpos = Vector(0, -1, 1)
local centered_sprintang = Vector(-15, 0, 0)

local bezierVectorBuffer = {}

local function bezierVector(t, vec1, vec2, vec3)
	local _1, _2 = vec1.x, vec3.x
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.x
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local x = TFA.tbezier(t, bezierVectorBuffer)

	_1, _2 = vec1.y, vec3.y
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.y
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local y = TFA.tbezier(t, bezierVectorBuffer)

	_1, _2 = vec1.z, vec3.z
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.z
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local z = TFA.tbezier(t, bezierVectorBuffer)

	return Vector(x, y, z)
end

function SWEP:CalculateViewModelOffset(delta)
	local self2 = self:GetTable()

	local target_pos, target_ang
	local additivePos = self2.GetStatL(self, "AdditiveViewModelPosition")

	if additivePos then
		target_pos, target_ang = Vector(), Vector()
	else
		target_pos = Vector(self2.GetStatL(self, "ViewModelPosition"))
		target_ang = Vector(self2.GetStatL(self, "ViewModelAngle"))
	end

	local CenteredViewModelPosition = self2.GetStatL(self, "CenteredViewModelPosition")
	local CenteredViewModelAngle = self2.GetStatL(self, "CenteredViewModelAngle")
	local IronSightsPosition = self2.GetStatL(self, "IronSightsPosition", self2.SightsPos)
	local IronSightsAngle = self2.GetStatL(self, "IronSightsAngle", self2.SightsAng)

	local targetPosCenter, targetAngCenter

	if CenteredViewModelPosition then
		targetPosCenter = Vector(CenteredViewModelPosition)

		if CenteredViewModelAngle then
			targetAngCenter = Vector(CenteredViewModelAngle)
		end
	elseif IronSightsPosition then
		targetPosCenter = Vector((self2.IronSightsPositionCurrent or IronSightsPosition).x, target_pos.y, target_pos.z - 3)

		if IronSightsAngle then
			targetAngCenter = Vector(0, (self2.IronSightsAngleCurrent or IronSightsAngle).y, 0)
		end
	else
		targetPosCenter, targetAngCenter = target_pos, target_ang
	end

	local stat = self:GetStatus()

	local holsterStatus = TFA.Enum.HolsterStatus[stat] and self2.GetStatL(self, "ProceduralHolsterEnabled")
	local proceduralReloadStatus = TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "IsProceduralReloadBased")
	local holsterProgress = 0
	local statusProgress = self:GetStatusProgress()

	if proceduralReloadStatus then
		holsterProgress = TFA.Quintic(Clamp((statusProgress >= 0.5 and (2 - statusProgress * 2) or (statusProgress * 2)), 0, 1))
	elseif self2.GetStatL(self, "ProceduralHolsterEnabled") then
		if TFA.Enum.HolsterStatusFinal[stat] then
			holsterProgress = 1
		elseif TFA.Enum.HolsterStatus[stat] then
			holsterProgress = TFA.Quintic(Clamp(statusProgress * 1.1, 0, 1))
		end
	end

	local sprintAnimAllowed = self2.GetStatL(self, "Sprint_Mode") ~= TFA.Enum.LOCOMOTION_ANI

	local ironSights = self:GetIronSights()
	local sprintProgress = sprintAnimAllowed and TFA.Cubic(self2.SprintProgressUnpredicted2 or self2.SprintProgressUnpredicted or self:GetSprintProgress()) or 0
	local safetyProgress = Lerp(sprintProgress, TFA.Cubic(self2.SafetyProgressUnpredicted or 0), 0)

	local ironSightsProgress = Clamp(
		Lerp(
			math_max(holsterProgress, sprintProgress, safetyProgress),
			TFA.Cubic(self2.IronSightsProgressUnpredicted2 or self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()),
			0)
		, 0, 1)

	--local ironSightsProgress = TFA.tbezier(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress(), IRON_SIGHTS_BEZIER)

	local crouchRatio = Lerp(math_max(ironSightsProgress, holsterProgress, Clamp(sprintProgress * 2, 0, 1), safetyProgress), TFA.Quintic(self2.CrouchingRatioUnpredicted or self:GetCrouchingRatio()), 0)

	if crouchRatio > 0.01 then
		target_pos = LerpVector(crouchRatio, target_pos, self2.GetStatL(self, "CrouchViewModelPosition"))
		target_ang = LerpVector(crouchRatio, target_ang, self2.GetStatL(self, "CrouchViewModelAngle"))
	end

	local isCentered = cl_tfa_viewmodel_centered:GetBool()
	if isCentered then
		target_pos:Set(targetPosCenter)
		target_ang:Set(targetAngCenter)
	end

	if holsterStatus or proceduralReloadStatus then
		local targetHolsterPos = Vector(self2.GetStatL(self, "ProceduralHolsterPosition"))
		local targetHolsterAng = Vector(self2.GetStatL(self, "ProceduralHolsterAngle"))

		if self2.ViewModelFlip then
			targetHolsterPos.x = -targetHolsterPos.x

			targetHolsterAng.y = -targetHolsterAng.y
			targetHolsterAng.z = -targetHolsterAng.z
		end

		target_pos = LerpVector(holsterProgress, target_pos, targetHolsterPos)
		target_ang = LerpVector(holsterProgress, target_ang, targetHolsterAng)
	end

	if
		(sprintProgress > 0.01 or safetyProgress > 0.01) and
		(sprintAnimAllowed and sprintProgress > 0.01 or safetyProgress > 0.01)
		and not TFA.Enum.BashStatus[stat]
	then
		local add_pos = isCentered and centered_sprintpos or vector_origin
		local add_ang = isCentered and centered_sprintang or vector_origin

		local sprint_pos = self2.GetStatL(self, "SprintViewModelPosition")
		local sprint_ang = self2.GetStatL(self, "SprintViewModelAngle")

		target_pos = LerpVector(safetyProgress, target_pos, self2.GetStatL(self, "SafetyPos", sprint_pos) + add_pos)
		target_ang = LerpVector(safetyProgress, target_ang, self2.GetStatL(self, "SafetyAng", sprint_ang) + add_ang)

		if sprintAnimAllowed then
			target_pos = LerpVector(sprintProgress, target_pos, sprint_pos + add_pos)
			target_ang = LerpVector(sprintProgress, target_ang, sprint_ang + add_ang)
		end
	end

	if ironSightsProgress > 0.02 and self2.GetStatL(self, "Sights_Mode") ~= TFA.Enum.LOCOMOTION_ANI then
		local score = self2.VM_IronPositionScore or 1
		local getSightsPos = self2.IronSightsPositionCurrent or IronSightsPosition or self2.GetStatL(self, "SightsPos", vector_origin)

		if targetPosCenter and score > 0.04 then
			target_pos = bezierVector(ironSightsProgress, target_pos, LerpVector(score, getSightsPos, targetPosCenter), getSightsPos)
		else
			target_pos = LerpVector(ironSightsProgress, target_pos, getSightsPos)
		end

		if targetAngCenter and score > 0.04 then
			local deviate = 30 * score

			if self2.VM_IsScopedIn then
				deviate = -deviate
			end

			if self2.ViewModelFlip then
				deviate = -deviate
			end

			local targetAngCenter2 = Vector(targetAngCenter.x * score, targetAngCenter.y * score, targetAngCenter.z * score + deviate)
			target_ang = bezierVector(ironSightsProgress, target_ang, targetAngCenter2, self2.IronSightsAngleCurrent or IronSightsAngle or self2.GetStatL(self, "SightsAng", vector_origin))
		else
			target_ang = LerpVector(ironSightsProgress, target_ang, self2.IronSightsAngleCurrent or IronSightsAngle or self2.GetStatL(self, "SightsAng", vector_origin))
		end
	end

	target_pos.x = target_pos.x + GetClampedCVarFloat(cl_tfa_viewmodel_offset_x) * (1 - ironSightsProgress)
	target_pos.y = target_pos.y + GetClampedCVarFloat(cl_tfa_viewmodel_offset_y) * (1 - ironSightsProgress)
	target_pos.z = target_pos.z + GetClampedCVarFloat(cl_tfa_viewmodel_offset_z) * (1 - ironSightsProgress)

	local customizationProgress = TFA.Quintic(self2.CustomizingProgressUnpredicted or self:GetInspectingProgress())

	if customizationProgress > 0.01 and self2.GetStatL(self, "Customize_Mode") ~= TFA.Enum.LOCOMOTION_ANI then
		if not self2.InspectPos then
			self2.InspectPos = Vector(self2.InspectPosDef)

			if self2.ViewModelFlip then
				self2.InspectPos.x = self2.InspectPos.x * -1
			end
		end

		if not self2.InspectAng then
			self2.InspectAng = Vector(self2.InspectAngDef)

			if self2.ViewModelFlip then
				self2.InspectAng.y = self2.InspectAngDef.y * -1
				self2.InspectAng.z = self2.InspectAngDef.z * -1
			end
		end

		target_pos = LerpVector(customizationProgress, target_pos, self2.GetStatL(self, "InspectPos"))
		target_ang = LerpVector(customizationProgress, target_ang, self2.GetStatL(self, "InspectAng"))
	end

	target_pos, target_ang = self:CalculateNearWall(target_pos, target_ang)

	if additivePos then
		target_pos:Add(self2.GetStatL(self, "ViewModelPosition"))
		target_ang:Add(self2.GetStatL(self, "ViewModelAngle"))
	end

	target_ang.z = target_ang.z + -7.5 * (1 - math.abs(0.5 - ironSightsProgress) * 2) * (self:GetIronSights() and 1 or 0.5) * (self2.ViewModelFlip and 1 or -1) * (self2.VM_IronPositionScore or 1)

	if self:GetHidden() then
		target_pos.z = target_pos.z - 5
	end

	if self2.GetStatL(self, "BlowbackEnabled") and self2.BlowbackCurrentRoot > 0.01 then
		local bbvec = self2.GetStatL(self, "BlowbackVector")
		target_pos = target_pos + bbvec * self2.BlowbackCurrentRoot
		local bbang = self2.GetStatL(self, "BlowbackAngle") or angle_zero
		bbvec = bbvec * 1
		bbvec.x = bbang.p
		bbvec.y = bbang.y
		bbvec.z = bbang.r
		target_ang = target_ang + bbvec * self2.BlowbackCurrentRoot
		bbang = self2.BlowbackRandomAngle * (1 - math.max(0, ironSightsProgress) * .8)
		bbvec.x = bbang.p
		bbvec.y = bbang.y
		bbvec.z = bbang.r
		target_ang = target_ang + bbvec * self2.BlowbackCurrentRoot
	end

	if not sv_tfa_recoil_legacy:GetBool() and cl_tfa_viewmodel_vp_enabled:GetBool() then
		if self:HasRecoilLUT() then
			if not ironSights then
				local ang = self:GetRecoilLUTAngle()

				target_ang.x = target_ang.x - ang.p / 2 * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchPitchMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch), self:GetStatL("ViewModelPunchPitchMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch_is))
				target_ang.y = target_ang.y + ang.y / 2 * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchYawMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw), self:GetStatL("ViewModelPunchYawMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw_is))
			end
		else
			target_ang.x = target_ang.x - self:GetViewPunchP() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchPitchMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch), self:GetStatL("ViewModelPunchPitchMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch_is))
			target_ang.y = target_ang.y + self:GetViewPunchY() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchYawMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw), self:GetStatL("ViewModelPunchYawMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw_is))

			local ViewModelPunch_MaxVertialOffset = Lerp(ironSightsProgress, self:GetStatL("ViewModelPunch_MaxVertialOffset") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_max_vertical), self:GetStatL("ViewModelPunch_MaxVertialOffset_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_max_vertical_is))

			target_pos.y = target_pos.y + math.Clamp(
				self:GetViewPunchP() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunch_VertialMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_vertical), self:GetStatL("ViewModelPunch_VertialMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_vertical_is)),
				-ViewModelPunch_MaxVertialOffset,
				ViewModelPunch_MaxVertialOffset)
		end
	end

	if not cv_customgunbob:GetBool() then
		self2.pos_cached, self2.ang_cached = Vector(target_pos), Angle(target_ang.x, target_ang.y, target_ang.z)

		return
	end

	local intensityWalk = math.min(self:GetOwner():GetVelocity():Length2D() / self:GetOwner():GetWalkSpeed(), 1) * Lerp(ironSightsProgress, self2.WalkBobMult, self2.WalkBobMult_Iron or self2.WalkBobMult)
	local intensityBreath = Lerp(ironSightsProgress, self2.GetStatL(self, "BreathScale", 0.2), self2.GetStatL(self, "IronBobMultWalk", 0.5) * intensityWalk)
	intensityWalk = (1 - ironSightsProgress) * intensityWalk
	local intensityRun = Lerp(self2.SprintProgressUnpredicted3 or self2.SprintProgressUnpredicted or self:GetSprintProgress(), 0, self2.SprintBobMult)
	local velocity = math.max(self:GetOwner():GetVelocity():Length2D() * self:AirWalkScale() - self:GetOwner():GetVelocity().z * 0.5, 0)
	local rate = math.min(math.max(0.15, math.sqrt(velocity / self:GetOwner():GetRunSpeed()) * 1.75), self:GetSprinting() and 5 or 3)

	self2.pos_cached, self2.ang_cached = self:WalkBob(
		target_pos,
		Angle(target_ang.x, target_ang.y, target_ang.z),
		math.max(intensityBreath - intensityWalk - intensityRun, 0),
		math.max(intensityWalk - intensityRun, 0), rate, delta)
end

local rft, eyeAngles, viewPunch, oldEyeAngles, delta, motion, counterMotion, compensation, fac, positionCompensation, swayRate, wiggleFactor, flipFactor

local gunswaycvar = GetConVar("cl_tfa_gunbob_intensity")
local gunswayinvertcvar = GetConVar("cl_tfa_gunbob_invertsway")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

function SWEP:Sway(pos, ang, ftv)
	local self2 = self:GetTable()
	--sanity check
	if not self:OwnerIsValid() then return pos, ang end
	--convar
	fac = GetClampedCVarFloat(gunswaycvar) * 3 * ((1 - ((self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) or 0)) * 0.85 + 0.15)
	if gunswayinvertcvar:GetBool() then fac = -fac end
	flipFactor = (self2.ViewModelFlip and -1 or 1)
	--init vars
	delta = delta or Angle()
	motion = motion or Angle()
	counterMotion = counterMotion or Angle()
	compensation = compensation or Angle()

	if ftv then
		--grab eye angles
		eyeAngles = self:GetOwner():EyeAngles()
		viewPunch = self:GetOwner():GetViewPunchAngles()
		eyeAngles.p = eyeAngles.p - viewPunch.p
		eyeAngles.y = eyeAngles.y - viewPunch.y
		oldEyeAngles = oldEyeAngles or eyeAngles
		--calculate delta
		wiggleFactor = (1 - (sv_tfa_weapon_weight:GetBool() and self2.GetStatL(self, "RegularMoveSpeedMultiplier") or 1)) / 0.6 + 0.15
		swayRate = math.pow(sv_tfa_weapon_weight:GetBool() and self2.GetStatL(self, "RegularMoveSpeedMultiplier") or 1, 1.5) * 10
		rft = math.Clamp(ftv, 0.001, 1 / 20)
		local clampFac = 1.1 - math.min((math.abs(motion.p) + math.abs(motion.y) + math.abs(motion.r)) / 20, 1)
		delta.p = math.AngleDifference(eyeAngles.p, oldEyeAngles.p) / rft / 120 * clampFac
		delta.y = math.AngleDifference(eyeAngles.y, oldEyeAngles.y) / rft / 120 * clampFac
		delta.r = math.AngleDifference(eyeAngles.r, oldEyeAngles.r) / rft / 120 * clampFac
		oldEyeAngles = eyeAngles
		--calculate motions, based on Juckey's methods
		counterMotion = LerpAngle(rft * (swayRate * (0.75 + math.max(0, 0.5 - wiggleFactor))), counterMotion, -motion)
		compensation.p = math.AngleDifference(motion.p, -counterMotion.p)
		compensation.y = math.AngleDifference(motion.y, -counterMotion.y)
		motion = LerpAngle(rft * swayRate, motion, delta + compensation)
	end

	--modify position/angle
	positionCompensation = 0.2 + 0.2 * ((self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) or 0)
	pos:Add(-motion.y * positionCompensation * 0.66 * fac * ang:Right() * flipFactor) --compensate position for yaw
	pos:Add(-motion.p * positionCompensation * fac * ang:Up()) --compensate position for pitch
	ang:RotateAroundAxis(ang:Right(), motion.p * fac)
	ang:RotateAroundAxis(ang:Up(), -motion.y * 0.66 * fac * flipFactor)
	ang:RotateAroundAxis(ang:Forward(), counterMotion.r * 0.5 * fac * flipFactor)

	return pos, ang
end

local mirror = Matrix()

hook.Add("PostRender", "TFA:CacheSightsPos", function()
	local self = LocalPlayer():GetActiveWeapon()
	if not IsValid(self) then return end
	local self2 = self:GetTable()
	if not self2.IsTFAWeapon then return end
	if not self2.ViewModelFlip then return end

	if not self2.VMIV(self) then return end
	local vm = self2.OwnerViewModel

	self2.ViewModelFlip = false

	vm:SetRenderOrigin(vector_origin)
	vm:SetRenderAngles(angle_zero)

	vm:InvalidateBoneCache()
	vm:SetupBones()

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	if ViewModelElements and self2.HasInitAttachments then
		if not self2.vRenderOrder then
			self:RebuildModsRenderOrder()
		end

		TFA._IncNextSetupBones()

		for index = 1, #self2.vRenderOrder do
			local name = self2.vRenderOrder[index]
			local element = ViewModelElements[name]

			if not element then
				self:RebuildModsRenderOrder()
				break
			end

			if element.type ~= "Model" then goto CONTINUE end

			if element.hide then goto CONTINUE end
			if not element.bone then goto CONTINUE end

			if self2.GetStatL(self, "ViewModelElements." .. name .. ".active") == false then goto CONTINUE end

			local pos, ang = self:GetBoneOrientation(ViewModelElements, element, vm, nil, true)
			if not pos and not element.bonemerge then goto CONTINUE end

			self:PrecacheElement(element, true)

			local model = element.curmodel
			local sprite = element.spritemat

			if IsValid(model) then
				if not element.bonemerge then
					model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)
					ang:RotateAroundAxis(ang:Up(), element.angle.y)
					ang:RotateAroundAxis(ang:Right(), element.angle.p)
					ang:RotateAroundAxis(ang:Forward(), element.angle.r)
					model:SetAngles(ang)
					mirror:Identity()
					mirror:Scale(element.size)
					model:EnableMatrix("RenderMultiply", mirror)
				end

				if not self2.VElementsBodygroupsCache[index] then
					self2.VElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
				end

				if self2.VElementsBodygroupsCache[index] then
					for _b = 0, self2.VElementsBodygroupsCache[index] do
						local newbg = self2.GetStatL(self, "ViewModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

						if model:GetBodygroup(_b) ~= newbg then
							model:SetBodygroup(_b, newbg)
						end
					end
				end

				if element.bonemerge then
					if element.rel and ViewModelElements[element.rel] and IsValid(ViewModelElements[element.rel].curmodel) then
						element.parModel = ViewModelElements[element.rel].curmodel
					else
						element.parModel = self2.OwnerViewModel or self
					end

					if model:GetParent() ~= element.parModel then
						model:SetParent(element.parModel)
					end

					if not model:IsEffectActive(EF_BONEMERGE) then
						model:AddEffects(EF_BONEMERGE)
						model:AddEffects(EF_BONEMERGE_FASTCULL)
						model:SetMoveType(MOVETYPE_NONE)
						model:SetLocalPos(vector_origin)
						model:SetLocalAngles(angle_zero)
					end
				elseif model:IsEffectActive(EF_BONEMERGE) then
					model:RemoveEffects(EF_BONEMERGE)
					model:SetParent(NULL)
				end

				model:InvalidateBoneCache()
				model:SetupBones()
				model.tfa_next_setup_bones = TFA._GetNextSetupBones()
			end

			::CONTINUE::
		end
	end

	self:CacheSightsPos(vm, true)

	vm:SetRenderOrigin()
	vm:SetRenderAngles()

	self.ViewModelFlip = true
	vm:InvalidateBoneCache()
end)

function SWEP:CacheSightsPos(vm, flipped)
	self.SightsAttPos, self.SightsAttAng = nil, nil

	if not self:GetStat("ProceduralSight", false) then return end

	local model = vm
	local attname = self:GetStat("ProceduralSight_VElement")

	if attname then
		if not self:GetStat("VElements." .. attname .. ".active", false) then return end

		model = self.VElements[attname].curmodel
	end

	if not IsValid(model) then return end

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	TFA._IncNextSetupBones()

	if self:GetStat("ProceduralSight_PositionType", TFA.Enum.SIGHTSPOS_ATTACH) == TFA.Enum.SIGHTSPOS_BONE then
		local boneid = self:GetStat("ProceduralSight_Bone")
		if not boneid then return end

		if type(boneid) == "string" then
			boneid = model:LookupBone(boneid)
		end

		if not boneid or boneid < 0 then return end

		self.SightsAttPos, self.SightsAttAng = model:GetBonePosition(boneid)
	else
		local attid = self:GetStat("ProceduralSight_Attachment")
		if not attid then return end

		if type(attid) == "string" then
			attid = model:LookupAttachment(attid)
		end

		if not attid or attid <= 0 then return end

		local attpos = model:GetAttachment(attid)

		self.SightsAttPos, self.SightsAttAng = attpos.Pos, attpos.Ang
	end

	if self.SightsAttPos and self.SightsAttAng then
		if not flipped then
			local transform = Matrix()
			transform:Translate(vm:GetPos())
			transform:Rotate(vm:GetAngles())
			transform:Invert()

			transform:Translate(self.SightsAttPos)
			transform:Rotate(self.SightsAttAng)

			self.SightsAttPos, self.SightsAttAng = transform:GetTranslation(), transform:GetAngles()
		end

		local OffsetPos = self:GetStatL("ProceduralSight_OffsetPos")

		if OffsetPos then
			if GetConVarNumber("developer") > 0 then -- draw pre-offset pos
				local a, b = LocalToWorld(self.SightsAttPos, self.SightsAttAng, vm:GetPos(), vm:GetAngles())

				render.DrawLine(a, a + b:Forward() * 1, Color(127, 0, 0), false)
				render.DrawLine(a, a - b:Right() * 1, Color(0, 127, 0), false)
				render.DrawLine(a, a + b:Up() * 1, Color(0, 0, 127), false)
			end

			self.SightsAttPos:Add(self.SightsAttAng:Right() * OffsetPos.x)
			self.SightsAttPos:Add(self.SightsAttAng:Forward() * OffsetPos.y)
			self.SightsAttPos:Add(self.SightsAttAng:Up() * OffsetPos.z)
		end

		local OffsetAng = self:GetStatL("ProceduralSight_OffsetAng")

		if OffsetAng then
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Right(), OffsetAng.p)
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Up(), OffsetAng.y)
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Forward(), OffsetAng.r)
		end

		if GetConVarNumber("developer") > 0 then -- draw final pos
			local a, b = LocalToWorld(self.SightsAttPos, self.SightsAttAng, vm:GetPos(), vm:GetAngles())

			render.DrawLine(a, a + b:Forward() * 1, Color(255, 0, 0), false)
			render.DrawLine(a, a - b:Right() * 1, Color(0, 255, 0), false)
			render.DrawLine(a, a + b:Up() * 1, Color(0, 0, 255), false)
		end
	end
end
--addons/tfa_base/lua/weapons/tfa_gun_base/client/bobcode.lua:
local vector_origin = Vector()

SWEP.ti = 0
SWEP.LastCalcBob = 0
SWEP.tiView = 0
SWEP.LastCalcViewBob = 0
local TAU = math.pi * 2
local rateScaleFac = 2
local rate_up = 6 * rateScaleFac
local scale_up = 0.5
local rate_right = 3 * rateScaleFac
local scale_right = -0.5
local rate_forward_view = 3 * rateScaleFac
local scale_forward_view = 0.35
local rate_right_view = 3 * rateScaleFac
local scale_right_view = -1
local rate_p = 6 * rateScaleFac
local scale_p = 3
local rate_y = 3 * rateScaleFac
local scale_y = 6
local rate_r = 3 * rateScaleFac
local scale_r = -6
local pist_rate = 3 * rateScaleFac
local pist_scale = 9
local rate_clamp = 2 * rateScaleFac
local walkIntensitySmooth, breathIntensitySmooth = 0, 0
local walkRate = 160 / 60 * TAU / 1.085 / 2 * rateScaleFac --steps are at 160bpm at default velocity, then divide that by 60 for per-second, multiply by TAU for trig, divided by default walk rate
local walkVec = Vector()
local ownerVelocity, ownerVelocityMod = Vector(), Vector()
local zVelocity, zVelocitySmooth = 0, 0
local xVelocity, xVelocitySmooth, rightVec = 0, 0, Vector()
local flatVec = Vector(1, 1, 0)
local WalkPos = Vector()
local WalkPosLagged = Vector()
local gunbob_intensity_cvar = GetConVar("cl_tfa_gunbob_intensity")
local gunbob_intensity = 0
SWEP.VMOffsetWalk = Vector(0.5, -0.5, -0.5)
SWEP.footstepTotal = 0
SWEP.footstepTotalTarget = 0
local upVec, riVec, fwVec = Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 0)

local function l_Lerp(t, a, b)
	if t <= 0 then return a end
	if t >= 1 then return b end
	return a + (b - a) * t
end

function SWEP:WalkBob(pos, ang, breathIntensity, walkIntensity, rate, ftv)
	local self2 = self:GetTable()
	if not self2.OwnerIsValid(self) then return end
	rate = math.min(rate or 0.5, rate_clamp)
	gunbob_intensity = gunbob_intensity_cvar:GetFloat()

	local ea = self:GetOwner():EyeAngles()
	local up = ang:Up()
	local ri = ang:Right()
	local fw = ang:Forward()
	local upLocal = upVec
	local riLocal = riVec
	local fwLocal = fwVec
	local delta = ftv
	local flip_v = self2.ViewModelFlip and -1 or 1
	--delta = delta * game.GetTimeScale()
	--self2.LastCalcBob = SysTime()
	self2.bobRateCached = rate
	self2.ti = self2.ti + delta * rate

	if self2.SprintStyle == nil then
		if self:GetStatL("SprintViewModelAngle") and self:GetStatL("SprintViewModelAngle").x > 5 then
			self2.SprintStyle = 1
		else
			self2.SprintStyle = 0
		end
	end

	--preceding calcs
	walkIntensitySmooth = l_Lerp(delta * 10 * rateScaleFac, walkIntensitySmooth, walkIntensity)
	breathIntensitySmooth = l_Lerp(delta * 10 * rateScaleFac, breathIntensitySmooth, breathIntensity)
	walkVec = LerpVector(walkIntensitySmooth, vector_origin, self2.VMOffsetWalk)
	ownerVelocity = self:GetOwner():GetVelocity()
	zVelocity = ownerVelocity.z
	zVelocitySmooth = l_Lerp(delta * 7 * rateScaleFac, zVelocitySmooth, zVelocity)
	ownerVelocityMod = ownerVelocity * flatVec
	ownerVelocityMod:Normalize()
	rightVec = ea:Right() * flatVec
	rightVec:Normalize()
	xVelocity = ownerVelocity:Length2D() * ownerVelocityMod:Dot(rightVec)
	xVelocitySmooth = l_Lerp(delta * 5 * rateScaleFac, xVelocitySmooth, xVelocity)

	--multipliers
	breathIntensity = breathIntensitySmooth * gunbob_intensity * 1.5
	walkIntensity = walkIntensitySmooth * gunbob_intensity * 1.5

	--breathing / walking while ADS
	local breatheMult2 = math.Clamp((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()), 0, 1)
	--local breatheMult2 = 0
	local breatheMult1 = 1 - breatheMult2
	--local breatheMult1 = 1

	pos:Add(riLocal * (math.sin(self2.ti * walkRate) - math.cos(self2.ti * walkRate)) * flip_v * breathIntensity * 0.2 * breatheMult1)
	pos:Add(upLocal * math.sin(self2.ti * walkRate) * breathIntensity * 0.5 * breatheMult1)

	pos:Add(riLocal * math.cos(self2.ti * walkRate / 2) * flip_v * breathIntensity * 0.6 * breatheMult2)
	pos:Add(upLocal * math.sin(self2.ti * walkRate) * breathIntensity * 0.3 * breatheMult2)

	--walk anims, danny method because i just can't
	self2.walkTI = (self2.walkTI or 0) + delta * 160 / 60 * self:GetOwner():GetVelocity():Length2D() / self:GetOwner():GetWalkSpeed()
	WalkPos.x = l_Lerp(delta * 5 * rateScaleFac, WalkPos.x, -math.sin(self2.ti * walkRate * 0.5) * gunbob_intensity * walkIntensity)
	WalkPos.y = l_Lerp(delta * 5 * rateScaleFac, WalkPos.y, math.sin(self2.ti * walkRate) / 1.5 * gunbob_intensity * walkIntensity)
	WalkPosLagged.x = l_Lerp(delta * 5 * rateScaleFac, WalkPosLagged.x, -math.sin((self2.ti * walkRate * 0.5) + math.pi / 3) * gunbob_intensity * walkIntensity)
	WalkPosLagged.y = l_Lerp(delta * 5 * rateScaleFac, WalkPosLagged.y, math.sin(self2.ti * walkRate + math.pi / 3) / 1.5 * gunbob_intensity * walkIntensity)
	pos:Add(WalkPos.x * 0.33 * riLocal)
	pos:Add(WalkPos.y * 0.25 * upLocal)
	ang:RotateAroundAxis(ri, -WalkPosLagged.y)
	ang:RotateAroundAxis(up, WalkPosLagged.x)
	ang:RotateAroundAxis(fw, WalkPos.x)

	--constant offset
	pos:Add(riLocal * walkVec.x * flip_v)
	pos:Add(fwLocal * walkVec.y)
	pos:Add(upLocal * walkVec.z)

	--jumping
	local trigX = -math.Clamp(zVelocitySmooth / 200, -1, 1) * math.pi / 2
	local jumpIntensity = (3 + math.Clamp(math.abs(zVelocitySmooth) - 100, 0, 200) / 200 * 4) * (1 - (self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) * 0.8)
	pos:Add(ri * math.sin(trigX) * scale_r * 0.1 * jumpIntensity * flip_v * 0.4)
	pos:Add(-up * math.sin(trigX) * scale_r * 0.1 * jumpIntensity * 0.4)
	ang:RotateAroundAxis(ang:Forward(), math.sin(trigX) * scale_r * jumpIntensity * flip_v * 0.4)

	--rolling with horizontal motion
	local xVelocityClamped = xVelocitySmooth

	if math.abs(xVelocityClamped) > 200 then
		local sign = (xVelocityClamped < 0) and -1 or 1
		xVelocityClamped = (math.sqrt((math.abs(xVelocityClamped) - 200) / 50) * 50 + 200) * sign
	end

	ang:RotateAroundAxis(ang:Forward(), xVelocityClamped * 0.04 * flip_v)

	return pos, ang
end

function SWEP:SprintBob(pos, ang, intensity, origPos, origAng)
	local self2 = self:GetTable()
	if not IsValid(self:GetOwner()) or not gunbob_intensity then return pos, ang end
	local flip_v = self2.ViewModelFlip and -1 or 1

	local eyeAngles = self:GetOwner():EyeAngles()
	local localUp = ang:Up()
	local localRight = ang:Right()
	local localForward = ang:Forward()

	local playerUp = eyeAngles:Up()
	local playerRight = eyeAngles:Right()
	local playerForward = eyeAngles:Forward()

	intensity = intensity * gunbob_intensity * 1.5
	gunbob_intensity = gunbob_intensity_cvar:GetFloat()

	if intensity > 0.005 then
		if self2.SprintStyle == 1 then
			local intensity3 = math.max(intensity - 0.3, 0) / (1 - 0.3)
			ang:RotateAroundAxis(ang:Up(), math.sin(self2.ti * pist_rate) * pist_scale * intensity3 * 0.33 * 0.75)
			ang:RotateAroundAxis(ang:Forward(), math.sin(self2.ti * pist_rate) * pist_scale * intensity3 * 0.33 * -0.25)
			pos:Add(ang:Forward() * math.sin(self2.ti * pist_rate * 2 + math.pi) * pist_scale * -0.1 * intensity3 * 0.4)
			pos:Add(ang:Right() * math.sin(self2.ti * pist_rate) * pist_scale * 0.15 * intensity3 * 0.33 * 0.2)
		else
			pos:Add(localUp * math.sin(self2.ti * rate_up + math.pi) * scale_up * intensity * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_right) * scale_right * intensity * flip_v * 0.33)
			pos:Add(eyeAngles:Forward() * math.max(math.sin(self2.ti * rate_forward_view), 0) * scale_forward_view * intensity * 0.33)
			pos:Add(eyeAngles:Right() * math.sin(self2.ti * rate_right_view) * scale_right_view * intensity * flip_v * 0.33)

			ang:RotateAroundAxis(localRight, math.sin(self2.ti * rate_p + math.pi) * scale_p * intensity * 0.33)
			pos:Add(-localUp * math.sin(self2.ti * rate_p + math.pi) * scale_p * 0.1 * intensity * 0.33)

			ang:RotateAroundAxis(localUp, math.sin(self2.ti * rate_y) * scale_y * intensity * flip_v * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_y) * scale_y * 0.1 * intensity * flip_v * 0.33)

			ang:RotateAroundAxis(localForward, math.sin(self2.ti * rate_r) * scale_r * intensity * flip_v * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_r) * scale_r * 0.05 * intensity * flip_v * 0.33)
			pos:Add(localUp * math.sin(self2.ti * rate_r) * scale_r * 0.1 * intensity * 0.33)
		end
	end

	return pos, ang
end

local cv_customgunbob = GetConVar("cl_tfa_gunbob_custom")
local fac, bscale

function SWEP:UpdateEngineBob()
	local self2 = self:GetTable()

	if cv_customgunbob:GetBool() then
		self2.BobScale = 0
		self2.SwayScale = 0

		return
	end

	local isp = self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()
	local wpr = self2.WalkProgressUnpredicted or self:GetWalkProgress()
	local spr = self:GetSprintProgress()

	fac = gunbob_intensity_cvar:GetFloat() * ((1 - isp) * 0.85 + 0.15)
	bscale = fac

	if spr > 0.005 then
		bscale = bscale * l_Lerp(spr, 1, self2.SprintBobMult)
	elseif wpr > 0.005 then
		bscale = bscale * l_Lerp(wpr, 1, l_Lerp(isp, self2.WalkBobMult, self2.WalkBobMult_Iron or self2.WalkBobMult))
	end

	self2.BobScale = bscale
	self2.SwayScale = fac
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/mods.lua:
--[[Thanks to Clavus.  Like seriously, SCK was brilliant. Even though you didn't include a license anywhere I could find, it's only fit to credit you.]]
--

local vector_origin = Vector()

--[[
Function Name:  InitMods
Syntax: self:InitMods().  Should be called only once for best performance.
Returns:  Nothing.
Notes:  Creates the VElements and WElements table, and sets up mods.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:InitMods()
	--Create a new table for every weapon instance.
	self.SWEPConstructionKit = true

	self.ViewModelElements = self:CPTbl(self.ViewModelElements)
	self.WorldModelElements = self:CPTbl(self.WorldModelElements)
	self.ViewModelBoneMods = self:CPTbl(self.ViewModelBoneMods)

	-- i have no idea how this gonna behave without that with SWEP Construction kit
	-- so we gonna leave this thing alone and precache everything
	self:CreateModels(self.ViewModelElements, true) -- create viewmodels
	self:CreateModels(self.WorldModelElements) -- create worldmodels

	--Build the bones and such.
	if self:OwnerIsValid() then
		local vm = self.OwnerViewModel

		if IsValid(vm) then
			--self:ResetBonePositions(vm)
			if (self.ShowViewModel == nil or self.ShowViewModel) then
				vm:SetColor(Color(255, 255, 255, 255))
				--This hides the viewmodel, FYI, lol.
			else
				vm:SetMaterial("Debug/hsv")
			end
		end
	end
end

--[[
Function Name:  UpdateProjectedTextures
Syntax: self:UpdateProjectedTextures().  Automatically called already.
Returns:  Nothing.
Notes:  This takes care of our flashlight and laser.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--

function SWEP:UpdateProjectedTextures(view)
	self:DrawLaser(view)
	self:DrawFlashlight(view)
end

--[[
Function Name:  ViewModelDrawn
Syntax: self:ViewModelDrawn().  Automatically called already.
Returns:  Nothing.
Notes:  This draws the mods.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:PreDrawViewModel(vm, wep, ply)
	self:ProcessBodygroups()

	--vm:SetupBones()

	if self:GetHidden() then
		render.SetBlend(0)
	end
end

SWEP.CameraAttachmentOffsets = {{"p", 0}, {"y", 0}, {"r", 0}}
SWEP.CameraAttachment = nil
SWEP.CameraAttachments = {"camera", "attach_camera", "view", "cam", "look"}
SWEP.CameraAngCache = nil
local tmpvec = Vector(0, 0, -2000)

do
	local reference_table

	local function rendersorter(a, b)
		local ar, br = reference_table[a], reference_table[b]

		if ar == br then
			return a > b
		end

		return ar > br
	end

	local function inc_references(lookup, name, entry, output, level)
		output[name] = (output[name] or 0) + level
		local elemother = lookup[entry.rel]

		if elemother then
			inc_references(lookup, entry.rel, elemother, output, level + 1)
		end
	end

	function SWEP:RebuildModsRenderOrder()
		self.vRenderOrder = {}
		self.wRenderOrder = {}
		self.VElementsBodygroupsCache = {}
		self.WElementsBodygroupsCache = {}

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion) or {}
		local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion) or {}

		if istable(ViewModelElements) then
			local target = self.vRenderOrder
			reference_table = {}

			for k, v in pairs(ViewModelElements) do
				if v.type == "Model" then
					table.insert(target, k)
					inc_references(ViewModelElements, k, v, reference_table, 10000)
				elseif v.type == "Sprite" or v.type == "Quad" or v.type == "Bodygroup" then
					table.insert(target, k)
					inc_references(ViewModelElements, k, v, reference_table, 1)
				end
			end

			table.sort(target, rendersorter)
		end

		if istable(WorldModelElements) then
			local target2 = self.wRenderOrder
			reference_table = {}

			for k, v in pairs(WorldModelElements) do
				if v.type == "Model" then
					table.insert(target2, 1, k)
					inc_references(WorldModelElements, k, v, reference_table, 10000)
				elseif v.type == "Sprite" or v.type == "Quad" or v.type == "Bodygroup" then
					table.insert(target2, k)
					inc_references(WorldModelElements, k, v, reference_table, 1)
				end
			end

			table.sort(target2, rendersorter)
		end

		return self.vRenderOrder, self.wRenderOrder
	end
end

function SWEP:RemoveModsRenderOrder()
	self.vRenderOrder = nil
end

local drawfn, drawself, fndrawpos, fndrawang, fndrawsize

local function dodrawfn()
	drawfn(drawself, fndrawpos, fndrawang, fndrawsize)
end

local next_setup_bones = 0

function TFA._IncNextSetupBones()
	next_setup_bones = next_setup_bones + 1
end

function TFA._GetNextSetupBones()
	return next_setup_bones
end

local mirror_scale = Vector(1, -1, 1)
local normal_scale = Vector(1, 1, 1)

local mirror = Matrix()

local DRAW_AND_SETUP = 0
local ONLY_DRAW = 1
local ONLY_SETUP = 2

local function draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, nodraw)
	if self2.GetStatL(self, "ViewModelElements." .. name .. ".active") == false then return end
	if self2.TFA_IsDrawingStencilSights and self2.GetStatL(self, "StencilSight_VElement") == name then return end

	local pos, ang = self:GetBoneOrientation(ViewModelElements, element, vm, nil, true)
	if not pos and not element.bonemerge then return end

	self:PrecacheElement(element, true)

	local model = element.curmodel
	local sprite = element.spritemat

	local dodraw = nodraw == DRAW_AND_SETUP or nodraw == ONLY_DRAW
	local dosetup = nodraw == DRAW_AND_SETUP or nodraw == ONLY_SETUP

	if element.type == "Model" and IsValid(model) then
		if not element.bonemerge and dosetup then
			mirror:Identity()

			if self2.ViewModelFlip then
				model:SetPos(pos + ang:Forward() * element.pos.x - ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), -element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), -element.angle.r)

				mirror:Scale(mirror_scale)
				mirror:Scale(element.size)
			else
				model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				mirror:Scale(normal_scale)
				mirror:Scale(element.size)
			end

			model:SetAngles(ang)
			model:EnableMatrix("RenderMultiply", mirror)
		end

		if dodraw then
			if element.surpresslightning then
				render.SuppressEngineLighting(true)
			end

			local material = self:GetStatL("ViewModelElements." .. name .. ".material")

			if not material or material == "" then
				model:SetMaterial("")
			elseif model:GetMaterial() ~= material then
				model:SetMaterial(material)
			end

			local skin = self:GetStatL("ViewModelElements." .. name .. ".skin")

			if skin and skin ~= model:GetSkin() then
				model:SetSkin(skin)
			end

			if not self2.SCKMaterialCached_V[name] then
				self2.SCKMaterialCached_V[name] = true

				local materialtable = self:GetStatL("ViewModelElements." .. name .. ".materials", {})
				local entmats = table.GetKeys(model:GetMaterials())

				for _, k in ipairs(entmats) do
					model:SetSubMaterial(k - 1, materialtable[k] or "")
				end
			end
		end

		if dosetup then
			if not self2.VElementsBodygroupsCache[index] then
				self2.VElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
			end

			if self2.VElementsBodygroupsCache[index] then
				for _b = 0, self2.VElementsBodygroupsCache[index] do
					local newbg = self2.GetStatL(self, "ViewModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

					if model:GetBodygroup(_b) ~= newbg then
						model:SetBodygroup(_b, newbg)
					end
				end
			end

			if element.bonemerge then
				model:SetPos(pos)
				model:SetAngles(ang)

				if element.rel and ViewModelElements[element.rel] and IsValid(ViewModelElements[element.rel].curmodel) then
					element.parModel = ViewModelElements[element.rel].curmodel
				else
					element.parModel = self2.OwnerViewModel or self
				end

				if model:GetParent() ~= element.parModel then
					model:SetParent(element.parModel)
				end

				if not model:IsEffectActive(EF_BONEMERGE) then
					model:AddEffects(EF_BONEMERGE)
					model:AddEffects(EF_BONEMERGE_FASTCULL)
					model:SetMoveType(MOVETYPE_NONE)
					model:SetLocalPos(vector_origin)
					model:SetLocalAngles(angle_zero)
				end
			elseif model:IsEffectActive(EF_BONEMERGE) then
				model:RemoveEffects(EF_BONEMERGE)
				model:SetParent(NULL)
			end
		end

		if dodraw then
			render.SetColorModulation(element.color.r / 255, element.color.g / 255, element.color.b / 255)
			render.SetBlend(element.color.a / 255)
		end

		if dosetup and model.tfa_next_setup_bones ~= next_setup_bones then
			model:InvalidateBoneCache()
			model:SetupBones()
			model.tfa_next_setup_bones = next_setup_bones
		end

		if dodraw then
			if self2.ViewModelFlip then
				render.CullMode(MATERIAL_CULLMODE_CW)
			end

			model:DrawModel()

			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if self2.ViewModelFlip then
				render.CullMode(MATERIAL_CULLMODE_CCW)
			end

			if element.surpresslightning then
				render.SuppressEngineLighting(false)
			end
		end
	elseif dodraw and element.type == "Sprite" and sprite then
		local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
		render.SetMaterial(sprite)
		render.DrawSprite(drawpos, element.size.x, element.size.y, element.color)
	elseif dodraw and element.type == "Quad" and element.draw_func then
		local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
		ang:RotateAroundAxis(ang:Up(), element.angle.y)
		ang:RotateAroundAxis(ang:Right(), element.angle.p)
		ang:RotateAroundAxis(ang:Forward(), element.angle.r)

		cam.Start3D2D(drawpos, ang, element.size)
		render.PushFilterMin(TEXFILTER.ANISOTROPIC)
		render.PushFilterMag(TEXFILTER.ANISOTROPIC)

		drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func, self, nil, nil, nil
		ProtectedCall(dodrawfn)

		render.PopFilterMin()
		render.PopFilterMag()
		cam.End3D2D()
	end
end

function SWEP:ViewModelDrawn()
	local self2 = self:GetTable()
	render.SetBlend(1)

	if self2.DrawHands then
		self2.DrawHands(self)
	end

	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	if not self:GetOwner().GetHands then return end

	if self2.UseHands then
		local hands = self:GetOwner():GetHands()

		if IsValid(hands) then
			if not self2.GetHidden(self) then
				hands:SetParent(vm)
			else
				hands:SetParent(nil)
				hands:SetPos(tmpvec)
			end
		end
	end

	self2.UpdateBonePositions(self, vm)

	if not self2.CameraAttachment then
		self2.CameraAttachment = -1

		for _, v in ipairs(self2.CameraAttachments) do
			local attid = vm:LookupAttachment(v)

			if attid and attid > 0 then
				self2.CameraAttachment = attid
				break
			end
		end
	end

	if self2.CameraAttachment and self2.CameraAttachment > 0 then
		local angpos = vm:GetAttachment(self2.CameraAttachment)

		if angpos and angpos.Ang then
			local ftv = FrameTime()
			local angv = angpos.Ang
			local off = vm:WorldToLocalAngles(angv)
			local spd = 15
			local cycl = vm:GetCycle()
			self2.CameraAngCache = self2.CameraAngCache or off

			for _, v in pairs(self2.CameraAttachmentOffsets) do
				local offtype = v[1]
				local offang = v[2]

				if offtype == "p" then
					off:RotateAroundAxis(off:Right(), offang)
				elseif offtype == "y" then
					off:RotateAroundAxis(off:Up(), offang)
				elseif offtype == "r" then
					off:RotateAroundAxis(off:Forward(), offang)
				end
			end

			if self2.ViewModelFlip then
				off = Angle()
			end

			local stat = self:GetStatus()

			if (stat == TFA.Enum.STATUS_DRAW) and cycl < 0.05 then
				local mul = cycl / 0.05

				self2.CameraAngCache.p = self2.CameraAngCache.p * mul
				self2.CameraAngCache.y = self2.CameraAngCache.y * mul
				self2.CameraAngCache.r = self2.CameraAngCache.r * mul
			elseif TFA.Enum.HolsterStatus[stat] and cycl > 0.95 and not self2.GetStatL(self, "ProceduralHolsterEnabled") then
				local mul = 1 - (cycl - 0.95) / 0.05

				self2.CameraAngCache.p = self2.CameraAngCache.p * mul
				self2.CameraAngCache.y = self2.CameraAngCache.y * mul
				self2.CameraAngCache.r = self2.CameraAngCache.r * mul
			end

			self2.CameraAngCache.p = math.Approach(self2.CameraAngCache.p, off.p, (self2.CameraAngCache.p - off.p) * ftv * spd)
			self2.CameraAngCache.y = math.Approach(self2.CameraAngCache.y, off.y, (self2.CameraAngCache.y - off.y) * ftv * spd)
			self2.CameraAngCache.r = math.Approach(self2.CameraAngCache.r, off.r, (self2.CameraAngCache.r - off.r) * ftv * spd)
		else
			self2.CameraAngCache.p = 0
			self2.CameraAngCache.y = 0
			self2.CameraAngCache.r = 0
		end
	end

	local ViewModelElements = self:GetStatRawL("ViewModelElements") or {}
	local ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups") or {}

	if ViewModelElements and self2.HasInitAttachments then
		-- ViewModelElements = self:GetStatL("ViewModelElements")
		-- self:CreateModels(ViewModelElements, true)

		self2.SCKMaterialCached_V = self2.SCKMaterialCached_V or {}

		if not self2.vRenderOrder then
			self:RebuildModsRenderOrder()
		end

		vm:InvalidateBoneCache()
		vm:SetupBones()
		next_setup_bones = next_setup_bones + 1

		for index = 1, #self2.vRenderOrder do
			local name = self2.vRenderOrder[index]
			local element = ViewModelElements[name]

			if not element then
				self:RebuildModsRenderOrder()
				break
			end

			if element.type == "Bodygroup" then
				if element.index and element.value_active then
					ViewModelBodygroups[element.index] = self2.GetStatL(self, "ViewModelElements." .. name .. ".active") and element.value_active or (element.value_inactive or 0)
				end

				goto CONTINUE
			end

			if element.hide then goto CONTINUE end

			if element.type == "Quad" and element.draw_func_outer then goto CONTINUE end
			if not element.bone and not element.attachment then goto CONTINUE end

			draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, element.translucent == true and ONLY_SETUP or DRAW_AND_SETUP)

			::CONTINUE::
		end
	end

	if not self2.UseHands and self2.ViewModelDrawnPost then
		self:ViewModelDrawnPost()
		self:ViewModelDrawnPostFinal()
	end

	if self2.ShellEjectionQueue ~= 0 then
		for i = 1, self2.ShellEjectionQueue do
			self:MakeShell(true)
		end

		self2.ShellEjectionQueue = 0
	end
end

function SWEP:ViewModelDrawnPostFinal()
	local self2 = self:GetTable()
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end

	local ViewModelElements = self:GetStatRawL("ViewModelElements")
	if not ViewModelElements then return end

	for index = 1, #self2.vRenderOrder do
		local name = self2.vRenderOrder[index]
		local element = ViewModelElements[name]

		if element.hide or not element.translucent then goto CONTINUE end

		if element.type == "Quad" and element.draw_func_outer then goto CONTINUE end
		if not element.bone and not element.attachment then goto CONTINUE end

		draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, ONLY_DRAW)

		::CONTINUE::
	end
end

function SWEP:ViewModelDrawnPost()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	if not self.ViewModelFlip then
		self2.CacheSightsPos(self, self.OwnerViewModel, false)
	end

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	if not ViewModelElements or not self2.vRenderOrder then return end

	for index = 1, #self2.vRenderOrder do
		local name = self2.vRenderOrder[index]
		local element = ViewModelElements[name]

		if element.type == "Quad" and element.draw_func_outer and not element.hide and (element.bone or element.attachment and element.attachment ~= "") and self:GetStatL("ViewModelElements." .. name .. ".active") ~= false then
			local pos, ang = self:GetBoneOrientation(ViewModelElements, element, self2.OwnerViewModel)

			if pos then
				local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func_outer, self, drawpos, ang, element.size
				ProtectedCall(dodrawfn)
			end
		end
	end
end

--[[
Function Name:  DrawWorldModel
Syntax: self:DrawWorldModel().  Automatically called already.
Returns:  Nothing.
Notes:  This draws the world model, plus its attachments.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:DrawWorldModel()
	local self2 = self:GetTable()

	local skinStat = self2.GetStatL(self, "Skin")
	if isnumber(skinStat) then
		if self:GetSkin() ~= skinStat then
			self:SetSkin(skinStat)
		end
	end

	if not self2.MaterialCached_W and self2.GetStatL(self, "MaterialTable_W") then
		self2.MaterialCached_W = {}
		self:SetSubMaterial()

		local collectedKeys = table.GetKeys(self2.GetStatL(self, "MaterialTable_W"))
		table.Merge(collectedKeys, table.GetKeys(self2.GetStatL(self, "MaterialTable")))

		for _, k in ipairs(collectedKeys) do
			if (k == "BaseClass") then goto CONTINUE end

			local v = self2.GetStatL(self, "MaterialTable_W")[k]

			if not self2.MaterialCached_W[k] then
				self:SetSubMaterial(k - 1, v)
				self2.MaterialCached_W[k] = true
			end

			::CONTINUE::
		end
	end

	local ply = self:GetOwner()
	local validowner = IsValid(ply)

	if validowner then
		-- why? this tanks FPS because source doesn't have a chance to setup bones when it needs to
		-- instead we ask it to do it `right now`
		-- k then
		ply:SetupBones()
		ply:InvalidateBoneCache()
		self:InvalidateBoneCache()
	end

	if self2.ShowWorldModel == nil or self2.ShowWorldModel or not validowner then
		self2.WorldModelOffsetUpdate(self, ply)
		self2.ProcessBodygroups(self)

		self:DrawModel()
	end

	self:SetupBones()
	self2.UpdateWMBonePositions(self)

	self:DrawWElements()

	if IsValid(self) and self.IsTFAWeapon and (self:GetOwner() ~= LocalPlayer() or not self:IsFirstPerson()) then
		self2.UpdateProjectedTextures(self, false)
	end
end

function SWEP:DrawWElements()
	local self2 = self:GetTable()

	local WorldModelElements = self2.GetStatRaw(self, "WorldModelElements", TFA.LatestDataVersion)

	if not WorldModelElements then return end

	if not self2.SCKMaterialCached_W then
		self2.SCKMaterialCached_W = {}
	end

	if not self2.wRenderOrder then
		self2.RebuildModsRenderOrder(self)
	end

	local ply = self:GetOwner()
	local validowner = IsValid(ply)

	for index = 1, #self2.wRenderOrder do
		local name = self2.wRenderOrder[index]
		local element = WorldModelElements[name]

		if not element then
			self2.RebuildModsRenderOrder(self)
			break
		end

		if element.type == "Bodygroup" then
			if element.index and element.value_active then
				self2.WorldModelBodygroups[element.index] = self2.GetStatL(self, "WorldModelElements." .. name .. ".active") and element.value_active or (element.value_inactive or 0)
			end

			goto CONTINUE
		end

		if element.hide then goto CONTINUE end
		if self2.GetStatL(self, "WorldModelElements." .. name .. ".active") == false then goto CONTINUE end

		local bone_ent = (validowner and ply:LookupBone(element.bone or "ValveBiped.Bip01_R_Hand")) and ply or self
		local pos, ang

		if element.bone then
			pos, ang = self2.GetBoneOrientation(self, WorldModelElements, element, bone_ent)
		else
			pos, ang = self2.GetBoneOrientation(self, WorldModelElements, element, bone_ent, "ValveBiped.Bip01_R_Hand")
		end

		if not pos and not element.bonemerge then goto CONTINUE end

		self2.PrecacheElement(self, element, true)

		local model = element.curmodel
		local sprite = element.spritemat

		if element.type == "Model" and IsValid(model) then
			if element.bonemerge then
				model:SetPos(pos)
				model:SetAngles(ang)
			else
				model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				model:SetAngles(ang)
			end

			local material = self2.GetStatL(self, "WorldModelElements." .. name .. ".material")

			if not material or material == "" then
				model:SetMaterial("")
			elseif model:GetMaterial() ~= material then
				model:SetMaterial(material)
			end

			local skin = self2.GetStatL(self, "WorldModelElements." .. name .. ".skin")

			if skin and skin ~= model:GetSkin() then
				model:SetSkin(skin)
			end

			if not self2.SCKMaterialCached_W[name] then
				self2.SCKMaterialCached_W[name] = true

				local materialtable = self2.GetStatL(self, "WorldModelElements." .. name .. ".materials", {})
				local entmats = table.GetKeys(model:GetMaterials())

				for _, k in ipairs(entmats) do
					model:SetSubMaterial(k - 1, materialtable[k] or "")
				end
			end

			if not self2.WElementsBodygroupsCache[index] then
				self2.WElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
			end

			if self2.WElementsBodygroupsCache[index] then
				for _b = 0, self2.WElementsBodygroupsCache[index] do
					local newbg = self2.GetStatL(self, "WorldModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

					if model:GetBodygroup(_b) ~= newbg then
						model:SetBodygroup(_b, newbg)
					end
				end
			end

			if element.surpresslightning then
				render.SuppressEngineLighting(true)
			end

			if element.bonemerge then
				if element.rel and WorldModelElements[element.rel] and IsValid(WorldModelElements[element.rel].curmodel) and WorldModelElements[element.rel].bone ~= "oof" then
					element.parModel = WorldModelElements[element.rel].curmodel
				else
					element.parModel = self
				end

				if model:GetParent() ~= element.parModel then
					model:SetParent(element.parModel)
				end

				if not model:IsEffectActive(EF_BONEMERGE) then
					model:AddEffects(EF_BONEMERGE)
					model:SetLocalPos(vector_origin)
					model:SetLocalAngles(angle_zero)
				end
			elseif model:IsEffectActive(EF_BONEMERGE) then
				model:RemoveEffects(EF_BONEMERGE)
				model:SetParent(nil)
			end

			render.SetColorModulation(element.color.r / 255, element.color.g / 255, element.color.b / 255)
			render.SetBlend(element.color.a / 255)

			model:DrawModel()

			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if element.surpresslightning then
				render.SuppressEngineLighting(false)
			end
		elseif element.type == "Sprite" and sprite then
			local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
			render.SetMaterial(sprite)
			render.DrawSprite(drawpos, element.size.x, element.size.y, element.color)
		elseif element.type == "Quad" and element.draw_func then
			local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
			ang:RotateAroundAxis(ang:Up(), element.angle.y)
			ang:RotateAroundAxis(ang:Right(), element.angle.p)
			ang:RotateAroundAxis(ang:Forward(), element.angle.r)
			cam.Start3D2D(drawpos, ang, element.size)

			drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func, self, nil, nil, nil
			ProtectedCall(dodrawfn)

			cam.End3D2D()
		end

		::CONTINUE::
	end
end

function SWEP:WorldModelOffsetUpdate(ply)
	if not IsValid(ply) then
		self:SetRenderOrigin(nil)
		self:SetRenderAngles(nil)

		local WorldModelOffset = self:GetStatRawL("WorldModelOffset")

		if WorldModelOffset and WorldModelOffset.Scale then
			self:SetModelScale(WorldModelOffset.Scale, 0)
		end

		return
	end


	local WorldModelOffset = self:GetStatRawL("WorldModelOffset")

		-- THIS IS DANGEROUS
	if WorldModelOffset and WorldModelOffset.Pos and WorldModelOffset.Ang then
		-- TO DO ONLY CLIENTSIDE
		-- since this will break hitboxes!
		local handBone = ply:LookupBone("ValveBiped.Bip01_R_Hand")

		if handBone then
			--local pos, ang = ply:GetBonePosition(handBone)
			local pos, ang
			local mat = ply:GetBoneMatrix(handBone)

			if mat then
				pos, ang = mat:GetTranslation(), mat:GetAngles()
			else
				pos, ang = ply:GetBonePosition(handBone)
			end

			local opos, oang, oscale = WorldModelOffset.Pos, WorldModelOffset.Ang, WorldModelOffset.Scale

			pos = pos + ang:Forward() * opos.Forward + ang:Right() * opos.Right + ang:Up() * opos.Up
			ang:RotateAroundAxis(ang:Up(), oang.Up)
			ang:RotateAroundAxis(ang:Right(), oang.Right)
			ang:RotateAroundAxis(ang:Forward(), oang.Forward)
			self:SetRenderOrigin(pos)
			self:SetRenderAngles(ang)
			--if WorldModelOffset.Scale and ( !self2.MyModelScale or ( WorldModelOffset and self2.MyModelScale!=WorldModelOffset.Scale ) ) then
			self:SetModelScale(oscale or 1, 0)
			--end
		end
	end
end

--[[
Function Name:  GetBoneOrientation
Syntax: self:GetBoneOrientation( base bone mod table, bone mod table, entity, bone override ).
Returns:  Position, Angle.
Notes:  This is a very specific function for a specific purpose, and shouldn't be used generally to get a bone's orientation.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:GetBoneOrientation(basetabl, tabl, ent, bone_override, isVM, isAttachment, isNonRoot)
	local bone, pos, ang

	if not IsValid(ent) then return Vector(), Angle() end

	if not isNonRoot and tabl.rel and tabl.rel ~= "" and not tabl.bonemerge then
		local v = basetabl[tabl.rel]
		if not v then return Vector(), Angle() end

		local boneName = tabl.bone

		if tabl.attachment and tabl.attachment ~= "" and v.curmodel:LookupAttachment(tabl.attachment) ~= 0 then
			pos, ang = self:GetBoneOrientation(basetabl, v, v.curmodel, tabl.attachment, isVM, true, true)

			if pos and ang then return pos, ang end
		elseif v.curmodel and ent ~= v.curmodel and (v.bonemerge or (boneName and boneName ~= "" and v.curmodel:LookupBone(boneName))) then
			pos, ang = self:GetBoneOrientation(basetabl, v, v.curmodel, boneName, isVM, false, true)

			if pos and ang then return pos, ang end
		else
			--As clavus states in his original code, don't make your elements named the same as a bone, because recursion.
			pos, ang = self:GetBoneOrientation(basetabl, v, ent, nil, isVM, false, true)

			if pos and ang then
				pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				-- For mirrored viewmodels.  You might think to scale negatively on X, but this isn't the case.

				return pos, ang
			end
		end
	end

	if isAttachment == nil then isAttachment = tabl.attachment ~= nil end

	if isnumber(bone_override) then
		bone = bone_override
	elseif isAttachment then
		bone = ent:LookupAttachment(bone_override or tabl.attachment)
	else
		bone = ent:LookupBone(bone_override or tabl.bone) or 0
	end

	if not bone or bone == -1 then return end
	pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)

	if ent.tfa_next_setup_bones ~= next_setup_bones then
		ent:InvalidateBoneCache()
		ent:SetupBones()
		ent.tfa_next_setup_bones = next_setup_bones
	end

	if isAttachment then
		-- mmmm yes tasty LuaVM memory
		-- GC screams in agony
		local get = ent:GetAttachment(bone)

		if get then
			pos, ang = get.Pos, get.Ang
		end
	else

		local m = ent:GetBoneMatrix(bone)

		if m then
			pos, ang = m:GetTranslation(), m:GetAngles()
		end
	end

	local owner = self:GetOwner()

	if isVM and self.ViewModelFlip then
		ang.r = -ang.r
	end

	return pos, ang
end
--[[
Function Name:  CleanModels
Syntax: self:CleanModels( elements table ).
Returns:   Nothing.
Notes:  Removes all existing models.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:CleanModels(input)
	if not istable(input) then return end

	for _, v in pairs(input) do
		if (v.type == "Model" and v.curmodel) then
			if IsValid(v.curmodel) then
				v.curmodel:Remove()
			end

			v.curmodel = nil
		elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spritemat or v.cursprite ~= v.sprite)) then
			v.cursprite = nil
			v.spritemat = nil
		end
	end
end

function SWEP:PrecacheElementModel(element, is_vm)
	element.curmodel = ClientsideModel(element.model, RENDERGROUP_OTHER)
	element.curmodel.tfa_gun_parent = self
	element.curmodel.tfa_gun_clmodel = true

	if self.SWEPConstructionKit then
		TFA.RegisterClientsideModel(element.curmodel, self)
	end

	if not IsValid(element.curmodel) then
		element.curmodel = nil
		return
	end

	element.curmodel:SetPos(self:GetPos())
	element.curmodel:SetAngles(self:GetAngles())
	element.curmodel:SetParent(self)
	element.curmodel:SetOwner(self)
	element.curmodel:SetNoDraw(true)

	if element.material then
		element.curmodel:SetMaterial(element.material or "")
	end

	if element.skin then
		element.curmodel:SetSkin(element.skin)
	end

	local matrix = Matrix()
	matrix:Scale(element.size)

	element.curmodel:EnableMatrix("RenderMultiply", matrix)
	element.curmodelname = element.model
	element.view = is_vm == true

	-- // make sure we create a unique name based on the selected options
end

do
	local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

	function SWEP:PrecacheElementSprite(element, is_vm)
		if element.vmt then
			element.spritemat = Material(element.sprite)
			element.cursprite = element.sprite
			return
		end

		local name = "tfa-" .. element.sprite .. "-"

		local params = {
			["$basetexture"] = element.sprite
		}

		for _, element_property in ipairs(tocheck) do
			if (element[element_property]) then
				params["$" .. element_property] = 1
				name = name .. "1"
			else
				name = name .. "0"
			end
		end

		element.cursprite = element.sprite
		element.spritemat = CreateMaterial(name, "UnlitGeneric", params)
	end
end

function SWEP:PrecacheElement(element, is_vm)
	if element.type == "Model" and element.model and (not IsValid(element.curmodel) or element.curmodelname ~= element.model) and element.model ~= "" then
		if IsValid(element.curmodel) then
			element.curmodel:Remove()
		end

		self:PrecacheElementModel(element, is_vm)
	elseif (element.type == "Sprite" and element.sprite and element.sprite ~= "" and (not element.spritemat or element.cursprite ~= element.sprite)) then
		self:PrecacheElementSprite(element, is_vm)
	end
end

--[[
Function Name:  CreateModels
Syntax: self:CreateModels( elements table ).
Returns:   Nothing.
Notes:  Creates the elements for whatever you give it.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:CreateModels(input, is_vm)
	if not istable(input) then return end

	for _, element in pairs(input) do
		self:PrecacheElement(element, is_vm)
	end
end

--[[
Function Name:  UpdateBonePositions
Syntax: self:UpdateBonePositions( viewmodel ).
Returns:   Nothing.
Notes:   Updates the bones for a viewmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
local bpos, bang
local onevec = Vector(1, 1, 1)
local getKeys = table.GetKeys

local function appendTable(t, t2)
	for i = 1, #t2 do
		t[#t + 1] = t2[i]
	end
end

SWEP.ChildrenScaled = {}
SWEP.ViewModelBoneMods_Children = {}

function SWEP:ScaleChildBoneMods(ent,bone,cumulativeScale)
	if self.ChildrenScaled[bone] then
		return
	end
	self.ChildrenScaled[bone] = true
	local boneid = ent:LookupBone(bone)
	if not boneid then return end
	local curScale = (cumulativeScale or Vector(1,1,1)) * 1
	if self.ViewModelBoneMods[bone] then
		curScale = curScale * self.ViewModelBoneMods[bone].scale
	end
	local ch = ent:GetChildBones(boneid)
	if ch and #ch > 0 then
		for _, boneChild in ipairs(ch) do
			self:ScaleChildBoneMods(ent,ent:GetBoneName(boneChild),curScale)
		end
	end
	if self.ViewModelBoneMods[bone] then
		self.ViewModelBoneMods[bone].scale = curScale
	else
		self.ViewModelBoneMods_Children[bone] = {
			["pos"] = vector_origin,
			["angle"] = angle_zero,
			["scale"] = curScale * 1
		}
	end
end

local vmbm_old_count = 0

function SWEP:UpdateBonePositions(vm)
	local self2 = self:GetTable()
	local vmbm = self2.GetStatL(self, "ViewModelBoneMods")

	local vmbm_count = 0

	if vmbm then
		vmbm_count = table.Count(vmbm)
	end

	if vmbm_old_count ~= vmbm_count then
		self:ResetBonePositions()
	end

	vmbm_old_count = vmbm_count

	if vmbm then
		local stat = self:GetStatus()

		if not self2.BlowbackBoneMods then
			self2.BlowbackBoneMods = {}
			self2.BlowbackCurrent = 0
		end

		if not self2.HasSetMetaVMBM then
			for k,v in pairs(self2.ViewModelBoneMods) do
				if (k == "BaseClass") then goto CONTINUE end -- do not name your bones like this pls

				local scale = v.scale

				if scale and scale.x ~= 1 or scale.y ~= 1 or scale.z ~= 1 then
					self:ScaleChildBoneMods(vm, k)
				end

				::CONTINUE::
			end

			for _,v in pairs(self2.BlowbackBoneMods) do
				v.pos_og = v.pos
				v.angle_og = v.angle
				v.scale_og = v.scale or onevec
			end

			self2.HasSetMetaVMBM = true
			self2.ViewModelBoneMods["wepEnt"] = self

			setmetatable(self2.ViewModelBoneMods, {__index = function(t,k)
				if not IsValid(self) then return end
				if self2.ViewModelBoneMods_Children[k] then return self2.ViewModelBoneMods_Children[k] end
				if not self2.BlowbackBoneMods[k] then return end
				if not ( self2.SequenceEnabled[ACT_VM_RELOAD_EMPTY] and TFA.Enum.ReloadStatus[stat] and self2.Blowback_PistolMode ) then
					self2.BlowbackBoneMods[k].pos = self2.BlowbackBoneMods[k].pos_og * self2.BlowbackCurrent
					self2.BlowbackBoneMods[k].angle = self2.BlowbackBoneMods[k].angle_og * self2.BlowbackCurrent
					self2.BlowbackBoneMods[k].scale = Lerp(self2.BlowbackCurrent, onevec, self2.BlowbackBoneMods[k].scale_og)
					return self2.BlowbackBoneMods[k]
				end
			end})
		end

		if not ( self2.SequenceEnabled[ACT_VM_RELOAD_EMPTY] and TFA.Enum.ReloadStatus[stat] and self2.Blowback_PistolMode ) then
			self2.BlowbackCurrent = math.Approach(self2.BlowbackCurrent, 0, self2.BlowbackCurrent * FrameTime() * 30)
		end

		local keys = getKeys(vmbm)
		appendTable(keys, getKeys(self2.GetStatL(self, "BlowbackBoneMods") or self2.BlowbackBoneMods))
		appendTable(keys, getKeys(self2.ViewModelBoneMods_Children))

		for _,k in pairs(keys) do
			if k == "wepEnt" then goto CONTINUE end

			local v = vmbm[k] or self2.GetStatL(self, "ViewModelBoneMods." .. k)
			if not v then goto CONTINUE end

			local vscale, vangle, vpos = v.scale, v.angle, v.pos

			local bone = vm:LookupBone(k)
			if not bone then goto CONTINUE end

			local b = self2.GetStatL(self, "BlowbackBoneMods." .. k)

			if b then
				vscale = Lerp(self2.BlowbackCurrent, vscale, vscale * b.scale)
				vangle = vangle + b.angle * self2.BlowbackCurrent
				vpos = vpos + b.pos * self2.BlowbackCurrent
			end

			if vm:GetManipulateBoneScale(bone) ~= vscale then
				vm:ManipulateBoneScale(bone, vscale)
			end

			if vm:GetManipulateBoneAngles(bone) ~= vangle then
				vm:ManipulateBoneAngles(bone, vangle)
			end

			if vm:GetManipulateBonePosition(bone) ~= vpos then
				vm:ManipulateBonePosition(bone, vpos)
			end

			::CONTINUE::
		end
	elseif self2.BlowbackBoneMods then
		for bonename, tbl in pairs(self2.BlowbackBoneMods) do
			local bone = vm:LookupBone(bonename)

			if bone and bone >= 0 then
				bpos = tbl.pos * self2.BlowbackCurrent
				bang = tbl.angle * self2.BlowbackCurrent
				vm:ManipulateBonePosition(bone, bpos)
				vm:ManipulateBoneAngles(bone, bang)
			end
		end
	end
end

--[[
Function Name:  ResetBonePositions
Syntax: self:ResetBonePositions( viewmodel ).
Returns:   Nothing.
Notes:   Resets the bones for a viewmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:ResetBonePositions(val)
	if SERVER then
		self:CallOnClient("ResetBonePositions", "")

		return
	end

	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	if (not vm:GetBoneCount()) then return end

	for i = 0, vm:GetBoneCount() do
		vm:ManipulateBoneScale(i, Vector(1, 1, 1))
		vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		vm:ManipulateBonePosition(i, vector_origin)
	end
end

--[[
Function Name:  UpdateWMBonePositions
Syntax: self:UpdateWMBonePositions( worldmodel ).
Returns:   Nothing.
Notes:   Updates the bones for a worldmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:UpdateWMBonePositions()
	if not self.WorldModelBoneMods then
		self.WorldModelBoneMods = {}
	end

	local WM_BoneMods = self:GetStatL("WorldModelBoneMods", self.WorldModelBoneMods)

	if next(WM_BoneMods) then
		for bone = 0, self:GetBoneCount() - 1 do
			local bonemod = WM_BoneMods[self:GetBoneName(bone)]
			if not bonemod then goto CONTINUE end

			local childscale
			local cur = self:GetBoneParent(bone)

			while (cur ~= -1) do
				local par = WM_BoneMods[self:GetBoneName(cur)]

				if par then
					childscale = (childscale or onevec) * (par.scale or onevec)
				end

				cur = self:GetBoneParent(cur)
			end

			local s = (bonemod.scale or onevec)
			if childscale then
				s = s * childscale
			end

			if self:GetManipulateBoneScale(bone) ~= s then
				self:ManipulateBoneScale(bone, s)
			end

			local a = bonemod.angle or angle_zero

			if self:GetManipulateBoneAngles(bone) ~= a then
				self:ManipulateBoneAngles(bone, a)
			end

			local p = bonemod.pos or vector_origin

			if self:GetManipulateBonePosition(bone) ~= p then
				self:ManipulateBonePosition(bone, p)
			end

			::CONTINUE::
		end
	end
end

--[[
Function Name:  ResetWMBonePositions
Syntax: self:ResetWMBonePositions( worldmodel ).
Returns:   Nothing.
Notes:   Resets the bones for a worldmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:ResetWMBonePositions(wm)
	if SERVER then
		self:CallOnClient("ResetWMBonePositions", "")

		return
	end

	if not wm then
		wm = self
	end

	if not IsValid(wm) then return end

	for i = 0, wm:GetBoneCount() - 1 do
		wm:ManipulateBoneScale(i, Vector(1, 1, 1))
		wm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		wm:ManipulateBonePosition(i, vector_origin)
	end
end

function SWEP:PreDrawStencilSight(vm, ply, SightElementTable)
end

function SWEP:PostDrawStencilSight(vm, ply, SightElementTable)
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/laser.lua:
local vector_origin = Vector()

local att, angpos, attname, elemname, targetent
local col = Color(255, 0, 0, 255)
local pc
local laserline
local laserdot
local laserFOV = 1.5
local traceres

local render = render
local Material = Material
local ProjectedTexture = ProjectedTexture
local math = math

SWEP.LaserDistance = 12 * 50 -- default 50 feet
SWEP.LaserDistanceVisual = 12 * 4 --default 4 feet

local function IsHolstering(wep)
	if IsValid(wep) and TFA.Enum.HolsterStatus[wep:GetStatus()] then return true end

	return false
end

function SWEP:DrawLaser(is_vm)
	local self2 = self:GetTable()

	if not laserline then
		laserline = Material(self2.LaserLine or "cable/smoke")
	end

	if not laserdot then
		laserdot = Material(self2.LaserDot or "effects/tfalaserdot")
	end

	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsPlayer() then
		local f = ply.GetNW2Vector or ply.GetNWVector
		pc = f(ply, "TFALaserColor", vector_origin)
		col.r = pc.x
		col.g = pc.y
		col.b = pc.z
	else
		col.r = 255
		col.g = 0
		col.b = 0
	end

	if is_vm then
		if not self2.VMIV(self) then
			self:CleanLaser()

			return
		end

		targetent = self2.OwnerViewModel
		elemname = self2.GetStatL(self, "LaserSight_VElement", self2.GetStatL(self, "LaserSight_Element"))

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

		if elemname and ViewModelElements[elemname] and IsValid(ViewModelElements[elemname].curmodel) then
			targetent = ViewModelElements[elemname].curmodel
		end

		att = self2.GetStatL(self, "LaserSightAttachment")
		attname = self2.GetStatL(self, "LaserSightAttachmentName")

		if attname then
			att = targetent:LookupAttachment(attname)
		end

		if (not att) or att <= 0 then
			self:CleanLaser()

			return
		end

		angpos = targetent:GetAttachment(att)

		if not angpos then
			self:CleanLaser()

			return
		end

		if self2.LaserDotISMovement and self2.CLIronSightsProgress > 0 then
			local isang = self2.GetStatL(self, "IronSightsAngle")
			angpos.Ang:RotateAroundAxis(angpos.Ang:Right(), isang.y * (self2.ViewModelFlip and -1 or 1) * self2.CLIronSightsProgress)
			angpos.Ang:RotateAroundAxis(angpos.Ang:Up(), -isang.x * self2.CLIronSightsProgress)
		end

		local localProjAng = select(2, WorldToLocal(vector_origin, angpos.Ang, vector_origin, EyeAngles()))
		localProjAng.p = localProjAng.p * ply:GetFOV() / self2.ViewModelFOV
		localProjAng.y = localProjAng.y * ply:GetFOV() / self2.ViewModelFOV
		local wsProjAng = select(2, LocalToWorld(vector_origin, localProjAng, vector_origin, EyeAngles())) --reprojection for trace angle
		traceres = util.QuickTrace(ply:GetShootPos(), wsProjAng:Forward() * 999999, ply)

		if not IsValid(ply.TFALaserDot) and not IsHolstering(self) then
			local lamp = ProjectedTexture()
			ply.TFALaserDot = lamp
			lamp:SetTexture(laserdot:GetString("$basetexture"))
			lamp:SetFarZ(self2.LaserDistance) -- How far the light should shine
			lamp:SetFOV(laserFOV)
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(angpos.Ang)
			lamp:SetBrightness(5)
			lamp:SetNearZ(1)
			lamp:SetEnableShadows(false)
			lamp:Update()
		end

		local lamp = ply.TFALaserDot

		if IsValid(lamp) then
			local lamppos = EyePos() + EyeAngles():Up() * 4
			local ang = (traceres.HitPos - lamppos):Angle()
			self2.laserpos_old = traceres.HitPos
			ang:RotateAroundAxis(ang:Forward(), math.Rand(-180, 180))
			lamp:SetPos(lamppos)
			lamp:SetAngles(ang)
			lamp:SetColor(col)
			lamp:SetFOV(laserFOV * math.Rand(0.9, 1.1))
			lamp:Update()
		end

		return
	end

	targetent = self

	elemname = self2.GetStatL(self, "LaserSight_WElement", self2.GetStatL(self, "LaserSight_Element"))

	local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion)

	if elemname and WorldModelElements[elemname] and IsValid(WorldModelElements[elemname].curmodel) then
		targetent = WorldModelElements[elemname].curmodel
	end

	att = self2.GetStatL(self, "LaserSightAttachmentWorld", self2.GetStatL(self, "LaserSightAttachment"))

	attname = self2.GetStatL(self, "LaserSightAttachmentWorldName", self2.GetStatL(self, "LaserSightAttachmentName"))

	if attname then
		att = targetent:LookupAttachment(attname)
	end

	if (not att) or att <= 0 then
		self:CleanLaser()

		return
	end

	angpos = targetent:GetAttachment(att)

	if not angpos then
		angpos = targetent:GetAttachment(1)
	end

	if not angpos then
		self:CleanLaser()

		return
	end

	if not IsValid(ply.TFALaserDot) and not IsHolstering(self) then
		local lamp = ProjectedTexture()
		ply.TFALaserDot = lamp
		lamp:SetTexture(laserdot:GetString("$basetexture"))
		lamp:SetFarZ(self2.LaserDistance) -- How far the light should shine
		lamp:SetFOV(laserFOV)
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(angpos.Ang)
		lamp:SetBrightness(5)
		lamp:SetNearZ(1)
		lamp:SetEnableShadows(false)
		lamp:Update()
	end

	local lamp = ply.TFALaserDot

	if IsValid(lamp) then
		local ang = angpos.Ang
		ang:RotateAroundAxis(ang:Forward(), math.Rand(-180, 180))
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(ang)
		lamp:SetColor(col)
		lamp:SetFOV(laserFOV * math.Rand(0.9, 1.1))
		lamp:Update()
	end

	traceres = util.QuickTrace(angpos.Pos, angpos.Ang:Forward() * self2.LaserDistance, ply)
	local hpos = traceres.StartPos + angpos.Ang:Forward() * math.min(traceres.HitPos:Distance(angpos.Pos), self2.LaserDistanceVisual )
	render.SetMaterial(laserline)
	render.SetColorModulation(1, 1, 1)
	render.StartBeam(2)
	col.r = math.sqrt(col.r / 255) * 255
	col.g = math.sqrt(col.g / 255) * 255
	col.b = math.sqrt(col.b / 255) * 255
	render.AddBeam(angpos.Pos, self2.LaserBeamWidth or 0.25, 0, col)
	col.a = 0
	render.AddBeam(hpos, 0, 0, col)
	render.EndBeam()
end

function SWEP:CleanLaser()
	local ply = self:GetOwner()

	if IsValid(ply) and IsValid(ply.TFALaserDot) then
		ply.TFALaserDot:Remove()
	end
end
--addons/egm_tfa_weapons/lua/weapons/weapon_752_e5.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "E-5 (Kamino)"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "Baktoid Armor Workshop"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = false

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["e5"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5_blaster.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 1, -4), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["e5"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/e5_blaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1.3, 3), angle = Angle(-11.723, 0, 180), size = Vector(1.15, 1.15, 1.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"

-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 45
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 400
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 200

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil
-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 25

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("w/e5.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--lua/weapons/weapon_chemlight/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Custom Chemlight"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1



function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255)) -- Paints world model in real time
	if IsValid(self.Owner) and !self.Owner:IsBot() then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = self.Owner:GetInfo("gmod_chemlight_red")
				dlight.g = self.Owner:GetInfo("gmod_chemlight_green")
				dlight.b = self.Owner:GetInfo("gmod_chemlight_blue")
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
		end
			end
		elseif IsValid(self.Owner) and self.Owner:IsBot() then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 255
				dlight.g = 255
				dlight.b = 255
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
		end 
			end
	end
	end
end


function SWEP:Deploy()

if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
self:SetColor(Color(self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255)) end-- Paints world model in real time


	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow")
		glow:SetOwner(self.Owner)
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
		glow:SetColor(Color(self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255))
		end
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end

local function Poisoning( ent, ply )
	local d = DamageInfo()
	d:SetDamage( 15 )
	d:SetInflictor( self.Weapon )
	d:SetDamageType( DMG_ACID ) 
	ply:TakeDamageInfo( d )
end

local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", self.Owner:GetInfo("gmod_chemlight_red") )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", self.Owner:GetInfo("gmod_chemlight_green") )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", self.Owner:GetInfo("gmod_chemlight_blue") )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			 end )
			timer.Create( "weapon_chemlight"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end	

return true
else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



hook.Add( "PlayerDeath", "ChemlightReloadGlitchRemover2", function(ply) 
timer.Remove("uncolorchemlighttimer"..ply:EntIndex())
end)

function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,255,255)) else
					ent:SetColor( Color( self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4)) 
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,255,255)) else
					ent:SetColor( Color( self.Owner:GetInfo("gmod_chemlight_red"), self.Owner:GetInfo("gmod_chemlight_green"), self.Owner:GetInfo("gmod_chemlight_blue"), 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(self.Owner:GetInfo("gmod_chemlight_red") / 255, self.Owner:GetInfo("gmod_chemlight_green") / 255, self.Owner:GetInfo("gmod_chemlight_blue") / 255) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight"..self.Owner:EntIndex() )
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--lua/weapons/weapon_chemlight_blue/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_blue/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Blue"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(0,0,255,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(0, 0, 255, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 0
				dlight.g = 0
				dlight.b = 255
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(0,0,255,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_blue"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_blue" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_blue")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(0,0,255,255)) else
		glow:SetColor(Color(0, 0, 255, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 255 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_blue"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 0, 0, 255, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 0, 0, 255, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_blue"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_blue"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,0,255,255)) else
					ent:SetColor( Color( 0, 0, 255, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_blue"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,0,255,255)) else
					ent:SetColor( Color( 0, 0, 255, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(0, 0, 255) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_blue"..self.Owner:EntIndex() )
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--lua/weapons/weapon_chemlight_green/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--addons/handschellen/lua/weapons/weapon_cuff_elastic.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Mehrfach benutzbare Handschellen."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.PrintName = "Handschellen"

// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_pipes/GutterMetal01a"
SWEP.CuffRope = "cable/red"
SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 75
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strength
SWEP.CuffRegenVariance = 0.3 // Randomise regen

--addons/handschellen/lua/weapons/weapon_cuff_standard.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------


AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Basic restraints."

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Basic Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.05 // Randomise strangth
SWEP.CuffRegenVariance = 0.05 // Randomise regen

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_ahsoka.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/reverseahsoka.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Ahsoka Tano" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_ahsoka" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Macht-Öffnung",
	"Atemkontrolle",
	"Macht-Stürmen",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Schwertbarriere",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/reverseahsoka.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

SWEP.UseGrip = "Reverse Blade ( Right )"
-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_ahsokadual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/ahsoka.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Ahsoka Tano - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_ahsokadual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Macht-Öffnung",
	"Atemkontrolle",
	"Macht-Stürmen",
	"Macht-Geschwindigkeit",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Lichtschwertwurf",
	"Macht-Entwaffnen"
}
--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/reverseahsoka.mdl" -- Model path of the hilt
SWEP.UseLength = 35 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/ahsoka.mdl"
SWEP.UseSecLength = 25
SWEP.UseSecWidth = 2
SWEP.UseSecColor = Color(173, 255, 47)
SWEP.UseSecDarkInner = 0

SWEP.UseGrip = "Reverse Blade ( Both )"


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_assassindual.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/samurai.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Attentäter - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_assassindual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Sicht",
	"Macht-Geschwindigkeit",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Willenskraft",
	"Dunkelschlag",
	"Machtschrei",
	"Beinhieb"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]     = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/samurai.mdl" -- Model path of the hilt
SWEP.UseLength = 40 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/samurai.mdl"
SWEP.UseLength = 40
SWEP.UseWidth = 2
SWEP.UseSecColor = Color(255, 0, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_billaba.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/zatt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Depa Billaba" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_billaba" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Machtschub",
	"Atemkontrolle",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Machtblockade",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/zatt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color( 0, 37, 255 ) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_darksaber.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/darksaber.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Dunkelschwert" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_darksaber" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {"Beinhieb"}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VII | Vaapad"]   = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Dark Saber"
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/darksaber.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 255, 255 ) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = false -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_electrostaff_republic.lua:

AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/oninoni/prp_magna_guard_weapon_season4.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.IsElectroStaff = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Elektrostab (Republik)" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_electrostaff_republic" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 35 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 500
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {
	"Beinhieb",
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"]  = {1, 2, 3},
	["Form III | Soresu"]  = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Corrupted"
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/oninoni/prp_magna_guard_weapon_season4.mdl" -- Model path of the hilt
SWEP.UseLength = 15 -- Length of the saber
SWEP.UseWidth = 2.5 -- Width of the saber
SWEP.UseColor = Color(255, 127, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 1 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

SWEP.HolsterOffset = Vector(5, 0, 3)
SWEP.HolsterAngle = Angle(0, 90, 0)
--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_fisto.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/kitfisto.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Kit Fisto" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_fisto" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Sicht",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Energiestrahl",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Kristallschlag",
	"Blenden",
	"Machtstoß",
	"Macht-Stasis",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Schallentladung", "Flammenschauer" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "SWTOR 2"
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/kitfisto.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_hettdual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "A'Sharad Hett - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_hettdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Atemkontrolle",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Machtstoß",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Seuche",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Blenden",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/kashyyyk.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = Color(0, 255, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_kungarama.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Nuru Kungarama" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_kungarama" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Atemkontrolle",
	"Machtspiegel",
	"Machtschub",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Machtzug",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_maul.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl"
SWEP.ViewModelFOV = 55

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Darth Maul" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_maul" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Machtspiegel",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Sicht",
	"Macht-Griff",
	"Lähmender Schlag",
	"Machtstoß",
	"Machtschrei",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Beinhieb",
	"Dunkelschlag",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_mukan.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Etain Tur-Mukan" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_mukan" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Atemkontrolle",
	"Machtheilung",
	"Machtzug",
	"Machtschub",
	"Machtstoß",
	"Gruppenheilung",
	"Lichtschwertwurf",
	"Machtspiegel",
	"Energiestrahl",
	"Macht-Sicht",
	"Macht-Griff",
	"Macht-Induktion",
	"Macht-Öffnung",
	"Selbstheilung",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/gungan.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_training_maul.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.TrainingLightsaber = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Trainingslichtschwert Doppelklinge" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_training_maul" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 75 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(225, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop8.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on4.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off4.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_trainingdual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.TrainingLightsaber = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Trainingslichtschwert - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_trainingdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 75 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(225, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop8.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on4_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off4_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.UseSecLength = 45
SWEP.UseSecWidth = 2
SWEP.UseSecColor = Color(225, 255, 0)
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_unduli.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/luminara.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Luminara Unduli" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_unduli" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub",
	"Machtstoß",
	"Energiestrahl",
	"Macht-Geschwindigkeit",
	"Atemkontrolle",
	"Machtheilung",
	"Gruppenheilung",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Macht-Sicht",
	"Macht-Stasis",
	"Machtschild",
	"Blenden",
	"Macht-Verlangsamung",
	"Machtspiegel",
	"Großer Machtschub",
	"Großer Machtzug",
	"Selbstheilung",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/luminara.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/lvs_base/lua/weapons/weapon_lvsrepair.lua:
AddCSLuaFile()

SWEP.Category				= "[LVS]"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/weapons/c_repairlvs.mdl"
SWEP.WorldModel			= "models/weapons/w_repairlvs.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.MaxRange = 250

function SWEP:SetupDataTables()
	self:NetworkVar( "Float",0, "FlameTime" )
end

function SWEP:GetLVS()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return NULL end

	local ent = ply:GetEyeTrace().Entity

	if not IsValid( ent ) then return NULL end

	if ent._lvsRepairToolLabel or ent.LVS then return ent end

	if not ent.GetBase then return NULL end

	ent = ent:GetBase()

	if IsValid( ent ) and ent.LVS then return ent end

	return NULL
end

function SWEP:FindClosest()
	local lvsEnt = self:GetLVS()

	if not IsValid( lvsEnt ) then return NULL end

	local ply = self:GetOwner()

	if ply:InVehicle() then return end

	local ShootPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()

	local ClosestDist = self.MaxRange
	local ClosestPiece = NULL

	local tableEnts = lvsEnt:GetChildren()

	if isfunction( lvsEnt.GetCrosshairFilterEnts ) then
		tableEnts = lvsEnt:GetCrosshairFilterEnts()
	end

	for _, target in pairs( tableEnts ) do
		if not IsValid( target ) then continue end

		for _, entity in pairs( target:GetChildren() ) do
			if entity:GetClass() ~= "lvs_armor" then continue end

			local boxOrigin = entity:GetPos()
			local boxAngles = entity:GetAngles()
			local boxMins = entity:GetMins()
			local boxMaxs = entity:GetMaxs()

			local HitPos, _, _ = util.IntersectRayWithOBB( ShootPos, AimVector * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

			if isvector( HitPos ) then
				local Dist = (ShootPos - HitPos):Length()

				if Dist < ClosestDist then
					ClosestDist = Dist
					ClosestPiece = entity
				end
			end
		end
	end

	return ClosestPiece
end

local function IsEngineMode( AimPos, Engine )
	if not IsValid( Engine ) then return false end

	if not isfunction( Engine.GetDoorHandler ) then return (AimPos - Engine:GetPos()):Length() < 25 end

	local DoorHandler = Engine:GetDoorHandler()

	if IsValid( DoorHandler ) then
		if DoorHandler:IsOpen() then
			return (AimPos - Engine:GetPos()):Length() < 50
		end

		return false
	end

	return (AimPos - Engine:GetPos()):Length() < 25
end

if CLIENT then
	SWEP.PrintName		= "Repair Torch"
	SWEP.Author			= "Blu-x92"

	SWEP.Slot				= 5
	SWEP.SlotPos			= 1

	SWEP.Purpose			= "Repair Broken Armor"
	SWEP.Instructions		= "Primary to Repair\nHold Secondary to switch to Armor Repair Mode"
	SWEP.DrawWeaponInfoBox 	= true

	SWEP.WepSelectIcon 			= surface.GetTextureID( "weapons/lvsrepair" )

	local ColorSelect = Color(0,255,255,50)
	local ColorText = Color(255,255,255,255)

	local function DrawText( pos, text, col )
		cam.Start2D()
			local data2D = pos:ToScreen()

			if not data2D.visible then return end

			local font = "TargetIDSmall"

			local x = data2D.x
			local y = data2D.y

			draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
		cam.End2D()
	end

	function SWEP:DrawEffects( weapon, ply )
		local ID = weapon:LookupAttachment( "muzzle" )

		local Muzzle = weapon:GetAttachment( ID )

		if not Muzzle then return end

		local T = CurTime()

		if self:GetFlameTime() < T or (self._NextFX1 or 0) > T then return end

		self._NextFX1 = T + 0.02

		local effectdata = EffectData()
		effectdata:SetOrigin( Muzzle.Pos )
		effectdata:SetAngles( Muzzle.Ang )
		effectdata:SetScale( 0.5 )
		util.Effect( "MuzzleEffect", effectdata, true, true )

		if (self._NextFX2 or 0) > T then return end

		self._NextFX2 = T + 0.06

		local trace = ply:GetEyeTrace()
		local ShootPos = ply:GetShootPos()

		if (ShootPos - trace.HitPos):Length() > self.MaxRange then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal * 0.15 )
		util.Effect( "manhacksparks", effectdata, true, true )

		local dlight = DynamicLight( self:EntIndex() )

		if not dlight then return end

		dlight.pos = (trace.HitPos + ShootPos) * 0.5
		dlight.r = 206
		dlight.g = 253
		dlight.b = 255
		dlight.brightness = 3
		dlight.decay = 1000
		dlight.size = 256
		dlight.dietime = CurTime() + 0.1
	end

	function SWEP:PostDrawViewModel( vm, weapon, ply )
		self:DrawEffects( vm, ply )
	end

	function SWEP:DrawWorldModel( flags )
		self:DrawModel( flags )
		self:DrawEffects( self, self:GetOwner() )
	end

	function SWEP:DrawHUD()
		local ply = self:GetOwner()

		if not IsValid( ply ) or not ply:KeyDown( IN_ATTACK2 ) then
			local lvsEnt = self:GetLVS()
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( lvsEnt ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				local Label = lvsEnt._lvsRepairToolLabel or "Frame"

				if isfunction( lvsEnt.GetEngine ) then
					local Engine = lvsEnt:GetEngine()

					local AimPos = ply:GetEyeTrace().HitPos

					local EngineMode = IsEngineMode( AimPos, Engine )

					if IsValid( Engine ) and EngineMode then
						DrawText( AimPos, "Engine\nHealth: "..math.Round(Engine:GetHP()).."/"..Engine:GetMaxHP(), ColorText )
					else
						DrawText( AimPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
					end
				else
					DrawText( ply:GetEyeTrace().HitPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
				end
			end

			return
		end

		local Target = self:FindClosest()

		if IsValid( Target ) then
			local boxOrigin = Target:GetPos()
			local boxAngles = Target:GetAngles()
			local boxMins = Target:GetMins()
			local boxMaxs = Target:GetMaxs()

			cam.Start3D()
				render.SetColorMaterial()
				render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, ColorSelect )
			cam.End3D()

			DrawText( Target:LocalToWorld( (boxMins + boxMaxs) * 0.5 ), (Target:GetIgnoreForce() / 100).."mm "..Target:GetLabel().."\nHealth: "..math.Round(Target:GetHP()).."/"..Target:GetMaxHP(), ColorText )
		else
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( self:GetLVS() ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				DrawText( Pos, "No Armor", ColorText )
			end
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local T = CurTime()

	self:SetNextPrimaryFire( T + 0.15 )

	self:SetFlameTime( T + 0.3 )

	local EngineMode = false
	local ArmorMode = true
	local Target = self:FindClosest()

	local ply = self:GetOwner()

	if IsValid( ply ) and not ply:KeyDown( IN_ATTACK2 ) then
		Target = self:GetLVS()

		if isfunction( Target.GetEngine ) then
			local Engine = Target:GetEngine()

			local AimPos = ply:GetEyeTrace().HitPos

			EngineMode = IsEngineMode( AimPos, Engine )

			if IsValid( Engine ) and EngineMode then
				Target = Engine
			end
		end

		ArmorMode = false
	end

	if not IsValid( Target ) then return end

	local HP = Target:GetHP()
	local MaxHP = Target:GetMaxHP()

	if IsFirstTimePredicted() then
		local trace = ply:GetEyeTrace()

		if HP ~= MaxHP then
			local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal )
			util.Effect( "stunstickimpact", effectdata, true, true )
		end
	end

	if CLIENT then return end

	Target:SetHP( math.min( HP + 15, MaxHP ) )

	if EngineMode and Target:GetDestroyed() then
		Target:SetDestroyed( false )
	end

	if not ArmorMode then return end

	if Target:GetDestroyed() then Target:SetDestroyed( false ) end

	if HP < MaxHP then return end

	Target:OnRepaired()
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	local ply = self:GetOwner()

	if not IsValid( ply ) then self:StopSND() return end

	local PlaySound = self:GetFlameTime() >= CurTime() and (ply:GetShootPos() - ply:GetEyeTrace().HitPos):Length() < self.MaxRange

	if PlaySound then
		self:PlaySND()
	else
		self:StopSND()
	end
end

function SWEP:StopSND()
	if CLIENT then return end

	if not self._snd then return end

	self._snd:Stop()
	self._snd = nil
end

function SWEP:PlaySND()
	if CLIENT then return end

	if self._snd then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	self._snd = CreateSound( ply, "lvs/weldingtorch_loop.wav" )
	self._snd:PlayEx(1, 70 )
end

function SWEP:OnRemove()
	self:StopSND()
end

function SWEP:OnDrop()
	self:StopSND()
end

function SWEP:Holster( wep )
	self:StopSND()
	return true
end

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_cisshotgun.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "CIS Shotgun"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "CIS Blaster Shotgun"
SWEP.Manufacturer           = "Baktoid Armor Workshop"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(2, -2, 0)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 1), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["hunter"] = { type = "Model", model = "models/swbf3/weapons/cisshotgun.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, 0, 1), angle = Angle(0, 89.5, 0), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["hunter"] = { type = "Model", model = "models/swbf3/weapons/cisshotgun.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.5, 1, -3), angle = Angle(13, 180, 180), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(10, 0, 2)
SWEP.HolsterAngle = Angle(0, 0, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 120
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 12
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 12

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 60

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 700

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 12
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 3
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.15
SWEP.Primary.IronAccuracy 			= 0.05

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.624, -5.026, -1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("w/dp23.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_cr2.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "CR-2"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Rifle"
SWEP.Manufacturer 			= "Corellian Arms"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"
SWEP.ViewModelFOV					= 75

SWEP.VMPos = Vector(2, -8, -1)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["cr2"] = { type = "Model", model = "models/sw_battlefront/weapons/cr2_pistol.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.2, 02.5, 0.5), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 0, [2] = 0, [3] = 0} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_e11_reference001", rel = "cr2", pos = Vector(-1.35, 1.3, 6.28), angle = Angle(0, 180, 0), size = Vector(0.32, 0.32, 0.32), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["cr2"] = { type = "Model", model = "models/sw_battlefront/weapons/cr2_pistol.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, -2), angle = Angle(-9, 0, 180), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 0, [2] = 0, [3] = 0} }
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_green"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto",
	"Single"
}

-- Automatic RPM
SWEP.Primary.RPM					= 960
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 218

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= 890
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= 0.2

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 250

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 16

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_green"
SWEP.Secondary.ScopeZoom 			= 3
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.01
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	1,
	2,
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-6.43, -4, 1.45)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/cr2.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/pistols.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_green.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_cyclerrifle_dissolve.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_cyclerrifle"

SWEP.PrintName				= "Cycler Rifle Disruptor"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Tusken Raider Cycler Rifle Disruptor"
SWEP.Manufacturer 			= "Handmade"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true
SWEP.AdminOnly = true


-- Let the target be dissolved after killing
SWEP.Primary.DamageType             = DMG_DISSOLVE
SWEP.DamageType                     = DMG_DISSOLVE

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
SWEP.Primary.AmmoConsumption 		= 200

SWEP.Primary.Damage					= 300


DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15s.lua:
-- Written by Oninoni & Fazor

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15S"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.1, 2.2, 0), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -0.5), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 444
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 222

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage 				= 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0185
SWEP.Primary.IronAccuracy 			= 0.0065

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5, -8, 3.2)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15s_blaster_carbine/dc15s_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15se.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "DC-15SE"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Light Scoped Blaster Carabine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(2, -7, -1.5)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["dc15"] = { type = "Model", model = "models/cs574/weapons/dc15se.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-0.75, 0, -0), angle = Angle(0, -90, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1]=1} },
	["dc15_scope2"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_e11_reference001", rel = "dc15", pos = Vector(1.35, -0.015, 4.60), angle = Angle(0, 180, 0), size = Vector(0.33, 0.33, 0.33), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc15"] = { type = "Model", model = "models/cs574/weapons/dc15se.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.8, 0.5, -0.5), angle = Angle(-12, 0, 172), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1]=1} },
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto",
	"Single"
}

-- Automatic RPM
SWEP.Primary.RPM					= 960
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 218

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= 890
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= 0.2

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 250

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 16

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.01
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	1,
	2,
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.6, -8, 4)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15s_blaster_carbine/dc15s_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")


DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15t.lua:
-- Written by Oninoni & Fazor

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-15T"
SWEP.Category               = "SW:RP (BAM!)"
SWEP.Type					= "Republic Blaster Carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = false

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.1, 2.2, 0), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc15s"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15s_carbine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -0.5), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/sw_battlefront/weapons/dc15s/t_dc15a_cs", skin = 0, bodygroup = {} }
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_rainbow"
SWEP.ImpactEffect 					= "rw_sw_impact_white"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 1
-- Magazine Count
SWEP.Primary.DefaultClip			= 1
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 0

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"20Burst",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 9001
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 9001

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= 9001
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= 0.5

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 300000

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5, -8, 3.2)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/dc15s_blaster_carbine/dc15s_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

if SERVER then
	SWEP.CustomBulletCallback = function(a,b,c)
		if IsValid(b.Entity) then
			if a:IsTeamMember() then
				if b.Entity:IsPlayer() then
					b.Entity:Kill()
				end

				if b.Entity:IsNPC() then
					b.Entity:Remove()
				end
			elseif a:IsPlayer() then
				a:Kill()
			end
		end
	end
end
DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dt12.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName				= "DT-12"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Pistol"
SWEP.Manufacturer 			= "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75

SWEP.VMPos = Vector(0.88, -9, -00.65)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dt12"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0.25, -2.0, -4.5), angle = Angle(0, 90, -1.5), size = Vector(1.05, 1.05, 1.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dt12"] = { type = "Model", model = "models/hauptmann/star wars/weapons/ddt12.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(6, 1.5, 2.65), angle = Angle(-10, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(0, 0, -5.5)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 50
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 218

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 31

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_red"
SWEP.Secondary.ScopeZoom 			= 8
SWEP.ScopeReticule_Scale 			= {1,1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

SWEP.ZoomLevels = {
	2,
	5
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.72, -6, 3.0)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dpst.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/pistols.wav");

if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_ee3.lua:
-- Written by Oninoni & Fazor

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "EE-3"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(2, 0, -1)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["ee3"] = { type = "Model", model = "models/sw_battlefront/weapons/ee3_carbine.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, -0.5, -0), angle = Angle(-02, -90, 0), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "ee3", pos = Vector(1.385, -0.015, 5.48), angle = Angle(0, 180, 0), size = Vector(0.23, 0.23, 0.23), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["ee3"] = { type = "Model", model = "models/sw_battlefront/weapons/ee3_carbine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2, 1, 0), angle = Angle(-12, 0, 170), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(6, 0, 1)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Burst",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 300
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 125

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= 300
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil
-- Burst fire count override (autocalculated by the clip size if nil)
SWEP.BurstFireCount                 = nil


-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12200

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_red"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	2,
	5
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector( -5.6, -7, 01.7)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 1.5)
SWEP.RunSightsAng = Vector(-22, 32.50, -19)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/ee3.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_red.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end

function SWEP:GetMaxBurst()
	local fm = self:GetFireMode()

	if fm == 2 then
		return 3
	end

	return 1
end

DEFINE_BASECLASS( SWEP.Base )
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_extinguisher/shared.lua:
SWEP.Gun							= "gun_base"
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Deltaa"

SWEP.PrintName						= "Versorgungskit - Feuerlöscher"
SWEP.Type							= "Versorgerkit."
SWEP.Slot							= 3
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 90, 0),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -06),
		angle = Angle(180, -05, -4),
		size = Vector(0.6, 0.6, 0.6),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.HolsterOffset = Vector(-2, 0, 7)
SWEP.HolsterAngle = Angle(90, 0, 0)

if SERVER then
	function SWEP:Think()
		if (self:Clip1() <= 0) and IsValid(self) and self:OwnerIsValid() then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= 5
SWEP.Primary.DefaultClip			= 5
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "weapon_extinguisher"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.RunSpeed						= 0.9
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= ""
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

function SWEP:PostSpawnProjectile(ent)
	ent:SetOwner(nil)
end
DEFINE_BASECLASS( SWEP.Base )
--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter_base/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SH         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_egm_base"

SWEP.PrintName 				= "Fusion Cutter"
SWEP.Author 				= "Deltaa"
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= ""
SWEP.Purpose 				= "Werkzeug zum Reparieren von Objekten"

SWEP.Spawnable				= false
SWEP.AdminOnly				= false

SWEP.ViewModel 				= "models/weapons/v_grenade.mdl"
SWEP.WorldModel 			= "models/weapons/w_datapad.mdl"
SWEP.ViewModelFOV 			= 70
SWEP.ViewModelFlip 			= false

SWEP.UseHands				= false
SWEP.IsFusioncutter			= true

SWEP.Primary.Automatic 		= true
SWEP.Secondary.Automatic 	= true

SWEP.data 					= {}
SWEP.data.ironsights 		= 0

SWEP.DefaultFireMode 		= "Normal"

SWEP.ShowViewModel 			= true
SWEP.ShowWorldModel 		= false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Pin"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01"] = { scale = Vector(1, 1, 1), pos = Vector(0, -1.297, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["holotablet"] = { type = "Model", model = "models/props/starwars/weapons/fusion_cutter.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-0.519, 0.518, 1.557), angle = Angle(162.468, -180, 24.545), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "holotablet", pos = Vector(9.869, -0.519, 16.104), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["lighteffect+"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "holotablet", pos = Vector(-1.558, -0.519, 9.67), size = { x = 1.599, y = 1.599 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

SWEP.WElements = {
	["holotablet"] = { type = "Model", model = "models/props/starwars/weapons/fusion_cutter.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 4.675, 3.635), angle = Angle(-8.183, -17.532, -146.105), size = Vector(0.885, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(16.104, -1.558, -12.988), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

function SWEP:GetMode()
	return self:GetNWString("Mode", "false")
end

function SWEP:ToggleInspect()
	return false
end

function SWEP:ProcessFireMode()
	return
end

function SWEP:DrawHUDAmmo()
	return false
end





--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter_light/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SH         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_fusioncutter_base"

SWEP.PrintName 				= "Fusion Cutter (Light)"
SWEP.Category 				= "SW:RP (Support)"
SWEP.Author 				= "Deltaa"
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= ""
SWEP.Purpose 				= "Werkzeug zum Reparieren von Objekten"

SWEP.Spawnable				= true
SWEP.AdminOnly				= false

SWEP.Slot 					= 2
SWEP.SlotPos 				= 1

SWEP.HoldType 				= "slam"

SWEP.Modes = {
	["vehicleModeLight"] = true
}



--gamemodes/starwarsrp/entities/weapons/weapon_swrp_hiddenblade/shared.lua:
--code by Blizzard -> rework this!

SWEP.DefaultHoldType = "knife"
SWEP.ViewModelFOV = 56
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ShowViewModel = true
SWEP.UseHands = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["knife thing"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "strap", pos = Vector(-2.122, 0, 2.977), angle = Angle(0, 0, 0), size = Vector(0.086, 0.156, 0.495), color = Color(123, 123, 123, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["strap"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(3.969, 0, 0.079), angle = Angle(-90, 0, 0), size = Vector(0.193, 0.193, 0.009), color = Color(85, 85, 85, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "knife thing", pos = Vector(-0.247, 0, 4.623), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.791), color = Color(255, 255, 255, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} },
	["strap+"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Forearm", rel = "", pos = Vector(9.324, 0, 0.483), angle = Angle(-90, 0, 0), size = Vector(0.172, 0.172, 0.009), color = Color(85, 85, 85, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} }
}

--SWEP.WElements = {
--	["blade"] = { type = "Model", model = "models/props_c17/FurnitureDrawer001a_Shard01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.642, 1.562, 1), angle = Angle(-99.703, -8.254, 0), size = Vector(0.5, 0.5, 0.791), color = Color(255, 255, 255, 255), surpresslightning = false, material = "silly/sillymaterialfix", skin = 0, bodygroup = {} }
--}

SWEP.Purpose = "Linksklick: Normaler Stich, Rechtsklick: Kill von hinten"
SWEP.AutoSwitchTo = true
SWEP.Contact = ""
SWEP.Author = "Silly"
SWEP.FiresUnderwater = true
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.Instructions = ""
SWEP.AutoSwitchFrom = false
SWEP.base = "weapon_base"
SWEP.Category = "SW:RP (Sonstiges)"
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.PrintName = "Hidden Blade"

SWEP.Primary.Delay			= 0.4 	
SWEP.Primary.Recoil			= 0		
SWEP.Primary.Damage			= 75
SWEP.Primary.NumShots		= 1		
SWEP.Primary.Cone			= 0 	
SWEP.Primary.ClipSize		= 0	
SWEP.Primary.DefaultClip	= 0	
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "none"	

function SWEP:PrimaryAttack()

	self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.7)

	local trace = self.Owner:GetEyeTrace()

	if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 100 then
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = self.Owner:GetShootPos()
		bullet.Dir    = self.Owner:GetAimVector()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 2
		bullet.Damage = 75
		bullet.Callback = function(attacker, tr, dmgInfo)
			dmgInfo:SetDamageType(DMG_SLASH + 1)
		end
			self.Owner:FireBullets(bullet)
			self.Owner:SetAnimation( PLAYER_ATTACK1 );
			self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
			self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)
	else
		self.Weapon:EmitSound("thehiddenblademiss1.wav", 25, 100, 0.75)
		self.Weapon:EmitSound("thehiddenblademiss2.wav", 25, 100, 0.75)
		self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	end
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )

	return true
end 

function SWEP:SecondaryAttack()
	self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
	self.Weapon:SetNextSecondaryFire(CurTime() + 5)

	local tracedata = { }
	local ShootPos = self.Owner:GetShootPos()
	local AimVector = self.Owner:GetAimVector()
	tracedata.start = ShootPos
	tracedata.endpos = ShootPos + AimVector*45
	tracedata.filter = self.Owner
	local trace = util.TraceLine(tracedata)

	if IsValid(trace.Entity) and SERVER then

		if !trace.Entity:IsWorld() then
			if trace.HitPos:Distance(self.Owner:GetShootPos()) <= 75 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self.Owner:GetAimVector()) > 0.6 then
				if trace.Entity:IsPlayer() then
					local dmg = DamageInfo()
					dmg:SetDamage(1000000)
					dmg:SetAttacker(self.Owner)
					dmg:SetInflictor(self)
					dmg:SetDamageType(DMG_SLASH)
					trace.Entity:TakeDamageInfo(dmg)
					self.Owner:SetAnimation( PLAYER_ATTACK1 );
					self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
					self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)
				elseif trace.Entity:IsNPC() then
					trace.Entity:TakeDamage(trace.Entity:Health(), self.Owner, self)
					self.Owner:SetAnimation( PLAYER_ATTACK1 );
					self.Weapon:EmitSound("thehiddenbladehit1.wav", 25, 100, 0.75)
					self.Weapon:EmitSound("thehiddenbladehit2.wav", 25, 100, 0.75)
				end
			end
		end
	end
end

function SWEP:Initialize()

	-- other initialize code goes here
	self:SetHoldType( self.DefaultHoldType )
	
	if CLIENT then
			
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
	end
end
function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	function table.FullCopy( tab )
		if (!tab) then return end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
	end
end

function SWEP:DrawHUD()

	-- No crosshair when Scoped is on
	if ( self.Weapon:GetNetworkedBool( "Scoped" ) ) then return end

	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	local scale = 2 * self.Primary.Cone
	
	-- Scale the size of the crosshair according to how long ago we fired our weapon
	local LastShootTime = self.Weapon:GetNetworkedFloat( "LastShootTime", 0 )
	scale = scale * (2 - math.Clamp( (CurTime() - LastShootTime) * 5, 0.0, 1.0 ))
	
	surface.SetDrawColor( 255, 255, 255, 255 )
	
	-- Draw an awesome crosshair
	local gap = 40 * scale
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )

end

SWEP.Primary.Cone = 0.2
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Bacta Granate
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Kann Türen und ähnliches öffnen"
SWEP.Instructions = "Linksklick/Rechtsklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Datapad (Doors)"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true


SWEP.Primary.Automatic = false

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = { 
		type = "Model", 
		model = "models/weapons/w_datapad.mdl", 
		bone = "ValveBiped.Bip01_R_Hand", 
		rel = "", 
		pos = Vector(1, 4, 1), 
		angle = Angle(-160, -160, -45), 
		size = Vector(1.2, 1.2, 1.2), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.Info = {}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/pad")
end

function SWEP:GetTrace()
	local tracedata = {}
	local ShootPos = self.Owner:GetShootPos()
	local AimVector = self.Owner:GetAimVector()
	tracedata.start = ShootPos
	tracedata.endpos = ShootPos + AimVector * self.Primary.Range
	tracedata.filter = self.Owner
	return util.TraceLine(tracedata)
end

local function isdoor(class)
	local t={"func_door", "func_door_rotating", "prop_door_rotating"}
	for k,v in pairs(t) do
		if class==v then
			return true
		end
	end
	return false
end

function SWEP:PrimaryAttack()
	if IsFirstTimePredicted() then
		if CLIENT then
			surface.PlaySound(UI.ButtonSound) 
		else
			local tr = self:GetTrace()

			if tr.Hit and tr.HitNonWorld then
				local class = tr.Entity:GetClass()

				if isdoor(class) then
					local savetable = tr.Entity:GetSaveTable()
					local open=(not tobool(savetable.m_toggle_state))
					local locked=tobool(savetable.m_bLocked)

					if locked then
						self.Owner:ChatPrint("Door locked, right click to open")
					else
						if open then
							self.Owner:ChatPrint("Closing Door...")
						else
							self.Owner:ChatPrint("Opening Door...")
						end
						tr.Entity:Fire("Toggle", 0)
					end
				elseif class == "prop_dynamic" then
					tr.Entity:Fire("setanimation", "open", 0)
				elseif class == "func_movelinear" then
					tr.Entity:Fire("Open", 0)
				elseif class == "func_button" then
					tr.Entity:Fire("Press", 0)
				elseif class == "gmod_button" or class== "gmod_wire_button" then
					tr.Entity:Use( self.Owner, self, USE_ON, 0 )
				end
			end
		end
	end
end

function SWEP:SecondaryAttack()
	if IsFirstTimePredicted() then
		if CLIENT then
			surface.PlaySound(UI.ButtonSound) 
		else
			local tr = self:GetTrace()

			if tr.Hit and tr.HitNonWorld then
				local class = tr.Entity:GetClass()

				if isdoor(class) then
					local savetable = tr.Entity:GetSaveTable()
					local open=(not tobool(savetable.m_toggle_state))
					local locked=tobool(savetable.m_bLocked)

					if locked then
						tr.Entity:Fire("Unlock", 0)
						tr.Entity:EmitSound("doors/door_latch3.wav")
						self.Owner:ChatPrint("Door unlocked.")
					else
						tr.Entity:Fire("Lock", 0)
						tr.Entity:EmitSound("doors/door_latch3.wav")
						self.Owner:ChatPrint("Door locked.")
					end
				elseif class == "prop_dynamic" then
					tr.Entity:Fire("setanimation", "close", 0)
				elseif class == "func_movelinear" then
					tr.Entity:Fire("Close", 0)
				end
			end
		end
	end
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end
function SWEP:IronSights()
end
function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad_st/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: ST Datapad
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Datapad (Strafverfolgung)"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true
SWEP.AllowIronSightsDoF = false
SWEP.Scoped = false

SWEP.Primary.Automatic = false

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = { 
		type = "Model", 
		model = "models/weapons/w_datapad.mdl", 
		bone = "ValveBiped.Bip01_R_Hand", 
		rel = "", 
		pos = Vector(1, 4, 1), 
		angle = Angle(-160, -160, -45), 
		size = Vector(1.2, 1.2, 1.2), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.Info = {}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/pad")
end

function SWEP:PrimaryAttack()
	if CLIENT and IsFirstTimePredicted() then
		surface.PlaySound(UI.ButtonSound)

		STNotes:Open()
	end
end

function SWEP:SecondaryAttack()
	
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end
function SWEP:IronSights()
end
function SWEP:DrawHUDAmmo()
	return false
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_pulserifle_dissolve.lua:
-- Written by Oninoni and Meredin

SWEP.Base					= "weapon_swrp_pulserifle"

SWEP.PrintName				= "Pulse Rifle Disruptor"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Beskar Steel Factory"
SWEP.Manufacturer 			= "Handmade"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true
SWEP.AdminOnly = true


-- Let the target be dissolved after killing
SWEP.Primary.DamageType             = DMG_DISSOLVE
SWEP.DamageType                     = DMG_DISSOLVE

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 200
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
SWEP.Primary.AmmoConsumption 		= 200

SWEP.Primary.Damage					= 300

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_rg4d.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "RG4D"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Blaster pistol"
SWEP.Manufacturer           = "unknown"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["rg4d"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/rg4d_blaster.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, -4, -3), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_scoutblaster_reference001", rel = "rg4d", pos = Vector(-3.6, 0, 6.94), angle = Angle(0, 180, 0), size = Vector(0.27, 0.27, 0.27), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["rg4d"] = { type = "Model", model = "models/kuro/sw_battlefront/weapons/rg4d_blaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.6, 1.6, 1.1), angle = Angle(-11.723, 0, 180), size = Vector(1.15, 1.15, 1.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(0, 0.1, -5.5)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 350
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 180

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 3040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_red"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25
SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	2,
	5
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.15, -14, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("weapons/rg4d_fire.wav")
-- Reload Sound

SWEP.Primary.ReloadSound = Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_westarm5.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "Westar M5"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Scoped Blaster Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(2, -1, -2)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["m5"] = { type = "Model", model = "models/sw_battlefront/weapons/new/westar_m5_blaster_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, 6, 1), angle = Angle(0, 180, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1, [2] = 1, [3] = 1, [4] = 1, [5] = 1} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "m5", pos = Vector(0.46, 4.2, 5.575), angle = Angle(0, -90, 0), size = Vector(0.35, 0.35, 0.35), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["m5"] = { type = "Model", model = "models/sw_battlefront/weapons/new/westar_m5_blaster_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(7.5, 1, -3), angle = Angle(0, 90, 192), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1, [2] = 1, [3] = 1, [4] = 1, [5] = 1} },
}

SWEP.HolsterOffset = Vector(4, 0, 1)
SWEP.HolsterAngle = Angle(0, 90, 0)

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"
SWEP.ImpactEffect 					= "rw_sw_impact_blue"

-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 445
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12200

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 1
SWEP.Primary.SpreadIncrement 		= 0.35

SWEP.ZoomLevels = {
	4,
	7,
	15
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.35, -4.5, 1.55)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("w/westar.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/heavy.wav")

hook.Add("TFA_GetStat", "WestarM5.Override", function(self, stat, finalReturn)
	if self:GetClass() == "weapon_swrp_westarm5" then
		if stat == "Primary.Damage" then
			if self:GetFireMode() == 1 then
				local relativeModifier = finalReturn / 30

				return 30 * relativeModifier
			else
				local relativeModifier = finalReturn / 30

				return 50 * relativeModifier
			end
		end

		if stat == "Primary.IronAccuracy" then
			if self:GetFireMode() == 1 then
				return 0.004
			else
				return 0.002
			end
		end
	end
end)

-- Recoil
SWEP.Primary.KickUp             = 0
-- This is the maximum upwards recoil (rise)
SWEP.Primary.KickDown           = 0
-- This is the maximum downwards recoil (skeet)
SWEP.Primary.KickHorizontal     = 0
-- This is the maximum sideways recoil (no real term)
SWEP.Primary.StaticRecoilFactor = 0
-- Amount of recoil to directly apply to EyeAngles.  Enter what fraction or percentage (in decimal form) you want.  This is also affected by a convar that defaults to 0.5.

-- AKA IronRecoilMultiplier
SWEP.Primary.IronRecoilMultiplier               = 0 -- Multiply recoil by this factor when we're in ironsights. This is proportional, not inversely.

-- Stats below have no effect if RecoilLUT is not defined
SWEP.Primary.RecoilLUT_IronSightsMult           = 0 -- Defaults to 0.5
-- controls how much effective LUT is when iron sighting
SWEP.Primary.RecoilLUT_AnglePunchMult           = 0 -- Defaults to 0.25
-- controls how much effective LUT at pushing EyeAngles of shooter
SWEP.Primary.RecoilLUT_ViewPunchMult            = 0 -- Defaults to 1
-- controls how much effective LUT at viewpunch

----------------- Recoil related things
SWEP.ViewModelPunchPitchMultiplier               = 0 -- Default value is 0.5
SWEP.ViewModelPunchPitchMultiplier_IronSights    = 0 -- Default value is 0.09

SWEP.ViewModelPunch_MaxVertialOffset             = 0 -- Default value is 3
SWEP.ViewModelPunch_MaxVertialOffset_IronSights  = 0 -- Default value is 1.95
SWEP.ViewModelPunch_VertialMultiplier            = 0 -- Default value is 1
SWEP.ViewModelPunch_VertialMultiplier_IronSights = 0 -- Default value is 0.25

SWEP.ViewModelPunchYawMultiplier                 = 0 -- Default value is 0.6
SWEP.ViewModelPunchYawMultiplier_IronSights      = 0 -- Default value is 0.25

DEFINE_BASECLASS( SWEP.Base )
--addons/vfire_flamethrower/lua/weapons/weapon_vfirethrower.lua:

AddCSLuaFile()
AddCSLuaFile("effects/vfirethrower_jet.lua")

if SERVER then
	resource.AddWorkshop("1525572545")
end

SWEP.PrintName = "vFire Flamethrower"
SWEP.Purpose = "To set things on fire!"
SWEP.Category = "vFire Weapons"
SWEP.Instructions = "Shoot fire to burn things!"

SWEP.Slot = 4
SWEP.SlotPos = 35
SWEP.Weight = 1

SWEP.DrawAmmo = false

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true

SWEP.DrawWeaponInfoBox = false
SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel = "models/weapons/vfirethrower/w_flamethrower.mdl"
SWEP.ViewModelFOV = 55
SWEP.WorldModel = "models/weapons/vfirethrower/w_flamethrower.mdl"
SWEP.HoldType = "shotgun"

SWEP.HolsterOffset = Vector(5, 10, 8)
SWEP.HolsterAngle = Angle(0, 0, 110)

SWEP.m_WeaponDeploySpeed = 2


-- Default values are for single player
SWEP.ShootInterval = 1
SWEP.ShootLife = 2
SWEP.ShootFeed = 0.5

-- Decrease load on the server by increasing shoot interval and increasing size to make up for it
if !game.SinglePlayer() then
	SWEP.ShootInterval = 0.07
	SWEP.ShootLife = 2.15
	SWEP.ShootFeed = 1
end


SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:SetupDataTables()
	self:NetworkVar("Bool", 0, "Shooting")
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	if SERVER then
		self:SetShooting(false)
	end

	if CLIENT then
		self.a = 0
	end
end

function SWEP:Equip()
end

function SWEP:EquipAmmo(ply)
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
	self:SetNextPrimaryFire(CurTime() + self:SequenceDuration())

	self:EmitSound("weapons/vfirethrower/deploy.wav", 80, math.random(80, 120))

	return true
end

-- We don't have a model attachment :( so we're using this function to retreive the approximated shoot position
-- for every view case
function SWEP:GetShootPosition()
	local pos
	local ang

	if CLIENT then -- We're drawing the view model
		if LocalPlayer() == self:GetOwner() and GetViewEntity() == LocalPlayer() then

			local vm = LocalPlayer():GetViewModel()
			pos, ang = vm:GetBonePosition(0)
			pos = pos
				+ ang:Forward() * -5 -- Left
				+ ang:Right() * 1.5 -- Down
				+ ang:Up() * 20 -- Forward

		else -- We're drawing the world model

			local ply = self:GetOwner()

			if !self.flameThrowerHand then
				self.flameThrowerHand = ply:LookupAttachment("anim_attachment_rh")
			end

			local handData = ply:GetAttachment(self.flameThrowerHand)

			ang = handData.Ang
			pos = handData.Pos
				+ ang:Forward() * 28
				+ ang:Right() * 0.3
				+ ang:Up() * 4.5

		end
	end

	if SERVER then -- Mainly used for positioning our fire balls

		pos = self:GetOwner():GetShootPos()
		ang = self:GetOwner():EyeAngles()
		pos = pos
			+ ang:Forward() * 1
			+ ang:Right() * 8
			+ ang:Up() * -20

	end

	return pos
end

function SWEP:ShootFire()

	if !self:GetShooting() then

		self:SetShooting(true)

		local effectdata = EffectData()
		effectdata:SetEntity(self)
		util.Effect("vfirethrower_jet", effectdata, true, true)

	end

	if SERVER then

		local life = math.Rand(4, 8) * self.ShootLife
		local owner = self:GetOwner()

		-- Determine how far forward we should spawn the fireball (we wish to extend it by default for animation purposes)
		local forwardBoost = math.Rand(20, 40)
		local frac = owner:GetEyeTrace().Fraction
		-- We're looking into an obstacle, spawn the fireball exactly on the barrel
		if frac < 0.001245 then
			forwardBoost = 1
		end

		local forward = self:GetOwner():EyeAngles():Forward()
		local pos = self:GetShootPosition() + forward * forwardBoost
		local vel = forward * math.Rand(900, 1000)
		local feedCarry = math.Rand(3, 8) * self.ShootFeed
		CreateVFireBall(life, feedCarry, pos, vel, owner)
	end

end

function SWEP:PrimaryAttack()

	if self:GetNextPrimaryFire() > CurTime() then return end

	if IsFirstTimePredicted() then

		self:ShootFire()

		if SERVER then

			if (self.Owner:KeyPressed(IN_ATTACK) || !self.Sound) then
				self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

				self.Sound = CreateSound(self.Owner, Sound("weapons/vfirethrower/fire.wav"))
			end

			if (self.Sound) then self.Sound:PlayEx(1, math.random(80, 110)) end

		end
	end

	self:SetNextPrimaryFire(CurTime() + self.ShootInterval)
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:PlayCloseSound()
	self:EmitSound("weapons/vfirethrower/close.wav", 80, math.random(90, 110))
end

function SWEP:Think()

	if CLIENT then
		local target = 0
		if self:GetShooting() then
			target = 2
		end
		self.a = Lerp(FrameTime() * 3, self.a, target)
		return
	end

	if self:GetNextSecondaryFire() > CurTime() then return end

	if (self.Owner:KeyReleased(IN_ATTACK) || (!self.Owner:KeyDown(IN_ATTACK) && self.Sound)) then

		self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)

		if (self.Sound) then
			self.Sound:Stop()
			self.Sound = nil
			self:PlayCloseSound()
			if (!game.SinglePlayer()) then self:CallOnClient("PlayCloseSound", "") end
		end

		self:SetShooting(false)

		self:SetNextPrimaryFire(CurTime() + self:SequenceDuration())
		self:SetNextSecondaryFire(CurTime() + self:SequenceDuration())

	end
end

function SWEP:Holster(weapon)
	if (CLIENT) then return end

	if (self.Sound) then
		self.Sound:Stop()
		self.Sound = nil
	end

	self:EmitSound("weapons/vfirethrower/undeploy.wav", 80, math.random(90, 110))

	return true
end


if (SERVER) then return end

SWEP.WepSelectIcon = Material("vfirethrower_icon.png")

function SWEP:GetViewModelPosition(pos, ang)
	pos = pos
		+ ang:Forward() * (10 - self.a)
		+ ang:Right() * 3
		+ ang:Up() * -17.5

	ang:RotateAroundAxis(ang:Right(), self.a)

	return pos, ang
end

function SWEP:DrawWorldModel()

	local ply = self:GetOwner()

	if !IsValid(ply) then
		-- No one is holding the weapon, draw it regularly and bail
		self:DrawModel()
		return
	end

	if !self.flameThrowerHand then
		self.flameThrowerHand = ply:LookupAttachment("anim_attachment_rh")
	end

	local handData = ply:GetAttachment(self.flameThrowerHand)

	if !handData then
		-- We don't have our data for some reason, draw and bail
		self:DrawModel()
		return
	else
		-- We have our data, proceed as normal
		local ang = handData.Ang
		local pos = handData.Pos
			+ ang:Forward() * 11
			+ ang:Right() * 0.3
			+ ang:Up() * -7

		self:SetRenderOrigin(pos)
		self:SetRenderAngles(ang)
		self:DrawModel()
	end
end

function SWEP:DrawWeaponSelection(x, y, w, h, a)
	surface.SetDrawColor(255, 255, 255, a)
	surface.SetMaterial(self.WepSelectIcon)

	local size = math.min(w, h) - 32
	surface.DrawTexturedRect(x + w / 2 - size / 2, y + h * 0.05, size, size)
end
--addons/wos-passiveevent/lua/weapons/wos_pes_tool/cl_init.lua:
include( "shared.lua" )

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0
SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )


function SWEP:Reload()
    if self.Owner:KeyPressed(IN_RELOAD) then
        if (self.firstReload || 0 ) < CurTime() then
            self.firstReload = CurTime() + 1
            wOS.PES:OpenMenu()
        end
    end
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    if not wOS.PES:IsEditingVar() then return end
    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.PrimaryAttack then
        varType.PrimaryAttack(self, self.Owner, element)
    end

    return true
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end
    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.SecondaryAttack then
        varType.SecondaryAttack(self, self.Owner, element)
    end

    return true
end

function SWEP:DrawHUD()
    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()
    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if not varType then return end

    draw.SimpleText( "Editing Variable","DermaLarge", ScrW()/2, ScrH() - 100, color_white, TEXT_ALIGN_CENTER)

    if varType.DrawHUD then
        varType.DrawHUD(self, self.Owner, element)
    end

    // Yeah, I ripped this from the TOOLGUN code. Familiar is the objective   
	local mode = varTable.Type

	local x, y = 50, 40
	local w, h = 0, 0

	local TextTable = {}
	local QuadTable = {}

	QuadTable.texture = self.Gradient
	QuadTable.color = Color( 10, 10, 10, 180 )

	QuadTable.x = 0
	QuadTable.y = y - 8
	QuadTable.w = 600
	QuadTable.h = self.ToolNameHeight - ( y - 8 )
	draw.TexturedQuad( QuadTable )

	TextTable.font = "GModToolName"
	TextTable.color = Color( 240, 240, 240, 255 )
	TextTable.pos = { x, y }
	TextTable.text = varTable.Name
	w, h = draw.TextShadow( TextTable, 2 )
	y = y + h

    if varTable.Description then
        TextTable.font = "GModToolSubtitle"
        TextTable.pos = { x, y }
        TextTable.text = varTable.Description
        w, h = draw.TextShadow( TextTable, 1 )
        y = y + h + 8
    end

	self.ToolNameHeight = y

	QuadTable.y = y
	QuadTable.h = self.InfoBoxHeight
	local alpha = 255
	QuadTable.color = Color( 10, 10, 10, 230 )
	draw.TexturedQuad( QuadTable )

	y = y + 4

	TextTable.font = "GModToolHelp"

	if ( !varType.ToolTips ) then
		TextTable.pos = { x + self.InfoBoxHeight, y }
		TextTable.text = mode
		w, h = draw.TextShadow( TextTable, 1 )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( self.InfoIcon )
		surface.DrawTexturedRect( x + 1, y + 1, h - 3, h - 3 )

		self.InfoBoxHeight = h + 8

		return
	end

	local h2 = 0

	for k, v in ipairs( varType.ToolTips ) do
		if ( isstring( v ) ) then v = { text = v } end
		if ( !v.text ) then continue end

		TextTable.text = v.text
		TextTable.pos = { x + 21, y + h2 }

		w, h = draw.TextShadow( TextTable, 1 )

		-- if ( !v.key ) then
		-- 	if ( v.text:StartWith( "info" ) ) then v.key = "gui/info" end
		-- 	if ( v.text:StartWith( "left" ) ) then v.key = "gui/lmb.png" end
		-- 	if ( v.text:StartWith( "right" ) ) then v.key = "gui/rmb.png" end
		-- 	if ( v.text:StartWith( "reload" ) ) then v.key = "gui/r.png" end
		-- 	if ( v.text:StartWith( "use" ) ) then v.key = "gui/e.png" end
		-- 	if ( v.text:StartWith( "speed" ) ) then v.key = "icon16/control_fastforward.png" end            
		-- end
		-- if ( !v.key2 && !v.text:StartWith( "use" ) && v.text:EndsWith( "use" ) ) then v.key2 = "gui/e.png" end

		self.Icons = self.Icons or {}
		if ( v.key && !self.Icons[ v.key ] ) then self.Icons[ v.key ] = Material( v.key ) end
		if ( v.key2 && !self.Icons[ v.key2 ] ) then self.Icons[ v.key2 ] = Material( v.key2 ) end

		if ( v.key && self.Icons[ v.key ] && !self.Icons[ v.key ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ v.key ] )
			surface.DrawTexturedRect( x, y + h2, 16, 16 )
		end

		if ( v.key2 && self.Icons[ v.key2 ] && !self.Icons[ v.key2 ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ v.key2 ] )
			surface.DrawTexturedRect( x - 25, y + h2, 16, 16 )

			draw.SimpleText( "+", "default", x - 8, y + h2 + 2, color_white )
		end

		h2 = h2 + h

	end

	self.InfoBoxHeight = h2 + 8

end


local matScreen = Material( "models/weapons/v_toolgun/screen" )
local txBackground = surface.GetTextureID( "models/weapons/v_toolgun/screen_bg" )
local TEX_SIZE = 256

-- GetRenderTarget returns the texture if it exists, or creates it if it doesn't
local RTTexture = GetRenderTarget( "GModToolgunScreen", TEX_SIZE, TEX_SIZE )

surface.CreateFont( "GModToolScreen", {
	font	= "Helvetica",
	size	= 60,
	weight	= 900
} )

local function DrawScrollingText( text, y, texwide )

	local w, h = surface.GetTextSize( text )
	w = w + 64

	y = y - h / 2 -- Center text to y position

	local x = RealTime() * 250 % w * -1

	while ( x < texwide ) do

		surface.SetTextColor( 0, 0, 0, 255 )
		surface.SetTextPos( x + 3, y + 3 )
		surface.DrawText( text )

		surface.SetTextColor( 255, 255, 255, 255 )
		surface.SetTextPos( x, y )
		surface.DrawText( text )

		x = x + w

	end

end

--[[---------------------------------------------------------
	We use this opportunity to draw to the toolmode
		screen's rendertarget texture.
-----------------------------------------------------------]]
function SWEP:RenderScreen()

    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()
    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if not varType then return end

	-- Set the material of the screen to our render target
	matScreen:SetTexture( "$basetexture", RTTexture )

	-- Set up our view for drawing to the texture
	render.PushRenderTarget( RTTexture )
	cam.Start2D()
 
		-- Background
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( txBackground )
		surface.DrawTexturedRect( 0, 0, TEX_SIZE, TEX_SIZE )

		-- -- Give our toolmode the opportunity to override the drawing
		-- if ( self:GetToolObject() && self:GetToolObject().DrawToolScreen ) then

		-- 	self:GetToolObject():DrawToolScreen( TEX_SIZE, TEX_SIZE )

		-- else

			surface.SetFont( "GModToolScreen" )
			DrawScrollingText( varTable.Name, 104, TEX_SIZE )

		-- end

	cam.End2D()
	render.PopRenderTarget()

end

function SWEP:Deploy()
    local cur_pan = wOS.PES:GetActiveMenu()
    if !IsValid(cur_pan) then return end
    if !cur_pan.menu then return end
    if not cur_pan.menu.CreationType then return end 
    if cur_pan.menu.CreationType == WOS_PES.CREATOR.EVENT then return end
    cur_pan:Remove()
end
--addons/wos-passiveevent/lua/weapons/wos_pes_tool/shared.lua:


SWEP.PrintName      = "Passive Event Tool"
--SWEP.Author	        = "Oliver (wiltOS)" //Clean this from the menu but keep it in code because Oliver deserves credit
SWEP.Instructions   = "Reload: Open Menu"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.Slot = 5
SWEP.SlotPos = 7
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.Category = "[wOS] Passive Event"
SWEP.UseHands = true

SWEP.ViewModel			= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel			= "models/weapons/w_toolgun.mdl"

SWEP.AlwaysRaised = true
--addons/mobile_ammunition/lua/entities/ammo_chargepack.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Versorgungskit - Blaster"
ENT.Category = "CW:RP Ammunition"
ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/cs574/objects/ammo_box.mdl"

function ENT:SpawnFunction( ply, tr, class )
	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll
	pAngle.yaw = pAngle.yaw + 180

	local ent = ents.Create(class)
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()

	return ent
end

function ENT:Draw()
	self:DrawModel()

	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90

	if LocalPlayer():EyePos():DistToSqr( p ) < 512 * 512 then
		cam.Start3D2D( p + Vector( 0, 0, -50 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
			draw.DrawText( "Versorgungskit", "header", -1, - 465, Color( 66, 224, 245, 255 ), TEXT_ALIGN_CENTER )
		cam.End3D2D()
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

		self:SetTrigger(true)
	end
end

function ENT:Use(ply)
	local max_blaster_count = AmmoSystem.AmmoTypes["ar2"].limit
	max_blaster_count = max_blaster_count * AmmoPerk:GetAmmoMultiply(ply)

	if ply:GetAmmoCount("ar2") < max_blaster_count then
		local dispencer_ammo_basic_count = GetConVar("rw_sw_dispencer_ammo_basic_count"):GetInt()

		if self.UseTimer <= CurTime() and ply:IsPlayer() then
			ply:GiveAmmo(dispencer_ammo_basic_count, "ar2", false )
			self:Remove()

			if ply:GetAmmoCount("ar2") > max_blaster_count then
				ply:SetAmmo(max_blaster_count, "ar2")
			end
		end
	end
end

function ENT:PhysicsCollide( data, phys )
end
--addons/mobile_ammunition/lua/entities/ammo_chargepack_explosives.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Versorgungskit - Explosives"
ENT.Category = "CW:RP Ammunition"
ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl"

function ENT:SpawnFunction(ply, tr, class)
	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll
	pAngle.yaw = pAngle.yaw + 180

	local ent = ents.Create(class)
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()

	return ent
end

function ENT:Draw()
	self:DrawModel()

	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90

	if LocalPlayer():GetPos():DistToSqr( p ) < 512 * 512 then
		cam.Start3D2D( p + Vector( 0, 0, -40 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 87, - 470, 170, 45, Color( 0, 0, 0, 230 ) )
			draw.DrawText( "Sprengstoff", "header", -1, - 465, Color( 66, 224, 245, 255 ), TEXT_ALIGN_CENTER )
		cam.End3D2D()
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )
		self:SetModelScale( self:GetModelScale() * 0.65, 0 )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

		self:SetTrigger(true)
	end
end

function ENT:Use(ply)
	local max_rpg_count = AmmoSystem.AmmoTypes["rpg_round"].limit
	max_rpg_count = max_rpg_count * AmmoPerk:GetAmmoMultiply(ply)

	if ply:GetAmmoCount("rpg_round") < max_rpg_count  then
		local dispencer_ammo_basic_count = GetConVar("rw_sw_dispencer_ammo_basic_count_grenade"):GetInt()

		if self.UseTimer <= CurTime() and ply:IsPlayer() then
			ply:GiveAmmo(dispencer_ammo_basic_count, "rpg_round", false )
			self:Remove()

			if (ply:GetAmmoCount("rpg_round") > max_rpg_count ) then
				ply:SetAmmo(max_rpg_count, "rpg_round")
			end
		end
	end
end

function ENT:PhysicsCollide( data, phys )
end
--addons/mobile_ammunition/lua/entities/ammo_chargepack_grenades.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Versorgungskit - Grenades"
ENT.Category = "CW:RP Ammunition"
ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/kingpommes/starwars/misc/imp_crate_single_closed.mdl"

function ENT:SpawnFunction(ply, tr, class)
	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll
	pAngle.yaw = pAngle.yaw + 180

	local ent = ents.Create(class)
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()

	return ent
end

function ENT:Draw()
	self:DrawModel()

	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90

	if LocalPlayer():GetPos():DistToSqr( p ) < 512 * 512 then
		cam.Start3D2D( p + Vector( 0, 0, -40 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 87, - 470, 170, 45, Color( 0, 0, 0, 230 ) )
			draw.DrawText( "Granaten", "header", -1, - 465, Color( 66, 224, 245, 255 ), TEXT_ALIGN_CENTER )
		cam.End3D2D()
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )
		self:SetModelScale( self:GetModelScale() * 0.65, 0 )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

		self:SetTrigger(true)
	end
end

function ENT:Use(ply)
	local max_grenade_count = AmmoSystem.AmmoTypes["smg1_grenade"].limit
	max_grenade_count = max_grenade_count * AmmoPerk:GetAmmoMultiply(ply)

	if ply:GetAmmoCount("smg1_grenade") < max_grenade_count  then
		local dispencer_ammo_basic_count = GetConVar("rw_sw_dispencer_ammo_basic_count_grenade"):GetInt()

		if self.UseTimer <= CurTime() and ply:IsPlayer() then
			ply:GiveAmmo(dispencer_ammo_basic_count, "smg1_grenade", false )
			self:Remove()

			if (ply:GetAmmoCount("smg1_grenade") > max_grenade_count ) then
				ply:SetAmmo(max_grenade_count, "smg1_grenade")
			end
		end
	end
end

function ENT:PhysicsCollide( data, phys )
end
--addons/bkeypads/lua/entities/bkeypad/shared.lua:
ENT.Type = "anim"
ENT.Base = "bkeypads_networkvarpostnotify"

ENT.PrintName = "#bKeypads_Keypad"
ENT.Author = "Billy"

ENT.Spawnable = false

ENT.DisableDuplicator = true

ENT.RenderGroup = RENDERGROUP_BOTH -- FIXME RENDERGROUP_TRANSLUCENT

function ENT:Initialize()
	self.bKeypad = true
	if not bKeypads.KeypadsRegistry[self] then
		bKeypads.KeypadsRegistry[self] = true
		table.insert(bKeypads.Keypads, self)
	end

	if SERVER then
		self:ServerInitialize()
	else
		self:ClientInitialize()
	end

	hook.Run("bKeypads.KeypadCreated", self)
end

function ENT:OnRemove()
	if SERVER then
		self:ServerOnRemove()
	else
		self:ClientOnRemove()
	end
	
	hook.Run("bKeypads.KeypadRemoved", self)
end

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "KeypadName")
	self:NetworkVar("String", 1, "ImageURL")

	self:NetworkVar("Int", 0, "BackgroundColor")

	self:NetworkVar("Int", 1, "ScanningStatus")
	self:NetworkVar("Int", 2, "AuthMode")

	self:NetworkVar("Int", 3, "PINDigitsInput")

	self:NetworkVar("Int", 4, "GrantedKey")
	self:NetworkVar("Int", 5, "GrantedRepeats")

	self:NetworkVar("Int", 6, "DeniedKey")
	self:NetworkVar("Int", 7, "DeniedRepeats")

	self:NetworkVar("Float", 0, "PaymentAmount")

	self:NetworkVar("Float", 1, "GrantedTime")
	self:NetworkVar("Float", 2, "GrantedDelay")
	self:NetworkVar("Float", 3, "GrantedRepeatDelay")

	self:NetworkVar("Float", 4, "DeniedTime")
	self:NetworkVar("Float", 5, "DeniedDelay")
	self:NetworkVar("Float", 6, "DeniedRepeatDelay")

	self:NetworkVar("Entity", 0, "ScanningEntity")
	self:NetworkVar("Entity", 1, "KeypadOwner")
	self:NetworkVar("Entity", 2, "ParentKeypad")

	self:NetworkVar("Bool", 0, "Broken")
	self:NetworkVar("Bool", 1, "Slanted")
	self:NetworkVar("Bool", 2, "Hacked")
	self:NetworkVar("Bool", 3, "Uncrackable")
	self:NetworkVar("Bool", 4, "IsLinked")
	self:NetworkVar("Bool", 5, "Persist")
	self:NetworkVar("Bool", 6, "GrantedNotifications")
	self:NetworkVar("Bool", 7, "DeniedNotifications")
	self:NetworkVar("Bool", 8, "Welded")
	self:NetworkVar("Bool", 9, "WiremodEnabled")
	self:NetworkVar("Bool", 10, "ChargeUnauthorized")

	self:NetworkVar("Bool", 11, "DestructionMode")
	self:NetworkVar("Float", 7, "Shield")

	self:NetworkVarPostNotify("ParentKeypad", self.OnKeypadLinked)

	self:NetworkVarPostNotify("AuthMode", self.AuthModeChanged)
	self:NetworkVarPostNotify("Broken", self.BrokenStatusChanged)
	self:NetworkVarPostNotify("Shield", self.OnShieldChanged)
	
	self:NetworkVarPostNotify("Uncrackable", self.KeypadCrackableChanged)
	self:NetworkVarPostNotify("IsLinked", self.KeypadCrackableChanged)

	if CLIENT then
		self:NetworkVarPostNotify("ScanningStatus", self.ScanningStatusChanged)
		self:NetworkVarPostNotify("BackgroundColor", self.BackgroundColorChanged)
	else
		self:NetworkVarPostNotify("Slanted", self.SlantedStatusChanged)
		self:NetworkVarPostNotify("DestructionMode", self.OnDestructionModeChanged)
	end
end

--## Linking ##--

function ENT:GetChildKeypads()
	return istable(bKeypads.KeypadLinking.Links[self]) and bKeypads.KeypadLinking.Links[self] or nil
end

function ENT:IsLinked()
	return IsValid(self:GetParentKeypad()) or self:GetChildKeypads()
end

function ENT:IsParentKeypad()
	return istable(bKeypads.KeypadLinking.Links[self])
end

function ENT:OnKeypadLinked()
	local parent = self:GetParentKeypad()
	if IsValid(parent) and bKeypads:IsKeypad(parent) then
		bKeypads.KeypadLinking.Links[self] = parent
		bKeypads.KeypadLinking.Links[parent] = bKeypads.KeypadLinking.Links[parent] or {}
		bKeypads.KeypadLinking.Links[parent][self] = true

		self:AuthModeChanged(nil, nil, parent:GetAuthMode())
	else
		local parent = bKeypads.KeypadLinking.Links[self]
		if IsValid(parent) then
			bKeypads.KeypadLinking.Links[self] = nil
			if bKeypads.KeypadLinking.Links[parent] then
				bKeypads.KeypadLinking.Links[parent][self] = nil
				if table.IsEmpty(bKeypads.KeypadLinking.Links[parent]) then
					bKeypads.KeypadLinking.Links[parent] = nil
				end
			end
		end
		bKeypads.KeypadLinking.Links[self] = nil

		self:AuthModeChanged(nil, nil, self:GetAuthMode())
	end

	if CLIENT then
		bKeypads.ESP:Refresh()
	end
end

function ENT:LinkProxy()
	local prnt = self:GetParentKeypad()
	if IsValid(prnt) and prnt.bKeypad then
		return prnt
	else
		return self
	end
end

--## Scanning ##--

function ENT:GetScanningPlayer()
	local ent = self:GetScanningEntity()
	if IsValid(ent) then
		if ent.bKeycard then
			return ent:GetOwner()
		elseif ent:IsPlayer() or ent:EntIndex() == -1 then
			return ent
		end
	end
	return NULL
end

--## Utility ##--

-- Fix for keypad breaking render angles
function ENT:_LocalToWorld(pos)
	if SERVER and self.HackedAngle then
		local ang = self:GetAngles()
		ang:RotateAroundAxis(self:GetRight(), -self.HackedAngle)
		ang:RotateAroundAxis(self:GetForward(), -self.HackedAngle)

		return LocalToWorld(pos, angle_zero, self:GetPos(), ang)
	else
		return LocalToWorld(pos, angle_zero, self:GetPos(), self:GetAngles())
	end
end

function ENT:ShowCamera(showCamera)
	if self:IsShowingInternals() then return end
	self:SetBodygroup(bKeypads.BODYGROUP.CAMERA, showCamera and 1 or 0)
end

function ENT:ShowTopLED(showTopLED)
	if self:IsShowingInternals() then return end
	self:SetBodygroup(bKeypads.BODYGROUP.LED_TOP, showTopLED and 1 or 0)
end

function ENT:ShowBottomLED(showBottomLED)
	if self:IsShowingInternals() then return end
	self:SetBodygroup(bKeypads.BODYGROUP.LED_BOTTOM, showBottomLED and 1 or 0)
end

function ENT:ShowKeycardSlot(showKeycardSlot)
	self:SetBodygroup(bKeypads.BODYGROUP.KEYCARD_SLOT, showKeycardSlot and 1 or 0)
end

function ENT:IsShowingInternals()
	return self:GetBodygroup(bKeypads.BODYGROUP.PANEL) == 1
end

function ENT:ShowInternals(showInternals)
	self:ShowCamera(not showInternals and self:LinkProxy():GetAuthMode() == bKeypads.BODYGROUP.CAMERA)
	if showInternals then
		self:SetBodygroup(bKeypads.BODYGROUP.LED_TOP, 0)
		self:SetBodygroup(bKeypads.BODYGROUP.LED_BOTTOM, 0)
		self:RemoveAllDecals()
	end
	self:SetBodygroup(bKeypads.BODYGROUP.PANEL, showInternals and 1 or 0)
	self:SetBodygroup(bKeypads.BODYGROUP.INTERNALS, showInternals and 1 or 0)
end

function ENT:RefreshBodygroups()
	local authMode = self:LinkProxy():GetAuthMode()
	self:ShowTopLED(authMode == bKeypads.AUTH_MODE.PIN)
	self:ShowCamera(authMode == bKeypads.AUTH_MODE.FACEID)
	self:ShowKeycardSlot(authMode == bKeypads.AUTH_MODE.KEYCARD)
	if authMode == bKeypads.AUTH_MODE.PIN then
		if CLIENT and (self:GetScanningStatus() == bKeypads.SCANNING_STATUS.IDLE or self:GetScanningStatus() == bKeypads.SCANNING_STATUS.LOADING) then
			self:SetLEDColor(false)
		end
	else
		self:ShowBottomLED(false)
	end
end

local cam_pos = Vector(0.58824694156647, 0.0051907757297158, 4.1580157279968)
function ENT:GetCamPos()
	return self:_LocalToWorld(cam_pos)
end

local beamSpriteTrace = {filter = {}, mask = MASK_OPAQUE_AND_NPCS}
function ENT:ScanningBeamLOS(ply)
	beamSpriteTrace.filter[1] = ply
	beamSpriteTrace.filter[2] = self
	beamSpriteTrace.start = SERVER and ply:EyePos() or EyePos()
	beamSpriteTrace.endpos = self:GetCamPos()
	return not util.TraceLine(beamSpriteTrace).Hit
end

function ENT:IsPlayerBehind(ply)
	return self:EntIndex() ~= -1 and (ply:EyePos() - self:_LocalToWorld(self:OBBCenter())):Angle():Forward():Dot(self:GetForward()) < 0
end

function ENT:IsPlayerFacing(ply)
	local worldCenter = self:_LocalToWorld(self:OBBCenter())
	local intersectKeypad = util.IntersectRayWithPlane(ply:EyePos(), ply:GetAimVector(), worldCenter, self:GetForward())
	return intersectKeypad and (intersectKeypad - worldCenter):LengthSqr() < 800
end

function ENT:CanFaceScan(ply)
	return
		not self:IsPlayerBehind(ply) and
		self:IsPlayerFacing(ply) and
		ply:EyePos():DistToSqr(self:_LocalToWorld(self:OBBCenter())) <= bKeypads.Config.Scanning.MaxDistance and
		self:ScanningBeamLOS(ply)
end

function ENT:GetScanPingInterval()
	return math.min((1 / bKeypads.Config.Scanning.ScanTimes.FaceID) * 1.5, bKeypads.Config.Scanning.ScanTimes.FaceID)
end

--## Networking ##--

function ENT:KeypadCrackableChanged()
	self.IsKeypad = self:GetIsLinked() and not self:GetUncrackable() or nil -- hack for Keypad Cracker support
end

function ENT:AuthModeChanged(_, __, authMode)
	self:RefreshBodygroups()
	if CLIENT then
		self.GrantedDenied = nil
	end
end

--## Destruction ##--

function ENT:GetDestructible()
	if bKeypads.Config.KeypadDestruction.Enable then
		return not self:GetDestructionMode()
	else
		return self:GetDestructionMode()
	end
end

function ENT:GetMaxShield()
	if self.m_iMaxShield then
		if bKeypads.Config.KeypadDestruction.MaxShield == 0 then
			return math.max(self.m_iMaxShield, self:GetMaxHealth())
		else
			return math.min(math.max(self.m_iMaxShield, self:GetMaxHealth()), self:GetMaxHealth() * bKeypads.Config.KeypadDestruction.MaxShield)
		end
	else
		return 0
	end
end

function ENT:OnShieldChanged(_, __, m_iShield)
	if m_iShield == 0 then
		self.m_iMaxShield = nil
	else
		self.m_iMaxShield = math.max(self.m_iMaxShield or 0, m_iShield)
	end
end

-- WARNING: Extremely cursed code
-- Not for the faint of heart
-- Do not scroll down if you are using a pacemaker

if bKeypads.Config.ExperimentalKeypadCompatibility then
	local entMeta = FindMetaTable("Entity")
	bKeypads_GetClass = bKeypads_GetClass or entMeta.GetClass
	function entMeta:GetClass()
		if self.bKeypad then
			return "keypad"
		else
			return bKeypads_GetClass(self)
		end
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/bkeypads_cracker/lua/entities/bkeypads_deployed_cracker/cl_init.lua:
include("shared.lua")

local RenderCable

function ENT:Draw(flags)
	local drawOpaque = bit.band(flags, STUDIO_TRANSPARENCY) == 0 or bit.band(flags, STUDIO_TWOPASS) == 0
	local drawTranslucent = bit.band(flags, STUDIO_TRANSPARENCY) == STUDIO_TRANSPARENCY or bit.band(flags, STUDIO_TWOPASS) == STUDIO_TWOPASS

	if not self:GetConsumed() then
		self:DrawScreenClipPlane()
			if drawOpaque then
				self:DrawModel()
				self:DrawWorldScreen()
			end
			if drawTranslucent then
				self:DrawLED()
				self:DrawHealth()
			end
		self:DrawScreenClipPlane()
	else
		self:DestroyShadow()
	end

	if drawOpaque and IsValid(self.m_ePoppedOffKeypad) then
		RenderCable(self, flags)
	end
end
function ENT:DrawTranslucent(flags)
	self:Draw(flags)
end

do
	if IsValid(bKeypads_DeployedCrackerMatrix) then bKeypads_DeployedCrackerMatrix:Remove() end
	function ENT:DrawMatrix(w, h)
		if bKeypads.Performance:Optimizing() then return end
		if not IsValid(bKeypads_DeployedCrackerMatrix) then
			bKeypads_DeployedCrackerMatrix = vgui.Create("bKeypads.Matrix")
			bKeypads_DeployedCrackerMatrix:SetMatrixID("DeployedCracker")
			bKeypads_DeployedCrackerMatrix:SetRainSize(20)
			bKeypads_DeployedCrackerMatrix:SetPaintedManually(true)
		end
		bKeypads_DeployedCrackerMatrix:SetSize(w, h)
		bKeypads_DeployedCrackerMatrix:PaintAt(0, 0)
	end

	local worldScreenPos = Vector(1.59, 1.77, 3.1)
	local worldScreenW, worldScreenH = 515, 230
	local scale_3d2d = 0.005
	local faceSize = .8
	function ENT:DrawWorldScreen()
		if not self.m_bSetupDataTables then return end

		local alpha_3d2d = (bKeypads.Performance:Optimizing() and bKeypads.Performance:Alpha3D2D(EyePos():DistToSqr(self:WorldSpaceCenter())) or 1)
		if alpha_3d2d == 0 then return end

		local isCracking = self.m_iAnimationStage == 0

		local ang = self:GetAngles()
		ang:RotateAroundAxis(self:GetUp(), -90)

		local w = worldScreenW
		local h = worldScreenH
		
		cam.Start3D2D(self:LocalToWorld(worldScreenPos), ang, scale_3d2d)
			surface.SetAlphaMultiplier(alpha_3d2d)
			if self.GetDestroyed and self:GetDestroyed() then
				if bKeypads:TVAnimation(self, 0.15, w, h, true) then cam.End3D2D() return end
				
				surface.SetDrawColor(255, 255, 255)
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_RED)
				surface.DrawTexturedRect(0, 0, w, h)

				self.Face = bKeypads.Emotes["shocked"]
			elseif isCracking then
				if not self.m_iStartCracking then
					self.m_iStartCracking = CurTime()
				end

				local frac = bKeypads.ease.InCirc(math.Clamp(math.TimeFraction(self.m_iStartCracking, self:GetCrackCompleteTime(), CurTime()), 0, 1))

				surface.SetDrawColor(255, 255, 255)
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_GREEN)
				surface.DrawTexturedRect(0, 0, w, h)
				
				surface.SetDrawColor(255, 255, 255, 255 * (1 - frac))
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_RED)
				surface.DrawTexturedRect(0, 0, w, h)

				self:DrawMatrix(w, h)

				if not self.m_iNextEmote or CurTime() >= self.m_iNextEmote then
					self.m_iNextEmote = CurTime() + math.Rand(0.5, 1)
					while true do
						local newFace = bKeypads.Emotes[bKeypads.Cracker.CrackingEmotes[math.random(1, #bKeypads.Cracker.CrackingEmotes)]]
						if #bKeypads.Emotes <= 1 or self.Face ~= newFace then
							self.Face = newFace
							break
						end
					end
				end
			else
				surface.SetDrawColor(255, 255, 255)
				surface.SetMaterial(bKeypads.Cracker.Materials.SCREEN_BLUE)
				surface.DrawTexturedRect(0, 0, w, h)

				self.m_iStartCracking = nil
				self.m_iNextEmote = nil

				self.Face = bKeypads.Emotes["sorry"]
			end

			local faceSize = h * faceSize
			local y = (h - faceSize) / 2
			surface.SetDrawColor(bKeypads.COLOR.SLATE)
			surface.SetMaterial(self.Face)
			surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)
			
			if bKeypads.Cracker.Config.SpecialSunglasses and self:GetSpecialCrackTime() then
				surface.SetMaterial(bKeypads.Sunglasses)
				surface.DrawTexturedRect((w - faceSize) / 2, y, faceSize, faceSize)
			end
			
			bKeypads:TVAnimation(self)
			surface.SetAlphaMultiplier(1)
		cam.End3D2D()
	end
end

do
	if IsValid(bKeypads_CrackerCablePlug) then bKeypads_CrackerCablePlug:Remove() end
	function ENT:GetCablePlug()
		if not IsValid(bKeypads_CrackerCablePlug) then
			bKeypads_CrackerCablePlug = ClientsideModel("models/props_lab/tpplug.mdl", RENDERGROUP_OTHER)
			bKeypads_CrackerCablePlug:SetNoDraw(true)
			bKeypads_CrackerCablePlug:SetModelScale(.15)
		end
		return bKeypads_CrackerCablePlug
	end

	local matCable = Material("cable/cable2")
	local cableFrame
	local cableRendered = false
	function RenderCable(self, flags)
		if cableFrame ~= FrameNumber() then
			cableFrame = FrameNumber()
			cableRendered = false
		end
		if not cableRendered then
			if not IsValid(self.m_eDeployedCracker) or not IsValid(self.m_eDeployedCracker.m_ePoppedOffKeypad) or not IsValid(self.m_eDeployedCracker.m_eCrackingKeypad) then return end
			if render.GetRenderTarget() == nil then cableRendered = true end
			if not self.m_eDeployedCracker.m_tCablePath or #self.m_eDeployedCracker.m_tCablePath ~= 3 then return end

			local cablePlug = self.m_eDeployedCracker:GetCablePlug()

			local clipNormal = self.m_eDeployedCracker.m_eCrackingKeypad:GetForward()
			local clipPos = self.m_eDeployedCracker.m_eCrackingKeypad:WorldSpaceCenter()
			clipPos = clipPos - (clipNormal * .25)
			render.PushCustomClipPlane(clipNormal, clipNormal:Dot(clipPos))

				local ang = self.m_eDeployedCracker.m_ePoppedOffKeypad:GetAngles()
				ang:RotateAroundAxis(self.m_eDeployedCracker.m_ePoppedOffKeypad:GetUp(), 180)

				cablePlug:SetPos(self.m_eDeployedCracker.m_ePoppedOffKeypad:GetPos())
				cablePlug:SetAngles(ang)
				cablePlug:DrawModel()

				render.SetMaterial(matCable)
				render.StartBeam(4)

					for i = 0, 2 do
						render.AddBeam(self.m_eDeployedCracker.m_tCablePath[i], 0.5, 0, color_white)
					end

					render.AddBeam(self.m_eDeployedCracker:GetCablePlugPoint(), 0.5, 0, color_white)

				render.EndBeam()

			render.PopCustomClipPlane()
		end
	end

	function ENT:GetCablePlugPoint()
		local cablePlug = self.m_eDeployedCracker:GetCablePlug()
		local plugMins, plugMaxs = cablePlug:GetModelBounds()
		local plugSize = (plugMins - plugMaxs) * .15
		local poppedPlug = self.m_eDeployedCracker.m_ePoppedOffKeypad:GetPos()
		poppedPlug = poppedPlug + (self.m_eDeployedCracker.m_ePoppedOffKeypad:GetForward() * plugSize.y)
		return poppedPlug
	end

	function ENT:CableThink()
		if IsValid(self.m_eCrackingKeypad) and IsValid(self.m_ePoppedOffKeypad) and self.m_tCablePath then
			local cableOrigin = self.m_eCrackingKeypad:WorldSpaceCenter()
			local cablePlug = self:GetCablePlugPoint()
			local cableDir = cableOrigin - cablePlug
			local cableLength = cableDir:Length()
			local cableAngle = cableDir:Angle():Forward()

			self.m_tCablePath[0] = cableOrigin
			self.m_tCablePath[3] = cablePlug

			for i = 1, 2 do
				local cableFrac = i * (1 / 3)
				local cablePoint = cableOrigin - (cableAngle * cableLength * cableFrac)
				cablePoint.z = cablePoint.z - (math.abs(cablePoint.z - cablePlug.z) * cableFrac)
				self.m_tCablePath[i] = cablePoint
			end
		end
	end
end

do
	local LEDSprite = Material("sprites/light_glow02_add")
	local LEDColor  = Color(255, 0, 0)
	local LEDPos    = Vector(1.0795739889145, -1.4562743902206, 3)
	function ENT:DrawLED()
		if self.m_iAnimationStage ~= self.ANIM.CRACKING or CurTime() > (self.m_fNextBlip - 1) + 0.25 then return end
		render.SetMaterial(LEDSprite)
		render.DrawSprite(self:LocalToWorld(LEDPos), 4, 4, LEDColor)
	end
end

do
	local scale_3d2d   = 0.02
	local top_left     = Vector(-1.5, -4.0125, -0.075)
	local bottom_right = Vector(2.25, 2.85, 3.3)
	local top_right    = Vector(bottom_right.x, -4.0125, bottom_right.z)
	local bottom_left  = Vector(top_left.x, 2.85, top_left.z)

	function ENT:DrawHealth()
		if self:GetMaxHealth() == 0 or (not bKeypads.Cracker.Config.Damage.CanDestroyDropped and (self.m_bIsWeapon or not IsValid(self:GetKeypad()))) then return end

		local center = self:OBBCenter()

		local pos = self:LocalToWorld(center)
		pos.z = math.max(self:LocalToWorld(top_left).z, self:LocalToWorld(top_right).z, self:LocalToWorld(bottom_left).z, self:LocalToWorld(bottom_right).z) + .5
		
		local ang = (EyePos() - pos):Angle()
		ang:RotateAroundAxis(ang:Up(), 90)
		ang:RotateAroundAxis(ang:Forward(), 90)

		local playerLooking = LocalPlayer():GetEyeTrace().Entity == self
		if playerLooking then bKeypads.cam.IgnoreZ(true) end

			local w, h = 300, 50
			cam.Start3D2D(pos, ang, scale_3d2d)
				bKeypads:DrawHealth(self, w, h)
			cam.End3D2D()

		if playerLooking then bKeypads.cam.IgnoreZ(false) end
	end
end

function ENT:CrackingSoundThink()
	if self.m_iAnimationStage ~= self.ANIM.CRACKING then
		if self.m_fCrackingSoundEnd and CurTime() <= self.m_fCrackingSoundEnd then
			self.m_fCrackingSoundEnd = nil
			self:StopSound(self.m_tCrackingSound.path)
		end
		if self.m_fNextBlip and CurTime() <= self.m_fNextBlip then
			self.m_fNextBlip = nil
			self:StopSound("buttons/blip2.wav")
		end
		return
	end
	
	if not self.m_fCrackingSoundEnd or CurTime() >= self.m_fCrackingSoundEnd then
		self.m_iCrackingSound = math.max(((self.m_iCrackingSound or 0) + 1) % (#bKeypads.Cracker.Sounds["typing"] + 1), 1)
		self.m_tCrackingSound = bKeypads.Cracker.Sounds["typing"][self.m_iCrackingSound]
		self.m_fCrackingSoundEnd = CurTime() + self.m_tCrackingSound.duration
		self:EmitSound(self.m_tCrackingSound.path)
	end

	if not self.m_fNextBlip or CurTime() >= self.m_fNextBlip then
		self.m_fNextBlip = CurTime() + (bKeypads.Cracker.Config.Beeps.BeepInterval == 0 and 1 or bKeypads.Cracker.Config.Beeps.BeepInterval)
		if bKeypads.Cracker.Config.Beeps.Enable then
			self:EmitSound("buttons/blip2.wav", 100)
		end
	end
end

function ENT:PopOffKeypad(keypad)
	self.m_tCablePath = {}

	self.m_eCrackingKeypad = keypad
	self.m_eCrackingKeypad:ShowInternals(true)
	self.m_eCrackingKeypad.m_eDeployedCracker = self

	self.m_ePoppedOffKeypad = ents.CreateClientside("bkeypads_popped_keypad")
	self.m_ePoppedOffKeypad.m_eDeployedCracker = self
	self.m_ePoppedOffKeypad:SetPos(keypad:WorldSpaceCenter())
	self.m_ePoppedOffKeypad:SetAngles(keypad:GetAngles())

	self.m_ePoppedOffKeypad:Spawn()
	if keypad:LinkProxy():GetAuthMode() == bKeypads.AUTH_MODE.FACEID then
		self.m_ePoppedOffKeypad:SetBodygroup(bKeypads.BODYGROUP.CAMERA, 1)
	end

	self.m_eCrackingKeypad.RenderCable = RenderCable
	self.m_ePoppedOffKeypad.RenderCable = RenderCable
end
function ENT:DrawScreenClipPlane()
	if self.m_bScreenClipPlanePushed then
		self.m_bScreenClipPlanePushed = nil
		render.PopCustomClipPlane()
		return
	end

	if not IsValid(self.m_eDeployedCracker) or not IsValid(self.m_eDeployedCracker.m_ePoppedOffKeypad) then return end
	if self.m_iAnimationStage >= self.ANIM.POP_OFF_CRACKER then return end

	if self.m_iAnimationStage == self.ANIM.CRACKING and CurTime() >= self.m_fAnimationStart + self.AnimationStages[self.ANIM.OPEN_PANEL].Duration then
		return
	end

	local clipNormal = -self.m_eDeployedCracker.m_ePoppedOffKeypad:GetForward()
	local clipPos = self.m_eDeployedCracker.m_ePoppedOffKeypad:WorldSpaceCenter()
	clipPos = clipPos - (clipNormal * .25)
	render.PushCustomClipPlane(clipNormal, clipNormal:Dot(clipPos))

	self.m_bScreenClipPlanePushed = true
end

function ENT:CleanUp()
	self.m_bPreventPopOff = true

	if IsValid(self.m_ePoppedOffKeypad) then
		self.m_ePoppedOffKeypad:Remove()
	end
	if IsValid(self.m_eCrackingKeypad) then
		self.m_eCrackingKeypad.RenderCable = nil
		self.m_eCrackingKeypad:ShowInternals(false)
		self.m_eCrackingKeypad:RemoveCallOnRemove("bKeypads.KeypadCrackerPlant")
	end
	
	self.m_tCablePath = nil
	self.m_eCrackingKeypad = nil

	if self.m_tCrackingSound then
		self:StopSound(self.m_tCrackingSound.path)
	end
	self:StopSound("buttons/blip2.wav")
end

function ENT:OnRemove()
	self:CleanUp()

	local modelPanel = self.m_pModelPanel
	bKeypads:nextTick(function()
		if IsValid(self) then
			self.m_bPreventPopOff = nil
		else
			if bKeypads.Cracker.DroppedDict[self] then
				bKeypads.Cracker.DroppedDict[self] = nil
				table.RemoveByValue(bKeypads.Cracker.Dropped, self)
			end
			if IsValid(modelPanel) then
				modelPanel:SetEntity(nil)
				modelPanel:Remove()
			end
		end
	end)
end

function ENT:NetworkedAnimationStage(_, __, stage)
	self:SkipToAnimationStage(stage)
end
function ENT:NetworkedAnimationStart(_, __, start)
	self.m_fAnimationStart = start
end

function ENT:OnDeployedBySet(_, __, deployedBy)
	if deployedBy == LocalPlayer() and not bKeypads.Cracker.DroppedDict[self] then
		bKeypads.Cracker.DroppedDict[self] = true
		table.insert(bKeypads.Cracker.Dropped, self)
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/bkeypads_cracker/lua/entities/bkeypads_deployed_cracker/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "#bKeypads_KeypadCracker"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.DisableDuplicator = true

ENT.ANIM = {}
ENT.ANIM.CRACKING        = 0
ENT.ANIM.OPEN_PANEL      = -1
ENT.ANIM.POP_OFF_CRACKER = 1
ENT.ANIM.CLOSE_PANEL     = 2
ENT.ANIM.POP_IN_PANEL    = 3
ENT.ANIM.FINISHED        = ENT.ANIM[table.GetWinningKey(ENT.ANIM)] + 1

ENT.AnimationStages = {
	[ENT.ANIM.CRACKING] = {
		Duration = function(self)
			return self.m_bIsWeapon or (self:GetCracking() and self:GetCrackCompleteTime() ~= 0 and IsValid(self:GetKeypad()) and self:GetKeypad().bKeypad and CurTime() > self:GetCrackCompleteTime())
		end
	},

	[ENT.ANIM.OPEN_PANEL] = {
		Duration = 1,
	},

	[ENT.ANIM.POP_OFF_CRACKER] = {
		Duration = 0.5,
	},

	[ENT.ANIM.CLOSE_PANEL] = {
		Duration = 1,
	},

	[ENT.ANIM.POP_IN_PANEL] = {
		Duration = 1.15,
		Delay = 0.115,
	},
}

ENT.PickupSounds = {
	Sound("npc/combine_soldier/gear1.wav"),
	Sound("npc/combine_soldier/gear2.wav"),
	Sound("npc/combine_soldier/gear3.wav"),
	Sound("npc/combine_soldier/gear4.wav"),
	Sound("npc/combine_soldier/gear5.wav"),
	Sound("npc/combine_soldier/gear6.wav")
}

local PickupSoundsPrecached = false

function ENT:Initialize()
	self:SetModel("models/bkeypads/cracker.mdl")
	self:SetModelScale(0.75, 0.0001)
	self:SetCollisionGroup(COLLISION_GROUP_PASSABLE_DOOR)

	self.m_iAnimationStage = 0
	self.m_fAnimationStart = CurTime()

	self:EmitSound("weapons/c4/c4_plant.wav", 75, 100, 0.5)

	if SERVER then
		self:SetUseType(SIMPLE_USE)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:AddEFlags(EFL_FORCE_CHECK_TRANSMIT)

		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:AddGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)
		end

		-- Retarded bug means I have to do this
		if not PickupSoundsPrecached then
			PickupSoundsPrecached = true
			for _, snd in ipairs(self.PickupSounds) do
				game.GetWorld():EmitSound(snd, 65, 100, 0)
			end
		end
	else
		self.m_eDeployedCracker = self

		if IsValid(self:GetDeployedBy()) and self:GetDeployedBy() == LocalPlayer() then
			self:OnDeployedBySet(nil, nil, self:GetDeployedBy())
		end

		if self:GetNetworkedAnimationStart() ~= 0 then
			self:NetworkedAnimationStart(nil, nil, self:GetNetworkedAnimationStart())
		end
		if self:GetNetworkedAnimationStage() ~= 0 then
			self:NetworkedAnimationStage(nil, nil, self:GetNetworkedAnimationStage())
		end
	end
end

function ENT:SetupDataTables()
	self.m_bSetupDataTables = true
	
	self:NetworkVar("Entity", 0, "Keypad")
	self:NetworkVar("Entity", 1, "DeployedBy")

	self:NetworkVar("Int", 0, "NetworkedAnimationStage")

	self:NetworkVar("Float", 0, "NetworkedAnimationStart")
	self:NetworkVar("Float", 1, "CrackCompleteTime")

	self:NetworkVar("Bool", 0, "Consumed")
	self:NetworkVar("Bool", 1, "Cracking")
	self:NetworkVar("Bool", 2, "Destroyed")
	self:NetworkVar("Bool", 3, "SpecialCrackTime")

	self:NetworkVarNotify("Consumed", self.OnConsumed)
	self:NetworkVarNotify("Keypad", self.OnKeypadSet)
	if CLIENT then
		self:NetworkVarNotify("NetworkedAnimationStage", self.NetworkedAnimationStage)
		self:NetworkVarNotify("NetworkedAnimationStart", self.NetworkedAnimationStart)
		self:NetworkVarNotify("DeployedBy", self.OnDeployedBySet)
	end
end

function ENT:OnKeypadSet(_, oldKeypad, newKeypad)
	if IsValid(oldKeypad) then
		oldKeypad.m_eDeployedCracker = nil
	end
	if IsValid(newKeypad) then
		newKeypad.m_eDeployedCracker = self
	end
end

function ENT:SkipToAnimationStage(stage)
	self.m_iAnimationStage = stage
	self:NextAnimation(true)
end

function ENT:OnAnimationStageChanged()
	if SERVER then
		self:SetNetworkedAnimationStage(self.m_iAnimationStage)
		self:SetNetworkedAnimationStart(self.m_fAnimationStart)
	end

	if CLIENT then
		if self.m_iAnimationStage == self.ANIM.FINISHED then
			if IsValid(self.m_eCrackingKeypad) then
				local fx = EffectData()
				fx:SetEntity(self.m_eCrackingKeypad)
				util.Effect("bkeypads_panel_attach", fx)

				self.m_eCrackingKeypad.m_bPlayTVAnimation = true
			end

			self:CleanUp()
			self.Think = nil

			return
		end
		
		if self.m_iAnimationStage == self.ANIM.CLOSE_PANEL then
			
			if IsValid(self.m_eCrackingKeypad) then
				self.m_eCrackingKeypad:EmitSound("npc/roller/mine/rmine_blip3.wav", 60)
			end

		elseif self.m_iAnimationStage == self.ANIM.POP_IN_PANEL then

			if IsValid(self.m_eCrackingKeypad) then
				self.m_eCrackingKeypad:EmitSound("ambient/machines/pneumatic_drill_4.wav", 60, 150, 0.5)
			end
			
		end
	else
		if self.m_iAnimationStage == self.ANIM.POP_OFF_CRACKER then

			--[[if GetConVar("developer"):GetInt() > 0 then
				print("Here's why the fuck we're popping off rn")
				print("self.m_bIsWeapon", self.m_bIsWeapon)
				print("self:GetCracking()", self:GetCracking())
				print("self:GetCrackCompleteTime()", self:GetCrackCompleteTime())
				print("CurTime()", CurTime())
				print("CurTime() > self:GetCrackCompleteTime()", CurTime() > self:GetCrackCompleteTime())
				print("self:GetKeypad()", self:GetKeypad())
				print("IsValid(self:GetKeypad())", IsValid(self:GetKeypad()))
				print("IsValid(self:GetKeypad()) and self:GetKeypad().bKeypad", IsValid(self:GetKeypad()) and self:GetKeypad().bKeypad)
				print("FINALLY", self.AnimationStages[self.ANIM.CRACKING].Duration(self))
			end]]

			if self.m_tCrackingSound then
				self:StopSound(self.m_tCrackingSound.path)
			end

			local keypad = self:GetKeypad()
			if IsValid(keypad) then
				local success = not self:GetDestroyed() and bKeypads.Cracker:CrackComplete(self, keypad, self:GetDeployedBy())
				if success then
					self:EmitSound(bKeypads.Cracker.Sounds["success"].path)
				else
					self:EmitSound(bKeypads.Cracker.Sounds["critical"].path)
				end
				keypad.m_eDeployedCracker = nil
			end

			self:BecomeWeapon(keypad, true)

		end
	end
end

function ENT:NextAnimation(skipped)
	if not skipped then
		if self.m_iAnimationStage >= self.ANIM.FINISHED then return end
		self.m_iAnimationStage = self.m_iAnimationStage + 1
		self.m_fAnimationStart = CurTime()
	end
	self:OnAnimationStageChanged()
end
function ENT:Think()
	if SERVER and self.AnimationStages[self.m_iAnimationStage] then
		local duration = self.AnimationStages[self.m_iAnimationStage].Duration
		local nextStage = false
		if isfunction(duration) then
			if duration(self) then
				nextStage = true
			end
		elseif CurTime() >= self.m_fAnimationStart + duration then
			nextStage = true
		end
		if nextStage then
			self:NextAnimation()
			return
		end
	end

	local keypad = self:GetKeypad()
	if CLIENT then

		self:CrackingSoundThink()

		if self.m_iAnimationStage == self.ANIM.FINISHED then return end

		if IsValid(keypad) and not self.m_bPreventPopOff then
			keypad:ShowInternals(true)
			if not IsValid(self.m_ePoppedOffKeypad) then
				self:PopOffKeypad(keypad)
			end
		end

		self:CableThink()

	elseif self.m_iAnimationStage == self.ANIM.FINISHED then
		if self:GetDestroyed() or (self.m_fExpiryTime and CurTime() > self.m_fExpiryTime) then
			self:DoDestroy()
		elseif self:GetConsumed() then
			self:Remove()
		end
	end
end

function ENT:OnConsumed(_, __, consumed)
	if not consumed then return end
	
	if IsValid(self:GetKeypad()) then
		self:GetKeypad().m_eDeployedCracker = nil
	end

	if self.m_iAnimationStage < self.ANIM.CLOSE_PANEL then
		self.m_iAnimationStage = self.ANIM.CLOSE_PANEL - 1
		self:NextAnimation()

		self:EmitSound(bKeypads.Cracker.Sounds["error"].path)
	end
end
--addons/bkeypads/lua/entities/bkeypads_repair/shared.lua:
AddCSLuaFile()

ENT.Base = "bkeypads_dmg_consumable"
DEFINE_BASECLASS(ENT.Base)

ENT.PrintName = "#bKeypads_KeypadBattery"
ENT.Category = "Billy's Keypads"
ENT.Spawnable = true

function ENT:Initialize()
	self:SetModel("models/items/battery.mdl")
	self:SetColor(bKeypads.COLOR.GREEN)
	self:SetBaseModelScale(.75, 0.0001)

	BaseClass.Initialize(self)
end

if SERVER then
	function ENT:Consume(keypad)
		if keypad:Health() >= keypad:GetMaxHealth() then return end

		keypad:StopSound("npc/scanner/scanner_siren2.wav")
		keypad:EmitSound("items/battery_pickup.wav", 75)
		keypad:SetHealth(math.min(math.max(keypad:Health(), 0) + math.ceil(keypad:GetMaxHealth() * bKeypads.Config.KeypadDestruction.BatteryCharge)), keypad:GetMaxHealth())

		return true
	end
else
	function ENT:DrawHUDLabel()
		draw.SimpleTextOutlined(bKeypads.L"KeypadBattery", "bKeypads.KeypadLabelFont", 0, 0, bKeypads.COLOR.GREEN, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, bKeypads.COLOR.BLACK)
	end

	function ENT:DrawConsumedLabel()
		draw.SimpleTextOutlined(bKeypads.L("HealthAdded"):format(math.ceil(self:GetConsumedBy():GetMaxHealth() * bKeypads.Config.KeypadDestruction.BatteryCharge)), "bKeypads.KeypadLabelFont", 0, 0, bKeypads.COLOR.GREEN, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, bKeypads.COLOR.BLACK)
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/ballistic_shields/lua/entities/bs_dshield_dooms/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/entities/bs_dshield_senat/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_dshield_st/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployable shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/entities/bs_hshield/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/entities/bs_hshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Heavy shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/entities/bs_hshield_dooms/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Heavy shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_shield_st/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end  
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--gamemodes/starwarsrp/entities/entities/council_chair_plo_koon/shared.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Jedi-Rat Stuhl - Plo Koon"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "CW:RP Sonstiges"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/plo_koon_council_chair.mdl"

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(pl, tr)
		local e = ents.Create("council_chair_plo_koon")
		e:SetPos(tr.HitPos + Vector(0, 0, 20))
		e:SetAngles(Angle(0, pl:GetAimVector():Angle().Yaw, 0))
		e:Spawn()
		e:Activate()

		return e
	end

	function ENT:Initialize()
		self:SetModel(self.EntModel)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:StartMotionController()
		self:SetUseType(SIMPLE_USE)
		self:SetRenderMode(RENDERMODE_TRANSALPHA)
		self:SecretChair(self:GetPos() + self:GetUp() * 10 + self:GetForward() * 4, self:GetAngles() + Angle(0, -90, 15)) -- Will most likely require tinkering for position
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(100000)
		end
	end

	function ENT:SecretChair(pos, ang)
		local e = ents.Create("prop_vehicle_prisoner_pod")
		e:SetPos(pos)
		e:SetAngles(ang)
		e:SetParent(self)
		e:SetModel("models/nova/airboat_seat.mdl")
		e:SetRenderMode(RENDERMODE_TRANSALPHA)
		e:SetColor(Color(255, 255, 255, 0))
		e:Spawn()
		e:Activate()
		e.IsSyphSeat = true
		self.Chair = e
	end

	hook.Add("PlayerEnteredVehicle", "SyphSeatEnter", function(p, v)
		if (IsValid(p) and IsValid(v)) and v.IsSyphSeat then
			p:SetNWEntity("SyphSeat", v)
		end
	end)

	hook.Add("PlayerLeaveVehicle", "SyphSeatExit", function(p, v)
		if (IsValid(p) and IsValid(v)) then
			if (v.IsSyphSeat) then
				p:SetNWEntity("SyphSeat", NULL)
			end

			p:SetPos(v:GetPos() + v:GetUp() * 10 + v:GetForward() * 50)
			p:SetEyeAngles(Angle(0, v:GetAngles().y + 90, 0))
		end
	end)

	function ENT:Use(p)
		if (not IsValid(self.Chair)) then return end
		p:EnterVehicle(self.Chair)
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end

	local View = {}

	hook.Add("CalcView", "SyphSeatView", function()
		local p = LocalPlayer()
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if (IsValid(Seat)) and (Seat:GetThirdPersonMode()) then
			local pos = Seat:GetPos() + LocalPlayer():GetAimVector():GetNormal() * -100 + Seat:GetUp() * 175
			local face = ((Seat:GetPos() + Vector(0, 0, 100)) - pos):Angle()
			View.origin = pos
			View.angles = face

			return View
		end
	end)

	hook.Add("ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function(p)
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if IsValid(Seat) and Seat:GetThirdPersonMode() then return true end
	end)
end
--gamemodes/starwarsrp/entities/entities/council_chair_windu/shared.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Jedi-Rat Stuhl - Mace Windu"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "CW:RP Sonstiges"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/mace_windu_council_chair.mdl"

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(pl, tr)
		local e = ents.Create("council_chair_windu")
		e:SetPos(tr.HitPos + Vector(0, 0, 20))
		e:SetAngles(Angle(0, pl:GetAimVector():Angle().Yaw, 0))
		e:Spawn()
		e:Activate()

		return e
	end

	function ENT:Initialize()
		self:SetModel(self.EntModel)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:StartMotionController()
		self:SetUseType(SIMPLE_USE)
		self:SetRenderMode(RENDERMODE_TRANSALPHA)
		self:SecretChair(self:GetPos() + self:GetUp() * 10 + self:GetForward() * 4, self:GetAngles() + Angle(0, -90, 15)) -- Will most likely require tinkering for position
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(100000)
		end
	end

	function ENT:Exit(kill)
		self.BaseClass.Exit(self, kill)

		if (IsValid(p)) then
			p:SetEyeAngles(self:GetAngles() + Angle(0, 180, 0))
		end
	end

	function ENT:SecretChair(pos, ang)
		local e = ents.Create("prop_vehicle_prisoner_pod")
		e:SetPos(pos)
		e:SetAngles(ang)
		e:SetParent(self)
		e:SetModel("models/nova/airboat_seat.mdl")
		e:SetRenderMode(RENDERMODE_TRANSALPHA)
		e:SetColor(Color(255, 255, 255, 0))
		e:Spawn()
		e:Activate()
		e.IsSyphSeat = true
		self.Chair = e
	end

	hook.Add("PlayerEnteredVehicle", "SyphSeatEnter", function(p, v)
		if (IsValid(p) and IsValid(v)) and v.IsSyphSeat then
			p:SetNWEntity("SyphSeat", v)
		end
	end)

	hook.Add("PlayerLeaveVehicle", "SyphSeatExit", function(p, v)
		if (IsValid(p) and IsValid(v)) then
			if (v.IsSyphSeat) then
				p:SetNWEntity("SyphSeat", NULL)
			end

			p:SetPos(v:GetPos() + v:GetUp() * 10 + v:GetForward() * 50)
			p:SetEyeAngles(Angle(0, v:GetAngles().y + 90, 0))
		end
	end)

	function ENT:Use(p)
		if (not IsValid(self.Chair)) then return end
		p:EnterVehicle(self.Chair)
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end

	local View = {}

	hook.Add("CalcView", "SyphSeatView", function()
		local p = LocalPlayer()
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if (IsValid(Seat)) and (Seat:GetThirdPersonMode()) then
			local pos = Seat:GetPos() + LocalPlayer():GetAimVector():GetNormal() * -100 + Seat:GetUp() * 175
			local face = ((Seat:GetPos() + Vector(0, 0, 100)) - pos):Angle()
			View.origin = pos
			View.angles = face

			return View
		end
	end)

	hook.Add("ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function(p)
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if IsValid(Seat) and Seat:GetThirdPersonMode() then return true end
	end)
end
--lua/entities/e60r_rocket2/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= ""  
 ENT.Contact			= ""  
 ENT.Purpose			= ""  
 ENT.Instructions			= ""  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--lua/entities/ent_bonemerged.lua:

AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"

function ENT:PhysicsUpdatePatch( physobj )

	if ( CLIENT ) then return end

	local isConstrained = false
	for _, ent in pairs( self.Constraints ) do
		if ( IsValid( ent ) and ent:GetClass() != "ent_bonemerged" ) then
			isConstrained = true
		end
	end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() and !isConstrained ) then

		physobj:SetVelocity( vector_origin )
		physobj:Sleep()

	end

end


if ( SERVER ) then return end

function ENT:Draw( flags )
	self:DrawModel( flags )
end

function ENT:DrawTranslucent( flags )
	self:Draw( flags )
end

--lua/entities/ent_chemlight_glow_blue/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.01
	end
end
--lua/entities/ent_chemlight_glow_cyan/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Cyan"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_glow_green/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_yellow/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow Yellow"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_inf/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:Draw()
	self.Entity:DrawModel()
end


function ENT:Think()


	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = rgba.g * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = rgba.b * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 1000
		dlight.DieTime = CurTime() + 0.05 --+ GetGlobalFloat( "global_Cheml_Lifetime", 25 ) --0.05


		end
	end
	
--lua/entities/ent_chemlight_rgb_antique.lua:
AddCSLuaFile()
ENT.Base					= "base_gmodentity"
ENT.Type					= "anim"
ENT.PrintName				= "Chemlight (RGB) Old"
ENT.Category				= "Fun + Games"
ENT.AdminOnly				= true
ENT.Spawnable				= true
ENT.AutomaticFrameAdvance	= true

		local rgbr = 255
		local rgbg = 0
		local rgbb = 0
		
		

ENT.Mod = "models/glowstick/chemstick_antic.mdl"								-- "models/Gibs/HGIBS.mdl" Моделька.
ENT.Mat = ""									-- "" Материал. Можно оставить пустым.
ENT.Col = Color(rgbr,rgbg,rgbb)									-- Color(255,255,255) Цвет.
if CLIENT then

function ENT:Draw()
self:DrawModel()
end


end


function ENT:SpawnFunction( ply, tr, class )
		local tr,trace = {},{}
		tr.start = ply:GetShootPos()
		tr.endpos = tr.start + ply:GetAimVector() * 22500
		tr.filter = ply
		tr.mask = MASK_WATER + MASK_SOLID
		trace = util.TraceLine( tr )
		local SpawnPos = trace.HitPos + trace.HitNormal * 1
		ent = ents.Create( class )
		ent:SetPos( SpawnPos )
		ent.Owner = ply 
		ent:SetAngles( ply:GetAngles() )
		ent:Spawn()
		ent:Activate()
		return ent
	end


function ENT:Initialize()

	if SERVER then
		self.Entity:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		if GetGlobalBool( "global_Cheml_oldmodel" ) then 
		self:SetModel(self.Mod or "models/glowstick/stick_antic.mdl")
		else
		self:SetModel(self.Mod or "models/glowstick/stick.mdl")
		end
		--self:SetModel(self.Mod or "models/glowstick/stick.mdl")
		self:SetMaterial(self.Mat or "")
		self:SetColor(self.Col or Color(rgbr,rgbg,rgbb))
		
		self:PhysicsInit(SOLID_VPHYSICS )
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
    
		local phys = self:GetPhysicsObject()
		
		
		if (phys:IsValid()) then
			phys:Wake()
		end
		
	end
	
	self:SetPlaybackRate(1)
end

function ENT:Think()



if  rgbg == 0 and rgbb == 0 then rgbr = 255 end
if  rgbr >= 255 and rgbg == 0 then rgbb = rgbb + 0.5 end
if  rgbb >= 255 then rgbr = rgbr - 0.5 end
if  rgbr <= 0 and rgbb >= 255 then rgbg = rgbg + 0.5 end
if  rgbg >= 255 and rgbr <= 0 then rgbb = rgbb - 0.5 end
if  rgbb <= 0 and rgbg == 255 then rgbr = rgbr + 0.5 end
if  rgbr >= 255 and rgbb <= 0 then rgbg = rgbg - 0.5 end

if rgbr <= 0 then rgbr = 0 end if rgbg <= 0 then rgbg = 0 end if rgbb <= 0 then rgbb = 0 end
if rgbr >= 255 then rgbr = 255 end if rgbg >= 255 then rgbg = 255 end if rgbb >= 255 then rgbb = 255 end

if CLIENT then
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgbr
		dlight.g = rgbg
		dlight.b = rgbb
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end

self:SetColor(Color(rgbr,rgbg,rgbb))
end
--addons/greifhaken/lua/entities/ent_realistic_hook.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminSpawnable = true

ENT.Model = "models/props_c17/TrapPropeller_Lever.mdl"
ENT.HitSound = Sound( "physics/metal/metal_barrel_impact_hard7.wav" )

local ServerConvarFlags = {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE}
CreateConVar( "hatshook_hookplayers", "1", ServerConvarFlags, "Allows the Grappling Hook to grab players" )
CreateConVar( "hatshook_physics", "1", ServerConvarFlags, "Grappling hook is launched as a projectile" )
CreateConVar( "hatshook_speed", "1000", ServerConvarFlags, "Launch velocity of the grappling hook (Max range for non-physics hooks)" )

CreateConVar( "hatshook_breakpower", "3", ServerConvarFlags, "Strength of each breakout attempt" )
CreateConVar( "hatshook_breakregen", "1", ServerConvarFlags, "Breakout depletion rate" )

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "HasHit" )
	
	self:NetworkVar( "Entity", 0, "Wep" )
	self:NetworkVar( "Entity", 1, "TargetEnt" )
	
	self:NetworkVar( "Int", 0, "Dist" )
	self:NetworkVar( "Int", 1, "Durability" )
	
	self:NetworkVar( "Int", 2, "FollowBone" )
	self:NetworkVar( "Vector", 1, "FollowOffset" )
	self:NetworkVar( "Angle", 0, "FollowAngle" )
	
	self:NetworkVar( "Vector", 0, "ShootDir" )
end

function ENT:Initialize()
	self:SetModel( self.Model )
	
	--self:SetMoveType( MOVETYPE_VPHYSICS )
	self:PhysicsInit( SOLID_VPHYSICS )
	if not cvars.Bool( "hatshook_hookplayers" ) then
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end
	
	self:PhysWake()
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		if SERVER then
			self:SetShootDir( self.Owner:GetAimVector() * cvars.Number( "hatshook_speed" ) )
		end
		phys:SetVelocity( self:GetShootDir() )
	end
	
	self.HookHealth = 100
	
	hook.Add( "AllowPlayerPickup", self, self.AllowPlayerPickup )
	if CLIENT then hook.Add( "HUDPaint", self, self.HUDPaint ) end
	
	if SERVER then
		local timerName = tostring(self).." Hook Durability Restore"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetDurability( math.Approach(self:GetDurability(), 0, cvars.Number("hatshook_breakregen") ) )
		end)
		hook.Add( "KeyPress", self, self.PlayerKeyPress )
	end
end

function ENT:Destroyed( NoCooldown )
	if CLIENT then return end
	
	local ef = EffectData()
	ef:SetStart( self:GetPos() )
	ef:SetOrigin( self:GetPos() )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	ef:SetMagnitude( 1 )
	ef:SetNormal( self:GetRight() )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, self:GetPos(), 75, 100 )
	
	if IsValid( self:GetWep() ) and self:GetWep().SetCooldown then
		self:GetWep():SetCooldown( NoCooldown and self:GetWep():GetCooldown()+10 or 100 )
	end
	
	self:Remove()
end
function ENT:OnTakeDamage( DmgInfo )
	self.HookHealth = (self.HookHealth or 0) - DmgInfo:GetDamage()
	if self.HookHealth<=0 then
		self:Destroyed()
	end
end

function ENT:DoParent( target, obj )
	if IsValid( target ) and target~=self and target~=self.Owner and (not (target:IsWeapon() and target:GetOwner()==self.Owner)) then
		self:SetParent( target )
		
		if target:GetClass():sub(1,5)~="func_" then
			for i=0,target:GetPhysicsObjectCount()-1 do
				local p = target:GetPhysicsObjectNum( i )
				if p==obj then
					--self:SetParentPhysNum( target:TranslatePhysBoneToBone(i) )
					--self:FollowBone( target, target:TranslatePhysBoneToBone(i) )
					--print(i,target:TranslatePhysBoneToBone(i))
					
					self:SetFollowBone( target:TranslatePhysBoneToBone(i) )
					local pos, ang = target:GetBonePosition( self:GetFollowBone() )
					if pos and ang then
						self:SetFollowOffset( self:GetPos() - pos )
						self:SetFollowAngle( self:GetAngles()-ang )
					end
					break
				end
			end
		end
		
		self:SetTargetEnt( target )
	end
end

local NoHitEnts = { ["func_breakable_surf"] = true, ["ent_realistic_hook"] = true, } // This is stuff we shouldn't attach to, glitches out
function ENT:PhysicsCollide( data, phys )
	if self:GetHasHit() then return end // Already hit
	
	if IsValid(data.HitEntity) and NoHitEnts[data.HitEntity:GetClass()] then // Something that'll bug out, eg a window
		self:Destroyed( true )
		return
	end
	
	local tr = util.TraceLine( {start = (data.HitPos - (data.HitNormal*10)), endpos = (data.HitPos+data.HitNormal*10), filter = self} )
	if tr.HitSky then return end
	
	timer.Simple(0,function()
		if not IsValid(self) then return end
		
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self:SetPos( data.HitPos )
		local ang = data.HitNormal:Angle()
		ang:RotateAroundAxis( ang:Up(), 90 )
		self:SetAngles( ang )
		self:SetMoveType( MOVETYPE_NONE )
		
		self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
		self:DoParent( data.HitEntity, data.HitObject )
	end)
	
	self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
	
	local ef = EffectData()
	ef:SetOrigin( data.HitPos )
	ef:SetNormal( data.HitNormal )
	ef:SetStart( data.HitPos )
	ef:SetMagnitude( 2 )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, data.HitPos, 75, 100 )
	
	-- if IsValid( data.HitEntity ) and data.HitEntity~=self and data.HitEntity~=self.Owner and (not (data.HitEntity:IsWeapon() and data.HitEntity:GetOwner()==self.Owner)) then
		-- self:SetParent( data.HitEntity )
		
		-- if data.HitEntity:GetClass():sub(1,5)~="func_" then
			-- for i=0,data.HitEntity:GetPhysicsObjectCount()-1 do
				-- local p = data.HitEntity:GetPhysicsObjectNum( i )
				-- if p==data.HitObject then
					-- self:SetFollowBone( data.HitEntity:TranslatePhysBoneToBone(i) )
					-- local pos, ang = data.HitEntity:GetBonePosition( self:GetFollowBone() )
					-- if pos and ang then
						-- self:SetFollowOffset( self:GetPos() - pos )
						-- self:SetFollowAngle( self:GetAngles()-ang )
					-- end
					-- break
				-- end
			-- end
		-- end
		
		-- self:SetTargetEnt( data.HitEntity )
	-- end
	
	self:SetHasHit( true )
end

-- Misc hooks --
----------------
function ENT:Think()
	if SERVER and (not (IsValid(self:GetWep()) and self:GetWep()==self.Owner:GetActiveWeapon()) ) then self:Remove() return end
	
	local phys = self:GetPhysicsObject()
	if IsValid(phys) and self:GetHasHit() then // This stuff doesn't work in the collision hook
		phys:EnableMotion( false )
		phys:SetPos( self:GetPos() )
		phys:SetAngles( self:GetAngles() )
	end
end

function ENT:AllowPlayerPickup( ply, ent )
	if ply==self.Owner then return false end // They're currently hooked to something, if we let them pick it up they can exploit and fly
end

-- 3D Drawing --
----------------
local HookCable = Material( "cable/cable2" )
function ENT:Draw()
	if IsValid( self:GetTargetEnt() ) then
		local bpos, bang = self:GetTargetEnt():GetBonePosition( self:GetFollowBone() )
		local npos, nang = self:GetFollowOffset(), self:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			self:SetPos( npos )
			self:SetAngles( nang )
		end
	end
	
	self:DrawModel()
	
	// We'll draw the beam from both the weapon and the hook, less likely to move out of rendering when it should be visible
	if not IsValid( self:GetWep() ) then return end
	if self.Owner==LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return end // Badly aligned, the rope will always be visible from the ViewModel draw anyway
	
	if IsValid(self.Owner) then
		local att = self:GetWep():GetAttachment( 1 )
		
		render.SetMaterial( HookCable )
		if att and att.Pos then
			render.DrawBeam( self:GetPos(), att.Pos, 1, 0, 2, Color(255,255,255,255) )
		else
			render.DrawBeam( self:GetPos(), self:GetWep():GetPos(), 1, 0, 2, Color(255,255,255,255) )
		end
	end
end

-- HUD stuff --
---------------
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
local function ShadowText( txt, x, y, col )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, col or Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
function ENT:HUDPaint()
	if not (LocalPlayer()==self:GetTargetEnt()) then return end
	
	ShadowText( "Rope length: "..tostring(self:GetDist()), ScrW()/2, ScrH()/2-60 )
	ShadowText( "You have been hooked!", ScrW()/2, ScrH()/2-75, Color(255,100,100) )
	ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Break free", ScrW()/2, ScrH()/2-40 )
	DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)-20, 140, 15, self:GetDurability() )
end

if SERVER then
	function ENT:PlayerKeyPress( ply, key )
		if (ply~=self:GetTargetEnt() or key~=IN_USE) then return end
		
		self:SetDurability( self:GetDurability()+cvars.Number("hatshook_breakpower") )
		if self:GetDurability()>=100 then self:Destroyed() end
	end
end

--lua/entities/entityflame/shared.lua:
--[[-------------------------------------------------------------------------

We override the default fire visuals and sound by creating an entity of our own with the same name (entityflame),
which is removed immediately on creation - this is the only functionality we care for.

---------------------------------------------------------------------------]]

AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

if SERVER then
	function ENT:Initialize()
		self:Remove()
	end
end
--lua/entities/flame.lua:

AddCSLuaFile()

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Flame"
ENT.Author			= "FiLzO"
ENT.Purpose			= "Can you feel Air Exchange?"
ENT.Category		= "Combine Units +PLUS+"

ENT.Spawnable		= false
ENT.AdminOnly		= false

local COLLISION_RADIUS = 3
local LIFE_TIME = 0.35
local sndEngulf = Sound( "Fire.Engulf" )

if SERVER then

function ENT:Initialize()	
	self:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
	self:SetNoDraw( true )
	self:DrawShadow( false )
	self:PhysicsInitSphere( COLLISION_RADIUS )
	self:SetCollisionBounds( Vector( -COLLISION_RADIUS, -COLLISION_RADIUS, -COLLISION_RADIUS ), Vector( COLLISION_RADIUS, COLLISION_RADIUS, COLLISION_RADIUS ) )
	self:SetNotSolid( true )
	self:SetTrigger( true )
	self:SetMoveType( MOVETYPE_FLY )
	self:SetMoveCollide( MOVECOLLIDE_FLY_SLIDE )
	self.Owner = self:GetOwner() or self
	if not self.Owner:IsValid() then self.Owner = self end
	
	self.Weapon = self.Owner:GetActiveWeapon()
	if not self.Weapon:IsValid() then self.Weapon = self end
	self.DamageModifier = 1
	self.BaseDamage = 1
	self.NextTouch = CurTime()
	self:Fire( "kill", "", LIFE_TIME )
	self.KillTime = CurTime() + LIFE_TIME
	
end


function ENT:SetDamage( mindmg, maxdmg )

	self.DamageModifier = ( maxdmg - mindmg ) / LIFE_TIME
	self.BaseDamage = mindmg

end


function ENT:Touch( ent )

	-- ent == self.Owner or ent:IsWorld() then return end
	
	--if ent:GetClass()=="cup_fuel_tank" and ent:GetClass()=="npc_stalker" or ent:GetClass()=="npc_combine_s" or ent:GetClass()=="npc_metropolice" or ent:GetClass()=="npc_cscanner" or ent:GetClass()=="npc_manhack" or ent:GetClass()=="npc_strider" or ent:GetClass()=="npc_hunter" or ent:GetClass()=="npc_rollermine" or ent:GetClass()=="npc_clawscanner" or ent:GetClass()=="npc_turret_floor" or ent:GetClass()=="npc_turret_ceiling" or ent:GetClass()=="npc_combine_camera" or ent:GetClass()=="npc_combinedropship" or ent:GetClass()=="npc_combinegunship" or ent:GetClass()=="npc_helicopter" or ent:GetClass()=="npc_turret_ground" or ent:GetClass()=="npc_apcdriver" then return end
	
	if ent.wearsuit == true then return end
	
	if self.NextTouch > CurTime() then return end
	self.NextTouch = CurTime() + 0.05
	
	-- Die under water
	--if self:WaterLevel() >= 1 then
	--	self:Remove()
	--	return
	--end
	
	-- Stop moving since we hit something
	self:SetMoveType( MOVETYPE_NONE )

	-- Make sure the owner and weapon are still around, otherwise we would error out
	if not self.Owner:IsValid() then self.Owner = self end
	if not self.Weapon:IsValid() then self.Weapon = self end
	
	-- Apply damage based on how long the projectile has been alive
	local dmg = ( self.KillTime - CurTime() ) * self.DamageModifier + self.BaseDamage
	if dmg < 0 then dmg = 0 end
	ent:TakeDamage( dmg, self.Owner, self.Weapon )
	
	-- Play that cool igniting sound if this entity is being ignited for the first time
	if not ent:IsOnFire() then
		ent:EmitSound( sndEngulf )
	end
	
	-- Ignite the entity
	--if ent:IsPlayer() then
		ent:Ignite( math.random( 5, 6 ), 0 ) -- Go easier on players
	--else
	--	ent:Fire( "IgniteLifeTime", math.random( 10, 12 ), 0 ) -- garry done broke ent:Ignite(), so we have to use this
	--end

end

end

--addons/hbombs_base/lua/entities/hb_base_advanced.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

local Models = {}
Models[1]                            =  "testmodel"

local ExploSnds = {}
ExploSnds[1]                         =  "BaseExplosionEffect.Sound"

local damagesound                    =  "weapons/rpg/shotdown.wav"

ENT.Spawnable		            	 =  false         
ENT.AdminSpawnable		             =  false       

ENT.PrintName		                 =  "Name"        
ENT.Author			                 =  "natsu & Business Cat"      
ENT.Contact			                 =  "natsu" 
ENT.Category                         =  ""            

ENT.Model                            =  ""            
ENT.Effect                           =  ""            
ENT.EffectAir                        =  ""           
ENT.EffectWater                      =  ""            
ENT.ExplosionSound                   =  ""            
ENT.ArmSound                         =  ""            
ENT.ActivationSound                  =  ""    
ENT.NBCEntity                        =  ""   


ENT.ShouldUnweld                     =  false         
ENT.ShouldIgnite                     =  false         
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false         
ENT.UseRandomModels                  =  false                
ENT.Timed                            =  false    
ENT.IsNBC                            =  false

ENT.ExplosionDamage                  =  0             
ENT.PhysForce                        =  0             
ENT.ExplosionRadius                  =  0            
ENT.SpecialRadius                    =  0             
ENT.MaxIgnitionTime                  =  5             
ENT.Life                             =  20           
ENT.MaxDelay                         =  2             
ENT.TraceLength                      =  500           
ENT.ImpactSpeed                      =  500          
ENT.Mass                             =  0                     
ENT.ArmDelay                         =  2                      
ENT.Timer                            =  0
ENT.Shocktime                        =  1

ENT.DEFAULT_PHYSFORCE                = 500
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 100
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 5000 
ENT.HBOWNER                          =  nil            

function ENT:Initialize()
 if (SERVER) then
     self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) 
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end
	 if (skincount > 0) then
	     self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Used     = false
	 self.Arming   = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:TriggerInput(iname, value)
     if (!self:IsValid()) then return end
	 if (iname == "Detonate") then
         if (value >= 1) then
		     if (!self.Exploded and self.Armed) then
			     timer.Simple(math.Rand(0,self.MaxDelay),function()
				     if !self:IsValid() then return end
	                 self.Exploded = true
			         self:Explode()
				 end)
		     end
		 end
	 end
	 if (iname == "Arm") then
         if (value >= 1) then
             if (!self.Exploded and !self.Armed and !self.Arming) then
			     self:EmitSound(self.ActivationSound)
                 self:Arm()
             end 
         end
     end		 
end 

function ENT:LoadModel()
     if self.UseRandomModels then
	     self:SetModel(table.Random(Models))
	 else
	     self:SetModel(self.Model)
	 end
end
	 

function Shockwave(pos, radius, owner)
	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", 300)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 200)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 200)
	ent:SetVar("HBOWNER", owner)
	ent:SetVar("MAX_RANGE", radius)
	ent:SetVar("SHOCKWAVE_INCREMENT",50)
	ent:SetVar("DELAY",0.005)
	ent.trace=200
	ent.decal="scorch_small"
end

function Shockwave(pos, radius, owner)
	if (SERVER) then
	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", 300)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 200)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 200)
	ent:SetVar("HBOWNER", owner)
	ent:SetVar("MAX_RANGE", radius)
	ent:SetVar("SHOCKWAVE_INCREMENT",50)
	ent:SetVar("DELAY",0.005)
	ent.trace=200
	ent.decal="scorch_small"
	end
end

function Soundwave(pos, radius, sound, shocktime)
	if (SERVER) then
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", nil)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", sound)
	if shocktime==nil then ent:SetVar("Shocktime", 0.1) else ent:SetVar("Shocktime", shocktime) end
	end
end



function ENT:Explode()
	if !self.Exploded then return end
	local pos = self:LocalToWorld(self:OBBCenter())

	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	ent:SetVar("SHOCKWAVE_INCREMENT",100)
	ent:SetVar("DELAY",0.01)
	ent.trace=self.TraceLength
	ent.decal=self.Decal

	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",200)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", self.ExplosionSound)
	ent:SetVar("Shocktime", self.Shocktime)
	
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
	     trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
	     trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
	     
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
     end
	 if self.IsNBC then
	     local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
     self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
     if self.Exploded then return end
     self:TakePhysicsDamage(dmginfo)
	 
	 local phys = self:GetPhysicsObject()
	 
     if (self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(!self.Armed and !self.Arming) then
	         self:Arm()
	     end
	 end
	 
     if(!self.Armed) then return end

	 if self:IsValid() then
	     self.Life = self.Life - dmginfo:GetDamage()
		 if (self.Life <= self.Life/2) and !self.Exploded and self.Flamable then
		     self:Ignite(self.MaxDelay,0)
		 end
		 if (self.Life <= 0) then 
		     timer.Simple(math.Rand(0,self.MaxDelay),function()
			     if !self:IsValid() then return end 
			     self.Exploded = true
			     self:Explode()
			 end)
	     end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then
		         self:EmitSound(damagesound)
	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Arm()
     if(!self:IsValid()) then return end
	 if(self.Exploded) then return end
	 if(self.Armed) then return end
	 self.Arming = true
	 self.Used = true
	 timer.Simple(self.ArmDelay, function()
	     if !self:IsValid() then return end 
	     self.Armed = true
		 self.Arming = false
		 self:EmitSound(self.ArmSound)
		 if(self.Timed) then
	         timer.Simple(self.Timer, function()
	             if !self:IsValid() then return end 
				 timer.Simple(math.Rand(0,self.MaxDelay),function()
			         if !self:IsValid() then return end 
			         self.Exploded = true
			         self:Explode()
				 end)
	         end)
	     end
	 end)
end	 

function ENT:Use( activator, caller )
     if(self.Exploded) then return end
     if(self:IsValid()) then
	     if(GetConVar("hb_easyuse"):GetInt() >= 1) then
	         if(!self.Armed) then
		         if(!self.Exploded) and (!self.Used) then
		             if(activator:IsPlayer()) then
                         self:EmitSound(self.ActivationSound)
                         self:Arm()
		             end
	             end
             end
         end
	 end
end

function ENT:OnRemove()
	 self:StopParticles()
	-- Wire_Remove(self)
end

if ( CLIENT ) then
     function ENT:Draw()
         self:DrawModel()
		 if !(WireAddon == nil) then Wire_Render(self.Entity) end
     end
end

function ENT:OnRestore()
     Wire_Restored(self.Entity)
end

function ENT:BuildDupeInfo()
     return WireLib.BuildDupeInfo(self.Entity)
end

function ENT:ApplyDupeInfo(ply, ent, info, GetEntByID)
     WireLib.ApplyDupeInfo( ply, ent, info, GetEntByID )
end

function ENT:PrentityCopy()
     local DupeInfo = self:BuildDupeInfo()
     if(DupeInfo) then
         duplicator.StorentityModifier(self,"WireDupeInfo",DupeInfo)
     end
end

function ENT:PostEntityPaste(Player,Ent,CreatedEntities)
     if(Ent.EntityMods and Ent.EntityMods.WireDupeInfo) then
         Ent:ApplyDupeInfo(Player, Ent, Ent.EntityMods.WireDupeInfo, function(id) return CreatedEntities[id] end)
     end
end
--addons/hbombs_base/lua/entities/hb_base_advanced_nuke.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

local Models = {}
Models[1]                            =  "testmodel"

local ExploSnds = {}
ExploSnds[1]                         =  "BaseExplosionEffect.Sound"

local damagesound                    =  "weapons/rpg/shotdown.wav"

ENT.Spawnable		            	 =  false         
ENT.AdminSpawnable		             =  false       

ENT.PrintName		                 =  "Name"        
ENT.Author			                 =  "natsu"      
ENT.Contact			                 =  "natsu" 
ENT.Category                         =  ""            

ENT.Model                            =  ""            
ENT.Effect                           =  ""            
ENT.EffectAir                        =  ""           
ENT.EffectWater                      =  ""            
ENT.ExplosionSound                   =  ""            
ENT.ArmSound                         =  ""            
ENT.ActivationSound                  =  ""    
ENT.NBCEntity                        =  ""   
ENT.GASENTITY                        =  ""   
ENT.PARALIZentITY                   =  ""   

ENT.ShouldUnweld                     =  false         
ENT.ShouldIgnite                     =  false         
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false         
ENT.UseRandomModels                  =  false                
ENT.Timed                            =  false    
ENT.IsParalize                       =  false     
ENT.IsNBC                            =  false
ENT.IsGas                            =  false

ENT.ExplosionDamage                  =  0             
ENT.PhysForce                        =  0             
ENT.ExplosionRadius                  =  0            
ENT.SpecialRadius                    =  0             
ENT.MaxIgnitionTime                  =  5             
ENT.Life                             =  20           
ENT.MaxDelay                         =  2             
ENT.TraceLength                      =  500           
ENT.ImpactSpeed                      =  500          
ENT.Mass                             =  0                     
ENT.ArmDelay                         =  2                      
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil            

function ENT:Initialize()
 if (SERVER) then
     self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) 
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end
	 if (skincount > 0) then
	     self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Used     = false
	 self.Arming   = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:TriggerInput(iname, value)
     if (!self:IsValid()) then return end
	 if (iname == "Detonate") then
         if (value >= 1) then
		     if (!self.Exploded and self.Armed) then
			     timer.Simple(math.Rand(0,self.MaxDelay),function()
				     if !self:IsValid() then return end
	                 self.Exploded = true
			         self:Explode()
				 end)
		     end
		 end
	 end
	 if (iname == "Arm") then
         if (value >= 1) then
             if (!self.Exploded and !self.Armed and !self.Arming) then
			     self:EmitSound(self.ActivationSound)
                 self:Arm()
             end 
         end
     end		 
end 

function ENT:LoadModel()
     if self.UseRandomModels then
	     self:SetModel(table.Random(Models))
	 else
	     self:SetModel(self.Model)
	 end
end
	 


function ENT:Explode()
     if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
	     if v:IsValid() then
			 local i = 0
		     while i < v:GetPhysicsObjectCount() do
			 phys = v:GetPhysicsObjectNum(i)
		     if (phys:IsValid()) then
				 local mass = phys:GetMass()
				 local F_ang = self.PhysForce
				 local dist = (pos - v:GetPos()):Length()
				 local relation = math.Clamp((self.SpecialRadius - dist) / self.SpecialRadius, 0, 1)
				 local F_dir = (v:GetPos() - pos):GetNormal() * self.PhysForce	 
			     if(GetConVar("hb_unfreeze"):GetInt() >= 1) then
				     phys:Wake()
			   	     phys:EnableMotion(true)
			     end
				 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
				     phys:AddVelocity(F_dir)
		     end
			 i = i + 1
			 end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius/2)) do
		 if(GetConVar("hb_deleteconstraints"):GetInt() >= 1) then
			 if self.ShouldUnweld then
				 if v:IsValid() and v:GetPhysicsObject():IsValid() then
				     constraint.RemoveAll(v)
				 end
			 end
		 end
		 if self.ShouldIgnite then
			 if v:IsOnFire() then
				 v:Extinguish()
			 end
			 v:Ignite(math.Rand(self.MaxIgnitionTime-2,self.MaxIgnitionTime),5)
		 end
     end
	 if(GetConVar("hb_explosion_damage"):GetInt() >= 1) then
	 	if !(self.HBOWNER==nil) then
			util.BlastDamage(self, self.HBOWNER, pos, self.ExplosionRadius, self.ExplosionDamage)
		end
	 end
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
	     trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
	     trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
	     
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
     end
	 if self.IsNBC then
	     local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
     self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
     if self.Exploded then return end
     self:TakePhysicsDamage(dmginfo)
	 
	 local phys = self:GetPhysicsObject()
	 
     if (self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(!self.Armed and !self.Arming) then
	         self:Arm()
	     end
	 end
	 
     if(!self.Armed) then return end

	 if self:IsValid() then
	     self.Life = self.Life - dmginfo:GetDamage()
		 if (self.Life <= self.Life/2) and !self.Exploded and self.Flamable then
		     self:Ignite(self.MaxDelay,0)
		 end
		 if (self.Life <= 0) then 
		     timer.Simple(math.Rand(0,self.MaxDelay),function()
			     if !self:IsValid() then return end 
			     self.Exploded = true
			     self:Explode()
			 end)
	     end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then
		         self:EmitSound(damagesound)
	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Arm()
     if(!self:IsValid()) then return end
	 if(self.Exploded) then return end
	 if(self.Armed) then return end
	 self.Arming = true
	 self.Used = true
	 timer.Simple(self.ArmDelay, function()
	     if !self:IsValid() then return end 
	     self.Armed = true
		 self.Arming = false
		 self:EmitSound(self.ArmSound)
		 if(self.Timed) then
	         timer.Simple(self.Timer, function()
	             if !self:IsValid() then return end 
				 timer.Simple(math.Rand(0,self.MaxDelay),function()
			         if !self:IsValid() then return end 
			         self.Exploded = true
			         self:Explode()
				 end)
	         end)
	     end
	 end)
end	 

function ENT:Use( activator, caller )
     if(self.Exploded) then return end
     if(self:IsValid()) then
	     if(GetConVar("hb_easyuse"):GetInt() >= 1) then
	         if(!self.Armed) then
		         if(!self.Exploded) and (!self.Used) then
		             if(activator:IsPlayer()) then
                         self:EmitSound(self.ActivationSound)
                         self:Arm()
		             end
	             end
             end
         end
	 end
end

function ENT:OnRemove()
	 self:StopParticles()
	-- Wire_Remove(self)
end

if ( CLIENT ) then
     function ENT:Draw()
         self:DrawModel()
		 if !(WireAddon == nil) then Wire_Render(self.Entity) end
     end
end

function ENT:OnRestore()
     Wire_Restored(self.Entity)
end

function ENT:BuildDupeInfo()
     return WireLib.BuildDupeInfo(self.Entity)
end

function ENT:ApplyDupeInfo(ply, ent, info, GetEntByID)
     WireLib.ApplyDupeInfo( ply, ent, info, GetEntByID )
end

function ENT:PrentityCopy()
     local DupeInfo = self:BuildDupeInfo()
     if(DupeInfo) then
         duplicator.StorentityModifier(self,"WireDupeInfo",DupeInfo)
     end
end

function ENT:PostEntityPaste(Player,Ent,CreatedEntities)
     if(Ent.EntityMods and Ent.EntityMods.WireDupeInfo) then
         Ent:ApplyDupeInfo(Player, Ent, Ent.EntityMods.WireDupeInfo, function(id) return CreatedEntities[id] end)
     end
end

--addons/hbombs_base/lua/entities/hb_base_rocket_.lua:
AddCSLuaFile()
-- Sounds
sound.Add( {
	name = "Motor_Small",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 100,
	pitch = {140, 140},
	sound = "gbombs_5/launch/rocket.wav"
} )
sound.Add( {
	name = "Motor_Small2",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 100,
	pitch = {120, 120},
	sound = "gbombs_5/launch/rocket.wav"
} )


sound.Add( {
	name = "Motor_Medium",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {100, 100},
	sound = "gbombs_5/launch/rocket.wav"
} )

sound.Add( {
	name = "Motor_Medium2",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {80, 80},
	sound = "gbombs_5/launch/rocket.wav"
} )

sound.Add( {
	name = "Motor_Large2",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 160,
	pitch = {50, 50},
	sound = "gbombs_5/launch/rocket.wav"
} )
-- End
DEFINE_BASECLASS( "base_anim" )

local ImpactSounds = {}
ImpactSounds[1]                      =  "chappi/imp0.wav"
ImpactSounds[2]                      =  "chappi/imp1.wav"
ImpactSounds[3]                      =  "chappi/imp2.wav"
ImpactSounds[4]                      =  "chappi/imp3.wav"
ImpactSounds[5]                      =  "chappi/imp4.wav"
ImpactSounds[6]                      =  "chappi/imp5.wav"
ImpactSounds[7]                      =  "chappi/imp6.wav"
ImpactSounds[8]                      =  "chappi/imp7.wav"
ImpactSounds[9]                      =  "chappi/imp8.wav"
ImpactSounds[10]                     =  "chappi/imp9.wav"

local damagesound                    =  "weapons/rpg/shotdown.wav"

local ExploSnds = {}
ExploSnds[1]                         =  "BaseExplosionEffect.Sound"

ENT.Spawnable		            	 =  false     
ENT.AdminSpawnable		             =  false       

ENT.PrintName		                 =  "natsu"            
ENT.Author			                 =  "natsu"       
ENT.Contact			                 =  "crap" 
ENT.Category                         =  "Explosives"   

ENT.Model                            =  ""            
ENT.RocketTrail                      =  ""            
ENT.RocketBurnoutTrail               =  ""            
ENT.Effect                           =  ""            
ENT.EffectAir                        =  ""            
ENT.EffectWater                      =  ""           
ENT.ExplosionSound                   =  ""            
ENT.StartSound                       =  ""            
ENT.ArmSound                         =  ""            
ENT.ActivationSound                  =  ""      
ENT.EngineSound                      =  "Missile.Ignite"  
ENT.NBCEntity                        =  "" 

ENT.ShouldUnweld                     =  false          
ENT.ShouldIgnite                     =  false         
ENT.UseRandomSounds                  =  false     
ENT.SmartLaunch                      =  true     
ENT.Timed                            =  false 
ENT.IsNBC                            =  false

ENT.ExplosionDamage                  =  0            
ENT.ExplosionRadius                  =  0             
ENT.PhysForce                        =  0             
ENT.SpecialRadius                    =  0             
ENT.MaxIgnitionTime                  =  5             
ENT.Life                             =  20            
ENT.MaxDelay                         =  2            
ENT.TraceLength                      =  500           
ENT.ImpactSpeed                      =  500           
ENT.Mass                             =  0   
ENT.EnginePower                      =  0             
ENT.FuelBurnoutTime                  =  0             
ENT.IgnitionDelay                    =  0                        
ENT.RotationalForce                  =  25            
ENT.ArmDelay                         =  2             
ENT.ForceOrientation                 =  "NORMAL"
ENT.Timer                            =  0


ENT.LightEmitTime                    =  0
ENT.LightRed                         =  0
ENT.LightBlue						 =  0
ENT.LightGreen						 =  0
ENT.LightBrightness					 =  0
ENT.LightSize   					 =  0




ENT.HBOWNER                          =  nil             -- don't you fucking touch this.



function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)  
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType(MOVETYPE_VPHYSICS)
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end
	 if (skincount > 0) then
	     self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Fired    = false
	 self.Burnt    = false
	 self.Ignition = false
	 self.Arming   = false
	 if !(WireAddon == nil) then self.Inputs = Wire_CreateInputs(self, { "Arm", "Detonate", "Launch" }) end
	end
end

function ENT:TriggerInput(iname, value)
     if (!self:IsValid()) then return end
	 if (iname == "Detonate") then
         if (value >= 1) then
		     if (!self.Exploded and self.Armed) then
			     timer.Simple(math.Rand(0,self.MaxDelay),function()
				     if !self:IsValid() then return end
	                 self.Exploded = true
					 
			         self:Explode()
				 end)
		     end
		 end
	 end
	 if (iname == "Arm") then
         if (value >= 1) then
             if (!self.Exploded and !self.Armed and !self.Arming) then
			     self:EmitSound(self.ActivationSound)
                 self:Arm()
             end 
         end
     end		 
	 if (iname == "Launch") then 
	     if (value >= 1) then
		     if (!self.Exploded and !self.Burnt and !self.Ignition and !self.Fired) then
			     self:Launch()
		     end
	     end
     end
end          

function ENT:Explode()
     if not self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	  	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime", self.Shocktime)

	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
	     if v:IsValid() then
		     --local phys = v:GetPhysicsObject()
			 local i = 0
		     while i < v:GetPhysicsObjectCount() do
			 phys = v:GetPhysicsObjectNum(i)	  
             if (phys:IsValid()) then		
		 	     local mass = phys:GetMass()
				 local F_ang = self.PhysForce
				 local dist = (pos - v:GetPos()):Length()
				 local relation = math.Clamp((self.SpecialRadius - dist) / self.SpecialRadius, 0, 1)
				 local F_dir = (v:GetPos() - pos):GetNormal() * self.PhysForce
				   
				 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
				 phys:AddVelocity(F_dir)
		     end
			 i = i + 1
			 end
		 end
	 end
	 
     if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
		 local tr2 = util.TraceLine(trdat2)
			 
	     if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)   
		 end
     else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
	     
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
     end
	 if self.IsNBC then
	     local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
     if !self:IsValid() then return end
     if self.Exploded then return end
	 if (self.Life <= 0) then return end
	 self:TakePhysicsDamage(dmginfo)
     if(GetConVar("hb_fragility"):GetInt() >= 1) then  
	     if(!self.Fired and !self.Burnt and !self.Arming and !self.Armed) then
	         if(math.random(0,9) == 1) then
		         self:Launch()
		     else
			     self:Arm()
			 end
	     end
	 end
	 if(self.Fired and !self.Burnt and self.Armed) then
	     if (dmginfo:GetDamage() >= 2) then
		     local phys = self:GetPhysicsObject()
		     self:EmitSound(damagesound)
	         phys:AddAngleVelocity(dmginfo:GetDamageForce()*0.1)
	     end
	 end
	 if(!self.Armed) then return end
	 self.Life = self.Life - dmginfo:GetDamage()
     if (self.Life <= 0) then 
		 timer.Simple(math.Rand(0,self.MaxDelay),function()
	         if !self:IsValid() then return end 
			 self.Exploded = true
			 self:Explode()
			
	     end)
	 end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(!self.Fired and !self.Burnt and !self.Arming and !self.Armed ) and (data.Speed > self.ImpactSpeed * 5) then --and !self.Arming and !self.Armed
		     if(math.random(0,9) == 1) then
			     self:Launch()
		         self:EmitSound(damagesound)
			 else
			     self:Arm()
				 self:EmitSound(damagesound)
			 end
	     end
	 end

	 if(!self.Armed) then return end
		
	 if (data.Speed > self.ImpactSpeed )then
		 self.Exploded = true
		 self:Explode()
	 end
end

function ENT:Launch()
     if(self.Exploded) then return end
	 if(self.Burned) then return end
	 --if(self.Armed) then return end
	 if(self.Fired) then return end
	 
	 local phys = self:GetPhysicsObject()
	 if !phys:IsValid() then return end
	 
	 self.Fired = true
	 if(self.SmartLaunch) then
		 constraint.RemoveAll(self)
	 end
	 timer.Simple(0.05,function()
	     if not self:IsValid() then return end
	     if(phys:IsValid()) then
             phys:Wake()
		     phys:EnableMotion(true)
	     end
	 end)
	 timer.Simple(self.IgnitionDelay,function()
	     if not self:IsValid() then return end  -- Make a short ignition delay!
		 self:SetNetworkedBool("Exploded",true)
		 self:SetNetworkedInt("LightRed", self.LightRed)
		 self:SetNetworkedInt("LightBlue", self.LightBlue)
		 self:SetNetworkedInt("LightGreen", self.LightGreen)	
		 self:SetNetworkedBool("EmitLight",true)
		 self:SetNetworkedInt("LightEmitTime", self.LightEmitTime)
		 self:SetNetworkedInt("LightBrightness", self.LightBrightness)
		 self:SetNetworkedInt("LightSize", self.LightSize)
		 local phys = self:GetPhysicsObject()
		 self.Ignition = true
		 self:Arm()
		 local pos = self:GetPos()
		 sound.Play(self.StartSound, pos, 160, 130,1)
	     self:EmitSound(self.EngineSound)
		 self:SetNetworkedBool("EmitLight",true)
		 self:SetNetworkedBool("self.Ignition",true)
		 ParticleEffectAttach(self.RocketTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
		 if(self.FuelBurnoutTime != 0) then 
	         timer.Simple(self.FuelBurnoutTime,function()
		         if not self:IsValid() then return end 
		         self.Burnt = true
		         self:StopParticles()
		         self:StopSound(self.EngineSound)
	             ParticleEffectAttach(self.RocketBurnoutTrail,PATTACH_ABSORIGIN_FOLLOW,self,1)
             end)	 
		 end
     end)		 
end

function ENT:Think()
     if(self.Burnt) then return end
     if(!self.Ignition) then return end -- if there wasn't ignition, we won't fly
	 if(self.Exploded) then return end -- if we exploded then what the fuck are we doing here
	 if(!self:IsValid()) then return end -- if we aren't good then something fucked up
	 local phys = self:GetPhysicsObject()  
	 local thrustpos = self:GetPos()
	 if(self.ForceOrientation == "RIGHT") then
	     phys:AddVelocity(self:GetRight() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "LEFT") then
	     phys:AddVelocity(self:GetRight() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "UP") then
	     phys:AddVelocity(self:GetUp() * self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "DOWN") then 
	     phys:AddVelocity(self:GetUp() * -self.EnginePower) -- Continuous engine impulse
	 elseif(self.ForceOrientation == "INV") then
	     phys:AddVelocity(self:GetForward() * -self.EnginePower) -- Continuous engine impulse
	 else
		 phys:AddVelocity(self:GetForward() * self.EnginePower) -- Continuous engine impulse
	 end
	 if (self.Armed) then
        phys:AddAngleVelocity(Vector(self.RotationalForce,0,0)) -- Rotational force
	 end
	 
	 self:NextThink(CurTime() + 0.01)
	 return true
end

function ENT:Arm()
     if(!self:IsValid()) then return end
	 if(self.Armed) then return end
	 self.Arming = true
	 
	 timer.Simple(self.ArmDelay, function()
	     if not self:IsValid() then return end 
	     self.Armed = true
		 self.Arming = false
		 self:EmitSound(self.ArmSound)
		 if(self.Timed) then
	         timer.Simple(self.Timer, function()
	             if !self:IsValid() then return end 
			     self.Exploded = true
			     self:Explode()
				 self.EmitLight = true
	         end)
		 end
	 end)
end	 

function ENT:Use( activator, caller )
     if(self.Exploded) then return end
	 if(self.Dumb) then return end
	 if(GetConVar("hb_easyuse"):GetInt() >= 1) then
         if(self:IsValid()) then
             if (!self.Exploded) and (!self.Burnt) and (!self.Fired) then
	             if (activator:IsPlayer()) then
                     self:EmitSound(self.ActivationSound)
                     self:Launch()
		         end
	         end
         end
	 end
end

function ENT:OnRemove()
     self:StopSound(self.EngineSound)
	 self:StopParticles()
end

if ( CLIENT ) then
     function ENT:Draw()
         self:DrawModel()
		 if !(WireAddon == nil) then Wire_Render(self.Entity) end
     end
end

function ENT:OnRestore()
     Wire_Restored(self.Entity)
end

function ENT:BuildDupeInfo()
     return WireLib.BuildDupeInfo(self.Entity)
end

function ENT:ApplyDupeInfo(ply, ent, info, GetEntByID)
     WireLib.ApplyDupeInfo( ply, ent, info, GetEntByID )
end

function ENT:PrentityCopy()
     local DupeInfo = self:BuildDupeInfo()
     if(DupeInfo) then
         duplicator.StorentityModifier(self.Entity,"WireDupeInfo",DupeInfo)
     end
end

function ENT:PostEntityPaste(Player,Ent,CreatedEntities)
     if(Ent.EntityMods and Ent.EntityMods.WireDupeInfo) then
         Ent:ApplyDupeInfo(Player, Ent, Ent.EntityMods.WireDupeInfo, function(id) return CreatedEntities[id] end)
     end
end
--addons/hbombs_base/lua/entities/hb_main_gasleakbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

local ExploSnds = {}
ExploSnds[1]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_small.mp3"
ExploSnds[2]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_medium.mp3"
ExploSnds[3]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_small2.mp3"
ExploSnds[4]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_medium2.mp3"


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Gas Bomb"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/props_wasteland/laundry_washer001a.mdl"                      
ENT.Effect                           =  "h_gasbomb"                  
ENT.EffectAir                        =  "h_gasbomb_air"                   
ENT.EffectWater                      =  "h_water_medium"
ENT.ExplosionSound                   =  ""
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  750
ENT.PhysForce                        =  600
ENT.ExplosionRadius                  =  950
ENT.SpecialRadius                    =  575
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  10                                 
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  300
ENT.ImpactSpeed                      =  350
ENT.Mass                             =  500
ENT.ArmDelay                         =  1 
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Explode()
    if !self.Exploded then return end
	if self.Exploding then return end
	local pos = self:LocalToWorld(self:OBBCenter())
	self:SetMoveType( MOVETYPE_NONE )
	
 	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",100)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", "hbombs/gasleak_long.mp3")
	ent:SetVar("Shocktime", self.Shocktime)
	timer.Simple(5, function()
	
	 	local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",100)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/light_bomb/mine_explosion.mp3")
		ent:SetVar("Shocktime", self.Shocktime)	
	
		local ent = ents.Create("hb_main_napalm_burning")
		local pos = self:LocalToWorld(self:OBBCenter())
		ent:SetPos( pos )
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER",self.HBOWNER)
		
		for k, v in pairs(ents.FindInSphere(pos,750)) do
			if v:IsPlayer() or v:IsNPC() then
				if v:GetClass()=="npc_helicopter" then return end
				v:Ignite(5,0)
			else
				local phys = self:GetPhysicsObject()
				if phys:IsValid() then
					v:Ignite(3,0)
				end
			end
		end
		self:Remove()
	end)
	if(self:WaterLevel() >= 1) then
		local trdata   = {}
		local trlength = Vector(0,0,9000)

		trdata.start   = pos
		trdata.endpos  = trdata.start + trlength
		trdata.filter  = self

		local tr = util.TraceLine(trdata) 
		local trdat2   = {}
		trdat2.start   = tr.HitPos
		trdat2.endpos  = trdata.start - trlength
		trdat2.filter  = self
		trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

		local tr2 = util.TraceLine(trdat2)

		if tr2.Hit then
			ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		end
	else
		local tracedata    = {}
		tracedata.start    = pos
		tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		tracedata.filter   = self.Entity

		local trace = util.TraceLine(tracedata)

		if trace.HitWorld then
			local ang = self:GetAngles()
			ParticleEffect(self.Effect,pos,Angle(0,ang.y,0),nil) 

		else 
			ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		end
	end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
     self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
     ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 48 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_misc_tower_02.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Nuclear Testing Tower 2"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/trinity_tower_2.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500         
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  50000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 890 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_c_tritium.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "H-3 (Tritium)"
ENT.Author							 =  "natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/tritium.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  200        
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  50

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
	 if not self.Exploded then return end
	 if self.UseRandomSounds then
		 sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
	 else
		 sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end


--addons/hbombs/lua/entities/hb_nuclear_castlebravo_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Castle Bravo - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/models/castlerubaut.mdl"                      
ENT.Effect                           =  "h_nuke4_a"                  
ENT.EffectAir                        =  "h_nuke4_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio3.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  25000
ENT.SpecialRadius                    =  10000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  25000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_big"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 200)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal

	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",20)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",5)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",40000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=18000
	 end			 
	 local ent = ents.Create("hb_shockwave_rumbling")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",200)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",150)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 64 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_clusternuke.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true    
ENT.AdminSpawnable		             =  false

ENT.AdminOnly 						 =  true

ENT.PrintName		                 =  "CLUSTER NUKE [WHY]"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/tsar.mdl"                      
ENT.Effect                           =  "hnuke1"                  
ENT.EffectAir                        =  "hnuke1_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/tsar_detonate.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  35000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1300
ENT.Mass                             =  18500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_tsar"
function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(data.Speed > 200) then
		if math.random(1,2)==1 then
			self:EmitSound("gbombs_5/arm/tsarland.wav", 80, math.random(90,110))
		else
			self:EmitSound("gbombs_5/arm/tsarland2.wav", 80, math.random(90,110))
		end
	 end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then

	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:GetPos()
	 
	 for i=1,5 do
		
		timer.Simple(i, function()
				
			local nuke_table = {"hb_nuclear_clusternuke","hb_nuclear_castlebravo","hb_nuclear_ionbomb","hb_nuclear_slownuke","hb_nuclear_fatman","hb_nuclear_grable","hb_nuclear_ivymike","hb_nuclear_littleboy","hb_nuclear_trinity"}
			local ent = ents.Create(table.Random(nuke_table))
			
			ent:SetPos(pos)
			
			ent:Spawn()
			ent:Activate()
		end)
	 end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",35000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("DEFAULT_PHYSFORCE", 955)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 15)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 155)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
	 end			 
	 local ent = ents.Create("hb_shockwave_rumbling")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",5000)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_in.mp3")

	 
	 local ent = ents.Create("hb_shockwave_sound_burst")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)

	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",110)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_detonate.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && v:Alive() then
			    v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
	     if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
     end)
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

		     local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
		         ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		    
			 end
		 else
		     local tracedata    = {}
	         tracedata.start    = pos
		     tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		     tracedata.filter   = self.Entity
				
		     local trace = util.TraceLine(tracedata)
	     
		     if trace.HitWorld then
		         ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			     timer.Simple(2, function()
			         if !self:IsValid() then return end 
			         ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				     self:Remove()
             end)	
		     else 
			     ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 --Here we do an emp check
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		     end
		 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_grable.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Mk33 [Atomic]"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/atomicshell.mdl"                      
ENT.Effect                           =  "h_nuke"                  
ENT.EffectAir                        =  "h_nuke_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  0                              
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end



function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_instant")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_BURSTS", 1)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("DELAY",0.1)
	 ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
	 ent:SetVar("Shocktime",1)
	 
	 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
	 end	
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 100)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",8000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( self:GetPos() ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT", 130)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")

	 
	 
	 
	 
	 
	 
	 
	 
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() and !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 
		 
		 
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
	
		 self:StopParticles()
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_ivyking.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Ivy King"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/failure/mk6/mk6.mdl"                      
ENT.Effect                           =  "h_nuke5"                  
ENT.EffectAir                        =  "h_nuke5_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  8500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0


ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 if self:GetModelScale() == 3 then return end
	 self:SetModelScale( self:GetModelScale() * 3 )
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",10000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 	
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
	 end	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")

	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,9000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
	
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

--function ENT:OnDuplicated() do 
--addons/hbombs/lua/entities/hb_nuclear_littleboy_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Little boy - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/littleboy.mdl"                      
ENT.Effect                           =  "h_nuke2_a"                  
ENT.EffectAir                        =  "h_nuke2_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1000
ENT.Mass                             =  1000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"



function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 for k, v in pairs(ents.FindInSphere(pos,8000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,5000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
				v:Kill()
			end
		 end
	 end
	 



  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 75)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 10)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",8000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
	 	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			end
			
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/realnukewithrumbling.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
		 self.Exploding = true
		 self:StopParticles()
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 24 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_megatonbomb_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Megaton Bomb - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/props_fallout/megatonbomb.mdl"                      
ENT.Effect                           =  "hnuke3_a"                  
ENT.EffectAir                        =  "hnuke3_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  15000
ENT.SpecialRadius                    =  6000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  20000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 655
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,10000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,6000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	 
  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
		 end	
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 150)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",12000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 
		 self.Exploding = true
		 constraint.RemoveAll(self)
		 
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
	 end)
	 
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		 end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 110 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(0,0,90))	
	 
	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_trinity.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Gadget"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/gadget.mdl"                      
ENT.Effect                           =  "h_nuke3"                  
ENT.EffectAir                        =  "h_nuke3_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  11000
ENT.SpecialRadius                    =  4500
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  2000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  5000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 655
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,10000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,6000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	 
  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=9000
		 end	
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 150)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",12000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
		 
		 self.Exploding = true
		 constraint.RemoveAll(self)
		 
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
	 end)
	 
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		 end
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 80 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(0,0,90))	 

	 return ent
end
--addons/hbombs/lua/entities/hb_proj_icbm_wh.lua:
AddCSLuaFile()


DEFINE_BASECLASS( "hb_base_dumb" )




ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "ICBM Warhead (EMPTY)"
ENT.Author							 =  ""
ENT.Contact							 =  ""
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/icbm/capsule.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  2500

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",500000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",20000)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime",4)
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * -600 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_shockwave_ash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 2
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
			         dmg:SetDamage(math.random(0,0))
			         dmg:SetDamageType(DMG_GENERIC)
			         dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if v:IsOnFire() then return end
				 
				 local damageables =  {["models/props_junk/wood_crate001a.mdl"]=true, 
				 ["models/props_junk/wood_crate001a_damaged.mdl"]=true, 
				 ["models/props_junk/wood_crate002a.mdl"]=true,
				 ["models/props_c17/furniturecupboard001a.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a_chunk01.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a_chunk02.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a_chunk03.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a_chunk05.mdl"]=true,
				 ["models/props_c17/furnituredrawer001a_chunk06.mdl"]=true,
				 ["models/props_c17/furnituredrawer002a.mdl"]=true,
				 ["models/props_c17/furnituredrawer003a.mdl"]=true,
				 ["models/props_c17/furnituredresser001a.mdl"]=true,
				 ["models/props_c17/furnituretable001a.mdl"]=true,
				 ["models/props_c17/furnituretable002a.mdl"]=true,
				 ["models/props_c17/furnituretable003a.mdl"]=true,
				 ["models/props_c17/shelfunit01a.mdl"]=true,
				 ["models/props_interiors/furniture_desk01a.mdl"]=true,
				 ["models/props_interiors/furniture_shelf01a.mdl"]=true,
				 ["models/props_interiors/furniture_vanity01a.mdl"]=true,
				 ["models/props_junk/cardboard_box001a.mdl"]=true,
				 ["models/props_junk/cardboard_box001a_gib01.mdl"]=true,
				 ["models/props_junk/cardboard_box001b.mdl"]=true,
				 ["models/props_junk/cardboard_box002a.mdl"]=true,
				 ["models/props_junk/cardboard_box002a_gib01.mdl"]=true,
				 ["models/props_junk/cardboard_box002b.mdl"]=true,
				 ["models/props_junk/cardboard_box003a.mdl"]=true,
				 ["models/props_junk/cardboard_box003a_gib01.mdl"]=true,
				 ["models/props_junk/cardboard_box003b.mdl"]=true,
				 ["models/props_junk/cardboard_box003b_gib01.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_boardx1.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_boardx2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_boardx4.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_panel1x1.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_panel1x2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_panel2x2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_panel2x4.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_panel4x4.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x1.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x1x1.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x1x2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x1x2b.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x2b.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire1x2x2b.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire2x2.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire2x2b.mdl"]=true,
				 ["models/props_phx/construct/wood/wood_wire2x2x2b.mdl"]=true,
				 ["models/props_junk/wood_pallet001a.mdl"]=true}

				 if damageables[v:GetModel()] then
					ParticleEffectAttach( "h_volcano_impact", PATTACH_POINT_FOLLOW, v, 0 )
					timer.Simple(0.1, function()
						if v:IsValid() then
							v:Remove()
						end
					end)
				 end
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormalized() * self.DEFAULT_PHYSFORCE 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
				 end
				 if (v:IsPlayer()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormalized() * self.DEFAULT_PHYSFORCE_PLYAIR
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormalized() * self.DEFAULT_PHYSFORCE_PLYGROUND	 
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsNPC()) then
					 v:Ignite(1,0)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_dir_vec.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
ENT.Burst                            = 0 
function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,self.MAX_RANGE)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 phys:AddVelocity(Vector(0,0,self.PropForce))
					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 phys:Wake()
						 phys:EnableMotion(true)
						 constraint.RemoveAll(v)
					 end
				 end
				 if (v:IsPlayer() and !v:IsOnGround()) then			
					 v:SetMoveType( MOVETYPE_WALK )
					 v:SetVelocity( Vector(0,0,self.PlyAirForce) )		
					 v:SetGravity(1)
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 v:SetMoveType( MOVETYPE_WALK )
					 v:SetVelocity( Vector(0,0,self.PlyForce))		
					 v:SetGravity(0)
				 end
				 if (v:IsNPC()) then
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= self.Burst) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_nondmg.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")
		 self.SHOCKWAVEDAMAGE = self:GetVar("SHOCKWAVE_DAMAGE")


     end
end

function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
		
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 phys:Wake()
						 phys:EnableMotion(true)
						 constraint.RemoveAll(v)
					 end
				 end
				 if (v:IsPlayer()) then
					
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_fire.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
				 dmg:SetDamage(math.random(1,2))
				 dmg:SetDamageType(DMG_RADIATION)
				 dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if v:IsOnFire() then
					v:Extinguish()
					v:Ignite(14,0)
				 else
					v:Ignite(14,0)
				 end
				 if (phys:IsValid()) && !(v:GetClass()=="hb_fireroar") then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
					 if v:IsOnFire() then
						v:Extinguish()
						v:Ignite(4,0)
					 else
						v:Ignite(4,0)
					 end
				 end
				 
				 if (v:IsPlayer()) and !v:IsOnGround() then
					 if !(self.Ignore==self.HBOWNER) && !(self.Ignoreowner) then
					 v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )
					 if v:IsOnFire() then
						v:Extinguish()
						v:Ignite(4,0)
					 else
						v:Ignite(4,0)
					 end
					 end
					 
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 if !(v==self.Ignore) && !(self.Ignoreowner) then
					 v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:TakeDamageInfo(dmg)
					 v:SetVelocity( F_dir )	
					 if v:IsOnFire() then
						v:Extinguish()
						v:Ignite(4,0)
					 else
						v:Ignite(4,0)
					 end
					 end
				 end
				 if (v:IsNPC()) then
					 v:TakeDamageInfo(dmg)
					 if v:IsOnFire() then
						v:Extinguish()
						v:Ignite(4,0)
					 else
						v:Ignite(4,0)
					 end
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_sound_burst.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""


function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 1500
		 self.HBOWNER = self:GetVar("HBOWNER")

     end
end

function ENT:Think(ply)

			
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = math.random(1,10)
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * math.random(1,10)
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
				 end
				 if (v:IsPlayer()) then
					 if !(table.HasValue(self.FILTER,v:SteamID())) then
						net.Start("hb_net_sound_lowsh")
							net.WriteString("gbombs_5/explosions/nuclear/blast_wave.mp3")
						net.Send(v)
						table.insert(self.FILTER, v:SteamID() )
					 end
				     
					 local mass = phys:GetMass()
					 local F_ang = math.random(1,10)
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * math.random(1,10)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
				   
					 local mass = phys:GetMass()
					 local F_ang = math.random(1,5)
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * math.random(1,5)
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsPlayer()) and v:IsOnGround() then
				   
					 local mass = phys:GetMass()
					 local F_ang = math.random(0,1)
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * math.random(0,1)
					 v:SetVelocity( F_dir )		
				 end

			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/heart_turbolaser_tool/lua/entities/heart_turbolaser/cl_init.lua:
include("shared.lua");
util.PrecacheModel("models/heart/turbolaser_bolt.mdl");
util.PrecacheModel("models/heart/turbolaser_glow.mdl");

function ENT:Initialize()
	self.model = ClientsideModel("models/heart/turbolaser_bolt.mdl");
	self.model:SetModelScale(self:GetScale(), 0);

	self.glow = ClientsideModel("models/heart/turbolaser_glow.mdl");
	self.glow:SetModelScale(self:GetScale(), 0);
	self.glow:SetColor(Color(self:GetColR(),self:GetColG(),self:GetColB()));
end

function ENT:Draw()
end

function ENT:Think()
	if not self:IsValid() then
		self.model:Remove();
		self.glow:Remove();
	end

	self.model:SetPos(self:GetPos());
	self.model:SetAngles(self:GetAngles());

	self.glow:SetPos(self:GetPos());
	self.glow:SetAngles(self:GetAngles());
end

function ENT:OnRemove()
	self.model:Remove();
	self.glow:Remove();
end

language.Add("heart_turbolaser", "Turbolaser");
--addons/egm_lvs_ships/lua/entities/hyena_bomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/egm_lvs_ships/lua/entities/hyena_bomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Bombe"
ENT.Author          = "Deltaa"
ENT.Information     = ""
ENT.Category        = "[LVS] - Separatisten"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--addons/vanilla-tools/lua/entities/hyperspace_highwake/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace_HighWake"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--addons/vanilla-tools/lua/entities/hyperspace_modelship/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace2"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--gamemodes/starwarsrp/entities/entities/jedi_training_droid/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel() -- Draws Model Client Side
end

net.Receive("JediDroid.Use", function()
	local ent = net.ReadEntity()

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle("Durchläufe")
	modal:Slider("Wähle aus, wie oft der Droide schießt!", function(value)
		net.Start("JediDroid.Use")
		net.WriteEntity(ent)
		net.WriteUInt(value, 5)
		net.SendToServer()
	end, function() end, 1, 30, 0, "Starten")
end)
--addons/lvs_turret/lua/entities/joes_turret_base_lfs/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Joes LFS Turret Base"
ENT.Category = "Joe | Turrets"

DEFINE_BASECLASS( "lunasflightschool_basescript" )

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Editable = true

ENT.model = "models/sam_model/base.mdl"

ENT.HideDriver = true
ENT.SeatPos = Vector(00,0,0)
ENT.SeatAng = Angle(0,-90,0)

ENT.MaxHealth = 5000
ENT.MaxShield = 0 --set 0 for no shield
ENT.Range = 60000 --range at which it will see the target
ENT.LoseTargetDistance = ENT.Range + 1000 --range at which it will lose the target
ENT.Clip = 8 --ammount of ammo before reload, set to -1 for inf
ENT.mass = 500
ENT.team = 1 --0 friendly to all, 1 good guys, 2 bad guys, 3 hostile to all

ENT.targetgroundvehicles = true
ENT.targetairvehicles = true
ENT.targethumans = true

ENT.BarrelPos = {
	[1] = Vector(-22,30,4),
	[2] = Vector(-22,21,4),
	[3] = Vector(-22,30,-4),
	[4] = Vector(-22,21,-4),
	[5] = Vector(-22,-21,4),
	[6] = Vector(-22,-30,4),
	[7] = Vector(-22,-21,-4),
	[8] = Vector(-22,-30,-4),
}

function ENT:SetupDataTables()

	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )
	self:NetworkVar( "Entity",2, "Gunner" )
	self:NetworkVar( "Entity",3, "GunnerSeat" )

	self:NetworkVar("Float",27, "Shield" )

	self:NetworkVar("Int",16, "AmmoPrimary" )
	self:NetworkVar("Int",17, "AmmoSecondary" )

	self:NetworkVar( "Float",2, "RPM" )
	self:NetworkVar( "Bool",3, "RotorDestroyed" )
	self:NetworkVar( "Bool",4, "EngineActive" )
	self:NetworkVar( "Bool",7, "lfsLockedStatus" )
	self:NetworkVar( "Bool",5, "Active" )
	self:NetworkVar( "Bool",6, "AI")
	self:NetworkVar( "Float",8, "MaintenanceProgress" )

	self:NetworkVar("Int",0, "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 1,min = 1, max = 3, category = "AI"} } )
	self:NetworkVar("Int",1, "ShootInterval", { KeyName = "shootint", Edit = { type = "Int", order = 1,min = 1, max = 10, category = "Shooting"} } )
	self:NetworkVar("Int",2, "ReloadTime", { KeyName = "reloadtime", Edit = { type = "Int", order = 1,min = 1, max = 20, category = "Shooting"} } )
	self:NetworkVar("Float",0, "HP", { KeyName = "Health", Edit = { type = "Float", order = 0,min = 0, max = self.MaxHealth} } )
	self:NetworkVar("Float",3, "Range", { KeyName = "range", Edit = { type = "Float", order = 5,min = 100, max = 100000} } )
	self:NetworkVar("Float",4, "LoseTargetDistance", { KeyName = "loseTargetDistance" } )
	self:NetworkVar("Bool",11, "TargetAir", { KeyName = "Target Air", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:NetworkVar("Bool",12, "TargetGround", { KeyName = "Target Vehicles", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:NetworkVar("Bool",13, "TargetHumans", { KeyName = "Target humans", Edit = { type = "Boolean", order = 1, category = "Type"} } )

	self:NetworkVar("Bool",1, "AIEnabled", { KeyName = "AIenabled", Edit = { type = "Boolean", order = 1} } )

	if self.team == 0 then
		self:SetAITEAM(3)
	else
		self:SetAITEAM(self.team)
	end
	self:SetShootInterval(2)
	self:SetReloadTime(10)
	self:SetHP(self.MaxHealth)
	self:SetShield(self.MaxShield)
	self:SetRange(self.Range)
	self:SetLoseTargetDistance(self.LoseTargetDistance)
	self:SetAmmoPrimary(self.Clip)
	self:SetAIEnabled(false)
	self:SetTargetAir(self.targetairvehicles)
	self:SetTargetGround(self.targetgroundvehicles)
	self:SetTargetHumans(self.targethumans)

	if SERVER then
		self:NetworkVarNotify( "Range", self.SetRangeStuff )
	end
end

function ENT:SetRangeStuff(name, old, new)
	self:SetLoseTargetDistance(new + 1000)
end
--addons/lvs_turret/lua/entities/joes_turret_base_lvs/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
/*
function ENT:Initialize()
end

function ENT:LFSCalcViewFirstPerson( view, ply )
	local v = {}
	return v
end

function ENT:LFSCalcViewThirdPerson( view, ply )
	local v = {}
	return v
end

function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle )
end

function ENT:LFSHudPaintInfoLine( HitPlane, HitPilot, LFS_TIME_NOTIFY, Dir, Len, FREELOOK )
end

function ENT:LFSHudPaintCrosshair( HitPlane, HitPilot )
end

function ENT:LFSHudPaint( X, Y, data, ply )
end

function ENT:LFSHudPaintPassenger( X, Y, ply )
end

function ENT:Think()
	self:DamageFX()
end

function ENT:DamageFX()
	local HP = self:GetHP()
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
end
*/
--addons/egm_lvs_ships/lua/entities/laat_bactabomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--lua/entities/laat_rocketlauncher/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--lua/entities/ladder_small/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

ENT.Type 			= "anim";
ENT.Base 			= "ladder_base";
ENT.PrintName		= "Ladder (Small)"
ENT.Category		= "Ladders"
ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Model			= Model("models/props_c17/metalladder001.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;
--addons/system_entities/lua/entities/lifesupport/cl_init.lua:
include( "shared.lua" )

surface.CreateFont( "BlahBlah2", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
	shadow = true,
	outline = false
} )

function ENT:Draw()
	self:DrawModel()

	--[[local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90]]--
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		
		plyAng = self:GetAngles()
		ang = Angle(plyAng.x, plyAng.y, plyAng.z)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 26, ang, .08)
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 66, 135, 245, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Lebenserhaltungsmodul", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -70, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			if self:Health() > self.SuppHealth / 2 then
				draw.DrawText( "online", "BlahBlah2", 39, - 295, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			if (self:Health() <= self.SuppHealth / 2 && self:Health() > 0) then
				draw.DrawText( "kritisch", "BlahBlah2", 42, - 295, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
			end

			if self:Health() == 0 then
				draw.DrawText( "offline", "BlahBlah2", 39, - 295, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			end

		cam.End3D2D()
	end
end

--addons/lvs_base/lua/entities/lvs_armor_penetrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.LifeTime = 15

if SERVER then
	local CountTotal = {}

	function ENT:Initialize()
		CountTotal[ self:EntIndex() ] = true

		local Num = table.Count( CountTotal )

		if (Num > 30 and math.random(1,2) == 1) or Num > 60 then
			self:Remove()

			return
		end

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		self.DieTime = CurTime() + self.LifeTime
	end

	function ENT:OnRemove()
		CountTotal[ self:EntIndex() ] = nil
	end

	function ENT:Think()
		self:NextThink( CurTime() + 0.1 )

		if not IsValid( self:GetParent() ) then self:Remove() return end

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	return
end

ENT.GlowMat1 = Material( "particle/particle_ring_wave_8" )
ENT.GlowMat2 = Material( "sprites/light_glow02_add" )
ENT.DecalMat = Material( "particle/particle_noisesphere" )
ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local CountTotal = {}

function ENT:Initialize()
	CountTotal[ self:EntIndex() ] = true

	self.RandomAng = math.random(0,360)
	self.DieTime = CurTime() + self.LifeTime

	local Pos = self:GetPos()
	local Dir = self:GetUp()

	self.emitter = ParticleEmitter( Pos, false )

	self:EmitSound( "lvs/armor_pen_"..math.random(1,3)..".wav", 95 )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.2 + table.Count( CountTotal ) / 50

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], self:GetPos() )

		if particle then
			particle:SetVelocity( self:GetUp() * 60 + VectorRand() * 30 )
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 30 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 0 )
			particle:SetEndSize( 60 )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	CountTotal[ self:EntIndex() ] = nil

	if not IsValid(self.emitter) then return end

	self.emitter:Finish()
end

function ENT:Draw()
	local Timed = 1 - (self.DieTime - CurTime()) / self.LifeTime
	local Scale = math.max(math.min(2 - Timed * 2,1),0)

	local Scale02 = math.max(Scale - 0.8,0) / 0.2

	cam.Start3D2D( self:GetPos() + self:GetAngles():Up(), self:GetAngles(), 1 )
		surface.SetDrawColor( 255 * Scale02, (93 + 50 * Scale) * Scale02, (50 * Scale) * Scale02, (200 * Scale) * Scale02 )

		surface.SetMaterial( self.GlowMat1 )
		surface.DrawTexturedRectRotated( 0, 0, 8 , 8 , self.RandomAng )

		surface.SetMaterial( self.GlowMat2 )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )

		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.SetMaterial( self.DecalMat )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )
	cam.End3D2D()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--addons/lvs_base/lua/entities/lvs_base/cl_effects.lua:

function ENT:StartWindSounds()
	if not LVS.ShowEffects then return end

	self:StopWindSounds()

	if LocalPlayer():lvsGetVehicle() ~= self then return end

	local EntTable = self:GetTable()

	EntTable._WindSFX = CreateSound( self, "LVS.Physics.Wind" )
	EntTable._WindSFX:PlayEx(0,100)

	EntTable._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
	EntTable._WaterSFX:PlayEx(0,100)
end

function ENT:StopWindSounds()
	local EntTable = self:GetTable()

	if EntTable._WindSFX then
		EntTable._WindSFX:Stop()
		EntTable._WindSFX = nil
	end

	if EntTable._WaterSFX then
		EntTable._WaterSFX:Stop()
		EntTable._WaterSFX = nil
	end
end

ENT.DustEffectSurfaces = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
}

ENT.GroundEffectsMultiplier = 1

function ENT:DoVehicleFX()
	local EntTable = self:GetTable()

	if EntTable.GroundEffectsMultiplier <= 0 or not LVS.ShowEffects then self:StopWindSounds() return end

	local Vel = self:GetVelocity():Length() * EntTable.GroundEffectsMultiplier

	if EntTable._WindSFX then EntTable._WindSFX:ChangeVolume( math.Clamp( (Vel - 1200) / 2800,0,1 ), 0.25 ) end

	if Vel < 1500 then
		if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end

		return
	end

	if (EntTable.nextFX or 0) < CurTime() then
		EntTable.nextFX = CurTime() + 0.05

		local LCenter = self:OBBCenter()
		LCenter.z = self:OBBMins().z

		local CenterPos = self:LocalToWorld( LCenter )

		local trace = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
		} )

		local traceWater = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
			mask = MASK_WATER,
		} )

		if EntTable._WaterSFX then EntTable._WaterSFX:ChangePitch( math.Clamp((Vel / 1000) * 50,80,150), 0.5 ) end

		if traceWater.Hit and trace.HitPos.z < traceWater.HitPos.z then 
			local effectdata = EffectData()
				effectdata:SetOrigin( traceWater.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_water", effectdata )

			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 1 - math.Clamp(traceWater.Fraction,0,1), 0.5 ) end
		else
			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end
		end

		if trace.Hit and EntTable.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] then
			local effectdata = EffectData()
				effectdata:SetOrigin( trace.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_dust", effectdata )
		end
	end
end

function ENT:GetParticleEmitter( Pos )
	local EntTable = self:GetTable()

	local T = CurTime()

	if IsValid( EntTable.Emitter ) and (EntTable.EmitterTime or 0) > T then
		return EntTable.Emitter
	end

	self:StopEmitter()

	EntTable.Emitter = ParticleEmitter( Pos, false )
	EntTable.EmitterTime = T + 2

	return EntTable.Emitter
end

function ENT:StopEmitter()
	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end
end
--addons/lvs_base/lua/entities/lvs_base/cl_hud.lua:

LVS:AddHudEditor( "VehicleHealth", 10, ScrH() - 85,  220, 75, 220, 75, "FAHRZEUGLEBEN",
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintVehicleHealth then return end

		vehicle:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "VehicleInfo", ScrW() - 460, ScrH() - 85,  220, 75, 220, 75, "FAHRZEUGINFORMATION",
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintInfoText then return end

		vehicle:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	draw.DrawText( "LEBEN ", "LVS_FONT", X + 102, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( math.Round( self:GetHP(), 0 ), "LVS_FONT_HUD_LARGE", X + 102, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

ENT.VehicleIdentifierRange = 10000

function ENT:LVSHudPaintVehicleIdentifier( X, Y, In_Col )
	local HP = self:GetHP()

	surface.SetDrawColor( In_Col.r, In_Col.g, In_Col.b, In_Col.a )
	LVS:DrawDiamond( X + 1, Y + 1, 20, HP / self:GetMaxHP() )

	if self:GetMaxShield() > 0 and HP > 0 then
		surface.SetDrawColor( 200, 200, 255, In_Col.a )
		LVS:DrawDiamond( X + 1, Y + 1, 24, self:GetShield() / self:GetMaxShield() )
	end
end

function ENT:LVSHudPaint( X, Y, ply )
end

function ENT:HurtMarker( intensity )
	LocalPlayer():EmitSound( "lvs/hit_receive"..math.random(1,2)..".wav", 75, math.random(95,105), 0.25 + intensity * 0.75, CHAN_STATIC )
	util.ScreenShake( Vector(0, 0, 0), 25 * intensity, 25 * intensity, 0.5, 1 )
end

function ENT:KillMarker()
	self.LastKillMarker = CurTime() + 0.5

	LocalPlayer():EmitSound( "lvs/hit_kill.wav", 85, 100, 0.4, CHAN_VOICE )
end

local LastMarker = 0
function ENT:ArmorMarker( IsDamage )
	local T = CurTime()

	local DontHurtEars = math.Clamp( T - LastMarker, 0, 1 ) ^ 2

	LastMarker = T

	local ArmorFailed = IsDamage and "takedamage" or "pen"
	local Volume = IsDamage and (0.3 * DontHurtEars) or 1

	LocalPlayer():EmitSound( "lvs/armor_"..ArmorFailed.."_"..math.random(1,3)..".wav", 85, math.random(95,105), Volume, CHAN_ITEM2 )
end

function ENT:HitMarker()
	self.LastHitMarker = CurTime() + 0.15

	LocalPlayer():EmitSound( "lvs/hit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM )
end

function ENT:CritMarker()
	self.LastCritMarker = CurTime() + 0.15

	LocalPlayer():EmitSound(  "lvs/hit_crit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM2 )
end

function ENT:GetHitMarker()
	return self.LastHitMarker or 0
end

function ENT:GetCritMarker()
	return self.LastCritMarker or 0
end

function ENT:GetKillMarker()
	return self.LastKillMarker or 0
end

function ENT:LVSPaintHitMarker( scr )
	local T = CurTime()

	local aV = math.cos( math.rad( math.max(((self:GetHitMarker() - T) / 0.15) * 360,0) ) )
	if aV ~= 1 then
		local Start = 12 + (1 - aV) * 8
		local dst = 10

		surface.SetDrawColor( 255, 255, 0, 255 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )

		scr.x = scr.x + 1
		scr.y = scr.y + 1

		surface.SetDrawColor( 0, 0, 0, 80 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )
	end

	local aV = math.sin( math.rad( math.max(((self:GetCritMarker() - T) / 0.15) * 180,0) ) )
	if aV > 0.01 then
		local Start = 10 + aV * 40
		local End = 20 + aV * 45

		surface.SetDrawColor( 255, 100, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 3, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 3, 20, 45 )
	end

	local aV = math.sin( math.rad( math.sin( math.rad( math.max(((self:GetKillMarker() - T) / 0.2) * 90,0) ) ) * 90 ) )
	if aV > 0.01 then
		surface.SetDrawColor( 255, 255, 255, 15 * (aV ^ 4) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		local Start = 10 + aV * 40
		local End = 20 + aV * 45
		surface.SetDrawColor( 255, 0, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 5, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 5, 20, 45 )
	end
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x, Pos2D.y, 4, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 5, Col )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 6, Shadow )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x,Pos2D.y, 17, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 18, Col )

	if LVS.AntiAliasingEnabled then
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Color( Col.r, Col.g, Col.b, 150 * Alpha ) )
		surface.DrawCircle( Pos2D.x, Pos2D.y, 20, Shadow )
	else
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Shadow )
	end
end

local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local endang = 360 * value

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			surface.SetDrawColor( data.col )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local X = Pos2D.x + 1
	local Y = Pos2D.y + 1

	local Size = 20

	surface.SetDrawColor( 0, 0, 0, 80 )
	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )

	if Col then
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
	else
		surface.SetDrawColor( 255, 255, 255, 255 )
	end

	X = Pos2D.x
	Y = Pos2D.y

	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )
end
--addons/lvs_base/lua/entities/lvs_base/cl_boneposeparemeter.lua:

function ENT:CreateBonePoseParameter( name, bone, ang_min, ang_max, pos_min, pos_max )
	if not istable( self._BonePoseParameters ) then self._BonePoseParameters = {} end

	self._BonePoseParameters[ name ] = {
		bone = (bone or -1),
		ang_min = ang_min or angle_zero,
		ang_max = ang_max or angle_zero,
		pos_min = pos_min or vector_origin,
		pos_max = pos_max or vector_origin,
	}
end

function ENT:SetBonePoseParameter( name, value )
	if name and string.StartsWith( name, "!" ) then
		name = string.Replace( name, "!", "" )
	end

	local EntTable = self:GetTable()

	if not istable( EntTable._BonePoseParameters ) or not EntTable._BonePoseParameters[ name ] then return end

	local data = EntTable._BonePoseParameters[ name ]

	local ang = LerpAngle( value, data.ang_min, data.ang_max )
	local pos = LerpVector( value, data.pos_min, data.pos_max )

	self:ManipulateBoneAngles( data.bone, ang )
	self:ManipulateBonePosition( data.bone, pos )
end
--addons/lvs_starwars/lua/entities/lvs_base_fakehover/cl_init.lua:
include("shared.lua")
include("sh_camera_eyetrace.lua")
include("cl_camera.lua")
include("cl_hud.lua")
--addons/lvs_starwars/lua/entities/lvs_base_fakehover/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Generic Fake Hover"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 1

ENT.MaxVelocityX = 300
ENT.MaxVelocityY = 300

ENT.MaxTurnRate = 1

ENT.BoostAddVelocityX = 200
ENT.BoostAddVelocityY = 200

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Vector", "AIAimVector" )
	self:AddDT( "Bool", "Disabled" )

	if SERVER then
		self:NetworkVarNotify( "Disabled", self.OnDisabled )
	end
end

function ENT:HitGround()
	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.GroundTraceLength) ),
		mins = Vector( -self.GroundTraceHull, -self.GroundTraceHull, 0 ),
		maxs = Vector( self.GroundTraceHull, self.GroundTraceHull, 0 ),
		filter = self:GetCrosshairFilterEnts()
	}

	local trace = util.TraceHull( data )

	data.mask = MASK_WATER

	local traceWater = util.TraceHull( data )

	return ((trace.Hit or (traceWater.Hit and self.GroundTraceHitWater)) and not trace.HitSky)
end

function ENT:GetThrottle()
	return math.min( self:GetVelocity():Length() / math.abs( self.MaxVelocityX + self.BoostAddVelocityX, self.MaxVelocityY + self.BoostAddVelocityY ), 1 )
end

function ENT:GetMaxThrottle()
	return 1
end

function ENT:GetThrustStrenght()
	return 0
end

function ENT:GetVehicleType()
	return "fakehover"
end
--addons/lvs_starwars/lua/entities/lvs_base_starfighter/cl_camera.lua:

ENT._lvsSmoothFreeLook = 0

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	local ViewPosL = pod:WorldToLocal( pos )

	local view = {}
	view.fov = fov
	view.drawviewer = true
	view.angles = self:GetAngles()

	local FreeLook = ply:lvsKeyDown( "FREELOOK" )
	local Zoom = ply:lvsKeyDown( "ZOOM" )

	if not pod:GetThirdPersonMode() then

		if FreeLook then
			view.angles = pod:LocalToWorldAngles( ply:EyeAngles() )
		end

		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local Dividor = math.abs( velL.x )
		local SideForce = math.Clamp( velL.y / Dividor, -1, 1)
		local UpForce = math.Clamp( velL.z / Dividor, -1, 1)

		local ViewPunch = Vector(0,math.Clamp(SideForce * 10,-1,1),math.Clamp(UpForce * 10,-1,1))
		if Zoom then
			ViewPunch = Vector(0,0,0)
		end

		pod._lerpPosOffset = pod._lerpPosOffset and pod._lerpPosOffset + (ViewPunch - pod._lerpPosOffset) * RealFrameTime() * 5 or Vector(0,0,0)
		pod._lerpPos = pos

		view.origin = pos + pod:GetForward() *  -pod._lerpPosOffset.y * 0.5 + pod:GetUp() *  pod._lerpPosOffset.z * 0.5
		view.angles.p = view.angles.p - pod._lerpPosOffset.z * 0.1
		view.angles.y = view.angles.y + pod._lerpPosOffset.y * 0.1
		view.drawviewer = false

		return view
	end

	pod._lerpPos = pod._lerpPos or self:GetPos()

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	if FreeLook then
		local velL = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

		local SideForce = math.Clamp(velL.y / 10,-250,250)
		local UpForce = math.Clamp(velL.z / 10,-250,250)

		pod._lerpPosL = pod._lerpPosL and (pod._lerpPosL + (Vector(radius, SideForce,150 + radius * 0.1 + radius * pod:GetCameraHeight() + UpForce) - pod._lerpPosL) * RealFrameTime() * 12) or Vector(0,0,0)
		pod._lerpPos = self:LocalToWorld( pod._lerpPosL )

		view.origin = pod._lerpPos
		view.angles = self:LocalToWorldAngles( Angle(0,180,0) )
	else
		local TargetPos = self:LocalToWorld( Vector(500,0,150 + radius * 0.1 + radius * pod:GetCameraHeight()) )

		local Sub = TargetPos - pod._lerpPos
		local Dir = Sub:GetNormalized()
		local Dist = Sub:Length()

		local DesiredPos = TargetPos - self:GetForward() * (300 + radius) - Dir * 100

		pod._lerpPos = pod._lerpPos + (DesiredPos - pod._lerpPos) * RealFrameTime() * (Zoom and 30 or 12)
		pod._lerpPosL = self:WorldToLocal( pod._lerpPos )

		local vel = self:GetVelocity()

		view.origin = pod._lerpPos
		view.angles = self:GetAngles()
	end

	view.origin = view.origin + ViewPosL

	return view
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	local cvarFocus = math.Clamp( LVS.cvarCamFocus:GetFloat() , -1, 1 )

	self._lvsSmoothFreeLook = self._lvsSmoothFreeLook + ((ply:lvsKeyDown( "FREELOOK" ) and 0 or 1) - self._lvsSmoothFreeLook) * RealFrameTime() * 10

	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = (self:GetForward() * (1 + cvarFocus) * self._lvsSmoothFreeLook * 0.8 + ply:EyeAngles():Forward() * math.max(1 - cvarFocus, 1 - self._lvsSmoothFreeLook)):Angle()

	if cvarFocus >= 1 then
		view.angles = LerpAngle( self._lvsSmoothFreeLook, ply:EyeAngles(), self:GetAngles() )
	else
		view.angles.r = 0
	end

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	if ply:lvsMouseAim() then
		return self:CalcViewMouseAim( ply, pos, angles, fov, pod )
	else
		return self:CalcViewDirectInput( ply, pos, angles, fov, pod )
	end
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_45z/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(209, 189, 3, 254)
ENT.EngineColor2 = Color(255, 0, 157)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-53, 9, 12),
	Vector(-53, -9, 12)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 15

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aat/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "AAT"
ENT.Author = "Luna"
ENT.Information = "Trade Federation Hover Tank. Later used in the Droid army of the Separatists"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/aat.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 18000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-260,0,0)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Float", "TurretPitch")
	self:AddDT("Float", "TurretYaw")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles((trace.HitPos - self:LocalToWorld(Vector(10,-60,81))):GetNormalized():Angle())
	local AimAnglesL = self:WorldToLocalAngles((trace.HitPos - self:LocalToWorld(Vector(10,60,81))):GetNormalized():Angle())

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 20 and AimAnglesL.p >= 20) or (AimAnglesR.p <= -30 and AimAnglesL.p <= -30) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 60)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment( "muzzle_left" )
		local ID_R = ent:LookupAttachment( "muzzle_right" )
		local MuzzleL = ent:GetAttachment( ID_L )
		local MuzzleR = ent:GetAttachment( ID_R )

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread = Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force = 100
		bullet.HullSize = 1
		bullet.Damage = 750
		bullet.Velocity = 12000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255,50,50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(Dir)
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			if not IsValid(ent.SNDLeft) then return end
			ent.SNDLeft:PlayOnce()

			return
		end

		if not IsValid(ent.SNDRight) then return end
		ent.SNDRight:PlayOnce()
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnThink = function(ent, active)
		if ent:GetIsCarried() then
			self:SetPoseParameter("cannon_right_pitch", 0 )
			self:SetPoseParameter("cannon_right_yaw", 0 )

			self:SetPoseParameter("cannon_left_pitch", 0 )
			self:SetPoseParameter("cannon_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("cannon_right_pitch", AimAnglesR.p )
		self:SetPoseParameter("cannon_right_yaw", AimAnglesR.y )

		self:SetPoseParameter("cannon_left_pitch", AimAnglesL.p )
		self:SetPoseParameter("cannon_left_yaw", AimAnglesL.y )
	end
	self:AddWeapon(weapon)


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local Driver = ent:GetDriver()

		local MissileAttach = {
			[1] = {
				left = "missile_1l",
				right = "missile_1r"
			},
			[2] = {
				left = "missile_2l",
				right = "missile_2r"
			},
			[3] = {
				left = "missile_3l",
				right = "missile_3r"
			},
		}

		for i = 1, 3 do
			timer.Simple( (i / 5) * 0.75, function()
				if not IsValid(ent) then return end

				if ent:GetAmmo() <= 0 then
					ent:SetHeat(1)
					return
				end

				local ID_L = ent:LookupAttachment(MissileAttach[i].left)
				local ID_R = ent:LookupAttachment(MissileAttach[i].right)
				local MuzzleL = ent:GetAttachment(ID_L)
				local MuzzleR = ent:GetAttachment(ID_R)

				if not MuzzleL or not MuzzleR then return end

				local swap = false

				for i = 1, 2 do
					local Pos = swap and MuzzleL.Pos or MuzzleR.Pos
					local Start = Pos + ent:GetForward() * 50
					local Dir = (ent:GetEyeTrace().HitPos - Start):GetNormalized()
					if not ent:WeaponsInRange() then
						Dir = swap and MuzzleL.Ang:Up() or MuzzleR.Ang:Up()
					end

					local projectile = ents.Create("lvs_missile")
					projectile:SetPos(Start)
					projectile:SetAngles(Dir:Angle())
					projectile:SetParent(ent)
					projectile:Spawn()
					projectile:Activate()
					projectile.GetTarget = function(missile)
						return missile
					end
					projectile.GetTargetPos = function(missile)
						return missile:LocalToWorld(Vector(150,0,0) + VectorRand() * math.random(-10,10))
					end
					projectile:SetAttacker( IsValid( Driver ) and Driver or self )
					projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
					projectile:SetSpeed(4000)
					projectile:SetDamage(900)
					projectile:SetRadius(150)
					projectile:Enable()
					projectile:EmitSound( "LVS.AAT.FIRE_MISSILE" )

					ent:TakeAmmo(1)

					swap = true
				end
			end)
		end

		ent:SetHeat(1)
		ent:SetOverheated(true)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon(weapon)

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/aat/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/aat/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/aat/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add({
	name = "LVS.AAT.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/aat/fire_missile.mp3"
})

sound.Add({
	name = "LVS.AAT.LASER_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {160, 180},
	sound = {
		"lvs/vehicles/aat/turret/impact1.ogg",
		"lvs/vehicles/aat/turret/impact2.ogg",
		"lvs/vehicles/aat/turret/impact3.ogg",
		"lvs/vehicles/aat/turret/impact4.ogg"
	}
})
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_armis/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Armis Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2327.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 500
ENT.MaxVelocityY = 400

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aurum/cl_init.lua:
include("shared.lua")

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_barc/cl_init.lua:
include("shared.lua")

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld(Vector(-90, 0, 40)))
		util.Effect("lfs_blacksmoke", effectdata)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_barc_medic/cl_init.lua:
include("shared.lua")

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld(Vector(-90, 0, 40)))
		util.Effect("lfs_blacksmoke", effectdata)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_cagespeeder/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(190, 0, 0)
ENT.EngineColor2 = Color(255, 185, 185)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-115, 20, 35),
	Vector(-115, -20, 35)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 40

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_isp/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(0, 50, 100, 100)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:OnSpawn()
	self.LeftCanon = ents.CreateClientProp("prop_dynamic")
	self.LeftCanon:SetModel("models/necro/isp_speeder/isp_speeder_cannons.mdl")
	self.LeftCanon:SetPos(self:GetPos() + self:GetRight() * -30 + self:GetForward() * 66 + self:GetUp() * 18)
	self.LeftCanon:SetAngles(self:GetAngles() + Angle(7,-11,0))
	self.LeftCanon:SetParent(self)
	self.LeftCanon:Spawn()

	self.RightCanon = ents.CreateClientProp("prop_dynamic")
	self.RightCanon:SetModel("models/necro/isp_speeder/isp_speeder_cannons.mdl")
	self.RightCanon:SetPos(self:GetPos() + self:GetRight() * 30 + self:GetForward() * 66 + self:GetUp() * 18)
	self.RightCanon:SetAngles(self:GetAngles() + Angle(7,-11,0))
	self.RightCanon:SetParent(self)
	self.RightCanon:Spawn()

	self.RCR = true
	self.LCR = true
end

function ENT:OnFrame()
	self:AnimGunner()
end

function ENT:AnimGunner()
	local Pod = self:GetGunnerSeat()
	if not IsValid(Pod) then return end

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	if not IsValid(self.LeftCanon) then return end

	local EyeAngles = self:WorldToLocalAngles(weapon:GetAimVector():Angle())

	local Yaw = math.Clamp(EyeAngles.y, -60, 60)
	self.LeftCanon:SetAngles(self:LocalToWorldAngles(Angle(0, Yaw, 0)))
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	render.SetMaterial(self.EngineGlow)

	local Size = 200
	for i = 0, 3 do
		render.DrawSprite(self:LocalToWorld(Vector(-103, 0, 51)), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(Vector(-110, 0, 51)), Size, Size, self.EngineColor)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin(self:LocalToWorld(Vector(-90,0,40)))
		util.Effect("lfs_blacksmoke", effectdata)
	end
end

function ENT:OnRemove()
	if IsValid(self.LeftCanon) then
		self.LeftCanon:Remove()
	end

	if IsValid(self.RightCanon) then
		self.RightCanon:Remove()
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_tx130/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-130"
ENT.Author = "Deltaa"
ENT.Information = "Hover Tank of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/tkaro/starwars/vehicle/tx130/tx130.mdl"
ENT.GibModels = {
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_charge_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_flap_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_hatch_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_main_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_2.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_model_turret_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_2.mdl",
}

ENT.MaxHealth = 18000
ENT.MaxShield = 4500

ENT.AITEAM = 2

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 3

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 150

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "BTLFire" )
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Bool", "WeaponOutOfRange")
	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Int", "DoorMode")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles((trace.HitPos - self:LocalToWorld(Vector(-60,-51,43))):GetNormalized():Angle())
	local AimAnglesL = self:WorldToLocalAngles((trace.HitPos - self:LocalToWorld(Vector(-60,51,43))):GetNormalized():Angle())

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not (AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30
end

function ENT:InitWeapons()
	-- Primary laser gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment("muzzle_left")
		local ID_R = ent:LookupAttachment("muzzle_right")
		local MuzzleL = ent:GetAttachment(ID_L)
		local MuzzleR = ent:GetAttachment(ID_R)

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir = (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread = Vector(0.01,  0.01, 0)
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force = 100
		bullet.HullSize = 1
		bullet.Damage = 900
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,50,255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(50,50,255))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(Dir)
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
			return
		end

		ent.SNDRight:PlayOnce(100 + math.sin( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnThink = function(ent, active)
		if ent:GetIsCarried() then
			self:SetPoseParameter("sidegun_left_yaw", 0)
			self:SetPoseParameter("sidegun_right_yaw", 0)

			self:SetPoseParameter("sidegun_pitch", 0)
			self:SetPoseParameter("sidegun_left_yaw", 0)

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("sidegun_left_yaw", AimAnglesR.p)
		self:SetPoseParameter("sidegun_right_yaw", AimAnglesR.y)

		self:SetPoseParameter("sidegun_pitch", AimAnglesL.p)
		self:SetPoseParameter("sidegun_left_yaw", AimAnglesL.y)
	end
	weapon.HudPaint = function(ent, X, Y, ply)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if ent:GetIsCarried() then return end

		local ID_L = ent:LookupAttachment("muzzle_left")
		local ID_R = ent:LookupAttachment("muzzle_right")
		local MuzzleL = ent:GetAttachment(ID_L)
		local MuzzleR = ent:GetAttachment(ID_R)

		if not MuzzleL or not MuzzleR then return end

		local dirR = MuzzleR.Ang:Up()
		local posR = MuzzleR.Pos

		local traceR = util.TraceLine({
			start = posR,
			endpos = posR + dirR * 50000,
		})

		local Pos2DR = traceR.HitPos:ToScreen()

		base:PaintCrosshairCenter(Pos2DR, color_white)
		base:LVSPaintHitMarker(Pos2DR)

		local dirL = MuzzleL.Ang:Up()
		local posL = MuzzleL.Pos

		local traceL = util.TraceLine({
			start = posL,
			endpos = posL + dirL * 50000,
		})

		local Pos2DL = traceL.HitPos:ToScreen()

		base:PaintCrosshairCenter(Pos2DL, color_white)
		base:LVSPaintHitMarker(Pos2DL)
	end
	self:AddWeapon(weapon)

	-- Adds the rocket gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end
		if self:GetDoorMode() == 0 then return end

		local ID1 = self:LookupAttachment("left_launch_tube_1")
		local ID2 = self:LookupAttachment("right_launch_tube_1")
		local ID3 = self:LookupAttachment("left_launch_tube_2")
		local ID4 = self:LookupAttachment("right_launch_tube_2")
		local ID5 = self:LookupAttachment("left_launch_tube_3")
		local ID6 = self:LookupAttachment("right_launch_tube_3")
		local ID7 = self:LookupAttachment("left_launch_tube_4")
		local ID8 = self:LookupAttachment("right_launch_tube_4")
		local ID9 = self:LookupAttachment("left_launch_tube_5")
		local ID10 = self:LookupAttachment("right_launch_tube_5")

		local Muzzle1 = self:GetAttachment(ID1)
		local Muzzle2 = self:GetAttachment(ID2)
		local Muzzle3 = self:GetAttachment(ID3)
		local Muzzle4 = self:GetAttachment(ID4)
		local Muzzle5 = self:GetAttachment(ID5)
		local Muzzle6 = self:GetAttachment(ID6)
		local Muzzle7 = self:GetAttachment(ID7)
		local Muzzle8 = self:GetAttachment(ID8)
		local Muzzle9 = self:GetAttachment(ID9)
		local Muzzle10 = self:GetAttachment(ID10)

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2,
			[3] = Muzzle3,
			[4] = Muzzle4,
			[5] = Muzzle5,
			[6] = Muzzle6,
			[7] = Muzzle7,
			[8] = Muzzle8,
			[9] = Muzzle9,
			[10] = Muzzle10,
		}

		if not FirePos then return end

		self.FireIndex2 = self.FireIndex2 and self.FireIndex2 + 1 or 1

		self:EmitSound("lvs/vehicles/tx130/rocket.wav")

		if self.FireIndex2 > 10 then
			self.FireIndex2 = 1
		elseif self.FireIndex2 == 10 then
			ent:SetHeat(1)
			ent:SetOverheated(true)
		end

		local Pos = FirePos[self.FireIndex2].Pos
		local Dir =  FirePos[self.FireIndex2].Ang:Up()

		local projectile = ents.Create("lvs_missile")
		projectile:SetPos(Pos)
		projectile:SetAngles(Dir:Angle())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile.GetTarget = function(missile) return missile end
		projectile.GetTargetPos = function(missile)
			return missile:LocalToWorld(Vector(150, 0, 0) + VectorRand() * math.random(-5, 5))
		end
		projectile:SetAttacker(self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(4000)
		projectile:SetDamage(1350)
		projectile:SetRadius(150)
		projectile:Enable()

		ent:TakeAmmo()
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	weapon.HudPaint = function(ent, X, Y, ply)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if ent:GetIsCarried() then return end

		if self:GetDoorMode() == 0 then return end

		local ID_L = ent:LookupAttachment("left_launch_tube_1")
		local ID_R = ent:LookupAttachment("right_launch_tube_1")
		local MuzzleL = ent:GetAttachment(ID_L)
		local MuzzleR = ent:GetAttachment(ID_R)

		if not MuzzleL or not MuzzleR then return end

		local dirR = MuzzleR.Ang:Up()
		local posR = MuzzleR.Pos

		local traceR = util.TraceLine({
			start = posR,
			endpos = posR + dirR * 50000,
		})

		local Pos2DR = traceR.HitPos:ToScreen()

		base:PaintCrosshairCenter(Pos2DR, color_white)
		base:LVSPaintHitMarker(Pos2DR)

		local dirL = MuzzleL.Ang:Up()
		local posL = MuzzleL.Pos

		local traceL = util.TraceLine({
			start = posL,
			endpos = posL + dirL * 50000,
		})

		local Pos2DL = traceL.HitPos:ToScreen()

		base:PaintCrosshairCenter(Pos2DL, color_white)
		base:LVSPaintHitMarker(Pos2DL)
	end
	self:AddWeapon(weapon)

	-- Activates / Deactivates the spotlight
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/light.png")
	weapon.Delay = 1
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if self.NextLight and self.NextLight >= CurTime() then return end
		self.NextLight = CurTime() + 1

		self:SetBodygroup(9, self:GetBodygroup(9) ~= 1 and 1 or 0)
	end
	self:AddWeapon(weapon)

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/tx130/engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}

function ENT:CalcMainActivity(ply)
	local Pod = ply:GetVehicle()
	if Pod == self:GetGunnerSeat() then
		if ply.m_bWasNoclipping then
			ply.m_bWasNoclipping = nil
			ply:AnimResetGestureSlot(GESTURE_SLOT_CUSTOM)

			if CLIENT then
				ply:SetIK(true)
			end
		end

		ply.CalcIdeal = ACT_STAND
		ply.CalcSeqOverride = ply:LookupSequence("idle_all_02")

		if ply:GetAllowWeaponsInVehicle() and IsValid(ply:GetActiveWeapon()) then
			local holdtype = ply:GetActiveWeapon():GetHoldType()
			if holdtype == "smg" then
				holdtype = "smg1"
			end

			local seqid = ply:LookupSequence("idle_" .. holdtype)

			if seqid ~= -1 then
				ply.CalcSeqOverride = seqid
			end
		end

		return ply.CalcIdeal, ply.CalcSeqOverride
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_x34_gun/shared.lua:
ENT.Base = "lvs_fakehover_x34"

ENT.PrintName = "X-34 (Gun)"
ENT.Author = "Deltaa"
ENT.Information = "The X-34 landspeeder was a model of civilian landspeeder manufactured by SoroSuub Corporation and available during the Galactic Civil War between the Galactic Empire and the Alliance to Restore the Republic."
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/niksacokica/x-34/x-34.mdl"

ENT.MaxHealth = 1500

ENT.AITEAM = 0

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local bullet = {}
		bullet.Src = ent:LocalToWorld(Vector(Vector(92, -15, 33)))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 150
		bullet.HullSize = 10
		bullet.Damage = 150
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end
--addons/lvs_starwars/lua/entities/lvs_protontorpedo.lua:
AddCSLuaFile()

ENT.Base = "lvs_missile"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n z�pfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_proton_explosion"
ENT.GlowColor = Color( 0, 127, 255, 255 )

if SERVER then
	function ENT:GetDamage() return
		self._dmg or 6000
	end

	function ENT:GetRadius()
		return self._radius or 200
	end

	return
end

ENT.GlowMat = Material("sprites/light_glow02_add")

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
	effectdata:SetOrigin(self:GetPos())
	effectdata:SetEntity(self)
	util.Effect("lvs_proton_trail", effectdata)
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_droidship/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineLaser =  Material("sprites/physbeam")
ENT.EngineColor1 = Color(255, 0, 0)
ENT.EngineColor2 = Color(255, 180, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-175, 515, -67), 5, 25, 2, 100, 150)
	self:RegisterTrail(Vector(-175, -515, -67), 5, 25, 2, 100, 150)
end

function ENT:PostDrawTranslucent()
	local EnginePos = {
		self:GetPos() + self:GetForward() * -640 + self:GetUp() * 39 + self:GetRight() * 70,
		self:GetPos() + self:GetForward() * -635 + self:GetUp() * 39 + self:GetRight() * 80,
		self:GetPos() + self:GetForward() * -634 + self:GetUp() * 39 + self:GetRight() * 90,
		self:GetPos() + self:GetForward() * -630 + self:GetUp() * 39 + self:GetRight() * 100,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * 110,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * 120,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * 130,
		self:GetPos() + self:GetForward() * -622 + self:GetUp() * 39 + self:GetRight() * 140,
		self:GetPos() + self:GetForward() * -620 + self:GetUp() * 39 + self:GetRight() * 150,
		self:GetPos() + self:GetForward() * -615 + self:GetUp() * 39 + self:GetRight() * 160,
		self:GetPos() + self:GetForward() * -610 + self:GetUp() * 39 + self:GetRight() * 170,
		self:GetPos() + self:GetForward() * -605 + self:GetUp() * 39 + self:GetRight() * 180,
		self:GetPos() + self:GetForward() * -602 + self:GetUp() * 39 + self:GetRight() * 190,
		self:GetPos() + self:GetForward() * -597 + self:GetUp() * 39 + self:GetRight() * 200,
		self:GetPos() + self:GetForward() * -592 + self:GetUp() * 39 + self:GetRight() * 210,
		self:GetPos() + self:GetForward() * -587 + self:GetUp() * 39 + self:GetRight() * 220,
		self:GetPos() + self:GetForward() * -581 + self:GetUp() * 39 + self:GetRight() * 230,
		self:GetPos() + self:GetForward() * -575 + self:GetUp() * 39 + self:GetRight() * 240,
		self:GetPos() + self:GetForward() * -568 + self:GetUp() * 39 + self:GetRight() * 250,
		self:GetPos() + self:GetForward() * -560 + self:GetUp() * 39 + self:GetRight() * 260,
		self:GetPos() + self:GetForward() * -550 + self:GetUp() * 39 + self:GetRight() * 270,
		self:GetPos() + self:GetForward() * -540 + self:GetUp() * 39 + self:GetRight() * 280,
		self:GetPos() + self:GetForward() * -530 + self:GetUp() * 39 + self:GetRight() * 290,

		self:GetPos() + self:GetForward() * -640 + self:GetUp() * 39 + self:GetRight() * -70,
		self:GetPos() + self:GetForward() * -635 + self:GetUp() * 39 + self:GetRight() * -80,
		self:GetPos() + self:GetForward() * -634 + self:GetUp() * 39 + self:GetRight() * -90,
		self:GetPos() + self:GetForward() * -630 + self:GetUp() * 39 + self:GetRight() * -100,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * -110,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * -120,
		self:GetPos() + self:GetForward() * -628 + self:GetUp() * 39 + self:GetRight() * -130,
		self:GetPos() + self:GetForward() * -622 + self:GetUp() * 39 + self:GetRight() * -140,
		self:GetPos() + self:GetForward() * -620 + self:GetUp() * 39 + self:GetRight() * -150,
		self:GetPos() + self:GetForward() * -615 + self:GetUp() * 39 + self:GetRight() * -160,
		self:GetPos() + self:GetForward() * -610 + self:GetUp() * 39 + self:GetRight() * -170,
		self:GetPos() + self:GetForward() * -605 + self:GetUp() * 39 + self:GetRight() * -180,
		self:GetPos() + self:GetForward() * -602 + self:GetUp() * 39 + self:GetRight() * -190,
		self:GetPos() + self:GetForward() * -597 + self:GetUp() * 39 + self:GetRight() * -200,
		self:GetPos() + self:GetForward() * -592 + self:GetUp() * 39 + self:GetRight() * -210,
		self:GetPos() + self:GetForward() * -587 + self:GetUp() * 39 + self:GetRight() * -220,
		self:GetPos() + self:GetForward() * -581 + self:GetUp() * 39 + self:GetRight() * -230,
		self:GetPos() + self:GetForward() * -575 + self:GetUp() * 39 + self:GetRight() * -240,
		self:GetPos() + self:GetForward() * -568 + self:GetUp() * 39 + self:GetRight() * -250,
		self:GetPos() + self:GetForward() * -560 + self:GetUp() * 39 + self:GetRight() * -260,
		self:GetPos() + self:GetForward() * -550 + self:GetUp() * 39 + self:GetRight() * -270,
		self:GetPos() + self:GetForward() * -540 + self:GetUp() * 39 + self:GetRight() * -280,
		self:GetPos() + self:GetForward() * -530 + self:GetUp() * 39 + self:GetRight() * -290,
	}

	if not self:GetEngineActive() then return end

	local Size = 100  + self:GetThrottle() * 60 + self:GetBoost() * 1.2

	for _, pos in ipairs(EnginePos) do
		render.SetMaterial(self.EngineGlow)
		render.DrawSprite(pos, Size, Size, self.EngineColor2)
	end

	local posr = self:GetPos() + self:GetForward() * 453 + self:GetUp() * -41 + self:GetRight() * 25
	local posl = self:GetPos() + self:GetForward() * 455 + self:GetUp() * -43 + -self:GetRight() * 25

	render.SetMaterial(self.EngineLaser)
	render.DrawBeam(posr, posr + self:GetUp() * 22.5 + self:GetRight() * 41 + self:GetForward() * -24, 70, 10, 10, self.EngineColor1)
	render.DrawBeam(posl, posl + self:GetUp() * 24.5 + -self:GetRight() * 43 + self:GetForward() * -24, 70, 10, 10, self.EngineColor1)
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship/sh_gunnerweapons.lua:
function ENT:SetNextRearGunFire(delay)
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:CanFireRearGun(ent)
	return ent:AngleBetweenNormal(ent:GetAimVector(), -ent:GetForward()) < 35
end

function ENT:CanFireWingTurret(ent)
	local Pod = self:GetGunnerSeat()

	local Driver = Pod:GetDriver()
	if not IsValid(Driver) then return end

	local EyeAngles = Pod:WorldToLocalAngles(Driver:EyeAngles())
	local AimAngYaw = math.abs(EyeAngles.y)

	return AimAngYaw < 90
end

function ENT:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	local base = ent:GetVehicle()

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not IsValid( base ) then return view end

	local radius = 800
	radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * 250
	local EndPos = StartPos - clamped_angles:Forward() * radius

	local WallOffset = 4

	local tr = util.TraceHull({
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector(-WallOffset, -WallOffset, -WallOffset),
		maxs = Vector(WallOffset, WallOffset, WallOffset),
	})

	view.drawviewer = true
	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:InitGunnerWeapons()
	-- Rear Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function(ent)
		if not self:CanFireRearGun(ent) then return end

		local trace = ent:GetEyeTrace()
		local Muzzle = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

		local bullet = {}
		bullet.Src = Muzzle
		bullet.Dir = (trace.HitPos - Muzzle):GetNormalized()
		bullet.Spread = Vector(0.03,  0.03, 0.03)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 10
		bullet.HullSize = 25
		bullet.Damage = 195
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		self.SNDTail:PlayOnce(100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnThink = function(ent, active)
		if not self:CanFireRearGun(ent) then
			self:SetPoseParameter("back_turret_z", 0)
			self:SetPoseParameter("back_turret_y", 0)
			return
		end

		local trace = ent:GetEyeTrace()
		local _, Ang = WorldToLocal(Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5))):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles(Angle(0,180,0)))

		self:SetPoseParameter("back_turret_z", Ang.p)
		self:SetPoseParameter("back_turret_y", -Ang.y)
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.StartAttack = function(ent)
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function(ent)
		ent.ShouldFire = false

		local snd = {
			[-1] = self.WingLeftSND,
			[1] = self.WingRightSND,
		}

		for _, sound in pairs(snd) do
			if not IsValid(sound) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function(ent, active)
		local snd = {
			[-1] = self.WingLeftSND,
			[1] = self.WingRightSND
		}

		local shouldFire = self:CanFireWingTurret(ent) and ent.ShouldFire
		if not shouldFire then
			self:SetWingTurretFire(false)

			for _, sound in pairs(snd) do
				if not IsValid(sound) then continue end
				sound:Stop()
			end

			ent:SetHeat(ent:GetHeat() - FrameTime())

			return
		end

		if not active then return end

		self:SetWingTurretFire(shouldFire)

		local trace = ent:GetEyeTrace()
		local endPos = trace.HitPos

		self:SetWingTurretTarget(endPos)

		local startPos = Vector(-55, 350, 90)
		if self:WorldToLocal(endPos).z > 0 then
			startPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()
		for i = -1, 1, 2 do
			local StartPos = self:LocalToWorld(startPos * Vector(1, i, 1))
			local beam = util.TraceLine({start = StartPos, endpos = endPos})

			self:BallturretDamage(beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized())

			if not IsValid(snd[i]) then continue end

			if beam.Entity ~= self then
				snd[i]:Play()

				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat(NewHeat)
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_nuclass/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "Nu-class Attack Shuttle"
ENT.Author = "Deltaa"
ENT.Information = "Attack/Transport Shuttle of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/swbf3/vehicles/nu_attackship.mdl"

ENT.MaxHealth = 18000
ENT.MaxShield = 7500

ENT.AITEAM = 2

ENT.MaxVelocity = 1000
ENT.MaxThrust = 1000

ENT.MaxPitch = 60

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Door")
	self:AddDT("Bool", "Wings")

	if SERVER then
		self:NetworkVarNotify("Wings", self.OnWingsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(470, 125, 153),
			Vector(470, 125, 177)
		},

		{
			Vector(470, -125, 153),
			Vector(470, -125, 177)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.15
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]
		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force = 250
			bullet.HullSize = 1
			bullet.Damage = 750
			bullet.Velocity = 40000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(0, 0, 255))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)

			ent:TakeAmmo()
		end

		if ent.NumPrim == 1 then
			ent.FrontSNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.FrontSNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self.SecFirePositions = {
		{
			Vector(235, 223, 140),
			Vector(210, 223, 122)
		},

		{
			Vector(235, -223, 140),
			Vector(210, -223, 122)
		}
	}

	-- Secondary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]
		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force = 100
			bullet.HullSize = 1
			bullet.Damage = 300
			bullet.Velocity = 40000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(0, 0, 255))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)

			ent:TakeAmmo()
		end

		if ent.NumPrim == 1 then
			ent.BackSNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.BackSNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/nuclass.png")
	weapon.Delay = 5
	weapon.Ammo = -1
	weapon.HeatRateUp = -1
	weapon.StartAttack = function(ent)
		local base = ent:GetVehicle()

		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 3

		base:SetDoor(not base:GetDoor())

		if base:GetDoor() then
			base:EmitSound("lfs/laat/door_open.wav")
		else
			base:EmitSound("lfs/laat/door_close.wav")
		end
	end
	self:AddWeapon(weapon)
end

ENT.FlyByAdvance = 0
ENT.FlyBySound = "lvs/vehicles/nuclass/hum.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/nuclass/hum.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_transporter/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "Troop Transporter"
ENT.Author = "Ophra & Deltaa"
ENT.Information = "Troop Transporter"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_rep_troop_transport_flight.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 12000
ENT.MaxShield = 6000

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(305, 50, -53),
			Vector(305, 50, -61)
		},

		{
			Vector(305, -50, -53),
			Vector(305, -50, -61)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src 	= ent:LocalToWorld(pos)
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.025,  0.025, 0)
			bullet.TracerName = "lvs_laser_red"
			bullet.Force = 100
			bullet.HullSize = 10
			bullet.Damage = 300
			bullet.Velocity = 50000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart(Vector(255, 50, 0))
				effectdata:SetOrigin(tr.HitPos)
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)
		end

		if ent.NumPrim == 1 then
			ent.SNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1, 1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1, 1), 1)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/transporter/engine.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_alligator/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Alligator Fighter"
ENT.Author = "Deltaa"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/alligator/rep_alligator_servius.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2750
ENT.MaxThrust = 2750

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.2
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 15000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(65, 155, 35),
		Vector(65, -155, 35)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 40000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end

		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255,50,50))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_ebonhawk/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 150, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-200, 400, 85), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-200, -400, 85), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-200, 400, 110), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-200, -400, 110), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-550, 120, 123), 0, 20, 2, 700, 150)
	self:RegisterTrail(Vector(-550, -120, 123), 0, 20, 2, 700, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	-- Draws the effect
	local Size = 300 + self:GetThrottle() * 60 + self:GetBoost() * 0.8
	render.SetMaterial(self.EngineGlow)

	for i = -1, 1, 2 do
		local pos = self:LocalToWorld(Vector(-560, 105 * i, 123))
		render.DrawSprite( pos, Size, Size, self.EngineColor)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = ParticleEmitter(self:GetPos(), false)
	if not IsValid(emitter) then return end

	for i = -1, 1, 2 do
		local vOffset = self:LocalToWorld(Vector(-570, -105 * i, 123))
		local vNormal = -self:GetForward()

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then return end

		particle:SetVelocity(vNormal * math.Rand(500, 2500) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(75, 100))
		particle:SetEndSize(math.Rand(15, 5))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 150, 0)
	end

	emitter:Finish()
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_interceptor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Interceptor Fighter"
ENT.Author = "Ophra & Deltaa"
ENT.Information = "Interceptor Fighter"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/ophra/ships/veh_neu_zak_fighter.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.5
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1.5

ENT.ForceLinearMultiplier = 1.5

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 12000
ENT.MaxShield = 4500

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(215, 19, -2),
		Vector(215, -19, -2),
	}

	-- Primary gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.025, 0.025, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 30
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 32
	weapon.Delay = 3 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		if (ent._nextMissle or 0) > T then return end
		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(220, ent._swapMissile and -80 or 80, -5)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0)))
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid(Driver) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

end


ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/interceptor/engine.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_missileboat/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(0, 140, 180)
ENT.EngineColor2 = Color(0, 100, 180)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-240, 52, 0),
	Vector(-240, -52, -44)
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-95, 250, -75), 4, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-95, -250, -75), 4, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(pos)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15, 25))
		particle:SetEndSize(math.Rand(5, 15))
		particle:SetRoll(math.Rand(-1, 1) * 100)
		particle:SetColor(0, 140, 180)
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25
	local Size2 = 75
	local Size3 = 125
	local Size4 = 100
	local Size5 = 150
	local Size6 = 200

	render.SetMaterial(Material( "sprites/light_glow02_add"))
	render.DrawSprite(self:LocalToWorld(Vector(-240,0,-33)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-246,0,-33)), Size2, Size2, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-252,0,-33)), Size3, Size3, self.EngineColor)

	render.DrawSprite(self:LocalToWorld(Vector(-240,16.5,-51.5)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-246,16.5,-51.5)), Size2, Size2, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-252,16.5,-51.5)), Size3, Size3, self.EngineColor)

	render.DrawSprite(self:LocalToWorld(Vector(-240,-16.5,-51.5)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-246,-16.5,-51.5)), Size2, Size2, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-252,-16.5,-51.5)), Size3, Size3, self.EngineColor)

	for i = 0, 2 do
		render.DrawSprite( self:LocalToWorld( Vector(-240,52.5,-44)), Size4, Size, self.EngineColor2)
		render.DrawSprite( self:LocalToWorld( Vector(-248,52.5,-44)), Size5, Size2, self.EngineColor2)
		render.DrawSprite( self:LocalToWorld( Vector(-256,52.5,-44)), Size6, Size3, self.EngineColor2)

		render.DrawSprite( self:LocalToWorld( Vector(-240,-52.5,-44)), Size4, Size, self.EngineColor2)
		render.DrawSprite( self:LocalToWorld( Vector(-248,-52.5,-44)), Size5, Size2, self.EngineColor2)
		render.DrawSprite( self:LocalToWorld( Vector(-256,-52.5,-44)), Size6, Size3, self.EngineColor2)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("ophra/ships/powerstart3.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("ophra/ships/shutdown.wav", 85)
end


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_missileboat/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Missile Boat"
ENT.Author = "Deltaa"
ENT.Information = "An advanced star fighter"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/niksacokica/missile_boat/missile_boat.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2250
ENT.MaxThrust = 2250

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.9
ENT.TurnRateYaw = 0.9
ENT.TurnRateRoll = 0.9

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 0.9
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 7500
ENT.MaxShield = 4500

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(151, 272, -42),
		Vector(151, -272, -42),
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src = ent:LocalToWorld(Vector(166, 0, -60))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 30
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("ophra/ships/weaponswitch.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Rockets
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 100
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local FirePos = {
			[1] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 35 + self:GetRight() * 120,
			[2] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 35 + self:GetRight() * -120,
			[3] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 22 + self:GetRight() * 135,
			[4] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 22 + self:GetRight() * -135,
			[5] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 22 + self:GetRight() * 105,
			[6] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 22 + self:GetRight() * -105,
			[7] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 9 + self:GetRight() * 120,
			[8] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 9 + self:GetRight() * -120,
			[9] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 9 + self:GetRight() * 90,
			[10] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * 9 + self:GetRight() * -90,
			[11] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * -4 + self:GetRight() * 105,
			[12] = self:GetPos() + self:GetForward() * 35 + self:GetUp() * -4 + self:GetRight() * -105
		}

		self.FireIndex = self.FireIndex and self.FireIndex + 1 or 1

		if self.FireIndex > 12 then
			self.FireIndex = 1
		elseif self.FireIndex == 12 then
			ent:SetHeat(1)
			ent:SetOverheated(true)
		end

		self:EmitSound("lvs/vehicles/missileboat/missile_launch.wav")

		local Pos = FirePos[self.FireIndex]

		local projectile = ents.Create("lvs_missile")
		projectile:SetPos(Pos)
		projectile:SetAngles(self:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile.GetTarget = function(missile)
			return missile
		end
		projectile.GetTargetPos = function(missile)
			return missile:LocalToWorld(Vector(150, 0, 0) + VectorRand() * math.random(-5, 5))
		end
		projectile:SetAttacker(self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(8000)
		projectile:SetDamage(1000)
		projectile:SetRadius(150)
		projectile:Enable()

		ent:TakeAmmo()
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/missileboat/engine_loop.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_nantex/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Nantex-class"
ENT.Author = "Deltaa"
ENT.Information = "Geonosian Starfighter"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/geon/geon1.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.4
ENT.TurnRateYaw = 1.4
ENT.TurnRateRoll = 1.4

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.4
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-230, 0, 15)
ENT.LAATC_PICKUP_Angle = Angle(0, 90, 0)

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(50, 110, 120),

	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = Vector(97, 0, 54.5)

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 900
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/vulturedroid/boost.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "^lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_scimitar/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Scimitar Fighter"
ENT.Author = "Deltaa"
ENT.Information = "The Scimitar, also known as the Sith Infiltrator, was a heavily modified Star Courier and the personal starship of Darth Maul."
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ranz/maul_scimitar.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.2
ENT.TurnRateYaw = 1.2
ENT.TurnRateRoll = 1.2

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.2
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 9000
ENT.MaxShield = 4500

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(10, 162, 103),
			Vector(10, 162, 81)
		},

		{
			Vector(10, -162, 103),
			Vector(10, -162, 81)
		}

	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector( 0.02,  0.02, 0 )
			bullet.TracerName = "lvs_laser_red"
			bullet.Force = 100
			bullet.HullSize = 40
			bullet.Damage = 300
			bullet.Velocity = 60000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetStart(Vector(255,50,50))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				util.Effect("lvs_laser_impact", effectdata)
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect("lvs_muzzle_colorable", effectdata)

			ent:TakeAmmo()

			if ent.NumPrim == 1 then
				ent.SNDPrimaryLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
			else
				ent.SNDPrimaryRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
			end
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Torpedo Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 3
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(10, ent._swapMissile and -162 or 162, 81)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/scimitar/missile.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat( NewHeat )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/scimitar/brake.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/scimitar/dist.wav",
		sound_int = "^lvs/vehicles/scimitar/engine.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle_armed/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Transport Shuttle HVC"
ENT.Author = "Miller"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lt_c/sci_fi/shuttle/shuttle_static.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2200
ENT.MaxThrust = 2200

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 7500
ENT.MaxShield = 4500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )


	if SERVER then
		self:NetworkVarNotify("Foils", self.OnFoilsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(98, 30, 25),
		Vector(98, -30, 25)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 600
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )


		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lfs/eng_jedistarfighter_hi_lp.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lfs/eng_jedistarfighter_hi_lp.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle_jedi/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Jedi Transport Shuttle HVC"
ENT.Author = "Miller"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lt_c/sci_fi/shuttle/shuttle_static.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 2200
ENT.MaxThrust = 2200

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 7500
ENT.MaxShield = 4500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )


	if SERVER then
		self:NetworkVarNotify("Foils", self.OnFoilsChanged)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(98, 30, 25),
		Vector(98, -30, 25)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 600
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )


		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lfs/eng_jedistarfighter_hi_lp.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lfs/eng_jedistarfighter_hi_lp.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_spiral/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 49, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-80,160,0), 0, 20, 2, 500, 150)
	self:RegisterTrail(Vector(-80,-160,0), 0, 20, 2, 500, 150)
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()

	render.SetMaterial(self.EngineGlow)

	render.DrawSprite(self:LocalToWorld(Vector(-150,71,57) ), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-150,-74,57) ), Size, Size, self.EngineColor)
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end
	self.nextEFX = T + 0.01

	local emitter = ParticleEmitter(self:GetPos(), false)
	local Pos = {
		Vector(-150,71,57),
		Vector(-150,-74,57),
	}

	if emitter then
		for _, pos in pairs(Pos) do
			local vOffset = self:LocalToWorld(pos)
			local vNormal = -self:GetForward()

			vOffset = vOffset + vNormal * 5

			local particle = emitter:Add("effects/muzzleflash2", vOffset)
			if not particle then return end

			particle:SetVelocity(vNormal * math.Rand(500,1000) + self:GetVelocity())
			particle:SetLifeTime(0)
			particle:SetDieTime(0.1)
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(15, 25))
			particle:SetEndSize(math.Rand(0, 10))
			particle:SetRoll(math.Rand(-1, 1) * 100)
			particle:SetColor(255, 50, 200)

			Mirror = true
		end

		emitter:Finish()
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 125 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_vwing/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 190, 160, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-100,0, 10),
	Vector(-100,0, -22),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(40, 75, 5), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(40, -75, 5), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:AnimAstromech()
	self:AnimWings()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimAstromech()
	if self.nextAstro and self.nextAstro < CurTime() then
		self.nextAstro = CurTime() + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end

		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 1, Angle(self.smastro,0,0) )
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetWings() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)

	local Rate = RFT * 0.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/arc170/sfoils.wav")
		end
	end

	local Ang = (1 - self._sm_wing) * 90

	self:ManipulateBoneAngles(2, Angle(0, Ang, 0))
	self:ManipulateBoneAngles(3, Angle(0, Ang, 0))
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_ywing/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "BTL-B Y-Wing"
ENT.Author = "Deltaa"
ENT.Information = "The Delta-7b Jedi starfighter was used by the Jedi Order before and during the Clone Wars."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/ywing_costum/ywing_btlb_test.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 2000
ENT.MaxThrust = 2000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 18000
ENT.MaxShield = 6000

util.PrecacheModel("models/ywing_costum/ywing_btlb_test.mdl")
util.PrecacheModel("models/ywing_costum/ywing_btlb_turret.mdl")
util.PrecacheModel("models/ywing_costum/ywing_btlb_guns.mdl")

function ENT:OnSetupDataTables()
	self:AddDT("Entity", "TailGunnerSeat")
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(445, 20, 40),
		Vector(445, -20, 40)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.015, 0.015, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 20
		bullet.Damage = 450
		bullet.Attacker = ent:GetDriver() 
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 20
	weapon.Delay = 3
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(445, ent._swapMissile and -20 or 20, 40)

		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:LocalToWorldAngles(Angle(0, ent._swapMissile and 2 or -2,0)))
		projectile:SetParent(ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid(Driver) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1)
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.25
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end

		ent:SetHeat(NewHeat)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)


	 -- Bombs
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 50
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.05
	weapon.Attack = function(ent)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local bomb = ents.Create("ywing_bomb")
		bomb:SetPos(self:LocalToWorld(Vector(50, 40, -160)))
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Gunner Gun
	self.GunFirePositions = {
		Vector(220, 30, 100),
		Vector(220, -30, 100)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local veh = ent:GetVehicle()

		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #veh.GunFirePositions then ent.NumPrim = 1 end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetUp()) < 40 then return true end
		if ent:AngleBetweenNormal(dir, ent:GetUp()) > 90 then return true end

		local CurPos = veh.GunFirePositions[ent.NumPrim]
		CurPos:Normalize()

		local trace = ent:GetEyeTrace()

		local driver = ent:GetDriver()
		if not IsValid(driver) then return end

		local EyeAngle = driver:LocalEyeAngles()
		local forward = EyeAngle:Forward()
		local pos = CurPos + Vector(CurPos, CurPos.y + (forward.y * 100), CurPos.z)

		local bullet = {}
		bullet.Num = 2
		bullet.Src = ent:LocalToWorld(pos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.005, 0.005, 0)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 20
		bullet.Damage = 825
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50, 255, 50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal )
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)

		veh.SNDCanon:PlayOnce(100 + math.cos( CurTime() + veh:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon, 2)
end

ENT.FlyByAdvance = 0
ENT.FlyBySound = ""
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/y-wing/ywing_dist.wav",
		sound_int = "lvs/vehicles/y-wing/ywing_eng.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/lvs_base/lua/entities/lvs_turret.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_wire_entity" )

ENT.PrintName		= "Projectile Turret"
ENT.WireDebugName = "Projectile Turret"

ENT.Author		= "Blu-x92"
ENT.Information		= "Projectile Turret"
ENT.Category		= "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.Editable = true

ENT.TracerOptions = {
	["LaserBlue"] = "lvs_laser_blue",
	["LaserRed"] = "lvs_laser_red",
	["LaserGreen"] = "lvs_laser_green",
	["TracerGreen"] = "lvs_tracer_green",
	["TracerOrange"] = "lvs_tracer_orange",
	["TracerWhite"] = "lvs_tracer_white",
	["TracerYellow"] = "lvs_tracer_yellow",
	["AutoCannon"] = "lvs_tracer_autocannon",
	["Cannon"] = "lvs_tracer_cannon",
}

ENT.SplashTypeOptions = {
	Shrapnel = "lvs_bullet_impact",
	Explosive = "lvs_bullet_impact_explosive"
}

function ENT:SetupDataTables()
	local TracerOptions = {}

	for id, name in pairs( self.TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end

		TracerOptions[ id ] = name
	end

	self:NetworkVar( "Float",1, "ShootDelay", { KeyName = "Shoot Delay", Edit = { type = "Float", order = 1,min = 0, max = 2, category = "Options"} } )
	self:NetworkVar( "Float",2, "Damage", { KeyName = "Damage", Edit = { type = "Float", order = 2,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",3, "Speed", { KeyName = "Speed", Edit = { type = "Float", order = 3,min = 10000, max = 100000, category = "Options"} } )
	self:NetworkVar( "Float",4, "Size", { KeyName = "Size", Edit = { type = "Float", order = 4,min = 0, max = 50, category = "Options"} } )
	self:NetworkVar( "Float",5, "Spread", { KeyName = "Spread", Edit = { type = "Float", order = 5,min = 0, max = 1, category = "Options"} } )
	self:NetworkVar( "Float",6, "Penetration", { KeyName = "Armor Penetration (mm)", Edit = { type = "Float", order = 6,min = 0, max = 500, category = "Options"} } )
	self:NetworkVar( "Float",7, "SplashDamage", { KeyName = "Splash Damage", Edit = { type = "Float", order = 7,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",8, "SplashDamageRadius", { KeyName = "Splash Damage Radius", Edit = { type = "Float", order = 8,min = 0, max = 750, category = "Options"} } )

	self:NetworkVar( "String", 1, "SplashDamageType", { KeyName = "Splash Damage Type", Edit = { type = "Combo",	order = 9,values = self.SplashTypeOptions,category = "Options"} } )

	self:NetworkVar( "String", 2, "Tracer", { KeyName = "Tracer", Edit = { type = "Combo",	order = 10,values = TracerOptions,category = "Options"} } )

	if SERVER then
		self:SetShootDelay( 0.05 )
		self:SetSpeed( 30000 )
		self:SetDamage( 15 )
		self:SetTracer( "lvs_tracer_orange" )
		self:SetSplashDamageType( "lvs_bullet_impact" )
	end
end

if CLIENT then
	function ENT:GetCrosshairFilterEnts()
		if not istable( self.CrosshairFilterEnts ) then
			self.CrosshairFilterEnts = {self}

			-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
			net.Start( "lvs_player_request_filter" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self.CrosshairFilterEnts
	end

	return
end

function ENT:GetCrosshairFilterEnts()
	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {}

		for _, Entity in pairs( constraint.GetAllConstrainedEntities( self ) ) do
			if not IsValid( Entity ) then continue end

			table.insert( self.CrosshairFilterEnts , Entity )
		end

		for _, Parent in pairs( self.CrosshairFilterEnts ) do
			for _, Child in pairs( Parent:GetChildren() ) do
				if not IsValid( Child ) then continue end

				table.insert( self.CrosshairFilterEnts , Child )
			end
		end
	end

	return self.CrosshairFilterEnts
end

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local ent = ents.Create( ClassName )
	ent.Attacker = ply
	ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:TriggerInput( name, value )
	if name == "Fire" then
		self.TriggerFire = value >= 1
	end
end

function ENT:Initialize()	
	self:SetModel( "models/props_junk/PopCan01a.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )
	self:SetCollisionGroup( COLLISION_GROUP_WEAPON  ) 
	
	self:PhysWake()
	
	self.Inputs = WireLib.CreateInputs( self,{"Fire"} )
end

function ENT:SetNextShoot( time )
	self.NextShoot = time
end

function ENT:CanShoot()
	if not self.TriggerFire then return false end
	
	self.NextShoot = self.NextShoot or 0
	
	return self.NextShoot < CurTime()
end

local IsCannon = {
	["lvs_tracer_autocannon"] = 0.25,
	["lvs_tracer_cannon"] = 1,
}

function ENT:Shoot()
	if not self:CanShoot() then return end

	local Tracer = self:GetTracer()

	local bullet = {}
	bullet.Src 	= self:GetPos()
	bullet.Dir 	= self:GetUp()
	bullet.Spread 	= Vector(self:GetSpread(),self:GetSpread(),self:GetSpread())
	bullet.TracerName = Tracer
	bullet.Force	= self:GetPenetration() * 100
	bullet.HullSize 	= self:GetSize()
	bullet.Damage	= self:GetDamage()
	bullet.Velocity = self:GetVelocity():Length() + self:GetSpeed()

	if IsCannon[ Tracer ] then
		self:SetShootDelay( math.max( self:GetShootDelay(), IsCannon[ Tracer ] ) )
	end

	local SplashDamage = self:GetSplashDamage()
	local SplashDamageRadius = self:GetSplashDamageRadius()

	if SplashDamage ~= 0 and SplashDamageRadius ~= 0 then
		bullet.SplashDamage = SplashDamage
		bullet.SplashDamageRadius = SplashDamageRadius

		local SplashEffect = self:GetSplashDamageType()
		local BlastDamage = SplashEffect == "lvs_bullet_impact_explosive"

		bullet.SplashDamageEffect = SplashEffect
		bullet.SplashDamageType = BlastDamage and DMG_BLAST or DMG_SONIC

		if BlastDamage then
			self:SetShootDelay( math.max( self:GetShootDelay(), 0.5 ) )
		end
	end

	bullet.Attacker = IsValid( self.Attacker ) and self.Attacker or self

	bullet.Entity = self
	bullet.SrcEntity = vector_origin

	LVS:FireBullet( bullet )

	self:SetNextShoot( CurTime() + self:GetShootDelay() )
end

function ENT:Think()	

	self.BaseClass.Think( self )
	
	self:Shoot()

	self:NextThink( CurTime() )
	
	return true
end
--addons/lvs_base/lua/entities/lvs_vehicle_spammer.lua:

AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "AI Vehicle Spammer"
ENT.Author = "Luna"
ENT.Information = "AI Vehicle Spawner. Spammer in the hands of a Minge."
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Editable = true

function ENT:SetupDataTables()
	local AllSents = scripted_ents.GetList() 
	local SpawnOptions = {}

	for _, v in pairs( AllSents ) do
		if not v or not istable( v.t ) or not v.t.Spawnable then continue end

		if v.t.Base and v.t.Base:lower() == "lvs_base_wheeldrive" and not v.t.lvsShowInSpawner then continue end

		if v.t.lvsShowInSpawner == false then continue end

		if v.t.lvsShowInSpawner or (v.t.Base and (string.StartWith( v.t.Base:lower(), "lvs_base" ) or string.StartWith( v.t.Base:lower(), "lunasflightschool" ))) then
			if v.t.Category and v.t.PrintName then
				local nicename = v.t.Category.." - "..v.t.PrintName
				if not table.HasValue( SpawnOptions, nicename ) then
					SpawnOptions[nicename] = v.t.ClassName
				end
			end
		end
	end

	self:NetworkVar( "String",0, "Type",	{ KeyName = "Vehicle Type",Edit = { type = "Combo",	order = 1,values = SpawnOptions,category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",3, "TeamOverride", { KeyName = "AI Team", Edit = { type = "Int", order = 4,min = -1, max = 3, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",4, "RespawnTime", { KeyName = "spawntime", Edit = { type = "Int", order = 5,min = 1, max = 120, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",5, "Amount", { KeyName = "amount", Edit = { type = "Int", order = 6,min = 1, max = 10, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",6, "SpawnWithSkin", { KeyName = "spawnwithskin", Edit = { type = "Int", order = 8,min = 0, max = 16, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",7, "SpawnWithHealth", { KeyName = "spawnwithhealth", Edit = { type = "Int", order = 9,min = 0, max = 50000, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",8, "SpawnWithShield", { KeyName = "spawnwithshield", Edit = { type = "Int", order = 10,min = 0, max = 50000, category = "Vehicle-Options"} } )

	self:NetworkVar( "Int",10, "SelfDestructAfterAmount", { KeyName = "selfdestructafteramount", Edit = { type = "Int", order = 22,min = 0, max = 100, category = "Spawner-Options"} } )
	self:NetworkVar( "Bool",2, "MasterSwitch" )

	if SERVER then
		self:NetworkVarNotify( "Type", self.OnTypeChanged )

		self:SetRespawnTime( 2 )
		self:SetAmount( 1 )
		self:SetSelfDestructAfterAmount( 0 )
		self:SetSpawnWithHealth( 0 )
		self:SetSpawnWithShield( 0 )
		self:SetTeamOverride( -1 )
	end
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 1 )
		ent:Spawn()
		ent:Activate()

		return ent

	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/hunter/plates/plate8x8.mdl" )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self.NextSpawn = 0
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		if not IsValid( self.Defusor ) then
			self.Defusor = ply
			self.DefuseTime = CurTime()
		end
	end
	
	function ENT:Think()
		if IsValid( self.Defusor ) and isnumber( self.DefuseTime ) then
			if self.Defusor:KeyDown( IN_USE ) then
				if CurTime() - self.DefuseTime > 1 then
					self:SetMasterSwitch( not self:GetMasterSwitch() )

					for k, v in pairs( ents.FindByClass( "lvs_vehicle_spammer" ) ) do
						if v ~= self and IsValid( v ) then
							v:SetMasterSwitch( self:GetMasterSwitch() )
						end
					end

					if self:GetMasterSwitch() then
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Enabled")
					else
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Disabled")
					end

					self.Defusor = nil
				end
			else
				self:SetMasterSwitch( not self:GetMasterSwitch() )

				if self:GetMasterSwitch() then
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Enabled")
				else
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Disabled")
				end

				self.Defusor = nil
			end
		end

		if not self:GetMasterSwitch() then return end

		self.spawnedvehicles = self.spawnedvehicles or {}

		if self.ShouldSpawn then
			if self.NextSpawn < CurTime() then
				
				self.ShouldSpawn = false
				
				local pos = self:LocalToWorld( Vector( 0, 0, 150 ) )
				local ang = self:LocalToWorldAngles( Angle( 0, 90, 0 ) )
				
				local Type = self:GetType()
				
				if Type ~= "" then
					local spawnedvehicle = ents.Create( Type )
					
					if IsValid( spawnedvehicle ) then
						if spawnedvehicle.SpawnNormalOffsetSpawner then
							spawnedvehicle:SetPos( self:LocalToWorld( Vector(0,0,spawnedvehicle.SpawnNormalOffsetSpawner) ) )
						else
							spawnedvehicle:SetPos( pos + Vector(0,0,spawnedvehicle.SpawnNormalOffset or 0) )
						end
						spawnedvehicle:SetAngles( ang )
						spawnedvehicle:Spawn()
						spawnedvehicle:Activate()
						spawnedvehicle:SetAI( true )
						spawnedvehicle:SetSkin( self:GetSpawnWithSkin() )
						spawnedvehicle.SpawnedByAISpawner = true

						if self:GetTeamOverride() >= 0 then
							spawnedvehicle:SetAITEAM( self:GetTeamOverride() )
						end

						if self:GetSpawnWithHealth() > 0 then
							spawnedvehicle.MaxHealth = self:GetSpawnWithHealth()
							spawnedvehicle:SetHP( self:GetSpawnWithHealth() )
						end
	
						if self:GetSpawnWithShield() > 0 then
							spawnedvehicle.MaxShield = self:GetSpawnWithShield()
							spawnedvehicle:SetShield( self:GetSpawnWithShield() )
						end

						if spawnedvehicle.LFS and not spawnedvehicle.DontPushMePlease then
							local PhysObj = spawnedvehicle:GetPhysicsObject()
							
							if IsValid( PhysObj ) then
								PhysObj:SetVelocityInstantaneous( -self:GetRight() * 1000 )
							end
						end

						table.insert( self.spawnedvehicles, spawnedvehicle )

						if self:GetSelfDestructAfterAmount() > 0 then
							self.RemoverCount = isnumber( self.RemoverCount ) and self.RemoverCount + 1 or 1

							if self.RemoverCount >= self:GetSelfDestructAfterAmount() then
								self:Remove()
							end
						end
					end
				end
			end
		else
			local AmountSpawned = 0
			for k,v in pairs( self.spawnedvehicles ) do
				if IsValid( v ) then
					AmountSpawned = AmountSpawned + 1
				else
					self.spawnedvehicles[k] = nil
				end
			end

			if AmountSpawned < self:GetAmount() then
				self.ShouldSpawn = true
				self.NextSpawn = CurTime() + self:GetRespawnTime()
			end
		end

		self:NextThink( CurTime() )

		return true
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local TutorialDone = false
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local ArrowMat = Material( "lvs/3d2dmats/arrow.png" )

	function ENT:Draw()
		local ply = LocalPlayer()

		if not IsValid( ply ) then return end

		if TutorialDone then
			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		else
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				if weapon_name == "gmod_camera" then return end

				local Trace = ply:GetEyeTrace()
				if Trace.Entity ~= self or (ply:GetShootPos() - Trace.HitPos):Length() > 800 then return end
			end
		end

		local Pos = self:GetPos()
		local R = 190
		render.SetMaterial( mat )
		render.DrawBox( Pos, self:GetAngles(), Vector(-R,-R,0), Vector(R,R,200), color_white )

		for i = 0, 180, 180 do
			cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(i,0,0) ), 0.185 )
				if self:GetMasterSwitch() then
					local T4 = CurTime() * 4

					local OY = math.cos( T4 )
					local A = math.max( math.sin( T4 ), 0 )
		
					surface.SetMaterial( ArrowMat )

					if self:GetType() == "" then
						surface.SetDrawColor( 255, 0, 0, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 255, 0, 0, math.abs( math.cos( T4 ) ) ^ 2 * 255  )
					else
						surface.SetDrawColor( 0, 127, 255, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 0, 127, 255, 255 )
					end
				else
					surface.SetDrawColor( 255, 0, 0, 255 )
		
					surface.SetMaterial( ArrowMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -1024, -1024, 2048, 2048 )
			cam.End3D2D()
		end
	end

	hook.Add( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial", function()
		if TutorialDone then
			hook.Remove( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial" )
		end

		local ply = LocalPlayer()

		if ply:InVehicle() then return end

		local trace = ply:GetEyeTrace()
		local Dist = (ply:GetShootPos() - trace.HitPos):Length()

		if Dist > 800 then return end

		local Ent = trace.Entity

		if not IsValid( Ent ) then return end

		if Ent:GetClass() ~= "lvs_vehicle_spammer" then return end

		local pos = Ent:GetPos()
		local scr = pos:ToScreen()
		local Alpha = 255

		if Ent:GetType() == "" then
			draw.SimpleText( "Hold C => Right Click on me => Edit Properties => Choose a Type", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			if not Ent:GetMasterSwitch() then
				local Key = input.LookupBinding( "+use" )
				if not isstring( Key ) then Key = "+use is not bound to a key" end

				draw.SimpleText( "Now press ["..Key.."] to enable!", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				draw.SimpleText( "or hold ["..Key.."] to enable globally!", "LVS_FONT", scr.x, scr.y + 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				TutorialDone = true
			end
		end
	end )
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atrt/shared.lua:
ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "AT-RT"
ENT.Author = "Deltaa"
ENT.Information = "The All Terrain Recon Transport (AT-RT) was a one-man bipedal walker used for reconnaissance and patrolling"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/KingPommes/starwars/atrt/main.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 15000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 0
ENT.HoverTraceLength = 90
ENT.HoverHullRadius = 75

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = false
ENT.LAATC_DROP_IN_AIR = false
ENT.LAATC_PICKUP_POS = Vector(-260, 0, 0)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true
}

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")
	self:AddDT("Bool", "NWGround")
	self:AddDT("Bool", "Disabled")

	if SERVER then
		self:NetworkVarNotify("Disabled", self.OnDisabled)
	end
end

function ENT:HitGround()
	return self:GetNWGround()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid(Driver) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld(Vector(0, 0, 74))
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.3
	weapon.Attack = function(ent)
		local veh = ent:GetVehicle()
		if not IsValid(veh) then return end

		local Attachment = self:GetAttachment(self:LookupAttachment("turret"))
		if not Attachment then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward()) > 60 then return true end
		if ent:AngleBetweenNormal(dir, ent:GetUp()) > 120 then return true end

		local EyeAngle = dir:Angle()
		local forward = EyeAngle:Forward()
		local direction = forward:GetNormalized()

		local CurPos = Vector(68, 0, 69)

		local bullet = {}
		bullet.Src = veh:LocalToWorld(CurPos)
		bullet.Dir = Vector(direction.x, direction.y, direction.z)
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		self.Turret:ResetSequence(self.Turret:LookupSequence("Shoot"))
		self.Turret:SetPlaybackRate(1)
		self:EmitSound("LVS.AT-RT.Shoot")
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

sound.Add({
	name = "LVS.AT-RT.Shoot",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {160, 180},
	sound = {
		"kingpommes/starwars/atrt/shoot1.wav",
		"kingpommes/starwars/atrt/shoot2.wav"
	}
})

sound.Add( {
	name = "atrt.step1",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step1.wav"
} )

sound.Add( {
	name = "atrt.step2",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step2.wav"
} )
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then
		for _, tab in pairs(self.IK_Joints) do
			for _,prop in pairs( tab ) do
				if IsValid(prop) then
					prop:Remove()
				end
			end
		end

		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts(index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS)
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[index] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[index] then
		self.IK_Joints[index] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()

		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/egm_lvs_ground/lua/entities/lvs_walker_atte_rear.lua:
AddCSLuaFile()

ENT.Base = "lvs_walker_atte_component"

if SERVER then
	function ENT:Initialize()
		self:SetModel("models/kingpommes/starwars/atte/lfs_rear.mdl")
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:AddFlags( FL_OBJECT )
	end

	function ENT:Think()
		self:NextThink( CurTime() )
		return true
	end

	return
end

include("entities/lvs_walker_atte/cl_ikfunctions.lua")

function ENT:OnRemove()
	self:OnRemoved()
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius )
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--addons/egm_tfa_mines/lua/entities/mine_training/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mines | Incendiary        --
---------------------------------------

ENT.Base = "mine_base"

ENT.PrintName = "Trainingsmine"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Skin = 4

ENT.Spawnable = true
--addons/mortar/lua/entities/mortar_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--lua/entities/parctrl_dummyent.lua:
//This is a dummy entity used by serverside projectile effects. It doesn't do anything special except be a SENT (we can't use PhysicsInitBox on prop_physics, apparently),
//call its own particle effects (since the projectile effect entity can't do that serverside), and not get duplicated!

AddCSLuaFile()

ENT.Base 			= "base_gmodentity"
ENT.PrintName			= "Particle Controller Dummy Entity"
ENT.Author			= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

if CLIENT then
	language.Add("parctrl_dummyent", "Physics Object")  //for killfeed notices
end




function ENT:SetupDataTables()

	self:NetworkVar( "String", 0, "EffectName" );
	self:NetworkVar( "Vector", 0, "UtilEffectInfo" );
	self:NetworkVar( "Vector", 1, "ColorInfo" );
	self:NetworkVar( "Int", 0, "AttachNum" );

end




//Since we're creating these entities serverside, we can't create the particle effects in the projectile-firing function, so do them here instead:
function ENT:Think()

	if SERVER then return end
	if self.ParticleEffectCalled then return end

	local effectname = self:GetEffectName()
	local utileffectinfo = self:GetUtilEffectInfo()
	local colorinfo = self:GetColorInfo()
	local attachnum = self:GetAttachNum()

	if effectname != nil and effectname != "" and colorinfo != nil and utileffectinfo != nil and attachnum != nil then

		local projfxent = self   //terminology's a bit weird here since it's mostly all copy-pasted from the projectile tool, but it's not really worth the trouble changing it all

		if string.StartWith( effectname, "!UTILEFFECT!" ) then

			//Create a util effect

			//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly

			local effectscale = utileffectinfo.x
			local effectmagnitude = utileffectinfo.y
			local effectradius = utileffectinfo.z

			local projeffectdata = EffectData()
			projeffectdata:SetEntity( projfxent )
			//if ( string.find(effectname, "Tracer", 0, true) != nil ) then projeffectdata:SetScale(5000) else projeffectdata:SetScale( effectscale ) end  //for tracer effects, scale is the speed of the bullet, so we need to keep this high; useless for a projectile effect
			projeffectdata:SetScale( effectscale )
			projeffectdata:SetMagnitude( effectmagnitude )
			projeffectdata:SetRadius(effectradius )

			//flags can be set by typing !FLAG#! at the end of the effect name
			projeffectdata:SetFlags( 0 )
			if string.EndsWith( effectname, "!" ) then
				if string.find( effectname, "!FLAG1!" ) then projeffectdata:SetFlags( 1 ) effectname = string.Replace( effectname, "!FLAG1!", "" ) end
				if string.find( effectname, "!FLAG2!" ) then projeffectdata:SetFlags( 2 ) effectname = string.Replace( effectname, "!FLAG2!", "" ) end
				if string.find( effectname, "!FLAG3!" ) then projeffectdata:SetFlags( 3 ) effectname = string.Replace( effectname, "!FLAG3!", "" ) end
				if string.find( effectname, "!FLAG4!" ) then projeffectdata:SetFlags( 4 ) effectname = string.Replace( effectname, "!FLAG4!", "" ) end
				if string.find( effectname, "!FLAG5!" ) then projeffectdata:SetFlags( 5 ) effectname = string.Replace( effectname, "!FLAG5!", "" ) end
				if string.find( effectname, "!FLAG6!" ) then projeffectdata:SetFlags( 6 ) effectname = string.Replace( effectname, "!FLAG6!", "" ) end
				if string.find( effectname, "!FLAG7!" ) then projeffectdata:SetFlags( 7 ) effectname = string.Replace( effectname, "!FLAG7!", "" ) end
				if string.find( effectname, "!FLAG8!" ) then projeffectdata:SetFlags( 8 ) effectname = string.Replace( effectname, "!FLAG8!", "" ) end
				if string.find( effectname, "!FLAG9!" ) then projeffectdata:SetFlags( 9 ) effectname = string.Replace( effectname, "!FLAG9!", "" ) end
			end

			//colors can also be set the same way
			projeffectdata:SetColor(0)
			if string.EndsWith( effectname, "!" ) then
				if string.find( effectname, "!COLOR1!" ) then projeffectdata:SetColor( 1 ) effectname = string.Replace( effectname, "!COLOR1!", "" ) end
				if string.find( effectname, "!COLOR2!" ) then projeffectdata:SetColor( 2 ) effectname = string.Replace( effectname, "!COLOR2!", "" ) end
				if string.find( effectname, "!COLOR3!" ) then projeffectdata:SetColor( 3 ) effectname = string.Replace( effectname, "!COLOR3!", "" ) end
				if string.find( effectname, "!COLOR4!" ) then projeffectdata:SetColor( 4 ) effectname = string.Replace( effectname, "!COLOR4!", "" ) end
				if string.find( effectname, "!COLOR5!" ) then projeffectdata:SetColor( 5 ) effectname = string.Replace( effectname, "!COLOR5!", "" ) end
				if string.find( effectname, "!COLOR6!" ) then projeffectdata:SetColor( 6 ) effectname = string.Replace( effectname, "!COLOR6!", "" ) end
				if string.find( effectname, "!COLOR7!" ) then projeffectdata:SetColor( 7 ) effectname = string.Replace( effectname, "!COLOR7!", "" ) end
				if string.find( effectname, "!COLOR8!" ) then projeffectdata:SetColor( 8 ) effectname = string.Replace( effectname, "!COLOR8!", "" ) end
				if string.find( effectname, "!COLOR9!" ) then projeffectdata:SetColor( 9 ) effectname = string.Replace( effectname, "!COLOR9!", "" ) end
			end
	
			//dumb situational crap
			if string.find( string.lower(effectname), "shakeropes" ) then projeffectdata:SetMagnitude( effectmagnitude * 20 ) end
			if string.find( string.lower(effectname), "thumperdust" ) then projeffectdata:SetScale( effectscale * 50 ) end
			if string.find( string.lower(effectname), "bloodspray" ) then projeffectdata:SetScale( effectscale * 4 ) end

			//just in case someone makes a utileffect that works as a projectile effect
			if projfxent:GetAttachment(attachnum) != nil then
				projeffectdata:SetStart( projfxent:GetAttachment( attachnum ).Pos )
				projeffectdata:SetOrigin( projfxent:GetAttachment( attachnum ).Pos )
				projeffectdata:SetAngles( projfxent:GetAttachment( attachnum ).Ang )
				projeffectdata:SetNormal( projfxent:GetAttachment( attachnum ).Ang:Forward() )
			else
				projeffectdata:SetStart( projfxent:GetPos() )
				projeffectdata:SetOrigin( projfxent:GetPos() )
				projeffectdata:SetAngles( projfxent:GetAngles() )
				projeffectdata:SetNormal( projfxent:GetAngles():Forward() )
			end

			util.Effect( string.Replace( effectname, "!UTILEFFECT!", "" ), projeffectdata )

		else

			//Create a particlesystem effect
	
			//Since we can't specify attachment points with Entity:CreateParticleEffect(), create an entity there to use as a target
			local attachment1 = self:GetAttachment( attachnum )
			if attachment1 != nil then
				//if SERVER then
				//	projfxent = ents.Create("parctrl_dummyent")
				//	projfxent:SetModel("models/hunter/plates/plate.mdl")
				//end
				if CLIENT then
					projfxent = ClientsideModel("models/hunter/plates/plate.mdl")
				end

				projfxent:SetParent(self, attachnum - 1)
				projfxent:SetPos( attachment1.Pos )
				projfxent:SetAngles( attachment1.Ang )
				projfxent:SetNoDraw(true)

				projfxent:Spawn()
				projfxent:Activate()

				self:CallOnRemove("RemoveProjFX", function() if IsValid(projfxent) then projfxent:Remove() end end)
			end


			local clrtb = nil
			if colorinfo == Vector(0,0,0) then
				//MsgN("color = false")
			else
				//MsgN("color = true")
				clrtb = { position = colorinfo }
			end
			local cpointtable = {}
				cpointtable[1] = { entity = projfxent, attachtype = PATTACH_ABSORIGIN_FOLLOW }

				for i = 2, 64 do					
 					if clrtb then
						cpointtable[i] = clrtb
					else
						cpointtable[i] = cpointtable[1]
					end
				end

			projfxent:CreateParticleEffect(effectname,cpointtable)

		end

	self.ParticleEffectCalled = true

	end

end




//don't duplicate this
duplicator.RegisterEntityClass( "parctrl_dummyent", function( ply, data )
end, "Data" )
--lua/entities/particlecontroller_tracer.lua:
AddCSLuaFile()

ENT.Base 			= "base_gmodentity"
ENT.PrintName			= "Particle Controller - Tracer"
ENT.Author			= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false
ENT.RenderGroup			= RENDERGROUP_NONE




function ENT:SetupDataTables()

	self:NetworkVar( "Entity", 0, "TargetEnt" );

	self:NetworkVar( "String", 0, "EffectName" );
	self:NetworkVar( "String", 1, "NumpadState" );
	self:NetworkVar( "String", 2, "Impact_EffectName" );

	self:NetworkVar( "Float", 0, "RepeatRate" );
	self:NetworkVar( "Float", 1, "TracerSpread" );
	self:NetworkVar( "Float", 2, "EffectLifetime" );

	self:NetworkVar( "Int", 0, "AttachNum" );
	self:NetworkVar( "Int", 1, "NumpadKey" );
	self:NetworkVar( "Int", 2, "TracerCount" );

	self:NetworkVar( "Bool", 0, "Active" );
	self:NetworkVar( "Bool", 1, "Toggle" );
	self:NetworkVar( "Bool", 2, "LeaveBulletHoles" );

	//we have 3 pieces of information we need for util.effect, and they're not going to be changed after the ent's been spawned, so there's no reason we can't save space by storing them all in this vector
	//self:NetworkVar( "Vector", 0, "UtilEffectInfo" );  //x = scale, y = magnitude, x = radius
	self:NetworkVar( "Vector", 0, "Impact_UtilEffectInfo" );  //x = scale, y = magnitude, x = radius
	self:NetworkVar( "Vector", 1, "Impact_ColorInfo" );

end




function ENT:Initialize()

	local target = self:GetTargetEnt()


	if SERVER then

		//Use ourselves as the target for control point 1 - because of how we have tracer effects set up, we're going to do this for both util and .pcf effects
		local attachment1 = target:GetAttachment( self:GetAttachNum() )
		if attachment1 != nil then 
			self:SetPos( attachment1.Pos )
			self:SetAngles( attachment1.Ang )
			self:Fire("setparentattachment", target:GetAttachments()[self:GetAttachNum()].name, 0.01)
			self:SetTargetEnt(self)
		end

	else

		//Set things up for a particlesystem effect

		if !string.StartWith( self:GetEffectName(), "!UTILEFFECT!" ) then

			//Make a table of control point information, so we only have to do this once instead of every time AttachParticle runs.

			local clrtb = nil
			if self:GetColor().r == 0 and self:GetColor().g == 0 and self:GetColor().b == 0 then
				//MsgN("color = false")
			else
				//MsgN("color = true")
				if self:GetColor().a == 1 then
					clrtb = { position = Vector( self:GetColor().r / 255, self:GetColor().g / 255, self:GetColor().b / 255 )  }
				else
					clrtb = { position = Vector( self:GetColor().r, self:GetColor().g, self:GetColor().b )  }
				end
			end
			self.cpointtable = {}
				self.cpointtable[1] = { entity = target, attachtype = PATTACH_ABSORIGIN_FOLLOW }

				//this entry is a placeholder - we want the second controlpoint to be at the endpos of a trace we haven't performed yet
				self.cpointtable[2] = true

				for i = 3, 64 do					
 					if clrtb then
						self.cpointtable[i] = clrtb
					else
						self.cpointtable[i] = self.cpointtable[1]
					end
				end

			PrecacheParticleSystem(self:GetEffectName())

		end

	end
	self:SetModel("models/hunter/plates/plate.mdl") //it's a tiny block so that model-covering fx show up at a single point instead of all over an invisible error model
	self:SetNoDraw(true)


	if self:GetRepeatRate() > 0 then
		//we're going to be repeating the effect, so let's set that up and let think do the rest
		self.NextRepeat = 0
	else
		//we won't be repeating the effect, so just attach it right now
		if self:GetActive() then self:AttachParticle() end
	end

end




function ENT:Think()

	if SERVER then return end

	if self:GetNumpadState() == "off" then
		//MsgN("turn off")
		self:SetNumpadState("")
	end

	if self:GetNumpadState() == "on" then
		//MsgN("turn on")
		self:SetNumpadState("")
		if self:GetRepeatRate() > 0 then
			//we're going to be repeating the effect, so let's set that up and let think do the rest
			self.NextRepeat = 0
		else
			//we won't be repeating the effect, so just attach it right now
			if self:GetActive() then self:AttachParticle() end
		end
	end


	if self:GetActive() == true and self:GetRepeatRate() > 0 then
		if !( self.NextRepeat > CurTime() ) then
			self:AttachParticle()
			self.NextRepeat = CurTime() + self:GetRepeatRate()
		end
	end
	
	self:NextThink(CurTime())
	return true

end




function ENT:AttachParticle()

	if SERVER then return end

	local target		= self:GetTargetEnt()
	//local attachnum	= self:GetAttachNum()  //this isn't used anywhere
	local effectname	= self:GetEffectName()

	local tracerspread	= math.Clamp( self:GetTracerSpread(), 0, 4)
	local tracercount	= self:GetTracerCount()
	local leavebulletholes	= self:GetLeaveBulletHoles()
	local effectlifetime	= math.Clamp( self:GetEffectLifetime(), 0.5, 5)

	local impact_effectname	= self:GetImpact_EffectName()

	if effectname == nil or !target:IsValid() then return end


	for i = 1, tracercount do

		//Do a trace to find the endpoint of the bullet	
		local tracedata = {}
		if self:GetParent() != NULL then tracedata.filter = {self:GetParent(), self:GetParent():GetParent()} end  //this returns a null entity if the player is outside of the visleaf, be careful
		local tracepos = target:GetPos()
		local traceang = target:GetAngles()

		//spread
		local randang = AngleRand()
		traceang:RotateAroundAxis( traceang:Forward(), randang.r )
		traceang:RotateAroundAxis( traceang:Right(), randang.p * (tracerspread / 2) )
		traceang:RotateAroundAxis( traceang:Up(), randang.y * (tracerspread / 4) )

		tracedata.start = tracepos
		tracedata.endpos = tracepos+(traceang:Forward()*20000)
		local trace = util.TraceLine(tracedata)


		//we're going to tie the tracer effect and impact effect to a clientside ent that expires quickly, so people can't create a million permanent medigun beams or anything like that
		local tracerent = ClientsideModel( "models/hunter/plates/plate.mdl", RENDERGROUP_OTHER )
		tracerent:SetNoDraw(true)
		tracerent:SetPos(trace.HitPos)
		tracerent:SetAngles(trace.HitNormal:Angle())
		timer.Simple(effectlifetime, function() if IsValid(tracerent) then tracerent:Remove() end; end)
		tracerent:Spawn()
		tracerent:Activate()

		if self.cpointtable then self.cpointtable[2] = { entity = tracerent, attachtype = PATTACH_ABSORIGIN_FOLLOW } end


		//Create a bullet hole effect, if enabled
		if leavebulletholes == true then
			local impacteffectdata = EffectData()
			impacteffectdata:SetStart( tracepos )
			impacteffectdata:SetOrigin( trace.HitPos )
			impacteffectdata:SetNormal( trace.HitNormal )
			impacteffectdata:SetEntity( trace.Entity )
			impacteffectdata:SetSurfaceProp( trace.SurfaceProps )
			impacteffectdata:SetHitBox( trace.HitBox )
			util.Effect( "Impact", impacteffectdata )
		end


		//Create the tracer effect
		if string.StartWith( effectname, "!UTILEFFECT!" ) then

			//Create a util effect

			//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly

			//local effectscale = self:GetUtilEffectInfo().x
			//local effectmagnitude = self:GetUtilEffectInfo().y
			//local effectradius = self:GetUtilEffectInfo().z

			local luaeffectdata = EffectData()
			luaeffectdata:SetEntity( tracerent )

			luaeffectdata:SetScale(5000) //for tracer effects, scale is the speed of the bullet, so we need to keep this high
			//luaeffectdata:SetMagnitude( 20 )
			//luaeffectdata:SetRadius( 10 )

			//flags can be set by typing !FLAG#! at the end of the effect name
			luaeffectdata:SetFlags( 0 )
			if string.EndsWith( effectname, "!" ) then
				if string.find( effectname, "!FLAG1!" ) then luaeffectdata:SetFlags( 1 ) effectname = string.Replace( effectname, "!FLAG1!", "" ) end
				if string.find( effectname, "!FLAG2!" ) then luaeffectdata:SetFlags( 2 ) effectname = string.Replace( effectname, "!FLAG2!", "" ) end
				if string.find( effectname, "!FLAG3!" ) then luaeffectdata:SetFlags( 3 ) effectname = string.Replace( effectname, "!FLAG3!", "" ) end
				if string.find( effectname, "!FLAG4!" ) then luaeffectdata:SetFlags( 4 ) effectname = string.Replace( effectname, "!FLAG4!", "" ) end
				if string.find( effectname, "!FLAG5!" ) then luaeffectdata:SetFlags( 5 ) effectname = string.Replace( effectname, "!FLAG5!", "" ) end
				if string.find( effectname, "!FLAG6!" ) then luaeffectdata:SetFlags( 6 ) effectname = string.Replace( effectname, "!FLAG6!", "" ) end
				if string.find( effectname, "!FLAG7!" ) then luaeffectdata:SetFlags( 7 ) effectname = string.Replace( effectname, "!FLAG7!", "" ) end
				if string.find( effectname, "!FLAG8!" ) then luaeffectdata:SetFlags( 8 ) effectname = string.Replace( effectname, "!FLAG8!", "" ) end
				if string.find( effectname, "!FLAG9!" ) then luaeffectdata:SetFlags( 9 ) effectname = string.Replace( effectname, "!FLAG9!", "" ) end
			end

			//colors can also be set the same way - i don't think there are any tracers that use these
			luaeffectdata:SetColor(0)
			if string.EndsWith( effectname, "!" ) then
				if string.find( effectname, "!COLOR1!" ) then luaeffectdata:SetColor( 1 ) effectname = string.Replace( effectname, "!COLOR1!", "" ) end
				if string.find( effectname, "!COLOR2!" ) then luaeffectdata:SetColor( 2 ) effectname = string.Replace( effectname, "!COLOR2!", "" ) end
				if string.find( effectname, "!COLOR3!" ) then luaeffectdata:SetColor( 3 ) effectname = string.Replace( effectname, "!COLOR3!", "" ) end
				if string.find( effectname, "!COLOR4!" ) then luaeffectdata:SetColor( 4 ) effectname = string.Replace( effectname, "!COLOR4!", "" ) end
				if string.find( effectname, "!COLOR5!" ) then luaeffectdata:SetColor( 5 ) effectname = string.Replace( effectname, "!COLOR5!", "" ) end
				if string.find( effectname, "!COLOR6!" ) then luaeffectdata:SetColor( 6 ) effectname = string.Replace( effectname, "!COLOR6!", "" ) end
				if string.find( effectname, "!COLOR7!" ) then luaeffectdata:SetColor( 7 ) effectname = string.Replace( effectname, "!COLOR7!", "" ) end
				if string.find( effectname, "!COLOR8!" ) then luaeffectdata:SetColor( 8 ) effectname = string.Replace( effectname, "!COLOR8!", "" ) end
				if string.find( effectname, "!COLOR9!" ) then luaeffectdata:SetColor( 9 ) effectname = string.Replace( effectname, "!COLOR9!", "" ) end
			end

			//dumb situational crap
			//if string.find( string.lower(effectname), "shakeropes" ) then luaeffectdata:SetMagnitude( effectmagnitude * 20 ) end
			//if string.find( string.lower(effectname), "thumperdust" ) then luaeffectdata:SetScale( effectscale * 50 ) end
			//if string.find( string.lower(effectname), "bloodspray" ) then luaeffectdata:SetScale( effectscale * 4 ) end

			luaeffectdata:SetOrigin( trace.HitPos )
			luaeffectdata:SetStart( tracepos )
			//luaeffectdata:SetAngles( traceang )
			luaeffectdata:SetNormal( trace.HitNormal:Angle():Forward() )
		
			util.Effect( string.Replace( effectname, "!UTILEFFECT!", "" ), luaeffectdata )

		else

			//Create a particlesystem effect

			tracerent:CreateParticleEffect(effectname,self.cpointtable)

		end


		//Create the impact effect, if enabled
		if impact_effectname != "" then
			if string.StartWith( impact_effectname, "!UTILEFFECT!" ) then

				//Create a util effect

				//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly

				local effectscale = self:GetImpact_UtilEffectInfo().x
				local effectmagnitude = self:GetImpact_UtilEffectInfo().y
				local effectradius = self:GetImpact_UtilEffectInfo().z

				local impacteffectdata = EffectData()
				impacteffectdata:SetEntity( tracerent )
				if ( string.find(impact_effectname, "Tracer", 0, true) != nil ) then impacteffectdata:SetScale(5000) else impacteffectdata:SetScale( effectscale ) end  //for tracer effects, scale is the speed of the bullet, so we need to keep this high
				impacteffectdata:SetMagnitude( effectmagnitude )
				impacteffectdata:SetRadius(effectradius )

				//flags can be set by typing !FLAG#! at the end of the effect name
				impacteffectdata:SetFlags( 0 )
				if string.EndsWith( impact_effectname, "!" ) then
					if string.find( impact_effectname, "!FLAG1!" ) then impacteffectdata:SetFlags( 1 ) impact_effectname = string.Replace( impact_effectname, "!FLAG1!", "" ) end
					if string.find( impact_effectname, "!FLAG2!" ) then impacteffectdata:SetFlags( 2 ) impact_effectname = string.Replace( impact_effectname, "!FLAG2!", "" ) end
					if string.find( impact_effectname, "!FLAG3!" ) then impacteffectdata:SetFlags( 3 ) impact_effectname = string.Replace( impact_effectname, "!FLAG3!", "" ) end
					if string.find( impact_effectname, "!FLAG4!" ) then impacteffectdata:SetFlags( 4 ) impact_effectname = string.Replace( impact_effectname, "!FLAG4!", "" ) end
					if string.find( impact_effectname, "!FLAG5!" ) then impacteffectdata:SetFlags( 5 ) impact_effectname = string.Replace( impact_effectname, "!FLAG5!", "" ) end
					if string.find( impact_effectname, "!FLAG6!" ) then impacteffectdata:SetFlags( 6 ) impact_effectname = string.Replace( impact_effectname, "!FLAG6!", "" ) end
					if string.find( impact_effectname, "!FLAG7!" ) then impacteffectdata:SetFlags( 7 ) impact_effectname = string.Replace( impact_effectname, "!FLAG7!", "" ) end
					if string.find( impact_effectname, "!FLAG8!" ) then impacteffectdata:SetFlags( 8 ) impact_effectname = string.Replace( impact_effectname, "!FLAG8!", "" ) end
					if string.find( impact_effectname, "!FLAG9!" ) then impacteffectdata:SetFlags( 9 ) impact_effectname = string.Replace( impact_effectname, "!FLAG9!", "" ) end
				end

				//colors can also be set the same way
				impacteffectdata:SetColor(0)
				if string.EndsWith( impact_effectname, "!" ) then
					if string.find( impact_effectname, "!COLOR1!" ) then impacteffectdata:SetColor( 1 ) impact_effectname = string.Replace( impact_effectname, "!COLOR1!", "" ) end
					if string.find( impact_effectname, "!COLOR2!" ) then impacteffectdata:SetColor( 2 ) impact_effectname = string.Replace( impact_effectname, "!COLOR2!", "" ) end
					if string.find( impact_effectname, "!COLOR3!" ) then impacteffectdata:SetColor( 3 ) impact_effectname = string.Replace( impact_effectname, "!COLOR3!", "" ) end
					if string.find( impact_effectname, "!COLOR4!" ) then impacteffectdata:SetColor( 4 ) impact_effectname = string.Replace( impact_effectname, "!COLOR4!", "" ) end
					if string.find( impact_effectname, "!COLOR5!" ) then impacteffectdata:SetColor( 5 ) impact_effectname = string.Replace( impact_effectname, "!COLOR5!", "" ) end
					if string.find( impact_effectname, "!COLOR6!" ) then impacteffectdata:SetColor( 6 ) impact_effectname = string.Replace( impact_effectname, "!COLOR6!", "" ) end
					if string.find( impact_effectname, "!COLOR7!" ) then impacteffectdata:SetColor( 7 ) impact_effectname = string.Replace( impact_effectname, "!COLOR7!", "" ) end
					if string.find( impact_effectname, "!COLOR8!" ) then impacteffectdata:SetColor( 8 ) impact_effectname = string.Replace( impact_effectname, "!COLOR8!", "" ) end
					if string.find( impact_effectname, "!COLOR9!" ) then impacteffectdata:SetColor( 9 ) impact_effectname = string.Replace( impact_effectname, "!COLOR9!", "" ) end
				end

				//dumb situational crap
				if string.find( string.lower(impact_effectname), "shakeropes" ) then impacteffectdata:SetMagnitude( effectmagnitude * 20 ) end
				if string.find( string.lower(impact_effectname), "thumperdust" ) then impacteffectdata:SetScale( effectscale * 50 ) end
				if string.find( string.lower(impact_effectname), "bloodspray" ) then impacteffectdata:SetScale( effectscale * 4 ) end

				impacteffectdata:SetStart( tracerent:GetPos() )
				impacteffectdata:SetOrigin( tracerent:GetPos() )
				impacteffectdata:SetAngles( tracerent:GetAngles() )
				impacteffectdata:SetNormal( trace.HitNormal )

				util.Effect( string.Replace( impact_effectname, "!UTILEFFECT!", "" ), impacteffectdata )

			else

				//Create a particlesystem effect

				local clrtb = nil
				if self:GetImpact_ColorInfo() == Vector(0,0,0) then
					//MsgN("color = false")
				else
					//MsgN("color = true")
					clrtb = { position = self:GetImpact_ColorInfo() }
				end
				local impactcpointtable = {}
					impactcpointtable[1] = { entity = tracerent, attachtype = PATTACH_ABSORIGIN_FOLLOW }

					for i = 2, 64 do					
 						if clrtb then
							impactcpointtable[i] = clrtb
						else
							impactcpointtable[i] = impactcpointtable[1]
						end
					end

				tracerent:CreateParticleEffect(impact_effectname,impactcpointtable)

			end
		end

	end

end




//numpad functions
if SERVER then

local function NumpadPress( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then
		if ent:GetActive() == false then
			ent:SetActive(true)
			ent:SetNumpadState("on")
		else
			ent:SetActive(false)
			ent:SetNumpadState("off")
		end
	else
		ent:SetActive( true )
		ent:SetNumpadState("on")
	end

end

local function NumpadRelease( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then return end
	
	ent:SetActive(false)
	ent:SetNumpadState("off")
	
end

numpad.Register( "Particle_Press", NumpadPress )
numpad.Register( "Particle_Release", NumpadRelease )

end




//don't duplicate this
duplicator.RegisterEntityClass( "particlecontroller_tracer", function( ply, data )
end, "Data" )
--lua/entities/pfx1_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire Embers"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]embers"
--lua/entities/pfx1_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire Trail"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flametrail"
--lua/entities/pfx1_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Ground Burst"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]groundflame"
--lua/entities/pfx2_02_a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood [Alien, Large]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood_alien*"



--lua/entities/pfx2_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Ground Acid"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]acid_ground"
--lua/entities/pfx2_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dripping blood"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]blood_leak"
--lua/entities/pfx3_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Cherry Tree Petals"
ENT.Category         = "PPE: Nature"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[3]sakura_env"


--lua/entities/pfx4_00~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f*"



--lua/entities/pfx4_01~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b*"

--lua/entities/pfx4_02_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Red Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r_s*"
--lua/entities/pfx4_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g"
--lua/entities/pfx4_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g*"
--lua/entities/pfx4_04_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Purple Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v_s"
--lua/entities/pfx4_04~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Purple Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v*"
--lua/entities/pfx4_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1"
--lua/entities/pfx5_00_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Small Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_micro"
--lua/entities/pfx6_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "AR2 Gunfire"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]gunfire_ar2"
--lua/entities/pfx7_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fog 1"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]areal_fog_s"
--lua/entities/pfx7_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blizzard [Moderate]"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]blizzard_mod"
--lua/entities/pfx8_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Flame 1"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_1"
--lua/entities/pfx8_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Portal"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_portal"
--lua/entities/pfx8_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Core"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]core_1"
--lua/entities/pfx_test.lua:
-- CAT** PlaceableFX::[Fire, Smoke, Weather, Tech, Nature, Other]
-- ENT** PFX:[*]
AddCSLuaFile()     
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "light_test"
ENT.Author			= "npc_teslacybertruck_driver"
ENT.Information		= ""
ENT.Category		= "PPE: Dev"
ENT.Spawnable		= false
ENT.AdminOnly		= false
if SERVER then
    function ENT:Initialize()
	    self:SetModel("models/hunter/blocks/cube025x025x025.mdl")
	    self:SetNoDraw(true)
	    self:DrawShadow(false)
	    self:PhysicsInit( SOLID_VPHYSICS )
	    self:SetMoveType( MOVETYPE_VPHYSICS )
	    self:SetSolid( SOLID_VPHYSICS )
        ParticleEffectAttach( "[~]light_test", 1, self, 1 )
    end
end



--addons/shieldgenerator/lua/entities/portable_shield_gen.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Mobiler Schildgenerator"
ENT.Author = "Summe"
ENT.Spawnable = false
ENT.AdminSpawnable = true
ENT.CooldownTime = 60 -- in seconds
ENT.Radius			= 47-- Actual prop radius (Do not change this value!)
ENT.SphereScale		= 3.5	

AddCSLuaFile()  

function ENT:Initialize()
	self:SetModel("models/lordtrilobite/starwars/props/hyperfuelbarrel01.mdl")

	local new_pos = self:GetPos() + Vector( 0, 0, -20 )
	self:SetPos( new_pos )
	self:SetModelScale(1)
	self:SetMoveType(MOVETYPE_VPHYSICS)   
	self:SetSolid(SOLID_VPHYSICS)
	self:SetHealth(1000)

	if SERVER then
		self:PhysicsInit(MOVETYPE_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
	end

	self:Activate()

	local phys = self:GetPhysicsObject()

	if phys:IsValid() then
		phys:Wake()
		phys:SetMass(5000)
		phys:EnableMotion(false)
		local phys = self:GetPhysicsObject()

		if phys:IsValid() then
			phys:Wake()
			phys:SetMass(5000)
			phys:EnableMotion(false)
		end
	end

	if SERVER then
		self.BlockSphere = ents.Create("portable_shield_gen_shield")
		self.BlockSphere:SetPos(self:GetPos())
		self.BlockSphere:Spawn()
		self.BlockSphere:Activate()

		self.BlockSphere:SetNWEntity("shield_gen", self)
	end

	self.SoundLoop = CreateSound(self, 'ambient/levels/citadel/field_loop2.wav')
	self.SoundLoop:SetSoundLevel(50)
	self.SoundLoop:PlayEx(0.32, 64)

	self:EmitSound("summe/sw02_gadgets_burstshield_start_var_3.mp3", 75, 100, 0.5)
	self:EmitSound('ambient/machines/thumper_hit.wav', 75, 64, 0.5)
	self:EmitSound('npc/scanner/scanner_siren1.wav', 75, 88, 0.5)
	self:EmitSound('ambient/levels/citadel/pod_open1.wav', 75, 100, 0.5)
end

if SERVER then
	function ENT:Use(activator, caller, useType, value)
		if IsValid(activator) and activator:IsPlayer() and self.owner == activator then
			if self:Health() >= 500 and self.BlockSphere:Health() > 500 then
				activator:Give("weapon_swrp_portable_shield")
				self:EmitSound("summe/sw01_gadgets_burstshield_stop_var_02.mp3", 75, 100, 0.5)
				self:Remove()
				if IsValid(self.BlockSphere) then
					local CooldownTime = (50000 / self.BlockSphere:Health()) * 2 + 40
					activator:SetNWInt('swrp_shieldgen_cd',CurTime()+CooldownTime)
				end
			else
				Notify:Warning(activator,"Nicht möglich", "Dein Schildgenerator ist fast zerstört.")
			end
		end
	end

	function ENT:OnRemove()
		if IsValid(self.BlockSphere) then
			self.BlockSphere:Remove()
			self.SoundLoop:Stop()

			for k, ply in pairs(ents.FindInSphere(self:GetPos(),200)) do
				if ply:IsPlayer() then
					ply:SetDSP(0)
				end
			end
		end
	end
end

local blockSphere = {}
blockSphere.Type = "anim"
blockSphere.Base = "base_gmodentity"
blockSphere.PrintName = "Mobiler Schildgenerator Schild"
blockSphere.Author = "Mattzi"
blockSphere.Spawnable = false
blockSphere.AdminSpawnable = true

function blockSphere:Initialize()
	local new_pos = self:GetPos() + Vector( 0, 0, -5 )
	self:SetModel("models/summe/shieldgenerator_sphere.mdl")
	self:SetMaterial("Models/effects/vol_light001")

	self:SetModelScale(1)
	self:SetPos( new_pos )
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_WORLD)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetHealth(5000)

	self:Activate()
	local phys = self:GetPhysicsObject()

	if phys:IsValid() then
		phys:Wake()
		phys:SetMass(5000)
		phys:EnableMotion(false)
	end
end

function blockSphere:OnTakeDamage(damage)
	local dmgpos = damage:GetDamagePosition()
	local ed = EffectData()
	ed:SetOrigin(dmgpos)
	ed:SetRadius(5)
	util.Effect('StunstickImpact',ed)

	if damage:GetDamageType() == 64 then -- DMG_BLAST
		self:SetHealth(self:Health() - damage:GetDamage() * 10)
	else
		self:SetHealth(self:Health() - damage:GetDamage())
		self:EmitSound("summe/sw01_gadgets_burstshield_enter_var_04.mp3", 75, 100, 1)
	end

	if (self:Health() <= 20) then
		self:Ignite( 3, 3 )
	end

	if (self:Health() <= 0) then
		self:EmitSound("ambient/explosions/explode_3.wav", 75, 100, 1)
		local BoomBoom4 = ents.Create( "env_explosion" )
		BoomBoom4:SetKeyValue( "spawnflags", 1 )
		BoomBoom4:SetKeyValue( "iMagnitude", 1 )
		BoomBoom4:SetKeyValue( "iRadiusOverride", 1 )
		BoomBoom4:SetPos( self:GetPos() )
		BoomBoom4:Spawn()
		BoomBoom4:Fire( "explode", "", 0 )

		local shieldGen = self:GetNWEntity("shield_gen")
		if IsValid(shieldGen) then
			shieldGen:Remove()
		end
	end
end

function ENT:OnTakeDamage(damage)
	self:SetHealth(self:Health() - damage:GetDamage())
	if (self:Health() <= 20) then
		self:Ignite( 3, 3 )
	end

	if (self:Health() <= 0) then
		self:EmitSound("ambient/explosions/explode_3.wav", 75, 100, 1)
		local BoomBoom4 = ents.Create( "env_explosion" )
		BoomBoom4:SetKeyValue( "spawnflags", 1 )
		BoomBoom4:SetKeyValue( "iMagnitude", 1 )
		BoomBoom4:SetKeyValue( "iRadiusOverride", 1 )
		BoomBoom4:SetPos( self:GetPos() )
		BoomBoom4:Spawn()
		BoomBoom4:Fire( "explode", "", 0 )
		self:Remove()
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()

		local Laser = Material( "cable/physbeam" )

		local Vector1 = self:LocalToWorld( Vector( 0, 0, -20 ) )
		local Vector2 = self:LocalToWorld( Vector( 0, 0, 165 ) ) 
		render.SetMaterial( Laser )
		render.DrawBeam( Vector1, Vector2, 50, 1, 1, Color( 255, 255, 255, 255 ) ) 
	end

	function blockSphere:Draw()
		self:DrawModel()

		local p = self:GetPos()

		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90
		if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 149 * 149 then
			cam.Start3D2D( p + Vector( 0, 0, 50 ), Angle( 0, ang.y, 90 ), .15 )
				draw.RoundedBox( 5, - 180, - 400, 350, 120, Color( 0, 0, 0, 230 ) )

				local shield_gen = self:GetNWEntity("shield_gen")
				if IsValid(shield_gen) then
					draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( shield_gen:Health() / 1000 * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
				end
				
				draw.RoundedBox( 5, - 180, - 358 + 2, math.Clamp( self:Health() / 5000 * 350, 0, 350 ), 10 - 2, Color( 49, 118, 222, 230 ) )
				draw.DrawText( "Squad-Schildgenerator", "header", -3, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

scripted_ents.Register(blockSphere, "portable_shield_gen_shield")
--addons/system_entities/lua/entities/powerstation/cl_init.lua:
include( "shared.lua" )

surface.CreateFont( "BlahBlah2", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
	shadow = true,
	outline = false
} )

function ENT:Draw()
	self:DrawModel()

	--[[local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90]]--
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		
		plyAng = self:GetAngles()
		ang = Angle(plyAng.x, plyAng.y, plyAng.z)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 26, ang, .08)
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 66, 135, 245, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Türsteuerungsmodul", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -70, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			if self:Health() > self.PowerHealth / 2 then
				draw.DrawText( "online", "BlahBlah2", 39, - 295, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			if (self:Health() <= self.PowerHealth / 2 && self:Health() > 0) then
				draw.DrawText( "kritisch", "BlahBlah2", 42, - 295, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
			end

			if self:Health() == 0 then
				draw.DrawText( "offline", "BlahBlah2", 39, - 295, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			end

		cam.End3D2D()
	end
end

--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_emp.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Shock_Explosion_02.wav")

ENT.DroidModels = {
	["models/kingpommes/starwars/playermodels/astromech.mdl"] = true,
	["models/kingpommes/starwars/playermodels/gnk.mdl"] = true,
	["models/kingpommes/starwars/playermodels/lin.mdl"] = true,
	["models/kingpommes/starwars/playermodels/mouse.mdl"] = true,
	["models/kingpommes/starwars/playermodels/wed.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r5_j2.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r4_i9.mdl"] = true,
	["models/sally/tkaro/bx_commando_droid.mdl"] = true,
	["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
	["models/player/hydro/b1_battledroids/specialist/b1_battledroid_specialist.mdl"] = true,
	["models/player/hydro/b1_battledroids/officer/b1_battledroid_officer.mdl"] = true,
	["models/player/hydro/b1_battledroids/heavy/b1_battledroid_heavy.mdl"] = true,
	["models/player/hydro/b1_battledroids/assault/b1_battledroid_assault.mdl"] = true,
	["models/player/jellik/starwars/highsinger.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_grievous.mdl"] = true,
	["models/player/t3_01.mdl"] = true,
	["models/player/t3_02.mdl"] = true,
	["models/player/t3_03.mdl"] = true,
	["models/player/t3_04.mdl"] = true,
	["models/sgg/starwars/battledroid.mdl"] = true,
	["models/player/sgg/starwars/battledroid.mdl"] = true,
	["models/sgg/starwars/battledroid_commander.mdl"] = true,
	["models/sgg/starwars/battledroid_geo.mdl"] = true,
	["models/sgg/starwars/battledroid_pilot.mdl"] = true,
	["models/sgg/starwars/battledroid_security.mdl"] = true,
	["models/player/sgg/starwars/battledroid.mdl"] = true,
	["models/player/sgg/starwars/battledroid_commander.mdl"] = true,
	["models/player/sgg/starwars/battledroid_geo.mdl"] = true,
	["models/player/sgg/starwars/battledroid_pilot.mdl"] = true,
	["models/player/sgg/starwars/battledroid_security.mdl"] = true,
	["models/player/hevoc/b1_battledroids/firefighter/b1_battledroid_firefighter.mdl"] = true,
	["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
	["models/player/tiki/med_droid.mdl"] = true,
	["models/player/valley/medicaldroid.mdl"] = true,
	["models/player/valley/policedroid.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/npc_cit_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_b2_staticarm.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_sw_t_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_comb_x_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_reb_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/npc_reb_sw_t_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b2.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_b2_gunvariant.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_commander.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_commando.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_droid_tactical.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_g_droid_b1.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_t_droid_b1.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/gnk_droid/gnk_droid.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/mouse_droid/mouse_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/gnk_550.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/lin_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r2_q5.mdl"] = true,
	["models/starwars/stan/droidekas/droideka.mdl"] = true,
	["models/player/r2d2.mdl"] = true,
	["models/player/r2kt.mdl"] = true,
	["models/player/r4p17.mdl"] = true,
	["models/player/r4_imperial.mdl"] = true,
	["models/player/r5blue.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/lin_droid/lin_droid.mdl"] = true,
	["models/kingpommes/emperors_tower/ph_props/wed_15/wed_15.mdl"] = true,
	["models/player/c3po.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl"] = true,
	["models/npc/starwars/crabby/crabdroid.mdl"] = true,
	["models/tactical_black/pm_droid_tactical_black.mdl"] = true,
	["models/tactical_blue/pm_droid_tactical_blue.mdl"] = true,
	["models/tactical_gold/pm_droid_tactical_gold.mdl"] = true,
	["models/tactical_purple/pm_droid_tactical_purple.mdl"] = true,
	["models/tactical_red/pm_droid_tactical_red.mdl"] = true,
	["models/super_tactical_kalani/pm_droid_tactical_kalani.mdl"] = true,
	["models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl"] = true,
	["models/player/b1battledroids/b1_base.mdl"] = true,
	["models/npc/starwars/dwarfspider/dwarfspiderdroid.mdl"] = true
}

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end

		self.Delay = CurTime() + 3
		self.First = true
		self.IsDetonated = false
	end
	timer.Simple( 2, function() self:EmitSound("summe/emp_01.mp3") end )
	timer.Simple( 0, function() self:EmitSound("weapons/tfa_starwars/Shock_Charge_01.wav") end )
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end

		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
	end
end
function ENT:Think()
	if SERVER and (CurTime() > self.Delay) and (self.IsDetonated == false) then
		self:Detonate(self, self:GetPos())
		self.IsDetonated = true
	end

	if self.IsDetonated == true then
		local elec = EffectData()
		elec:SetOrigin(self:GetPos())
		elec:SetMagnitude(3)
		util.Effect("Sparks", elec)

		for k, v in pairs(ents.FindInSphere(self:GetPos(), 150)) do
			if v:IsPlayer() then
				if Realism.Droids[v:GetModel()] then
					FreezePlayer(self)
					v:ScreenFade(SCREENFADE.IN, Color(61, 177, 179, 20), 0.2, 0)
					local damage = DamageInfo()
					damage:SetDamage(math.random(5, 10))
					damage:SetAttacker(self:GetOwner())
					damage:SetDamageType(DMG_SHOCK)
					v:TakeDamageInfo(damage)
				else
					v:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 20), 0.4, 0)
					v:SendLua("surface.PlaySound( \"summe/electro_charge.ogg\" )")
					local ply_armor = v:Armor()

					if v:Armor() > 0 then
						v:SetArmor(ply_armor - 2)
					end

					if v:Armor() < 0 then
						v:SetArmor(0)
					end

					v:ConCommand("pp_motionblur 1")

					timer.Simple(7, function()
						v:ConCommand("pp_motionblur 0")
					end)
				end
			end

			if v:IsNPC() and Realism.Droids[v:GetModel()] then
				local damage = DamageInfo()
				damage:SetDamage(math.random(10, 40))
				damage:SetAttacker(self:GetOwner())
				damage:SetDamageType(DMG_SHOCK)
				v:TakeDamageInfo(damage)
			end
		end
	end

	self:NextThink(CurTime() + 0.3)

	return true
end

function FreezePlayer(self,pos)
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 200 ) ) do
		if v:IsPlayer() then
			local fx = EffectData()
			fx:SetOrigin( v:GetPos() )
			fx:SetMagnitude(2)

			util.Effect("TeslaHitBoxes",fx)
			v:Freeze( true )

			timer.Simple(3, function()
				v:Freeze( false )
			end)
		end
	end
end

function ENT:Detonate(self,pos)
	local zap = ents.Create("pfx4_05") -- Tesla Effect
	zap:SetPos(self:GetPos())
	zap:Spawn()

	local light = ents.Create("light_dynamic") -- Light Effect
	light:SetPos(self:GetPos())
	light:Spawn()
	light:SetKeyValue("_light", "66 135 245")
	light:SetKeyValue("distance","100")

	timer.Simple(5, function() zap:Remove() light:Remove() end)


	self.ParticleCreated = true
	self.ExtinguishParticleCreated = true

	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
	end

	self:SetMoveType( MOVETYPE_NONE )

	if SERVER then
		SafeRemoveEntityDelayed(self,5)
	end
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_poison.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")
ENT.RemoveDelay = 30

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/dioxisgrenade.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end

		self:SetNWInt("duration", self.RemoveDelay)

		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
	end
end

function ENT:Think()
	if SERVER then
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.DetonatePos = self:GetPos()
				self.IsDetonated = true
			end
		end
	end

	if self.IsDetonated == true then
	for k, v in pairs( ents.FindInSphere( self.DetonatePos, 216 ) ) do
			if v:IsPlayer() or v:IsNPC() then
				if v:GetNWBool("Realism.UsingBreather", false) then continue end

				damage = DamageInfo()
				damage:SetDamage( math.random( 3, 7 ) )

				if IsValid(self:GetOwner()) then
					damage:SetAttacker( self:GetOwner() )
				end

				damage:SetDamageType( DMG_POISON )
				v:TakeDamageInfo( damage )
				if isfunction(v.ViewPunch) then
					v:ViewPunch( Angle( math.random( -3, 3 ), math.random( -3, 3 ), math.random( -3, 3 ) ) )
				end
			end
		end
	end

	self:NextThink( CurTime() + 0.25 )

	return true
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false

	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)

		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self)
		util.Effect("tfa_csgo_poisonade", gas)

		SafeRemoveEntityDelayed(self, self.RemoveDelay)
	end
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_smoke_impact.lua:

AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/impactgrenade.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)

		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:SetMass(1)
		end

		self:DrawShadow(true)
	end
end

function ENT:PhysicsCollide(data, phys)
	if not self.Detonated and (20 < data.Speed and 0.25 < data.DeltaTime) then
		self:Explode()
	end

	for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
		if v:GetClass() == "tfa_csgo_fire_1" or v:GetClass() == "tfa_csgo_fire_2" and self.IsDetonated == false then
			self:Detonate(self,self:GetPos())
			self.IsDetonated = true
		end
	end
end

function ENT:Explode()
	self.Detonated = true
	self.ExtinguishParticleCreated = false

	if SERVER then
		if not self:IsValid() then return end
		self:EmitSound(self.ExplodeSound)

		local gas = EffectData()
		gas:SetOrigin(self:GetPos())
		gas:SetEntity(self.Owner)
		util.Effect("tfa_csgo_smokenade", gas)
	end

	if SERVER then
		SafeRemoveEntityDelayed(self, 20)
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_thermal.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/ThermalDetonator_Beeps_01.wav")
	self.Delay = CurTime() + 2.5
end

function ENT:Think()
	if SERVER and self.Delay <= CurTime() then
		self:Explode()
		self:Remove()
	end
end

function ENT:PhysicsCollide( data )
	if SERVER and data.Speed > 150 then
	self:EmitSound( "TFA_CSGO_HEGrenade.Bounce" )
	end
end

function ENT:OnRemove()
end

function ENT:Explode()
	if not IsValid(self:GetOwner()) then return end
	local effectdata = EffectData()
	effectdata:SetOrigin( self:GetPos() )
	util.Effect("Explosion", effectdata)
	util.BlastDamage( self, self:GetOwner(), self:GetPos(), 300, 300 )
	local spos = self:GetPos()
	local trs = util.TraceLine({start = spos + Vector(0,0,64), endpos = spos + Vector(0,0,-32), filter = self})
	util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
end
--addons/vanilla-tools/lua/entities/shipdestruction/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Think()
end

function ENT:OnRemove()
end

--addons/system_entities/lua/entities/status/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Status-Bildschirm"
ENT.Category = "CW:RP Systementites"

ENT.StatusHealth = 100000000000

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end


function ENT:Draw()
	self:DrawModel()

	--[[local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90]]--
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		
		plyAng = self:GetAngles()
							ang = Angle(plyAng.x, plyAng.y, plyAng.z)

							ang:RotateAroundAxis(ang:Forward(), 90)
							ang:RotateAroundAxis(ang:Right(), -90)

							cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 20, ang, .16)

		--cam.Start3D2D( p + Vector( 0, 0, 20 ), Angle( 0, -180, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 400, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 1, - 180, - 350, 350, 4, Color( 255, 255, 255, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Systemstatus", "header", -1, - 395, Color( 0, 176, 255, 255 ), TEXT_ALIGN_CENTER )

			draw.DrawText( "Lebenserhaltung", "BlahBlah2", 0, - 340, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER ) --LEBENERHALTUNG
			local ent_lifesupport = ents.FindByClass( "lifesupport" )
			local ent_lifesupportCount = table.Count(ent_lifesupport)
			local test1 = 0

			for k, v in pairs( ents.FindByClass( "lifesupport" ) ) do
				if v:Health() == 0 then
				test1 = test1 + 1
				end
			end

			if ent_lifesupportCount == 0 then
				draw.DrawText( "...", "BlahBlah2", 0, - 310, Color( 66, 135, 245, 255 ), TEXT_ALIGN_CENTER )
			elseif ent_lifesupportCount == test1 then
				draw.DrawText( "offline", "BlahBlah2", 0, - 310, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "online", "BlahBlah2", 0, - 310, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end


			draw.DrawText( "Türsteuerung", "BlahBlah2", 0, - 280, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER ) --POWER
			local ent_powerstation = ents.FindByClass( "powerstation" )
			local ent_powerstationCount = table.Count(ent_powerstation)
			local test2 = 0

			for k, v in pairs( ents.FindByClass( "powerstation" ) ) do
				if v:Health() == 0 then
				test2 = test2 + 1
				end
			end

			if ent_powerstationCount == 0 then
				draw.DrawText( "...", "BlahBlah2", 0, - 250, Color( 66, 135, 245, 255 ), TEXT_ALIGN_CENTER )
			elseif ent_powerstationCount == test2 then
				draw.DrawText( "offline", "BlahBlah2", 0, - 250, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "online", "BlahBlah2", 0, - 250, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end


			draw.DrawText( "Transmitter", "BlahBlah2", 0, - 220, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER ) --KOMMUNIKATIONSARRAY
			local ent_commsarray = ents.FindByClass( "commsarray" )
			local ent_commsarrayCount = table.Count(ent_commsarray)
			local test3 = 0

			for k, v in pairs( ents.FindByClass( "commsarray" ) ) do
				if v:Health() == 0 then
				test3 = test3 + 1
				end
			end

			if ent_commsarrayCount == 0 then
				draw.DrawText( "...", "BlahBlah2", 0, - 190, Color( 66, 135, 245, 255 ), TEXT_ALIGN_CENTER )
			elseif ent_commsarrayCount == test3 then
				draw.DrawText( "offline", "BlahBlah2", 0, - 190, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "online", "BlahBlah2", 0, - 190, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end


			draw.DrawText( "Gravitationsgenerator", "BlahBlah2", 0, - 160, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER ) --GRAVITATIONSGENERATOR
			local ent_gravgen = ents.FindByClass( "gravgen" )
			local ent_gravgenCount = table.Count(ent_gravgen)
			local test4 = 0

			for k, v in pairs( ents.FindByClass( "gravgen" ) ) do
				if v:Health() == 0 then
				test4 = test4 + 1
				end
			end

			if ent_gravgenCount == 0 then
				draw.DrawText( "...", "BlahBlah2", 0, - 130, Color( 66, 135, 245, 255 ), TEXT_ALIGN_CENTER )
			elseif ent_gravgenCount == test4 then
				draw.DrawText( "offline", "BlahBlah2", 0, - 130, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "online", "BlahBlah2", 0, - 130, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			--[[draw.DrawText( "Shieldgenerator", "BlahBlah2", 0, - 100, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER ) --GRAVITATIONSGENERATOR
			for k, v in pairs( ents.FindByClass( "shieldgenerator" ) ) do
				if ( v:Health() >= 5000 ) then
					draw.DrawText( "online", "BlahBlah2", 0, - 70, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
				elseif ( v:Health() < 5000 && v:Health() > 0 ) then
					draw.DrawText( "kritisch", "BlahBlah2", 0, - 70, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
				else
					draw.DrawText( "offline", "BlahBlah2", 0, - 70, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
				end
			end]]--



				if ( self:Health() < 1 ) then
					--draw.DrawText( "Lebenserhaltung", "BlahBlah2", 0, - 250, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
				end

		cam.End3D2D()
	end
end

SYSTEMSTATUS_FRAME = {}

if CLIENT then

	net.Receive("SYSTEMSTATUS_FRAME.OpenMenu", function()
		SYSTEMSTATUS_FRAME.OpenMenu()
	end)

	surface.CreateFont( "text_24", {
		font = "Roboto",
		extended = false,
		size = 24,
		weight = 500,
	})

	surface.CreateFont( "text_27", {
		font = "Roboto",
		extended = false,
		size = 27,
		weight = 1000,
	})

	surface.CreateFont( "text_25", {
		font = "Roboto",
		extended = false,
		size = 27,
		weight = 100,
	})

	local frameColor = Color(31, 31, 31)
	local buttonColor = Color(38, 38, 38)
	local textColor = Color(255, 255, 255)
	local onlineColor = Color(28, 242, 0)
	local criticalColor = Color(242, 153, 0)
	local offlineColor = Color(242, 0, 56)
	local damagedColor = Color(255, 238, 0)


		function SYSTEMSTATUS_FRAME.OpenMenu()
		local scrw, scrh = ScrW(), ScrH()
		if IsValid(SYSTEMSTATUS_FRAME.Menu) then
			SYSTEMSTATUS_FRAME.Menu:Remove()
		end

		local frameW, frameH, animTime, animDelay, animEase = scrw * .5, scrh * .5, 1.8, 0, .1
		SYSTEMSTATUS_FRAME.Menu = vgui.Create("DFrame")
		SYSTEMSTATUS_FRAME.Menu:SetTitle("")
		SYSTEMSTATUS_FRAME.Menu:MakePopup()
		SYSTEMSTATUS_FRAME.Menu:Center()
		SYSTEMSTATUS_FRAME.Menu.Paint = function(me,w,h)
			surface.SetDrawColor(frameColor)
			surface.DrawRect(0, 0, w, h)
			draw.SimpleText("Systemübersicht  ", "text_27", w / 2, h * .03, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		local scroll = vgui.Create("DScrollPanel", SYSTEMSTATUS_FRAME.Menu)
		scroll:Dock(FILL)


		for k, v in pairs (ents.FindByClass("gravgen")) do
				SysEnt_list = vgui.Create("DButton", scroll)
				SysEnt_list:Dock(TOP)
				SysEnt_list:SetText("")
				SysEnt_list:DockMargin(0, 0, 0, 0)
				SysEnt_list:SetTall(SysEnt_list:GetTall()*4)
				local speed = 2
				local range = 100
				local SysEnt_list_use = true
				SysEnt_list.Paint = function(me,w,h)
					local offset = range * math.sin(CurTime() * speed)
					surface.SetDrawColor(buttonColor)
					surface.DrawRect(0, h / 8, w, h)
					draw.SimpleText("Gravitationsmodul #"..k, "text_24", w * .5, h * .3, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					draw.SimpleText(v:Health() / 20 .."%", "text_24", w * .5, h * .55, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					if v:Health() >= 50 then
						draw.SimpleText("Online", "text_24", w * .5, h * .8, onlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					elseif v:Health() < 50 and v:Health() > 0 then
						draw.SimpleText("Kritisch", "text_24", w * .5, h * .8, criticalColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					else
						draw.SimpleText("Offline", "text_24", w * .5, h * .8, offlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				end

				local icon = vgui.Create( "DModelPanel", SysEnt_list )
				icon:SetSize( 150, 150 )
				icon:SetModel( v:GetModel() )
				local mn, mx = icon.Entity:GetRenderBounds()
				local size = 0
				size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
				size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
				size = math.max( size, math.abs(mn.z) + math.abs(mx.z) + 10)

				icon:SetFOV( 45 )
				icon:SetCamPos( Vector( size, size, size ) )
				icon:SetLookAt( (mn + mx) * 0.5 )

		end

		for k, v in pairs (ents.FindByClass("lifesupport")) do
				SysEnt_list = vgui.Create("DButton", scroll)
				SysEnt_list:Dock(TOP)
				SysEnt_list:SetText("")
				SysEnt_list:DockMargin(0, 5, 0, 0)
				SysEnt_list:SetTall(SysEnt_list:GetTall()*4)
				local speed = 2
				local range = 100
				local SysEnt_list_use = true
				SysEnt_list.Paint = function(me,w,h)
					local offset = range * math.sin(CurTime() * speed)
					surface.SetDrawColor(buttonColor)
					surface.DrawRect(0, h / 8, w, h)
					draw.SimpleText("Lebenserhaltungsmodul #"..k, "text_24", w * .5, h * .3, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					draw.SimpleText(v:Health() / 20 .."%", "text_24", w * .5, h * .55, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					if v:Health() >= 50 then
						draw.SimpleText("Online", "text_24", w * .5, h * .8, onlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					elseif v:Health() < 50 and v:Health() > 0 then
						draw.SimpleText("Kritisch", "text_24", w * .5, h * .8, criticalColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					else
						draw.SimpleText("Offline", "text_24", w * .5, h * .8, offlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				end

				local icon = vgui.Create( "DModelPanel", SysEnt_list )
				icon:SetSize( 150, 150 )
				icon:SetModel( v:GetModel() )
				local mn, mx = icon.Entity:GetRenderBounds()
				local size = 0
				size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
				size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
				size = math.max( size, math.abs(mn.z) + math.abs(mx.z) + 10)

				icon:SetFOV( 45 )
				icon:SetCamPos( Vector( size, size, size ) )
				icon:SetLookAt( (mn + mx) * 0.5 )

		end


		for k, v in pairs (ents.FindByClass("powerstation")) do
				SysEnt_list = vgui.Create("DButton", scroll)
				SysEnt_list:Dock(TOP)
				SysEnt_list:SetText("")
				SysEnt_list:DockMargin(0, 5, 0, 0)
				SysEnt_list:SetTall(SysEnt_list:GetTall()*4)
				local speed = 2
				local range = 100
				local SysEnt_list_use = true
				SysEnt_list.Paint = function(me,w,h)
					local offset = range * math.sin(CurTime() * speed)
					surface.SetDrawColor(buttonColor)
					surface.DrawRect(0, h / 8, w, h)
					draw.SimpleText("Türsteuerungsmodul #"..k, "text_24", w * .5, h * .3, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					draw.SimpleText(v:Health() / 20 .."%", "text_24", w * .5, h * .55, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					if v:Health() >= 50 then
						draw.SimpleText("Online", "text_24", w * .5, h * .8, onlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					elseif v:Health() < 50 and v:Health() > 0 then
						draw.SimpleText("Kritisch", "text_24", w * .5, h * .8, criticalColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					else
						draw.SimpleText("Offline", "text_24", w * .5, h * .8, offlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				end

				local icon = vgui.Create( "DModelPanel", SysEnt_list )
				icon:SetSize( 150, 150 )
				icon:SetModel( v:GetModel() )
				local mn, mx = icon.Entity:GetRenderBounds()
				local size = 0
				size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
				size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
				size = math.max( size, math.abs(mn.z) + math.abs(mx.z) + 10)

				icon:SetFOV( 45 )
				icon:SetCamPos( Vector( size, size, size ) )
				icon:SetLookAt( (mn + mx) * 0.5 )

		end


		for k, v in pairs (ents.FindByClass("commsarray")) do
				SysEnt_list = vgui.Create("DButton", scroll)
				SysEnt_list:Dock(TOP)
				SysEnt_list:SetText("")
				SysEnt_list:DockMargin(0, 5, 0, 0)
				SysEnt_list:SetTall(SysEnt_list:GetTall()*4)
				local speed = 2
				local range = 100
				local SysEnt_list_use = true
				SysEnt_list.Paint = function(me,w,h)
					local offset = range * math.sin(CurTime() * speed)
					surface.SetDrawColor(buttonColor)
					surface.DrawRect(0, h / 8, w, h)
					draw.SimpleText("Kommunikationsmodul #"..k, "text_24", w * .5, h * .3, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					draw.SimpleText(v:Health() / 20 .."%", "text_24", w * .5, h * .55, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					if v:Health() >= 50 then
						draw.SimpleText("Online", "text_24", w * .5, h * .8, onlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					elseif v:Health() < 50 and v:Health() > 0 then
						draw.SimpleText("Kritisch", "text_24", w * .5, h * .8, criticalColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					else
						draw.SimpleText("Offline", "text_24", w * .5, h * .8, offlineColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				end

				local icon = vgui.Create( "DModelPanel", SysEnt_list )
				icon:SetSize( 150, 150 )
				icon:SetModel( v:GetModel() )
				local mn, mx = icon.Entity:GetRenderBounds()
				local size = 0
				size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
				size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
				size = math.max( size, math.abs(mn.z) + math.abs(mx.z) + 10)

				icon:SetFOV( 45 )
				icon:SetCamPos( Vector( size, size, size ) )
				icon:SetLookAt( (mn + mx) * 0.5 )

		end

			local isAnimating = true
			SYSTEMSTATUS_FRAME.Menu:SizeTo(frameW, frameH, animTime, animDelay, animEase, function()
				isAnimating = false
			end)
			SYSTEMSTATUS_FRAME.Menu.OnSizeChanged = function(me,w,h)
				if isAnimating then
					me:Center()
				end
				if SysEnt_list_use then
					SysEnt_list:SetTall(h * .1)
				end
				if SysEnt_list2_use then
					SysEnt_list2:SetTall(h * .1)
				end
			end
	end
end
--addons/emplacements/lua/entities/swrp_turret_stand_bullets.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Turret Stand Bullets"
ENT.Category = "CW:RP Geschütze"
ENT.Editable = true
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/reach/weapons/turret/tripod.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll 
	pAngle.yaw = pAngle.yaw + 180
	local ent = ents.Create( ClassName ) 
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()
	return ent	
end

if CLIENT then

	surface.CreateFont( "info_1", {
	font = "Arial",
	extended = false,
	size = 25,
	weight = 100,
	shadow = true,
	outline = false
	} )

	function ENT:Draw()
		self:DrawModel()

		local p = self:GetPos()

		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90
		if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
			cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
				--draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
				--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
				--draw.DrawText( "Turret Stand", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
				
				local swep = LocalPlayer():GetActiveWeapon()
				if swep:IsValid() and swep:GetClass() == "weapon_swrp_bullets_deployable" then
					draw.RoundedBox( 5, - 126, - 470, 250, 100, Color( 0, 0, 0, 230 ) )
					draw.RoundedBox( 1, - 126, - 424, 250, 2, Color( 255, 255, 255, 230 ) )
					draw.DrawText( "> Geschütz platzieren <", "info_1", -1, - 410, Color( 0, 255, 51, 255 ), TEXT_ALIGN_CENTER )
				else
					draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
				end
				draw.DrawText( "Blaster Cannon", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
		self:SetTrigger(true)
	

	end
end

if SERVER then
	function ENT:Think()
		if self:GetNWBool("Remove?", false) then
			self:Remove()
			local cannon = ents.Create("turret_bullets_deployable") -- Tesla Effect
			cannon:SetPos(self:GetPos())
			cannon:Spawn()
		end
	end

	function ENT:Use(activator, caller, useType, value)
		if IsValid(activator) and activator:IsPlayer() and self.owner == activator then
			activator:Give("weapon_swrp_bullets_deployable")
			self:EmitSound("summe/sw01_gadgets_burstshield_stop_var_02.mp3")
			self:Remove()
		end
	end

end
--addons/starwars_universe/lua/entities/swu_map/shared.lua:
ENT.Type        = "anim"
ENT.PrintName   = "[SWU] Map"
ENT.Author      = "The Coding Ducks"
ENT.Information = ""
ENT.Category    = "[SWU] Universe"

ENT.Spawnable	= false

function ENT:SetupDataTables()
end
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/entities/swu_so_base/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/starwars_universe/lua/entities/swu_so_shipyard/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if (SWU.Controller:GetHyperspace() == SWU.Hyperspace.IN) then return end

	self:DrawModel()
end

--addons/starwars_universe/lua/entities/swu_teleporter/cl_init.lua:
include("shared.lua")

function ENT:Draw()
end

--addons/starwars_universe/lua/entities/swu_teleporter/shared.lua:
ENT.Type			=	"brush"
ENT.Base			=	"base_brush"

--addons/tfa_base/lua/entities/tfa_exp_rocket.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Rocket-Propelled Explosive"

-- EDITABLE PARAMETERS -- START

ENT.LaunchSound = "" -- none, replace to enable
ENT.PropelSound = Sound("Missile.Accelerate") -- looped propel sound

ENT.BaseSpeed = 500 -- base rocket speed, in units

ENT.AccelerationTime = 0.25 -- time in seconds to accelerate to max speed
ENT.MaxSpeed = 1500 -- maximum speed, works if AccelerationTime > 0

ENT.HasTrail = true -- create trail

-- EDITABLE PARAMETERS -- END

ENT.AccelProgress = 0

ENT.DefaultModel = Model("models/weapons/w_missile.mdl")
ENT.Delay = 10

DEFINE_BASECLASS(ENT.Base)

-- Creates HL2 rocket trail by default, feel free to copy and edit to your needs
function ENT:CreateRocketTrail()
	if not SERVER then return end

	local rockettrail = ents.Create("env_rockettrail")
	rockettrail:DeleteOnRemove(self)

	rockettrail:SetPos(self:GetPos())
	rockettrail:SetAngles(self:GetAngles())
	rockettrail:SetParent(self)
	rockettrail:SetMoveType(MOVETYPE_NONE)
	rockettrail:AddSolidFlags(FSOLID_NOT_SOLID)

	rockettrail:SetSaveValue("m_Opacity", 0.2)
	rockettrail:SetSaveValue("m_SpawnRate", 100)
	rockettrail:SetSaveValue("m_ParticleLifetime", 0.5)
	rockettrail:SetSaveValue("m_StartColor", Vector(0.65, 0.65, 0.65))
	rockettrail:SetSaveValue("m_EndColor", Vector(0, 0, 0))
	rockettrail:SetSaveValue("m_StartSize", 8)
	rockettrail:SetSaveValue("m_EndSize", 32)
	rockettrail:SetSaveValue("m_SpawnRadius", 4)
	rockettrail:SetSaveValue("m_MinSpeed", 2)
	rockettrail:SetSaveValue("m_MaxSpeed", 16)
	rockettrail:SetSaveValue("m_nAttachment", 0)
	rockettrail:SetSaveValue("m_flDeathTime", CurTime() + 999)

	rockettrail:Activate()
	rockettrail:Spawn()
end

function ENT:Initialize(...)
	BaseClass.Initialize(self, ...)

	self:EmitSoundNet(self.PropelSound)

	if self.LaunchSound and self.LaunchSound ~= "" then
		self:EmitSoundNet(self.LaunchSound)
	end

	self:SetFriction(0)
	self:SetLocalAngularVelocity(angle_zero)

	self:SetMoveType(bit.bor(MOVETYPE_FLYGRAVITY, MOVECOLLIDE_FLY_BOUNCE))
	self:SetLocalVelocity(self:GetForward() * self.BaseSpeed)

	if self.HasTrail then
		self:CreateRocketTrail()
	end
end

function ENT:Think(...)
	if self.AccelerationTime > 0 and self.AccelProgress < 1 then
		self.LastAccelThink = self.LastAccelThink or CurTime()
		self.AccelProgress = Lerp((CurTime() - self.LastAccelThink) / self.AccelerationTime, self.AccelProgress, 1)
	end

	self:SetLocalVelocity(self:GetForward() * Lerp(self.AccelProgress, self.BaseSpeed, self.MaxSpeed))

	return BaseClass.Think(self, ...)
end

function ENT:Explode(...)
	self:StopSound(self.PropelSound)

	return BaseClass.Explode(self, ...)
end

function ENT:Touch()
	self.killtime = -1
end

--addons/tfa_base/lua/entities/tfbow_arrow_stuck/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() -- Draw the model.
end

--addons/emplacements/lua/entities/turret_bullets2_deployable/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 105, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Heavy Blaster Cannon", "header", -1, - 395, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )

		cam.End3D2D()
	end

end
--addons/emplacements/lua/entities/turret_grenade_deployable/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 105, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Grenade Launcher", "header", -1, - 395, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )

		cam.End3D2D()
	end

end
--lua/entities/vox_e60r_rocket/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= ""  
 ENT.Contact			= ""  
 ENT.Purpose			= ""  
 ENT.Instructions			= ""  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--addons/wos-alcs-custom/lua/entities/wos_duel_dome/cl_init.lua:
include('shared.lua')

local mat_orb = Material("sprites/rollermine_shock")

function ENT:Initialize()

end

function ENT:Think()
	
end

function ENT:OnRemove()

end

function ENT:Draw()

	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if wep:GetClass() != "wos_alcs_duelplacer" then return end
	
	render.SetColorMaterial( mat_orb )
	local color = Color( 0, 125, 175, 175 )
	if wep:GetSelected() == self then
		color = Color( 0, 175, 125, 175 )
	end
	render.DrawSphere( self:GetPos(), -1*self:GetRadius(), 75, 75, color )
	render.DrawSphere( self:GetPos(), self:GetRadius(), 75, 75, color )
	
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor10/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor10", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor8/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor8", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor9/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor9", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/effect_sw_impact_2/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/sw_laser_bit" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 32 do

			local particle = emitter:Add( "effects/sw_laser_bit", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );

		end
		emitter:Finish();
	end
	
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/awoi_musket_smoke_01"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(1, 3));
			particle_s:SetStartAlpha(150);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(10, 20));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
	
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--lua/effects/effect_sw_laser_green_sniper/init.lua:
TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 8000
EFFECT.Length				= 600
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 250

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_yellow_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_zeus_muzzleflash/init.lua:
AddCSLuaFile()

EFFECT.Author = "BFG"
EFFECT.Life = 0
function EFFECT:Init(fxdata)
	self.attachment = fxdata:GetAttachment()
	self.Ent = fxdata:GetEntity()
	self.Position = fxdata:GetStart()
	self.StartPos = self:GetTracerShootPos( self.Position, self.Ent, self.attachment )
	//util.Effect(self.StartPos, self.size or 60, self.size or 60, Color(200,200,255))
	//self.Life = 0
end

function EFFECT:Render()
	render.SetMaterial(Material("sprites/glow04_noz"))
	render.DrawSprite( self.StartPos, self.size or 60, self.size or 60, Color(180,180,255))
end

function EFFECT:Think()
	self.Life = self.Life + FrameTime() * 4
	self.size = 60 * ( 1 - self.Life )	
	return (self.Life < 1)	
end
--lua/effects/electric_spark.lua:
function EFFECT:Init(data)
    self.Position = data:GetOrigin()
    self.Scale = data:GetMagnitude() or 1 -- Adjust scale as needed

    local entindex = data:GetEntity():EntIndex()

    -- Start a coroutine to create the electric spark effect
    coroutine.wrap(function()
        for i = 1, math.random(5, 10) do
            local lightning = ents.Create("point_tesla")
            lightning:SetPos(self.Position)
            lightning:SetKeyValue("m_SoundName", "")
            lightning:SetKeyValue("texture", "sprites/bluelight1.spr")
            lightning:SetKeyValue("m_Color", "255 255 150")
            lightning:SetKeyValue("m_flRadius", "150")
            lightning:SetKeyValue("beamcount_max", "15")
            lightning:SetKeyValue("thick_min", "15")
            lightning:SetKeyValue("thick_max", "30")
            lightning:SetKeyValue("lifetime_min", "0.15")
            lightning:SetKeyValue("lifetime_max", "0.4")
            lightning:SetKeyValue("interval_min", "0.15")
            lightning:SetKeyValue("interval_max", "0.25")
            lightning:Spawn()
            lightning:Fire("DoSpark", "", 0)
            lightning:Fire("kill", "", 0.2)

            local light = ents.Create("light_dynamic")
            light:SetPos(self.Position)
            light:Spawn()
            light:SetKeyValue("_light", "100 100 255")
            light:SetKeyValue("distance", "550")
            light:Fire("Kill", "", 0.20)

            sound.Play("k_lab.teleport_spark", self.Position, 110)

            -- Wait for a random interval before creating the next spark
            local interval = math.Rand(0.03, 0.1)
            coroutine.yield(interval)
        end
    end)()
end

function EFFECT:Think()
    -- No need to continue thinking
    return false
end

function EFFECT:Render()
end
--addons/wos-alcs-custom/lua/effects/force_lightning.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid(self.Ent) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625

		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid(self.Ent) then
		return false
	end

	return true
end

local BeamMat = Material("trails/electric")
local mat = Material("sprites/light_glow02_add")

function EFFECT:Render()
	if IsValid( self.Ent ) then
		local boneID = self.Ent:LookupBone("ValveBiped.Bip01_L_Hand")

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos

				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255
					dlight.g = 255
					dlight.b = 255
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end

			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine({start = StartPos, endpos = EndPos, filter = self.Ent})

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
					effectdata:SetNormal( -trace.HitNormal )
					util.Effect("force_lightning_hit", effectdata )

					if math.random(1,3) == 3 then
						local dlight = DynamicLight(self.Ent:EntIndex() + math.random(100,9999))
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255
							dlight.g = 150
							dlight.b = 255
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end
					end
				end
			end

			render.SetMaterial(mat)
			render.DrawSprite(StartPos, 64, 64, Color( 0, 50, 255, 255))
			render.DrawSprite(StartPos, 16, 16, Color( 255, 255, 255, 255))

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial(BeamMat)
			render.DrawBeam(BeamStart, BeamEnd, 18, 0, 1, Color(255, 255, 255, 255))

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 150 + 155 * Width, 255, 255 ) )

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 255, 255, 255 ) )
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255, 255 ) )

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--lua/effects/gdca_airburst_t/init.lua:

   
 /*--------------------------------------------------------- 
    Initializes the effect. The data is a table of data  
    which was passed from the server. 
 ---------------------------------------------------------*/ 
 function EFFECT:Init( data ) 
	
	self.Origin = data:GetOrigin()
	self.Scale = data:GetScale()
	self.Magnitude = data:GetMagnitude()
	self.Emitter = ParticleEmitter( self.Origin )

	sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Origin, 75, 100, 1 )
		
	for i=0, 40*self.Scale do
	
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Origin )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.Rand(500, 1500)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 3 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 70*self.Scale )
		Smoke:SetEndSize( math.Rand(100, 130)*self.Scale )
		Smoke:SetRoll( math.Rand(0, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 		
		Smoke:SetColor( 60,60,60 )
		end
		end
	

		for i=0, 40*self.Scale do
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Origin )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( VectorRand():GetNormalized()*math.Rand(3000, 5000)*self.Scale )
		Shrapnel:SetDieTime( math.random( 0.3, 0.6) )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7*self.Scale) )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 20 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=1,3 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Origin )
		if (Flash) then
		Flash:SetVelocity( VectorRand() )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.1 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Magnitude*10 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1,1 do 
		local Shockwave = self.Emitter:Add( "sprites/heatwave", self.Origin )
		if (Shockwave) then
		Shockwave:SetVelocity( VectorRand() )
		Shockwave:SetAirResistance( 200 )
		Shockwave:SetDieTime( 0.07 )
		Shockwave:SetStartAlpha( 255 )
		Shockwave:SetEndAlpha( 0 )
		Shockwave:SetStartSize( self.Magnitude*25 )
		Shockwave:SetEndSize( self.Magnitude*20 )
		Shockwave:SetRoll( math.Rand(180,480) )
		Shockwave:SetRollDelta( math.Rand(-1,1) )
		Shockwave:SetColor(255,255,255)	
		end
		end

 end
   
   
/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think( )
	return false
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()
end

 
--lua/effects/gdca_cinematicboom_t/init.lua:

					//Sound,Impact

					// 1        2       3      4      5
					//Dirt, Concrete, Metal, Glass, Flesh

					// 1     2     3      4      5      6      7      8         9
					//Dust, Dirt, Sand, Metal, Smoke, Wood,  Glass, Blood, YellowBlood
local mats={				
	[MAT_ALIENFLESH]		={5,9},
	[MAT_ANTLION]			={5,9},
	[MAT_BLOODYFLESH]		={5,8},
	[45]				={5,8},	// Metrocop heads are a source glitch, they have no enumeration
	[MAT_CLIP]			={3,5},
	[MAT_COMPUTER]			={4,5},
	[MAT_FLESH]			={5,8},
	[MAT_GRATE]			={3,4},
	[MAT_METAL]			={3,4},
	[MAT_PLASTIC]			={2,5},
	[MAT_SLOSH]			={5,5},
	[MAT_VENT]			={3,4},
	[MAT_FOLIAGE]			={1,5},
	[MAT_TILE]			={2,5},
	[MAT_CONCRETE]			={2,1},
	[MAT_DIRT]			={1,2},
	[MAT_SAND]			={1,3},
	[MAT_WOOD]			={2,6},
	[MAT_GLASS]			={4,7},
}


function EFFECT:Init(data)
self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light			//
self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect			//
self.Scale 		= data:GetScale()*0.8		// Scale determines how large the effect is				//
self.Radius 		= data:GetRadius() or 1		// Radius determines what type of effect to create, default is Concrete	//
self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect		//
self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations	//
self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"	//
self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal				//
self.DebrizzlemyNizzle 	= 10+data:GetScale()		// Debrizzle my Nizzle is how many "trails" to make			//
self.Size 		= 5*self.Scale			// Size is exclusively for the explosion "trails" size			//
self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error			//
	

			if self.Scale<2.1 then
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			else
			sound.Play( "Explosion.Boom", self.Pos)
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			end


	self.Mat=math.ceil(self.Radius)


 
	if     mats[self.Mat][2]==1 then	self:Dust()	
	elseif mats[self.Mat][2]==2 then	self:Dirt()
	elseif mats[self.Mat][2]==3 then	self:Sand()
	elseif mats[self.Mat][2]==4 then	self:Metal()
	elseif mats[self.Mat][2]==5 then	self:Smoke()
	elseif mats[self.Mat][2]==6 then	self:Wood()
	elseif mats[self.Mat][2]==7 then	self:Glass()
	elseif mats[self.Mat][2]==8 then	self:Blood()
	elseif mats[self.Mat][2]==9 then	self:YellowBlood()
	else 					self:Smoke()
	end

end
 
 function EFFECT:Dust()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end


		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 80,80,80 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,85,75 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,500)*self.Scale + VectorRand():GetNormalized() * math.random(0,400)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 60,60,60 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 5) + (DustRing*math.Rand(2, 5))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,87+Rcolor,80+Rcolor )
			end
		end
 end
 
function EFFECT:Dirt()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,500)*self.Scale + VectorRand():GetNormalized() * math.random(0,400)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 50,53,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(2, 6) + (DustRing*math.Rand(1, 4))	

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,83+Rcolor,68+Rcolor )
			end
		end
 end

 function EFFECT:Sand()

		for i=0, 45*self.Scale do		// This is the main plume
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 50,1000*self.Scale) + VectorRand():GetNormalized()*300*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 50*self.Scale )
		Smoke:SetEndSize( 120*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-1, 1) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// This is the dirt kickup
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,700)*self.Scale + VectorRand():GetNormalized()*250*self.Scale )
		Dust:SetDieTime( math.Rand( 0.5 , 1,5 ) )
		Dust:SetStartAlpha( 200 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( 60*self.Scale )
		Dust:SetEndSize( 90*self.Scale )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 200 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=0, 25*self.Scale do		// Chunkage
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,500)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,8)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 53,50,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=0, 25*self.Scale do		// Shrapnel
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos+self.DirVec )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( (self.DirVec*700*self.Scale) + (VectorRand():GetNormalized() * 1000*self.Scale) )
		Shrapnel:SetDieTime( math.random( 0.3, 0.5) * self.Scale )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7)*self.Scale )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 10 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 
		Shrapnel:SetCollide( true )
		Shrapnel:SetBounce( 0.8 )			
		end
		end

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.10 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 10*self.Scale do		
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 30,120*self.Scale) + VectorRand():GetNormalized() * math.random( 50,100*self.Scale) )
		Smoke:SetDieTime( math.Rand( 0.5 , 1 )*self.Scale  )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 100 ) 			 
		Smoke:SetGravity( Vector( math.random(-20,20)*self.Scale, math.random(-20,20)*self.Scale, 250 ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end
		
	
		for i=0, 5*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 300,600*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 30, 40 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end


				local Density = 40*self.Scale					/// This part is for the dust ring ///
				local Angle = self.DirVec:Angle()
				for i=0, Density do	
				Angle:RotateAroundAxis(Angle:Forward(), (360/Density))
				local ShootVector = Angle:Up()
				local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
				if (Smoke) then
				Smoke:SetVelocity( ShootVector * math.Rand(50,700*self.Scale) )
				Smoke:SetDieTime( math.Rand( 1 , 4 )*self.Scale  )
				Smoke:SetStartAlpha( math.Rand( 90, 120 ) )
				Smoke:SetEndAlpha( 0 )
				Smoke:SetStartSize( 40*self.Scale )
				Smoke:SetEndSize( 70*self.Scale )
				Smoke:SetRoll( math.Rand(0, 360) )
				Smoke:SetRollDelta( math.Rand(-1, 1) )			
				Smoke:SetAirResistance( 200 ) 			 
				Smoke:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )			
				Smoke:SetColor( 90,83,68 )
				end	
				end
 end

 function EFFECT:Metal()

		for i=1,3 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 50, 70 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end

 		for i=0, 30*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/spark", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( ((self.DirVec*0.75)+VectorRand()) * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(0.3, 1) ) 				 
 		Sparks:SetStartAlpha( 255 )  				 
 		Sparks:SetStartSize( math.Rand(7, 15)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 20 ) 
 		Sparks:SetGravity( Vector( 0, 0, -600 ) ) 
 		end 	
		end 

 		for i=0, 10*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/yellowflare", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( VectorRand() * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(1, 1.7) ) 				 
 		Sparks:SetStartAlpha( 200 )  				 
 		Sparks:SetStartSize( math.Rand(10, 13)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 100 ) 
 		Sparks:SetGravity( Vector( 0, 0, -60 ) ) 
 		end 	
		end 

end


 function EFFECT:Smoke()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1200*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end


		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(100,400)*self.Scale + VectorRand():GetNormalized() * math.random(100,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 3) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 70,70,70 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 4) + (DustRing*math.Rand(3, 4))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0, 3 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,85+Rcolor,75+Rcolor )
			end
		end
end

 function EFFECT:Wood()

		for i=1,5 do 				
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000)*self.Scale )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 70, 90 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 90,85,75 )
		end
		end

		for i=0, 20*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_wood"..math.random(1,2), self.Pos+self.DirVec )
		if (Debris) then
		Debris:SetVelocity( self.DirVec * math.random(50,300)*self.Scale + VectorRand():GetNormalized() * math.random(200,600)*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 2) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(10,15)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 70 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end
end

 function EFFECT:Glass()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 30*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * math.random(100,600)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2.5) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,7)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 200,200,200 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.5 )				
		end
		end


		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,800*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end
		
end

 function EFFECT:Blood()

		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 70,35,35 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end

end

 function EFFECT:YellowBlood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		local Distort = self.Emitter:Add( "sprites/heatwave", self.Pos )
		if (Distort) then
		Distort:SetVelocity( self.DirVec )
		Distort:SetAirResistance( 200 )
		Distort:SetDieTime( 0.1 )
		Distort:SetStartAlpha( 255 )
		Distort:SetEndAlpha( 0 )
		Distort:SetStartSize( self.Scale*600 )
		Distort:SetEndSize( 0 )
		Distort:SetRoll( math.Rand(180,480) )
		Distort:SetRollDelta( math.Rand(-1,1) )
		Distort:SetColor(255,255,255)	
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 120,120,0 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end
end
 

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--lua/effects/lfs_fb_wingturret_projector.lua:
EFFECT.Mat = Material( "effects/lfs_base/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	self.DownPos = Vector(-55, 350, 90)
	self.UpPos = Vector(-55, 370, 125)
	self.StartPos = self.DownPos
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.Entity:GetWingTurretFire() then
		return false
	end
	
	self.EndPosDesired = self.Entity:GetWingTurretTarget() 
	self:SetRenderBoundsWS( self.Entity:GetPos(), self.EndPosDesired )
	
	return true
end

local color_white = Color(255, 255, 255, 255)
local color_green = Color(0, 255, 0, 255)
local trData = {}
function EFFECT:Render()
	if not self.EndPosDesired then return end
	
	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10
	
	for i = -1, 1, 2 do
		local StartPos = self.Entity:LocalToWorld(self.StartPos * Vector(1, i, 1))
		
		trData.start = StartPos
		trData.endpos = self.EndPos
		local Trace = util.TraceLine(trData)
		local EndPos = Trace.HitPos
		
		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = self.DownPos
		else
			self.StartPos = self.UpPos
		end
		
		if Trace.Entity ~= self.Entity then
			render.SetMaterial(self.Mat)
			render.DrawBeam(StartPos, EndPos, 14 + math.random(0, 4), 1, 0, color_green)
			render.DrawBeam(StartPos, EndPos, 3 + math.random(0, 4), 1, 0, color_white)
			
			render.SetMaterial( self.HitMat )
			local A = 150 + math.random(0, 20)
			local B = 70 + math.random(0, 20)
			render.DrawSprite(StartPos, A, A, color_green)
			render.DrawSprite(StartPos, B, B, color_white)
			
			render.DrawSprite(EndPos, A, A, color_green)
			render.DrawSprite(EndPos + VectorRand() * 10, B, B, color_white)
			
			if math.random(0,5) == 1 then
				local emitter = ParticleEmitter(EndPos, false)
				local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
				
				for i = 0, 10 do
					local particle = emitter:Add("sprites/rico1", EndPos)
					local vel = VectorRand() * 100 + dir * 40
					
					if particle then
						particle:SetVelocity(vel)
						particle:SetAngles(vel:Angle() + Angle(0, 90, 0))
						particle:SetDieTime(math.Rand(0.1, 0.3) * 0.5)
						particle:SetStartAlpha(math.Rand( 200, 255 ))
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(1, 30))
						particle:SetEndSize(0)
						particle:SetRoll(math.Rand(-100, 100))
						particle:SetRollDelta(math.Rand(-100, 100))
						particle:SetAirResistance(0)
					end
				end
				
				emitter:Finish()
			end
		end
	end
end
--addons/lvs_base/lua/effects/lvs_exhaust.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local Vel = Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

	if not particle then return end

	local Col = 100 - 60 * Scale

	particle:SetVelocity( Vel + Dir * (100 + 50 * Scale) )
	particle:SetDieTime( 0.4 - 0.3 * Scale )
	particle:SetAirResistance( 400 ) 
	particle:SetStartAlpha( 80 )
	particle:SetStartSize( 2 )
	particle:SetEndSize( 10 + 20 * Scale )
	particle:SetRoll( math.Rand( -1, 1 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) * 2 )
	particle:SetColor( Col, Col, Col )
	particle:SetGravity( Vector( 0, 0, 10 ) )
	particle:SetCollide( false )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_exhaust_fire.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( "effects/lvs_base/fire", Pos )

	if particle then
		particle:SetVelocity( Dir * 70 )
		particle:SetDieTime( 0.2 )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 + 18 * Scale )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-1,1) * 180 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end
	
	for i = 1, 3 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos )
		
		if particle then
			particle:SetVelocity( Dir * 40 * i )
			particle:SetDieTime( 0.2 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( (5 + 5 * Scale) - i )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-1,1) * 180 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_explosion_bomb.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = Vector(0,0,1)
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = 3

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 3 do
				local StartPos = trace.HitPos + Vector(math.random(-200,200),math.random(-200,200),0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(3,6), math.Rand(3,6) )
			end
		end
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BOMB_EXPLOSION", Pos )
			sound.Play( "LVS.BOMB_EXPLOSION_DYNAMIC", Pos )
		end )
	end

	for i = 1, 10 do
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1, 10 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

		if not particle then continue end

		particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * scale )
		particle:SetDieTime( (i / 8) * DieTime )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( 20 * i * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
		particle:SetGravity( Vector(0,0,-600) * scale )
		particle:SetCollide( false )
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if particle then
			local ang = i * 15
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(1500,2000)

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( math.Rand(1,3) )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 )
			particle:SetEndSize( 600 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		local vel = VectorRand() * math.Rand(800,1600)
		vel.z = math.Rand(1000,4000)

		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.random(5,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -2000 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -450 * InvScale, 30,30, Color( 255, 200, 150, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -500 * InvScale, 30,30, Color( 255, 200, 150, 100 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -550 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 600 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
	end
end

--addons/lvs_base/lua/effects/lvs_explosion_nodebris.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.EXPLOSION", Pos )
	end

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if not IsValid( self ) then return end

			local p = Pos + VectorRand() * 10 * i
			
			self:Explosion( p, math.Rand(0.5,0.8) )
		end)
	end
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( math.Rand(0.75,1.5) * scale )
		particle:SetAirResistance( math.Rand(200,600) ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( math.Rand(60,120) * scale )
		particle:SetEndSize( math.Rand(160,280) * scale )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( math.Rand(60,120) * scale )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_firetrail.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	self.Scale = data:GetScale()
	self.DieTime = CurTime() + data:GetMagnitude()
	self.Pos = data:GetStart()
	
	if not IsValid( self.Entity ) then return end

	self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.Pos ), false )
end


function EFFECT:Think()
	if IsValid( self.Entity ) then
		local Pos = self.Entity:LocalToWorld( self.Pos )

		local T = CurTime()

		if (self.nextDFX or 0) < T then
			self.nextDFX = T + 0.05

			if self.Emitter then
				local particle = self.Emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( 3 )
					particle:SetAirResistance( 0 )
					particle:SetStartAlpha( 150 )
					particle:SetStartSize( 150 * self.Scale )
					particle:SetEndSize( math.Rand(200,300) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 100 )
					particle:SetColor( 40,40,40 )
					particle:SetGravity( Vector( 0, 0, 0 ) )
					particle:SetCollide( false )
				end

				local particle = self.Emitter:Add( "effects/lvs_base/fire", Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( math.random(40,80) / 100 )
					particle:SetAirResistance( 0 ) 
					particle:SetStartAlpha( 255 )
					particle:SetStartSize( 130 * self.Scale )
					particle:SetEndSize( math.Rand(50,100) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 180 )
					particle:SetColor( 255,255,255 )
					particle:SetGravity( Vector( 0, 0, 70 ) )
					particle:SetCollide( false )
				end

				for i = 0,3 do
					local particle = self.Emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos + VectorRand() * 100 * self.Scale )

					if particle then
						particle:SetVelocity( VectorRand() * 100 * self.Scale )
						particle:SetDieTime( math.random(30,60) / 100 )
						particle:SetAirResistance( 0 ) 
						particle:SetStartAlpha( 255 )
						particle:SetStartSize( 70 * self.Scale )
						particle:SetEndSize( math.Rand(25,80) * self.Scale )
						particle:SetRoll( math.Rand(-1,1) * 180 )
						particle:SetColor( 255,255,255 )
						particle:SetGravity( Vector( 0, 0, 40 ) )
						particle:SetCollide( false )
					end
				end
			end
		end

		if self.DieTime < CurTime() then 
			if self.Emitter then
				self.Emitter:Finish()
			end

			return false
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
end

--addons/lvs_starwars/lua/effects/lvs_hsd_dish_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_primary" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), -Muzzle.Ang:Right() * 50000 )
		end
	end

	self.SpawnTime = CurTime()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetProjectorBeam() then
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local T = CurTime()

	local Mul = math.min( math.max( 1.5 - (T - self.SpawnTime), 0 ) ^ 2, 1 )

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = -Muzzle.Ang:Right()
	local StartPos = Muzzle.Pos
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, (16 + math.random(0,3)) * Mul, 1, 0, Color(255,0,0,255) )
	render.DrawBeam( StartPos, EndPos, (4 + math.random(0,2)) * Mul, 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A * Mul, A * Mul, Color(255,0,0,255) )
	render.DrawSprite( StartPos, B * Mul, B * Mul, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(255,0,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if (self._Next or 0) > T then return end

	self._Next = T + 0.02

	local emitter = ParticleEmitter( EndPos, false )

	if not emitter or not IsValid( emitter ) then return end

	local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
	
	for i = 0, 3 do
		local particle = emitter:Add( "sprites/light_glow02_add", EndPos )

		local vel = VectorRand() * 250 + Trace.HitNormal

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 1 )
	end

	local Dist = (StartPos - EndPos):Length()

	local invMul = (1 - Mul)

	for i = 0, Dist, 25 do
		local Pos = StartPos + Dir * i

		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand()  * 150
		
		if not particle then continue end

		particle:SetVelocity( vel + vel * invMul )
		particle:SetDieTime( 0.1 + 0.15 * invMul )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand( 1, 5 ) + invMul * 2 )
		particle:SetEndSize( 0 )
		particle:SetColor( 50 + 205 * Mul, 0, 0 )
		particle:SetAirResistance( 0 )
		particle:SetRoll( math.Rand(-10,10) )
		particle:SetRollDelta( math.Rand(-10,10) )
		particle:SetGravity( Vector(0,0,-600 * invMul) )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

--addons/lvs_starwars/lua/effects/lvs_laser_charge.lua:

EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.ID = data:GetAttachment()

	if not IsValid( self.Ent ) then return end

	
	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	self.Emitter = ParticleEmitter( Pos, false )
	self.Particles = {}
end

function EFFECT:Think()
	if (self.DieTime or 0) < CurTime() or not IsValid( self.Ent ) then 
		if IsValid( self.Emitter ) then
			self.Emitter:Finish()
		end

		return false
	end

	self:DoSpark()

	return true
end

function EFFECT:DoSpark()
	local T = CurTime()

	if (self._Next or 0) > T then return end

	self._Next = T + 0.01

	if not IsValid( self.Emitter ) then return end

	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos
	local Dir = VectorRand() * 25

	for id, particle in pairs( self.Particles ) do
		if not particle then
			self.Particles[ id ] = nil

			continue
		end

		particle:SetGravity( (Pos - particle:GetPos()) * 50 )
	end

	local particle = self.Emitter:Add( "sprites/rico1", Pos + Dir )

	if not particle then return end

	particle:SetDieTime( 0.25 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.Rand( 1, 5 ) )
	particle:SetEndSize( 0 )
	particle:SetColor( 255, 0, 0 )
	particle:SetAirResistance( 0 )
	particle:SetRoll( math.Rand(-10,10) )
	particle:SetRollDelta( math.Rand(-10,10) )

	table.insert( self.Particles, particle )
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	if Scale <= 0 then return end

	local rnd = VectorRand() * math.Rand(0,0.5)

	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( att.Pos, 30 *(1 - Scale), 30 * (1 - Scale), Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat ) 
	render.DrawSprite( att.Pos + rnd, 120 *  (1 - Scale), 120 * (1 - Scale), Color(255,0,0,255) ) 
end
	

--addons/lvs_starwars/lua/effects/lvs_laser_green_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 100, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_yellow.lua:

EFFECT.MatBeam = Material("effects/spark")
EFFECT.MatSprite = Material("sprites/light_glow02_add")

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS(pos, pos + dir * 50000)
end

function EFFECT:Think()
	if not LVS:GetBullet(self.ID) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet(self.ID)

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial(self.MatSprite)
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color(200, 150, 0))

	render.SetMaterial(self.MatBeam)
	render.DrawBeam(endpos - dir * len, endpos + dir * len, 45, 1, 0, Color(200, 150, 0))
	render.DrawBeam(endpos - dir * len, endpos + dir * len, 15, 1, 0, Color(255, 255, 255, 255))
end

--addons/lvs_base/lua/effects/lvs_missiletrail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 60 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor(40,40,40)
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity

	if not IsValid( ent ) then return end

	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_physics_dust.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local MatDebris = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local Dir = Ent:GetForward()

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	local VecCol = render.GetLightColor( Pos + Vector(0,0,10) ) * 0.5 + Vector(0.3,0.25,0.15)

	if emitter and emitter.Add then
		for i = 1, 3 do
			local particle = emitter:Add( MatDebris[math.random(1,#MatDebris)], Pos + VectorRand(-10,10) )
			if particle then
				particle:SetVelocity( Vector(0,0,150) - Dir * 150 )
				particle:SetDieTime( 0.2 )
				particle:SetAirResistance( 60 ) 
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 255 )
				particle:SetStartSize( 15 )
				particle:SetEndSize( 50 )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				particle:SetColor( VecCol.x * 130,VecCol.y * 100,VecCol.z * 60 )
				particle:SetGravity( Vector( 0, 0, -600 ) )
				particle:SetCollide( false )
			end
		end

		local Right = Ent:GetRight() 
		Right.z = 0
		Right:Normalize()

		for i = -1,1,2 do
			local particle = emitter:Add( Materials[math.random(1,#Materials)], Pos + Vector(0,0,10)  )
			if particle then
				particle:SetVelocity( -Dir * 400 + Right * 150 * i )
				particle:SetDieTime( math.Rand(0.5,1) )
				particle:SetAirResistance( 150 ) 
				particle:SetStartAlpha( 50 )
				particle:SetStartSize( -80 )
				particle:SetEndSize( 400 )
				particle:SetColor( VecCol.x * 255,VecCol.y * 255,VecCol.z * 255 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end
	end
end


function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/lvs_base/lua/effects/lvs_physics_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos + VectorRand(-10,10) - Vector(0,0,20) )
		if particle then
			particle:SetVelocity( Vector(0,0,250) )
			particle:SetDieTime( 0.8 )
			particle:SetAirResistance( 60 ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 100 )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = (self.DieTime - self.LifeTime - CurTime()) / self.LifeTime
		local S = 200 - Scale * 600
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--addons/lvs_base/lua/effects/lvs_tracer_orange.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 50, 0, 255 ) )
end

--addons/npc_droppod_tool/lua/effects/m9k_gdcw_s_blood_cloud/init.lua:

function EFFECT:Init(data)

	self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light
	self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect
	self.Scale 		= data:GetScale()		// Scale determines how large the effect is
	self.Radius 		= data:GetRadius() or 1		// Radius determines what type of effect to create, default is Concrete
	self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect
	self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations
	self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"
	self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal
	self.DebrizzlemyNizzle 	= 10+data:GetScale()		// Debrizzle my Nizzle is how many "trails" to make
	self.Size 		= 5*self.Scale		// Size is exclusively for the explosion "trails" size
	self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error
	sound.Play( "physics/flesh/flesh_squishy_impact_hard" .. math.random(1,4) .. ".wav", self.Pos, 180, 100 )

	self:Blood()

end

 function EFFECT:Blood()
 
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand(1,2) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150,360) )
		Smoke:SetRollDelta( math.Rand(-2,2) )
		Smoke:SetColor( 70,35,35 )
		Smoke:SetGravity( Vector(math.Rand(-50,50)*self.Scale, math.Rand(-50,50)*self.Scale, math.Rand(0,-200)) )	
		Smoke:SetAirResistance( 400 )
		end
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand(1,4) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150,360) )
		Smoke:SetRollDelta( math.Rand(-2,2) )
		Smoke:SetColor( 70,35,35 )
		Smoke:SetGravity( Vector(math.Rand(-50,50)*self.Scale,math.Rand(-50,50)*self.Scale,math.Rand(-50,-300)) )	
		Smoke:SetAirResistance( 400 )
		end
		end

		for i=1, 5 do		// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( 300*self.Scale )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor( 255,255,255 )
		Flash:SetAirResistance( 200 )
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized()*400*self.Scale )
		Debris:SetDieTime( math.random(0.3,0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0,360) )
		Debris:SetRollDelta( math.Rand(-5,5) )
		Debris:SetColor( 70,35,35 )
		Debris:SetGravity( Vector(0,0,-600) )
		Debris:SetAirResistance( 30 )
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )
		end
		end

end

function EFFECT:Think( )
return false
end
function EFFECT:Render()
end
--addons/npc_droppod_tool/lua/effects/m9k_gdcw_s_boom/init.lua:

function EFFECT:Init(data)

	self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light			//
	self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect			//
	self.Scale 		= data:GetScale()		// Scale determines how large the effect is			//
	self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect			//
	self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations			//
	self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"	//
	self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal			//
	self.DebrizzlemyNizzle = math.random(10,20)		// Debrizzle my Nizzle is how many "trails" to make			//
	self.Size 		= 5*self.Scale		// Size is exclusively for the explosion "trails" size			//
	self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error			//
	sound.Play( "ambient/explosions/explode_1.wav", self.Pos, 100, math.Rand(80,120) )

	self:Dust()

end
 
 function EFFECT:Dust()

		for i=1, 200*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec*math.Rand(100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand(2,3) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150,360) )
		Dust:SetRollDelta( math.Rand(-1,1) )
		Dust:SetColor( 80,80,80 )
		Dust:SetGravity( Vector(0,0,math.Rand(-100,-400)) )	
		Dust:SetAirResistance( 150 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec*math.Rand(100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand(1,5)*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150,360) )
		Dust:SetRollDelta( math.Rand(-1,1) )
		Dust:SetColor( 90,85,75 )
		Dust:SetGravity( Vector(math.Rand(-200,200),math.Rand(-200,200),math.Rand(10,100)) )
		Dust:SetAirResistance( 250 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec*math.random(0,700)*self.Scale + VectorRand():GetNormalized()*math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random(1,2)*self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale )
		Debris:SetRoll( math.Rand(0,360) )
		Debris:SetRollDelta( math.Rand(-5,5) )
		Debris:SetColor( 60,60,60 )	
		Debris:SetGravity( Vector(0,0,-600) )		
		Debris:SetAirResistance( 40 )
		end
		end

		local Angle = self.DirVec:Angle()
		for i=1, self.DebrizzlemyNizzle do		// This part makes the trailers
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(0.5,3) + (DustRing*math.Rand(3,7))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )	
			particle1:SetVelocity( (VectorRand():GetNormalized()*math.Rand(1,2)*self.Size) + (RanVec*self.Size*k*3.5) )
			particle1:SetDieTime( math.Rand(0.5,4)*self.Scale )
			particle1:SetStartAlpha( math.Rand(90,100) )
			particle1:SetEndAlpha( 0 )
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random(-500,500)/100 )
			particle1:SetRollDelta( math.random(-0.5,0.5) )
			particle1:SetColor( 110+Rcolor,107+Rcolor,100+Rcolor )
			particle1:SetGravity( (VectorRand():GetNormalized()*math.Rand(5,10)*self.Size) + Vector(0,0,-50) )
			particle1:SetAirResistance( 400 )
			end

		end

 end

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--addons/wos-grandmaster-einf/lua/effects/rb655_force_repulse_in.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	--local rad = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_splash_warpring1", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 100 )
		particle:SetEndSize( 0 )

		particle:SetStartAlpha( 0 )
		particle:SetEndAlpha( 200 )

		particle:SetColor( 255, 255, 255 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end

	--[[local particle = emitter:Add( "effects/select_ring", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.3 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( math.random( 38, 42 ) )
		particle:SetEndSize( math.random( 48, 52 ) )

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 255 )

		particle:SetColor( 0, 255, 255 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end]]

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/rb655_saber_underwater.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	local number_lol = 4

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		local particle = emitter:Add( "effects/bubble", pos2 + Vector( math.random( -number_lol / 2, number_lol / 2 ), math.random( -number_lol / 2, number_lol / 2 ), math.random( -number_lol / 2, number_lol / 2 ) ) )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( math.random( 1, 4 ) )
			particle:SetEndSize( math.random( 1, 4 ) )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( 255, 255, 255 )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/rw_sw_impact_aqua.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_aqua" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_black.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_black" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_lightblue.lua:
local MaterialGlow		= Material( "cs574/impacts/sw_laser_bit_lightblue" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_purple.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_purple" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_white.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_white" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_laser_blue.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 30
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_laser_green.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material("effects/sw_laser_green_main")
local MaterialFront			= Material("effects/sw_laser_green_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/serv_passive_poison.lua:
EFFECT.Mat1 = Material( "particle/particle_ring_wave_8" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HPMax = math.max( math.Round( data:GetMagnitude() ),0)
	self.HealingAm = 0

	self.Life = 0

	self.Color = Color(91, 47, 82, 255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.HealingAm = math.Clamp((self.Entity:GetMaxHealth()-self.Entity:Health())/2, 0, 10)

	self.FollowPlayer = self.Entity:GetPos()

	self.Life = self.Life + FrameTime() * 6

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles
	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat1, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*15) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(1) 
		particle:SetStartAlpha( 80+(self.HealingAm*5) )
		particle:SetEndAlpha(0)
		particle:SetStartSize(30) 
		particle:SetEndSize(70)
		particle:SetAngles( Angle(math.random( 0, 360 ),math.random( 0, 360 ),math.random( 0, 360 )) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetRoll(math.random( 0, 360 ))
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, 0 ) ) 
		particle:SetVelocity( Vector(math.random( -30, 30 ), math.random( -30, 30 ), math.random( 50, 75 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()
end
--lua/effects/serv_passive_stun.lua:
EFFECT.BeatMat = Material( "sprites/tp_beam001" )
EFFECT.SprMat = Material( "particle/particle_ring_wave_8_15ob_nofog" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(150,150,250,255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.FollowPlayer = self.Entity:GetPos()+Vector(0,0,50)

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles

	render.SetMaterial( self.SprMat )
	render.DrawSprite( 
		self.FollowPlayer,
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		self.Color
	)

	render.SetMaterial( self.BeatMat )
	for i = 1, 5 do
		local randvec = VectorRand()
		randvec.z = -2
		render.DrawBeam( 
			self.FollowPlayer + (VectorRand()*5),
			self.FollowPlayer + (randvec*(math.min(self.Life*5,50)+math.random( -15, 45 ))),
			math.random(8,14),
			5,
			3,
			self.Color
		)
	end

end
--addons/egm_tfa_weapons_zdisabled/lua/effects/snx_passive_stun.lua:
EFFECT.BeatMat = Material( "sprites/tp_beam001" )
EFFECT.SprMat = Material( "particle/particle_ring_wave_8_15ob_nofog" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(150,150,250,255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.FollowPlayer = self.Entity:GetPos()+Vector(0,0,50)

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles

	render.SetMaterial( self.SprMat )
	render.DrawSprite( 
		self.FollowPlayer,
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		self.Color
	)

	render.SetMaterial( self.BeatMat )
	for i = 1, 5 do
		local randvec = VectorRand()
		randvec.z = -2
		render.DrawBeam( 
			self.FollowPlayer + (VectorRand()*5),
			self.FollowPlayer + (randvec*(math.min(self.Life*5,50)+math.random( -15, 45 ))),
			math.random(8,14),
			5,
			3,
			self.Color
		)
	end

end
--addons/egm_tfa_grenades/lua/effects/tfa_csgo_impactsmoke/init.lua:
-- smoke_grenade_effect.lua

EFFECT.Mat = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Position = data:GetOrigin()
	self.Normal = data:GetNormal()
	self.Scale = 20 -- Replace with your desired scale
	self.Life = 1 -- Replace with your desired life duration

	self:SetRenderBounds( Vector( -128, -128, -128 ), Vector( 128, 128, 128 ) )
end

function EFFECT:Think()
	return CurTime() < self.Life
end

function EFFECT:Render()
	local delta = ( self.Life - CurTime() ) / self.Life
	local alpha = 255 * delta

	render.SetMaterial( self.Mat )
	render.DrawQuadEasy( self.Position + self.Normal * 4, self.Normal, self.Scale, self.Scale, Color( 200, 200, 200, alpha ) )
end

--lua/effects/tfa_csgo_smokeexpl/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 100 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 400) )
			if i <= 1 then 
				particle:SetDieTime( 0.5 )
			else
				particle:SetDieTime( math.Rand( 23,28 ) )
			end
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 44 )
			particle:SetEndSize( 144 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 65, 65, 65 ) 
			particle:SetAirResistance( 100 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/tfa_base/lua/effects/tfa_metal_impact/init.lua:
local gravity_cv = GetConVar("sv_gravity")
EFFECT.VelocityRandom = 0.25
EFFECT.VelocityMin = 95
EFFECT.VelocityMax = 125
EFFECT.ParticleCountMin = 4
EFFECT.ParticleCountMax = 7
EFFECT.ParticleLife = 1.3

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.LifeTime = 0.1
	self.DieTime = CurTime() + self.LifeTime
	self.PartMult = 0.2
	self.Grav = Vector(0, 0, -gravity_cv:GetFloat())
	self.SparkLife = 1
	local emitter = ParticleEmitter(self.StartPos)
	local partcount = math.random(self.ParticleCountMin, self.ParticleCountMax)

	--Sparks
	for _ = 1, partcount do
		local part = emitter:Add("effects/yellowflare", self.StartPos)
		part:SetVelocity(Lerp(self.VelocityRandom, self.Dir, VectorRand()) * math.Rand(self.VelocityMin, self.VelocityMax))
		part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
		part:SetStartAlpha(255)
		part:SetStartSize(math.Rand(2, 4))
		part:SetEndSize(0)
		part:SetRoll(0)
		part:SetGravity(self.Grav)
		part:SetCollide(true)
		part:SetBounce(0.55)
		part:SetAirResistance(0.5)
		part:SetStartLength(0.2)
		part:SetEndLength(0)
		part:SetVelocityScale(true)
		part:SetCollide(true)
	end

	--Impact
	local part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(255)
	part:SetStartSize(15 * self.PartMult)
	part:SetDieTime(self.LifeTime * 1)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/tfa_muzzleflash_fubar/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 255
        dlight.g                = 109
        dlight.b                = 0
        dlight.Brightness = 6.0
        dlight.size     = 110
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_revolver/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1.25
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_sniper_energy/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 2
EFFECT.FlashSize = 2
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.45
EFFECT.HeatSize = 2
EFFECT.Color = Color(128,192,255)
EFFECT.ColorSprites = true

--addons/tfa_base/lua/effects/tfa_penetrate/init.lua:
local PenetColor = Color(255, 255, 255, 255)
local PenetMat = Material("trails/smoke")
local PenetMat2 = Material("effects/yellowflare")
local cv_gv = GetConVar("sv_gravity")
local cv_sl = GetConVar("cl_tfa_fx_impact_ricochet_sparklife")

--local cv_sc = GetConVar("cl_tfa_fx_impact_ricochet_sparks")
local DFX = {
	["AR2Tracer"] = true,
	["Tracer"] = true,
	["GunshipTracer"] = true,
	["GaussTracer"] = true,
	["AirboatGunTracer"] = true,
	["AirboatGunHeavyTracer"] = true
}

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Dir:Normalize()
	self.Len = 32
	self.EndPos = self.StartPos + self.Dir * self.Len
	self.LifeTime = 0.75
	self.DieTime = CurTime() + self.LifeTime
	self.Thickness = 1
	self.Grav = Vector(0, 0, -cv_gv:GetFloat())
	self.PartMult = data:GetRadius()
	self.SparkLife = cv_sl:GetFloat()
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end

	if self.WeaponEnt.TracerPCF then
		local traceres = util.QuickTrace(self.StartPos, self.Dir * 9999999, Entity(math.Round(data:GetScale())))
		self.EndPos = traceres.HitPos or self.StartPos
		local efn = self.WeaponEnt.TracerName
		local spos = self.StartPos
		local cnt = math.min(math.Round(data:GetMagnitude()), 6000)

		timer.Simple(cnt / 1000000, function()
			TFA.ParticleTracer(efn, spos, traceres.HitPos or spos, false)
		end)

		return
	end

	local tn = self.WeaponEnt.BulletTracerName

	if tn and tn ~= "" and not DFX[tn] then
		local fx = EffectData()
		fx:SetStart(self.StartPos)
		local traceres = util.QuickTrace(self.StartPos, self.Dir * 9999999, Entity(math.Round(data:GetScale())))
		self.EndPos = traceres.HitPos or self.StartPos
		fx:SetOrigin(self.EndPos)
		fx:SetEntity(self.WeaponEnt)
		fx:SetMagnitude(1)
		util.Effect(tn, fx)
		SafeRemoveEntityDelayed(self, 0)
		--Sparks
		--Impact

		return
	else
		local emitter = ParticleEmitter(self.StartPos)
		--[[
		for i = 1, cv_sc:GetFloat() * self.PartMult * 0.1 do
			local part = emitter:Add("effects/yellowflare", self.StartPos)
			part:SetVelocity((self.Dir + VectorRand() * 0.5) * math.Rand(75, 185))
			part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
			part:SetStartAlpha(255)
			part:SetStartSize(math.Rand(2, 4))
			part:SetEndSize(0)
			part:SetRoll(0)
			part:SetGravity(self.Grav)
			part:SetCollide(true)
			part:SetBounce(0.55)
			part:SetAirResistance(0.5)
			part:SetStartLength(0.2)
			part:SetEndLength(0)
			part:SetVelocityScale(true)
			part:SetCollide(true)
		end
		]]
		--
		local part = emitter:Add("effects/select_ring", self.StartPos)
		part:SetStartAlpha(225)
		part:SetStartSize(1)
		part:SetDieTime(self.LifeTime / 5)
		part:SetEndSize(0)
		part:SetEndAlpha(0)
		part:SetRoll(math.Rand(0, 360))
		part:SetColor(200, 200, 200)
		part = emitter:Add("effects/select_ring", self.StartPos)
		part:SetStartAlpha(255)
		part:SetStartSize(1.5 * self.PartMult)
		part:SetDieTime(self.LifeTime / 6)
		part:SetEndSize(0)
		part:SetEndAlpha(0)
		part:SetRoll(math.Rand(0, 360))
		part:SetColor(200, 200, 200)
		emitter:Finish()
	end
end

function EFFECT:Think()
	if self.DieTime and (CurTime() > self.DieTime) then return false end

	return true
end

function EFFECT:Render()
	if self.DieTime then
		local fDelta = (self.DieTime - CurTime()) / self.LifeTime
		fDelta = math.Clamp(fDelta, 0, 1)
		render.SetMaterial(PenetMat)
		local color = ColorAlpha(PenetColor, 32 * fDelta)
		local precision = 16
		local i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), self.Thickness * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end

		render.SetMaterial(PenetMat2)
		i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), self.Thickness / 3 * 2 * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end
	end
end
--addons/tfa_base/lua/effects/tfa_tracer_cryo/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(255, 255, 255, 255) --Color(225,225,225,225)
EFFECT.Col2 = Color(65, 128, 255, 200)
EFFECT.Speed = 1024*3
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos, Vector(1000,1000,1000))
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
render.SetMaterial(self.Mat)
lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
local startbeampos = LerpVector(self.Life, self.StartPos, self.EndPos)
local endbeampos = LerpVector(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--addons/tfa_base/lua/effects/tfa_tracer_plasma/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(128, 255, 255) --Color(225,225,225,225)
EFFECT.Col2 = Color(97, 218, 255)
EFFECT.Speed = 4096
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
render.SetMaterial(self.Mat)
lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
local startbeampos = Lerp(self.Life, self.StartPos, self.EndPos)
local endbeampos = Lerp(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--addons/vfire_flamethrower/lua/effects/vfirethrower_jet.lua:
function EFFECT:Init(data)
	self.wep = data:GetEntity()
	self.owner = self.wep:GetOwner()

	self:SetRenderOrigin(self.owner:GetPos())
	local mins, maxs = self.owner:GetRenderBounds()
	self:SetRenderBounds(mins, maxs, Vector(500, 500, 500))

	-- Used to determine when to spawn the next clientside fireball
	self.lastFireBall = 0

	-- Used in the think hook to avoid early dismissals
	self.startTime = CurTime()
end

local beamMat = Material("effects/combinemuzzle2_dark")
function EFFECT:Render()
	local eyeAngs = self.owner:EyeAngles()

	local pos
	if GetViewEntity() == owner then
		pos = self.wep:GetShootPosition()
	else
		pos = self.wep:GetShootPosition()
	end

	local vel = eyeAngs:Forward() * math.Rand(2300, 2700)

	-- Should we disable the clientside balls assistance for singleplayer, where it's not needed?
	if CurTime() > self.lastFireBall then
		local lifeTime = math.Rand(0.3, 0.7)
		CreateCSVFireBall(10, pos, vel * 0.3415, lifeTime)
		self.lastFireBall = CurTime() + 0.01
	end

	-- Draw a beam
	render.SetMaterial(beamMat)
	render.DrawBeam(pos, pos + vel * 0.0335, math.Rand(6, 10), math.Rand(0, 1), 1, Color(255, 255, 255, 255))

	-- Draw following particles
	local pe = ParticleEmitter(pos, false)
	local p = pe:Add("effects/combinemuzzle2_dark", pos + vel * 0.003)
		p:SetDieTime(0.2)
		p:SetVelocity(vel)
		p:SetGravity(Vector(0, 0, -1750))
		p:SetAirResistance(math.Rand(600, 1000))
		p:SetStartAlpha(math.Rand(100, 200))
		p:SetEndAlpha(0)
		p:SetStartSize(math.Rand(3, 4))
		p:SetEndSize(math.Rand(8, 30))
		p:SetRoll(math.Rand(0, math.pi))
		p:SetRollDelta(math.Rand(-40, 40))
	pe:Finish()

	-- Draw a light
	local dLight = DynamicLight(self.wep:EntIndex())
	if dLight then
		dLight.Pos = pos
		dLight.r = 255
		dLight.g = 100
		dLight.b = 80
		dLight.Brightness = 2
		dLight.Decay = 30000
		dLight.Size = 250
		dLight.DieTime = CurTime() + 0.2
	end
end

-- Kill the effect
function EFFECT:Think()
	if IsValid(self.owner) then
		self:SetRenderOrigin(self.owner:GetPos())
		local mins, maxs = self.owner:GetRenderBounds()
		self:SetRenderBounds(mins, maxs, Vector(500, 500, 500))
	end

		if !IsValid(self.wep) or self.wep:GetClass() != "weapon_vfirethrower" then return false end
		if CurTime() < self.startTime + 0.1 then return true end
	return self.wep:GetShooting()
end
--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_electrictouch/init.lua:

PrecacheParticleSystem( "[4]arcs_electric_1_small" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local time = data:GetRadius()
	
	self.Particle = CreateParticleSystem( ent, "[4]arcs_electric_1_small", PATTACH_ABSORIGIN_FOLLOW, nil, ent:GetUp()*30 ) 
	self.LifeTime = CurTime() + time
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_fireflood/init.lua:

PrecacheParticleSystem( "[1]flamethrower_basic" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local vec = data:GetAngles()
	
	self.Particle = CreateParticleSystem( ent, "[1]flamethrower_basic", PATTACH_POINT, ent:LookupAttachment( "anim_attachment_LH" ) ) 
	self.Particle:SetControlPointOrientation( 0, vec:Forward(), vec:Right(), vec:Up() )
	self.LifeTime = CurTime() + 0.25
	
end

function EFFECT:Think()
	
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/wos_unstable_discharge/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		if ( particle ) then
			
			local velocity = pos2 - pos
			local angle = velocity:Angle()
			
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( vector_origin )
			particle:SetVelocity( velocity )

			particle:SetStartSize( 2 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 )/8 )
			particle:SetEndAlpha( 0 )
		
			
			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( angle )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--gamemodes/egmrp/gamemode/core/propertymodel/cl_propertymodel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Property model      --
---------------------------------------


-- Contains a list of all properties
PropertyModel.PropertyList = {}

-- Adds a property to the property list.
-- Properties in this list are used when creating a property list.
-- The order calling this function will be the order in the propertylist.
--
-- @param String key
-- @param String name
-- @param String info
-- @param String typeInfo
-- @param Table/Function values
-- @param Function inList
-- @param Number sort
function PropertyModel:AddPropertyToList(key, name, info, typeInfo, values, inList, sort, category)
    local oldPropertyList = self.PropertyList[key]
    if istable(oldPropertyList) then
        sort = sort or oldPropertyList.Sort
    else
        sort = sort or table.Count(self.PropertyList)
    end

    category = category or egmt("propertymodel.category_base")
    self.PropertyList[category] = self.PropertyList[category] or {}

    self.PropertyList[category][key] = {
        key = key,
        name = name,
        info = info,
        typeInfo = typeInfo,
        values = values,
        inList = inList,
        Sort = sort,
        Category = category,
    }
end

-- Returns a table containing all properties that should appear in a property list.
-- Merges the input of AddPropertyToList with the property table from AddProperty.
-- Also calls the values and inList function and saves the output.
--
-- @param VarArg ...
-- @return Table propertyList
function PropertyModel:GetPropertyList(...)
    local propertyList = {}

    for category, categoryData in SortedPairs(self.PropertyList) do
        propertyList[category] = {}

        for _, propertyData in SortedPairsByMemberValue(categoryData, "Sort") do
            if isfunction(propertyData.inList) and not propertyData.inList(...) then
                continue
            end

            local property = self:GetProperty(propertyData.key)
            if not property then
                continue
            end

            -- Merge property data.
            table.Merge(property, propertyData)

            -- Call values function.
            if isfunction(property.values) then
                property.values = property.values(...)
            end

            table.insert(propertyList[category], property)
        end
    end

    hook.Run(self.Name .. ".GetPropertyList", propertyList, ...)

    return propertyList
end

-- Same like GetPropertyList but checks whether the property is in the whitelist.
--
-- @param VarArg ...
-- @return Table propertyList
function PropertyModel:GetCreationPropertyList(...)
    local propertyList = {}

    for category, categoryData in SortedPairs(self.PropertyList) do
        propertyList[category] = {}

        for _, propertyData in SortedPairsByMemberValue(categoryData, "Sort") do
            if isfunction(propertyData.inList) and not propertyData.inList(...) then
                continue
            end

            if istable(self.PropertiesAllowedOnCreationWhitelist) and not table.HasValue(self.PropertiesAllowedOnCreationWhitelist, propertyData.key) then
                continue
            end

            local property = self:GetProperty(propertyData.key)
            if not property then
                continue
            end

            -- Merge property data.
            table.Merge(property, propertyData)

            -- Call values function.
            if isfunction(property.values) then
                property.values = property.values(...)
            end

            table.insert(propertyList[category], property)
        end
    end

    hook.Run(self.Name .. ".GetCreationPropertyList", propertyList, ...)

    return propertyList
end

-- Tells the server to create a new property model after validating the data.
--
-- @param Table data
-- @param Table properties
-- @return Bool success
-- @return? Table errors
function PropertyModel:Create(data, properties)
    local propertyModel = self:Init()

    -- Init data and properties without validation.
    -- Validation is done later to get all errors with IsValid.
    -- (IsValid won't return correct errors, because SetData and SetProperty would not set the value)
    for k, v in pairs(data) do
        propertyModel:InitData(k, v, true)
    end

    for k, v in pairs(properties) do
        propertyModel:InitProperty(k, v, true)
    end

    local isValid, validationErrors = propertyModel:IsValid(true)
    if isValid then
        local canCreate, error = self:CanPlayerCreate(LocalPlayer(), data, properties)
        if not canCreate then
            return false, { error }
        end

        local info = CompressTable({
            data = self:ValuesToString(data),
            properties = self:ValuesToString(properties)
        })

        if self.CreationNetworkingInitialized then
            net.Start(self.Name .. ".Create")
                net.WriteInt(#info, 32)
                net.WriteData(info, #info)
            net.SendToServer()
        end

        return true
    end

    return false, validationErrors
end

-- Tells the server to create a new property model after validating the data.
--
-- @param Table data
-- @param Table properties
-- @return Table propertyModel
function PropertyModel:Load(data, properties)
    local propertyModel = self:Init()

    -- Initialize data after fixing data types.
    for k, v in pairs(self:FixDataTypes(data)) do
        propertyModel:InitData(k, v, true)
    end

    -- Initialize properties after fixing data types.
    for k, v in pairs(self:FixPropertiesTypes(properties)) do
        propertyModel:InitProperty(k, v, true)
    end

    hook.Run(self.Name .. ".Load", propertyModel)

    return propertyModel
end
--gamemodes/egmrp/gamemode/core/propertymodel/cl_propertylist.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

-- This function registers a property type panel, to be used in the property list.
--
-- @param String type
-- @param Function createPanel
function PropertyList:RegisterPropertyType(type)
    self.PropertyTypes = self.PropertyTypes or {}

    local propertyType = {
        Type = type
    }

    PROPERTY_TYPE = propertyType
    include("propertylist/" .. type .. ".lua")
    PROPERTY_TYPE = nil

    self.PropertyTypes[propertyType.Type] = propertyType
end

-- Searches for all property types and registers them.
function PropertyList:RegisterAllPropertyTypes()
    local propertyListFiles = file.Find("egmrp/gamemode/core/propertymodel/propertylist/*", "LUA")
    for _, propertyListFile in pairs(propertyListFiles) do
        local split = string.Split(propertyListFile, ".")
        self:RegisterPropertyType(split[1])
    end
end

PropertyList:RegisterAllPropertyTypes()

function PropertyList:CreatePropertyListCategory(parent, collapsibleCategory, categoryData, values, propertyModel, ignoreCanEdit)
	local canEditAtLeastOneProperty = false
	local ply = LocalPlayer()

	for _, propertyListData in SortedPairs(categoryData) do
		-- Get the property type.
		local propertyType = self.PropertyTypes[propertyListData.typeInfo]

		-- Skip, if the property type is not registered.
		if not propertyType then
			continue
		end

		-- Permission check.
		local canEdit

		-- If we are ignoring the canEdit check, set canEdit to false. (Used for inherited objects)
		if not ignoreCanEdit then
			if not propertyModel then
				canEdit = true
			else
				if isfunction(propertyType.CanEdit) then
					if  propertyType:CanEdit(ply, propertyListData, propertyModel) then
						canEdit = true
					end
				else
					canEdit = false
				end
			end
		else
			canEdit = false
		end

		if not isbool(canEdit) then
			canEdit = false
		end

		-- Write if one property can be edited.
		if canEdit then
			canEditAtLeastOneProperty = true
		end

		local collapsibleEntry = vgui.Create("DCollapsibleCategory", collapsibleCategory)
		collapsibleEntry:Dock(TOP)
		collapsibleEntry:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, 0)
		collapsibleEntry:InvalidateParent(true)

		collapsibleEntry:SetHeaderHeight(ScrH() * 0.02)
		collapsibleEntry:SetLabel("")
		function collapsibleEntry:Paint(ww, hh)
			local headerHeight = self:GetHeaderHeight()

			if self:GetExpanded() then
				if canEdit then
					draw.RoundedBox(0, 0, 0, ww, headerHeight, UI.ForegroundColor)
				else
					draw.RoundedBox(0, 0, 0, ww, headerHeight, Color(80, 80, 80))
				end
			else
				draw.RoundedBox(0, 0, 0, ww, headerHeight, UI.BackgroundColor2)
			end

			draw.SimpleText(propertyListData.name, "EGMText6", ScrW() * 0.001, headerHeight * 0.5, UI.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		if propertyModel then
			local databaseName = "PropertyList." .. propertyModel:GetModel().Name .. "." .. propertyListData.key .. ".Collapsed"
			collapsibleEntry:SetExpanded(cookie.GetNumber(databaseName, 0) == 0)

			function collapsibleEntry:OnToggle(expanded)
				cookie.Set(databaseName, expanded and 0 or 1)
			end
		end

		local propertyPanel = vgui.Create("DPanel", parent)
		parent.PropertyPanels[propertyListData.key] = propertyPanel

		propertyPanel:DockMargin(0, ScrH() * 0.005, 0, 0)
		propertyPanel:Dock(TOP)
		propertyPanel:InvalidateParent(true)

		propertyPanel:SetTooltip(propertyListData.info)
		propertyPanel.Paint = function(_, width, height)
		end

		collapsibleEntry:SetContents(propertyPanel)

		if istable(propertyType) then
			propertyType:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)

			values[propertyListData.key] = function()
				return propertyType:GetValue(propertyPanel)
			end
		end

		-- Adjust the height of the property model to the height of it's contents.
		propertyPanel:SizeToChildren(false, true)
		collapsibleEntry:SizeToChildren(false, true)
    end

    return canEditAtLeastOneProperty
end

-- Creates vgui elements for every property attachet to the parent and returns
-- a table containing functions to get the current value of every property.
-- If a propertymodel is given, it hat permission checks for whether you are allowed to edit the properties.
--
-- @param Panel parent
-- @param Table properties
-- @param Table propertyModel
-- @param Boolean ignoreCanEdit
-- @return Table values
-- @return Boolean canEditAtLeastOneProperty
function PropertyList:CreatePropertyList(parent, propertyList, propertyModel, ignoreCanEdit)
    -- Remove all panels from the panel. Allows refreshing a property list by calling the create function again.
    parent:Clear()
	parent:InvalidateLayout(true)

    parent.PropertyPanels = {}

	local scrollPos = parent:GetVBar():GetScroll()

    local canEditAtLeastOneProperty = false
    values = {}
    for category, categoryData in SortedPairs(propertyList) do
        local collapsibleCategory = vgui.Create("DCollapsibleCategory", parent)
        collapsibleCategory:DockMargin(ScrW() * 0.0025, ScrH() * 0.01, ScrW() * 0.0025, 0)
        collapsibleCategory:Dock(TOP)
		collapsibleCategory:InvalidateParent(true)

        collapsibleCategory:SetHeaderHeight(ScrH() * 0.02)
        collapsibleCategory:SetLabel("")
        function collapsibleCategory:Paint(ww, hh)
            local headerHeight = self:GetHeaderHeight()

            if self:GetExpanded() then
                draw.RoundedBox(0, 0, 0, ww, headerHeight, UI.ForegroundColor)
            else
                draw.RoundedBox(0, 0, 0, ww, headerHeight, UI.BackgroundColor2)
            end

            draw.SimpleText(category, "EGMText6", ScrW() * 0.001, headerHeight * 0.5, UI.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

		if propertyModel then
			local categoryDatabaseName = "PropertyListCategory." .. propertyModel:GetModel().Name .. "." .. category .. ".Collapsed"
			collapsibleCategory:SetExpanded(cookie.GetNumber(categoryDatabaseName, 0) == 0)
			function collapsibleCategory:OnToggle(expanded)
				cookie.Set(categoryDatabaseName, expanded and 0 or 1)
			end
		end

		local n = table.Count(parent.PropertyPanels)

		local canEdit = self:CreatePropertyListCategory(parent, collapsibleCategory, categoryData, values, propertyModel, ignoreCanEdit)
		if canEdit then
			canEditAtLeastOneProperty = true
		end

		-- Remove the category if no properties were added.
		if table.Count(parent.PropertyPanels) == n then
			collapsibleCategory:Remove()
		end
    end

    local spacer = vgui.Create("DPanel", parent)
    spacer:Dock(TOP)
    spacer:SetHeight(ScrH() * 0.01)
    spacer.Paint = function(_, width, height)
    end

	-- Move the scrollbar to the previous position. (SetScroll doesn't work for some reason)
	parent:GetVBar():AnimateTo(scrollPos, 0)

    return values, canEditAtLeastOneProperty
end

-- Alias for Backwards compatibility.
function CreatePropertyList(...)
    return PropertyList:CreatePropertyList(...)
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/boolean.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or false
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local values = propertyListData.values or {}
	local yesString = values[1] or egmt("propertymodel.yes")
	local noString = values[2] or egmt("propertymodel.no")

	local booleanProperty
	if canEdit then
		booleanProperty = vgui.Create("DButton", propertyPanel)

		function booleanProperty:Paint(width, height)
			local green = GetColor("green")
			local red = GetColor("red")

			if self.Value then
				draw.RoundedBox(0, 0, 0, width * 0.7, height, green)
				draw.RoundedBox(0, width * 0.7, 0, width * 0.3, height, red)
				draw.SimpleText(yesString, "EGMText6", width * 0.35, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.RoundedBox(0, 0, 0, width * 0.3, height, green)
				draw.RoundedBox(0, width * 0.3, 0, width * 0.7, height, red)
				draw.SimpleText(noString, "EGMText6", width * 0.65, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end

		function booleanProperty:DoClick()
			booleanProperty.Value = not booleanProperty.Value
		end
	else
		booleanProperty = vgui.Create("DLabel", propertyPanel)

		function booleanProperty:Paint(width, height)
			if self.Value then
				draw.SimpleText(yesString, "EGMText6", width, height * 0.5, UI.TextColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(noString, "EGMText6", width, height * 0.5, UI.TextColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			end
		end
	end

	propertyPanel.BooleanProperty = booleanProperty
	booleanProperty:SetHeight(ScrH() * 0.02)
	booleanProperty:Dock(FILL)
	booleanProperty:SetText("")
	booleanProperty.Value = currentValue
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.BooleanProperty) then
		return false
	end

	return propertyPanel.BooleanProperty.Value
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, false) then
		return true
	end

	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, true) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/string.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or ""
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local stringProperty = vgui.Create("DTextEntry", propertyPanel)
	propertyPanel.StringProperty = stringProperty

	stringProperty:SetHeight(ScrH() * 0.02)
	stringProperty:Dock(FILL)
	stringProperty:SetValue(currentValue)
	stringProperty:SetDisabled(not canEdit)
	stringProperty:SetFont("EGMText6")
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.StringProperty) then
		return ""
	end

	return propertyPanel.StringProperty:GetValue()
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Checking an empty string should be sufficient.
	-- If the player can edit an empty string, he can edit all strings.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, propertyListData.default or "") then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/loading/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Loading | Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Background for the loading screen.
Loading.Background = "backgrounds/xenonuke_gateway_station.png"
--gamemodes/egmrp/gamemode/core/loading/cl_loading.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Loading | Client          --
---------------------------------------

-- List of all package types.
Loading.PackageTypes = {}
Loading.CurrentPackageType = 0

-- Registers a new package type.
--
-- @param String typeName
-- @param String name
-- @param Function handleData(data) - handles the transmitted data.
function Loading:RegisterPackageType(typeName, name, handleData)
    local packageType = {
        ["TypeName"] = typeName,
        ["Name"] = name,
        ["HandleData"] = handleData
    }

    self.PackageTypes[typeName] = packageType
end

-- Request the next package from the server.
function Loading:RequestNextPackage()
    local packageIdentifier = self.PackageTypeCounts[self.CurrentPackageType]
    local packageType = self.PackageTypes[packageIdentifier.TypeName]

    self:AppendLog(egmt("loading.process", packageType.Name))

    net.Start("Loading.RequestPackage")
        net.WriteString(packageType.TypeName)
        net.WriteInt(self.CurrentPackageIndex, 32)
    net.SendToServer()

    self:UpdateProgress()
end

-- Receives the package type counts from the server.
net.Receive("Loading.Init", function()
    Loading.PackageTypeCounts = net.ReadTable()

    Loading.CurrentPackageType = 1
    Loading.CurrentPackageIndex = 1
    Loading.CurrentPackage = ""

    Loading:AppendLog(egmt("loading.package_group_list"), "green")
    Loading:AppendLog(egmt("loading.count", #Loading.PackageTypeCounts), "yellow")

    Loading:RequestNextPackage()
end)

function Loading:HandlePackage(compressedPackage)
    local packageIdentifier = self.PackageTypeCounts[self.CurrentPackageType]
    local packageType = self.PackageTypes[packageIdentifier.TypeName]

    self.CurrentPackage = self.CurrentPackage .. compressedPackage

    self:AppendLog(egmt("loading.processing", packageType.Name .. " (" .. self.CurrentPackageIndex .. "/" .. packageIdentifier.Count .. ")"))

    -- Process
    if self.CurrentPackageIndex == packageIdentifier.Count then
        local packageData = DecompressTable(self.CurrentPackage)
        if not istable(packageData) then
            self:AppendLog(egmt("loading.package_error", packageType.Name), "yellow")

            return
        end

        packageType.HandleData(packageData)

        self:AppendLog(egmt("loading.package_processed", packageType.Name))
    end

    if self.CurrentPackageIndex < packageIdentifier.Count then
        self.CurrentPackageIndex = self.CurrentPackageIndex + 1
    else
        self.CurrentPackageIndex = 1
        self.CurrentPackage = ""

        if self.CurrentPackageType < #self.PackageTypeCounts then
            self.CurrentPackageType = self.CurrentPackageType + 1
        else
            self:AppendLog(egmt("loading.finished"), "green")

            self.CurrentPackageType = nil
            self.CurrentPackageIndex = nil
            self.CurrentPackage = nil

            self:UpdateProgress()

            net.Start("Loading.Finished")
            net.SendToServer()

            hook.Run("Loading.Finished")

            return
        end
    end

    self:RequestNextPackage()
end

net.Receive("Loading.TransmitPackage", function()
    local len = net.ReadUInt(16)
    local compressedPackage = net.ReadData(len)

    Loading:HandlePackage(compressedPackage)
end)

-- Open the loading loading menu directly after joining.
hook.Add("InitPostEntity", "Loading.Prepare", function()
    Loading:OpenMenu()
end)
--gamemodes/egmrp/gamemode/core/util/cl_draw.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Draw Utilities | Shared      --
---------------------------------------

-- Copied from http://wiki.garrysmod.com/page/surface/DrawPoly
function draw.Circle( x, y, radius, seg )
    local cir = {}

    table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
    for i = 0, seg do
        local a = math.rad( ( i / seg ) * -360 )
        table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
    end

    local a = math.rad( 0 ) -- This is needed for non absolute segment counts
    table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

    surface.DrawPoly( cir )
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmframe.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          VGUI | EGMFrame          --
---------------------------------------

ELEMENT.Name = "EGMFrame"
ELEMENT.Base = "DFrame"

-- Initializes the EGMFrame
function ELEMENT:Init()
	local _self = self

	self:SetPos(0, 0)
	self:SetSize(ScrW(), ScrH())
	self:SetDraggable(false)
	self:ShowCloseButton(false)
	self:SetTitle("")

	self.Title = Config.Servername
	self.SubTitle = ""

	self.Background = vgui.Create("DImage", self)
	self.Background:SetPos(0, 0)
	self.Background:SetSize(self:GetSize())
	self.Background:SetKeepAspect(true)

	function self.Background:PaintOver(width, height)
		-- We need to round the numbers, to perfectly align the polys with the box.
		local barStart = math.Round(width * 0.2)
		local barWidth = math.Round(width * 0.6)

		draw.RoundedBox(0, barStart, 0, barWidth, height * 0.11, UI.BackgroundColor2)

		surface.SetDrawColor(UI.BackgroundColor2)
		draw.NoTexture()

		surface.DrawPoly({
			{x = width * 0.15, y = 0},
			{x = barStart, y = 0},
			{x = barStart, y = height * 0.11}
		})
		surface.DrawPoly({
			{x = barStart + barWidth, y = 0},
			{x = width * 0.85, y = 0},
			{x = barStart + barWidth, y = height * 0.11}
		})

		draw.DrawText(string.upper(_self.Title), "EGMText36", width / 2, 0, UI.ForegroundColor, TEXT_ALIGN_CENTER)

		if #_self.SubTitle > 0 then
			draw.RoundedBox(10, width * 0.25, height * 0.115, width * 0.5, height * 0.08, UI.BackgroundColor2)

			draw.SimpleText(_self.SubTitle, "EGMText15", width / 2, height * 0.13, UI.ForegroundColor2, TEXT_ALIGN_CENTER)
		end
	end

	self.CloseButton = vgui.Create("EGMCloseButton", self)
	self.CloseButton:SetPos(self:GetWide() * 0.965, self:GetTall() * 0.01)
	self.CloseButton:SetSize(self:GetWide() * 0.03, self:GetTall() * 0.05)
	self.CloseButton:SetPanel(self)
end

-- Draws the EGMFrame (Only visible when no image is set.)
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
	--draw.RoundedBox(0, 0, 0, width, height, GetColor("white"))
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the title of the EGMFrame.
--
-- @param String text
function ELEMENT:SetTitle(text)
	self.Title = text
end

-- Sets the subtitle of the EGMFrame.
--
-- @param String text
function ELEMENT:SetSubTitle(text)
	self.SubTitle = text
end

-- Tells if the close button should be enabled or not.
--
-- @param boolean bool
function ELEMENT:EnableCloseButton(bool)
	self.CloseButton:SetActivated(bool)
end

-- Sets the background image.
--
-- @param String image
function ELEMENT:SetBackground(image)
	if not file.Exists(image, "GAME") then
		return
	end

	self.Background:SetImage(image)
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmpropertysheet.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       VGUI | EGMProterySheet      --
---------------------------------------

ELEMENT.Name = "EGMPropertySheet"
ELEMENT.Base = "DPanel"

-- Initializes the EGMProterySheet.
function ELEMENT:Init()
    self.Panels = {}

    self.navBar = vgui.Create("DPanel", self)
    function self.navBar:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.contentPanel = vgui.Create("DPanel", self)
    function self.contentPanel:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
    end
end

-- Sets the layout.
function ELEMENT:PerformLayout()
    self.navBar:Dock(TOP)
    self.navBar:SetHeight(self:GetTall() * 0.075)

    self.contentPanel:Dock(FILL)
end

-- Adds a sheet to the EGMProterySheet.
--
-- @param String name
-- @param Panel panel
function ELEMENT:AddSheet(name, panel)
    local sheet = self

    local button = vgui.Create("DButton", self.navBar)
    button:Dock(LEFT)
    button:DockMargin(self:GetWide() * 0.05 * 0.05, self:GetTall() * 0.08 * 0.08, 0, self:GetTall() * 0.08 * 0.08)
    button:SetWide(self:GetWide() * 0.15)
    button:SetFont("EGMText12")
    button:SetTextColor(UI.ForegroundColor3)
    button:SetText(name)
    button.Panel = panel
    button.Selected = table.Count(self.Panels) == 0
    function button:DoClick()
        --surface.PlaySound(EGM.UI.ButtonSound)
        for k, v in pairs(sheet.Panels) do
            v.panel:SetVisible(false)
            v.button.Selected = false
        end

        self.Selected = true
        self.Panel:SetVisible(true)

        if self.Panel.OnSheetSelected then
            self.Panel:OnSheetSelected()
        end
    end
    function button:Paint(width, height)
        if self.Selected then
            draw.RoundedBox(5, 0, 0, width, height, ColorAlpha(UI.ForegroundColor2 , 50))
        else
            draw.RoundedBox(5, 0, 0, width, height, UI.ForegroundColor)
        end
    end

    --button.Panel:Dock(FILL)
    --button.Panel:DockMargin(self:GetWide() * 0.01, self:GetTall() * 0.02, self:GetWide() * 0.01, self:GetTall() * 0.02)
    button.Panel:SetVisible(button.Selected)

    table.insert(self.Panels, {["name"] = name, ["panel"] = panel, ["button"] = button})
end

-- Adds a button.
--
-- @param String name
-- @param Function clickFunction
function ELEMENT:AddButton(name, clickFunction)
    local button = vgui.Create("DButton", self.navBar)
    button:Dock(LEFT)
    button:DockMargin(self:GetWide() * 0.05 * 0.05, self:GetTall() * 0.08 * 0.08, 0, self:GetTall() * 0.08 * 0.08)
    button:SetWide(self:GetWide() * 0.15)
    button:SetFont("EGMText12")
    button:SetTextColor(UI.ForegroundColor3)
    button:SetText(name)
    function button:DoClick()
        --surface.PlaySound(EGM.UI.ButtonSound)
        clickFunction()
    end
    function button:Paint(width, height)
        if self:IsHovered() then
            draw.RoundedBox(5, 0, 0, width, height, ColorAlpha(UI.ForegroundColor2 , 50))
        else
            draw.RoundedBox(5, 0, 0, width, height, UI.ForegroundColor)
        end
    end
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmsmallframe.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        VGUI | EGMSmallFrame       --
---------------------------------------

ELEMENT.Name = "EGMSmallFrame"
ELEMENT.Base = "DFrame"

-- Initializes the EGMSmallFrame
function ELEMENT:Init()
	self.CustomTitle = ""

	local scrW = ScrW()
	local scrH = ScrH()

	local w, h = scrW * 0.3, scrH * 0.8
	local x, y = (scrW - w) * 0.5, (scrH - h) * 0.5

	self.HeaderHeight = h * 0.06

	self:SetPos(x, y)
	self:SetSize(w, h)

	self:SetTitle("")
	self:SetDraggable(false)
	self:ShowCloseButton(false)

	local closeSize = h * 0.04
	local centeredY = (self.HeaderHeight - 5) * 0.5 - closeSize * 0.5 + 5
	local closeX = w - closeSize - centeredY

	self.CloseButton = vgui.Create("EGMCloseButton", self)
	self.CloseButton:SetPanel(self)
	self.CloseButton:SetPos(closeX, centeredY)
	self.CloseButton:SetSize(closeSize, closeSize)

	self:DockPadding(0, h * 0.06, 0, 0)
end

-- Paints the EGMSmallFrame
function ELEMENT:Paint(ww, hh)
	draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	draw.RoundedBox(0, 0, 0, ww, self.HeaderHeight, UI.BackgroundColor2)

	draw.SimpleText(self.CustomTitle, "EGMText15", ww * 0.5, self.HeaderHeight / 2, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the CustomTitle of the EGMSmallFrame
-- @param String title
function ELEMENT:SetCustomTitle(title)
	self.CustomTitle = title
end
--gamemodes/egmrp/gamemode/core/notify/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Notify index            --
---------------------------------------

Notify = {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_notify.lua")
    AddCSLuaFile("cl_notify.lua")

    include("sv_notify.lua")
    include("sh_notify.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("cl_notify.lua")
    include("sh_notify.lua")
end
--gamemodes/egmrp/gamemode/core/notify/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Notify Config           --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Sound when a notification pops up, false to disable.
Notify.Sound = "notify/notify.mp3"
--gamemodes/egmrp/gamemode/core/notify/cl_notify.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--              Notify cl            --
---------------------------------------

-- Create notify fonts.
surface.CreateFont("EGMNotifyHeader", {
  font = "Franklin Gothic Demi",
  size = ScreenScale(12),
  width = 150
})

surface.CreateFont("EGMNotifyBody", {
  font = "Franklin Gothic Demi",
  size = ScreenScale(8),
  width = 150
})

-- Displays a new notification.
--
-- @param String mode
-- @param String title
-- @param String body
-- @param Number duration
function Notify:Add(mode, title, body, duration)
    mode = mode or "info"
    title = title or ""
    body = body or ""
    duration = duration or 3

    if self.Sound then
        surface.PlaySound(self.Sound)
    end

    if IsValid(self.Current) then
        self.Current:Remove()
    end

    self.Current = vgui.Create("DPanel")
    self.Current:SetPos(ScrW() * 0.74, ScrH() * 0.85)

    --self.Current:Dock(BOTTOM)
    --self.Current:DockMargin(ScrW() * 0.75, ScrH() * 0.005, ScrW() * 0.035, ScrH() * 0.05)
    self.Current:SetSize(ScrW() * 0.25, ScrH() * 0.1)
    self.Current:SetDrawOnTop(true)
    self.Current:SetAlpha(0)

    -- Need to set this outside the paint func to use it in the rich text.
    if mode == "success" then
        self.Current.headlineColor = "green"
        self.Current.titleColor = "green"
        self.Current.textColor = "white"
    elseif mode == "danger" then
        self.Current.headlineColor = "red"
        self.Current.titleColor = "red"
        self.Current.textColor = "white"
    elseif mode == "warning" then
        self.Current.headlineColor = "yellow"
        self.Current.titleColor = "yellow"
        self.Current.textColor = "white"
    elseif mode == "info" then
        self.Current.headlineColor = "blue"
        self.Current.titleColor = "blue"
        self.Current.textColor = "white"
    end

    function self.Current:Paint(width, height)
        if vgui.GetKeyboardFocus() then
            draw.RoundedBox(5, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
        else
            draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor)
        end

        draw.RoundedBox(0, 0, 0, width, height * 0.05, GetColor(self.headlineColor))
        draw.DrawText(title, "EGMNotifyHeader", width * 0.02, height * 0.05, GetColor(self.titleColor), TEXT_ALIGN_LEFT)
    end

    local w, h = self.Current:GetWide(), self.Current:GetTall()

    local bodyText = vgui.Create("RichText", self.Current)
    bodyText:Dock(FILL)
    bodyText:DockMargin(w * 0.01, h * 0.35, w * 0.01, h * 0.05)
    bodyText:InsertColorChange(GetColor2(self.Current.textColor))
    bodyText:AppendText(body)
    bodyText:SetVerticalScrollbarEnabled(false)
    function bodyText:PerformLayout()
        self:SetFontInternal("EGMNotifyBody")
    end

    self.Current:AlphaTo(255, 0.75, 0)
    self.Current:AlphaTo(0, 0.75, duration + 0.75, function()
        if IsValid(self.Current) then
            self.Current:Remove()

            local queue = self.Queue or {}
            table.remove(queue, 1)

            local nextNotify = queue[1]
            if nextNotify then
                self:Add(nextNotify.Mode, nextNotify.Title, nextNotify.Body, nextNotify.Duration)
            end
        end
    end)

    MsgC(GetColor(self.Current.titleColor), "[Notify - " .. title .. "] ", GetColor(self.Current.textColor), body .. "\n")
end

function Notify:AddQueue(mode, title, body, duration)
    self.Queue = self.Queue or {}

    -- Check, if the notification is already in the queue.
    for k, v in pairs(self.Queue) do
        if v.Title == title and v.Body == body then
            return
        end
    end

    local element = {
        Mode = mode,
        Title = title,
        Body = body,
        Duration = duration,
    }

    table.insert(self.Queue, element)

    -- If there is only one notification in the queue, start going through it.
    if #Notify.Queue == 1 then
        local first = Notify.Queue[1]
        if istable(first) then
            Notify:Add(first.Mode, first.Title, first.Body, first.Duration)
        end
    end
end


-- Net receiver for displaying a new notification.
net.Receive("Notify", function()
    local mode = net.ReadString()
    local title = net.ReadString()
    local body = net.ReadString()
    local duration = net.ReadInt(8)

    Notify:AddQueue(mode, title, body, duration)
end)
--gamemodes/egmrp/gamemode/core/notify/sh_notify.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Notify          --
---------------------------------------

-- Displays a success notification. Alias for Notify:Add
--
-- @param String title
-- @param String body
-- @param Number duration
function Notify:Success(...)
    self:Add("success", ...)
end

-- Displays a danger notification. Alias for Notify:Add
--
-- @param String title
-- @param String body
-- @param Number duration
function Notify:Danger(...)
    self:Add("danger", ...)
end

-- Displays a warning notification. Alias for Notify:Add
--
-- @param String title
-- @param String body
-- @param Number duration
function Notify:Warning(...)
    self:Add("warning", ...)
end

-- Displays a info notification. Alias for Notify:Add
--
-- @param String title
-- @param String body
-- @param Number duration
function Notify:Info(...)
    self:Add("info", ...)
end
--gamemodes/egmrp/gamemode/core/permission/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Keybinds | Client         --
---------------------------------------

-- Keybind to toggle administrate mode.
KeyBind:Register(egmt("player.administrate"), egmt("shared.team"), function()
    if not LocalPlayer():IsAtLeast(Permission.AdministrateRank) then return end

    net.Start("Player.Administrate")
    net.SendToServer()
end, Permission.AdministrateDefaultKey)

--gamemodes/egmrp/gamemode/core/eventlog/cl_eventlog.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Event Log Menu | Client      --
---------------------------------------

-- Open the EventLog menu.
function EventLog:Open()
    if not LocalPlayer():IsAtLeast(self.MinAccessGroup) then
        Notify:Danger(egmt("shared.access_denied"), egmt("eventlog.access_denied"))

        return
    end

    self:CloseMenu()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle(egmt("eventlog.title"))
    -- Clear runtime variables.
    function self.Frame:OnClose()
        EventLog.LoadingLogs = nil
        EventLog.LoadingEvents = nil
    end

    -- Event selection.
    self.EventSelection = vgui.Create("DPanel", self.Frame)
    self.EventSelection:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.EventSelection:SetSize(ScrW() * 0.2, ScrH() * 0.65)
    function self.EventSelection:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
    end

    self.EventList = vgui.Create("EGMListView", self.EventSelection)
    self.EventList:Dock(FILL)
    self.EventList:SetHeaderHeight(ScrH() * 0.05)
    self.EventList:SetDataHeight(ScrH() * 0.03)
    self.EventList:SetMultiSelect(false)
    self.EventList:AddCustomColumn(egmt("eventlog.events"))

    function self.EventList:Think()
        if EventLog.LoadingLogs then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end
    function self.EventList:OnRowSelected(index, line)
        -- Reset page when selecting a new event.
        EventLog.PageSelection:SetPage(1)
        EventLog.PageSelection:SetPageCount(1)

        -- Update selected event and reload logs.
        EventLog.SelectedEvent = line.event
        EventLog:LoadLogs()
    end

    self.EventListLoadingHint = vgui.Create("DLabel", self.EventList)
    self.EventListLoadingHint:Dock(FILL)
    self.EventListLoadingHint:SetText("")
    function self.EventListLoadingHint:Paint(width, height)
        if EventLog.LoadingEvents then
            draw.SimpleText(egmt("eventlog.loading"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        elseif #EventLog.EventList:GetLines() == 0 then
            draw.SimpleText(egmt("eventlog.no_events"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        end
    end

    -- Log panel.
    self.LogPanel = vgui.Create("DPanel", self.Frame)
    self.LogPanel:SetPos(ScrW() * 0.35, ScrH() * 0.25)
    self.LogPanel:SetSize(ScrW() * 0.55, ScrH() * 0.65)
    function self.LogPanel:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
    end

    self.LogList = vgui.Create("EGMListView", self.LogPanel)
    self.LogList:Dock(FILL)
    self.LogList:SetHeaderHeight(ScrH() * 0.05)
    self.LogList:SetDataHeight(ScrH() * 0.03)
    self.LogList:SetMultiSelect(false)
    self.LogList:AddCustomColumn(egmt("eventlog.log_entry"))
    self.LogList:AddCustomColumn(egmt("shared.time")):SetFixedWidth(ScrW() * 0.1)
    function self.LogList:OnRowRightClick(index, line)
        SetClipboardText(line:GetValue(2) .. " | " .. line:GetValue(1))
        Notify:Info(egmt("eventlog.title"), egmt("eventlog.copy"))
    end

    self.LogListLoadingHint = vgui.Create("DLabel", self.LogList)
    self.LogListLoadingHint:Dock(FILL)
    self.LogListLoadingHint:SetText("")
    function self.LogListLoadingHint:Paint(width, height)
        if EventLog.LoadingLogs then
            draw.SimpleText(egmt("eventlog.loading_entries"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        elseif #EventLog.LogList:GetLines() == 0 then
            draw.SimpleText(egmt("eventlog.no_entries"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        end
    end

    self.Filter = vgui.Create("DTextEntry", self.LogPanel)
    self.Filter:SetHeight(ScrH() * 0.025)
    self.Filter:Dock(BOTTOM)
    self.Filter:SetPlaceholderText(egmt("shared.searching"))
    function self.Filter:OnValueChange(newFilter)
        -- Reset pages when the filter changes.
        EventLog.PageSelection:SetPage(1)
        EventLog.PageSelection:SetPageCount(1)

        -- Reload logs.
        EventLog:LoadLogs()
    end
    function self.Filter:Think()
        if EventLog.LoadingLogs then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.PageSelection = vgui.Create("EGMPageSelector", self.LogPanel)
    self.PageSelection:SetHeight(ScrH() * 0.025)
    self.PageSelection:Dock(BOTTOM)
    self.PageSelection:SetPage(1)
    self.PageSelection:SetPageCount(1)
    self.PageSelection:SetCallback(function(newPage)
        EventLog:LoadLogs()
    end)
    function self.PageSelection:Think()
        if EventLog.LoadingLogs then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self:LoadEvents()
    self.Frame:MakePopup()
end

-- Loads all events from the server.
function EventLog:LoadEvents()
    self.LoadingEvents = true
    self.EventList:Clear()
    self.LogPanel:SetVisible(false)

    net.Start("EventLog.Events")
    net.SendToServer()
end

-- Net receiver to display loaded events.
net.Receive("EventLog.Events", function()
    if not IsValid(EventLog.EventList) then return end

    EventLog.LoadingEvents = false

    local events = net.ReadTable()
    for k, v in pairs(events) do
        EventLog.EventList:AddCustomLine(v)
    end
end)

-- Loads all logs that match the selected event, filter and page from server.
function EventLog:LoadLogs()
    self.LogList:Clear()
    self.LogPanel:SetVisible(true)
    self.LoadingLogs = true

    local event = self.EventList:GetLine(self.EventList:GetSelectedLine()):GetValue(1)
    local filter = self.Filter:GetValue()
    local page = self.PageSelection:GetPage()

    net.Start("EventLog.Logs")
        net.WriteString(event)
        net.WriteString(filter)
        net.WriteInt(page, 32)
    net.SendToServer()
end

net.Receive("EventLog.Logs", function()
    EventLog.LoadingLogs = false

    local len = net.ReadInt(32)
    local logs = DecompressTable(net.ReadData(len))
    local count = net.ReadInt(32)

    -- Fill logs
    for k, entry in pairs(logs) do
        EventLog.LogList:AddSortedLine(entry.text, nil, os.date(egmt("shared.date_time"), entry.created), entry.created)
    end

    -- Sort the list by the created time (descending).
    EventLog.LogList:SortByColumns(2, true)

    -- Set the page count.
    EventLog.PageSelection:SetPageCount(math.ceil(count / EventLog.PageSize))
end)

-- Closes the event log menu.
function EventLog:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end
--gamemodes/egmrp/gamemode/core/chat/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            Chat | Index           --
---------------------------------------

Chat = Chat or {}
Chat.Types = {}
Chat.Commands = {}

if SERVER then
    local EGMRP = GM or GAMEMODE

    -- Hide all chat messages, not handled within hooks!
    function EGMRP:PlayerSay()
        return ""
    end
end

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("cl_chat.lua")

    include("sh_config.lua")
    include("sv_chat.lua")
    include("sv_eventlog.lua")
    include("sv_chat_types.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("cl_chat.lua")
end
--gamemodes/egmrp/gamemode/core/chat/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Chat | Config           --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Whether to allow private messages.
Chat.PMChatEnabled = true

-- Whether to allow local rp messages without commands.
Chat.RPChatEnabled = false

-- List all Command Prefixes.
Chat.CommandPrefixTable = {
    "/",
    "!",
    ".",
    "@"
}

if SERVER then
    -- Chat Types
    -- OOC Chat
    Chat.Types["ooc"] = Chat.Types["ooc"] or {}
    Chat.Types["ooc"].enabled = true

    -- Local OOC Chat
    Chat.Types["looc"] = Chat.Types["looc"] or {}
    Chat.Types["looc"].enabled = true

    -- It Chat
    Chat.Types["it"] = Chat.Types["it"] or {}
    Chat.Types["it"].enabled = true

    -- Admin Chat
    Chat.Types["admin"] = Chat.Types["admin"] or {}
    Chat.Types["admin"].enabled = true
end

-- Whether join- and leavemessages are enabled
Chat.JoinLeaveMessages = true
--gamemodes/egmrp/gamemode/core/voicechat/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         VoiceChat | Index         --
---------------------------------------

VoiceChat = VoiceChat or {}

if SERVER then
    AddCSLuaFile("cl_voicechat.lua")
	AddCSLuaFile("cl_ui.lua")

    include("sv_voicechat.lua")
end

if CLIENT then
    include("cl_voicechat.lua")
	include("cl_ui.lua")
end
--gamemodes/egmrp/gamemode/core/voicechat/cl_voicechat.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         VoiceChat | Client        --
---------------------------------------

hook.Add("EGMRP.Loaded", "Chat.CacheTalkRangeClient", function()
    VoiceChat.TalkRange = VoiceChat.TalkRange or VoiceChat.DefaultTalkRange
end)

-- Register a keybind for changing the talking radius.
KeyBind:Register(egmt("chat.changerange"), egmt("shared.normal"), function()
    if VoiceChat.TalkRange + 1 <= #VoiceChat.TalkRanges then
        VoiceChat.TalkRange = VoiceChat.TalkRange + 1
    else
        VoiceChat.TalkRange = 1
    end

    Notify:Info(egmt("chat.voicerange"), egmt("chat.changedrange", VoiceChat.TalkRanges[VoiceChat.TalkRange].name), 1)

    net.Start("VoiceChat.ChangeTalkRange")
        net.WriteInt(VoiceChat.TalkRange, 8)
    net.SendToServer()
end, VoiceChat.TalkRangeDefaultKey)

-- Draw current talking range info.
hook.Add("HUDPaint", "VoiceChat.HUD", function()
    if hook.Run("HUDShouldDraw", "EGMRPTalkRange") == false then return end

    local talkRange = VoiceChat.TalkRanges[VoiceChat.TalkRange]

    if talkRange then
        surface.SetDrawColor(talkRange.textColor)
        draw.NoTexture()
        draw.Circle(ScrW() * 0.825, ScrH() * 0.035, 10, 16)
    end
end)

local voice_mat = Material("talkicon/voice.png")
hook.Add("PostPlayerDraw", "Chat.DrawIcons", function(ply)
    if ply == LocalPlayer() and GetViewEntity() == LocalPlayer() then return end
    if not ply:IsSpeaking() then return end

    local pos = ply:GetPos() + Vector(0, 0, ply:GetModelRadius() + 15)

    local attachment = ply:GetAttachment(ply:LookupAttachment("eyes"))
    if attachment then
        pos = ply:GetAttachment(ply:LookupAttachment("eyes")).Pos + Vector(0, 0, 15)
    end

    render.SetMaterial(voice_mat)

    local color_var = 255

    local computed_color = render.ComputeLighting(ply:GetPos(), Vector(0, 0, 1))
    local max = math.max(computed_color.x, computed_color.y, computed_color.z)
    color_var = math.Clamp(max * 255 * 1.11, 0, 255)

    color_var = color_var / 255
    local TalkRange = ply:GetNWInt("VoiceChat.TalkRange", 3)

    local DrawColor = {}
    DrawColor.b = math.Clamp(VoiceChat.TalkRanges[TalkRange].textColor.b * color_var, 0, 255)
    DrawColor.r = math.Clamp(VoiceChat.TalkRanges[TalkRange].textColor.r * color_var, 0, 255)
    DrawColor.g = math.Clamp(VoiceChat.TalkRanges[TalkRange].textColor.g * color_var, 0, 255)

    render.DrawSprite(pos, 12, 12, Color(DrawColor.r, DrawColor.g, DrawColor.b))
end)
--gamemodes/egmrp/gamemode/core/manager/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Manager | Index          --
---------------------------------------

Manager = Manager or {}

if SERVER then
    AddCSLuaFile("cl_config.lua")
    AddCSLuaFile("cl_manager.lua")
    AddCSLuaFile("cl_keybinds.lua")
    AddCSLuaFile("cl_interact.lua")

    include("cl_config.lua")
end

if CLIENT then
    include("cl_config.lua")
    include("cl_manager.lua")
    include("cl_keybinds.lua")
    include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/core/player/cl_player.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Player Data       --
---------------------------------------

-- Load and cache a joining players data.
net.Receive("PlayerData.Load", function()
    local len = net.ReadInt(32)
    local data = DecompressTable(net.ReadData(len))

    PlayerData:Load(data.data, data.properties):Cache()
end)

-- Remove player data from cache on player disconnect.
gameevent.Listen("player_disconnect")
hook.Add("player_disconnect", "PlayerData.RemoveOnDisconnect", function(data)
    local steamId64 = util.SteamIDTo64(data.networkid)

    for k, playerData in pairs(PlayerData:GetCache()) do
        if playerData:Get("steamId64") == steamId64 then
            playerData:RemoveFromCache()
            break
        end
    end
end)

-- Register player_data package type.
-- This is used, to load all currently online players, for a new joining player.
Loading:RegisterPackageType("player_data", egmt("player.name"), function(packageData)
    for _, pData in pairs(packageData) do
        PlayerData:Load(pData.data, pData.properties):Cache()
    end
end)
--gamemodes/egmrp/gamemode/core/player/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Player Menu       --
---------------------------------------

-- Opens the player manager.
function PlayerManager:Open()
    self:CloseMenu()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle(egmt("player.manager"))
    function self.Frame:OnClose()
        -- Reset runtime variables on close.
        PlayerManager.CurrentPlayerData = nil
        PlayerManager.CurrentCharacter = nil
        PlayerManager.Loading = nil
        PlayerManager.LoadingPlayerData = nil
        PlayerManager.LoadingCharacters = nil
    end

    self.Selection = vgui.Create("DPanel", self.Frame)
    self.Selection:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.Selection:SetSize(ScrW() * 0.2, ScrH() * 0.65)
    function self.Selection:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
    end

    self.List = vgui.Create("EGMListView", self.Selection)
    self.List:Dock(FILL)
    self.List:SetHeaderHeight(ScrH() * 0.05)
    self.List:SetDataHeight(ScrH() * 0.03)
    self.List:SetMultiSelect(false)
    self.List:AddCustomColumn(egmt("player.selection"))
    function self.List:OnRowSelected(index, line)
        PlayerManager:ShowPlayerData(line.playerData)
    end
    function self.List:Think()
        if PlayerManager.LoadingCharacters then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.ListLoadingHint = vgui.Create("DLabel", self.List)
    self.ListLoadingHint:Dock(FILL)
    self.ListLoadingHint:SetText("")
    function self.ListLoadingHint:Paint(width, height)
        if PlayerManager.LoadingPlayerData then
            draw.SimpleText(egmt("shared.loading_content"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        elseif #PlayerManager.List:GetLines() == 0 then
            draw.SimpleText(egmt("player.none_found"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        end
    end

    self.LoadOfflineCheckBox = vgui.Create("EGMCheckBox", self.Selection)
    self.LoadOfflineCheckBox:SetPos(ScrW() * 0.15, ScrH() * 0.0125)
    self.LoadOfflineCheckBox:SetSize(ScrH() * 0.025, ScrH() * 0.025)
    self.LoadOfflineCheckBox:SetChecked(false)
    self.LoadOfflineCheckBox:SetTooltip(egmt("player.load_offline"))
    function self.LoadOfflineCheckBox:OnChange()
        -- Reset pages when loading offline.
        PlayerManager.PageSelection:SetPage(1)
        PlayerManager.PageSelection:SetPageCount(1)

        PlayerManager:LoadPlayerData()
    end
    function self.LoadOfflineCheckBox:Think()
        if PlayerManager.LoadingPlayerData or PlayerManager.LoadingCharacters then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.Filter = vgui.Create("DTextEntry", self.Selection)
    self.Filter:SetHeight(ScrH() * 0.025)
    self.Filter:Dock(BOTTOM)
    self.Filter:SetPlaceholderText(egmt("shared.searching"))
    function self.Filter:OnValueChange(newFilter)
        -- Reset pages when selecting a new filter.
        PlayerManager.PageSelection:SetPage(1)
        PlayerManager.PageSelection:SetPageCount(1)

        PlayerManager:LoadPlayerData()
    end
    function self.Filter:Think()
        if PlayerManager.LoadingPlayerData or PlayerManager.LoadingCharacters then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.PageSelection = vgui.Create("EGMPageSelector", self.Selection)
    self.PageSelection:SetHeight(ScrH() * 0.025)
    self.PageSelection:Dock(BOTTOM)
    self.PageSelection:SetPage(1)
    self.PageSelection:SetPageCount(1)
    self.PageSelection:SetCallback(function(newPage)
        PlayerManager:LoadPlayerData()
    end)
    function self.PageSelection:Think()
        if PlayerManager.LoadingPlayerData or PlayerManager.LoadingCharacters then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    -- Player panel
    local w, h = ScrW() * 0.55, ScrH() * 0.65

     self.PlayerPanel = vgui.Create("DPanel", self.Frame)
    self.PlayerPanel:SetPos(ScrW() * 0.35, ScrH() * 0.25)
    self.PlayerPanel:SetSize(w, h)
    self.PlayerPanel:SetVisible(false)
    function self.PlayerPanel:Paint(width, height)
        draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.PlayerName = vgui.Create("DLabel", self.PlayerPanel)
    self.PlayerName:SetPos(w * 0.05, h * 0.05)
    self.PlayerName:SetTextColor(UI.TextColor)
    self.PlayerName:SetFont("EGMText15")

    self.PlayerProperties = vgui.Create("DPanel", self.PlayerPanel)
    self.PlayerProperties:SetPos(w * 0.05, h * 0.15)
    self.PlayerProperties:SetSize(w * 0.425, h * 0.8)
    function self.PlayerProperties:Paint(width, height)
    end

    self.PlayerPropertiesList = vgui.Create("EGMScrollPanel", self.PlayerProperties)
    self.PlayerPropertiesList:Dock(FILL)
    self.PlayerPropertiesList:SetBackgroundColor(Color(0, 0, 0, 0))

    self.PlayerPropertiesSave = vgui.Create("EGMButton", self.PlayerProperties)
    self.PlayerPropertiesSave:SetHeight(h * 0.05)
    self.PlayerPropertiesSave:Dock(BOTTOM)
    self.PlayerPropertiesSave:SetTextColor(UI.TextColor)
    self.PlayerPropertiesSave:SetFont("EGMText10")
    self.PlayerPropertiesSave:SetText(egmt("player.save"))
    function self.PlayerPropertiesSave:DoClick()
        local properties = {}

        for k, v in pairs(PlayerManager.PlayerPropertiesList.Values) do
            properties[k] = v()
        end

        local success, errors = PlayerManager.CurrentPlayerData:EditProperties(properties)
        if success then
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.saving_process"), false)
			PlayerManager.PlayerEditModal = modal
        else
            if errors then
                for k, v in pairs(errors) do
                    Notify:Danger(egmt("shared.invalid_property"), v)
                end
            else
                Notify:Danger(egmt("shared.unknown_error"))
            end
        end
    end

    self.CharacterList = vgui.Create("EGMListView", self.PlayerPanel)
    self.CharacterList:SetPos(w * 0.525, h * 0.15)
    self.CharacterList:SetSize(w * 0.425, h * 0.3)
    self.CharacterList:SetHeaderHeight(ScrH() * 0.05)
    self.CharacterList:SetDataHeight(ScrH() * 0.03)
    self.CharacterList:SetMultiSelect(false)
    self.CharacterList:AddCustomColumn(egmt("character.selection"))
    function self.CharacterList:OnRowSelected(index, line)
        PlayerManager:ShowPlayerCharacter(line.character)
    end

    self.CharacterListLoadingHint = vgui.Create("DLabel", self.CharacterList)
    self.CharacterListLoadingHint:Dock(FILL)
    self.CharacterListLoadingHint:SetText("")
    function self.CharacterListLoadingHint:Paint(width, height)
        if PlayerManager.LoadingCharacters then
            draw.SimpleText(egmt("shared.loading_content"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        elseif #PlayerManager.CharacterList:GetLines() == 0 then
            draw.SimpleText(egmt("player.no_characters"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        end
    end

    self.CharacterDownload = vgui.Create("EGMButton", self.PlayerPanel)
    self.CharacterDownload:SetPos(w * 0.525, h * 0.15)
    self.CharacterDownload:SetSize(w * 0.425, h * 0.1)
    self.CharacterDownload:SetText(egmt("player.download_characters"))
    self.CharacterDownload:SetTextColor(UI.TextColor)
    self.CharacterDownload:SetFont("EGMText12")
    self.CharacterDownload:SetVisible(false)
    function self.CharacterDownload:DoClick()
        PlayerManager:LoadOfflineCharacters()
    end

    self.InfoPanel = vgui.Create("DPanel", self.PlayerPanel)
    self.InfoPanel:SetPos(w * 0.525, h * 0.5)
    self.InfoPanel:SetSize(w * 0.425, h * 0.45)
    function self.InfoPanel:Paint(width, height)
    end

    self.PlayerInfoPanel = vgui.Create("RichText", self.InfoPanel)
    self.PlayerInfoPanel:Dock(FILL)
    function self.PlayerInfoPanel:PerformLayout()
        self:SetFontInternal("EGMText8")
    end

    self.CharacterPanel = vgui.Create("DPanel", self.InfoPanel)
    self.CharacterPanel:Dock(FILL)
    self.CharacterPanel:SetVisible(false)
    function self.CharacterPanel:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 220))
    end

    self.CharacterShowPlayerInfo = vgui.Create("EGMButton", self.CharacterPanel)
    self.CharacterShowPlayerInfo:SetPos(w * 0.325, 0)
    self.CharacterShowPlayerInfo:SetSize(w * 0.1, h * 0.05)
    self.CharacterShowPlayerInfo:SetTextColor(UI.TextColor)
    self.CharacterShowPlayerInfo:SetFont("EGMText8")
    self.CharacterShowPlayerInfo:SetText(egmt("shared.back"))
    self.CharacterShowPlayerInfo:SetButtonColor(UI.ForegroundColor2)
    function self.CharacterShowPlayerInfo:DoClick()
        PlayerManager.CharacterList:ClearSelection()
        PlayerManager.CharacterPanel:SetVisible(false)
        PlayerManager.PlayerInfoPanel:SetVisible(true)
    end

    self.CharacterName = vgui.Create("DLabel", self.CharacterPanel)
    self.CharacterName:SetPos(w * 0.01, 0)
    self.CharacterName:SetTextColor(UI.TextColor)
    self.CharacterName:SetFont("EGMText10")

    self.CharacterModel = vgui.Create("EGMModelPanel", self.CharacterPanel)
    self.CharacterModel:SetPos(0, 0)
    self.CharacterModel:SetSize(w * 0.2, h * 0.35)
    self.CharacterModel:SetZPos(-1)

    self.ShowCharacter = vgui.Create("EGMButton", self.CharacterPanel)
    self.ShowCharacter:SetPos(0, h * 0.35)
    self.ShowCharacter:SetSize(w * 0.425, h * 0.05)
    self.ShowCharacter:SetTextColor(UI.TextColor)
    self.ShowCharacter:SetFont("EGMText10")
    self.ShowCharacter:SetText(egmt("player.show_character"))
    function self.ShowCharacter:DoClick()
        local character = PlayerManager.CurrentCharacter

        -- Open the character menu after closing the player manager.
        CharacterManager:Open()

        -- Select faction of the character in the character manager.
        CharacterManager.SelectedFaction = character:GetFaction()
        local faction = character:GetFaction()

        if faction then
            for k, line in pairs(CharacterManager.FactionList:GetLines()) do
                if line.faction:GetId() == faction:GetId() then
                    CharacterManager.FactionList:SelectItem(line)
                    break
                end
            end

            -- Load other online characters of the character's faction. true is for preventing auto selection.
            CharacterManager:LoadCharacters(true)

            -- If the character is on the online characters list, select it.
            local added = false
            for k, line in pairs(CharacterManager.CharacterList:GetLines()) do
                if line.character:GetId() == character:GetId() then
                    CharacterManager.CharacterList:SelectItem(line)
                    added = true

                    break
                end
            end

            -- Otherwise add it to the list and then select it.
            if not added then
                local name = character:GetRank():GetProperty("prefix", "") .. " " .. character:GetName()
                local line = CharacterManager.CharacterList:AddSortedLine(name, character:GetRank():GetAuthorityLevel())
                line.character = character

                if not character:IsValid() then
                    line:SetCustomTextColor(GetColor("red"))
                end

                -- Resort by permission level.
                CharacterManager.CharacterList:SortByColumns(1, false)

                -- Select the character.
                CharacterManager.CharacterList:SelectItem(line)
            end
        else
            -- Open The Character Panel without a list.
            CharacterManager:ShowCharacter(character)
        end



        -- Now close the player manager.
        PlayerManager:CloseMenu()
    end

    self.CharacterDelete = vgui.Create("EGMButton", self.CharacterPanel)
    self.CharacterDelete:SetPos(0, h * 0.4)
    self.CharacterDelete:SetSize(w * 0.425, h * 0.05)
    self.CharacterDelete:SetTextColor(UI.TextColor)
    self.CharacterDelete:SetFont("EGMText10")
    self.CharacterDelete:SetText(egmt("player.delete_character"))
    self.CharacterDelete:SetButtonColor(GetColor("red"))
    function self.CharacterDelete:DoClick()
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
        modal:Confirm(egmt("player.character_delete_warning"), function()
            PlayerManager.CurrentCharacter:Delete()

			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("player.character_deletion_process"), false)
			PlayerManager.CharacterDeletionModal = modal
        end)
    end

    self:LoadPlayerData()
    self.Frame:MakePopup()
end

-- Inform about successfull character deletion.
hook.Add("Character.DeletionSuccess", "PlayerManager.CharacterDeletionSuccess", function()
    if PlayerManager.CharacterDeletionModal then
        PlayerManager.CharacterDeletionModal:SetCustomTitle(egmt("shared.success"))
        PlayerManager.CharacterDeletionModal:SetBarColor(GetColor("green"))
        PlayerManager.CharacterDeletionModal:Notify(egmt("player.character_deletion_success"), nil, nil, GetColor("lightgray"), function()
            -- Remove currently selected (deleted) character from list.
            PlayerManager.CharacterList:RemoveLine(PlayerManager.CharacterList:GetSelectedLine())

            -- Show player info.
            PlayerManager.CharacterPanel:SetVisible(false)
            PlayerManager.PlayerInfoPanel:SetVisible(true)

            PlayerManager.CharacterDeletionModal = nil
        end)
    end
end)

-- Inform about character deletion error.
hook.Add("Character.DeletionError", "PlayerManager.CharacterDeletionError", function()
    if PlayerManager.CharacterDeletionModal then
        PlayerManager.CharacterDeletionModal:SetCustomTitle(egmt("shared.error"))
        PlayerManager.CharacterDeletionModal:SetBarColor(GetColor("red"))
        PlayerManager.CharacterDeletionModal:Notify(egmt("player.character_deletion_error"), nil, nil, GetColor("lightgray"), function()
            PlayerManager.CharacterDeletionModal = nil
        end)
    end
end)

-- Inform about successfull playerdata edit.
hook.Add("PlayerData.EditPropertiesSuccess", "PlayerManager.PlayerDataEditPropertiesSuccess", function()
    if PlayerManager.PlayerEditModal then
        PlayerManager.PlayerEditModal:SetCustomTitle(egmt("shared.success"))
        PlayerManager.PlayerEditModal:SetBarColor(GetColor("green"))
        PlayerManager.PlayerEditModal:Notify(egmt("player.saved"), nil, nil, GetColor("lightgray"), function()
            PlayerManager.PlayerEditModal = nil

            -- Manually update properties of offline player data. This is not done automatically, because changes of offline data is not synced.
            local playerData = PlayerManager.CurrentPlayerData
            if playerData and not playerData:GetPlayer() then
                -- Collect changed properties from the propertylist and assign them.
                local properties = {}
                for k, v in pairs(PlayerManager.PlayerPropertiesList.Values) do
                    properties[k] = v()
                end

                playerData:SetProperties(properties, true)

                -- Call this hook so that the menu gets refreshed.
                hook.Run("PlayerData.PropertyChanged", playerData)
            end
        end)
    end
end)

-- Inform about playerdata edit error.
hook.Add("PlayerData.EditPropertiesError", "PlayerManager.PlayerDataEditError", function()
    if PlayerManager.PlayerEditModal then
        PlayerManager.PlayerEditModal:SetCustomTitle(egmt("shared.error"))
        PlayerManager.PlayerEditModal:SetBarColor(GetColor("red"))
        PlayerManager.PlayerEditModal:Notify(egmt("player.saving_error"), nil, nil, GetColor("lightgray"), function()
            PlayerManager.PlayerEditModal = nil
        end)
    end
end)

-- Loads the players based on the selected page, filter and loadOffline value.
-- Called when load offline, page or filter got changed.
function PlayerManager:LoadPlayerData()
    self.List:Clear()
    self.PlayerPanel:SetVisible(false)
    self.CurrentPlayerData = nil

    local loadOffline = self.LoadOfflineCheckBox:GetChecked()
    local filter = self.Filter:GetValue()
    local page = self.PageSelection:GetPage()

    if not loadOffline then
        local playerData = {}
        for k, data in pairs(PlayerData:GetCache()) do
            if string.find(string.lower(data:GetName()), string.lower(filter)) or data:Get("steamId64") == filter or util.SteamIDFrom64(data:Get("steamId64")) == filter then
                table.insert(playerData, data)
            end
        end

        -- Set the number of pages.
        local pages = math.max(math.ceil(table.Count(playerData) / self.PageSize), 1)
        self.PageSelection:SetPageCount(pages)

        -- Add every player data to the list.
        for k, data in SortedPairs(playerData) do
            if k > (page - 1) * self.PageSize and k <= page * self.PageSize then
                local line = self.List:AddCustomLine(data:GetName())
                line.playerData = data

                if not data:IsValid() then
                    line:SetCustomTextColor(GetColor("red"))
                end
            end
        end

        -- Automatically select the first item, if there is only one.
        if #self.List:GetLines() == 1 then
            self.List:SelectFirstItem()
        end
    else
        self.LoadingPlayerData = true

        net.Start("PlayerManager.OfflinePlayers")
            net.WriteString(filter)
            net.WriteInt(page, 32)
        net.SendToServer()
    end
end

-- Net Receiver for offline player data.
net.Receive("PlayerManager.OfflinePlayers", function()
    PlayerManager.LoadingPlayerData = false

    local len = net.ReadInt(32)
    local playerDataList = DecompressTable(net.ReadData(len))
    local pages = net.ReadInt(32)

    for k, data in pairs(playerDataList) do
        local playerData = PlayerData:Load(data.data, data.properties)
        local line = PlayerManager.List:AddCustomLine(playerData:GetName())
        line.playerData = playerData

        if not playerData:IsValid() then
            line:SetCustomTextColor(GetColor("red"))
        end
    end

    -- Automatically select the first item, if there is only one.
    if #PlayerManager.List:GetLines() == 1 then
        PlayerManager.List:SelectFirstItem()
    end

    PlayerManager.PageSelection:SetPageCount(pages)
end)

-- Net receiver for loading errors.
net.Receive("PlayerManager.OfflinePlayersError", function(len, ply)
    PlayerManager:CloseMenu()
       Notify:Danger(egmt("shared.error"), egmt("shared.offline_error"))
end)

-- Shows the given player data in the player panel.
--
-- @param Table playerData
function PlayerManager:ShowPlayerData(playerData)
    self.PlayerPanel:SetVisible(true)
    self.PlayerInfoPanel:SetVisible(true)
    self.CharacterPanel:SetVisible(false)

    self.CurrentPlayerData = playerData

    local success, errors = playerData:IsValid()

    if not success then
        for k, v in pairs(errors) do
            Notify:Danger(egmt("player.invalid"), v)
        end
    end

    -- Clear character selection.
    self.CharacterList:Clear()
    self.CurrentCharacter = nil

    -- Fill character selection of online players.
    if playerData:GetPlayer() then
        self.CharacterList:SetVisible(true)
        self.CharacterDownload:SetVisible(false)

        for k, character in pairs(playerData:GetPlayer():GetCharacters()) do
            local rank = character:GetRank()

            local name = character:GetName()
            local authorityLevel = 0

            if rank then
                name = rank:GetProperty("prefix", "") .. " " .. name
                authorityLevel = rank:GetAuthorityLevel()
            end

            local line = self.CharacterList:AddSortedLine(name, authorityLevel)
            line.character = character

            if not character:IsValid() then
                line:SetCustomTextColor(GetColor("red"))
            end

            self.CharacterList:SortByColumns(1, false)
        end
    else
        self.CharacterList:SetVisible(false)
        self.CharacterDownload:SetVisible(true)
    end

    -- Set the player name.
    self.PlayerName:SetText(playerData:GetName())
    self.PlayerName:SizeToContents()

    local globalCanEdit = false
    -- Create property list.
    self.PlayerPropertiesList.Values, globalCanEdit = CreatePropertyList(
        self.PlayerPropertiesList,
        PlayerData:GetPropertyList(playerData),
        playerData
    )
    self.PlayerPropertiesSave:SetDisabled(not globalCanEdit)

    -- Update player info panel.
    self.PlayerInfoPanel:SetText("")

    self.PlayerInfoPanel:InsertColorChange(GetColor2("blue"))
    self.PlayerInfoPanel:AppendText(egmt("player.created_on"))
    self.PlayerInfoPanel:InsertColorChange(GetColor2("white"))
    self.PlayerInfoPanel:AppendText(os.date(egmt("shared.date_time"), playerData:Get("created", 0)) .. "\n\n")

    self.PlayerInfoPanel:InsertColorChange(GetColor2("blue"))
    self.PlayerInfoPanel:AppendText(egmt("player.last_online"))
    self.PlayerInfoPanel:InsertColorChange(GetColor2("white"))
    self.PlayerInfoPanel:AppendText(os.date(egmt("shared.date_time"), playerData:GetProperty("lastonline", 0)) .. "\n\n")

    self.PlayerInfoPanel:InsertColorChange(GetColor2("blue"))
    self.PlayerInfoPanel:AppendText(egmt("player.steamId64_list"))
    self.PlayerInfoPanel:InsertColorChange(GetColor2("white"))
    self.PlayerInfoPanel:AppendText(playerData:Get("steamId64") .. "\n\n")

    self.PlayerInfoPanel:InsertColorChange(GetColor2("blue"))
    self.PlayerInfoPanel:AppendText(egmt("player.steamId_list"))
    self.PlayerInfoPanel:InsertColorChange(GetColor2("white"))
    self.PlayerInfoPanel:AppendText(util.SteamIDFrom64(playerData:Get("steamId64")))
end

-- Characters of offline players need to be loaded from database and networked to the client afterwards.
-- To reduce networking, we only load those characters when this function is called
-- (when the player clicks the "load offline characters" button).
function PlayerManager:LoadOfflineCharacters()
    self.LoadingCharacters = true

    self.CharacterDownload:SetVisible(false)
    self.CharacterList:SetVisible(true)

    net.Start("PlayerManager.OfflineCharacters")
        net.WriteString(self.CurrentPlayerData:Get("steamId64"))
    net.SendToServer()
end

-- Net receiver for offline characters.
net.Receive("PlayerManager.OfflineCharacters", function()
    PlayerManager.LoadingCharacters = false

    local len = net.ReadInt(32)
    local offlineCharacters = DecompressTable(net.ReadData(len))

    for k, data in pairs(offlineCharacters) do
        local character = Character:Load(data.data, data.properties)

		local fullName = character:GetFullName()
		local line = PlayerManager.CharacterList:AddSortedLine(fullName, character:GetId())
		line.character = character

		if not character:IsValid() then
			line:SetCustomTextColor(GetColor("red"))
		end
    end

    PlayerManager.CharacterList:SortByColumns(1, false)
end)

-- Net receiver for loading errors.
net.Receive("PlayerManager.OfflineCharactersError", function(len, ply)
    PlayerManager:CloseMenu()
    Notify:Danger(egmt("shared.error"), egmt("shared.offline_error"))
end)

-- Shows the given character in the character panel.
--
-- @param Table character
function PlayerManager:ShowPlayerCharacter(character)
    self.PlayerInfoPanel:SetVisible(false)
    self.CharacterPanel:SetVisible(true)

    self.CurrentCharacter = character

    self.CharacterName:SetText(character:GetFullName())
    self.CharacterName:SizeToContents()
    self.CharacterModel:SetCharacter(character)

    local success, errors = character:IsValid()

    if not success then
        for k, v in pairs(errors) do
            Notify:Danger(egmt("character.invalid"), v)
        end
    end

    self.CharacterDelete:SetEnabled(character:CanPlayerDelete(LocalPlayer()))
end

-- Closes the player manager.
function PlayerManager:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

------------------------------------------
--    The following code is for live    --
--     refreshing. If any data gets     --
--  changed, it is updated in the menu. --
------------------------------------------

-- Refresh menu when a player data property got changed.
-- Only works for online players.
hook.Add("PlayerData.PropertyChanged", "PlayerManager.RefreshPlayer", function(playerData)
    if IsValid(PlayerManager.Frame) then
        if PlayerManager.CurrentPlayerData and PlayerManager.CurrentPlayerData:GetId() == playerData:GetId() then
            PlayerManager:ShowPlayerData(playerData)
        end

        -- Update Entry in list.
        for k, line in pairs(PlayerManager.List:GetLines()) do
            if line.playerData and line.playerData:GetId() == playerData:GetId() then
                -- Update the playerData set in the line. This allows the data to be updated when the line is clicked.
                line.playerData = playerData

                -- Update text in the EGMListView.
                line.Columns[1].Value = playerData:GetName()

                break
            end
        end
    end
end)
--gamemodes/egmrp/gamemode/core/player/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Player Keybinds     --
---------------------------------------

-- Keybind for opening the player manager.
KeyBind:Register(egmt("player.manager"), egmt("shared.team"), function()
    PlayerManager:Open()
end, PlayerManager.DefaultKey)

-- Keybind for dropping a weapon.
KeyBind:Register(egmt("player.drop_weapon"), egmt("shared.normal"), function()
    local weapon = LocalPlayer():GetActiveWeapon()

    if IsValid(weapon) and not table.HasValue(PlayerConfig.NoDropWeapons, weapon:GetClass()) then
        net.Start("Player.DropWeapon")
        net.SendToServer()
    end
end)

-- Keybind for dropping a weapon.
KeyBind:Register(egmt("player.throw_weapon"), egmt("shared.normal"), function()
    local weapon = LocalPlayer():GetActiveWeapon()

    if IsValid(weapon) and not table.HasValue(PlayerConfig.NoDropWeapons, weapon:GetClass()) then
        net.Start("Player.ThrowWeapon")
        net.SendToServer()
    end
end)
--gamemodes/egmrp/gamemode/core/character/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Character config     --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- The model that is set, when the model of the character is invalid.
Character.FallbackModel = "models/player/alyx.mdl"

-- The default active weapon all characters start with.
Character.DefaultActiveWeapon = "weapon_fists"

-- Default weapons that all characters get.
Character.DefaultWeapons = {
    "weapon_fists",
}

-- Weapons that players being at least of the specicified group get.
Character.ServerGroupWeapons = {
    operator = {
        "weapon_physgun",
    },
    admin = {
        "gmod_tool",
    },
}

-- Minimal group required to edit some character properties like the name.
Character.MinAccessGroup = "operator"

-- Minimal group that has full access to the character system, including editing every property and deleting characters.
Character.MinFullAccessGroup = "superadmin"

-- Whether a player is allowed to edit his own character.
Character.CanSelfEdit = false

-- Can a player delete his own character?
Character.CanDeleteOwnCharacter = true

-- Slow walk speed (Marching speed).
-- Default: 100
Character.SlowWalkSpeed = 100

-- Crouch Walk modifier.
-- Default: 0.3
Character.CrouchedWalkSpeed = 0.3

-- Background image for the character creation.
CharacterCreation.Background = "backgrounds/betel_arg_welcome_to_gmod.png"

-- Background image for the character selection.
CharacterSelection.Background = "backgrounds/idiotdoug_bucket_by_the_window.png"

-- Default bind to open the character selection.
CharacterSelection.DefaultBind = KEY_F2

-- Background image of the character manager.
CharacterManager.Background = "backgrounds/idiotdoug_red_and_blue.png"

-- Default bind to open the character manager.
CharacterManager.DefaultKey = KEY_F4

-- The maximum number of elements a page can have in the character manager. The higher the number the higher the loading time.
CharacterManager.PageSize = 50
--gamemodes/egmrp/gamemode/core/character/sh_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Character System     --
---------------------------------------

-- Set shared property variables.
Character.Name = "Character"

-- Initialize networking
Character:InitCreationNetworking()
Character:InitEditNetworking()
Character:InitDeletionNetworking()



---------------------------------------
--           Character Data          --
---------------------------------------

-- Add Character data: playerSteamId64
Character:AddData("playerSteamId64", "string", "player_steamid64", "VARCHAR(17) NOT NULL",
function(character, value)
    if not isstring(value) or not #value == 17 then
        return false, egmt("character.invalid_steamid")
    end

    return true
end,
function(character, ply)
    return true
end)

-- Tries to fetch a player from the player Steam64Id.
-- Only works when the player is currently online.
--
-- @return Player ply or Boolean false
function Character.Meta:GetOwner()
    local ply = player.GetBySteamID64(self:Get("playerSteamId64"))

    if IsValid(ply) then
        return ply
    end

    return false
end

-- Returns all characters from cache owned by the player.
--
-- @param Player ply
-- @return Table characters
function Character:GetOwnedByPlayer(ply)
    local characters = {}

    for k, character in pairs(self:GetCache()) do
        if character:BelongsTo(ply) then
            table.insert(characters, character)
        end
    end

    return characters
end

-- Checks whether the character belongs to the player.
--
-- @param Player ply
-- @return Boolean belongsTo
function Character.Meta:BelongsTo(ply)
    return self:Get("playerSteamId64") == ply:SteamID64()
end

-- Add Character data: factionId
Character:AddData("factionId", "number", "faction_id", "INT NOT NULL",
function(character, factionId)
    if not isnumber(factionId) then
        return false, egmt("character.invalid_faction_id")
    end

    local faction = Faction:GetCached(factionId)
    if not faction then
        return false, egmt("character.invalid_faction")
    end

    local isValid, errors = faction:IsValid()
    if not isValid then
        PrintTable(errors)
        return false, egmt("character.invalid_faction")
    end

    return true
end,
function(character, ply)
    return true
end)

-- Returns the faction of the character.
--
-- @return Table faction
function Character.Meta:GetFaction()
    return Faction:GetCached(self:Get("factionId"))
end

-- Gets all cnaracters from cache belonging to the faction.
-- Only returns for cached characters.
--
-- @param Number factionId
-- @param Table characters
function Character:GetByFaction(factionId)
    local characters = {}

    for k, character in pairs(self:GetCache()) do
        local faction = character:GetFaction()
        if not faction then
            continue
        end

        if faction:GetId() == factionId then
            table.insert(characters, character)
        end
    end

    return characters
end

-- Returns the name of the faction of the character.
--
-- @return String factionName
function Character.Meta:GetFactionName()
	local faction = self:GetFaction()
	if not faction then
		return "???"
	end

	-- Insert into table and run hook.
	local factionNameTable = {[0] = faction:GetName()}
	hook.Run("Character.GetFactionName", self, factionNameTable)

	return table.concat(NormalizeTable(factionNameTable), " ")
end

-- Returns the prefix of the faction of the character.
--
-- @return String factionPrefix
function Character.Meta:GetFactionPrefix()
	local faction = self:GetFaction()
	if not faction then
		return "???"
	end

	-- Insert into table and run hook.
	local factionPrefixTable = {[0] = faction:GetPrefix()}
	hook.Run("Character.GetFactionPrefix", self, factionPrefixTable)

	return table.concat(NormalizeTable(factionPrefixTable), " ")
end

-- Returns the color of the faction of the character.
--
-- @return Color factionColor
function Character.Meta:GetFactionColor()
	local faction = self:GetFaction()
	if not faction then
		return Color(255, 255, 255)
	end

	local factionColor = faction:GetColor()
	local override = hook.Run("Character.GetFactionColor", self, factionColor)
	if isstring(override) then
		return override
	end

	return factionColor
end

-- Add Character data: rankId
Character:AddData("rankId", "number", "rank_id", "INT NOT NULL",
function(character, rankId)
    if not isnumber(rankId) then
        return false, egmt("character.invalid_rank_id")
    end

    local faction = character:GetFaction()
    if not faction then
        return false, egmt("character.invalid_faction")
    end

    local isValid1, errors1 = faction:IsValid()
    if not isValid1 then
        PrintTable(errors1)
        return false, egmt("character.invalid_faction")
    end

    local rank = Rank:GetCached(rankId)
    if not rank then
        return false, egmt("character.invalid_rank")
    end

    local isValid2, errors2 = rank:IsValid()
    if not isValid2 then
        PrintTable(errors2)
        return false, egmt("character.invalid_rank")
    end

    return true
end,
function(character, ply)
    return true
end)

-- Returns the rank of the character.
--
-- @return Table rank
function Character.Meta:GetRank()
    return Rank:GetCached(self:Get("rankId"))
end

-- Gets all characters from cache belonging to the rank.
-- Only returns for cached characters.
--
-- @param Table rankId
-- @return Table characters
function Character:GetByRank(rankId)
    local characters = {}

    for k, character in pairs(self:GetCache()) do
        local rank = character:GetRank()
        if not rank then
            continue
        end

        if rank:GetId() == rankId then
            table.insert(characters, character)
        end
    end

    return characters
end

-- Returns the name of the rank of the character.
--
-- @return String rankName
function Character.Meta:GetRankName()
	local rank = self:GetRank()
	if not rank then
		return "???"
	end

	-- Insert into table and run hook.
	local rankNameTable = {[0] = rank:GetName()}
	hook.Run("Character.GetRankName", self, rankNameTable)

	return table.concat(NormalizeTable(rankNameTable), " ")
end

-- Returns the prefix of the rank of the character.
--
-- @return String rankPrefix
function Character.Meta:GetRankPrefix()
	local rank = self:GetRank()
	if not rank then
		return "???"
	end

	-- Insert into table and run hook.
	local rankPrefixTable = {[0] = rank:GetPrefix()}
	hook.Run("Character.GetRankPrefix", self, rankPrefixTable)

	return table.concat(NormalizeTable(rankPrefixTable), " ")
end

-- Returns the color of the rank of the character.
--
-- @return Color rankColor
function Character.Meta:GetRankColor()
	local rank = self:GetRank()
	if not rank then
		return Color(255, 255, 255)
	end

	local rankColor = rank:GetColor()
	local override = hook.Run("Character.GetRankColor", self, rankColor)
	if isstring(override) then
		return override
	end

	return rankColor
end



---------------------------------------
--        Character Properties       --
---------------------------------------

-- Whitelist for properties that are allowed to be set during creation.
Character.PropertiesAllowedOnCreationWhitelist = {
    "name",
    "modelSkin",
}

-- Add Character property: name
Character:AddProperty("name", "string", nil, function(character, value)
    if not isstring(value) or #value < 2 or #value > 100  then
        return false, egmt("character.name_error")
    end

    return true
end,
function(character, ply)
    return true
end)

-- Returns the name property of the character or a string containing the id as a fallback.
--
-- @return String name
function Character.Meta:GetName()
    return hook.Run("Character.OverrideName", self)
        or self:GetProperty("name")
        or egmt("character") .. " " .. self:GetId()
end

-- Alias of GetName
--
-- @return String name
function Character.Meta:GetRPName()
    return self:GetName()
end

-- Character property: modelSkin
Character:AddProperty("modelSkin", "table", {}, function(character, modelSkin)
	if not istable(modelSkin) then
		return false, egmt("shared.invalid_type")
	end

	local model = modelSkin.Model
	local overrideModel, err1 = hook.Run("Character.OverrideModelValid", character, model)
	if overrideModel == nil then
		if not isstring(model) or IsUselessModel(model) then
			return false, egmt("character.invalid_model")
		end

		-- Allow fallback model.
		if model == Character.FallbackModel then
			return true
		end
	elseif overrideModel == false then
		return false, err1
	end

	local skinId = modelSkin.SkinId
	local overrideSkinId, err2 = hook.Run("Character.OverrideSkinValid", character, model, skinId)
	if overrideSkinId == nil then
		if not isnumber(skinId) then
			return false, egmt("character.invalid_skin_id")
		end
	elseif overrideSkinId == false then
		return false, err2
	end

	return true
end, function(character, ply)
	return true
end)

-- Returns the model and skinId of the character or a fallback model.
--
-- @return String model
-- @return Number skinId
function Character.Meta:GetModelSkin()
	local modelSkin = self:GetProperty("modelSkin", {Model = Character.FallbackModel})

	-- Add internal override for model and skin.
	local internalOverride = self.ModelSkinOverride
	if istable(internalOverride) then
		return internalOverride.Model, internalOverride.SkinId or 0
	end

	-- Allow external override for model and skin.
	local override = hook.Run("Character.OverrideModelSkin", self, modelSkin)
	if istable(override) then
		return override.Model, override.SkinId or 0
	end

	return modelSkin.Model, modelSkin.SkinId or 0
end

-- Add Character property: lastplayed
Character:AddProperty("lastplayed", "number", nil, nil, function(character, ply)
    return true
end)



---------------------------------------
--        Character Utilities        --
---------------------------------------

-- Used to check whether a character is able to play.
-- Checks whether a character is valid. Also used for additional checks like whitelist / slots.
--
-- ?@param Boolean skipIdCreated
-- @return Boolean playable
-- @return? Table errors
function Character.Meta:IsPlayable(skipIdCreated)
	local isValid, validationErrors = self:IsValid(skipIdCreated)
	if not isValid then
		return false, validationErrors
	end

	local owner = self:GetOwner()
	if not IsValid(owner) then
		return false, {egmt("character.invalid_owner")}
	end

	local rank = self:GetRank()
	local faction = self:GetFaction()
	if not faction:HasRank(rank) then
		return false, {egmt("character.rank_not_available")}
	end

	local currentModelSkin = newModelSkin or self:GetProperty("modelSkin", {Model = Character.FallbackModel})

	local model = currentModelSkin.Model
	if model ~= Character.FallbackModel then
		if not table.HasValue(self:GetValidModels(), model) then
			return false, {egmt("character.unavailable_model")}
		end

		local skinId = currentModelSkin.SkinId
		if not table.HasValue(self:GetValidSkins(model), skinId) then
			return false, {egmt("character.unavailable_skin")}
		end
	end

	local playable, error = hook.Run("Character.IsPlayable", self, owner)
	if playable == false then
		return false, { error }
	end

	return true
end

-- Returns the roleplay name of the character.
--
-- @return String fullName
-- @return Color factionColor
function Character.Meta:GetFullName()
	local fullNameTable = {[0] = self:GetName()}

	-- Insert the faction prefix into the table.
	local factionPrefix = self:GetFactionPrefix()
	if isstring(factionPrefix) and factionPrefix ~= "" then
		fullNameTable[-200] = factionPrefix
	else
		-- Fallback to faction name if no prefix is available.
		local factionName = self:GetFactionName()
		if isstring(factionName) and factionName ~= "" then
			fullNameTable[-200] = factionName
		end
	end

	-- Insert the rank prefix into the table.
	local rankPrefix = self:GetRankPrefix()
	if isstring(rankPrefix) and rankPrefix ~= "" then
		fullNameTable[-100] = rankPrefix
	else
		-- Fallback to rank name if no prefix is available.
		local rankName = self:GetRankName()
		if isstring(rankName) and rankName ~= "" then
			fullNameTable[-100] = rankName
		end
	end

	-- Allow other modules, to modify the full name.
	local colorTable = {[0] = self:GetFactionColor()}
	hook.Run("Character.GetFullName", self, fullNameTable, colorTable)

	return table.concat(NormalizeTable(fullNameTable), " "), colorTable[0]
end

-- Returns the limited roleplay name of the character.
--
-- @return String limitedName
-- @return Color factionColor
function Character.Meta:GetLimitedName()
	local limitedNameTable = {}

	-- Insert the faction prefix into the table.
	local factionPrefix = self:GetFactionPrefix()
	if isstring(factionPrefix) and factionPrefix ~= "" then
		limitedNameTable[-200] = factionPrefix
	else
		-- Fallback to faction name if no prefix is available.
		local factionName = self:GetFactionName()
		if isstring(factionName) and factionName ~= "" then
			limitedNameTable[-200] = factionName
		end
	end

	-- Insert the rank prefix into the table.
	local rankPrefix = self:GetRankPrefix()
	if isstring(rankPrefix) and rankPrefix ~= "" then
		limitedNameTable[-100] = rankPrefix
	else
		-- Fallback to rank name if no prefix is available.
		local rankName = self:GetRankName()
		if isstring(rankName) and rankName ~= "" then
			limitedNameTable[-100] = rankName
		end
	end

	-- Allow other modules, to modify the limited name.
	local colorTable = {[0] = self:GetFactionColor()}
	hook.Run("Character.GetLimitedName", self, limitedNameTable, colorTable)

	return table.concat(NormalizeTable(limitedNameTable), " "), colorTable[0]
end

-- Return all equipment applicable to the character by the faction and rank.
--
-- @param Character char
-- @param Faction faction
-- @param Rank rank
-- @return Table equipment
function Character:GetRelevantEquipment(char, faction, rank)
	local relevantEquipment = {}

	local equipment = faction:GetEquipment()
	for _, equip in ipairs(equipment) do
		local overrideAllow = hook.Run("Character.AllowEquipment", equip, char, faction, rank)
		if isbool(overrideAllow) then
			if overrideAllow then
				table.insert(relevantEquipment, equip)
			end

			continue
		end

		if not equip:IsRankWhitelisted(rank) then
			continue
		end

		local overrideBlock = hook.Run("Character.BlockEquipment", equip, char, faction, rank)
		if overrideBlock then
			continue
		end

		table.insert(relevantEquipment, equip)
	end

	return relevantEquipment
end

-- Return all equipment applicable to the character.
--
-- @return Table equipment
function Character.Meta:GetRelevantEquipment()
	local faction = self:GetFaction()
	local rank = self:GetRank()
	if not faction or not rank then
		return {}
	end

	local relevantEquipment = Character:GetRelevantEquipment(self, faction, rank)

	hook.Run("Character.GetRelevantEquipment", self, relevantEquipment)

	return relevantEquipment
end

-- Returns the valid models of a character by the given faction, rank and equipment.
--
-- @param Faction faction
-- @param Rank rank
-- @param Table relevantEquipment
-- @return Table validModels
function Character:GetValidModels(faction, rank, relevantEquipment)
    local validModels = {}

    -- Load models from the faction.
    if faction then
        validModels = faction:GetModels()
    end

    -- Load models from the rank and apply the blacklist filter again, to remove models, that are blacklisted by the rank.
    if rank then
        local rankModels = rank:GetModels()
        MergeTableByValue(validModels, rankModels)
        validModels = FilterBlacklist(validModels)
    end

    -- Load models from the equipment or remove them from the valid models, if they are blacklisted.
    local equipBlacklist = {}
    for _, equip in pairs(relevantEquipment) do
        local equipModels = equip:GetModels()
        if equip:GetProperty("blacklist", false) then
            MergeTableByValue(equipBlacklist, equipModels)
        else
            MergeTableByValue(validModels, equipModels)
        end
    end
    for _, model in pairs(equipBlacklist) do
        table.RemoveByValue(validModels, model)
    end

    return validModels
end

-- Determine all valid models of a character.
--
-- @return Table validModels
function Character.Meta:GetValidModels()
    local validModels = Character:GetValidModels(self:GetFaction(), self:GetRank(), self:GetRelevantEquipment())

    hook.Run("Character.GetValidModels", self, validModels)
    hook.Run("Character.RemoveValidModels", self, validModels)

    return validModels
end

-- Returns the valid skins of a character by the given faction, rank and equipment.
--
-- @param Faction faction
-- @param Rank rank
-- @param Table relevantEquipment
-- @return Boolean allSkins
-- @return? Table skinList
function Character:GetValidSkins(model, faction, rank, relevantEquipment)
	local validSkins = {}

	-- Load skins from the faction.
	if faction then
		local factionAllSkins, factionSkinList = faction:GetSkins(model)
		if factionAllSkins then
			return true, {}
		end

		if istable(factionSkinList) then
			validSkins = factionSkinList
		end
	end

	-- Load skins from the rank.
	if rank then
		local rankAllSkins, rankSkinList = rank:GetSkins(model)
		if rankAllSkins then
			return true, {}
		end

		-- Rank overrides faction skins, if the rank has a skin list.
		if istable(rankSkinList) then
			validSkins = rankSkinList
		end
	end

	-- Load skins from equipment.
	local equipBlacklist = {}
	for _, equip in pairs(relevantEquipment) do
		local equipAllSkins, equipSkinList = equip:GetSkins(model)

		-- Equipment is merged with the faction and rank skins.
		if equip:GetProperty("blacklist", false) then
			if equipAllSkins then
				return false, {}
			end

			MergeTableByValue(equipBlacklist, equipSkinList or {})
		else
			if equipAllSkins then
				return true, {}
			end

			MergeTableByValue(validSkins, equipSkinList or {})
		end
	end
	for _, skinId in pairs(equipBlacklist) do
		table.RemoveByValue(validSkins, skin)
	end

	return false, validSkins
end

-- Determine all valid skins of a character given a model.
--
-- @param String model
-- @return Table validSkins
function Character.Meta:GetValidSkins(model)
	local faction = self:GetFaction()
	local rank = self:GetRank()
	local relevantEquipment = self:GetRelevantEquipment()

	local allSkins, validSkins = Character:GetValidSkins(model, faction, rank, relevantEquipment)

	-- Get all skins if allSkins is true.
	if allSkins then
		for i = 0, GetModelSkinCount(model) - 1 do
			table.insert(validSkins, i)
		end
	end

	hook.Run("Character.GetValidSkins", self, model, faction, rank, relevantEquipment, validSkins)
	hook.Run("Character.RemoveValidSkins", self, model, faction, rank, relevantEquipment, validSkins)

	return validSkins
end

-- Determines all valid weapons of a character.
--
-- @return Table validWeapons
function Character.Meta:GetValidWeapons()
    local validWeapons = {}

    -- Load weapons from the faction.
    local faction = self:GetFaction()
    if faction then
        validWeapons = faction:GetWeapons()
    end

    -- Load weapons from the rank and apply the blacklist filter again, to remove weapons, that are blacklisted by the rank.
    local rank = self:GetRank()
    if rank then
        local rankWeapons = rank:GetProperty("weapons", {})
        MergeTableByValue(validWeapons, rankWeapons)

        validWeapons = FilterBlacklist(validWeapons)
    end

    -- Load weapons from the equipment or remove them from the valid weapons, if they are blacklisted.
    local equipBlacklist = {}
    local relevantEquipment = self:GetRelevantEquipment()
    for _, equip in pairs(relevantEquipment) do
        local equipWeapons = equip:GetProperty("weapons", {})
        if equip:GetProperty("blacklist", false) then
            MergeTableByValue(equipBlacklist, equipWeapons)
        else
            MergeTableByValue(validWeapons, equipWeapons)
        end
    end
    for _, weapon in pairs(equipBlacklist) do
        table.RemoveByValue(validWeapons, weapon)
    end

    hook.Run("Character.GetValidWeapons", self, validWeapons)
    hook.Run("Character.RemoveValidWeapons", self, validWeapons)

    return validWeapons
end

-- Determines the health, armor and speed of a character.
--
-- @return Number health
-- @return Number armor
function Character.Meta:GetStats()
	local rank = self:GetRank()

	-- Load stats from the rank.
	local health = rank:GetProperty("health", 100)
	local armor = rank:GetProperty("armor", 0)

	-- Apply stat modifiers from the equipment.
	local relevantEquipment = self:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		health = health + equip:GetProperty("healthBonus", 0)
		armor = armor + equip:GetProperty("armorBonus", 0)
	end

	local stats = {health, armor}
	hook.Run("Character.GetStats", self, stats)

	return stats[1] or 100, stats[2] or 0
end

-- Determines the speed and jump power of a character.
--
-- @return Number speed
-- @return Number jumpPower
function Character.Meta:GetMovement()
	local rank = self:GetRank()

	-- Load movement from the rank.
	local speed = rank:GetProperty("speed", 175)
	local jumpPower = rank:GetProperty("jumpPower", 200)

	-- Apply stat modifiers from the equipment.
	local relevantEquipment = self:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		speed = speed + equip:GetProperty("speedBonus", 0)
		jumpPower = jumpPower + equip:GetProperty("jumpBonus", 0)
	end

	local movement = {speed, jumpPower}
	hook.Run("Character.GetMovement", self, movement)

	return movement[1] or 175, movement[2] or 200
end

-- Determines the model scale of a character.
--
-- @return Number scale
function Character.Meta:GetScale()
	local rank = self:GetRank()

	-- Load scale from the rank.
	local scale = rank:GetProperty("scale", 1)

	local scaleTable = {scale}
	hook.Run("Character.GetScale", self, scaleTable)

	return math.Clamp(scaleTable[1] or 1, 0.8, 1.2)
end
--gamemodes/egmrp/gamemode/core/character/cl_characterselection.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client | Character Selection    --
---------------------------------------

-- Closes the character selection.
function CharacterSelection:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Opens the character selection.
--
-- @param Boolean hideCloseButton
function CharacterSelection:Open(hideCloseButton)
	self:Close()

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.Background)
	self.Frame:SetSubTitle(egmt("character.selection"))
	self.Frame:EnableCloseButton(not hideCloseButton)
	self.HideCloseButton = hideCloseButton

	self:CreateCharacterPanels()
	self:CreateSelectionButtons()

	hook.Run("CharacterSelection.Open", self)

	self.Frame:MakePopup()
end

-- Creates the character panels.
function CharacterSelection:CreateCharacterPanels()
	_self = self

	if IsValid(self.CharacterPanel) then
		self.CharacterPanel:Remove()
	end

	local w, h = ScrW(), ScrH()

	local offset = self.Offset or 0

	local characterPanel = vgui.Create("DPanel", self.Frame)
	characterPanel:SetPos(w * 0.075, h * 0.25)
	characterPanel:SetSize(w * 0.85, h * 0.7)
	function characterPanel:Paint(width, height)
		draw.RoundedBox(w * 0.01, 0, 0, width, height, UI.BackgroundColor)
	end

	local characters = LocalPlayer():GetCharacters()
	local cCount = #characters

	local shownCharacters = {}
	characterPanel.Panels = {}
	for i = 1, 5 do
		local cId = i + (offset or 0)
		if cCount <= 1 then
			cId = i - 2
		elseif cCount <= 3 then
			cId = i - 1
		elseif cCount <= 4 then
			cId = i
		else
			cId = cId % (cCount + 1)
		end

		local character = characters[cId]
		if character and table.HasValue(shownCharacters, character) then
			character = nil
		end

		local panel = vgui.Create("DPanel", characterPanel)
		panel:SetWide(w * 0.15)
		panel:DockMargin(0, 0, w * 0.025, 0)
		panel:Dock(LEFT)

		local characterName = ""
		local characterInfo = {}

		if character then
			characterName = character:GetRPName()

			local factionName = character:GetFactionPrefix()
			if not isstring(factionName) or factionName == "" then
				factionName = character:GetFactionName()
			end

			local rankName = character:GetRankName()
			if factionName and rankName then
				table.insert(characterInfo, factionName .. " - " .. rankName)
			end

			local rank = character:GetRank()
			if rank then
				local slotType = rank:GetProperty("slotType")
				table.insert(characterInfo, Rank.SlotTypes[slotType].name)
			end

			-- Allow other addons to draw on the character panel.
			hook.Run("CharacterSelection.GetCharacterInfo", panel, character, characterInfo)

			local isPlayable, errors = character:IsPlayable()
			if not isPlayable then
				for _, err in pairs(errors) do
					table.insert(characterInfo, {
						Color = GetColor("red"),
						Text = err
					})
				end

			end

		end

		function panel:Paint(width, height)
			if not character then
				draw.RoundedBox(w * 0.01, 0, 0, width, height, UI.BackgroundColor)

				return
			end

			draw.RoundedBox(w * 0.01, 0, 0, width, height, UI.BackgroundColor2)

			if self:IsHovered() then
				draw.RoundedBox(w * 0.01, 0, 0, width, height, GetColor("blue", 127))
			end

			draw.SimpleText(characterName, "EGMText10", width * 0.5, height * 0.01, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			for k, v in pairs(characterInfo) do
				local text = v
				local color = UI.TextColor
				if istable(v) then
					text = v.Text
					color = v.Color
				end

				draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.01 + k * height * 0.04, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			end
		end

		if character then
			local modelPanel = vgui.Create("EGMModelPanel", panel)
			modelPanel:Dock(FILL)
			modelPanel:SetCharacter(character)
			modelPanel:SetMouseInputEnabled(false)

			local playButton = vgui.Create("EGMButton", panel)
			playButton:SetTall(h * 0.05)
			playButton:Dock(BOTTOM)
			playButton:SetFont("EGMText10")
			playButton:SetTextColor(UI.TextColor)
			playButton:SetText(character:IsCurrentCharacter() and egmt("character.selection_continue") or egmt("character.selection_play"))
			playButton:SetButtonCornerRadius(w * 0.01)
			playButton:SetButtonCornerRound(false, false, true, true)
			function playButton:DoClick()
				if not character:IsCurrentCharacter() then
					net.Start("Player.ChangeCharacter")
						net.WriteInt(character:GetId(), 32)
					net.SendToServer()
				end

				_self:Close()
			end

			panel.ModelPanel = modelPanel
			panel.PlayButton = playButton

			table.insert(shownCharacters, character)
		else
			local createButton = vgui.Create("EGMButton", panel)
			createButton:SetPos(w * 0.025, h * 0.45 - w * 0.1)
			createButton:SetSize(w * 0.1, w * 0.1)
			createButton:SetText("")
			function createButton:Paint(ww, hh)
				local color = UI.ForegroundColor
				if self:IsHovered() then
					color = UI.ForegroundColor2
				end

				-- Draw a plus sign.
				draw.RoundedBox(0, 0, hh * 0.45, ww, hh * 0.1, color)
				draw.RoundedBox(0, ww * 0.45, 0, ww * 0.1, hh, color)
			end

			function createButton:DoClick()
				_self:Close()

				CharacterCreation:Open()
			end
		end

		characterPanel.Panels[i] = panel
	end

	self.CharacterPanel = characterPanel
end

-- Create the selection buttons.
function CharacterSelection:CreateSelectionButtons()
	_self = self

	if IsValid(self.LeftButton) then
		self.LeftButton:Remove()
	end

	if IsValid(self.RightButton) then
		self.RightButton:Remove()
	end

	local w, h = ScrW(), ScrH()

	self.Offset = self.Offset or 0

	local leftButton = vgui.Create("DButton", self.Frame)
	leftButton:SetPos(w * 0.0125, h * 0.5)
	leftButton:SetSize(w * 0.05, h * 0.2)
	leftButton:SetText("")
	function leftButton:Paint(width, height)
		if self:IsHovered() then
			surface.SetDrawColor(UI.ForegroundColor2)
		else
			surface.SetDrawColor(UI.ForegroundColor)
		end

		draw.NoTexture()
		surface.DrawPoly({
			{x = width * 0.1, y = height * 0.5},
			{x = width * 0.9, y = height * 0.1},
			{x = width * 0.3, y = height * 0.5},
			{x = width * 0.9, y = height * 0.9}
		})
	end
	function leftButton:DoClick()
		_self.Offset = _self.Offset - 1
		_self:CreateCharacterPanels()
	end

	local rightButton = vgui.Create("DButton", self.Frame)
	rightButton:SetPos(w * 0.9375, h * 0.5)
	rightButton:SetSize(w * 0.05, h * 0.2)
	rightButton:SetText("")
	function rightButton:Paint(width, height)
		if self:IsHovered() then
			surface.SetDrawColor(UI.ForegroundColor2)
		else
			surface.SetDrawColor(UI.ForegroundColor)
		end

		draw.NoTexture()
		surface.DrawPoly({
			{x = width * 0.9, y = height * 0.5},
			{x = width * 0.1, y = height * 0.9},
			{x = width * 0.7, y = height * 0.5},
			{x = width * 0.1, y = height * 0.1}
		})
	end
	function rightButton:DoClick()
		_self.Offset = _self.Offset + 1
		_self:CreateCharacterPanels()
	end

	self.LeftButton = leftButton
end

-- Updates the character selection, if the character is owned by the local player.
hook.Add("Character.Created", "CharacterSelection.Update", function(char)
	if not CharacterSelection.Frame then return end

	local ply = char:GetOwner()
	if LocalPlayer() ~= ply then return end

	CharacterSelection:CreateCharacterPanels()
end)
--gamemodes/egmrp/gamemode/modules/inventory/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Inventory         --
---------------------------------------

if not RequireModules({"bodygroups", "unarmed"}) then
	return false
end

-- TODO: Ultrawide Support

Inventory = Inventory or {}
ItemType = ItemType or table.Copy(PropertyModel)

-- Item slot type alignment global variables.
ITEM_SLOT_LEFT  = 1
ITEM_SLOT_RIGHT = 2
ITEM_SLOT_CENTER = 3
ITEM_SLOT_LEFT_TOP = 4

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_loaders.lua")

	AddCSLuaFile("sh_inventory.lua")
	AddCSLuaFile("cl_inventory.lua")
	AddCSLuaFile("sh_itemtype.lua")
	AddCSLuaFile("cl_itemtype.lua")

	AddCSLuaFile("cl_manager.lua")
	AddCSLuaFile("cl_inventory_gui.lua")
	AddCSLuaFile("cl_keybinds.lua")

	include("sh_config.lua")
	include("sh_loaders.lua")

	include("sh_inventory.lua")
	include("sv_inventory.lua")
	include("sh_itemtype.lua")
	include("sv_itemtype.lua")

	include("sv_net.lua")
	include("sv_eventlog.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_loaders.lua")

	include("sh_inventory.lua")
	include("cl_inventory.lua")
	include("sh_itemtype.lua")
	include("cl_itemtype.lua")

	include("cl_manager.lua")
	include("cl_inventory_gui.lua")
	include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/modules/bodygroups/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | BodyGroup System     --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Background of the Changing room menu.
BodyGroups.MenuBackground = "backgrounds/pajtajster_gwick.jpg"

-- Model for the Changing room.
BodyGroups.ChangingRoomModel = "models/props_wasteland/controlroom_storagecloset001a.mdl"

-- Dependencies of bodygroups.
-- A dependent bodygroups is only set on ApplyBodygroups, if the dependency is not set.
-- This does not affect, what is stored for the bodygroups of a character it just filters, what is applied to the player.
BodyGroups.Dependencies = {}
--[[
BodyGroups.Dependencies["Binoculars"] = {
	Dependency = "Head",
	DependencyNotSet = 1,
	ValueNotSet = 1,
}
]]

-- Incompatible bodygroups.
-- An incompatible bodygroup is reset, if its incompatible partner is set.
BodyGroups.Incompatibles = {}
--[[
BodyGroups.Incompatibles["Visor"]			= {
	Incompatible = "Binoculars",
	IncompatibleNotSet = 1,
	ValueNotSet = 1,
}
]]

-- Access to the /model command.
BodyGroups.AccessGroup = "operator"

BodyGroups.EnforceStrictModel = true
--gamemodes/egmrp/gamemode/modules/bodygroups/sh_bodygroups.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | BodyGroup System     --
---------------------------------------

-- Add character property: bodygroups
Character:AddProperty("bodygroups", "table", {}, function(char, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(char, ply)
	return true
end)

-- Get the bodygroups of the given character.
--
-- @return Table bodygroups
function Character.Meta:GetBodyGroups()
	return self:GetProperty("bodygroups", {})
end

-- You should be allowed to edit your own bodygroups.
hook.Add("Character.CanPlayerEditProperty.bodygroups", "Character.EditBodygroupsPermissions", function(ply, char, value)
	if char:BelongsTo(ply) then
		return true
	end
end)



---------------------------------------
--        Applying Bodygroups        --
---------------------------------------

-- Checks dependencies and returns true if the bodygroup should be set to the given value.
--
-- @param Entity ent
-- @param Table bodygroups
-- @param Number id
-- @param String name
-- @return Boolean shouldSet
-- @return? Number valueNotSet
function BodyGroups:ApplyDependency(ent, bodygroups, id, name)
	local dependencyData = self.Dependencies[name]
	if istable(dependencyData) then
		local bodyGroupId = ent:FindBodygroupByName(dependencyData.Dependency or "")
		if isnumber(bodyGroupId) and bodyGroupId ~= -1
		and bodygroups[bodyGroupId] == (dependencyData.DependencyNotSet or 0)
		and bodygroups[id] ~= nil and bodygroups[id] ~= (dependencyData.ValueNotSet or 0)
		then
			return true, dependencyData.ValueNotSet or 0
		end
	end

	return false
end

-- Checks incompatible bodygroups and returns true if the bodygroup should be set to the given value.
--
-- @param Entity ent
-- @param Table bodygroups
-- @param Number id
-- @param String name
-- @return Boolean shouldSet
-- @return? Number valueNotSet
function BodyGroups:ApplyIncompatibility(ent, bodygroups, id, name)
	for bodyGoupName1, incompatibleData in pairs(BodyGroups.Incompatibles) do
		local bodyGoupTable = incompatibleData.Incompatible
		if not istable(bodyGoupTable) then
			bodyGoupTable = {bodyGoupTable}
		end

		for _, bodyGoupName2 in ipairs(bodyGoupTable) do
			local valueNotSet
			local incompatibleName
			local incompatibleNotSet
			if bodyGoupName1 == name then
				valueNotSet = incompatibleData.ValueNotSet or 0

				incompatibleName = bodyGoupName2
				incompatibleNotSet = incompatibleData.IncompatibleNotSet or 0
			elseif bodyGoupName2 == name then
				valueNotSet = incompatibleData.IncompatibleNotSet or 0

				incompatibleName = bodyGoupName1
				incompatibleNotSet = incompatibleData.ValueNotSet or 0
			else
				continue
			end

			local bodyGroupId = ent:FindBodygroupByName(incompatibleName or "")
			if isnumber(bodyGroupId) and bodyGroupId ~= -1
			and (bodygroups[bodyGroupId] or 0) ~= (incompatibleNotSet or 0)
			and (bodygroups[id] or 0) ~= nil and (bodygroups[id] or 0) ~= (valueNotSet or 0)
			then
				return true, valueNotSet or 0
			end
		end
	end

	return false
end

-- Applies the given bodygroup to the entity internally.
--
-- @param Entity ent
-- @param Table bodygroups
function BodyGroups:ApplyInternal(ent, bodygroups)
	for _, data in pairs(ent:GetBodyGroups()) do
		local id = data.id
		local name = data.name

		-- Check, if a dependency is not met.
		local dependencyShouldSet, dependencyValue = self:ApplyDependency(ent, bodygroups, id, name)
		if dependencyShouldSet then
			ent:SetBodygroup(id, dependencyValue)

			continue
		end

		-- Check, if a incompatible bodygroup is set.
		local incompatibleShouldSet, incompatibleValue = self:ApplyIncompatibility(ent, bodygroups, id, name)
		if incompatibleShouldSet then
			ent:SetBodygroup(id, incompatibleValue)

			continue
		end

		-- Set the bodygroup to the given value.
		local bodyGroupData = bodygroups[id] or 0
		if isnumber(bodyGroupData) then
			ent:SetBodygroup(id, bodyGroupData)
		else
			ent:SetBodygroup(id, 0)
		end
	end
end

-- Applies the given bodygroup to the entity.
--
-- @param Character char
-- @param Entity ent
-- @param? Table bodygroups
function BodyGroups:Apply(char, ent, bodygroups)
	bodygroups = bodygroups or char:GetBodyGroups()

	-- Override default behaviour.
	local override = hook.Run("BodyGroups.Override", char, ent, bodygroups)
	if not override then
		self:ApplyInternal(ent, bodygroups)
	end

	hook.Run("BodyGroups.Apply", char, ent, bodygroups)
end
--gamemodes/egmrp/gamemode/modules/bodygroups/cl_bodygroups.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | BodyGroup System     --
---------------------------------------

-- Closes the bodygroups menu.
function BodyGroups:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Get the current bodygroups table of the character.
--
-- @param Character char
-- @return Table bodygroups
function BodyGroups:GetCurrentBodygroups(char)
	local bodygroups = table.Copy(char:GetBodyGroups())

	-- Allow overriding the bodygroups.
	local override = hook.Run("BodyGroups.OverrideBodygroups", char, bodygroups)
	if override then
		bodygroups = override
	end

	return bodygroups
end

-- Opens the body group menu.
function BodyGroups:Open()
	self:Close()

	local currentCharacter = LocalPlayer():GetCurrentCharacter()
	if not currentCharacter then return end

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.MenuBackground)
	self.Frame:SetSubTitle(egmt("bodygroups.appearance"))

	-- Initialize the bodygroups.
	self.Bodygroups = BodyGroups:GetCurrentBodygroups(currentCharacter)

	self:CreateModelPreview(currentCharacter)
	self:CreateModelSelection(currentCharacter)
	self:CreateBodyGroupSelection(currentCharacter)

	hook.Run("BodyGroups.Open", self, currentCharacter)

	self.Frame:MakePopup()
end

-- Creates the model selection.
--
-- @param Character char
function BodyGroups:CreateModelSelection(char)
	_self = self

	if IsValid(self.ModelSelection) then
		self.ModelSelection:Remove()
	end

	local modelSelection = vgui.Create("EGMScrollPanel", self.Frame)
	modelSelection:SetPos(ScrW() * 0.04, ScrH() * 0.25)
	modelSelection:SetSize(ScrW() * 0.08, ScrH() * 0.7)
	modelSelection:SetBackgroundColor(UI.BackgroundColor)

	-- Reloads the model selection.
	function modelSelection:Reload()
		self.ModelIcons = {}

		local validModels = char:GetValidModels()
		hook.Run("BodyGroups.AddValidModels", char, validModels)
		hook.Run("BodyGroups.RemoveValidModels", char, validModels)

		for _, model in pairs(validModels) do
			local validSkins = char:GetValidSkins(model)
			hook.Run("BodyGroups.AddValidSkins", char, model, validSkins)
			hook.Run("BodyGroups.RemoveValidSkins", char, model, validSkins)

			for _, skinId in pairs(validSkins) do
				local modelIcon = vgui.Create("EGMModelIcon", self)
				modelIcon:DockMargin(0, ScrH() * 0.005, 0, ScrH() * 0.005)
				modelIcon:SetSize(ScrW() * 0.08, ScrW() * 0.08)
				modelIcon:Dock(TOP)

				modelIcon:SetModel(model, skinId)
				modelIcon:SetDisplayType("body")
				modelIcon:GenerateIcon()

				table.insert(self.ModelIcons, modelIcon)

				function modelIcon:DoClick()
					surface.PlaySound(UI.ButtonSound)

					_self.ModelPreview:SetModelSkin(model, skinId)

					-- Re-Run the hook, so attached models are shown.
					char.ModelSkinOverride = {Model = model, SkinId = skinId}
					hook.Run("EGMModelPanel.SetCharacter", _self.ModelPreview, char)
					char.ModelSkinOverride = nil

					_self.BodyGroupSelection:Reload()
				end
			end
		end

		self:SetVisible(#self.ModelIcons > 0)
	end

	modelSelection:Reload()

	self.ModelSelection = modelSelection
end

-- Creates the bodygroup selection.
--
-- @param Character char
function BodyGroups:CreateBodyGroupSelection(char)
	_self = self

	if IsValid(self.BodyGroupSelection) then
		self.BodyGroupSelection:Remove()
	end

	local bodyGroupSelection = vgui.Create("EGMScrollPanel", self.Frame)
	bodyGroupSelection:SetPos(ScrW() * 0.6, ScrH() * 0.25)
	bodyGroupSelection:SetSize(ScrW() * 0.35, ScrH() * 0.6)
	bodyGroupSelection:SetBackgroundColor(UI.BackgroundColor)

	-- Adds a bodygroup to the bodygroup selection.
	function bodyGroupSelection:AddBodyGroup(id, name, n)
		local rows = math.ceil(n / 4)

		local bodyGroupPanel = vgui.Create("DPanel", self)
		bodyGroupPanel:DockMargin(0, ScrH() * 0.005, 0, ScrH() * 0.005)
		bodyGroupPanel:SetHeight(ScrH() * 0.03 * rows + ScrH() * 0.005 * (rows - 1))
		bodyGroupPanel:Dock(TOP)
		function bodyGroupPanel:Paint(ww, hh)
			draw.RoundedBox(5, 0, 0, ww, hh, UI.BackgroundColor2)

			draw.SimpleText(name, "EGMText10", ScrW() * 0.005, hh / 2, UI.ForegroundColor2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		local buttonPanel = vgui.Create("DPanel", bodyGroupPanel)
		buttonPanel:SetWide(ScrW() * 0.03 * 4 + ScrW() * 0.005 * 3)
		buttonPanel:Dock(RIGHT)
		function buttonPanel:Paint(ww, hh) end

		local ent = _self.ModelPreview.Entity
		if not IsValid(ent) then
			return
		end

		local value = _self.Bodygroups[id] or 0
		for row = 1, rows do
			local buttonRow = vgui.Create("DPanel", buttonPanel)
			buttonRow:SetTall(ScrH() * 0.03)
			buttonRow:DockMargin(0, 0, 0, ScrH() * 0.005)
			buttonRow:Dock(TOP)
			function buttonRow:Paint(ww, hh) end

			for column = 1, 4 do
				local i = (row - 1) * 4 + column
				if i > n then break end

				local button = vgui.Create("EGMButton", buttonRow)
				button:SetWide(ScrW() * 0.03)
				button:DockMargin(0, 0, ScrW() * 0.005, 0)
				button:Dock(LEFT)
				button:SetFont("EGMText12")
				button:SetTextColor(UI.TextColor)
				button:SetText(i)

				local override = hook.Run("BodyGroups.OverrideBodyGroup", button, ent, id, name, i)
				if override then
					continue
				end

				local selected = (value == i - 1)

				local color = GetColor("lightgray")
				if selected then
					color = UI.ForegroundColor2
				end

				local incompatibleSuccess = _self:ApplyIncompatibility(ent, _self.Bodygroups, id, name)
				if incompatibleSuccess and selected then
					color = GetColor("red")
				end

				local dependencySuccess = _self:ApplyDependency(ent, _self.Bodygroups, id, name)
				if dependencySuccess and selected then
					color = UI.ForegroundColor
				end

				button:SetButtonColor(color)

				function button:DoClick()
					surface.PlaySound(UI.ButtonSound)

					_self.Bodygroups[id] = i - 1

					_self:ApplyInternal(ent, _self.Bodygroups)

					_self.BodyGroupSelection:Reload()
				end
			end
		end
	end

	-- Reloads the bodygroup selection.
	function bodyGroupSelection:Reload()
		self:Clear()

		local ent = _self.ModelPreview.Entity
		if not IsValid(ent) then
			return
		end

		-- Add default bodygroups.
		local model = _self.ModelPreview.Model
		local skinId = _self.ModelPreview.SkinId
		local bodygroups = ent:GetBodyGroups()
		for id, bodyGroup in SortedPairs(bodygroups) do
			if bodyGroup.num <= 1 then continue end

			if hook.Run("BodyGroups.RestrictBodyGroup", char, model, skinId, bodyGroup) then
				-- Reset the bodygroup if it is restricted.
				_self.Bodygroups[id - 1] = nil

				continue
			end

			self:AddBodyGroup(id - 1, bodyGroup.name, bodyGroup.num)
		end

		-- Allow custom bodygroups to be added.
		hook.Run("BodyGroups.AddBodyGroups", self, char, ent)
	end

	bodyGroupSelection:Reload()

	self.BodyGroupSelection = bodyGroupSelection
end

-- Create the model preview.
--
-- @param Character char
function BodyGroups:CreateModelPreview(char)
	_self = self

	if IsValid(self.ModelPreview) then
		self.ModelPreview:Remove()
	end

	if IsValid(self.ApplyButton) then
		self.ApplyButton:Remove()
	end

	local modelPreview = vgui.Create("EGMModelPanel", self.Frame)
	modelPreview:SetPos(ScrW() * 0.14, ScrH() * 0.2)
	modelPreview:SetSize(ScrW() * 0.44, ScrH() * 0.8)
	modelPreview:SetCharacter(char)

	local applyButton = vgui.Create("EGMButton", self.Frame)
	applyButton:SetPos(ScrW() * 0.6, ScrH() * 0.9)
	applyButton:SetSize(ScrW() * 0.35, ScrH() * 0.05)
	applyButton:SetFont("EGMText12")
	applyButton:SetTextColor(UI.TextColor)
	applyButton:SetText(egmt("shared.apply"))
	applyButton:SetButtonColor(GetColor("green"))

	-- Applies the bodygroups.
	function applyButton:DoClick()
		surface.PlaySound(UI.ButtonSound)

		local ent = _self.ModelPreview.Entity
		if not IsValid(ent) then
			return
		end

		local model = _self.ModelPreview.Model
		local skinId = _self.ModelPreview.SkinId

		char.SkipSaveBodygroups = nil

		-- Ability to override the bodygroups save.
		hook.Run("BodyGroups.Save", char, model, skinId, _self.Bodygroups)
		if char.SkipSaveBodygroups then
			char.SkipSaveBodygroups = nil

			_self.Frame:Close()

			return
		end

		-- Edit model and skin first, so the bodygroups can be applied correctly.
		char:EditProperty("modelSkin", {
			Model = model,
			SkinId = skinId,
		})

		-- Remove invalid bodygroups from the bodygroups table.
		local bodygroups = ent:GetBodyGroups()
		for id, _ in pairs(_self.Bodygroups) do
			local foundBodyGroup = false
			for _, bodyGroup in pairs(bodygroups) do
				if bodyGroup.id == id then
					foundBodyGroup = bodyGroup
				end
			end

			if not foundBodyGroup then
				_self.Bodygroups[id] = nil
			end

			if value and value >= foundBodyGroup.num then
				_self.Bodygroups[id] = nil
			end
		end

		-- Apply the bodygroups.
		char:EditProperty("bodygroups", _self.Bodygroups)

		_self.Frame:Close()
	end

	self.ModelPreview = modelPreview
	self.ApplyButton = applyButton
end

-- Menu is opened when this net message is received.
net.Receive("BodyGroups.OpenMenu", function()
	BodyGroups:Open()
end)



---------------------------------------
--               Hooks               --
---------------------------------------

-- Apply bodygroups to all model panels.
hook.Add("EGMModelPanel.SetCharacter", "BodyGroup.SetModelPanel", function(panel, char)
	local ent = panel.Entity
	if not IsValid(ent) then return end

	BodyGroups:Apply(char, panel.Entity)
end)
--gamemodes/egmrp/gamemode/modules/bodygroups/entities/egmrp_changingroom/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | Changingroom Entity   --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = egmt("bodygroups.changing_room")
ENT.Category = "EGM:RP"
ENT.Author = "P4sca1 & Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.WorldModel = BodyGroups.ChangingRoomModel

-- Initializes the entity.
function ENT:Initialize()
	self.WorldModel = BodyGroups.ChangingRoomModel

	if util.IsValidModel(self.WorldModel) then
		self:SetModel(self.WorldModel)
	else
		self:SetModel("models/props_wasteland/controlroom_storagecloset001a.mdl")
	end
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)

	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
	end

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()
		phys:SetMass(50)
	end
end
--gamemodes/egmrp/gamemode/modules/unarmed/sh_index.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--          Unarmed | Index          --
---------------------------------------

if not RequireModules({"interact"}) then
	return false
end

Unarmed = Unarmed or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_unarmed.lua")
	AddCSLuaFile("cl_unarmed.lua")
	AddCSLuaFile("cl_interact.lua")
	AddCSLuaFile("sh_pickup.lua")
	AddCSLuaFile("cl_pickup.lua")

	include("sh_config.lua")
	include("sh_unarmed.lua")
	include("sv_unarmed.lua")
	include("sh_pickup.lua")
	include("sv_pickup.lua")
	include("sv_eventlog.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_unarmed.lua")
	include("cl_unarmed.lua")
	include("cl_interact.lua")
	include("sh_pickup.lua")
	include("cl_pickup.lua")
end
--gamemodes/egmrp/gamemode/modules/interact/cl_interactmenu.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       VGUI | EGMInteractMenu      --
---------------------------------------

-- VGUI Element that generates a round menu with n buttons to press.
--
-- Parent: DFrame.

local EGMInteractMenu = {}

local twopi = math.pi * 2
local pidiv2 = math.pi / 2
local twopiDiv90 = twopi / 90


-- Initializes the EGMInteractMenu.
function EGMInteractMenu:Init()
    self.Entries = {}
    self.EntryCount = 0

    self:SetPos(ScrW() * 0.5 - ScrH() * 0.35, ScrH() * 0.5 - ScrH() * 0.35)
    self:SetSize(ScrH() * 0.7, ScrH() * 0.7)
    self:SetDraggable(false)
    self:ShowCloseButton(false)
    self:SetTitle("")

    self.Page = 1
    self.Pages = 1
    self.PageSize = 8
    self.BackgroundColor = UI.BackgroundColor2
    self:SetBackgroundColor()
    self:SetCenterLabel()
    self:SetTextColor()

    self:MakePopup()
end

-- Acts on Mouse Pressed.
function EGMInteractMenu:OnMousePressed(keycode)
    local x, y = gui.MousePos()
    local bX, bY, bW, bH = self:GetBounds()

    local wD2 = bW / 2
    local hD2 = bH / 2

    local inBounds = false
    if x >= bX and x <= bX + bW and y >= bY and y <= bY + bH then
        inBounds = true
    end

    local mouseAngle = false
    local mouseRadius = false
    if inBounds then
        local lX = x - (bX + wD2)
        local lY = y - (bY + hD2)

        local lXs = lX / wD2
        local lYs = lY / hD2

        mouseAngle = math.atan2(-lYs, -lXs) + pidiv2
        if mouseAngle > twopi then
            mouseAngle = mouseAngle - twopi
        elseif mouseAngle < 0 then
            mouseAngle = mouseAngle + twopi
        end

        mouseRadius = math.sqrt(lX * lX + lY * lY)
    end

    local entries = self.Entries[self.Page] or {}
    local count = #entries
    local entryAngle = twopi / count

    if count == 0 then
        surface.PlaySound(UI.ButtonSound)

        self:Remove()
    end

    local endAngle = 0
    for i, entry in pairs(entries) do
        local startAngle = endAngle
        endAngle = i * entryAngle

        if mouseAngle and mouseAngle > startAngle and mouseAngle < endAngle and mouseRadius and mouseRadius < math.max(wD2, hD2) and mouseRadius > math.max(wD2, hD2) / 2.5 then
            surface.PlaySound(UI.ButtonSound)

            if isfunction(entry.callback) then
                entry.callback()
            end
        end
    end
end

-- Draws the EGMInteractMenu.
--
-- @param Number width
-- @param Number height
function EGMInteractMenu:Paint(width, height)
    local x, y = gui.MousePos()
    local bX, bY, bW, bH = self:GetBounds()

    local wD2 = bW / 2
    local hD2 = bH / 2
    local wDSel = bW / 20
    local hDSel = bH / 20
    local wDSel2 = wDSel / 2.5
    local hDSel2 = hDSel / 2.5

    local eW = wD2 - wDSel
    local eH = hD2 - hDSel
    local eW2 = eW / 2.5
    local eH2 = eH / 2.5

    local inBounds = false
    if x >= bX and x <= bX + bW and y >= bY and y <= bY + bH then
        inBounds = true
    end

    local mouseAngle = false
    local mouseRadius = false
    if inBounds then
        local lX = x - (bX + wD2)
        local lY = y - (bY + hD2)

        local lXs = lX / wD2
        local lYs = lY / hD2

        mouseAngle = math.atan2(-lYs, -lXs) + pidiv2
        if mouseAngle > twopi then
            mouseAngle = mouseAngle - twopi
        elseif mouseAngle < 0 then
            mouseAngle = mouseAngle + twopi
        end

        mouseRadius = math.sqrt(lX * lX + lY * lY)
    end

    local entries = self.Entries[self.Page] or {}
    local count = #entries
    local entryAngle = twopi / count

    draw.NoTexture()

    local endAngle = 0
    for i, entry in pairs(entries) do
        local startAngle = endAngle
        endAngle = i * entryAngle

        if mouseAngle and mouseAngle > startAngle and mouseAngle < endAngle and mouseRadius and mouseRadius < math.max(wD2, hD2) and mouseRadius > math.max(wD2, hD2) / 2.5 then
            entry.selected = math.min(entry.selected + 6 * FrameTime(), 1)
        else
            entry.selected = math.max(entry.selected - 2 * FrameTime(), 0)
        end

        surface.SetDrawColor(MixColor(entry.backgroundColor, entry.backgroundColorHovered, entry.selected))

        -- Inner Circle
        local segment = {}

        table.insert(segment, {
            x = -math.sin(startAngle + (endAngle - startAngle) / 2) * (eW + (entry.selected * wDSel)) + wD2,
            y =  math.cos(startAngle + (endAngle - startAngle) / 2) * (eH + (entry.selected * hDSel)) + hD2
        })

        table.insert(segment, {
            x = -math.sin(endAngle) * (eW2 + (entry.selected * wDSel2)) + wD2,
            y =  math.cos(endAngle) * (eH2 + (entry.selected * hDSel2)) + hD2
        })

        local j = endAngle - twopiDiv90
        while j > startAngle do
            table.insert(segment, {
                x = -math.sin(j) * (eW2 + (entry.selected * wDSel2)) + wD2,
                y =  math.cos(j) * (eH2 + (entry.selected * hDSel2)) + hD2
            })

            j = j - twopiDiv90
        end

        table.insert(segment, {
            x = -math.sin(startAngle) * (eW2 + (entry.selected * wDSel2)) + wD2,
            y =  math.cos(startAngle) * (eH2 + (entry.selected * hDSel2)) + hD2
        })

        surface.DrawPoly(segment)

        -- Outer Circle
        segment = {}

        table.insert(segment, {
            x = -math.sin(startAngle + (endAngle - startAngle) / 2) * (eW + (entry.selected * wDSel)) + wD2,
            y =  math.cos(startAngle + (endAngle - startAngle) / 2) * (eH + (entry.selected * hDSel)) + hD2
        })

        table.insert(segment, {
            x = -math.sin(startAngle) * (eW2 + (entry.selected * wDSel2)) + wD2,
            y =  math.cos(startAngle) * (eH2 + (entry.selected * hDSel2)) + hD2
        })

        table.insert(segment, {
            x = -math.sin(startAngle) * (eW + (entry.selected * wDSel)) + wD2,
            y =  math.cos(startAngle) * (eH + (entry.selected * hDSel)) + hD2
        })

        j = startAngle + twopiDiv90
        while j < endAngle do
            table.insert(segment, {
                x = -math.sin(j) * (eW + (entry.selected * wDSel)) + wD2,
                y =  math.cos(j) * (eH + (entry.selected * hDSel)) + hD2
            })

            j = j + twopiDiv90
        end

        table.insert(segment, {
            x = -math.sin(endAngle) * (eW + (entry.selected * wDSel)) + wD2,
            y =  math.cos(endAngle) * (eH + (entry.selected * hDSel)) + hD2
        })

        table.insert(segment, {
            x = -math.sin(endAngle) * (eW2 + (entry.selected * wDSel2)) + wD2,
            y =  math.cos(endAngle) * (eH2 + (entry.selected * hDSel2)) + hD2
        })

        surface.DrawPoly(segment)

        local textX = -math.sin((startAngle + endAngle) * 0.5) * (eW + (entry.selected * wDSel)) / 1.5 + wD2
        local textY =  math.cos((startAngle + endAngle) * 0.5) * (eH + (entry.selected * hDSel)) / 1.5 + hD2
        draw.SimpleText(entry.name, "EGMText8", textX, textY, MixColor(entry.textColor, entry.textColorHovered, entry.selected), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    surface.SetDrawColor(self.BackgroundColor)

    -- Center Label
    local segment = {}

    local j = 0
    while j < twopi do
        table.insert(segment, {
            x = -math.sin(j) * eW2 + wD2,
            y =  math.cos(j) * eH2 + hD2
        })

        j = j + twopiDiv90
    end

    surface.DrawPoly(segment)

    draw.SimpleText(self.CenterLabelText, "EGMText8", wD2, hD2, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

-- Adds an entry to the EGMInteractMenu.
--
-- @param Number page
-- @param String name
-- @param? Function callback
-- @param? Color textColor
-- @param? Color backgroundColor
-- @param? Color textColorHovered
-- @param? Color backgroundColorHovered
function EGMInteractMenu:AddInternalEntry(page, name, callback, textColor, backgroundColor, textColorHovered, backgroundColorHovered)
    if not self.Entries[self.Pages] then
        self.Entries[self.Pages] = {}
    end

    textColor = textColor or UI.TextColor or GetColor("white")
    backgroundColor = backgroundColor or UI.BackgroundColor or GetColor("darkgray", 200)
    textColorHovered = textColorHovered or GetColor("yellow")
    backgroundColorHovered = backgroundColorHovered or MixColor(backgroundColor, GetColor("white", backgroundColor.a), 0.2)

    table.insert(self.Entries[page], {
        name = name,
        callback = callback,
        textColor = textColor,
        backgroundColor = backgroundColor,
        textColorHovered = textColorHovered,
        backgroundColorHovered = backgroundColorHovered,
        selected = 0,
    })
end

-- Adds an entry to the EGMInteractMenu.
--
-- @param String name
-- @param? Function callback
-- @param? Color textColor
-- @param? Color backgroundColor
-- @param? Color textColorHovered
-- @param? Color backgroundColorHovered
function EGMInteractMenu:AddEntry(name, callback, textColor, backgroundColor, textColorHovered, backgroundColorHovered)
    self.EntryCount = self.EntryCount + 1
    self.Pages = math.ceil(self.EntryCount / self.PageSize)

    if self.Pages > #self.Entries then
        if not self.NoClose then
            self:AddInternalEntry(self.Pages, egmt("interact.close"), function() self:Remove() end, nil, nil, GetColor("red"))
        end

        if self.Entries[self.Pages - 1] then
            self:AddInternalEntry(self.Pages - 1, ">>>", function() self.Page = self.Page + 1 end)

            self:AddInternalEntry(self.Pages, "<<<", function() self.Page = self.Page - 1 end)
        end
    end

    self:AddInternalEntry(self.Pages, name, callback, textColor, backgroundColor, textColorHovered, backgroundColorHovered)
end

-- Sets the Page Size of a Menu.
-- Needs to be set BEFORE entries are added.
--
-- @param Number size
function EGMInteractMenu:SetPageSize(size)
    self.PageSize = size
end

-- Sets the Background color for the center label.
--
-- @param Color color
function EGMInteractMenu:SetBackgroundColor(color)
    self.BackgroundColor = color or UI.BackgroundColor2 or GetColor("darkgray", 200)
end

-- Sets the Text color for the center label.
--
-- @param Color color
function EGMInteractMenu:SetTextColor(color)
    self.TextColor = color or UI.TextColor or GetColor("white")
end

-- Sets the center Label Text
--
-- @param String text
function EGMInteractMenu:SetCenterLabel(text)
    self.CenterLabelText = text or egmt("interact.interact")
end

vgui.Register("EGMInteractMenu", EGMInteractMenu, "DFrame")

--gamemodes/egmrp/gamemode/modules/unarmed/sh_unarmed.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--          Unarmed | Server         --
---------------------------------------

-- Determine the angpos, where the ragdoll should be placed.
function Unarmed:GetTargetPos(ply)
	local trace = ply:GetEyeTrace()
	if not trace.Hit then
		return
	end

	local pos = trace.HitPos + Vector(0, 0, 32)
	local distance = pos:Distance(ply:GetPos())
	if distance > Unarmed.DropMaxDistance then
		return
	end

	-- Failsafe, if the position is not in the world.
	if not util.IsInWorld(pos) then
		print("Failsafe Triggered!")

		return
	end

	local ang = ply:EyeAngles()
	local carryAngle = ply:GetNWAngle("Unarmed.CarryAngle")
	ang = ang - carryAngle

	ang.p = 0
	return pos, ang
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Prevent weapon switching, if the player is carrying a ragdoll.
hook.Add("PlayerSwitchWeapon", "Unarmed.PlayerSwitchWeapon", function(ply, oldWeapon, newWeapon)
	if ply:GetNWBool("Unarmed.CarryingRagdoll") then
		local class = newWeapon:GetClass()

		-- Allow Switch to Unarmed
		if class == "egmrp_unarmed" then
			return
		end

		-- Allow Switch to Whitelisted Weapons
		if table.HasValue(Unarmed.WeaponWhitelist, class) then
			return
		end

		return true
	end

	-- Prevent switching, if the player is being carried.
	local carryPly = ply:GetNWEntity("Unarmed.CarriedPlayer")
	if IsValid(carryPly) then
		return true
	end
end)

-- Change speed, if the character is carrying a ragdoll.
-- Only load this hook, if the inventory weight module is not loaded, since that module already implements a similar hook.
if not Config.Modules["inventory_weight"] then
	hook.Add("Character.GetMovement", "Unarmed.SlowDown", function(char, movement)
		if not char:IsCurrentCharacter() then return end

		local ply = char:GetOwner()
		if not IsValid(ply) then return end

		if not ply:GetNWBool("Unarmed.CarryingRagdoll") then return end

		movement[1] = movement[1] / 1.5
	end)
end

-- Inventory Container Access based on an active animation.
-- Used by default, to allow players to be search while performing the surrender animation.
hook.Add("InventoryContainer.CanAccessInventory", "Unarmed.AccessInventoryOnAnimation", function(ply, targetChar)
	local targetPly = targetChar:GetOwner()
	if not IsValid(targetPly) then return end

	if not targetPly:GetNWBool("Unarmed.AnimationActive", false) then return end

	local animationId = targetPly:GetNWInt("Unarmed.AnimationId", 0)
	if animationId == 0 then return end

	local animationData = Unarmed.Animations[animationId]
	if not istable(animationData) then return end

	if not animationData.AccessInventory then return end

	return true
end)
--gamemodes/egmrp/gamemode/modules/inventory/sh_itemtype.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Item Type        --
---------------------------------------

-- Set sharedside property variables.
ItemType.Name = "ItemType"

-- Initialize networking.
ItemType:InitCreationNetworking()
ItemType:InitEditNetworking()
ItemType:InitDeletionNetworking()

-- Add item type property: name
ItemType:AddProperty("name", "string", nil, function(itemType, value)
	if not isstring(value) or #value < 3 then
		return false, egmt("itemType.invalid_name")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Used to get the name of a item type. Will use the name property or the id as a fallback.
--
-- @return String name
function ItemType.Meta:GetName()
	return self:GetProperty("name") or egmt("shared.itemType") .. " " .. self:GetId()
end

-- Override the getSort function to sort by name.
function ItemType.Meta:GetSort()
	return self:GetName()
end

-- Add item type property: itemClass
ItemType:AddProperty("itemClass", "string", "base", function(itemType, value)
	if not isstring(value) then
		return false, egmt("inventory.invalid_item_class_name")
	end

	local itemClass = Inventory:GetItemClassFromName(value)
	if not itemClass then
		return false, egmt("inventory.invalid_item_class")
	end

	-- Allow other modules to validate the item class.
	local override, err = hook.Run("ItemType.ValidateItemClass", itemType, value, itemClass)
	if isbool(override) then
		return override, err
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the item class of the item type.
--
-- @return ItemClass itemClass
function ItemType.Meta:GetItemClass()
	return Inventory:GetItemClassFromName(self:GetProperty("itemClass", ""))
end

-- Add item type property: rarity
ItemType:AddProperty("rarity", "number", 1, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the rarity of the item type.
--
-- @return Number rarity
function ItemType.Meta:GetRarity()
	return self:GetProperty("rarity", 1)
end

-- Limit access to the edit functions.
hook.Add("ItemType.CanPlayerEditProperties", "ItemType.EditPropertiesPermissions", function(ply, itemType, properties)
	return ply:IsAtLeast(ItemType.MinAccessGroup)
end)

hook.Add("ItemType.CanPlayerCreate", "ItemType.CreatePermissions", function(ply, data, properties)
	return ply:IsAtLeast(ItemType.MinAccessGroup)
end)

hook.Add("ItemType.CanPlayerDelete", "ItemType.DeletePermissions", function(ply, character)
	return ply:IsAtLeast(ItemType.MinAccessGroup)
end)



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- Add item type property: models
ItemType:AddProperty("models", "table", {}, function(itemType, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Get the models of the item type.
--
-- @return Table models
function ItemType.Meta:GetModels()
	return self:GetProperty("models", {})
end

-- Check, if the model is used by this item type.
--
-- @param String model
-- @param? Number skinId
-- @return Bool hasModel
function ItemType.Meta:HasModel(model, skinId)
	local override = hook.Run("ItemType.HasModel", self, model, skinId)
	if isbool(override) then
		return override
	end

	local models = self:GetModels()
	for _, modelData in pairs(models) do
		if isstring(modelData) and modelData == model then
			return true
		end

		if istable(modelData) and modelData.Model == model then
			if skinId == nil then
				return true
			end

			return table.HasValue(modelData.Skins or {}, skinId)
		end
	end

	return false
end

-- Find an item type using the model.
--
-- @param String model
-- @param? Number skinId
-- @param? ItemType ignoreItemType
-- @return Boolean success
-- @return ItemType itemType
function ItemType:FindByModel(model, skinId, ignoreItemType)
	self.ModelItemTypeCache = self.ModelItemTypeCache or {}
	local cacheId = model .. "_" .. (skinId or 0)

	-- Check, if the model is already cached.
	local cachedId = self.ModelItemTypeCache[cacheId]
	if isnumber(cachedId) then
		local itemType = self:GetCached(cachedId)
		if itemType and itemType ~= ignoreItemType and itemType:HasModel(model, skinId) then
			return true, itemType
		end
	end

	-- Find an item type using the model.
	for _, itemType in pairs(ItemType:GetCache()) do
		if itemType == ignoreItemType then continue end

		if itemType:HasModel(model, skinId) then
			self.ModelItemTypeCache[cacheId] = itemType:GetId()

			return true, itemType
		end
	end

	return false
end

-- Get all item types which has a specific class
--
-- @param String class
-- @return Table itemTypes
function ItemType:GetItemsByClass(class)
	local itemTypes = {}

	local itemCached = ItemType:GetCache()

	for _, itemType in pairs(itemCached) do
		if itemType:GetProperty("itemClass") == class then
			table.insert(itemTypes, itemType)
		end
	end

	return itemTypes
end

-- Check, if no other item type uses the model.
--
-- @param String model
-- @param? Number skinId
-- @return Bool isFree
function ItemType.Meta:IsModelFree(model, skinId)
	if ItemType:FindByModel(model, skinId, self) then
		return false
	end

	return true
end

-- Add item type property: armorBonus
ItemType:AddProperty("armorBonus", "number", 0, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the armor bonus of the item type.
--
-- @return Number armorBonus
function ItemType.Meta:GetArmorBonus()
	return self:GetProperty("armorBonus", 0)
end

-- Add item type property: speedBonus
ItemType:AddProperty("speedBonus", "number", 0, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the speed bonus of the item type.
--
-- @return Number speedBonus
function ItemType.Meta:GetSpeedBonus()
	return self:GetProperty("speedBonus", 0)
end

-- Add item type property: consealedWeapon
ItemType:AddProperty("consealedWeapon", "boolean", false, function(itemType, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns if the item type allows consealed weapons.
--
-- @return Boolean consealedWeapon
function ItemType.Meta:AllowsConsealedWeapon()
	return self:GetProperty("consealedWeapon", false)
end

-- Add item type property: backpackSlots
ItemType:AddProperty("backpackSlots", "number", 0, function(itemType, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	if value < 0 or value > 44 then
		return false, egmt("itemType.invalid_backpack_slots", 44)
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the amount of backpack slots of the item type.
--
-- @return Number backpackSlots
function ItemType.Meta:GetBackpackSlots()
	return self:GetProperty("backpackSlots", 0)
end

-- Add item type property: weapons
ItemType:AddProperty("weapons", "table", {}, function(itemType, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	-- Skip check, if exclusive weapons are disabled.
	if not Inventory.ExclusiveWeapons then
		return true
	end

	-- Check, if the weapon is already used by another item type.
	for _, weaponClass in pairs(value) do
		if not itemType:IsWeaponFree(weaponClass) then
			return false, egmt("itemType.weapon_already_used")
		end
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns the weapons of the item type.
--
-- @return Table weapons
function ItemType.Meta:GetWeapons()
	return self:GetProperty("weapons", {})
end

-- Check, if the weapon is used by this item type.
--
-- @param String weaponClass
-- @return Bool hasWeapon
function ItemType.Meta:HasWeapon(weaponClass)
	local weapons = self:GetProperty("weapons")
	if not istable(weapons) then
		return false
	end

	return table.HasValue(weapons, weaponClass)
end

-- Find an item type using the weapon.
--
-- @param String weaponClass
-- @param? ItemType ignoreItemType
-- @return Boolean success
-- @return ItemType itemType
function ItemType:FindByWeapon(weaponClass, ignoreItemType)
	self.WeaponItemTypeCache = self.WeaponItemTypeCache or {}

	-- Check, if the weapon is already cached.
	local cachedId = self.WeaponItemTypeCache[weaponClass]
	if isnumber(cachedId) then
		local itemType = self:GetCached(cachedId)
		if itemType and itemType ~= ignoreItemType and itemType:HasWeapon(weaponClass) then
			return true, itemType
		end
	end

	for _, itemType in pairs(ItemType:GetCache()) do
		if itemType == ignoreItemType then continue end

		local itemClass = itemType:GetItemClass()
		if not itemClass then continue end

		-- Allow item classes to use the property to add weapon but not be a weapon.
		if itemClass.SkipWeaponFind then continue end

		if itemType:HasWeapon(weaponClass) then
			self.WeaponItemTypeCache[weaponClass] = itemType:GetId()

			return true, itemType
		end
	end

	return false
end

-- Check, if no other item type uses the weapon.
--
-- @param String weaponClass
-- @return Bool isFree
function ItemType.Meta:IsWeaponFree(weaponClass)
	if ItemType:FindByWeapon(weaponClass, self) then
		return false
	end

	return true
end

if Config.Modules["species"] then
	-- Add item type property: species
	ItemType:AddProperty("species", "table", {}, function(itemType, value)
		if not istable(value) then
			return false, egmt("shared.invalid_type")
		end

		return true
	end,
	function(itemType, ply)
		return true
	end)

	-- Is the given species allowed to use this item type?
	--
	-- @param Species species
	-- @return Boolean allowed
	function ItemType.Meta:IsSpeciesAllowed(species)
		local speciesTable = self:GetProperty("species", {})
		if not istable(speciesTable) then
			return false
		end

		-- Empty table means all species are allowed.
		if table.IsEmpty(speciesTable) then
			return true
		end

		return table.HasValue(speciesTable, species:GetId())
	end
end
--gamemodes/egmrp/gamemode/modules/inventory/cl_inventory_gui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Inventory        --
---------------------------------------

-- Closes the inventory.
function Inventory:Close()
	if IsValid(self.Frame) then
		self.Frame:Remove()
	end
end

-- Opens the inventory.
--
-- @param Character char
-- @param? Number xOffset
-- @param? String context
function Inventory:Open(char, xOffset, context)
	self:Close()

	if not char then
		local ply = LocalPlayer()
		char = ply:GetCurrentCharacter()

		if not char then
			return
		end
	end

	self.Frame = vgui.Create("EGMSmallFrame")
	self.Frame:SetCustomTitle(egmt("inventory.title"))

	local oldX, oldY = self.Frame:GetPos()
	self.Frame:SetPos(oldX + (xOffset or 0), oldY)

	local content = vgui.Create("DPanel", self.Frame)
	content:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	content:Dock(FILL)
	function content:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end

	self.Frame:InvalidateLayout(true)

	self.Content = content
	self.Context = context

	local charEnt = char:GetOwner()
	self:CreatePlayerPreview(charEnt)
	self:CreatePlayerInventory(char)

	hook.Run("Inventory.Open", self)

	self.Frame:MakePopup()
end

-- Show the playermodel even in first person.
hook.Add("ShouldDrawLocalPlayer", "Testing", function(ply)
	if ply.InventoryRenderOverride then
		return true
	end
end)

-- Creates the player preview.
--
-- @param Entity charEnt
function Inventory:CreatePlayerPreview(charEnt)
	if IsValid(self.PlayerPreview) then
		self.PlayerPreview:Remove()
	end

	local panel = vgui.Create("DModelPanel", self.Content)
	panel:Dock(FILL)
	panel:SetMouseInputEnabled(false)
	function panel:LayoutEntity() end

	panel:SetEntity(charEnt)
	panel:SetFOV(10)

	-- Have the camera follow the player.
	function panel:Think()
		local pos = charEnt:GetPos()
		local forward = charEnt:GetForward()
		forward.z = 0
		forward:Normalize()

		self:SetLookAt(pos + Vector(0, 0, 36))
		self:SetCamPos(pos + Vector(0, 0, 36) + forward * 320)
	end

	function panel:PreDrawModel(ent)
		charEnt.InventoryRenderOverride = true
	end
	function panel:PostDrawModel(ent)
		charEnt.InventoryRenderOverride = false

		-- Call the normal hook.
		hook.Run("EGMModelPanel.PostDrawModel", self, ent)
	end

	hook.Run("Inventory.CreatePlayerPreview", panel, charEnt)

	self.PlayerPreview = panel
end

-- Creates the inventory.
--
-- @param Character char
function Inventory:CreatePlayerInventory(char)
	local content = self.Content
	if istable(content.InventorySlots) then
		for _, panels in pairs(content.InventorySlots) do
			for _, panel in pairs(panels) do
				if IsValid(panel) then
					panel:Remove()
				end
			end
		end
	end

	local w = self.Content:GetWide()
	local gridScale = math.floor(w / 12)

	content.InventorySlots = {}
	local inventory = char:GetInventory()

	for slotId, slotData in pairs(self.PlayerInventorySlots) do
		local slotType = slotData.Type
		if not isstring(slotType) then
			continue
		end
		local slotTypeClass = self:GetItemSlotClass(slotType)
		if not slotTypeClass then
			continue
		end

		local panels = slotTypeClass:CreateUI(content, slotId, slotData, gridScale, inventory, nil, function()
			local context = "player"
			if self.Context then
				context = self.Context .. "_player"
			end

			return context
		end)

		content.InventorySlots[slotId] = panels
	end

	hook.Run("Inventory.CreatePlayerInventory", content, char)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Update the inventory, if the property changes.
hook.Add("Character.PropertyChanged", "Inventory.Update", function(char, key)
	if not IsValid(Inventory.Frame) then return end

	if char:GetOwner() ~= LocalPlayer() then return end
	if not char:IsCurrentCharacter() then return end

	if key == "inventory" then
		Inventory:CreatePlayerInventory(char)
	end
end)

hook.Add("EscapeScreeen.Override", "Inventory.CloseOnEscape", function()
	if IsValid(Inventory.Frame) then
		Inventory:Close()

		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Keybinds | Inventory       --
---------------------------------------

-- Add a keybind, to open the inventory.
KeyBind:Register(egmt("inventory.key_name"), egmt("inventory.key_description"), function()
	Inventory:Open()
end, Inventory.DefaultKey)
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/armor/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Armor Item        --
---------------------------------------

-- This item class is used for armor, which can be equipped by the player.
-- Armor defines the skin of the player and adds protection against damage.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "base"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"body",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 1

-- Helper boolean to check if the item is an armor item.
ITEM_CLASS.IsArmor = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Validate the item data.
--
-- @param itemType
-- @param itemData
-- @return Boolean success
-- @return String error
function ITEM_CLASS:Validate(itemType, itemData)
	local override, err = hook.Run("Inventory.ValidateArmor", self, itemType, itemData)
	if isbool(override) then
		return override, err
	end

	local model = itemData.Model
	local skinId = itemData.SkinId or 0

	-- Check if the model is a string.
	if not isstring(model) then
		return false, egmt("inventory.no_model") -- Localize
	end

	-- Check if the model is valid.
	if not util.IsValidModel(model) then
		return false, egmt("inventory.invalid_model") -- Localize
	end

	-- Check if the skinId is a number.
	if not isnumber(skinId) then
		return false, egmt("inventory.no_skin_id") -- Localize
	end

	-- Check, if the model and skinid are whitelisted for the item type.
	for _, modelData in pairs(itemType:GetModels()) do
		if istable(modelData) then
			if modelData.Model == model and modelData.Skins[skinId] then
				return true
			end
		else
			if modelData == model then
				return true
			end
		end
	end

	return false, egmt("inventory.invalid_model_skin") -- Localize
end

-- Check, if slots are unlocked by this item.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @return Table additionalSlots
function ITEM_CLASS:UnLockSlots(inventory, itemType, itemData)
	local additionalSlots = ITEM_CLASS.Base.UnLockSlots(self, inventory, itemType, itemData) or {}

	-- Add consealed weapon slot, if the armor item allows it.
	if itemType:AllowsConsealedWeapon() then
		additionalSlots["weapon_consealed"] = math.max(additionalSlots["weapon_consealed"] or 0, 1)
	end

	-- Add backpack slots, if the armor item allows it.
	local backPackSlots = itemType:GetBackpackSlots()
	if backPackSlots > 0 then
		additionalSlots["backpack"] = (additionalSlots["backpack"] or 0) + backPackSlots
	end

	return additionalSlots
end

-- Helper function to get the name of the item.
--
-- @param String model
-- @param? Number skinId
-- @return String name
function ITEM_CLASS:GetItemName(model, skinId)
	local override = hook.Run("Inventory.GetArmorName", self, model, skinId)
	if isstring(override) then
		return override
	end

	local modelName = player_manager.TranslateToPlayerModelName(model)
	if isnumber(skinId) and skinId > 0 then
		modelName = modelName .. " (" .. skinId .. ")"
	end

	return modelName
end

-- Get all variants of the item as a table.
--
-- @param ItemType itemType
-- @return Table itemVariants
function ITEM_CLASS:GetVariants(itemType)
	local itemVariants = {}

	for _, model in pairs(itemType:GetModels()) do
		if istable(model) then
			itemVariants[model.Model] = self:GetItemName(model.Model) .. " (Random Skin)" -- TODO: Localize

			for skinId, enabled in pairs(model.Skins) do
				if not enabled then continue end

				itemVariants[model.Model .. "_" .. skinId] = self:GetItemName(model.Model, model.SkinId)
			end
		else
			itemVariants[model] = self:GetItemName(model) .. " (Random Skin)" -- TODO: Localize

			-- Insert all skins of the model as variants.
			local skinCount = GetModelSkinCount(model)
			for skinId = 1, skinCount do
				itemVariants[model .. "_" .. skinId] = self:GetItemName(model, skinId)
			end
		end
	end

	hook.Run("Inventory.GetArmorVariants", self, itemType, itemVariants)
	return itemVariants
end

-- Get item data from variant string.
--
-- @param ItemType itemType
-- @param String variant
-- @return? Table itemData
function ITEM_CLASS:GetVariantData(itemType, variant)
	if not isstring(variant) then
		return false
	end

	-- Handle Variants with model and skin selected.
	local split = string.Split(variant, ".mdl_")
	if #split == 2 then
		local model = split[1] .. ".mdl"
		local skinId = split[2]

		-- Convert to number, if possible.
		skinId = tonumber(skinId) or skinId

		return {
			TypeId = itemType:GetId(),

			Model = model,
			SkinId = skinId,
		}
	end

	-- Handle variants with only model selected.
	if variant ~= "" then
		local skinCount = GetModelSkinCount(variant)

		return {
			TypeId = itemType:GetId(),

			Model = variant,
			SkinId = math.random(0, skinCount - 1),
		}
	end

	-- Handle random variant recursively.
	local variants = self:GetVariants(itemType)
	return self:GetVariantData(itemType, table.Random(variants))
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Gets the name for the item.
--
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:GetName(itemType, itemData)
	return self:GetItemName(itemData.Model, itemData.SkinId)
end



---------------------------------------
--           Util Functions          --
---------------------------------------

-- Gets the current armor of the character.
--
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function Inventory:GetCurrentArmor(char, inventory)
	if char then
		-- Current characters have a cached armor item.
		if char:IsCurrentCharacter() then
			return char.CurrentArmorItem
		end

		inventory = inventory or char:GetInventory()
	end

	-- If the character is not the current character, we need to check the inventory manually.
	if istable(inventory) then
		for slotId, slotItemData in pairs(inventory) do
			if not Inventory:IsEquipmentSlot(slotId) then continue end

			for _, itemData in pairs(slotItemData) do
				local success, itemClass, _ = Inventory:GetItemClass(itemData)
				if not success then continue end
				if not itemClass.IsArmor then continue end

				return itemData
			end
		end
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Remove all models from the valid skins, which are used by armor items.
-- It is ONLY removed at the skin level, if there are skins in a model, which are not used by armor items.
hook.Add("Character.RemoveValidSkins", "Inventory.RemoveItems", function(char, model, faction, rank, relevantEquipment, validSkins)
	if char and char.SkipItemRemoval then return end

	local toBeRemoved = {}
	for _, skinId in pairs(validSkins) do
		if ItemType:FindByModel(model, skinId) then
			table.insert(toBeRemoved, skinId)
		end
	end

	for _, skinId in pairs(toBeRemoved) do
		table.RemoveByValue(validSkins, skinId)
	end
end)

-- Override the model skin of the character, if the character has an armor item equipped.
hook.Add("Character.OverrideModelSkin", "Inventory.OverrideWithArmor", function(char, modelSkin)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	return {
		Model = currentArmor.Model,
		SkinId = currentArmor.SkinId
	}
end)

-- Override the bodygroups of the item, if the character has an armor item equipped.
hook.Add("BodyGroups.Override", "Inventory.OverrideWithArmor", function(char, ent, bodygroups)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	-- Override the bodygroups with the ones from the armor item.
	BodyGroups:ApplyInternal(ent, currentArmor.Bodygroups or {})

	-- Prevent normal bodygroups from being applied.
	return true
end)

-- Change armor stats, if the character has an armor item equipped.
hook.Add("Character.GetStats", "Inventory.AddArmor", function(char, stats)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	local typeId = currentArmor.TypeId
	local itemType = ItemType:GetCached(typeId)
	if not itemType then return end

	local itemArmorBonus = itemType:GetArmorBonus()

	stats[2] = stats[2] + itemArmorBonus
end)

-- Change speed movement, if the character has an armor item equipped.
hook.Add("Character.GetMovement", "Inventory.AddArmor", function(char, movement)
	local currentArmor = Inventory:GetCurrentArmor(char)
	if not currentArmor then return end

	local typeId = currentArmor.TypeId
	local itemType = ItemType:GetCached(typeId)
	if not itemType then return end

	local itemSpeedBonus = itemType:GetSpeedBonus()

	movement[1] = movement[1] + itemSpeedBonus
end)

if Config.Modules["species"] then
	-- Restrict armor items to certain species.
	hook.Add("Inventory.CanAddItem", "Inventory.RestrictArmorSpecies", function(char, itemData, slotId, subId)
		if not Inventory:IsEquipmentSlot(slotId) then return end

		local itemType = ItemType:GetCached(itemData.TypeId)
		if not itemType then return end

		local itemClass = itemType:GetItemClass()
		if not itemClass then return end

		if not itemClass.IsArmor then return end

		local species = char:GetSpecies()
		if not species then return end

		if itemType:IsSpeciesAllowed(species) then return end

		return false, egmt("inventory.species_not_allowed", species:GetName())
	end)
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/base/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Base Item        --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = false

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {}

-- Sorting order of the item.
ITEM_CLASS.Sort = 0

-- Allow stacking of the item outside of storage.
ITEM_CLASS.AlwaysStack = false



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Validate the item data.
--
-- @param itemType
-- @param itemData
-- @return Boolean success
-- @return String error
function ITEM_CLASS:Validate(itemType, itemData)
	return false, "Not implemented." -- TODO: Localize
end

-- Check, if slots are unlocked by this item.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @return Table additionalSlots
function ITEM_CLASS:UnLockSlots(inventory, itemType, itemData)
	local additionalSlots = {}
	hook.Run("Inventory.UnLockSlots", self, inventory, itemType, itemData, additionalSlots)

	return additionalSlots
end

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	local slots = self.Slots
	if #slots == 0 then
		return false, egmt("inventory.no_slots")
	end

	-- If the slotType is given, check if it is a valid slot.
	if not isstring(slotType) then
		return false, egmt("inventory.invalid_slot")
	end

	if table.HasValue(slots, slotType) then
		return true
	end

	return false, egmt("inventory.incompatible_slot")
end

-- Get all variants of the item as a table.
--
-- @param ItemType itemType
-- @return Table variants
function ITEM_CLASS:GetVariants(itemType)
	return {}
end

-- Get item data from variant string.
--
-- @param ItemType itemType
-- @param String variant
-- @return? Table itemData
function ITEM_CLASS:GetVariantData(itemType, variant)
	return false
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Gets the name for the item.
--
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:GetName(itemType, itemData)
	return itemType:GetName()
end

-- Gets the rarity for the item.
--
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:GetRarity(itemType, itemData)
	return itemType:GetRarity()
end

-- Gets the rarity color for the item.
--
-- @param ItemType itemType
-- @param Table itemData
-- @return Color rarityColor
function ITEM_CLASS:GetRarityColor(itemType, itemData)
	local rarity = self:GetRarity(itemType, itemData)

	local rarityData = Inventory.Rarities[rarity]
	if not istable(rarityData) then
		return Color(255,0, 0, 255)
	end

	return rarityData.Color or UI.ForegroundColor
end

-- Gets the rarity name for the item.
--
-- @param ItemType itemType
-- @param Table itemData
-- @return String rarityName
function ITEM_CLASS:GetRarityName(itemType, itemData)
	local rarity = self:GetRarity(itemType, itemData)

	local rarityData = Inventory.Rarities[rarity]
	if not istable(rarityData) then
		return egmt("inventory.rarity.unknown")
	end

	return rarityData.Name or egmt("inventory.rarity.common")
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/base/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Base Item        --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Base Item"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {}

-- Determine if a propertymodel property should be shown, if this item class is used.
--
-- @param String propertyName
-- @return Boolean shouldShow
function ITEM_CLASS:ShouldShowProperty(propertyName)
	return table.HasValue(self.PropertyList, propertyName)
end

-- Create the item panel for the item.
--
-- @param Panel parent
-- @param Table itemData
function ITEM_CLASS:CreateItemPanel(parent, itemData)
	function parent:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, Color(0, 0, 0, 255))

		draw.SimpleText("[???]", "EGMText6", ww / 2, hh / 2, Color(255, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	function parent:PaintOver(ww, hh)
		local stackSize = itemData.StackSize or 1
		if stackSize <= 1 then return end

		draw.SimpleText(stackSize, "EGMText8", ww - 5, hh - 5, UI.ForegroundColor2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)
	end
end

-- Callback run, when the item is equipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnEquip(ply, char, itemType, itemData)
end

-- Callback run, when the item is unequipped.
-- Clientside this includes the item being dropped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnUnequip(ply, char, itemType, itemData)
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Callback run, when the item is showing in the inventory tooltip.
--
-- @param ItemType itemType
-- @param Table itemData
-- @param Table lines
function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
end

-- Gets the tooltip lines for the item.
--
-- @param ItemType itemType
-- @param Table itemData
-- @param Boolean detailed
-- @return Table lines
function ITEM_CLASS:GetTooltipLines(itemType, itemData, detailed)
	local lines = {}

	table.insert(lines, {
		Text = self:GetName(itemType, itemData),
		Color = self:GetRarityColor(itemType, itemData)
	})

	if detailed then
		self:AddDescriptionLines(itemType, itemData, lines)
	end

	table.insert(lines, {})

	hook.Run("Inventory.AddTooltipLines", self, itemType, itemData, detailed, lines)

	local stackSize = itemData.StackSize or 1
	if stackSize > 1 then
		table.insert(lines, {
			Text = egmt("inventory.stack_size", stackSize),
			Color = UI.TextColor,
			Align = TEXT_ALIGN_RIGHT
		})
	end

	table.insert(lines, {
		Text = egmt("inventory.rarity", self:GetRarityName(itemType, itemData)),
		Color = self:GetRarityColor(itemType, itemData),
		Align = TEXT_ALIGN_RIGHT
	})

	return lines
end



---------------------------------------
--            UI Behaviour           --
---------------------------------------

-- Callback run, to add additional context menu options to the item.
--
-- @param Table slot
-- @param Panel dermaMenu
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:AddContextMenuOptions(slot, dermaMenu, itemType, itemData)
	local slotId, subId, context = slot:GetId()

	if not string.find(context, "player") then return end

	dermaMenu:AddOption(egmt("inventory.drop"), function()
		local curTime = CurTime()
		if (Inventory.LastNetMessage or 0) + Inventory.NetworkDelay < curTime then
			net.Start("Inventory.DropItem")
				net.WriteString(slotId)
				net.WriteUInt(subId, 16)
				net.WriteString(context)
			net.SendToServer()
		end

		Inventory.LastNetMessage = curTime
	end):SetIcon("icon16/arrow_down.png")
end

-- Override this function, to change the drag-and-drop behaviour of the item.
--
-- @param Table slot
-- @param Table dragSlot
-- @param ItemType itemType
-- @param Table itemData
-- @return Boolean override
function ITEM_CLASS:OnDragDrop(slot, dragSlot, itemType, itemData)
	local dragSlotId, dragSubId, dragContext = dragSlot:GetId()
	local slotId, subId, context = slot:GetId()

	local override = hook.Run("Inventory.OnDragDrop", self, slot, dragSlot, itemType, itemData)
	if override then
		return true
	end

	local curTime = CurTime()
	if (Inventory.LastNetMessage or 0) + Inventory.NetworkDelay < curTime then
		net.Start("Inventory.SwapItem")
			net.WriteString(dragSlotId)
			net.WriteUInt(dragSubId, 16)
			net.WriteString(dragContext)
			net.WriteString(slotId)
			net.WriteUInt(subId, 16)
			net.WriteString(context)
		net.SendToServer()
	end

	Inventory.LastNetMessage = curTime
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_big/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "weapon_small"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"weapon_big",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 110
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_big/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory.item_class_weapon_big")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_grenade/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "weapon"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"belt",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 130
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/body/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Back Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_consealed/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.weapon_consealed_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/egmrp/gamemode/modules/comlink/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Chat config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum access grou, to access the custom com channels.
ComChannel.MinAccessGroup = "superadmin"
--gamemodes/egmrp/gamemode/modules/comlink/sh_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Shared | Comlink Integration    --
---------------------------------------

if not Config.Modules["course"] then return end

-- Add course property: hasComlink
hook.Add("EGMRP.Loaded", "Comlink.RegisterCourseProperties", function()
	Course:AddProperty("hasComlink", "boolean", false, function(course, value)
		if not isbool(value) then
			return false, egmt("shared.invalid_type")
		end

		return true
	end,
	function(course, ply)
		return true
	end)

	-- Returns, if the course has a comlink
	--
	-- @return Boolean hasComlink
	function Course.Meta:HasComlink()
		return self:GetProperty("hasComlink", false)
	end

	-- Add course property to the list
	if CLIENT then
		Course:AddPropertyToList("hasComlink", egmt("comlink.courseHas"), egmt("comlink.courseHas_description"), "boolean", nil, nil, 1, egmt("comlink.category"))
	end
end)

-- Create a course comlink channel.
--
-- @param Course course
-- @return Table comlinkData
function Comlink:CreateCourseChannel(course)
	if not course then return end
	if not course:HasComlink() then return end

	local comlinkData = Comlink:RegisterChannel("course", course:GetId(), course:GetName())
	comlinkData.AccessCourse = course

	return comlinkData
end

-- Create a comlink channel for every course on load.
hook.Add("Course.Load", "Comlink.AddCourseChannel", function(course)
	Comlink:CreateCourseChannel(course)
end)

-- Create a comlink channel for a course on creation.
hook.Add("Course.Created", "Comlink.CreateCourseChannel", function(course)
	Comlink:CreateCourseChannel(course)
end)

-- Remove a comlink channel for a course on deletion.
hook.Add("Course.Delete", "Comlink.RemoveCourseChannel", function(course)
	Comlink.Channels["course_" .. course:GetId()] = nil
end)

-- Update comlink channel for a course on property change.
hook.Add("Course.PropertyChanged", "Comlink.AddCourseChannel", function(course,  key, value)
	Comlink.Channels["course_" .. course:GetId()] = nil

	Comlink:CreateCourseChannel(course)
end)

-- Add course access to comlink channels.
hook.Add("Comlink.AddCustomAccess", "Comlink.AddCourseAccess", function(self, currentCharacter, comlinkData)
	local course = comlinkData.AccessCourse
	if not course then return end

	local courses = currentCharacter:GetCourses()
	if table.Count(courses) == 0 then return end

	if table.HasValue(courses, course:GetId()) then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/base_model/sh_inventory_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Base Model        --
---------------------------------------

-- Add ItemType property: materialSets
ItemType:AddProperty("materialSets", "table", {}, function(itemType, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Get the material sets for a item type.
function ItemType.Meta:GetMaterialSets()
	return self:GetProperty("materialSets", {})
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Add the abiliy to ItemTypes, to be detected via base model material sets.
hook.Add("ItemType.HasModel", "BaseModel.OverrideBaseModel", function(itemType, model, skinId)
	if not isstring(model) then return end
	skinId = skinId or 0

	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return end

	-- Allow the default skin.
	if isnumber(skinId) and skinId == 0 then
		local materialSets = itemType:GetMaterialSets()
		if table.HasValue(materialSets, model) then
			return true
		end
	else
		local materialSetData = baseModelData.MaterialSets[skinId]
		if not istable(materialSetData) then
			return false
		end

		local models = itemType:GetModels()
		for _, modelData in pairs(models) do
			local otherModel = modelData
			if istable(modelData) then
				otherModel = modelData.Model
			end

			if otherModel ~= model then continue end

			local materialSets = itemType:GetMaterialSets()
			if not table.HasValue(materialSets, model .. "_" .. skinId) then continue end

			return true
		end
	end

	return false
end)

-- Override Model Name
hook.Add("Inventory.GetArmorName", "BaseModel.OverrideModelName", function(itemClass, model, skinId)
	if not isstring(model) or not isstring(skinId) then return end

	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return end

	local materialSetData = baseModelData.MaterialSets[skinId]
	if not istable(materialSetData) then return end

	return materialSetData.Name
end)

-- Add material sets to the armor variants table.
hook.Add("Inventory.GetArmorVariants", "BaseModel.AddMaterialSets", function(self, itemType, itemVariants)
	for _, materialSetString in pairs(itemType:GetMaterialSets()) do
		local split = string.Split(materialSetString, ".mdl_")

		local model = split[1] .. ".mdl"
		local materialSet = split[2]

		local baseModelData = BaseModel:GetBaseModel(model)
		if not istable(baseModelData) then continue end

		local materialSetData = baseModelData.MaterialSets[materialSet]
		if not istable(materialSetData) then continue end

		itemVariants[materialSetString] = materialSetData.Name
	end
end)

hook.Add("Inventory.ValidateArmor", "BaseModel.ValidateMaterialSets", function(itemClass, itemType, itemData)
	local model = itemData.Model
	local skinId = itemData.SkinId

	-- Return to normal validation if the model or skinId is not a string.
	if not isstring(model) or not isstring(skinId) then return end
	if not util.IsValidModel(model) then return end

	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return false, "Invalid Base Model" end

	local materialSetData = baseModelData.MaterialSets[skinId]
	if not istable(materialSetData) then return false, "Invalid Material Set Id" end

	-- Check, if the material set is allowed for the item type.
	local materialSets = itemType:GetMaterialSets()

	if not table.HasValue(materialSets, model .. "_" .. skinId) then
		return false, "Invalid Material Set"
	end

	return true
end)
--gamemodes/egmrp/gamemode/modules/thirdperson/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Third Person System         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Default Key to toggle the third person view.
ThirdPerson.DefaultToggleKey = KEY_T

-- Distance of the camera towards the player.
ThirdPerson.Distance = 100
--gamemodes/egmrp/gamemode/modules/thirdperson/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--  Client | Third Person Keybinds   --
---------------------------------------

-- Register a keybind for the third person toggle.
KeyBind:Register(egmt("thirdperson.toggle"), egmt("shared.normal"), function()
    ThirdPerson:Toggle()
end, ThirdPerson.DefaultToggleKey)
--gamemodes/egmrp/gamemode/modules/developer/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Developer | Index          --
---------------------------------------

Developer = Developer or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_developer.lua")

	include("sh_config.lua")
	include("sh_developer.lua")
	include("sv_developer.lua")
	include("sv_chats.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_developer.lua")
end
--gamemodes/egmrp/gamemode/modules/species/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Config | Species         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum group, to access editing the species of a character.
Species.MinAccessGroup = "operator"

-- List of DamageTypes that species can be immune to.
-- Damage Types can be found here: https://wiki.facepunch.com/gmod/Enums/DMG
Species.DamageTypes = {
	[DMG_BURN] = "Fire",
	[DMG_POISON] = "Poison",
	[DMG_DROWN] = "Drown",
}
--gamemodes/egmrp/gamemode/modules/inventory_private/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Index | Inventory Private     --
---------------------------------------

if not RequireModules({"inventory_storage"}) then
	return false
end

InventoryPrivate = InventoryPrivate or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_inventory_private.lua")
	AddCSLuaFile("cl_inventory_private.lua")

	include("sh_config.lua")
	include("sh_inventory_private.lua")
	include("sv_inventory_private.lua")

	include("sv_net.lua")
	include("sv_eventlog.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_inventory_private.lua")
	include("cl_inventory_private.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Index | Inventory Storage     --
---------------------------------------

if not RequireModules({"inventory"}) then
	return false
end

InventoryStorage = InventoryStorage or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")

	AddCSLuaFile("cl_inventory_storage.lua")
	AddCSLuaFile("cl_net.lua")

	include("sh_config.lua")

	include("sv_inventory_storage.lua")
	include("sv_net.lua")
end

if CLIENT then
	include("sh_config.lua")

	include("cl_inventory_storage.lua")
	include("cl_net.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/entities/egmrp_storage/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Storage Entity      --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")

-- Drawing the model.
function ENT:Draw()
	self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/entities/egmrp_storage/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Storage Entity      --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = egmt("inventory_storage.entity")
ENT.Category = "EGM:RP"
ENT.Author = "Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.IsInventoryStorage = true

ENT.WorldModel = InventoryStorage.Model

-- Initializes the entity.
function ENT:Initialize()
	self.WorldModel = InventoryStorage.Model

	if util.IsValidModel(self.WorldModel) then
		self:SetModel(self.WorldModel)
	else
		self:SetModel("models/Items/ammocrate_smg1.mdl")
	end
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)

	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
	end

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()
		phys:SetMass(50)
	end
end
--gamemodes/egmrp/gamemode/modules/inventory_money/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | InventoryMoney      --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- The delay in minutes between paychecks.
InventoryMoney.PaycheckDelay = 10

-- Minimum rank, to be able to give money to other players.
InventoryMoney.GiveMoneyRank = "admin"

-- The ammount of money, which is assumed to generate the item icon.
InventoryMoney.PreviewCount = 1

-- Models for money when dropped depending on the amount.
InventoryMoney.Models = {
	--[[
	{
		Model = "models/egm/core/credits/single_credit/single_credit.mdl",
		MaxAmount = 10,
	},
	{
		Model = "models/egm/core/credits/little_credits/little_credits.mdl",
		MinAmount = 11,
		MaxAmount = 100,
	},
	{
		Model = "models/egm/core/credits/big_credits/big_credits.mdl",
		MinAmount = 101,
		MaxAmount = 1000,
	},

	-- Box Model
	{
		Model = "models/cire992/props/hvywepcrate01.mdl",
		Skin = 2,

		MinAmount = 1001,
	},
	]]
}
--gamemodes/egmrp/gamemode/modules/inventory_money/item_classes/money/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Money Item        --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory_money.item_class_money")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {}



-- Create the item panel for the item.
-- Displays a centered, properly zoomed in model of the swep.
--
-- @param Panel parent
-- @param Table itemData
function ITEM_CLASS:CreateItemPanel(parent, itemData)
	ITEM_CLASS.Base.CreateItemPanel(self, parent, itemData)

	local model, skinId = self:GetMoneyModel(InventoryMoney.PreviewCount)

	function parent:Paint(ww, hh)
	end

	local modelIcon = vgui.Create("EGMModelIcon", parent)
	modelIcon:Dock(FILL)
	modelIcon:SetMouseInputEnabled(false)

	modelIcon:SetModel(model, skinId)
	modelIcon:SetDisplayType("Money")

	modelIcon:SetSize(math.floor(ScrW() * 0.1), math.floor(ScrW() * 0.1))
	modelIcon:GenerateIcon()

	parent.ModelIcon = modelIcon
end

---------------------------------------
--            UI Behaviour           --
---------------------------------------

-- Callback run, to add additional context menu options to the item.
--
-- @param Table slot
-- @param Panel dermaMenu
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:AddContextMenuOptions(slot, dermaMenu, itemType, itemData)
	ITEM_CLASS.Base.AddContextMenuOptions(self, slot, dermaMenu, itemType, itemData)

	-- Only add the context menu options for the player inventory.
	local slotId, subId, context = slot:GetId()
	if not string.find(context, "player") then return end

	dermaMenu:AddSpacer()

	dermaMenu:AddOption(egmt("inventory_money.merge"), function()
		net.Start("InventoryMoney.Merge")
		net.SendToServer()
	end):SetIcon("icon16/arrow_merge.png")

	if itemData.StackSize > 1 then
		dermaMenu:AddOption(egmt("inventory_money.split"), function()
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("inventory_money.split"))
			modal:Slider(egmt("inventory_money.split_description"), function(ammount)
				net.Start("InventoryMoney.Split")
					net.WriteString(slotId)
					net.WriteUInt(subId, 16)
					net.WriteUInt(ammount, 32)
				net.SendToServer()
			end, nil, 1, itemData.StackSize, 0)
		end):SetIcon("icon16/arrow_divide.png")
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override Camera Position for the model icon.
hook.Add("EGMModelIcon.OverrideDisplay", "InventoryMoney.OverrideMoney", function(displayType, modelPanel, ent)
	if displayType ~= "Money" then return end

	modelPanel:SetLookAt(Vector(0, 0, 0))
	modelPanel:SetCamPos(Vector(0, 0, 50))

	return true
end)
--gamemodes/egmrp/gamemode/modules/instructor/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Instructor | index         --
---------------------------------------

Instructor = Instructor or {}
InstructorManager = InstructorManager or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_instructor.lua")
    AddCSLuaFile("cl_instructor.lua")
    AddCSLuaFile("cl_manager.lua")
    AddCSLuaFile("cl_keybinds.lua")
    AddCSLuaFile("cl_scoreboard.lua")

    include("sh_config.lua")
    include("sh_instructor.lua")
    include("sv_instructor.lua")
    include("sv_manager.lua")
    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_instructor.lua")
    include("cl_instructor.lua")
    include("cl_manager.lua")
    include("cl_keybinds.lua")
    include("cl_scoreboard.lua")
end
--gamemodes/starwarsrp/gamemode/modules/backpack/cl_backpack.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Backpack         --
---------------------------------------

ItemType:AddPropertyToList("backpackSlot", "Rücken Slot", "Sollte die Rüstung einen Rücken Slot haben?", "boolean", nil, nil, 3, egmt("inventory.title"))

-- Show the back slot property.
hook.Add("ItemClass.ShouldShowProperty", "Backpack.ShowProperties", function(itemClass, propertyName)
	if not itemClass.IsArmor then return end

	if propertyName == "backpackSlot" then
		return true
	end
end)



---------------------------------------
--       BoneMerge Integration       --
---------------------------------------

-- Add the species head model to the bone merge system.
InventoryBoneMerge:RegisterCharacterModel("Backpack", function(char)
	local currentBackpack = Inventory:GetCurrentBackpack(char)
	if not currentBackpack then return end

	return currentBackpack.Model
end, function(char, clientEnt)
	local currentBackpack = Inventory:GetCurrentBackpack(char)
	if not currentBackpack then return end

	local model = currentBackpack.Model
	local materialSetId = currentBackpack.SkinId
	if isstring(model) and materialSetId ~= nil then
		BaseModel:ApplyBaseModel(clientEnt, model, materialSetId)
	end

	local bodygroups = currentBackpack.Bodygroups
	if istable(bodygroups) then
		BodyGroups:ApplyInternal(clientEnt, bodygroups)
	end
end)

-- Add the species head model to the bone merge system.
InventoryBoneMerge:RegisterCharacterModel("Sidebag", function(char)
	local currentSidebag = Inventory:GetCurrentSidebag(char)
	if not currentSidebag then return end

	return currentSidebag.Model
end, function(char, clientEnt)
	local currentSidebag = Inventory:GetCurrentSidebag(char)
	if not currentSidebag then return end

	local model = currentSidebag.Model
	local materialSetId = currentSidebag.SkinId
	if isstring(model) and materialSetId ~= nil then
		BaseModel:ApplyBaseModel(clientEnt, model, materialSetId)
	end

	local bodygroups = currentSidebag.Bodygroups
	if istable(bodygroups) then
		BodyGroups:ApplyInternal(clientEnt, bodygroups)
	end
end)
--gamemodes/starwarsrp/gamemode/modules/backpack/item_classes/sidebag/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Sidebag Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Seitentasche"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "backpackSlots", "requiredArmor"}



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override Camera Position for the model icon.
hook.Add("EGMModelIcon.OverrideDisplay", "Backpack.OverrideSidebag", function(displayType, modelPanel, ent)
	if displayType ~= "Sidebag" then return end

	local bodyBone = ent:LookupBone("ValveBiped.Bip01_Spine2")
	if bodyBone then
		local bodyPos = ent:GetBonePosition(bodyBone)

		modelPanel:SetLookAt(bodyPos + Vector(5,   0, -12))
		modelPanel:SetCamPos(bodyPos + Vector(5, 300, -12))

		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/backpack/item_slots/back/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Back Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/starwarsrp/gamemode/modules/jetpack/sh_sounds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Jetpack         --
---------------------------------------

sound.Add( {
	name = "jetpack.on",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = 75,
	sound = "egm/core/jetpack/jetpack_on.wav"
})

sound.Add( {
	name = "jetpack.off",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = 75,
	sound = "egm/core/jetpack/jetpack_off.wav"
})

sound.Add( {
	name = "jetpack.loop",
	channel = CHAN_AUTO,
	volume = 0.6,
	level = 75,
	sound = "egm/core/jetpack/jetpack_loop.wav"
})
--gamemodes/starwarsrp/gamemode/modules/jetpack/item_classes/jetboot/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Jetpack Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Jet Boots"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "backpackSlots", "jpUp", "jpFor", "jpSide", "jpFuel", "jpEFuel", "secFuel", "jpRegen", "requiredArmor"}
--gamemodes/starwarsrp/gamemode/modules/medicsystem/sh_medicsystem.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | SH        	 --
---------------------------------------

local Player = FindMetaTable("Player")
function Player:IsDead()
	return self:GetNWBool("Medicsystem.IsDead", false)
end

local Entity = FindMetaTable("Entity")
function Entity:IsDead()
	return self:GetNWBool("Medicsystem.IsDead", false)
end

-- Displays the alive state
--
-- @param? Bool pulse
function Medicsystem:HasPulse(ply)
	if ply:IsDead() then
		return "Verstorben"
	else
		return "Lebend"
	end
end

-- Checks whether an entity is valid
--
-- @param? Entity ent
function Medicsystem:IsValidEntity(ent)
	if ent:IsPlayer() then
		return ent
	end

	if ent:IsRagdoll() and IsValid(ent:GetOwner()) then
		return ent:GetOwner():IsPlayer() and ent:GetOwner()
	end

	if ent:IsRagdoll() then
		return ent
	end

	if ent:GetClass() == "prop_vehicle_prisoner_pod" and IsValid(ent:GetDriver()) then
		return ent:GetDriver()
	end

	return false
end

-- Since ragdolls can also be the target, a check must be made that returns either the player name or a placeholder.
--
-- @param? Entity ent
function Medicsystem:GetCurrentCharacterFullName(ent)
	if ent:IsPlayer() then
		return ent:GetCurrentCharacterFullName()
	else
		return "Puppe"
	end
end

if SERVER then
	local PLAYER = FindMetaTable("Player")

	function PLAYER:HasInjury(injury)
		if not self.Injuries then return false end

		for hitgroup, _ in pairs(self.Injuries) do
			if self.Injuries[hitgroup][injury] then
				return true
			end
		end

		return false
	end
end

-- Checks if the player has a scanner
--
-- @param? Player ply
hook.Add("Medicsystem.HasScanner", "Medicsystem.Scanner", function(ply)
	for _, wep in pairs(ply:GetWeapons()) do
		if wep.IsMedicScanner then
			return true
		end
	end
end)

-- Register a new treatment
--
-- @param? String key
-- @param? Table treatmentData
function Medicsystem:RegisterTreatment(key, treatmentData)
	if Medicsystem.Treatments[key] then
		MsgC(Color(255, 0, 0), "[Medicsystem] Treatment " .. key .. " already loaded!" .. "\n")
		return
	end

	Medicsystem.Treatments[key] = treatmentData

	if SERVER and treatmentData.Hooks then
		for hookName, hookFunction in pairs(treatmentData.Hooks) do
			hook.Add(hookName, "Medicsystem." .. key, hookFunction)
		end
	end

	MsgC(Color(0, 255, 0), "[Medicsystem] Loaded treatment " .. key .. " ..." .. "\n")
end

-- Register a new injury
--
-- @param? String key
-- @param? Table injuryData
function Medicsystem:RegisterInjury(key, injuryData)
	if Medicsystem.Injuries[key] then
		MsgC(Color(255, 0, 0), "[Medicsystem] Injury " .. key .. " already loaded!" .. "\n")
		return
	end

	Medicsystem.Injuries[key] = injuryData
	Medicsystem.InjuryNames[injuryData.Name] = key

	if SERVER and injuryData.Detection then
		for hookName, hookFunction in pairs(injuryData.Detection) do
			hook.Add(hookName, "Medicsystem." .. key, hookFunction)
		end
	end

	if CLIENT and injuryData.Effect then
		hook.Add(injuryData.Effect.hookName, "Medicsystem." .. key, function()
			if Medicsystem.Effects and Medicsystem.Effects[key] == true then
				if not LocalPlayer():Alive() then return end

				DrawMaterialOverlay(injuryData.Effect.material, injuryData.Effect.refract)
			end
		end)
	end

	MsgC(Color(0, 255, 0), "[Medicsystem] Loaded injury " .. key .. " ..." .. "\n")
end

-- Translate the injury name to the injury data table
--
-- @param? String injuryName
function Medicsystem:TranslateInjury(injuryName)
	if Medicsystem.Injuries[injuryName] then
		return Medicsystem.Injuries[injuryName].Name
	elseif Medicsystem.InjuryNames[injuryName] then
		return Medicsystem.InjuryNames[injuryName]
	end

	return false
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem/weapons/weapon_swrp_medic_scanner/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Scanner       --
---------------------------------------

SWEP.Author = "Deltaa"
SWEP.Contact = "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Purpose = "Scanner für das Diagnostizieren von Verletzungen"
SWEP.Instructions = "Linksklick zum Benutzen"

SWEP.Category = "SW:RP (Medicsystem)"

SWEP.PrintName = "Medizinischer Scanner"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 2
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.Primary.Automatic = false
SWEP.AllowIronSightsDoF = false
SWEP.Scoped = false

SWEP.DefaultFireMode = "Normal"

SWEP.IsMedicScanner = true

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.NextUse = 0

SWEP.VElements = {
	["element_scope"] = {
		type = "Model",
		model = "models/weapons/w_datapad.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1, 4, 1),
		angle = Angle(-160, -160, -45),
		size = Vector(1.2, 1.2, 1.2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

function SWEP:PrimaryAttack()
	if self.NextUse > CurTime() then return end
	self.NextUse = CurTime() + 1

	local trace = self:GetOwner():GetEyeTrace()
	local entity = trace.Entity

	-- Check whether the entity is valid
	if not IsValid(entity) then return end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > Medicsystem.MaxDistance then return end

	if Medicsystem:IsValidEntity(entity) then
		entity = Medicsystem:IsValidEntity(entity)

		if CLIENT then
			Medicsystem:OpenMenu(entity, "Medizinischer Scanner")
		end
	end
end

function SWEP:SecondaryAttack()
	if self.NextUse > CurTime() then return end
	self.NextUse = CurTime() + 1

	if CLIENT then
		Medicsystem:OpenMenu(LocalPlayer(), "Medizinischer Scanner")
	end
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end

function SWEP:IronSights()
end

function SWEP:DrawHUD()
	local ply = LocalPlayer()
	if IsValid(ply) and ply:Alive() then
		local ent = ply:GetEyeTrace().Entity

		if IsValid(ent) and ent:IsPlayer() and ent:Alive() and ply:GetPos():DistToSqr(ent:GetPos()) <= 5000 then
			draw.RoundedBox(0, ScrW() / 2 - 80, ScrH() / 2 + 5, 160, 60, UI.BackgroundColor)
			draw.SimpleText("Leben", "EGMText8", ScrW() / 2, ScrH() / 2 + 13, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(ent:Health() .. " / " .. ent:GetMaxHealth(), "EGMText8", ScrW() / 2, ScrH() / 2 + 30, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end
	end
end

function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/entities/medicsystem_refill_pack/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Medicsystem | Refill Pack     --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Medizinisches Auffüllpack"
ENT.Category = "CW:RP Medizin"
ENT.Author = "Deltaa"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.ChargeableSweps = {
	["weapon_swrp_medic_faidkit"] = true,
	["weapon_swrp_medic_injector"] = true,
	["weapon_swrp_medic_kit"] = true,
	["weapon_swrp_medic_opkit"] = true,
	["weapon_swrp_medic_jedi"] = true,
	["weapon_swrp_medic_injector_swt"] = true
}
--gamemodes/starwarsrp/gamemode/modules/gravitylock/entities/swrp_gravitylock_small/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Locks           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Gravity Locks | CL         --
---------------------------------------

include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/permaprops/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permaprop sh index         --
---------------------------------------

PermaProps = PermaProps or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_permaprops.lua")

    AddCSLuaFile("sh_stool_permaprop.lua")
    AddCSLuaFile("sh_stool_removeprops.lua")

    AddCSLuaFile("cl_permaprops.lua")
    AddCSLuaFile("cl_interact.lua")

    include("sh_config.lua")
    include("sh_permaprops.lua")

    include("sh_stool_permaprop.lua")
    include("sh_stool_removeprops.lua")

    include("sv_permaprops.lua")
    include("sv_permaprops_whitelist.lua")
    include("sv_permaprops_integration.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_permaprops.lua")

    include("sh_stool_permaprop.lua")
    include("sh_stool_removeprops.lua")

    include("cl_permaprops.lua")
    include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/modules/socket/cl_socket.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Socket | Client          --
---------------------------------------

-- Initializes Group Servers table.
Socket.GroupServers = Socket.GroupServers or {}

net.Receive("Socket.AddGroupServer", function()
    local id = net.ReadInt(32)

    Socket.GroupServers[id] = net.ReadTable()
end)

net.Receive("Socket.RemoveGroupServer", function()
    local id = net.ReadInt(32)

    Socket.GroupServers[id] = nil
end)


hook.Add("EGMRP.Loaded", "Socket.LoadSetting", function()
    Settings:Register(egmt("chat.gooc"), egmt("socket.chats"), function() end, "true")
end)
--gamemodes/egmrp/gamemode/modules/multiserver/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Multiserver | Config       --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Message that is given when the group has reached it's maximum Capacity.
MultiServer.ServerFullMsg = [[
---------------------------------------------------------------

]] .. egmt("multiserver.kick_full") .. [[

---------------------------------------------------------------]]

-- If the server allows normal connects.
-- If set to false only connects from another server in the group are allowed
MultiServer.AllowConnect = true

-- Message that is returned when connecting onto a server wich does not allow direct connect.
MultiServer.DenyConnectMessage = [[
---------------------------------------------------------------

]] .. egmt("multiserver.kick_eventserver") .. [[

---------------------------------------------------------------]]

-- Minimum Range at wich you are allowed so send somebody to another server.
MultiServer.MinimumChangeServerRank = "operator"

-- Table of teammember ranks which should be able to join. (False to disable)
MultiServer.DirectJoinGroups = {
    "testmoderator",
    "moderator",
    "seniormoderator",
    "admin",
    "superadmin",
    "communitymanager",
    "owner"
}

-- Disable the Atlas Chat Join/Disconnect Message. Only needed when Atlas Chat is installed.
MultiServer.DisableAtlasChatMessages = false
--gamemodes/egmrp/gamemode/modules/multiserver/cl_multiserver_count.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   MultiServer Counting | Client   --
---------------------------------------

-- Receive global player count from server.
net.Receive("MultiServer.PlayerCount", function()
    MultiServer.PlayerCount = net.ReadInt(8)
end)

-- Override player count display in scoreboard.
hook.Add("Scoreboard.GetPlayerCount", "MultiServer.ScoreboardPlayerCount", function()
    if MultiServer.PlayerCount then
        return MultiServer.PlayerCount
    end
end)

--gamemodes/egmrp/gamemode/modules/experience/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Experience System index       --
---------------------------------------

Experience = Experience or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_experience.lua")
    AddCSLuaFile("cl_experience.lua")
    AddCSLuaFile("sh_perks.lua")
    AddCSLuaFile("cl_perks.lua")
    AddCSLuaFile("cl_keybinds.lua")

    include("sh_config.lua")
    include("sh_experience.lua")
    include("sv_experience.lua")
    include("sh_perks.lua")
    include("sv_perks.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_experience.lua")
    include("cl_experience.lua")
    include("sh_perks.lua")
    include("cl_perks.lua")
    include("cl_keybinds.lua")
end
--gamemodes/egmrp/gamemode/modules/experience/sh_experience.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Experience        --
---------------------------------------

-- Add a character property for the experience.
Character:AddProperty("experience", "number", 0, function(character, value)
    if not isnumber(value) then
        return false, egmt("shared.invalid_type")
    end

    if value < 0 then
        return false, egmt("experience.xp_below_zero")
    end

    return true
end,
function(character, ply)
    -- Only network the experience to the owner of the character.
    return character:BelongsTo(ply)
end)

-- Add a character property for the level.
Character:AddProperty("level", "number", 0, function(character, value)
    if not isnumber(value) then
        return false, egmt("shared.invalid_type")
    end

    if value < 0 then
        return false, egmt("experience.level_below_zero")
    end

    if value > Experience.MaxLevel then
        return false, egmt("experience.level_above_max")
    end

    return true
end,
function(character, ply)
    return true
end)

-- Calculates the experience needed for the given level.
--
-- @return Number level
-- @return Number exp
function Experience:GetNeededExp(level)
    if level == self.MaxLevel then
        return 0
    end

    return math.floor(self.ExpPerLevel * math.pow(self.LevelExpMultiplier, level - 1))
end

-- Checks whether the player has the maximum level.
--
-- @return Boolean isMaxLevel
function Character.Meta:IsMaxLevel()
    return self:GetProperty("level", 0) >= Experience.MaxLevel
end

-- Alias function for getting the experience of a character.
function Character.Meta:GetExperience()
    return self:GetProperty("experience", 0)
end

-- Alias function for getting the level of a character.
function Character.Meta:GetLevel()
    return self:GetProperty("level", 0)
end

-- Alias functions on the player for getting the exp / level of his current character.
local Player = FindMetaTable("Player")

function Player:GetExperience()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetExperience()
    end

    return 0
end

function Player:GetLevel()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetLevel()
    end

    return 0
end
--gamemodes/egmrp/gamemode/modules/inventory_container/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Index | Inventory Container    --
---------------------------------------

if not RequireModules({"inventory"}) then
	return false
end

InventoryContainer = InventoryContainer or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_inventory_container.lua")
	AddCSLuaFile("cl_net.lua")

	include("sh_config.lua")
	include("sv_inventory_container.lua")
	include("sv_corpse.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("cl_inventory_container.lua")
	include("cl_net.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_container/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Config | Inventory Container   --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Time to hold E, until an inventory is opened intead of the item picked up.
InventoryContainer.SelectTime = 0.5
--gamemodes/egmrp/gamemode/modules/inventory_container/cl_inventory_container.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Inventory Container   --
---------------------------------------

function InventoryContainer:CloseContainer()
	if IsValid(self.ContainerFrame) then
		self.ContainerFrame:Remove()
	end
end

-- Open a the container inventory.
--
-- @param Table inventory
-- @param Entity itemEntity
-- @param Boolean isChar
function InventoryContainer:OpenContainer(inventory, itemEntity, isChar)
	-- print("\nInventoryContainer:OpenContainer", inventory, itemEntity, isChar)

	local _self = self

	if IsValid(self.ContainerFrame) then
		self.ContainerFrame:Remove()
	end

	-- Open the local player's inventory to the left.
	Inventory:Open(nil, ScrW() * -0.2, "container")

	self.ItemEntity = itemEntity

	-- Open the container to the right.
	self.ContainerFrame = vgui.Create("EGMSmallFrame")
	local oldX, oldY = self.ContainerFrame:GetPos()
	self.ContainerFrame:SetPos(oldX + ScrW() * 0.2, oldY)

	-- Close both windows together.
	function self.ContainerFrame:OnRemove()
		if self ~= _self.ContainerFrame then return end
		Inventory:Close()
	end
	function Inventory.Frame:OnRemove()
		if self ~= Inventory.Frame then return end
		_self:CloseContainer()
	end

	local content = vgui.Create("DPanel", self.ContainerFrame)
	content:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	content:Dock(FILL)
	function content:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end

	self.ContainerContent = content

	local name = egmt("inventory.container")

	-- If the inventory is a numbered list, the first item is the main item.
	if IsValid(itemEntity) and itemEntity:IsRagdoll() then
		name = egmt("inventory.corpse")
	elseif IsValid(itemEntity) and itemEntity:IsPlayer() then
		name = itemEntity:GetCurrentCharacterFullName()
	else
		local itemData = inventory[1]
		if istable(itemData) then
			local success, _, itemType = Inventory:GetItemClass(itemData)
			if success then
				name = itemType:GetName()
			end
		end
	end

	self.ContainerFrame:SetCustomTitle(name)

	if isChar then
		self:OpenCharacterContainer(inventory)
	else
		self:OpenGenericContainer(inventory)
	end

	hook.Run("InventoryContainer.OpenContainer", self)

	self.ContainerFrame:MakePopup()
end

-- Open a generic container.
--
-- @param Table inventory
function InventoryContainer:OpenGenericContainer(inventory)
	local content = self.ContainerContent
	if istable(content.InventorySlots) then
		for _, panels in pairs(content.InventorySlots) do
			for _, panel in pairs(panels) do
				if IsValid(panel) then
					panel:Remove()
				end
			end
		end
	end

	-- First scale the window down vertically.
	local x, y = self.ContainerFrame:GetPos()
	self.ContainerFrame:SetPos(x, y + ScrH() * 0.2)
	self.ContainerFrame:SetTall(ScrH() * 0.3)

	local w = Inventory.Content:GetWide()
	local gridScale = math.floor(w / 12)

	content.InventorySlots = {}

	local slotData = { Type = "container", X = 0, Y = 0.25, Align = ITEM_SLOT_LEFT_TOP }
	local slotTypeClass = Inventory:GetItemSlotClass("container")
	if not slotTypeClass then
		return
	end

	local backPackPanels = slotTypeClass:CreateUI(content, "container", slotData, gridScale, {["container"] = inventory}, nil, "container")
	content.InventorySlots["container"] = backPackPanels
end

-- Open a character container.
--
-- @param Table inventory
function InventoryContainer:OpenCharacterContainer(inventory)
	local content = self.ContainerContent
	if istable(content.InventorySlots) then
		for _, panels in pairs(content.InventorySlots) do
			for _, panel in pairs(panels) do
				if IsValid(panel) then
					panel:Remove()
				end
			end
		end
	end

	local w = Inventory.Content:GetWide()
	local gridScale = math.floor(w / 12)

	content.InventorySlots = {}

	for slotId, slotData in pairs(Inventory.PlayerInventorySlots) do
		local slotType = slotData.Type
		if not isstring(slotType) then
			continue
		end
		local slotTypeClass = Inventory:GetItemSlotClass(slotType)
		if not slotTypeClass then
			continue
		end

		local panels = slotTypeClass:CreateUI(content, slotId, slotData, gridScale, inventory, nil, "other_player")
		content.InventorySlots[slotId] = panels
	end
end

-- Get the progress of opening a container.
--
-- @return Bool isOpening
function InventoryContainer:GetOpenContainerProgress()
	local ply = LocalPlayer()
	if not ply:KeyDown(IN_USE) and not ply:KeyDown(IN_ATTACK) then
		return false
	end

	local trace = ply:GetEyeTrace()
	local ent = trace.Entity
	if not IsValid(ent) then
		return false
	end

	-- Open the container if the entity is an item entity.
	if ent:GetNWBool("IsItemEntity", false) then
		return true
	end

	-- Open the container if the entity is a player.
	if ent:IsPlayer() then
		local targetChar = ent:GetCurrentCharacter()
		if not targetChar then
			return
		end

		local canAccessInventory = Inventory.DefaultAccessPlayer
		local override = hook.Run("InventoryContainer.CanAccessInventory", ply, targetChar)
		if override ~= nil then
			canAccessInventory = override
		end

		return canAccessInventory
	end

	-- Open the container if the entity is a ragdoll.
	if ent:IsRagdoll() and ent:GetNWBool("IsPlayerCorpse", false) then
		local canAccessInventory = Inventory.DefaultAccessCorpse
		local override = hook.Run("InventoryContainer.CanAccessCorpse", ply, ent)
		if override ~= nil then
			canAccessInventory = override
		end

		return canAccessInventory
	end

	return false
end



---------------------------------------
--               Hooks               --
---------------------------------------

local holdTime = 0
hook.Add("HUDPaint", "InventoryContainer.OpenContainer", function()
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid(wep) or wep:GetClass() ~= "egmrp_unarmed" then return end

	if InventoryContainer:GetOpenContainerProgress() then
		holdTime = holdTime + FrameTime()
		local targetTime = InventoryContainer.SelectTime * 2

		local progress = math.Clamp(holdTime / targetTime, 0, 1)

		-- Draw Circle progress bar
		local x, y = ScrW() / 2, ScrH() / 2
		local radius = 100

		surface.SetDrawColor(0, 0, 0, 200)
		surface.DrawCircle(x, y, radius * (1 - progress), 255, 255, 255, 255)

		return
	end

	holdTime = 0
end)

-- Highlight the container slots.
hook.Add("Inventory.GetSlotColor", "InventoryContainer.OverrideColor", function(itemData, slotData, subId)
	if slotData.Type ~= "container" then
		return
	end

	-- Skip the first slot, as it is the main item.
	if subId == 1 then
		return
	end

	return GetColor("green")
end)
--gamemodes/egmrp/gamemode/modules/inventory_container/cl_net.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client Networking | Inventory   --
---------------------------------------

net.Receive("Inventory.OpenContainer", function()
	local itemEntity = net.ReadEntity()
	local containerInventory = net.ReadTable()
	local isContainer = net.ReadBool()
	local update = net.ReadBool()

	if update and not IsValid(InventoryContainer.ContainerFrame) then return end

	InventoryContainer:OpenContainer(containerInventory, itemEntity, not isContainer)
end)

net.Receive("Inventory.CloseContainer", function()
	local itemEntity = net.ReadEntity()

	local ent = InventoryContainer.ItemEntity
	if IsValid(ent) and ent ~= itemEntity then return end

	if IsValid(InventoryContainer.ContainerFrame) then
		InventoryContainer.ContainerFrame:Close()
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory_loadout/sh_inventory_loadout.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Inventory Loadout    --
---------------------------------------

-- Add character property: loadout
Character:AddProperty("loadout", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the loadout of a character.
-- @return Table loadout
function Character.Meta:GetLoadout()
	return self:GetProperty("loadout", {})
end

-- Add faction property: loadout
Faction:AddProperty("loadout", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get the loadout of a faction.
-- @return Table loadout
function Faction.Meta:GetLoadout()
	return self:GetProperty("loadout", {})
end

LOADOUT_PERMISSION_SAVE = "loadout_save"
Rank:RegisterPermission(LOADOUT_PERMISSION_SAVE, egmt("inventory_loadout.permission"))
--gamemodes/egmrp/gamemode/modules/inventory_loadout/cl_inventory_loadout.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Inventory Loadout    --
---------------------------------------

-- Create the loadout panel.
--
-- @param Panel parent
-- @param Character char
-- @param Entity ent
function InventoryLoadout:CreateLoadout(parent, char, ent)
	local loadout = InventoryStorage:CreateStoragePanel(parent, egmt("inventory_loadout.type"))
	parent.Loadout = loadout
end

-- Create a loadout panel.
--
-- @param Panel panel
-- @param String loadoudId
-- @param String loadoutName
-- @param Table loadoutItemData
function InventoryLoadout:ApplyLoadoutPanel(panel, loadoudId, loadoutName, loadoutItemData, canSave)
	local loadoutPanel = vgui.Create("DPanel", panel)
	loadoutPanel:SetTall(ScrH() * 0.1)
	loadoutPanel:DockMargin(0, ScrH() * 0.005, 0, ScrH() * 0.005)
	loadoutPanel:Dock(TOP)
	function loadoutPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)

		draw.SimpleText(loadoutName, "EGMText10", ww * 0.02, 0, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	end

	local buttonPanel = vgui.Create("DPanel", loadoutPanel)
	buttonPanel:SetWide(ScrW() * 0.1)
	buttonPanel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	buttonPanel:Dock(RIGHT)
	function buttonPanel:Paint(ww, hh)
	end

	local equipButton = vgui.Create("DButton", buttonPanel)
	equipButton:SetTall(ScrH() * 0.04)
	equipButton:Dock(TOP)
	equipButton:SetText("")
	function equipButton:DoClick()
		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
		modal:Confirm(egmt("inventory_loadout.equip_confirm"), function()
			net.Start("InventoryLoadout.Equip")
				net.WriteString(loadoudId)
			net.SendToServer()
		end)
	end

	function equipButton:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)

		if self:IsHovered() then
			draw.SimpleText(egmt("inventory_loadout.equip"), "EGMText8", ww / 2, hh / 2, UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText(egmt("inventory_loadout.equip"), "EGMText8", ww / 2, hh / 2, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local saveButton = vgui.Create("DButton", buttonPanel)
	saveButton:SetTall(ScrH() * 0.04)
	saveButton:Dock(BOTTOM)
	saveButton:SetText("")
	function saveButton:DoClick()
		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
		modal:Confirm(egmt("inventory_loadout.save_confirm"), function()
			net.Start("InventoryLoadout.Save")
				net.WriteString(loadoudId)
			net.SendToServer()
		end)
	end

	if not canSave then
		saveButton:SetDisabled(true)
	end

	function saveButton:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)

		if self:GetDisabled() then
			draw.SimpleText(egmt("inventory_loadout.save"), "EGMText8", ww / 2, hh / 2, GetColor("lightgray"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		elseif self:IsHovered() then
			draw.SimpleText(egmt("inventory_loadout.save"), "EGMText8", ww / 2, hh / 2, UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText(egmt("inventory_loadout.save"), "EGMText8", ww / 2, hh / 2, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local w = panel:GetParent():GetParent():GetWide()
	local gridScale = math.floor(w / 16)

	local slotType = Inventory:GetItemSlotClass("loadout")
	local inventory = {["loadout"] = loadoutItemData}
	local slots = slotType:CreateUI(loadoutPanel, "loadout", {Y = 0.1, X = 0}, gridScale, inventory, GetColor("lightgray"), "loadout")
	panel.ItemSlots = slots

	-- Set the height of the storage panel.
	local frame = slots.Frame
	loadoutPanel:SetHeight(frame:GetY() + frame:GetTall() + ScrH() * 0.01)

	return loadoutPanel
end

-- Apply the loadout to the loadout panel.
--
-- @param Panel parent
function InventoryLoadout:ApplyLoadout(parent, char)
	local loadout = parent.Loadout
	if not IsValid(loadout) then return end

	-- Remove existing loadout panels.
	if istable(loadout.Loadouts) then
		for _, loadOutPanel in pairs(loadout.Loadouts) do
			if IsValid(loadOutPanel) then
				loadOutPanel:Remove()
			end
		end
	end

	loadout.Loadouts = {}

	local privateLoadoutItemData = char:GetLoadout()
	local privateLoadout = self:ApplyLoadoutPanel(loadout, "loadout_private", egmt("inventory_loadout.private"), privateLoadoutItemData, true)
	table.insert(loadout.Loadouts, privateLoadout)

	local faction = char:GetFaction()
	if faction then
		local factionLoadoutItemData = faction:GetLoadout()

		local canSave = false
		local rank = char:GetRank()
		if rank then
			canSave = rank:HasPermission(LOADOUT_PERMISSION_SAVE)
		end

		local factionLoadout = self:ApplyLoadoutPanel(loadout, "loadout_faction", egmt("inventory_loadout.faction"), factionLoadoutItemData, canSave)
		table.insert(loadout.Loadouts, factionLoadout)
	end

	hook.Run("InventoryLoadout.CreateLoadout", loadout, loadout.Loadouts)

	local height = ScrH() * 0.04
	for _, loadOutPanel in pairs(loadout.Loadouts) do
		height = height + loadOutPanel:GetTall() + ScrH() * 0.01
	end

	loadout:SetHeight(height)

	parent:InvalidateLayout(true)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Create the supply storage tab.
hook.Add("InventoryStorage.CreateSupply", "InventoryLoadout.AddToSupply", function(content, char, ent)
	InventoryLoadout:CreateLoadout(content, char, ent)
end)

-- Apply the supply storage tab.
hook.Add("InventoryStorage.ApplySupply", "InventoryLoadout.ApplySupply", function(content, char, ent)
	InventoryLoadout:ApplyLoadout(content, char)
end)

-- Update the character loadout when the loadout is changed.
hook.Add("Character.PropertyChanged", "InventoryLoadout.Update", function(char, key, value)
	if not IsValid(InventoryStorage.Frame) then return end

	if char:GetOwner() ~= LocalPlayer() then return end
	if not char:IsCurrentCharacter() then return end

	if key == "loadout" then
		local storageTabs = InventoryStorage.StorageTabs
		if not istable(storageTabs) then return end

		local tabButton = storageTabs["supply"]
		if not IsValid(tabButton) then return end

		local content = tabButton.Content
		if not IsValid(content) then return end

		InventoryLoadout:ApplyLoadout(content, char)
	end
end)

-- Update the faction loadout when the loadout is changed.
hook.Add("Faction.PropertyChanged", "InventoryLoadout.Update", function(faction, key, value)
	if not IsValid(InventoryStorage.Frame) then return end

	local char = LocalPlayer():GetCurrentCharacter()

	local currentFaction = char:GetFaction()
	if not currentFaction then return end

	if faction ~= currentFaction then return end

	if key == "loadout" then
		local storageTabs = InventoryStorage.StorageTabs
		if not istable(storageTabs) then return end

		local tabButton = storageTabs["supply"]
		if not IsValid(tabButton) then return end

		local content = tabButton.Content
		if not IsValid(content) then return end

		InventoryLoadout:ApplyLoadout(content, char)
	end
end)
--gamemodes/egmrp/gamemode/modules/spawnpoints/cl_spawnpoints.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Spawnpoints       --
---------------------------------------


-- Sets the spawn of a faction for the active map.
--
-- @param number factionId
-- @param Vector pos
function Spawnpoints:SetFactionSpawn(factionId, pos, tempBooleanValue)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Spawnpoints.SetFactionSpawn")
        net.WriteInt(factionId, 32)
        net.WriteVector(pos)
        net.WriteBool(tempBooleanValue)
    net.SendToServer()
end

-- Requests a faction spawnpoint from the server. Executes the given callback afterwards.
--
-- @param number factionId
-- @param function callback(pos)
function Spawnpoints:GetFactionSpawns(factionId, callback)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    self.FactionCallback = callback

    net.Start("Spawnpoints.GetFactionSpawn")
        net.WriteInt(factionId, 32)
    net.SendToServer()
end
net.Receive("Spawnpoints.GetFactionSpawn", function()
    local pos = net.ReadTable()
    if isfunction(Spawnpoints.FactionCallback) then
        Spawnpoints.FactionCallback(pos)
    end
end)


-- Removes the spawn of the faction for the active map.
--
-- @param number factionId
function Spawnpoints:RemoveFactionSpawn(factionId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Spawnpoints.RemoveFactionSpawn")
        net.WriteInt(factionId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

net.Receive("Spawnpoints.UpdateSelected", function()
    local pos = net.ReadTable()
    Spawnpoints.spawnSelected = pos
end)

-- Sets the spawn of a rank for the active map.
--
-- @param number rankId
-- @param Vector pos
function Spawnpoints:SetRankSpawn(factionId, rankId, pos, tempBooleanValue)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Spawnpoints.SetRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
        net.WriteVector(pos)
        net.WriteBool(tempBooleanValue)
    net.SendToServer()
end

-- Requests a rank spawnpoint from the server. Executes the given callback afterwards.
--
-- @param number rankId
-- @param function callback(pos)
function Spawnpoints:GetRankSpawns(factionId, rankId, callback)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    self.RankCallback = callback

    net.Start("Spawnpoints.GetRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
    net.SendToServer()
end
net.Receive("Spawnpoints.GetRankSpawn", function()
    local pos = net.ReadTable()
    if isfunction(Spawnpoints.RankCallback) then
        Spawnpoints.RankCallback(pos)
    end
end)

-- Removes the spawn of the rank for the active map.
--
-- @param number rankId
function Spawnpoints:RemoveRankSpawn(factionId, rankId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Spawnpoints.RemoveRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

--gamemodes/starwarsrp/gamemode/modules/helmet/sh_helmet.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Helmet          --
---------------------------------------

-- Add item type property: helmetSlot
ItemType:AddProperty("helmetSlot", "boolean", false, function(itemType, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns if the item type allows a helmet slot.
--
-- @return Boolean helmetSlot
function ItemType.Meta:AllowsHelmetSlot()
	return self:GetProperty("helmetSlot", false)
end

-- Add item property: hideHead
ItemType:AddProperty("hideHead", "boolean", false, function(item, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(item, ply)
	return true
end)

-- Returns if the item should hide the head.
--
-- @return Boolean hideHead
function ItemType.Meta:ShouldHideHead()
	return self:GetProperty("hideHead", false)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Unlock the helmet slot, if the slot is active in the armor.
hook.Add("Inventory.UnLockSlots", "Helmet.UnlockHelmetSlot", function(itemClass, inventory, itemType, itemData, additionalSlots)
	if itemType:AllowsHelmetSlot() then
		additionalSlots["head"] = math.max(additionalSlots["head"] or 0, 1)
	end
end)

-- Hide the head, if the item should hide the head.
hook.Add("Species.HideHeadModel", "Helmet.HideHead", function(char, species, model, skinId)
	if char.GetCorpseHead then return end

	local itemData = Inventory:GetCurrentHelmet(char)
	if not istable(itemData) then return end

	local success, _, itemType = Inventory:GetItemClass(itemData)
	if not success then return end

	if itemType:ShouldHideHead() then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/signs/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Signs | Index           --
---------------------------------------

Signs = Signs or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_signs.lua")
    AddCSLuaFile("cl_signs.lua")

    include("sh_config.lua")
    include("sh_signs.lua")
    include("sv_signs.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_signs.lua")
    include("cl_signs.lua")
end
--gamemodes/egmrp/gamemode/modules/signs/cl_signs.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Signs | Client          --
---------------------------------------

Signs.ImageCache = {}
Signs.Fetching = {}
Signs.RenderTargets = {}

local validFormats = {
    "jpg",
    "jpeg",
    "png",
}

file.CreateDir("egmrp/signs")

Signs.SignDataCache = Signs.SignDataCache or {}

hook.Add("EGMRP.Loaded", "Signs.LoadFonts", function()
    -- Initialise the fonts from the config.
    for id, fontData in pairs(Signs.Fonts) do
        for i = fontData.Min, fontData.Max do
            surface.CreateFont(fontData.Name .. i, {
                font = fontData.Font,
                size = i * fontData.SizeMultiplier + fontData.SizeOffset,
                weight = 500,
                antialias = true,
            })
        end
    end
end)

-- Query an image from the internet and create a texture from it.
--
-- @param String url
-- @param function callback
function Signs:QueryImage(url, callback)
    local uuid = util.SHA1(url)

    -- Already cached locallly.
    if IsValid(self.ImageCache[uuid]) then
        callback(self.ImageCache[uuid])

        return true
    end

    -- Check for valid file url.
    local split = string.Split(url, ".")
    if table.Count(split) ~= 4 then
        return false, "Invalid URL Format!"
    end
    local fileExtension = split[4]
    if not table.HasValue(validFormats, fileExtension) then
        return false, "Invalid Image Format!"
    end

    -- Already cached in file locally.
    local fileName = "egmrp/signs/url_" .. uuid .. "." .. fileExtension
    if file.Exists(fileName, "DATA") then
        self.ImageCache[uuid] = Material("data/" .. fileName)
        callback(self.ImageCache[uuid])

        return true
    end

    -- Fetch file externally.
    self.ImageCache[uuid] = Material("icon16/error.png")

    if table.HasValue(self.Fetching, uuid) then
        return true
    end

    http.Fetch(url, function(body)
        table.RemoveByValue(self.Fetching, uuid)

        file.Write(fileName, body)

        self.ImageCache[uuid] = Material("data/" .. fileName)
        callback(self.ImageCache[uuid])
    end, function(error)
        table.RemoveByValue(self.Fetching, uuid)
        print(error)
    end)

    table.insert(self.Fetching, uuid)

    return true
end

-- Return the tools settings as a useable table.
--
-- @return Table signData
function Signs:GetToolData()
    local signData = {}

    local count = cookie.GetNumber("signs_count") or 4
    signData.Count = count

    local size = cookie.GetNumber("signs_size") or 1
    signData.Size = size

    signData.Mirror = false
    if cookie.GetNumber("signs_mirror") == 1 then
        signData.Mirror = true
    end

    signData.Rows = {}
    for i = 1, count do
        local rowData = {}

        local mode = cookie.GetNumber("signs_mode" .. i) or 1
        rowData.Mode = mode
        if mode == 1 then
            rowData.Text = cookie.GetString("signs_text" .. i) or ""

            local fontName = cookie.GetString("signs_font" .. i) or Signs.Fonts[1].Name
            rowData.FontName = fontName

            local selectedFontData
            for _, fontData in pairs(Signs.Fonts) do
                if fontData.Name == fontName then
                    selectedFontData = fontData

                    break
                end
            end

            if selectedFontData == nil then
                selectedFontData = Signs.Fonts[1]
                fontName = selectedFontData.Name
            end

            local fontScale = math.min(selectedFontData.Max, math.max(selectedFontData.Min, cookie.GetNumber("signs_fontSize" .. i) or selectedFontData.Min))
            rowData.FontScale = fontScale

            rowData.Font = fontName .. fontScale

            local color = Color(
                cookie.GetNumber("signs_r" .. i) or 255,
                cookie.GetNumber("signs_g" .. i) or 255,
                cookie.GetNumber("signs_b" .. i) or 255,
                cookie.GetNumber("signs_a" .. i) or 255
            )
            rowData.Color = color
        elseif mode == 2 then
            rowData.Image = cookie.GetString("signs_image" .. i) or ""

            rowData.Scale = cookie.GetNumber("signs_imageScale" .. i) or 1
        elseif mode == 3 then
            rowData.Height = cookie.GetNumber("signs_spacerHeight" .. i) or 0
        end

        signData.Rows[i] = rowData
    end

    return signData
end

-- Return the tools settings as a useable json string.
--
-- @return String jsonToolData
function Signs:GetToolDataJSON()
    local signData = self:GetToolData()

    return util.TableToJSON(signData)
end

-- Set the tools settings from a table.
--
-- @param Table signData
function Signs:SetToolData(signData)
    if not istable(signData) then
        return
    end

    local count = signData.Count
    local size = signData.Size
    if not isnumber(count) or not isnumber(size) then
        return
    end

    local mirror = signData.Mirror
    if not isbool(mirror) then
        return
    end

    local rows = signData.Rows
    if not istable(rows) then
        return
    end

    if mirror then
        cookie.Set("signs_mirror", 1)
    else
        cookie.Set("signs_mirror", 0)
    end
    cookie.Set("signs_count", count)
    cookie.Set("signs_size", size)

    for i = 1, count do
        local rowData = rows[i]
        if not istable(rowData) then
            continue
        end

        local mode = rowData.Mode or 1
        cookie.Set("signs_mode" .. i, mode)

        if mode == 1 then
            local text = rowData.Text or ""
            cookie.Set("signs_text" .. i, text)

            local fontName = rowData.FontName or Signs.Fonts[1].Name
            cookie.Set("signs_font" .. i, fontName)

            local fontScale = rowData.FontScale or 1
            cookie.Set("signs_fontSize" .. i, fontScale)

            local color = rowData.Color or Color(255, 255, 255, 255)
            cookie.Set("signs_r" .. i, color.r)
            cookie.Set("signs_g" .. i, color.g)
            cookie.Set("signs_b" .. i, color.b)
            cookie.Set("signs_a" .. i, color.a)
        elseif mode == 2 then
            local image = rowData.Image or ""
            cookie.Set("signs_image" .. i, image)

            local scale = rowData.Scale or 1
            cookie.Set("signs_imageScale" .. i, scale)
        elseif mode == 3 then
            local height = rowData.Height or 0
            cookie.Set("signs_spacerHeight" .. i, height)
        end
    end
end

-- Set the tools settings from a json string.
--
-- @param String jsonToolData
function Signs:SetToolDataJSON(jsonToolData)
    local signData = util.JSONToTable(jsonToolData)

    Signs:SetToolData(signData)
end

-- Create a render target for the given sign data.
--
-- @param String uuid
-- @param Table signData
-- @param Table images
function Signs:CreateRT(uuid, signData, images)
    local height = 0
    local width = 0

    local count = signData.Count or 4

    for i = 1, count do
        local rowData = signData.Rows[i]

        if rowData.Mode == 1 then
            surface.SetFont(rowData.Font)
            local textWidth, textHeight = surface.GetTextSize(rowData.Text)

            height = height + textHeight
            width = math.max(width, textWidth)
        elseif rowData.Mode == 2 then
            local image = images[i]

            height = height + image:Height() * rowData.Scale
            width = math.max(width, image:Width() * rowData.Scale)
        elseif rowData.Mode == 3 then
            height = height + rowData.Height
        end
    end

    local rtName = "egmrp_signs_" .. uuid

    local rt = GetRenderTarget(rtName, width, height)
    self.RenderTargets[uuid] = CreateMaterial(rtName, "UnlitGeneric", {
        ["$basetexture"] = rt:GetName(),
        ["$translucent"] = 1,
        ["$vertexalpha"] = 1
    })

    render.PushRenderTarget(rt)

    cam.Start2D()
        render.Clear(0, 0, 0, 0, true, true)

        local offset = 0
        for i = 1, count do
            local rowData = signData.Rows[i]

            local mode = rowData.Mode or 1
            if mode == 1 then
                surface.SetFont(rowData.Font)
                local _, textHeight = surface.GetTextSize(rowData.Text)
                local color = rowData.Color or Color(255, 255, 255, 255)

                draw.SimpleText(rowData.Text, rowData.Font, width / 2, offset + textHeight / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

                offset = offset + textHeight
            elseif mode == 2 then
                local image = images[i]

                local ww = image:Width() * rowData.Scale
                local hh = image:Height() * rowData.Scale

                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(image)
                surface.DrawTexturedRect((width - ww) / 2, offset, ww, hh)

                offset = offset + hh
            elseif mode == 3 then
                offset = offset + rowData.Height
            end
        end
    cam.End2D()

    render.PopRenderTarget()
end

-- Request the creation of an rt for the given sign data.
--
-- @param String uuid
-- @param Table signData
function Signs:RequestRT(uuid, signData)
    local count = signData.Count or 4

    local toBeLoaded = 1
    local images = {}

    for i = 1, count do
        local rowData = signData.Rows[i]

        local mode = rowData.Mode or 1
        if mode == 1 then
            continue
        elseif mode == 2 then
            toBeLoaded = toBeLoaded + 1
            self:QueryImage(rowData.Image, function(image)
                images[i] = image

                toBeLoaded = toBeLoaded - 1
                if toBeLoaded == 0 then
                    self:CreateRT(uuid, signData, images)
                end
            end)
        elseif mode == 3 then
            continue
        end
    end

    toBeLoaded = toBeLoaded - 1
    if toBeLoaded == 0 then
        self:CreateRT(uuid, signData, images)
    end
end

-- Render a sign at the given position.
--
-- @param Vector pos
-- @param Angle ang
-- @param Boolean preview
-- @param String uuid
-- @param Table signData
function Signs:RenderSign(pos, ang, preview, uuid, signData)
    if not istable(signData) then
        return
    end

    local ply = LocalPlayer()
    local distance = ply:GetPos():DistToSqr(pos)
    local percentage = distance / 10000000
    if percentage >= 1 then
        return
    end

    local rtMaterial = self.RenderTargets[uuid]
    if not rtMaterial then
        -- Precache Images and create the rt.
        self:RequestRT(uuid, signData)

        return
    end

    render.SetMaterial(rtMaterial)

    local alpha = 255
    if preview then
        alpha = 63
    elseif percentage > 0.9 then
        alpha = 255 - (percentage - 0.9) * 2550
    end

    local scale = 4 / signData.Size
    local wScale = rtMaterial:Width() / scale
    local hScale = rtMaterial:Height() / scale

    local up = ang:Up()
    local right = ang:Right()

    local p1 = pos - up * hScale - right * wScale
    local p2 = pos - up * hScale + right * wScale
    local p3 = pos + up * hScale + right * wScale
    local p4 = pos + up * hScale - right * wScale

    render.DrawQuad(p1, p2, p3, p4, Color(255, 255, 255, alpha))

    if signData.Mirror then
        render.DrawQuad(p2, p1, p4, p3, Color(255, 255, 255, alpha))
    end
end

hook.Add("PostDrawTranslucentRenderables", "Signs.DrawPreview", function()
    local ply = LocalPlayer()
    local wep = ply:GetActiveWeapon()

    if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" or wep:GetMode() ~= "egmrp_signs" then
        return
    end

    local eyeTrace = ply:GetEyeTrace()

    local ent = eyeTrace.Entity
    if IsValid(ent) and ent:GetClass() == "egmrp_signs" then
        return
    end

    local pos = eyeTrace.HitPos
    local ang = eyeTrace.HitNormal:AngleEx(Vector(0, 0, -1))

    local signData = Signs:GetToolData()
    local uuid = Signs:HashSignData(signData)

    Signs:RenderSign(pos, ang, true, uuid, signData)
end)

--[[
hook.Add("HUDPaint", "Debug", function()
    local i = math.floor(CurTime()) % table.Count(Signs.RenderTargets)

    local keys = table.GetKeys(Signs.RenderTargets)
    local uuid = keys[i + 1]

    local material = Signs.RenderTargets[uuid]
    if not material then return end

    surface.SetMaterial(material)

    surface.SetDrawColor(255, 255, 255, 255)
    surface.DrawTexturedRect(0, 512, material:Width(), material:Height())
end)
]]
--gamemodes/starwarsrp/gamemode/modules/garage/entities/egmrp_garage/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Garage Entity      --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")

-- Drawing the model.
function ENT:Draw()
    self:DrawModel()
end
--gamemodes/starwarsrp/gamemode/modules/streamer/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Streamer Module          --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Streamer Module | SH Index    --
---------------------------------------

if not RequireModules({"chat"}) then
	return false
end

Streamer = Streamer || {}
Streamer.Config = Streamer.Config || {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_streamer.lua")
	AddCSLuaFile("cl_streamer.lua")

	include("sh_config.lua")
	include("sh_streamer.lua")
	include("sv_streamer.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_streamer.lua")
	include("cl_streamer.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_weight/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Weight     --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Default weight limit for the player inventory.
InventoryWeight.DefaultWeightLimit = 50

-- Minimum speed when overburdened.
-- Default: 100
InventoryWeight.MinimumSpeed = 100

-- Weight of a dead corpse when carrying it.
InventoryWeight.CorpseWeight = 100
--gamemodes/egmrp/gamemode/modules/inventory_shop/sh_loaders.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Loaders | Inventory Shop     --
---------------------------------------

-- Load the given shop class.
--
-- @param String shopDirectory
-- @param String shopName
-- @return Boolean success
-- @return? String error
function InventoryShop:LoadShopClass(shopDirectory, shopName)
	SHOP_CLASS = {}
	SHOP_CLASS.Class = shopName

	local success = pcall(function()
		if SERVER then
			AddCSLuaFile(shopDirectory .. shopName .. "/shared.lua")
			AddCSLuaFile(shopDirectory .. shopName .. "/cl_init.lua")

			include(shopDirectory .. shopName .. "/shared.lua")
			include(shopDirectory .. shopName .. "/init.lua")
		end

		if CLIENT then
			include(shopDirectory .. shopName .. "/shared.lua")
			include(shopDirectory .. shopName .. "/cl_init.lua")
		end
	end)
	if not success then
		return false, "Cannot load Shop Class \"" .. shopName .. "\""
	end

	self.ShopClasses[shopName] = SHOP_CLASS
	SHOP_CLASS = nil

	return true
end

-- Reload all Shop Classes.
--
-- @param String moduleDirectory
function InventoryShop:LoadShopClasses(moduleDirectory)
	self.ShopClasses = self.ShopClasses or {}

	local shopDirectory = moduleDirectory .. "shop_classes/"
	local _, shopDirectories = file.Find(shopDirectory .. "*", "LUA")

	for _, shopName in pairs(shopDirectories) do
		self.ShopClasses[shopName] = nil

		local success, error = self:LoadShopClass(shopDirectory, shopName)
		if success then
			LogInfo("|-- Loaded Shop Class \"" .. shopName .. "\"")
		else
			LogWarning("|-- " .. error)
		end
	end
end

-- Link all the Shop Classes with their dependencies.
function InventoryShop:LinkShopClasses()
	for _, shopClass in pairs(self.ShopClasses) do
		local baseShopClassName = shopClass.BaseShopClass
		if not isstring(baseShopClassName) then
			continue
		end

		local baseShopClass = self.ShopClasses[baseShopClassName]
		if istable(baseShopClass) then
			shopClass.Base = baseShopClass
			setmetatable(shopClass, {__index = baseShopClass})
		else
			LogWarning("|-- Failed, to find Shop Class Baseclass \"" .. baseShopClassName .. "\" for \"" .. shopClass.Class .. "\"")
		end
	end
end

-- Get the shop Class by the given name.
--
-- @param String shopClassName
-- @return? Table shopClass
function InventoryShop:GetShopClassFromName(shopClassName)
	return self.ShopClasses[shopClassName]
end



---------------------------------------
--             Load Hooks            --
---------------------------------------

-- Load all the shop Classes from the given module.
hook.Add("EGMRP.ModuleLoaded", "InventoryShop.LoadClasses", function(_, folderPath)
	InventoryShop:LoadShopClasses(folderPath)
end)

-- Link all the shop Classes with their dependencies.
hook.Add("EGMRP.Loaded", "InventoryShop.LinkClasses", function()
	InventoryShop:LinkShopClasses()
end)
--gamemodes/egmrp/gamemode/modules/inventory_shop/sh_inventory_shop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Inventory Shop      --
---------------------------------------

-- Check, if a character can buy a given shop entry.
--
-- @param Character char
-- @param ShopEntry shopEntry
-- @param Table shopClass
-- @return Boolean canBuy
-- @return? String error
function InventoryShop:CanBuy(char, shopEntry, shopClass)
	if not shopClass then
		shopClass = shopEntry:GetShopClass()
	end

	if not istable(shopClass) then
		return false, egmt("inventory_shop.invalid_shop_class")
	end

	-- Allow other modules, to prevent the character from buying the item.
	local canBuy, err = hook.Run("InventoryShop.PreventBuy", char, shopEntry, shopClass)
	if canBuy == true then
		return false, err
	end

	-- Check, if the character has access to the shop entry.
	if not char:HasShopEntryAccess(shopEntry) then
		return false, egmt("inventory_shop.no_access")
	end

	-- Call the shop class function.
	local canBuy2, err2 = shopClass:CanBuy(char, shopEntry)
	if canBuy2 == false then
		return false, err2
	end

	return true
end

-- Get all shop entries, that a character can buy.
--
-- @return Table shopEntries
function Character.Meta:GetShopEntries()
	local shopEntries = {}

	for _, shopEntry in ipairs(ShopEntry:GetCache()) do
		local canBuy, _ = InventoryShop:CanBuy(self, shopEntry)
		if canBuy then
			table.insert(shopEntries, shopEntry)
		end
	end

	return shopEntries
end
--gamemodes/starwarsrp/gamemode/modules/garage_shop/shop_classes/vehicle/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Item Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Base Shop class, from which functions and such should be inherited.
SHOP_CLASS.BaseShopClass = "base"

-- Helper function to get the vehicle name and model.
--
-- @param ShopEntry shopEntry
function SHOP_CLASS:GetNameModel(shopEntry)
	local entClass = shopEntry:GetVehicleClass()
	if not isstring(entClass) or entClass == "" then
		return "???", "models/props_junk/watermelon01.mdl"
	end

	local vehicleTable = scripted_ents.GetStored(entClass)
	if istable(vehicleTable) and istable(vehicleTable.t) then
		return vehicleTable.t.PrintName, vehicleTable.t.MDL
	else
		local vehicleList = list.Get("Vehicles")
		if not istable(vehicleList) then
			return "???", "models/props_junk/watermelon01.mdl"
		end

		local vehicleTable2 = vehicleList[entClass]
		if not istable(vehicleTable2) then
			return "???", "models/props_junk/watermelon01.mdl"
		end

		return vehicleTable2.Name, vehicleTable2.Model
	end
end

-- Check, if a character can buy a given shop entry.
--
-- @param Character char
-- @param ShopEntry shopEntry
-- @return Boolean canBuy
-- @return? String error
function SHOP_CLASS:CanBuy(char, shopEntry)
	return true -- TODO: Implement
end

-- Get the name of the shop entry.
--
-- @param ShopEntry shopEntry
-- @return String name
function SHOP_CLASS:GetShopEntryName(shopEntry)
	local name, _ = self:GetNameModel(shopEntry)

	return name
end
--gamemodes/starwarsrp/gamemode/modules/garage_shop/shop_classes/vehicle/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Item Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Display name for the shop used in UI elements.
SHOP_CLASS.Name = "Vehicle Shop"

-- List of properties that should be shown in the manager, if this shop is used.
SHOP_CLASS.PropertyList = {"vehicle"}

-- Create the shop panel for the shop.
--
-- @param Panel parent
-- @param ShopEntry shopEntry
function SHOP_CLASS:CreateShopPanel(parent, shopEntry)
	SHOP_CLASS.Base.CreateShopPanel(self, parent, shopEntry)
	function parent:Paint(ww, hh)
	end

	local _, model = self:GetNameModel(shopEntry)

	local modelIcon = vgui.Create("EGMModelIcon", parent)
	modelIcon:Dock(FILL)
	modelIcon:SetMouseInputEnabled(false)

	modelIcon:SetModel(model)
	modelIcon:SetDisplayType("Weapon")

	modelIcon:SetSize(math.floor(ScrW() * 0.1), math.floor(ScrW() * 0.1))
	modelIcon:GenerateIcon()

	parent.ModelIcon = modelIcon
end
--gamemodes/starwarsrp/gamemode/modules/stnotes/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | STNotes Config      --
---------------------------------------

-- Background for the stnotes.
STNotes.Background = "materials/wallpaper/924920.png"

-- After this time in minutes exceeding the jail time, the character is automatically released.
STNotes.MaxOvertime = 60

-- Maximum elements that can be displayed on a single page. Should not be set higher, because of performance issues.
STNotes.PageSize = 50

-- Minimum team group that receives notifications.
STNotes.MinNotifyGroup = "testmoderator"
--gamemodes/starwarsrp/gamemode/modules/shiputil/sh_shiputil.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          ShipUtil Shared          --
---------------------------------------

-- Override permissions for LVS entities right click menu.
hook.Add( "CanProperty", "!!!!lvsEditPropertiesDisabler", function( ply, property, ent )
	if ent.LVS and not ply:IsAtLeast("eventleiter") and property == "editentity" then return false end
end )
--gamemodes/egmrp/gamemode/modules/inventory_faction/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Index | Inventory Faction     --
---------------------------------------

if not RequireModules({"inventory_private"}) then
	return false
end

InventoryFaction = InventoryFaction or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_inventory_faction.lua")
	AddCSLuaFile("cl_inventory_faction.lua")

	AddCSLuaFile("cl_net.lua")

	include("sh_config.lua")
	include("sh_inventory_faction.lua")
	include("sv_inventory_faction.lua")

	include("sv_net.lua")
	include("sv_eventlog.lua")
else
	include("sh_config.lua")
	include("sh_inventory_faction.lua")
	include("cl_inventory_faction.lua")

	include("cl_net.lua")
end
--gamemodes/egmrp/gamemode/modules/cloneid/sh_cloneid.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | CloneId         --
---------------------------------------

-- Add rank property: cloneIdEnabled
Rank:AddProperty("cloneIdEnabled", "boolean", true, function(rank, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Helper function to get the clone id of a character from the database id.
--
-- @param Number id
-- @return String cloneId
function CloneId:GenerateCloneId(id)
	-- Generate a clone id based on the character database id.
	local cloneIdString = tostring(id)

	-- Add 0 in front of the id until reaching 6 characters.
	while #cloneIdString < 6 do
		cloneIdString = "0" .. cloneIdString
	end

	-- Random code to make the clone id more special.
	return
		cloneIdString[4] ..
		(cloneIdString[2] + 3) % 10 ..
		"-" ..
		cloneIdString[6] ..
		(cloneIdString[1] + 5) % 10 ..
		cloneIdString[5] ..
		cloneIdString[3]
end

-- Returns the CloneId of a character.
--
-- @return String cloneId
function Character.Meta:GetCloneId()
	local rank = self:GetRank()
	if not rank then return "" end

	local cloneIdEnabled = rank:GetProperty("cloneIdEnabled", false)
	if not cloneIdEnabled then return "" end

	local cloneIdOverride = hook.Run("CloneId.OverrideCustomCloneId", self)
	if isstring(cloneIdOverride) and cloneIdOverride ~= "" then
		return cloneIdOverride
	end

	return CloneId:GenerateCloneId(self:GetId())
end

-- Add the clone id to the full name of a character.
hook.Add("Character.GetFullName", "CloneId.GetFullName", function(character, fullNameTable)
	local cloneId = character:GetCloneId()
	if not isstring(cloneId) or cloneId == "" then return end

	fullNameTable[-50] = cloneId
end)

-- Add the clone id to the limited name of a character.
hook.Add("Character.GetLimitedName", "CloneId.GetLimitedName", function(character, limitedNameTable)
	local cloneId = character:GetCloneId()
	if not isstring(cloneId) or cloneId == "" then return end

	limitedNameTable[-50] = cloneId
end)



---------------------------------------
--   Special Character Integration   --
---------------------------------------

if Config.Modules["special_character"] then
	-- Add special character property: customCloneId
	SpecialCharacter:AddProperty("customCloneId", "string", "", function(rank, value)
		if not isstring(value) then
			return false, egmt("shared.invalid_type")
		end

		return true
	end,
	function(rank, ply)
		return true
	end)

	-- Override the custom clone id of a character.
	hook.Add("CloneId.OverrideCustomCloneId", "SpecialCharacter.OverrideCustomCloneId", function(character)
		local specialChar = character:GetSpecialCharacter()
		if not specialChar then return end

		local cloneId = specialChar:GetProperty("customCloneId", "")
		if cloneId == "" then return end

		return cloneId
	end)
end
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/sh_config.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Config | Cloakdisguise      --
---------------------------------------

Cloaking.Types = {
	{
		name = "Tarngerät - SWT",
		class = "swt",
		createWeapon = true,
		--disguiser = true,
		drawHalo = true,
		--[[
		whitelist = {
			["models/linxreen/egm/shadow_trooper.mdl"] = true,
			["models/linxreen/custom_char/swt/coin/coin.mdl"] = true,
			["models/linxreen/custom_char/swt/shevla/shevla.mdl"] = true,
			["models/dominance/custom_char/ris/bandit.mdl"] = true
		}]]
	},

	{
		name = "Jedi Schatten",
		class = "jedi",
		createWeapon = false,
		--disguiser = false,
		drawHalo = false
	},

	{
		name = "Tarngerät - Event",
		class = "event",
		createWeapon = true,
		--disguiser = true,
		drawHalo = true
	}
}
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/sh_cloaking.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           SH | Cloaking           --
---------------------------------------

local Player = FindMetaTable("Player")

function Player:IsCloaked()
	return self:GetNWInt("Cloakdisguise", 0) > 0
end

function Player:GetCloakId()
	return self:GetNWInt("Cloakdisguise", 0)
end

function Cloaking:CreateSWEP(id)
	local configData = Cloaking.Types[id]
	if not configData.createWeapon then return end

	local swep = weapons.Get("weapon_swrp_cloakingdevice")
	swep.PrintName = configData.name
	swep.Category = "SW:RP (Sonstiges)"
	swep.ClassName = "weapon_swrp_cloakingdevice_" .. configData.class
	swep.Spawnable = true
	swep.AdminOnly = false
	swep.Id = id
	swep.Disguiser = configData.disguiser or false

	weapons.Register(swep, swep.ClassName)
end

hook.Add("EGMRP.Loaded", "Cloaking.CreateDevices", function()
	for number, _ in pairs(Cloaking.Types) do
		Cloaking:CreateSWEP(number)
	end
end)

-- Removes Footstep while player is cloaked
hook.Add("PlayerFootstep", "Cloaking.PlayerFootstep", function(ply)
	if ply:IsCloaked() then
		return true
	end
end)

-- Prevent shooting with non attached swt mode in cloak
--
-- @param? Entity weapon
hook.Add("TFA_CanPrimaryAttack", "Cloaking.DontShootCloaked", function(weapon)
	local owner = weapon:GetOwner()
	if not owner:IsCloaked() then return end

	if not weapon:IsAttached("swrp_am_swt") then
		return false
	end
end)


--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/sh_disguise.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           SH | Disguise           --
---------------------------------------

--[[

local Player = FindMetaTable("Player")

function Player:IsDisguised()
	return self:GetNWInt("disguiseId", 0) > 0
end

function Player:GetDisguiseId()
	return self:GetNWInt("disguiseId", 0)
end

function Player:GetDisguiseModel()
	return self:GetNWString("disguiseModel", "")
end

function Player:GetDisguiseName()
	return self:GetNWString("disguiseName", "")
end

function Player:GetDisguiseCustomId()
	return self:GetNWString("disguiseCustomId", "")
end

function Player:GetDisguiseRank()
	return self:GetNWInt("disguiseRank", -1)
end

-- Returns the roleplay name of the character.
--
-- @return String name
function Character.Meta:GetFullName(prefixes)
	local longName = ""

	if not prefixes then
		prefixes = {
			"rank",
			"specialisation",
			"faction",
			"cloneid"
		}
	end

	-- Adds an override hook for the full name.
	local override = hook.Run("Character.GetFullName", self)
	if isstring(override) then return override end

	local rankPrefix = self:GetRankPrefix()

	if rankPrefix ~= "" and table.HasValue(prefixes, "rank") then
		longName = longName .. rankPrefix .. " "
	end

	if Config.Modules["specialisation"] and table.HasValue(prefixes, "specialisation") then
		local specialisations = self:GetSpecialisations()

		if specialisations then
			for _, specialisation in pairs(specialisations) do
				local specialisationPrefix = specialisation:GetProperty("prefix", "")

				if specialisationPrefix ~= "" then
					longName = longName .. specialisationPrefix .. " "
				end
			end
		end
	end

	local factionPrefix = self:GetFactionPrefix()

	if factionPrefix ~= "" and table.HasValue(prefixes, "faction") then
		longName = longName .. factionPrefix .. " "
	end

	if Config.Modules["cloneid"] and table.HasValue(prefixes, "cloneid") then
		local cloneId = self:GetCloneId()

		if cloneId then
			longName = longName .. cloneId .. " "
		end
	end

	longName = longName .. self:GetRPName()

	return longName
end

-- Returns the prefix of the faction of the character.
--
-- @return String factionPrefix
function Character.Meta:GetFactionPrefix()
	local faction = self:GetFaction()
	if not faction then return "" end

	local override = hook.Run("Character.GetFactionPrefix", self)
	if isstring(override) then return override end

	return faction:GetProperty("prefix", "")
end

-- Returns the color of the faction of the character.
--
-- @return Color factionColor
function Character.Meta:GetFactionColor()
	local faction = self:GetFaction()
	if not faction then return Color(255, 255, 255) end

	local override = hook.Run("Character.GetFactionColor", self)
	if IsColor(override) then
		return override
	end

	return faction:GetProperty("color", Color(255, 255, 255, 255))
end

-- Returns the prefix of the rank of the character.
--
-- @return String rankPrefix
function Character.Meta:GetRankPrefix()
	local rank = self:GetRank()
	if not rank then return "" end

	local override = hook.Run("Character.GetRankPrefix", self)
	if isstring(override) then return override end

	return rank:GetProperty("prefix", "")
end

-- Returns the color of the rank of the character.
--
-- @return Color rankColor
function Character.Meta:GetRankColor()
	local rank = self:GetRank()
	if not rank then return Color(255, 255, 255) end

	local override = hook.Run("Character.GetRankColor", self)
	if IsColor(override) then return override end

	return rank:GetProperty("color", Color(255, 255, 255, 255))
end

if Config.Modules["cloneid"] then
	-- Returns the CloneId of a character.
	--
	-- @return String cloneId or Boolean false when there is no cloneId.
	function Character.Meta:GetCloneId()
		local rank = self:GetRank()
		if not rank then return end

		if hook.Run("CloneId.IsEnabled", self) == false then return end

		local cloneIdEnabled = rank:GetProperty("cloneIdEnabled", false)
		if cloneIdEnabled or hook.Run("CloneId.IsEnabled", self) == true then
			local cloneIdOverride = hook.Run("CloneId.OverrideCustomCloneId", self)
			if isstring(cloneIdOverride) and cloneIdOverride ~= "" then
				return cloneIdOverride
			end

			if Config.Modules["extrarank"] then
				local extraRank = self:GetExtraRank()
				if extraRank then
					local customCloneId = extraRank:GetProperty("customCloneId", "")
					if customCloneId ~= "" then
						return customCloneId
					end
				end
			end

			if Config.Modules["specialisation"] then
				local specialisations = self:GetSpecialisations()
				if specialisations then
					for _, spec in pairs(specialisations) do
						local customCloneId = spec:GetProperty("customCloneId", "")
						if customCloneId ~= "" then
							return customCloneId
						end
					end
				end
			end

			local customCloneId = rank:GetProperty("customCloneId", "")
			if customCloneId ~= "" then
				return customCloneId
			end

			local cloneIdString = tostring(self:GetId())

			-- Add 0 in front of the id until reaching 6 characters.
			while #cloneIdString < 6 do
				cloneIdString = "0" .. cloneIdString
			end

			-- Random code to make the clone id more special.
			return
				cloneIdString[4] ..
				(cloneIdString[2] + 3) % 10 ..
				"-" ..
				cloneIdString[6] ..
				(cloneIdString[1] + 5) % 10 ..
				cloneIdString[5] ..
				cloneIdString[3]
		end

		return false
	end
end

hook.Add("Character.GetFactionPrefix", "Disguise.OverrideFractionPrefix", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if not ply:IsDisguised() then return end

	local rank = Rank:GetCached(ply:GetDisguiseRank())
	if not rank then return end

	local faction = rank:GetFaction()
	if not faction then return end

	return faction:GetProperty("prefix", "")
end)

hook.Add("Character.GetFactionColor", "Disguise.OverrideFractionColor", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if not ply:IsDisguised() then return end

	local rank = Rank:GetCached(ply:GetDisguiseRank())
	if not rank then return end

	local faction = rank:GetFaction()
	if not faction then return end

	return faction:GetProperty("color", Color(255, 255, 255, 255))
end)

hook.Add("Character.GetRankPrefix", "Disguise.OverrideRankPrefix", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if not ply:IsDisguised() then return end

	local rank = Rank:GetCached(ply:GetDisguiseRank())
	if not rank then return end

	return rank:GetProperty("prefix", "")
end)

hook.Add("Character.GetRankColor", "Disguise.OverrideRankColor", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if not ply:IsDisguised() then return end

	local rank = Rank:GetCached(ply:GetDisguiseRank())
	if not rank then return end

	return rank:GetProperty("color", Color(255, 255, 255, 255))
end)

hook.Add("Character.OverrideName", "Disguise.OverrideName", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsDisguised() and ply:GetDisguiseName() ~= "" and ply:GetCurrentCharacter() == character then
		return ply:GetDisguiseName()
	end
end)

hook.Add("Character.GetFullName", "Disguise.OverrideFullName", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if not rank then return end

		local faction = rank:GetFaction()
		if not faction then return end

		if Config.Modules["cloneid"] and character:GetCloneId() then
			return character:GetRankPrefix() .. " " .. character:GetFactionPrefix() .. " " .. character:GetCloneId() .. " " .. character:GetName()
		end

		return character:GetRankPrefix() .. " " .. character:GetFactionPrefix() .. " " .. character:GetName()
	end
end)

hook.Add("CloneId.IsEnabled", "Disguise.OverrideCloneIdEnabled", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if not rank then return end

		return rank:GetProperty("cloneIdEnabled", false)
	end
end)

hook.Add("CloneId.OverrideCustomCloneId", "Disguise.OverrideCloneId", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if rank and ply:GetDisguiseCustomId() ~= "" then
			return ply:GetDisguiseCustomId()
		end
	end
end)

hook.Add("Comlink.CanEnterFactionChannel", "Disguise.CanEnterFactionChannel", function(character, faction)
	local ply = character:GetOwner()
	if not IsValid(ply) then return end

	local rank = Rank:GetCached(ply:GetDisguiseRank())
	if not rank then return end

	local disguiseFaction = rank:GetFaction()
	if not disguiseFaction then return end

	if ply:IsDisguised() and faction == disguiseFaction then
		return true
	end
end)

]]
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/weapons/weapon_swrp_cloakingdevice/cl_init.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           CL | Cloaking           --
---------------------------------------

include("shared.lua")

local CamoActivate = Sound("camo/camo_on.wav")
local CamoDeactivate = Sound("camo/camo_off.wav")

function SWEP:PrimaryAttack()
	if not self:CanPrimaryAttack() then return end
	self:SetNextPrimaryFire(CurTime() + 5)

	local isCloaked = self:GetOwner():IsCloaked()
	if isCloaked then
		surface.PlaySound(CamoDeactivate)
	else
		surface.PlaySound(CamoActivate)
	end
end

function SWEP:SecondaryAttack()
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_b3_ubg/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

include("shared.lua")
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_crab/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

if SERVER then
	AddCSLuaFile()
end

ENT.Base   = "npc_swrp_nextbot_base"

ENT.PrintName = "Crab Droid"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "SW:RP (NPCs)"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.IsSWRPNextbot = true

ENT.AnimIdle = 0
ENT.AnimWalk = "walk"
ENT.AnimIdleAim = 0
ENT.AnimWalkAim = "walk"
ENT.AnimReload = 0

ENT.MaxHealth = 600

-- Speed value of the character. Scales running aswell.
ENT.WalkSpeed = 100

if SERVER then
	function ENT:Initialize()
		self.BehaviourState = 0

		self.TargetRelationships = {}
		self.TargetMemory = {}

		self.HomePos = self:GetPos()
		self.TargetPos = self.TargetPos or self.HomePos

		self:SetModel(self.DefaultModel)
		self:Give(self.DefaultWeapon)

		self:SetMaxHealth(self.MaxHealth)
		self:SetHealth(self.MaxHealth)

		self:SetCollisionGroup(COLLISION_GROUP_NPC_SCRIPTED)

		self.loco:SetDesiredSpeed(self.WalkSpeed)
		self.loco:SetAcceleration(1000)
		self:ChangeActivity(self.AnimIdle)

		self:SetKeyValue( "spawnflags", bit.bor( SF_NPC_NO_WEAPON_DROP, SF_NPC_FADE_CORPSE, SF_NPC_LONG_RANGE ) )

		self:SetFOV(self.FOV)
		self:SetMaxVisionRange(3000)

		self.Reloading = CurTime()
	end

	function ENT:OnKilled(dmgInfo)
		hook.Call( "OnNPCKilled", GAMEMODE, self, dmgInfo:GetAttacker(), dmgInfo:GetInflictor() )

		local oldWeapon = self:GetNWEntity("ActiveWeapon")
		if IsValid(oldWeapon) then
			SafeRemoveEntity(oldWeapon)
		end

		self:EmitSound("ambient/levels/labs/electric_explosion1.wav")

		SafeRemoveEntity(self)
	end

	function ENT:ChangeActivity(sequence)
		if self.LastAnimation == sequence then return end

		self:SetSequence(sequence)
		self.LastAnimation = sequence

		self.ResetSequences = true
	end
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_deathwatch.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Deathwatch"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/ee3_carbine.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "weapons/dwrifle_fire.wav"
SWEP.ClipSize = 20
SWEP.Damage = 20


--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_droideka.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Droideka"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.2
SWEP.Sound = "w/droideka_fire.wav"
SWEP.ClipSize = 50
SWEP.Damage = 15
SWEP.NumOfShots = 2

function SWEP:Reload()
	self:SetClip1(self.ClipSize or 40)

	self:EmitSound(self.ReloadSound or "w/heavy.wav")

	self:SetNextPrimaryFire(CurTime() + 3)
	self:SetNextSecondaryFire(CurTime() + 3)
end

--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/stools/nextbotspawner.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

TOOL.Category = "EGM:RP"
TOOL.Name = "NPC Spawner"
TOOL.Command = nil
TOOL.ConfigName = ""
TOOL.AddToMenu = true


FORMATION_LINE              = 0
FORMATION_LINE_CENTERED     = 1
--FORMATION_SQUAD             = 2
--FORMATION_SQUAD_CENTERED    = 3
FORMATION_ARROW             = 3
--FORMATION_ARROW_EXPANDED    = 5

NextBotToolPanel = NextBotToolPanel or false

if CLIENT then
	language.Add("Tool.nextbotspawner.name", "NPC Spawner")
	language.Add("Tool.nextbotspawner.desc", "Creates one or more Nextbot NPC using custom settings")
	language.Add("Tool.nextbotspawner.0", "LeftClick: Spawn NPC!")

	local function CreateCategory(parent, name, titleHeight, height)
		local headerPanel = vgui.Create("DPanel", parent)
		headerPanel:SetHeight(titleHeight)
		headerPanel:Dock(TOP)
		function headerPanel:Paint(ww, hh)
			draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)

			draw.SimpleText(name, "EGMText4", ww / 2, hh / 2, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		local scrollPanel = vgui.Create("DScrollPanel", parent)
		scrollPanel:SetHeight(height)
		scrollPanel:Dock(TOP)
		function scrollPanel:Paint(ww, hh)
			draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
		end

		return headerPanel, scrollPanel
	end

	local function CreateEntry(parent, name, height)
		local panel = vgui.Create("DPanel", parent)
		panel:SetHeight(height)
		panel:DockMargin(8, 0, 8, 8)
		panel:Dock(TOP)
		function panel:Paint(ww, hh)
			draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)

			draw.SimpleText(name, "EGMText8", 8, hh * 0.5, UI.ForegroundColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		return panel
	end

	function TOOL:BuildCPanel()
		local w = ScrW()
		local h = ScrH()

		s = self -- TODO: Scope from tool to this self (Check Default Code)
		NextBotToolPanel = s

		self.HeaderPanel, self.PresetsScrollPanel = CreateCategory(self, "#Tool.nextbotspawner.desc", h * 0.025, h * 0.2)

		self.PresetSelection = vgui.Create("DIconLayout", self.PresetsScrollPanel)
		self.PresetSelection:Dock(FILL)
		function self.PresetSelection:Select(icon)
			self.Selected = icon

			s.SettingsHealth:SetValue(icon.Preset.Health)
			s.SettingsPrecision:SetPrecision(icon.Preset.Precision)
		end
		function self.PresetSelection:Refresh()
			self.Presets = {}
			self:Clear()

			for _, preset in pairs(NextbotSpawner.Presets) do
				local icon = self:Add("SpawnIcon")
				icon.Preset = preset

				icon:SetSize(w * 0.05, w * 0.05)
				local model = preset.Model
				if istable(model) then
					_, model = next(model)
				end
				icon:SetModel(model or "")
				icon:SetTooltip(preset.Name or "")
				function icon:DoClick()
					s.PresetSelection:Select(self)
				end
				function icon:Paint(ww, hh)
					if s.PresetSelection.Selected == self then
						draw.RoundedBox(0, 0, 0, ww, hh, ColorAlpha(UI.ForegroundColor2, 127))
					end
				end
				function icon:PaintOver(ww, hh)
					self:DrawSelections()
				end

				if not self.Selected then
					self:Select(icon)
				end

				table.insert(self.Presets, icon)
			end
		end

		self.SettingsHeaderPanel, self.SettingsScrollPanel = CreateCategory(self, "Settings", h * 0.025, h * 0.15)

		self.SettingsHealthPanel = CreateEntry(self.SettingsScrollPanel, "Health:", h * 0.025)
		self.SettingsHealthPanel:DockMargin(8, 8, 8, 8)

		self.SettingsHealth = vgui.Create("DNumberWang", self.SettingsHealthPanel)
		self.SettingsHealth:SetWidth(w * 0.05)
		self.SettingsHealth:Dock(RIGHT)
		self.SettingsHealth:SetMin(0)
		self.SettingsHealth:SetMax(1000)
		self.SettingsHealth:SetDecimals(0)
		self.SettingsHealth:SetValue(0)

		self.SettingsPrecisionPanel = CreateEntry(self.SettingsScrollPanel, "Precision:", h * 0.025)

		self.SettingsPrecision = vgui.Create("DSlider", self.SettingsPrecisionPanel)
		self.SettingsPrecision:SetWidth(w * 0.05)
		self.SettingsPrecision:Dock(RIGHT)
		function self.SettingsPrecision:GetPrecision()
			return 1 - self:GetSlideX()
		end
		function self.SettingsPrecision:SetPrecision(value)
			self:SetSlideX(1 - value)
		end

		self.SettingsBehaviourPanel = CreateEntry(self.SettingsScrollPanel, "Behaviour:", h * 0.025)

		self.SettingsBehaviour = vgui.Create("DComboBox", self.SettingsBehaviourPanel)
		self.SettingsBehaviour:SetWidth(w * 0.05)
		self.SettingsBehaviour:Dock(RIGHT)
		self.SettingsBehaviour:AddChoice("Passive", BEHAVIOUR_STUPID, true)
		self.SettingsBehaviour:AddChoice("Defensive", BEHAVIOUR_DEFENSIVE)
		self.SettingsBehaviour:AddChoice("Patrol", BEHAVIOUR_PATROL)
		self.SettingsBehaviour:AddChoice("Attack", BEHAVIOUR_ATTACK)
		function self.SettingsBehaviour:GetBehavior()
			local _, data = self:GetSelected()
			return data
		end

		self.SettingsTrainingPanel = CreateEntry(self.SettingsScrollPanel, "Training:", h * 0.025)

		self.SettingsTraining = vgui.Create("DComboBox", self.SettingsTrainingPanel)
		self.SettingsTraining:SetWidth(w * 0.05)
		self.SettingsTraining:Dock(RIGHT)
		self.SettingsTraining:AddChoice("Training Ammo", true)
		self.SettingsTraining:AddChoice("Deadly Ammo", false, true)
		function self.SettingsTraining:GetTraining()
			local _, data = self:GetSelected()
			return data
		end

		self.GroupHeaderPanel, self.GroupScrollPanel = CreateCategory(self, "Group Settings", h * 0.025, h * 0.15)

		self.SettingsFormationPanel = CreateEntry(self.GroupScrollPanel, "Formation:", h * 0.025)
		self.SettingsFormationPanel:DockMargin(8, 8, 8, 8)

		self.SettingsFormation = vgui.Create("DComboBox", self.SettingsFormationPanel)
		self.SettingsFormation:SetWidth(w * 0.05)
		self.SettingsFormation:Dock(RIGHT)
		self.SettingsFormation:AddChoice("Line", FORMATION_LINE, true)
		self.SettingsFormation:AddChoice("Line (Centered)", FORMATION_LINE_CENTERED)
		self.SettingsFormation:AddChoice("Arrow", FORMATION_ARROW)
		function self.SettingsFormation:GetFormation()
			local _, data = self:GetSelected()
			return data
		end

		self.SettingsGroupSizePanel = CreateEntry(self.GroupScrollPanel, "Group Size:", h * 0.025)

		self.SettingsGroupSize = vgui.Create("DNumberWang", self.SettingsGroupSizePanel)
		self.SettingsGroupSize:SetWidth(w * 0.05)
		self.SettingsGroupSize:Dock(RIGHT)
		self.SettingsGroupSize:SetMin(1)
		self.SettingsGroupSize:SetMax(10)
		self.SettingsGroupSize:SetDecimals(0)
		self.SettingsGroupSize:SetValue(1)

		self.SettingsGroupSpacingPanel = CreateEntry(self.GroupScrollPanel, "Group Spacing:", h * 0.025)

		self.SettingsGroupSpacing = vgui.Create("DNumberWang", self.SettingsGroupSpacingPanel)
		self.SettingsGroupSpacing:SetWidth(w * 0.05)
		self.SettingsGroupSpacing:Dock(RIGHT)
		self.SettingsGroupSpacing:SetMin(50)
		self.SettingsGroupSpacing:SetMax(200)
		self.SettingsGroupSpacing:SetDecimals(0)
		self.SettingsGroupSpacing:SetValue(100)

		self.PresetSelection:Refresh(ww, hh)
	end
end

function TOOL:LeftClick(tr)
	local trEnt = tr.Entity

	if IsValid(trEnt) then
		if trEnt:IsPlayer() then
			return false
		end

		if CLIENT and trEnt:GetClass() == "npc_swrp_nextbot_base" then
			net.Start("NextBotSpawner.UpdateTarget")
				net.WriteEntity(trEnt)
				net.WriteString(NextBotToolPanel.SettingsBehaviour:GetBehavior())
				net.WriteVector(self.TargetPos or trEnt:GetPos())
			net.SendToServer()

			return true
		end
	end

	if CLIENT and IsFirstTimePredicted() then
		local data = {}

		if not NextBotToolPanel then return false end

		local selected = NextBotToolPanel.PresetSelection.Selected
		if not selected then return false end

		local preset = selected.Preset
		if not preset then return false end

		local model = preset.Model
		if istable(model) then
			model = table.Random(model)
		end

		data.Model = model
		data.Name = preset.Name
		data.Health = NextBotToolPanel.SettingsHealth:GetValue()
		data.Weapon = preset.Weapon
		data.Precision = NextBotToolPanel.SettingsPrecision:GetPrecision()
		data.Behaviour = NextBotToolPanel.SettingsBehaviour:GetBehavior()
		data.Training = NextBotToolPanel.SettingsTraining:GetTraining()

		data.Formation = NextBotToolPanel.SettingsFormation:GetFormation()
		data.FormationSize = NextBotToolPanel.SettingsGroupSize:GetValue()
		data.FormationSpacing = NextBotToolPanel.SettingsGroupSpacing:GetValue()

		if data.FormationSize > NextBotToolPanel.SettingsGroupSize:GetMax() then
			data.FormationSize = NextBotToolPanel.SettingsGroupSize:GetMax()
		end

		data.TargetPos = self.TargetPos

		if preset.Entity then
			data.Entity = preset.Entity
		end

		if preset.Sounds then
			data.Sounds = preset.Sounds
		end

		if preset.ThrowGrenades then
			data.ThrowGrenades = preset.ThrowGrenades
		end

		if preset.Grenades and istable(preset.Grenades) then
			data.Grenades = preset.Grenades || {}
		end

		if preset.Animations and istable(preset.Animations) then
			data.Animations = preset.Animations || {}
		end

		net.Start("NextBotSpawner.Spawn")
			net.WriteTable(data)
		net.SendToServer()

		return true
	end

	return false
end

function TOOL:RightClick(tr)
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		return false
	end

	if CLIENT and IsFirstTimePredicted() then
		self.TargetPos = tr.HitPos

		return true
	end

	return false
end

local innerRadius = 5
local outerRadius = 10
local height = 30
local color = Color(255, 0, 0)

-- Renders the marker.
hook.Add("HUDPaint", "NextBotSpawner.Render", function()
	local ply = LocalPlayer()
	local tool = ply:GetActiveWeapon()

	if IsValid(tool) and tool:GetClass() == "gmod_tool" and ply:GetTool() and ply:GetTool().Mode == "nextbotspawner" then
		local targetPos = ply:GetTool().TargetPos
		if isvector(targetPos) then
			cam.Start3D()
				render.DrawLine(targetPos, targetPos + Vector(-outerRadius, -outerRadius, height), color)
				render.DrawLine(targetPos, targetPos + Vector(-outerRadius,  outerRadius, height), color)
				render.DrawLine(targetPos, targetPos + Vector( outerRadius, -outerRadius, height), color)
				render.DrawLine(targetPos, targetPos + Vector( outerRadius,  outerRadius, height), color)

				render.DrawWireframeBox(targetPos, Angle(), Vector(-outerRadius, -outerRadius, height), Vector(outerRadius, outerRadius, height + outerRadius * 2), color)
				render.DrawWireframeSphere(targetPos + Vector(0, 0, height + outerRadius), innerRadius, 32, 32, color)
				render.DrawWireframeBox(targetPos, Angle(), Vector(-innerRadius, -innerRadius, height + (outerRadius - innerRadius)), Vector(innerRadius, innerRadius, height + (outerRadius - innerRadius) + innerRadius * 2), color)

				render.DrawLine(targetPos + Vector(0, 0, height * 1.5 + outerRadius * 2), targetPos + Vector(-outerRadius, -outerRadius, height + outerRadius * 2), color)
				render.DrawLine(targetPos + Vector(0, 0, height * 1.5 + outerRadius * 2), targetPos + Vector(-outerRadius,  outerRadius, height + outerRadius * 2), color)
				render.DrawLine(targetPos + Vector(0, 0, height * 1.5 + outerRadius * 2), targetPos + Vector( outerRadius, -outerRadius, height + outerRadius * 2), color)
				render.DrawLine(targetPos + Vector(0, 0, height * 1.5 + outerRadius * 2), targetPos + Vector( outerRadius,  outerRadius, height + outerRadius * 2), color)
			cam.End3D()
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/eventspawns/cl_eventspawns.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Eventspawns       --
---------------------------------------

-- Sets the spawn of a faction for the active map.
--
-- @param number factionId
-- @param Vector pos
function Eventspawns:SetFactionSpawn(factionId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Eventspawns.SetFactionSpawn")
        net.WriteInt(factionId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

-- Removes the spawn of the faction for the active map.
--
-- @param number factionId
-- @param Vector pos
function Eventspawns:RemoveFactionSpawn(factionId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Eventspawns.RemoveFactionSpawn")
        net.WriteInt(factionId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

net.Receive("Eventspawns.UpdateSelected", function()
    local pos = net.ReadTable()
    Spawnpoints.spawnSelected = pos
end)

-- Requests a faction spawnpoint from the server. Executes the given callback afterwards.
--
-- @param number factionId
-- @param function callback(pos)
function Eventspawns:GetFactionSpawns(factionId, callback)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    self.FactionCallback = callback

    net.Start("Eventspawns.GetFactionSpawn")
        net.WriteInt(factionId, 32)
    net.SendToServer()
end
net.Receive("Eventspawns.GetFactionSpawn", function()
    local pos = net.ReadTable()
    if isfunction(Eventspawns.FactionCallback) then
        Eventspawns.FactionCallback(pos)
    end
end)
-- Sets the spawn of a rank for the active map.
--
-- @param number rankId
-- @param Vector pos
function Eventspawns:SetRankSpawn(factionId, rankId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Eventspawns.SetRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

-- Removes the spawn of the rank for the active map.
--
-- @param number rankId
function Eventspawns:RemoveRankSpawn(factionId, rankId, pos)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    net.Start("Eventspawns.RemoveRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
        net.WriteVector(pos)
    net.SendToServer()
end

-- Requests a rank spawnpoint from the server. Executes the given callback afterwards.
--
-- @param number rankId
-- @param function callback(pos)
function Eventspawns:GetRankSpawns(factionId, rankId, callback)
    if not self:CanPlayerEdit(LocalPlayer()) then
        Notify:Danger(egmt("spawnpoints.denied"), egmt("spawnpoints.denied_description"))
        return
    end

    self.RankCallback = callback

    net.Start("Eventspawns.GetRankSpawn")
        net.WriteInt(factionId, 32)
        net.WriteInt(rankId, 32)
    net.SendToServer()
end
net.Receive("Eventspawns.GetRankSpawn", function()
    local pos = net.ReadTable()
    if isfunction(Eventspawns.RankCallback) then
        Eventspawns.RankCallback(pos)
    end
end)
--gamemodes/starwarsrp/gamemode/modules/eventspawns/stools/eventspawns_tool.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Eventspawns STool    --
---------------------------------------

TOOL.Category = "CW:RP"
TOOL.Name = "#Tool.eventspawns_tool.name"
TOOL.Command = nil
TOOL.ConfigName = nil

Spawnpoints.spawnSelected = {}

local factionSelected = nil
local rankSelected = nil
local defaultSelected = false
local colorSelected = nil

if CLIENT then
	language.Add("Tool.eventspawns_tool.name", "Eventspawns")
	language.Add("Tool.eventspawns_tool.desc", "Setzte temporäre Spawnpunkte auf der Map")
	language.Add("Tool.eventspawns_tool.0", "Linksklick: Setzen; Rechtsklick: Entfernen")
end

function TOOL:LeftClick(trace)
	if not IsFirstTimePredicted() and CLIENT then return end

	local pos = trace.HitPos

    Spawnpoints.spawnSelected[0] = pos

    if defaultSelected then
        Eventspawns:SetFactionSpawn(-1, pos)
        return true
    end

    if rankSelected then
        Eventspawns:SetRankSpawn(factionSelected:GetId(), rankSelected:GetId(), pos)
        return true
    end

    if factionSelected then
        Eventspawns:SetFactionSpawn(factionSelected:GetId(), pos)
        return true
    end
end

function TOOL:RightClick(trace)
    if not IsFirstTimePredicted() and CLIENT then return end

    local pos = trace.HitPos

    if defaultSelected then
        Eventspawns:RemoveFactionSpawn(-1, pos)
        return true
    end

    if rankSelected then
        Eventspawns:RemoveRankSpawn(factionSelected:GetId(), rankSelected:GetId(), pos)
		return true
    end

    if factionSelected then
        Eventspawns:RemoveFactionSpawn(factionSelected:GetId(), pos)
		return true
    end
end

function TOOL:BuildCPanel()
	local description = vgui.Create("DLabel", self)
	description:Dock(TOP)
	description:SetText("#Tool.eventspawns.desc")
	description:SetContentAlignment(5)
	description:SetTextColor(GetColor("darkgray"))

	local factionTitle = vgui.Create("DLabel", self)
	factionTitle:Dock(TOP)
	factionTitle:SetText("Fraktionsspawn")
	factionTitle:SetContentAlignment(5)
	factionTitle:SetTextColor(GetColor("darkgray"))

	local factionList
	local rankList
	local selectedName

	local defaultButton = vgui.Create("DButton", self)
	defaultButton:DockMargin(0, 0, 0, 16)
	defaultButton:Dock(TOP)
	defaultButton:SetHeight(ScrH() * 0.04)
	defaultButton:SetText("Select Default Spawn")
	defaultButton:SetContentAlignment(5)
	defaultButton:SetTextColor(GetColor("darkgray"))
	function defaultButton:DoClick()
		factionSelected = nil
		rankSelected = nil
		colorSelected = Color(255, 255, 255)

		defaultSelected = true

		selectedName:SetText("Default Spawn")

		Spawnpoints.spawnSelected = {}

		Eventspawns:GetFactionSpawns(-1, function(pos)
            Spawnpoints.spawnSelected = pos

        end)

		factionList:Refresh()
		rankList:Refresh(factionSelected)
	end

	factionList = vgui.Create("DListView", self)
	factionList:SetHeight(ScrH() * 0.2)
	factionList:Dock(TOP)
	factionList:AddColumn("Fraktion")
	function factionList:Refresh()
		factionList:Clear()

		for k, faction in pairs(Faction:GetCache()) do
			local line = factionList:AddLine(faction:GetName())
			line.faction = faction
		end
	end
	function factionList:OnRowSelected(index, line)
		factionSelected = line.faction
		colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))
		rankSelected = nil

		defaultSelected = false

		selectedName:SetText(factionSelected:GetName())

		Spawnpoints.spawnSelected = {}

		Eventspawns:GetFactionSpawns(factionSelected:GetId(), function(pos)
			Spawnpoints.spawnSelected = pos

		end)

		rankList:Refresh(factionSelected)
	end

	local rankTitle = vgui.Create("DLabel", self)
	rankTitle:Dock(TOP)
	rankTitle:SetText("Rangspawn")
	rankTitle:SetContentAlignment(5)
	rankTitle:SetTextColor(GetColor("darkgray"))

	rankList = vgui.Create("DListView", self)
	rankList:SetHeight(ScrH() * 0.2)
	rankList:Dock(TOP)
	rankList:AddColumn("Rang")
	function rankList:Refresh(faction)
		rankList:Clear()

		if not faction then return end

		for k, rank in pairs(faction:GetRanks()) do
			local line = rankList:AddLine(rank:GetName())
			line.rank = rank
		end
	end
	function rankList:OnRowSelected(index, line)
		rankSelected = line.rank
		colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))

		defaultSelected = false

		selectedName:SetText(factionSelected:GetProperty("prefix", "") .. " " .. rankSelected:GetName())

		Spawnpoints.spawnSelected = {}

		Eventspawns:GetRankSpawns(factionSelected:GetId(), rankSelected:GetId(), function(pos)
            Spawnpoints.spawnSelected = pos

        end)
	end
	function rankList:OnRowRightClick(index, line)
        rankSelected = nil
        Spawnpoints.spawnSelected = {}

        line:SetSelected(false)


        factionIndex, factionLine = factionList:GetSelectedLine()
        factionSelected = factionLine.faction

        colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))

        selectedName:SetText(factionSelected:GetName())

        Eventspawns:GetFactionSpawns(factionSelected:GetId(), function(pos)
            Spawnpoints.spawnSelected = pos

        end)
    end

	local selectedSpawn = vgui.Create("DPanel", self)
	selectedSpawn:SetHeight(ScrH() * 0.1)
	selectedSpawn:Dock(TOP)

	local selectedTitel = vgui.Create("DLabel", selectedSpawn)
	selectedTitel:Dock(TOP)
	selectedTitel:SetText("Ausgewählter Spawn:")
	selectedTitel:SetContentAlignment(5)
	selectedTitel:SetTextColor(GetColor("darkgray"))

	selectedName = vgui.Create("DLabel", selectedSpawn)
	selectedName:Dock(TOP)
	selectedName:SetText("---")
	selectedName:SetContentAlignment(5)
	selectedName:SetTextColor(GetColor("darkgray"))

	factionList:Refresh()
end

local innerRadius = 5
local outerRadius = 10
local height = 30

-- Renders the marker.
hook.Add( "HUDPaint", "Eventspawns.Render", function()
    if LocalPlayer():GetActiveWeapon() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gmod_tool" and LocalPlayer():GetTool() and LocalPlayer():GetTool().Mode == "eventspawns_tool" then
        cam.Start3D()
            if table.Count(Spawnpoints.spawnSelected) > 0 then
                for k,vectorData in pairs(Spawnpoints.spawnSelected) do
                    if isvector(vectorData) then
                        render.DrawLine(vectorData, vectorData + Vector(-outerRadius, -outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector(-outerRadius,  outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector( outerRadius, -outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector( outerRadius,  outerRadius, height), colorSelected)

                        render.DrawWireframeBox(vectorData, Angle(), Vector(-outerRadius, -outerRadius, height), Vector(outerRadius, outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawWireframeSphere(vectorData + Vector(0, 0, height + outerRadius), innerRadius, 32, 32, colorSelected)
                        render.DrawWireframeBox(vectorData, Angle(), Vector(-innerRadius, -innerRadius, height + (outerRadius - innerRadius)), Vector(innerRadius, innerRadius, height + (outerRadius - innerRadius) + innerRadius * 2), colorSelected)

                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector(-outerRadius, -outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector(-outerRadius,  outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector( outerRadius, -outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector( outerRadius,  outerRadius, height + outerRadius * 2), colorSelected)
                    end
                end
            end
        cam.End3D()
    end
end )
--gamemodes/starwarsrp/gamemode/modules/education/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis   --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--         Config | Education        --
---------------------------------------

Education.Background = "backgrounds/mrshlapa_the_first_mingebag.jpg"

-- Cooldown after fail in s
Education.CooldownTime = 360

Education.QuestionCount = 6

Education.Images = {
	"materials/education/begrüßung.png",
	"materials/education/regelwerk.png",
	"materials/education/chatbefehle.png",
	"materials/education/passivrp.png",	
	"materials/education/hotkeys.png",
	"materials/education/raenge.png",
	"materials/education/sicherheitslevel.png",
	"materials/education/faq.png",
}

Education.Newbie = {}
local question

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die Regel Random Deathmatch?"

question.answers = {}
table.insert(question.answers, "Das Töten ohne Rp-lichen Grund ist verboten")
table.insert(question.answers, "Handeln nach eigenem Ermessen ist immer gestattet")
table.insert(question.answers, "Jede Person zu töten ist immer erlaubt")

question.rightAnswer = "Das Töten ohne RP-lichen Grund ist verboten"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die Regel Vehicle Deathmatch?"

question.answers = {}
table.insert(question.answers, "Ich darf mit meinem Panzer alles und jeden umfahren und umschießen")
table.insert(question.answers, "Ich zerstöre alle feindlichen Panzereinheiten und klaue ihnen ihre Panzer")
table.insert(question.answers, "Ich darf keinen mit einem Fahrzeug grundlos töten und muss die Regeln der Fahrzeuge beachten")

question.rightAnswer = "Ich darf keinen mit einem Fahrzeug grundlos töten und muss die Regeln der Fahrzeuge beachten"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die Erotik-RP Regel?"

question.answers = {}
table.insert(question.answers, "Ich darf mit keinem anderem Klon oder anderem Wesen erotisches/sexuelles Roleplay betreiben")
table.insert(question.answers, "Ich darf auf Coruscant eine Frau und Kinder haben")
table.insert(question.answers, "Ich darf in sämtlichen Bars erotisches/sexuelles Roleplay betreiben")

question.rightAnswer = "Ich darf mit keinem anderem Klon oder anderem Wesen erotisches/sexuelles Roleplay betreiben"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was machst du, wenn du ohne Grund angeschossen wirst?"

question.answers = {}
table.insert(question.answers, "Ich versuche ihn als erstes zu töten")
table.insert(question.answers, "Ich rufe Verstärkung, nehme ihn mit einer Formation fest und rufe die Stoßtruppen")
table.insert(question.answers, "Ich lasse mich erschießen")

question.rightAnswer = "Ich rufe Verstärkung, nehme ihn mit einer Formation fest und rufe die Stoßtruppen"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Du wurdest durch einen Droiden getroffen und bist an der Verletzung gestorben. Nun bist du respawnt. Darfst du zurück zu der Stelle wo du getötet wurdest?"

question.answers = {}
table.insert(question.answers, "Natürlich, ich habe doch nichts vergessen")
table.insert(question.answers, "Nur wenn ich den Befehl dazu bekomme oder darauf hingewiesen werde, was passiert ist")
table.insert(question.answers, "Ich betreibe Metagaming und laufe zu der besagten Stelle")

question.rightAnswer = "Nur wenn ich den Befehl dazu bekomme oder darauf hingewiesen werde, was passiert ist"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die FearRP Regel?"

question.answers = {}
table.insert(question.answers, "Das eigene Leben ist wichtiger als der Auftrag")
table.insert(question.answers, "Der Auftrag steht an oberster Stelle und wird um jeden Preis erledigt")
table.insert(question.answers, "Der Commander ist nun im Dienst, man muss nun Angst um sein Leben haben")

question.rightAnswer = "Das eigene Leben ist wichtiger als der Auftrag"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die Fail-RP Regel?"

question.answers = {}
table.insert(question.answers, "Man muss sich stehts wie ein Droide verhalten")
table.insert(question.answers, "Man soll sich immer wie ein Klon oder Jedi verhalten")
table.insert(question.answers, "Das Roleplay muss in jeglicher Hinsicht beachtet werden")

question.rightAnswer = "Das Roleplay muss in jeglicher Hinsicht beachtet werden"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was machst du, wenn du einen Klon siehst, welcher Fail-RP macht? (z.B. Bunny-Hoppen)"

question.answers = {}
table.insert(question.answers, "Ich weise ihn darauf hin, dass er es zu unterlassen hat und bei wiederholten mal rufe ich ein Teammitglied")
table.insert(question.answers, "Ich erschieße ihn, damit er respawnen muss")
table.insert(question.answers, "Ich bringe ihn zur Vernunft, betäube ihn und bringe ihn zu den Stoßtruppen")

question.rightAnswer = "Ich weise ihn darauf hin, dass er es zu unterlassen hat und bei wiederholten mal rufe ich ein Teammitglied"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Darfst du mit einem Flugobjekt oder Panzer fahren beziehungsweise fliegen?"

question.answers = {}
table.insert(question.answers, "Klar, da ich die Ausbildung als CT Private habe")
table.insert(question.answers, "Nein, da ich dafür in der jeweiligen Einheit sein muss")
table.insert(question.answers, "Natürlich, wenn ich die Fortbildung habe")

question.rightAnswer = "Nein, da ich dafür in der jeweiligen Einheit sein muss"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was ist Powergaming?"

question.answers = {}
table.insert(question.answers, "Handlungen, die menschlich unmöglich sind oder wenn man seinem Gegenüber keine Chance auf eine Reaktion im Roleplay ermöglicht bezeichnet man als Powergaming")
table.insert(question.answers, "Das Nutzen von OOC Informationen im IC (In Charakter) ist verboten")
table.insert(question.answers, "Das Roleplay gilt in jeglicher Hinsicht zu beachten! Ausnahme bilden hier InGame-Supportgespräche mit Teammitgliedern")

question.rightAnswer = "Handlungen, die menschlich unmöglich sind oder wenn man seinem Gegenüber keine Chance auf eine Reaktion im RP ermöglicht bezeichnet man als Powergaming"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was besagt die Metagaming Regel?"

question.answers = {}
table.insert(question.answers, "Das Benutzen von OOC Begriffen im IC ist erlaubt")
table.insert(question.answers, "Das Benutzen von OOC Informationen im Roleplay ist verboten")
table.insert(question.answers, "Das Erschießen eines anderen Spieler ohne Grund ist verboten")

question.rightAnswer = "Das Benutzen von OOC Informationen im Roleplay ist verboten"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Ab wann ist es erlaubt das Spielgeschehen aufzunehmen?"

question.answers = {}
table.insert(question.answers, "Das Aufnehmen vom Spielgeschehen ist niemals gestattet")
table.insert(question.answers, "Das Aufnehmen des Spielgeschehen ist nur gestattet, wenn man es im OOC-Chat ankündigt")
table.insert(question.answers, "Jeder User, welcher dem Server joint ist durch die Serverregeln damit einverstanden, dass man aufgenommen wird")

question.rightAnswer = "Jeder User, welcher dem Server joint ist durch die Serverregeln damit einverstanden, dass man aufgenommen wird"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wann betätigt man Offline-Flucht?"

question.answers = {}
table.insert(question.answers, "Man verlässt den Server, um einem Supportgespräch zu entkommen")
table.insert(question.answers, "Man verlässt den Server, obwohl man alleine in einer Ecke steht")
table.insert(question.answers, "Man kann den Server immer verlassen")

question.rightAnswer = "Man verlässt den Server, um einem Supportgespräch zu entkommen"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was ist E-RP?"

question.answers = {}
table.insert(question.answers, "Elektronik-RP")
table.insert(question.answers, "Erotik-RP")
table.insert(question.answers, "Ewok-RP")

question.rightAnswer = "Erotik-RP"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Welcher Rufname ist erlaubt?"

question.answers = {}
table.insert(question.answers, "Slayer")
table.insert(question.answers, "Profigamer2000")
table.insert(question.answers, "Peter Maddonson")

question.rightAnswer = "Slayer"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wann darf ich reden, wenn PTS ausgerufen wurde?"

question.answers = {}
table.insert(question.answers, "Wenn ich Ranghöher bin als der, welcher PTS ausgerufen hat")
table.insert(question.answers, "Wenn ich was wichtiges zu melden habe")
table.insert(question.answers, "Wenn ich “/me erbittet PTS” in den Chat geschrieben habe und mir das PTS erteilt wurde")

question.rightAnswer = "Wenn ich “/me erbittet PTS” in den Chat geschrieben habe und mir das PTS erteilt wurde"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie sicherst man seine Waffe?"

question.answers = {}
table.insert(question.answers, "Scrollen")
table.insert(question.answers, "Shift + E")
table.insert(question.answers, "Alt + E")

question.rightAnswer = "Shift + E"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Darfst du einen Gefangenen einfach erschießen?"

question.answers = {}
table.insert(question.answers, "Nein, da er sich vor einem Gericht verantworten muss")
table.insert(question.answers, "Natürlich, da er Hochverrat begangen hat")
table.insert(question.answers, "Ja, da mein Corporal es mir gesagt hat")

question.rightAnswer = "Nein, da er sich vor einem Gericht verantworten muss"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was machst du, wenn jemand verletzt am Boden liegt?"

question.answers = {}
table.insert(question.answers, "Ich suche nach Puls und Verletzungen und gebe die Information an das RMC weiter")
table.insert(question.answers, "Ich gebe ihm den Gnadenstoß, damit die Schmerzen für ihn aufhören")
table.insert(question.answers, "Ich lasse ihn liegen und ziehe weiter")

question.rightAnswer = "Ich suche nach Puls und Verletzungen und gebe die Information an das RMC weiter"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was ist PassivRP?"

question.answers = {}
table.insert(question.answers, "PassivRP´s sind “/me” Aktionen, um das dazustellen, was das Spiel nicht hergibt")
table.insert(question.answers, "PassivRP ist eine Aktion, bei welcher man entscheiden kann, was man ist oder wie stark man ist")
table.insert(question.answers, "PassivRP ist eine Aktion, bei welcher man mit seinem Gegenüber interagiert und dieser keine Ausweichchance hat")

question.rightAnswer = "PassivRP´s sind “/me” Aktionen, um das dazustellen, was das Spiel nicht hergibt"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wofür ist der /it oder /git Befehl?"

question.answers = {}
table.insert(question.answers, "Mit dem Befehl stellt man eine Situation da, welche das Spiel nicht anzeigen kann")
table.insert(question.answers, "Dies ist der Befehl für Supportanfragen")
table.insert(question.answers, "Ist ein Befehl, welcher nur von Teammitgliedern genutzt werden kann")

question.rightAnswer = "Mit dem Befehl stellt man eine Situation da, welche das Spiel nicht anzeigen kann"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie Funkt man richtig?"

question.answers = {}
table.insert(question.answers, "/funk *ID an Truppen Stellen sie sich bei den Landeplattformen auf")
table.insert(question.answers, "/funk *ID an Truppen* Stellen sie sich bei den Landeplattformen auf")
table.insert(question.answers, "/funk ID an Truppen Stellen sie sich bitte bei den Landeplattformen auf")

question.rightAnswer = "/funk *ID an Truppen* Stellen sie sich bei den Landeplattformen auf"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie funke ich richtig nach einem Medic"

question.answers = {}
table.insert(question.answers, "/funk ID an Truppen *HILFE ICH BRAUCH EINEN MEDIC!!!*")
table.insert(question.answers, "/funk *ID an RMC* 10-5M, 10-20 Standort")
table.insert(question.answers, "/funk *ID an RMC* Bräuchte einen Medizinier hier bei mir")

question.rightAnswer = "/funk *ID an RMC* 10-5M, 10-20 Standort"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was ist der unterschied zwischen 10-3 und 10-4?"

question.answers = {}
table.insert(question.answers, "10-3 heißt nein und 10-4 heißt ja")
table.insert(question.answers, "10-3 heißt Übungsalarm und 10-4 heißt Alarm und alle müssen auf die Kampfpositionen")
table.insert(question.answers, "10-3 heißt wie bitte? und 10-4 heißt “Melde mich vom Dienst ab”")

question.rightAnswer = "10-3 heißt nein und 10-4 heißt ja"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie melde ich mich richtig im Funk?"

question.answers = {}
table.insert(question.answers, "Melde mich zum Dienst")
table.insert(question.answers, "10-1, 10-11,10-20,10-18a")
table.insert(question.answers, "10-1, 10-11")

question.rightAnswer = "10-1, 10-11"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was bedeutet 10-20?"

question.answers = {}
table.insert(question.answers, "Freigabe")
table.insert(question.answers, "Standort")
table.insert(question.answers, "Melde mich vom Dienst ab")

question.rightAnswer = "Standort"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Welche Sicherheitslevel darfst du als Private betreten?"

question.answers = {}
table.insert(question.answers, "Sicherheitslevel 1")
table.insert(question.answers, "Sicherheitslevel 2")
table.insert(question.answers, "Sicherheitslevel 3")
table.insert(question.answers, "Sicherheitslevel 4")

question.rightAnswer = "Sicherheitslevel 1"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie ist die richtige Reihenfolge?"

question.answers = {}
table.insert(question.answers, "Private, Private First Class, Corporal, Sergeant, Lieutenant, Captain, Commander")
table.insert(question.answers, "Private, Private  First Class, Sergeant, Corporal, Lieutenant, Captain, Commander")
table.insert(question.answers, "Private, Private First Class, Corporal, Sergeant, Captain, Lieutenant, Commander")

question.rightAnswer = "Private, Private First Class, Corporal, Sergeant, Lieutenant, Captain, Commander"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Ein Sergeant kommt dir entgegen, was machst du?"

question.answers = {}
table.insert(question.answers, "Ich lache ihn aus")
table.insert(question.answers, "Ich bleibe stehen und salutiere vor ihm")
table.insert(question.answers, "Ich winke ihm zu")

question.rightAnswer = "Ich bleibe stehen und salutiere vor ihm"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Wie kannst du anderen Einheiten beitreten"

question.answers = {}
table.insert(question.answers, "Ich frage die Republic Navy, ob sie mich einer Einheit zuteilen könnte")
table.insert(question.answers, "Ich lasse mich von einem Teammitglied einer Einheit zuteilen")
table.insert(question.answers, "Über Rekrutierungen oder ein Praktikum bei der gewünschten Einheit")

question.rightAnswer = "Über Rekrutierungen oder ein Praktikum bei der gewünschten Einheit"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
question = {}
question.message = "Was muss man bei einem “Gefangen-Diamanten” beachten?"

question.answers = {}
table.insert(question.answers, "Nach außen schauen und die Umgebung im Blick behalten")
table.insert(question.answers, "Die Person schützen und in die Richtung schauen, in welche die Person schaut.")
table.insert(question.answers, "Auf seine Füße zielen und versuchen ihn zu entwaffnen. Außerdem darf man nicht auf seine Befehle hören")

question.rightAnswer = "Auf seine Füße zielen und versuchen ihn zu entwaffnen. Außerdem darf man nicht auf seine Befehle hören"
table.insert(Education.Newbie, question)
----------------------------------------------------------------------------------------------------

--gamemodes/starwarsrp/gamemode/modules/voicenotify/cl_vgui_default.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Voicenotify            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Voicenotify | CL          --
---------------------------------------

surface.CreateFont("AurebeshName", {
	font = "Aurebesh",
	size = 14,
	weight = 1,
	shadow = false
})

local PANEL = {}

function PANEL:Init()
	self.playerName = vgui.Create( "DLabel", self )
	self.playerName:SetFont( "EGMText9" )
	self.playerName:Dock( TOP )
	self.playerName:DockMargin( 8, 0, 0, 2 )
	self.playerName:SetTextColor(color_white)

	self.aurName = vgui.Create( "DLabel", self )
	self.aurName:SetFont( "AurebeshName" )
	self.aurName:Dock( TOP )
	self.aurName:DockMargin( 8, 0, 0, 0 )
	self.aurName:SetTextColor(color_white)

	self.Avatar = vgui.Create("EGMModelPanel", self)
	self.Avatar:Dock( LEFT )
	self.Avatar:SetSize(40, 40)
	self.Avatar:SetZPos(-1)

	self.Color = color_transparent

	self:SetSize( 350, 50 )
	self:DockPadding( 4, 4, 4, 4 )
	self:DockMargin( 2, 2, 2, 2 )
	self:Dock( BOTTOM )
end

function PANEL:Setup( ply )
	self.ply = ply
	self.playerName:SetText( ply:Nick() )
	self.aurName:SetText( ply:Nick() )

	if ply:GetCurrentCharacter() then
		self.Avatar:SetCharacter(ply:GetCurrentCharacter())
	end

	self.playerName:SetFont(Voicenotify:GetFont(ply:Nick(), 210))

	self.Color = team.GetColor( ply:Team() )

	self:InvalidateLayout()
end

function PANEL:Paint( w, h )
	if ( !IsValid( self.ply ) ) then return end

	draw.RoundedBox( 4, 0, 0, w, h, Color( 0, self.ply:VoiceVolume() * 255, 0, 240 ) )

	surface.SetDrawColor(Voicenotify.Colors["nameColor"])
	self:DrawOutlinedRect()
end

function PANEL:Think()
	if IsValid(self.ply) then
		self.playerName:SetText( self.ply:Nick() )
	end

	if ( self.fadeAnim ) then
		self.fadeAnim:Run()
	end
end

function PANEL:FadeOut( anim, delta, data )
	if ( anim.Finished ) then
		if ( IsValid( Voicenotify.PlayerVoicePanels[ self.ply ] ) ) then
			Voicenotify.PlayerVoicePanels[ self.ply ]:Remove()
			Voicenotify.PlayerVoicePanels[ self.ply ] = nil
			return
		end

		return
	end

	self:SetAlpha( 255 - ( 255 * delta ) )
end

derma.DefineControl( "VoiceNotify", "", PANEL, "DPanel" )
--gamemodes/starwarsrp/gamemode/modules/hud/cl_hud.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Client | HUD            --
---------------------------------------

Faction:AddPropertyToList("isCloneFaction", "Klon-Fraktion", "Zeigt die ID und den Rang anderer Fraktionen mit diesem Wert an.", "boolean")

Faction:AddPropertyToList("factionAlias", "Fraktionsalias", "Die Fraktion, die externen Spielern angezeigt wird.", "dropdown", function()
	local factions = {}

	table.insert(factions, {text = "Kein Alias", data = -1})

	for k, faction in pairs(Faction:GetCache()) do
		table.insert(factions, {text = faction:GetName(), data = faction:GetId()})
	end

	return factions
end)

Rank:AddPropertyToList("factionAlias", "Fraktionsalias", "Die Fraktion, die externen Spielern angezeigt wird. Überschreibt Fraktionsalias!", "dropdown", function()
	local factions = {}

	table.insert(factions, {text = "Kein Alias", data = -1})

	for k, faction in pairs(Faction:GetCache()) do
		table.insert(factions, {text = faction:GetName(), data = faction:GetId()})
	end

	return factions
end)




---------------------------------------
--               Hooks               --
---------------------------------------

-- Hide limited name for completely seperate factions.
hook.Add("UI.OverridePlayerInfo", "EGMHUD.OverrideLimitedName", function(currentCharacter, currentFaction, targetCharacter, targetFaction, shouldDrawFullName)
	-- Only override the limited name.
	if shouldDrawFullName then return end

	-- Do not change anything if both factions are clone factions.
	-- This is already handled by the default code.
	if currentFaction:GetProperty("isCloneFaction", false) and targetFaction:GetProperty("isCloneFaction", false) then
		return
	end

	-- Get the faction alias
	local factionId = targetFaction:GetProperty("factionAlias", -1)
	if factionId == -1 then
		factionId = targetFaction:GetId()
	end

	local targetRank = targetCharacter:GetRank()
	if not targetRank then return end

	-- If rank faction alias, override
	local rankId = targetRank:GetProperty("factionAlias", -1)
	if rankId ~= -1 then
		factionId = rankId
	end

	-- Get the faction by the id
	local displayFaction = Faction:GetCached(factionId)
	if not displayFaction then return end

	return {
		Text = displayFaction:GetName(),
		Color = displayFaction:GetColor()
	}
end)
--gamemodes/starwarsrp/gamemode/modules/ammoperk/cl_perk.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Ammo Perk | Client         --
---------------------------------------

-- OVERWRITE: Opens the ammo system menu.
function AmmoSystem:OpenMenu()
	self:CloseMenu()

	self.ammoMultiply = AmmoPerk:GetAmmoMultiply(LocalPlayer())

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.MenuBackground)
	self.Frame:SetSubTitle("Munitionskiste")

	self.AmmoList = vgui.Create("EGMScrollPanel", self.Frame)
	self.AmmoList:SetPos(ScrW() * 0.1, ScrH() * 0.25)
	self.AmmoList:SetSize(ScrW() * 0.39, ScrH() * 0.7)
	self.AmmoList.AmmoTypes = {}

	for ammo, ammoProperties in pairs(AmmoSystem.AmmoTypes) do
		local sortFrame = vgui.Create("DPanel", self.AmmoList)
		sortFrame:Dock(TOP)
		sortFrame:SetHeight(ScrH() * 0.06)

		local ammoCounterLabel = vgui.Create("DLabel", sortFrame)
		ammoCounterLabel:SetHeight(ScrH() * 0.05)
		ammoCounterLabel:Dock(LEFT)
		ammoCounterLabel:SetFont("EGMText12")
		ammoCounterLabel:SetText(ammoProperties.name)
		ammoCounterLabel:SetTextColor(GetColor("white"))
		ammoCounterLabel:SetContentAlignment(4)
		ammoCounterLabel:SizeToContents()
		ammoCounterLabel:DockMargin(5, 0, 0, 0)

		if Realism.EnableAmmoWeight then
			local ammoWeightLabel = vgui.Create("DLabel", sortFrame)
			ammoWeightLabel:SetHeight(ScrH() * 0.05)
			ammoWeightLabel:Dock(RIGHT)
			ammoWeightLabel:SetFont("EGMText12")
			ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. tostring(ammoProperties.weight * tonumber(LocalPlayer():GetAmmoCount(ammo))))
			ammoWeightLabel:SetTextColor(GetColor("white"))
			ammoWeightLabel:SetContentAlignment(6)
			ammoWeightLabel:SizeToContents()
			ammoWeightLabel:DockMargin(0, 0, 5, 0)
		end
		local ammoCounter = vgui.Create("DNumSlider", self.AmmoList)
		ammoCounter:SetHeight(ScrH() * 0.05)
		ammoCounter:DockMargin(ScrW() * -0.2 ,5 ,0 ,5)
		ammoCounter:Dock(TOP)
		ammoCounter:SetMin(0)
		ammoCounter:SetMax(math.Round(ammoProperties.limit * self.ammoMultiply))
		ammoCounter:SetValue(tostring(LocalPlayer():GetAmmoCount(ammo)))
		ammoCounter:SetDecimals(0)

		ammoCounter.Paint = function(panel, width, height)
			draw.RoundedBox(0, 0, 0, width, height, UI.TextColor)
		end
		if Realism.EnableAmmoWeight then
			ammoCounter.OnChange = function()
				if ammoCounter:GetValue() and tonumber(ammoCounter:GetValue()) then
					ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. ammoProperties.weight * tonumber(ammoCounter:GetValue()))
					ammoWeightLabel:SizeToContents()
				else
					ammoWeightLabel:SetText(egmt("ammosystem.weight") .. ": " .. ammoProperties.weight)
					ammoWeightLabel:SizeToContents()
				end
			end
		end
		ammoCounter.AllowInput = function(panel, stringValue)
			if not isnumber(tonumber(stringValue)) or (tonumber(ammoCounter:GetValue()) and tonumber(tostring(ammoCounter:GetValue()) .. tostring(stringValue)) > math.Round(ammoProperties.limit * self.ammoMultiply)) then
				return true
			else
				return false
			end
		end

		local ammoCounterTable = {ammoCounter, ammo}
		table.insert(self.AmmoList.AmmoTypes, ammoCounterTable)
	end

	if Realism.EnableAmmoWeight then
		self.currentWeightPanel = vgui.Create("DPanel", self.Frame)
		self.currentWeightPanel:SetPos(ScrW() * 0.51, ScrH() * 0.25)
		self.currentWeightPanel:SetSize(ScrW() * 0.39, ScrH() * 0.13)

		self.currentWeightText = vgui.Create("DLabel", self.currentWeightPanel)
		self.currentWeightText:Dock(TOP)
		self.currentWeightText:SetFont("EGMText12")
		self.currentWeightText:SetText(egmt("ammosystem.weight_maxweight"))
		self.currentWeightText:SetContentAlignment(5)
		self.currentWeightText:SizeToContents()

		self.currentWeightIndicator = vgui.Create("DLabel", self.currentWeightPanel)
		self.currentWeightIndicator:Dock(TOP)
		self.currentWeightIndicator:SetFont("EGMText12")
		self.currentWeightIndicator:SetText(tostring((LocalPlayer():GetNWInt("Realism.currentWeight", 0) + LocalPlayer():GetNWInt("Realism.ammoWeight", 0)) .. " / " .. LocalPlayer():GetNWInt("Realism.maxWeight", 0)))
		self.currentWeightIndicator:SetContentAlignment(5)
		self.currentWeightIndicator:SizeToContents()
	end

	self.Confirm = vgui.Create("EGMButton", self.Frame)
	self.Confirm:SetPos(ScrW() * 0.4, ScrH() * 0.9)
	self.Confirm:SetSize(ScrW() * 0.2, ScrH() * 0.05)
	self.Confirm:SetFont("EGMText12")
	self.Confirm:SetTextColor(UI.TextColor)
	self.Confirm:SetText(egmt("shared.apply"))
	self.Confirm:SetButtonColor(GetColor("green"))
	self.Confirm:SetButtonCornerRadius(5)
	function self.Confirm:DoClick()
		local sendTable = {}

		for k,v in pairs(AmmoSystem.AmmoList.AmmoTypes) do
			table.insert(sendTable, {math.floor(v[1]:GetValue()), v[2]})
		end

		net.Start("AmmoSystem.ChangeLoadout")
			net.WriteTable(sendTable)
		net.SendToServer()

		AmmoSystem:CloseMenu()
	end

	self.Frame:MakePopup()
end

--gamemodes/starwarsrp/gamemode/modules/lightsaberutil/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Lightsaber Config          --
---------------------------------------

-- The amount of levels required to become a new skill point.
LightsaberUtil.LevelPerSkillPoint = 5

LightsaberUtil.BlockAnims = {
	"b_block_forward_riposte",
	"h_block",
	"h_block_forward_riposte",
	"judge_h_block",
	"phalanx_b_block_left"
}

LightsaberUtil.HiddenClasses = {
	["weapon_lightsaber_palpatine"] = true,
	["weapon_lightsaber_palpatinedual"] = true,
}

LightsaberUtil.InvHolster = {
	["weapon_lightsaber_electrostaff_republic"] = true,
	["weapon_lightsaber_electrostaff"] = true,
	["weapon_lightsaber_vibro"] = true,
}

LightsaberUtil.DualModels = {
	["models/swtor/arsenic/lightsabers/adascorppolesaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/antiquesocorrosaberstaffaurek.mdl"] = true,
	["models/swtor/arsenic/lightsabers/antiquesocorrosaberstaffdorn.mdl"] = true,
	["models/swtor/arsenic/lightsabers/artusiansaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/attunedforcelord'ssaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/reckoning'sexposedsaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/retribution'sexposedsaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/blademaster'sattenuatedsaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/blademaster'ssaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/temptedapprentice'sdualsaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/chrysopazsaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/unstablepeacemaker'sdualsaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/exquisitechampiondualsaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/ardentdefender'sdualsaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/defianttechnographer'sdualsaber.mdl"] = true,
	["models/swtor/arsenic/lightsabers/derelictsaberstaff.mdl"] = true,
	["models/swtor/arsenic/lightsabers/revanite'smk-1polesaber.mdl"] = true
}
--gamemodes/starwarsrp/gamemode/modules/lightsaberutil/sh_lightsaberutil.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Lightsaber Shared          --
---------------------------------------

-- Add rank property: forcepowers
Rank:AddProperty("forcepowers", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add equipment property: forcepowers
Equipment:AddProperty("forcepowers", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Add Equipment property: fPowers
Equipment:AddProperty("fPowers", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Add material sets to the effect list.
hook.Add("Equipment.GetEffectList", "LigthsaberUtil.EquipmentEffect", function(equip, effectList)
	local forcePowers = equip:GetProperty("forcepowers", {})
	if istable(forcePowers) and table.Count(forcePowers) > 0 then
		table.insert(effectList, "SKILL")
	end

	local fPowers = equip:GetProperty("fPowers", {})
	if istable(fPowers) and table.Count(fPowers) > 0 then
		table.insert(effectList, "FORCE")
	end
end)



---------------------------------------
--               Hooks               --
---------------------------------------

function LightsaberUtil:OverrideFallDamageHook(ply, speed)
	if not SERVER then return end

	hook.Add("GetFallDamage", "rb655_lightsaber_no_fall_damage_wOS", function(ply, speed)
		if not IsValid(ply) then return end

		local activeWeapon = ply:GetActiveWeapon()
		if not IsValid(activeWeapon) or not activeWeapon.IsLightsaber then return end

		if activeWeapon.AllowFallDamage then return end

		return 0
	end)
end

local function applyOverrides()
	local Player = FindMetaTable("Player")

	function Player:GetSkillLevel()
		return self:GetLevel()
	end

	if SERVER then
		function Player:GetSkillPoints()
			local availableSkillPoints = math.floor(self:GetLevel() / LightsaberUtil.LevelPerSkillPoint)

			local usedPoints = 0
			for _, treeData in pairs(self.SkillTree or {}) do
				if not istable(treeData) then continue end

				for _, skillData in pairs(treeData) do
					if not istable(skillData) then continue end

					usedPoints = usedPoints + skillData.PointsRequired
				end
			end

			self:SetNW2Int( "wOS.SkillPoints", availableSkillPoints - usedPoints )
			return availableSkillPoints - usedPoints
		end
	end

	function Player:AddSkillXP() end
	function Player:AddSkillPoints() end

	LightsaberUtil:OverrideFallDamageHook()
end

-- Override the skill system to use the egmrp level system instead.
hook.Add("wOS.ALCS.OnLoaded", "WOS.ALCS.Compatibility.Load", applyOverrides)

-- Load on file load, for the case when ALCS is already loaded.
applyOverrides()
--gamemodes/egmrp/gamemode/modules/realism/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Realism config           --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Whether to disable the ability to sprint backwards.
Realism.DisableBackwardSprinting = true

-- Whether to remove footstep sounds when crouching (holding ctrl by default).
Realism.RemoveFootstepsWhenCrouching = true

-- Velocity is divided by this value to calculate the falldamage.
Realism.FallDamageDividor = 16

-- Wheter to enable the stamina system.
Realism.StaminaSystemEnabled = true

-- Maximum amount of stamina.
Realism.MaxStamina = 100

-- Amount of stamina that gets lost per second while sprinting
Realism.StaminaLoose = 20

-- Amound of stamina the player regenerates per second when not in sprint
Realism.StaminaRegeneration = 20

-- Whether to enable the water (drowning and extinguish) system.
Realism.WaterSystemEnabled = true

-- Maximum amount of oxygen.
Realism.MaxOxygen = 100

-- Amount of oxygen that gets lost per second when under water
Realism.OxygenLoose = 3

-- Amound of oxygen the player regenerates per second when out of water.
Realism.OxygenRegeneration = 10

-- Amount of damage that the player takes per second while drowning.
Realism.DrowningDamage = 10

-- Whether the realistig damage system is enabled
Realism.DamageSystemEnabled = true

-- Realistic damage multipliers.
Realism.HeadDamageMultiplier = 2.5
Realism.ChestDamageMultiplier = 1
Realism.StomachDamageMultiplier = 0.75
Realism.ArmDamageMultiplier = 0.5
Realism.LegDamageMultiplier = 0.5

-- Whether the resistance system should be enabled.
Realism.ResistanceSystemEnabled = false

-- Player models that are resistant to specific damage types.
Realism.PlayerModelResistance = {
    --[DMG_TYPE] = {"models/player/model.mdl", "models/player/model_two.mdl"}
}

-- The time the breathing swep makes a player immune against the specified DMG_TYPES below
Realism.BreathingTime = 600

-- Against which DMG_Types  the Breathing SWEP makes resistant
Realism.BreathingResistance = {
    DMG_POISON,
    DMG_DROWN,
    DMG_NERVEGAS
}
--gamemodes/egmrp/gamemode/modules/realism/sh_watersystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Watersystem        --
---------------------------------------

Realism.NextDrownThink = CurTime()
Realism.BreatherOxygenLoose = Realism.OxygenLoose / (Realism.BreathingTime / Realism.MaxOxygen)

if SERVER then
    hook.Add("OnEntityWaterLevelChanged", "Realism.ShouldDrown", function(ent, old, new)
        if new == 3 and ent:IsPlayer() and (ent:HasMoveType(MOVETYPE_WALK) or ent:HasMoveType(MOVETYPE_NONE) or ent:InVehicle()) then
            ent.Submerged = true
        else
            ent.Submerged = nil
        end

        -- Extinguish ignited entities when they are under water.
        if new >= 2 and ent:IsOnFire() then
            ent:Extinguish()

            -- Sound from https://steamcommunity.com/sharedfiles/filedetails/?id=1228296128
            local phys = ent:GetPhysicsObject()
            if IsValid(phys) then
                ent:EmitSound("realism/flame_out.wav", math.Clamp(phys:GetMass() * 0.25, 55, 85))
            else
                ent:EmitSound("realism/flame_out.wav", 75)
            end
        end
    end)

    hook.Add("PlayerSpawn", "Realism.ResetDowning", function(ply)
        ply.Oxygen = Realism.MaxOxygen
        ply.Submerged = nil
        ply:SetNWBool("Realism.UsingBreather", false)
    end)

    local function doWaterThink(ply)
        if ply:Alive() then
            if ply.Submerged or ply:GetNWBool("Realism.UsingBreather", false) then
                if ply.Oxygen == 0 then
                    local dmg = DamageInfo()
                    dmg:SetDamage(Realism.DrowningDamage)
                    dmg:SetAttacker(ply)
                    dmg:SetInflictor(ply)
                    dmg:SetDamageType(DMG_DROWN)

                    ply:TakeDamageInfo(dmg)
                else
                    if ply:GetNWBool("Realism.UsingBreather", false) then
                        ply.Oxygen = math.max(0, ply.Oxygen - Realism.BreatherOxygenLoose)
                    else
                        ply.Oxygen = math.max(0, ply.Oxygen - Realism.OxygenLoose)
                    end
                end
            else
                ply.Oxygen = math.min(Realism.MaxOxygen, ply.Oxygen + Realism.OxygenRegeneration)
            end
        end
    end

    hook.Add("Think", "Realism.WaterSystem", function()
        if Realism.NextDrownThink < CurTime() then
            for _, ply in pairs(player.GetHumans()) do
                doWaterThink(ply)
            end

            Realism.NextDrownThink = CurTime() + 1
        end
    end)
end

if CLIENT then
    local function doWaterThink(ply)
        if not ply:Alive() then return end

        local char = ply:GetCurrentCharacter()
        if not char then return end

        if not isnumber(ply.Oxygen) then
            ply.Oxygen = Realism.MaxOxygen
        end

        -- Check if the player is underwater.
        if ply:GetNWBool("Realism.UsingBreather", false) then
            ply.Oxygen = math.max(0, ply.Oxygen - Realism.BreatherOxygenLoose * FrameTime())
        elseif ply:WaterLevel() == 3 then
            ply.Oxygen = math.max(0, ply.Oxygen - Realism.OxygenLoose * FrameTime())
        else
            ply.Oxygen = math.min(Realism.MaxOxygen, ply.Oxygen + Realism.OxygenRegeneration * FrameTime())
        end
    end

    hook.Add("Think", "Realism.WaterSystem", function()
        if not Realism.WaterSystemEnabled then return end

        doWaterThink(LocalPlayer())
    end)
end

if CLIENT then
    -- Paint oxygen bar.
    hook.Add("HUDPaint", "Realism.WaterSystem", function()
        local ply = LocalPlayer()

        if ply.Oxygen and Realism.MaxOxygen and  ply.Oxygen < Realism.MaxOxygen then
            local percentage = math.Round(ply.Oxygen, 1) / Realism.MaxOxygen
            local color = percentage > 0.25 and GetColor("black", 127) or GetColor("red", 127)

            -- Background bar.
            draw.RoundedBox(5, ScrW() * 0.4, ScrH() * 0.935, ScrW() * 0.2, ScrH() * 0.011, color)

            -- Foreground bar.
            draw.RoundedBox(5, math.floor(ScrW() * 0.4 + ScrW() * 0.1 * (1 - percentage)), ScrH() * 0.935, math.ceil(ScrW() * 0.2 * percentage), ScrH() * 0.011, GetColor("blue", 175))

            if percentage < 0.5 then
                local alphaValue = math.max(0, (0.5 - percentage) * 2) * 250
                draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), GetColor("gray", alphaValue))
            end
        end
    end)
end
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--  Lightsaber Crafting | SH Index   --
---------------------------------------

if not RequireModules({"donator"}) then
	return false
end

LightsaberCrafting = LightsaberCrafting or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_lightsaber.lua")
	AddCSLuaFile("sh_donator.lua")
	AddCSLuaFile("cl_lightsaber.lua")
	AddCSLuaFile("cl_crafting.lua")
	AddCSLuaFile("cl_adminmenu.lua")

	include("sh_config.lua")
	include("sh_lightsaber.lua")
	include("sh_donator.lua")
	include("sv_lightsaber.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_lightsaber.lua")
	include("sh_donator.lua")
	include("cl_lightsaber.lua")
	include("cl_crafting.lua")
	include("cl_adminmenu.lua")
end
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/sh_lightsaber.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Lightsaber Crafting | SH      --
---------------------------------------

Character:AddProperty("lightsaberData", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	-- Only network the saber data to the owner of the character.
	return character:BelongsTo(ply)
end)

Character:AddProperty("lightsaberInv", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	if ply:IsAtLeast(LightsaberCrafting.ModifyAtLeast) then return true end

	return character:BelongsTo(ply)
end)

function Character.Meta:HasLightsaberItem(item)
	if self:GetOwner():HasDonatorItem(item) then return true end
	if item == "Standard" then return true end

	local inventory = self:GetProperty("lightsaberInv", {})
	return table.HasValue(inventory, item)
end

local Player = FindMetaTable("Player")
function Player:HasDonatorItem(item)
	for identifier, name in pairs(LightsaberCrafting.DonatorPackets) do
		if name == item then
			return self:IsDonator(identifier)
		end
	end
end

---------------------------------------
--        Primary Lightsaber         --
---------------------------------------

-- Returns the characters current used crystal
--
-- @return? String crystal
function Character.Meta:GetCrystal()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing crystal
	local crystal = saberData.Crystal
	if not crystal then return "Standard" end

	-- The crystal must a wOS valid item
	local itemData = wOS:GetItemData(crystal)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.CRYSTAL then return "Standard" end

	return crystal
end

-- Returns the characters current used hilt
--
-- @return? String hilt
function Character.Meta:GetHilt()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing hilt
	local hilt = saberData.Hilt
	if not hilt then return "Standard" end

	-- The hilt must a wOS valid item
	local itemData = wOS:GetItemData(hilt)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.HILT then return "Standard" end

	return hilt
end

-- Returns the characters current used power vortex
--
-- @return? String powerVortex
function Character.Meta:GetPowerVortex()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing power vortex
	local powerVortex = saberData.PowerVortex
	if not powerVortex then return "Standard" end

	-- The power vortex must a wOS valid item
	local itemData = wOS:GetItemData(powerVortex)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.VORTEX then return "Standard" end

	return powerVortex
end

-- Returns the characters current used idle regulator
--
-- @return? String idleRegulator
function Character.Meta:GetIdleRegulator()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing power vortex
	local idleRegulator = saberData.IdleRegulator
	if not idleRegulator then return "Standard" end

	-- The idle regulator must a wOS valid item
	local itemData = wOS:GetItemData(idleRegulator)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.IDLE then return "Standard" end

	return idleRegulator
end

-- Returns the characters current used crystal activator
--
-- @return? String crystalActivator
function Character.Meta:GetActivator()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is an existing crystal activator
	local activator = saberData.Activator
	if not activator then return "Standard" end

	-- The crystal activator must be a wOS valid item
	local itemData = wOS:GetItemData(activator)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.IGNITER then return "Standard" end

	return activator
end

---------------------------------------
--       Secondary Lightsaber        --
---------------------------------------

-- Returns the characters current used secondary crystal
--
-- @return? String crystal
function Character.Meta:GetSecCrystal()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing crystal
	local crystal = saberData.SecCrystal
	if not crystal then return "Standard" end

	-- The crystal must a wOS valid item
	local itemData = wOS:GetItemData(crystal)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.CRYSTAL then return "Standard" end

	return crystal
end

-- Returns the characters current used secondary hilt
--
-- @return? String hilt
function Character.Meta:GetSecHilt()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing hilt
	local hilt = saberData.SecHilt
	if not hilt then return "Standard" end

	-- The hilt must a wOS valid item
	local itemData = wOS:GetItemData(hilt)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.HILT then return "Standard" end

	return hilt
end

-- Returns the characters current used secondary power vortex
--
-- @return? String powerVortex
function Character.Meta:GetSecPowerVortex()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing power vortex
	local powerVortex = saberData.SecPowerVortex
	if not powerVortex then return "Standard" end

	-- The power vortex must a wOS valid item
	local itemData = wOS:GetItemData(powerVortex)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.VORTEX then return "Standard" end

	return powerVortex
end

-- Returns the characters current used secondary idle regulator
--
-- @return? String idleRegulator
function Character.Meta:GetSecIdleRegulator()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is a existing power vortex
	local idleRegulator = saberData.SecIdleRegulator
	if not idleRegulator then return "Standard" end

	-- The idle regulator must a wOS valid item
	local itemData = wOS:GetItemData(idleRegulator)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.IDLE then return "Standard" end

	return idleRegulator
end

-- Returns the characters current used crystal activator
--
-- @return? String crystalActivator
function Character.Meta:GetSecActivator()
	-- Calls the saber data
	local saberData = self:GetProperty("lightsaberData", {})
	if table.IsEmpty(saberData) then return "Standard" end

	-- Checks if there is an existing crystal activator
	local activator = saberData.SecActivator
	if not activator then return "Standard" end

	-- The crystal activator must be a wOS valid item
	local itemData = wOS:GetItemData(activator)
	if not itemData then return "Standard" end
	if itemData.Type ~= WOSTYPE.IGNITER then return "Standard" end

	return activator
end
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/cl_lightsaber.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Lightsaber Crafting | CL      --
---------------------------------------

-- Closes the inventory.
function LightsaberCrafting:CloseMenu()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

function LightsaberCrafting:OpenInventory()
	self:CloseMenu()

	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.Background)
	self.Frame:SetSubTitle("Laserschwert - Inventar")

	self.ModelPanel = vgui.Create("EGMModelPanel", self.Frame)
	self.ModelPanel:SetPos(ScrW() * 0.1, ScrH() * 0.25)
	self.ModelPanel:SetSize(ScrW() * 0.3, ScrH() * 0.65)
	self.ModelPanel:SetCharacter(character)

	self.InventoryPanel = vgui.Create("EGMScrollPanel", self.Frame)
	self.InventoryPanel:SetPos(ScrW() * 0.45, ScrH() * 0.25)
	self.InventoryPanel:SetSize(ScrW() * 0.5, ScrH() * 0.65)
	function self.InventoryPanel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 220))
	end

	local iconWidth = ScrW() * 0.15

	function self.InventoryPanel:Update()
		if IsValid(self.IconLayout) then
			self.IconLayout:Clear()
			self.IconLayout:Remove()
		end

		self.IconLayout = vgui.Create("DIconLayout", self)
		self.IconLayout:DockMargin(8, 8, 0, 0)
		self.IconLayout:Dock(FILL)
		self.IconLayout:SetSpaceY(8)
		self.IconLayout:SetSpaceX(8)

		-- Adds all inventory items
		local inventory = character:GetProperty("lightsaberInv", {})
		for id, item in pairs(inventory) do
			local itemData = wOS.ItemList[item]
			if not itemData then print("[Lightsaber Crafting] Item " .. item .. " not found!") continue end

			local icon = vgui.Create("EGMModelIcon", self.IconLayout)
			icon:SetWidth(iconWidth)
			icon:SetHeight(iconWidth / 2)

			icon:SetModel(itemData.Model)
			icon:SetDisplayType("Money")

			function icon:DoClick()
				local contextMenu = DermaMenu(false, self)
				contextMenu:AddOption("Entfernen", function()
					net.Start("LSCrafting.RemoveItem")
						net.WriteInt(character:GetId(), 32)
						net.WriteInt(id, 6)
					net.SendToServer()
				end):SetImage("icon16/cross.png")
			end

			function icon:Paint(ww, hh)
				local mat = self.Material
				if mat then
					surface.SetDrawColor(255, 255, 255, 255)
					surface.SetMaterial(mat)
					surface.DrawTexturedRect(0, 0, ww, hh)
				end

				draw.SimpleText(itemData.Name, "EGMText10", ww / 2, hh - 5, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
			end
		end

		hook.Run("LightsaberCrafting.AddInventoryItems", self)

		self.IconLayout:Refresh()
		self:Rebuild()
	end
	self.InventoryPanel:Update()

	self.Frame:MakePopup()
end

-- Adds donator items
hook.Add("LightsaberCrafting.AddInventoryItems", "LightsaberCrafting.AddDonatorItems", function(panel)
	for identifier, name in pairs(LightsaberCrafting.DonatorPackets) do
		if not LocalPlayer():IsDonator(identifier) then continue end
		local iconWidth = ScrW() * 0.15

		local itemData = wOS.ItemList[name]
		if not itemData then print("[Lightsaber Crafting] Item " .. name .. " not found!") continue end

		local icon = vgui.Create("EGMModelIcon", panel.IconLayout)
		icon:SetWidth(iconWidth)
		icon:SetHeight(iconWidth / 2)

		icon:SetModel(itemData.Model)
		icon:SetDisplayType("Money")

		function icon:DoClick()
		end

		function icon:Paint(ww, hh)
			local mat = self.Material
			if mat then
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetMaterial(mat)
				surface.DrawTexturedRect(0, 0, ww, hh)
			end

			draw.SimpleText(itemData.Name, "EGMText10", ww / 2, hh - 5, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		end
	end
end)

-- Refresh menu when a character property / data got changed.
hook.Add("Character.PropertyChanged", "LightsaberCrafting.InventoryUpdated", function(character, key, value, oldValue)
	if IsValid(LightsaberCrafting.Frame) and character:GetOwner() == LocalPlayer() and key == "lightsaberInv" then
		LightsaberCrafting.InventoryPanel:Update()
	end
end)





--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/cl_crafting.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Lightsaber Crafting | CL      --
---------------------------------------

local w, h = ScrW(), ScrH()

if not wOS or not wOS.ALCS then
	return
end

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation or Vector( 0, 0, 0 )
local color_unselected = Color( 0, 0, 0, 100 )

wOS.CraftingCamera = {}
wOS.CraftingCamera[ "Overview" ] = { origin = centerpoint - Vector( 400, -35, -25 ), angles = Angle( 20.840, -30.501, 0.000 ) }

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )

local ItemTable = {}
ItemTable[WOSTYPE.CRYSTAL] = Material("wos/crafting/items/crystal.png", "unlitgeneric")
ItemTable[WOSTYPE.IGNITER] = Material("wos/crafting/items/crystal_ignitor.png", "unlitgeneric")
ItemTable[WOSTYPE.IDLE] = Material("wos/crafting/items/idle_regulator.png", "unlitgeneric")
ItemTable[WOSTYPE.VORTEX] = Material("wos/crafting/items/power_vortex.png", "unlitgeneric")
ItemTable[WOSTYPE.HILT] = Material("wos/crafting/items/hilt.png", "unlitgeneric")
ItemTable[WOSTYPE.BLUEPRINT] = Material("wos/crafting/items/blueprint.png", "unlitgeneric")

function wOS:OpenSaberCrafting()
	if self.CraftingMenu then
		self:CleanCraftingMenus()
		net.Start("wOS.ALCS.Crafting.CleanExit")
		net.SendToServer()
		return
	end

	gui.EnableScreenClicker( true )

	if !self.PreCraftingMenu then
		wOS.UsingDualLightsaber = false
		self.PreCraftingMenu = vgui.Create( "DPanel" )
		self.PreCraftingMenu:SetSize( w, h )
		self.PreCraftingMenu:Center()
		self.PreCraftingMenu.Paint = function() end
		self.PreCraftingMenu.Think = function()
			if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		end

		local PrimarySaber = vgui.Create( "DButton", self.PreCraftingMenu )
		PrimarySaber:SetSize(w * 0.12, h * 0.05)
		PrimarySaber:SetPos(w * 0.38, h * 0.44)
		PrimarySaber:SetText("")
		PrimarySaber.Paint = function( pan, ww, hh )
			surface.SetDrawColor( ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.SimpleText( "Primary Lightsaber", "wOS.CraftMinors", ww/2, hh/2, ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		PrimarySaber.DoClick = function( pan )
			wOS.CurrentInventoryTable = "EquippedItems"
			wOS.CurrentCraftTable = "PersonalSaber"
			wOS.UsingDualLightsaber = false
			wOS:OpenSaberCrafting()
		end

		local SecondarySaber = vgui.Create( "DButton", self.PreCraftingMenu )
		SecondarySaber:SetSize( w*0.12, h*0.05 )
		SecondarySaber:SetPos( w*0.51, h*0.51 )
		SecondarySaber:SetText( "" )
		SecondarySaber.Paint = function( pan, ww, hh )
			surface.SetDrawColor( ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.SimpleText( "Off Hand Lightsaber", "wOS.CraftMinors", ww/2, hh/2, ( pan:IsHovered() and Color( 0, 166, 255, 255 ) ) or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		SecondarySaber.DoClick = function( pan )
			wOS.CurrentInventoryTable = "SecEquippedItems"
			wOS.CurrentCraftTable = "SecPersonalSaber"
			wOS.UsingDualLightsaber = true
			wOS:OpenSaberCrafting()
		end

		return
	else
		self.PreCraftingMenu:Remove()
		self.PreCraftingMenu = nil
	end

	if self.InventoryPanel then
		self:ViewInventory()
	end

	gui.EnableScreenClicker(true)
	wOS.PersonalSaber.Hilt = GetConVar( "rb655_lightsaber_model" ):GetString()
	wOS.PersonalSaber.CustomSettings[ "CraftingSaber" ] = true
	self.CraftingFocus = "Overview"

	self.CraftingMenu = vgui.Create( "DFrame" )
	self.CraftingMenu:SetDraggable( true )
	self.CraftingMenu:ShowCloseButton( false )
	self.CraftingMenu:SetTitle( "" )
	self.CraftingMenu:SetSize( ScrW()*0.9, ScrH()*0.9 )
	self.CraftingMenu:Center()
	self.CraftingMenu.SpawnTime = CurTime()
	self.CraftingMenu.PosData = { x = -1, y = -1 }

	local mw, mh = self.CraftingMenu:GetSize()
	local button = vgui.Create( "DButton", self.CraftingMenu )
	button:SetSize(mw * 0.015, mh * 0.02 )
	button:SetPos(mw * 0.985, 0 )
	button:SetText("")
	button.DoClick = function()
		self:CleanCraftingMenus()

		net.Start( "wOS.ALCS.Crafting.CleanExit" )
		net.SendToServer()
	end
	button.Paint = nil

	self.CraftingMenu.Paint = function( pan, ww, hh )
		if not pan.DrawRender then return end
		local ww, hh = pan:GetSize()
		local px, py = pan:GetPos()
		pan.PosData.x, pan.PosData.y = pan:CursorPos()

		pan.RenderNow = true
			draw.RoundedBox( 0, px, py, ww*0.985, hh*0.02, Color( 255, 255, 255, 155 ) )
			draw.RoundedBox( 0, px + ww*0.985, py, ww*0.015, hh*0.02, Color( 255, 0, 0 ) )
			local tbl = hook.Call( "CalcView", GAMEMODE, LocalPlayer() )
			tbl.w = ww
			tbl.h = hh*0.98
			tbl.x = px
			tbl.y = py + hh*0.02
			tbl.fov = 85
			render.RenderView( tbl )
		pan.RenderNow = false
	end

	self.CraftingMenu.Think = function()
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		if not LocalPlayer():Alive() or input.IsKeyDown( KEY_BACKSPACE ) then
			wOS:CleanCraftingMenus()
			net.Start( "wOS.ALCS.Crafting.CleanExit" )
			net.SendToServer()
			return
		end
	end

	self.CraftingMenu.OriginalItems = table.Copy( self[ self.CurrentInventoryTable ] )

	self:BuildCraftingSaber()
	LastCamOrigin = self.CraftingMenu.Saber:GetPos() + Vector( 0, 0, 50 )
	LastCamAng = Angle( 90, 0, 0 )
	self:RebuildCraftingMenus()
end

wOS.CraftMenuLibrary = {}

wOS.CraftMenuLibrary[ "Overview" ] = function()
	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 5
	bladecat.ShouldAcceptInputs = true
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, -15 + 2 * hh )
		pan:Line( 0, -15 + 2 * hh, 5, -15 + hh/2 )
		pan:Rect( 5, -15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( language.GetPhrase( "wos_option_color" ), "wOS.TitleFont", 5, -15, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/button9.wav" )
		   	wOS.CraftingFocus = language.GetPhrase( "wos_option_color" )
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	bladecat:SetUIScale( 10 )
	bladecat:SetIgnoreZ( false )

	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles + Angle( 0, 0, 0 )
	bladecat.CamPos = spos + sang * wOS[ wOS.CurrentCraftTable ].UseLength * 0.5
	bladecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_option_color" ) ] = { origin = bladecat.CamPos + Vector( -15, -10, 5 ), angles = Vector( 15, -7, -5 ):Angle() + Angle( 0, 45, 0 ) - Angle( 0, 360, 0 )  }
	table.insert( wOS.CraftingButtons, bladecat )

	local hiltcat = tduiw.Create()
	hiltcat.SizeX = 10
	hiltcat.SizeY = 5
	hiltcat.ShouldAcceptInputs = true
	hiltcat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, -15 + 2*hh )
		pan:Line( 0, -15 + 2*hh, -5, -15 + hh/2 )
		pan:Rect( -5 - ww, -15, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_option_hilt" ), "wOS.TitleFont", -5 - ww, -15, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/button9.wav" )
		   	wOS.CraftingFocus = language.GetPhrase( "wos_option_hilt" )
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	hiltcat:SetUIScale( 10 )
	hiltcat:SetIgnoreZ( false )
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )
	hiltcat.CamPos = apos
	hiltcat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_option_hilt" ) ] = { origin = hiltcat.CamPos + Vector( 0, 0, 30 ), angles = ( Vector( 0, 0, -30 ) ):Angle() + Angle( 0, 0, 90 ) }
	table.insert( wOS.CraftingButtons, hiltcat )

	local ignitecat = tduiw.Create()
	ignitecat.SizeX = 15
	ignitecat.SizeY = 5
	ignitecat.ShouldAcceptInputs = true
	ignitecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, 15 - 2*hh )
		pan:Line( 0, 15 - 2*hh, 5, 15 - hh/2 )
		pan:Rect( 5, 15 - hh, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_igniter" ), "wOS.TitleFont", 5, 15 - hh, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/button9.wav" )
		   	wOS.CraftingFocus = language.GetPhrase( "wos_info_igniter" )
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	ignitecat:SetUIScale( 10 )
	ignitecat:SetIgnoreZ( false )
	ignitecat.CamPos = spos
	ignitecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_igniter" ) ] = { origin = ignitecat.CamPos + Vector( -5, -5, -2 ), angles = Vector( 5, 5, 2 ):Angle() - Angle( 360, 0, 0 )  }
	table.insert( wOS.CraftingButtons, ignitecat )

	local idlecat = tduiw.Create()
	idlecat.SizeX = 15
	idlecat.SizeY = 5
	idlecat.ShouldAcceptInputs = true
	idlecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, 0, 15 - 2*hh )
		pan:Line( 0, 15 - 2*hh, -5, 15 - hh/2 )
		pan:Rect( -5 - ww, 15 - hh, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_humsound" ), "wOS.TitleFont", -5 - ww, 15 - hh, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/button9.wav" )
		   	wOS.CraftingFocus = language.GetPhrase( "wos_info_humsound" )
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	idlecat:SetUIScale( 10 )
	idlecat:SetIgnoreZ( false )
	idlecat.CamPos = apos - aang*3
	idlecat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_humsound" ) ] = { origin = idlecat.CamPos + Vector( 5, 5, -5 ), angles = Vector( -5, -5, 5 ):Angle() - Angle( 360, 360, 0 )  }
	table.insert( wOS.CraftingButtons, idlecat )

	local powercat = tduiw.Create()
	powercat.SizeX = 20
	powercat.SizeY = 5
	powercat.ShouldAcceptInputs = true
	powercat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Line( 0, 0, -5, -5 )
		pan:Line( -5, -5, -15, -5 )
		pan:Rect( -15 - ww, -5 - hh/2, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		--pan:Text( "Crystal", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		local _jp, _pr, _hov = pan:Button(language.GetPhrase( "wos_info_swingsound" ), "wOS.TitleFont", -15 - ww, -5 - hh/2, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/button9.wav" )
		   	wOS.CraftingFocus = language.GetPhrase( "wos_info_swingsound" )
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	powercat:SetUIScale( 10 )
	powercat:SetIgnoreZ( false )
	powercat.CamPos = apos - aang*1.5
	powercat.CamAng = cang
	wOS.CraftingCamera[ language.GetPhrase( "wos_info_swingsound" ) ] = { origin = powercat.CamPos + Vector( 5, 5, 3 ), angles = Vector( -5, -5, -3 ):Angle() - Angle( 0, 360, 0 )  }
	table.insert( wOS.CraftingButtons, powercat )

	local backbutt = tduiw.Create()
	backbutt.SizeX = 20
	backbutt.SizeY = 25
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 40

		pan:Rect( x, -10 - hh*(7/8) - 0.5, ww, hh*(7/8), Color( 25, 25, 25, 245 ), color_white )
		pan:Rect( x, -10 - hh*(7/8) - 0.5, ww, hh*(1/8), Color( 25, 25, 25, 245 ), color_white )
		pan:Text( "Current Stats", "wOS.TitleFont", x + ww*0.05, -10 - hh*(7/8) - 0.5 + hh/16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		-- pan:Text( "Proficiency Level: " .. LocalPlayer():GetNW2Int( "wOS.ProficiencyLevel", 0 ), "wOS.TitleFont", x + ww*0.95, -10 - hh*(7/8) - 0.5 + hh/16, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		pan:Text( "Hilt: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Crystal: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Idle Regulator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 4, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Crystal Activator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 6, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Power Vortex Regulator: " .. wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ], "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 8, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Blade Length: " .. wOS[ wOS.CurrentCraftTable ].UseLength, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Blade Width: " .. wOS[ wOS.CurrentCraftTable ].UseWidth, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Base Damage: " .. wOS[ wOS.CurrentCraftTable ].SaberDamage, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 14, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Text( "Base Burn Damage: " .. wOS[ wOS.CurrentCraftTable ].SaberBurnDamage, "wOS.TitleFont", x + 1, -10 - hh*(7/8) - 0.5 + hh/8 + 1.5 + 16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		pan:Rect( x, -5, ww, hh / 8, Color( 25, 25, 25, 245 ), color_unselected)
		local _jp, _pr, _hov = pan:Button( "Fabricate", "wOS.TitleFont", x, -5, ww, hh / 8 )
		if _jp then
			surface.PlaySound( "buttons/button24.wav" )
			wOS:CleanCraftingMenus()

			net.Start("LightsaberCrafting.UpdateItems")
				net.WriteTable(wOS.EquippedItems)
				net.WriteTable(wOS.SecEquippedItems)
			net.SendToServer()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 20 )
	backbutt.Scaling = 0.05
	backbutt.CamPos = apos - aang * 1.5
	backbutt.CamAng = cang

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[language.GetPhrase( "wos_option_color" )] = function()
	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )

	local sorted_list = {}
	sorted_list[1] = wOS[wOS.CurrentInventoryTable][WOSTYPE.CRYSTAL]
	if sorted_list[1] ~= "Standard" then
		sorted_list[2] = "Standard"
	end

	local inventory = character:GetProperty("lightsaberInv", {})
	for id, name in pairs(inventory) do
		local itemData = wOS.ItemList[name]
		if not itemData then continue end
		if itemData.Type ~= WOSTYPE.CRYSTAL then continue end

		if not table.HasValue(sorted_list, name) then
			sorted_list[#sorted_list + 1] = name
		end
	end

	hook.Run("LightsaberCrafting.AddShopItems", sorted_list, WOSTYPE.CRYSTAL)

	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 2.5
	bladecat.ShouldAcceptInputs = true
	bladecat.ScrollMin = 1
	bladecat.ScrollMax = 3
	bladecat.SortedList = table.Copy( sorted_list )
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = 2
		local bw, bh = ww, hh*0.5

		if #pan.SortedList > 3  then
			pan:Mat( upButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, ww * 0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect(ww * 0.48 - hh / 2, offset + bh / 2 + bh / 6, hh / 2, 2 * bh, Color( 0, 0, 0, 0 ), color_white)
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.CRYSTAL ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect(ww * 0.5, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			pan:Text(data.Name, "wOS.CraftDescriptions", ww*0.5 + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text(data.Description, "wOS.CraftMinors", ww*0.5 + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", ww*0.5 + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ] == data.Name then
				pan:Rect( ww*0.5, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.5, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.CRYSTAL ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable(wOS[ wOS.CurrentInventoryTable])
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end

		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end

	bladecat:SetUIScale( 100 )
	bladecat.Scaling = 0.01
	bladecat.CamPos = spos + sang * wOS[ wOS.CurrentCraftTable ].UseLength * 0.5
	bladecat.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, bladecat )

	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -2*ww, 4, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -2*ww, 4, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
		   	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end

	backbutt:SetUIScale(100)
	backbutt.Scaling = 0.01
	backbutt.CamPos = spos + sang * wOS[wOS.CurrentCraftTable].UseLength * 0.5
	backbutt.CamAng = sang:Angle() + Angle(0, 90, 0)

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_option_hilt" ) ] = function()
	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )

	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.HILT ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.HILT ]
	end

	local inventory = character:GetProperty("lightsaberInv", {})
	for id, name in pairs(inventory) do
		local itemData = wOS.ItemList[name]
		if not itemData then continue end
		if itemData.Type and itemData.Type ~= WOSTYPE.HILT then continue end

		if not table.HasValue(sorted_list, name) then
			sorted_list[#sorted_list + 1] = name
		end
	end

	hook.Run("LightsaberCrafting.AddShopItems", sorted_list, WOSTYPE.HILT)

	if wOS[ wOS.CurrentCraftTable ].UseHilt:find("maul_saber_staff") then
		aang = aang * -1
	end

	local bladecat = tduiw.Create()
	bladecat.SizeX = 10
	bladecat.SizeY = 2.5
	bladecat.ShouldAcceptInputs = true
	bladecat.ScrollMin = 1
	bladecat.ScrollMax = 3
	bladecat.SortedList = table.Copy( sorted_list )
	bladecat.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local offset = -2.3
		local bw, bh = ww, hh * 0.5

		if #pan.SortedList > 3  then
			pan:Mat( upButton, ww * 0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( ww*0.48 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.HILT ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( ww*0.5, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", ww*0.5 + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", ww*0.5 + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", ww*0.5 + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ] == data.Name then
				pan:Rect( ww*0.5, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.5, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.HILT ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", ww*0.48 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat:SetUIScale( 100 )
	bladecat.Scaling = 0.01
	bladecat.CamPos = apos + Vector( 0, 0, 8 )
	bladecat.CamAng = aang:Angle() + Angle( 94, -5, 0 )

	table.insert( wOS.CraftingButtons, bladecat )

	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -9 - ww/2, 4, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -9 - ww/2, 4, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
		   	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.01
	backbutt.CamPos = apos + Vector( 0, 0, 8 )
	backbutt.CamAng = aang:Angle() + Angle( 94, -5, 0 )

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_igniter" ) ] = function()
	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	local spos, sang = wOS:FindBladePosAng(nil, false, wOS.CraftingMenu.Saber)

	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ]
	if sorted_list[1] ~= "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.IGNITER ] ~= "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.IGNITER ]
	end

	local inventory = character:GetProperty("lightsaberInv", {})
	for id, name in pairs(inventory) do
		local itemData = wOS.ItemList[name]
		if not itemData then continue end
		if itemData.Type ~= WOSTYPE.IGNITER then continue end

		if not table.HasValue(sorted_list, name) then
			sorted_list[#sorted_list + 1] = name
		end
	end

	hook.Run("LightsaberCrafting.AddShopItems", sorted_list, WOSTYPE.IGNITER)

	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -2
		local offset = 3.5
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.IGNITER ][ pan.SortedList[ i ] ]
			if not data then continue end

			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IGNITER ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end

		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.004
	bladecat2.CamPos = spos
	bladecat2.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, bladecat2 )

	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -11 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -11 - ww/2, 3, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
		   	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005
	backbutt.CamPos = spos
	backbutt.CamAng = sang:Angle() + Angle( 0, 90, 0 )

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_humsound" ) ] = function()
	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )

	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.IDLE ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.IDLE ]
	end

	local inventory = character:GetProperty("lightsaberInv", {})
	for id, name in pairs(inventory) do
		local itemData = wOS.ItemList[name]
		if not itemData then continue end
		if itemData.Type ~= WOSTYPE.IDLE then continue end

		if not table.HasValue(sorted_list, name) then
			sorted_list[#sorted_list + 1] = name
		end
	end

	hook.Run("LightsaberCrafting.AddShopItems", sorted_list, WOSTYPE.IDLE)

	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -2
		local offset = 3.5
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x*1.1 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.IDLE ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.IDLE ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x*1.1 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.004
	bladecat2.CamPos = apos - aang*3
	bladecat2.CamAng = sang:Angle() + Angle( 0, -90, 0 )

	table.insert( wOS.CraftingButtons, bladecat2 )

	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -11 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -11 - ww/2, 3, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
		   	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005
	backbutt.CamPos = apos - aang*3
	backbutt.CamAng = sang:Angle() + Angle( 0, -90, 0 )

	table.insert( wOS.CraftingButtons, backbutt )
end

wOS.CraftMenuLibrary[ language.GetPhrase( "wos_info_swingsound" ) ] = function()
	local character = LocalPlayer():GetCurrentCharacter()
	if not character then return end

	local spos, sang = wOS:FindBladePosAng( nil, false, wOS.CraftingMenu.Saber )
	local cpos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
	local cang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
	local apos, aang = wOS:FindHandPosAng( wOS.CraftingMenu.Saber )

	local sorted_list = {}
	sorted_list[1] = wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ]
	if sorted_list[1] != "Standard" then
		sorted_list[2] = "Standard"
	elseif wOS.CraftingMenu.OriginalItems[ WOSTYPE.VORTEX ] != "Standard" then
		sorted_list[2] = wOS.CraftingMenu.OriginalItems[ WOSTYPE.VORTEX ]
	end

	local inventory = character:GetProperty("lightsaberInv", {})
	for id, name in pairs(inventory) do
		local itemData = wOS.ItemList[name]
		if not itemData then continue end
		if itemData.Type ~= WOSTYPE.VORTEX then continue end

		if not table.HasValue(sorted_list, name) then
			sorted_list[#sorted_list + 1] = name
		end
	end

	hook.Run("LightsaberCrafting.AddShopItems", sorted_list, WOSTYPE.VORTEX)

	local bladecat2 = tduiw.Create()
	bladecat2.SizeX = 10
	bladecat2.SizeY = 2.5
	bladecat2.ShouldAcceptInputs = true
	bladecat2.ScrollMin = 1
	bladecat2.ScrollMax = 3
	bladecat2.SortedList = table.Copy( sorted_list )
	bladecat2.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 0
		local offset = -11
		local bw, bh = ww, hh*0.5
		if #pan.SortedList > 3 then
			pan:Mat( upButton, x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMin > 1 then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin - 1
					pan.ScrollMax = pan.ScrollMax - 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0 )
			end

			pan:Mat( bufferBar, x - 0.5 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh )
			pan:Rect( x - 0.5 - hh/2, offset + bh/2 + bh/6, hh/2, 2*bh, Color( 0, 0, 0, 0 ), color_white )
		end

		for i = pan.ScrollMin, pan.ScrollMax do
			local data = wOS.SortedItemList[ WOSTYPE.VORTEX ][ pan.SortedList[ i ] ]
			if not data then continue end
			pan:Rect( x, offset, bw, bh, Color( 25, 25, 25, 245 ), color_white )
			local col = color_white
			pan:Text( data.Name, "wOS.CraftDescriptions", x + bw*0.01, offset + bh*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan:Text( data.Description, "wOS.CraftMinors", x + bw*0.01, offset + bh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			if data.BurnOnUse then
				pan:Text( "BURNED ON USE", "wOS.CraftMinors", x + bw*0.98, offset + bh*0.05, Color( 255, 0, 0 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
			end
			if wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ] == data.Name then
				pan:Rect( x, offset, bw, bh, Color( 0, 0, 0, 0 ), Color( 0, 128, 255 ) )
			else
				local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x, offset, bw, bh )
				if _jp then
					surface.PlaySound( "buttons/button9.wav" )
					wOS[ wOS.CurrentInventoryTable ][ WOSTYPE.VORTEX ] = data.Name
					net.Start( "wOS.Crafting.PreviewChange" )
						net.WriteBool( wOS.UsingDualLightsaber )
						net.WriteTable( wOS[ wOS.CurrentInventoryTable ] )
					net.SendToServer()
				elseif _hov then
					wOS:CheckButtonHover( pan, i + 30 )
				end
			end
			offset = offset + bh + 0.25
		end
		if #pan.SortedList > 3  then
			offset = offset - 0.25
			pan:Mat( downButton, x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			local _jp, _pr, _hov = pan:Button("", "wOS.CraftDescriptions", x - 0.5 - hh/2, offset - bh/2, hh/2, hh/2 )
			if _jp then
				if pan.ScrollMax < #pan.SortedList then
					surface.PlaySound( "buttons/lightswitch2.wav" )
					pan.ScrollMin = pan.ScrollMin + 1
					pan.ScrollMax = pan.ScrollMax + 1
				end
			elseif _hov then
				wOS:CheckButtonHover( pan, 0.1 )
			end
		end
	end
	bladecat2:SetUIScale( 100 )
	bladecat2.Scaling = 0.003
	bladecat2.CamPos = apos - aang*3
	bladecat2.CamAng = sang:Angle() + Angle( 0, -90, 0 )

	table.insert(wOS.CraftingButtons, bladecat2)

	local backbutt = tduiw.Create()
	backbutt.SizeX = 8
	backbutt.SizeY = 2
	backbutt.ShouldAcceptInputs = true
	backbutt.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		pan:Rect( -5 - ww/2, 3, ww, hh, Color( 25, 25, 25, 245 ), color_unselected )
		local _jp, _pr, _hov = pan:Button( "Back", "wOS.CraftTitles", -5 - ww/2, 3, ww, hh )
		if _jp then
			surface.PlaySound( "buttons/combine_button2.wav" )
		   	wOS.CraftingFocus = "Overview"
			wOS:RebuildCraftingMenus()
		elseif _hov then
			wOS:CheckButtonHover( pan, 0 )
		end
		pan:BlockUseBind()
	end
	backbutt:SetUIScale( 100 )
	backbutt.Scaling = 0.005
	backbutt.CamPos = apos - aang*3
	backbutt.CamAng = sang:Angle() + Angle( 0, -90, 0 )

	table.insert( wOS.CraftingButtons, backbutt )
end

hook.Add("LightsaberCrafting.AddShopItems", "LightsaberCrafting.AddShopItems", function(items, itemType)
	for identifier, name in pairs(LightsaberCrafting.DonatorPackets) do
		if not LocalPlayer():IsDonator(identifier) then continue end

		local itemData = wOS.ItemList[name]
		if not itemData then print("[Lightsaber Crafting] Item " .. name .. " not found!") continue end

		if itemData.Type ~= itemType then continue end

		if not table.HasValue(items, name) then
			items[#items + 1] = name
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/course/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Course | Index          --
---------------------------------------

Course = Course or table.Copy(PropertyModel)

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_course.lua")
    AddCSLuaFile("cl_course.lua")

    AddCSLuaFile("cl_manager.lua")

    include("sh_config.lua")
    include("sh_course.lua")
    include("sv_course.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_course.lua")
    include("cl_course.lua")

    include("cl_manager.lua")
end
--gamemodes/egmrp/gamemode/modules/course/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Course | Manager         --
---------------------------------------

-- Add the course type to the faction manager.
Manager:RegisterObjectType(
    Faction.Name,
    Course.Name,
    egmt("shared.course"),
    function(faction)
        return faction:GetCourses()
    end,
    function(faction)
        return Course:Create({factionId = faction:GetId()}, {name = egmt("course.new")})
    end,
    function(faction, course)
        return course:GetModel():GetPropertyList(faction, course)
    end,
    egmt("course.duplicate"),
    egmt("course.delete"),
    egmt("course.delete_warning"),
    egmt("course.add"),
    egmt("course.save")
)
--gamemodes/egmrp/gamemode/modules/event/cl_event.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Event Lister       --
---------------------------------------

-- Sync the whitelist with the client.
net.Receive("Event.SyncWhitelist", function()
	local whitelist = net.ReadTable()

	LocalPlayer().EventWhitelist = whitelist
end)

-- Closes the event lister.
function Event:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Opens the eventlister.
function Event:Open()
	self:Close()

	if not LocalPlayer():IsAtLeast(Event.MinAccessGroup) then
		chat.AddText(
			GetColor("red"),
			"[" .. egmt("event.lister") .. "] ",
			GetColor("white"),
			egmt("event.lister_denied")
		)

		return
	end

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(Event.Background)
	self.Frame:SetSubTitle(egmt("event.lister"))

	self.PlayerList = vgui.Create("EGMListView", self.Frame)
	self.PlayerList:SetPos(ScrW() * 0.05, ScrH() * 0.25)
	self.PlayerList:SetSize(ScrW() * 0.425, ScrH() * 0.7)
	self.PlayerList:SetHeaderHeight(ScrH() * 0.05)
	self.PlayerList:SetDataHeight(ScrH() * 0.03)
	self.PlayerList:SetMultiSelect(false)
	self.PlayerList:SetHeaderFont("EGMText10")
	self.PlayerList:SetDataFont("EGMText6")
	self.PlayerList:AddCustomColumn(egmt("event.steam_name"))
	self.PlayerList:AddCustomColumn(egmt("event.character_name"))
	function self.PlayerList:Refresh(searchValue)
		if not searchValue then searchValue = "" end

		self:Clear()

		for k, ply in pairs(player.GetAll()) do
			if string.find(string.lower(ply:SteamName()), string.lower(searchValue)) or string.find(string.lower(ply:GetName()), string.lower(searchValue)) then
				local line = self:AddCustomLine(ply:SteamName(), ply:GetName())
				line.ply = ply
			end
		end
	end
	self.PlayerList:Refresh()

	self.PlayerFilter = vgui.Create("DTextEntry", self.PlayerList)
	self.PlayerFilter:SetHeight(ScrH() * 0.03)
	self.PlayerFilter:Dock(BOTTOM)
	self.PlayerFilter:SetUpdateOnType(false)
	self.PlayerFilter:SetPlaceholderText(egmt("shared.searching"))
	function self.PlayerFilter:OnValueChange(newFilter)
		Event.PlayerList:Refresh(newFilter)
	end

	self.RankList = vgui.Create("EGMListView", self.Frame)
	self.RankList:SetPos(ScrW() * 0.525, ScrH() * 0.25)
	self.RankList:SetSize(ScrW() * 0.425, ScrH() * 0.625)
	self.RankList:SetHeaderHeight(ScrH() * 0.05)
	self.RankList:SetDataHeight(ScrH() * 0.03)
	self.RankList:SetMultiSelect(true)
	self.RankList:SetHeaderFont("EGMText10")
	self.RankList:SetDataFont("EGMText6")
	self.RankList:AddCustomColumn(egmt("event.faction"))
	self.RankList:AddCustomColumn(egmt("event.rank"))
	function self.RankList:Refresh(searchValue)
		if not searchValue then searchValue = "" end

		self:Clear()

		for k, rank in pairs(Rank:GetCache()) do
			if rank:GetProperty("slotType") == "event" and
				(string.find(string.lower(rank:GetFaction():GetName()), string.lower(searchValue)) or string.find(string.lower(rank:GetName()), string.lower(searchValue)))
			then
				local line = self:AddCustomLine(rank:GetFaction():GetName(), rank:GetName())
				line.rankID = rank:GetId()
			end
		end
	end
	self.RankList:Refresh()

	self.RankFilter = vgui.Create("DTextEntry", self.RankList)
	self.RankFilter:SetHeight(ScrH() * 0.03)
	self.RankFilter:Dock(BOTTOM)
	self.RankFilter:SetPlaceholderText(egmt("shared.searching"))
	function self.RankFilter:OnValueChange(newFilter)
		Event.RankList:Refresh(newFilter)
	end

	self.Add = vgui.Create("DButton", self.Frame)
	self.Add:SetPos(ScrW() * 0.525, ScrH() * 0.9)
	self.Add:SetSize(ScrW() * 0.425, ScrH() * 0.05)
	self.Add:SetFont("EGMText12")
	self.Add:SetTextColor(UI.TextColor)
	self.Add:SetText(egmt("event.add_to_whitelist"))
	function self.Add:Think()
		if #Event.PlayerList:GetSelected() > 0 and #Event.RankList:GetSelected() > 0 then
			self:SetEnabled(true)
		else
			self:SetEnabled(false)
		end
	end
	function self.Add:Paint(width, height)
		if self:IsEnabled() then
			draw.RoundedBox(0, 0, 0, width, height, GetColor("green"))
		else
			draw.RoundedBox(0, 0, 0, width, height, GetColor("red"))
		end
	end
	function self.Add:DoClick()
		surface.PlaySound(UI.ButtonSound)

		local ranks = {}
		for _, line in pairs(Event.RankList:GetSelected()) do
			table.insert(ranks, line.rankID)
			line:SetSelected(false)
		end

		for _, line in pairs(Event.PlayerList:GetSelected()) do
			local ply = line.ply

			net.Start("Event.AddToWhitelist")
				net.WriteEntity(ply)
				net.WriteTable(ranks)
			net.SendToServer()
		end

		Notify:Success(egmt("event.lister"), egmt("event.whitelist_success"))
	end

	self.Frame:MakePopup()
end
--gamemodes/egmrp/gamemode/modules/event/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Event Keybinds      --
---------------------------------------

-- Add a keybind for opening the event lister.
KeyBind:Register(egmt("event.lister"), egmt("shared.team"), function()
    Event:Open()
end, Event.DefaultBind)
--gamemodes/starwarsrp/gamemode/modules/weaponutil/sh_jedihands.lua:
DEFINE_BASECLASS( "drive_base" );


drive.Register( "drive_jedihands",
{
	--
	-- Called on creation
	--
	Init = function( self )
		self.CameraDist     = 4
		self.CameraDistVel  = 0.1
	end,

	--
	-- Calculates the view when driving the entity
	--
	CalcView =  function( self, view )
		--
		-- Use the utility method on drive_base.lua to give us a 3rd person view
		--
		local idealdist = math.max( 10, self.Entity:BoundingRadius() ) * self.CameraDist
		self:CalcView_ThirdPerson( view, idealdist, 2, { self.Entity } )
		view.angles.roll = 0
	end,

	SetupControls = function( self, cmd )
		--
		-- If we're holding the reload key down then freeze the view angles
		--
		if ( cmd:KeyDown( IN_RELOAD ) ) then
			self.CameraForceViewAngles = self.CameraForceViewAngles or cmd:GetViewAngles()
			cmd:SetViewAngles( self.CameraForceViewAngles )
		else
			self.CameraForceViewAngles = nil
		end

		--
		-- Zoom out when we use the mouse wheel (this is completely clientside, so it's ok to use a lua var!!)
		--
		self.CameraDistVel = self.CameraDistVel + cmd:GetMouseWheel() * -0.5

		self.CameraDist = self.CameraDist + self.CameraDistVel * FrameTime()
		self.CameraDist = math.Clamp( self.CameraDist, 2, 20 )
		self.CameraDistVel = math.Approach( self.CameraDistVel, 0, self.CameraDistVel * FrameTime() * 2 )

	end,
	--
	-- Called before each move. You should use your entity and cmd to
	-- fill mv with information you need for your move.
	--
	StartMove =  function( self, mv, cmd )
		--
		-- Set the observer mode to chase so that the entity is drawn
		--
		self.Player:SetObserverMode( OBS_MODE_CHASE )

		--
		-- Use (E) was pressed - stop it.
		--
		if ( mv:KeyReleased( IN_USE ) ) then
			self:Stop()
		end

		--
		-- Update move position and velocity from our entity
		--
		mv:SetOrigin( self.Entity:GetNetworkOrigin() )
		mv:SetVelocity( self.Entity:GetAbsVelocity() )
		mv:SetMoveAngles( mv:GetAngles() )      -- Always move relative to the player's eyes

		local entity_angle      = mv:GetAngles()
		entity_angle.roll       = self.Entity:GetAngles().roll

		--
		-- Right mouse button is down, don't change the angle of the object
		--
		if ( mv:KeyDown( IN_ATTACK2 ) or mv:KeyReleased( IN_ATTACK2 ) ) then
			entity_angle = self.Entity:GetAngles()
		end

		--
		-- If reload is down then spin the object around
		--
		if ( mv:KeyDown( IN_RELOAD ) ) then
			entity_angle.roll = entity_angle.roll + cmd:GetMouseX() * 0.01
		end

		--
		-- Right mouse button was released
		--
		if ( mv:KeyReleased( IN_ATTACK2 ) ) then
			self.Player:SetEyeAngles( self.Entity:GetAngles() )
		end

		mv:SetAngles( entity_angle )
	end,

	--
	-- Runs the actual move. On the client when there's
	-- prediction errors this can be run multiple times.
	-- You should try to only change mv.
	--
	Move = function( self, mv )
		--
		-- Set up a speed, go faster if shift is held down
		--
		local speed = 0.0005 * FrameTime()
		if ( mv:KeyDown( IN_SPEED ) ) then speed = 0.005 * FrameTime() end

		--
		-- Get information from the movedata
		--
		local ang = mv:GetMoveAngles()
		local pos = mv:GetOrigin()
		local vel = mv:GetVelocity()

		-- Cancel out the roll
		ang.roll = 0

		--
		-- Add velocities. This can seem complicated. On the first line
		-- we're basically saying get the forward vector, then multiply it
		-- by our forward speed (which will be > 0 if we're holding W, < 0 if we're
		-- holding S and 0 if we're holding neither) - and add that to velocity.
		-- We do that for right and up too, which gives us our free movement.
		--
		vel = vel + ang:Forward()   * mv:GetForwardSpeed()  * speed
		vel = vel + ang:Right()     * mv:GetSideSpeed()     * speed
		vel = vel + ang:Up()        * mv:GetUpSpeed()       * speed

		--
		-- We don't want our velocity to get out of hand so we apply
		-- a little bit of air resistance. If no keys are down we apply
		-- more resistance so we slow down more.
		--
		if ( math.abs(mv:GetForwardSpeed()) + math.abs(mv:GetSideSpeed()) + math.abs(mv:GetUpSpeed()) < 0.1 ) then
			vel = vel * 0.90
		else
			vel = vel * 0.99
		end

		--
		-- Add the velocity to the position (this is the movement)
		--
		pos = pos + vel

		--
		-- We don't set the newly calculated values on the entity itself
		-- we instead store them in the movedata. These get applied in FinishMove.
		--
		mv:SetVelocity( vel )
		mv:SetOrigin( pos )
	end,

	--
	-- The move is finished. Use mv to set the new positions
	-- on your entities/players.
	--
	FinishMove =  function( self, mv )
		--
		-- Update our entity!
		--
		self.Entity:SetNetworkOrigin( mv:GetOrigin() )
		self.Entity:SetAbsVelocity( mv:GetVelocity() )
		self.Entity:SetAngles( mv:GetAngles() )

		--
		-- If we have a physics object update that too. But only on the server.
		--
		if ( SERVER && IsValid( self.Entity:GetPhysicsObject() ) ) then
			self.Entity:GetPhysicsObject():EnableMotion( true )
			self.Entity:GetPhysicsObject():SetPos( mv:GetOrigin() );
			self.Entity:GetPhysicsObject():Wake()
			self.Entity:GetPhysicsObject():EnableMotion( false )
		end
	end
}, "drive_base" );
--gamemodes/starwarsrp/gamemode/modules/weaponutil/item_classes/weapon_backpack/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Waffe (Rucksack)"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}
--gamemodes/starwarsrp/gamemode/modules/pronemod/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--         ProneMod Extension        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--   ProneMod Extension | SH Index   --
---------------------------------------

if not prone then
	print("Prone Mod not loaded")
	return
end

ProneMod = ProneMod or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_keybinds.lua")
	AddCSLuaFile("cl_settings.lua")
	AddCSLuaFile("cl_pronemod.lua")

	include("sh_config.lua")
	include("sv_pronemod.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("cl_keybinds.lua")
	include("cl_settings.lua")
	include("cl_pronemod.lua")
end
--gamemodes/starwarsrp/gamemode/modules/rakghoul/weapons/weapon_swrp_rakghoul_blank_swep/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | SH           --
---------------------------------------

SWEP.Base 				= "weapon_swrp_rakghoul_swep"

SWEP.PrintName			= "Beast SWEP"
SWEP.Category			= "SW:RP (Sonstiges)"

SWEP.Spawnable			= true
SWEP.AdminOnly			= false
SWEP.ViewModel 			= "models/weapons/c_arms_citizen.mdl"
SWEP.WorldModel			= ""
SWEP.ViewModelFOV 		= 50
SWEP.ViewModelFlip 		= false
SWEP.DrawCrosshair		= false

function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() >= CurTime() then return end
	self:SetNextPrimaryFire(CurTime() + 0.5)

	local vm = self:GetOwner():GetViewModel()
	vm:ResetSequence( vm:LookupSequence( "fists_idle_01" ) )

	anim = self.AttackAnims[ math.random( 1, 2 ) ]

	timer.Simple( 0, function()
		if ( !IsValid( self ) || !IsValid( self:GetOwner() ) || !self:GetOwner():GetActiveWeapon() || self:GetOwner():GetActiveWeapon() != self ) then return end

		vm = self:GetOwner():GetViewModel()
		vm:ResetSequence( vm:LookupSequence( anim ) )
	end )

	self:GetOwner():DoAnimationEvent(ACT_GMOD_GESTURE_RANGE_FRENZY)

	self:GetOwner():EmitSound(table.Random(self.AttackSound), 60)
	self:GetOwner():EmitSound(table.Random(self.SwingSound))

	local owner = self:GetOwner()
	if IsValid(owner) and owner:IsPlayer() then
		local pos = owner:GetShootPos()
		local ang = owner:GetAimVector()

		local damageMultiplicator = math.Rand(0.9, 1.50)
		local damage = self.Primary.Damage * damageMultiplicator

		local slash = {}
		slash.start = pos
		slash.endpos = pos + (ang * 70)
		slash.filter = owner
		slash.mins = Vector(-5, -5, 0)
		slash.maxs = Vector(5, 5, 5)

		local slashtrace = util.TraceHull(slash)
		if slashtrace.Hit then
			local target = slashtrace.Entity

			if IsValid(target) then
				self:SendWeaponAnim(ACT_VM_HITCENTER)

				local dmgInfo = DamageInfo()
				dmgInfo:SetDamage(damage)
				dmgInfo:SetDamageType(DMG_SLASH)
				dmgInfo:SetAttacker(owner)
				dmgInfo:SetInflictor(self)
				dmgInfo:SetDamageForce(slashtrace.Normal * math.random(1000, 20000))

				target:TakeDamageInfo(dmgInfo)

				if target:IsPlayer() then
					target:ViewPunch(Angle(-10, -20, 0))
				end

				target:EmitSound(table.Random(self.FleshSound))
				self:EmitSound(table.Random(self.HitSound), 75)
			end
		end
	end
end
--gamemodes/starwarsrp/gamemode/config/sh_chat.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Chat | Config           --
---------------------------------------

-- Whether to allow private messages.
Chat.PMChatEnabled = true

-- Whether to allow local rp messages without commands.
Chat.RPChatEnabled = false

-- List all Command Prefixes.
Chat.CommandPrefixTable = {
    "/",
    "!",
    ".",
    "@"
}

if SERVER then
    -- Chat Types
    -- OOC Chat
    Chat.Types["ooc"] = Chat.Types["ooc"] or {}
    Chat.Types["ooc"].enabled = true

    -- Local OOC Chat
    Chat.Types["looc"] = Chat.Types["looc"] or {}
    Chat.Types["looc"].enabled = true

    -- It Chat
    Chat.Types["it"] = Chat.Types["it"] or {}
    Chat.Types["it"].enabled = true

    -- Admin Chat
    Chat.Types["admin"] = Chat.Types["admin"] or {}
    Chat.Types["admin"].enabled = true
end

-- Whether join- and leavemessages are enabled
Chat.JoinLeaveMessages = false
--gamemodes/starwarsrp/gamemode/config/sh_developer.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Developer | Config          --
---------------------------------------

-- Unbannable, Untargetable even by Developers, For more Information see Developer.DeveloperSteamID64, BE CAREFUL
Developer.OwnerSteamID64 = "76561198152415776"

-- SteamIDs that have ALL permissions on the server. Really ALL. Be careful. Untargetable. They can even send command to the server console from their clients
Developer.DeveloperSteamID64 = {
	"76561198152415776", -- P4sca1
	"76561198039545371", -- Oninoni
	"76561198068891112", -- Mattzi
}

-- Just Shows in Chat and on Scoreboard that this Person is a developer. Would be nice if you could leave us in there.
Developer.ShowDeveloperSteamID64 = {
	-- EGM:RP
	"76561198152415776", -- P4sca1
	"76561198066776771", -- Airfox
	"76561198039545371", -- Oninoni
	"76561198068891112", -- Mattzi

	-- LUA
	"76561198254979985", -- Kabasch
	"76561198151138833", -- tschubaki
	"76561198079303956", -- Voodoo

	-- Model
	"76561198316606808", -- Glänzer
	"76561199008656478", -- Nymphix
	"76561198359752268", -- Hydra
	"76561198301915741", -- Cast
	"76561198311473468", -- Linxreen
	"76561198158878288", -- Axe

	-- Mapping
	-- Keiner aktuell vorhanden
}

-- The color developers have in chat and on scoreboard.
-- Set false if color should not be overwritten.
Developer.OverrideUserGroupColor = Color(238, 58, 140)
--gamemodes/starwarsrp/gamemode/config/sh_inventory_container.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Config | Inventory Container   --
---------------------------------------

-- Time to hold E, until an inventory is opened intead of the item picked up.
InventoryContainer.SelectTime = 0.5
--gamemodes/starwarsrp/gamemode/config/sh_inventory_money.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | InventoryMoney      --
---------------------------------------

-- The delay in minutes between paychecks.
InventoryMoney.PaycheckDelay = 10

-- Minimum rank, to be able to give money to other players.
InventoryMoney.GiveMoneyRank = "moderator"

-- The ammount of money, which is assumed to generate the item icon.
InventoryMoney.PreviewCount = 1

-- Models for money when dropped depending on the amount.
InventoryMoney.Models = {
	{
		Model = "models/egm/core/credits/single_credit/single_credit.mdl",
		MaxAmount = 10,
	},
	{
		Model = "models/egm/core/credits/little_credits/little_credits.mdl",
		MinAmount = 11,
		MaxAmount = 100,
	},
	{
		Model = "models/egm/core/credits/big_credits/big_credits.mdl",
		MinAmount = 101,
		MaxAmount = 1000,
	},

	-- Box Model
	{
		Model = "models/cire992/props/hvywepcrate01.mdl",
		Skin = 2,

		MinAmount = 1001,
	},
}
--gamemodes/starwarsrp/gamemode/config/sh_signs.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Signs | Config          --
---------------------------------------

-- Fonts Used for Textscreens.
Signs.Fonts = {
	{
		Name = "Signs Default",
		Font = "Arial",
		Min = 1,
		Max = 20,
		SizeOffset = 20,
		SizeMultiplier = 4,
	},
	{
		Name = "Signs Classic",
		Font = "Impact",
		Min = 1,
		Max = 20,
		SizeOffset = 20,
		SizeMultiplier = 4,
	},
	{
		Name = "Signs Aurebesh",
		Font = "Aurebesh",
		Min = 1,
		Max = 20,
		SizeOffset = 20,
		SizeMultiplier = 2,
	},
	{
		Name = "Signs Handwritten",
		Font = "Ink Free",
		Min = 1,
		Max = 20,
		SizeOffset = 20,
		SizeMultiplier = 4,
	},
	{
		Name = "Signs Battlefront",
		Font = "ITC Avant Garde Std Bk",
		Min = 1,
		Max = 20,
		SizeOffset = 20,
		SizeMultiplier = 4,
	},
}
--gamemodes/starwarsrp/gamemode/config/sh_species.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Config | Species         --
---------------------------------------

-- Minimum group, to access editing the species of a character.
Species.MinAccessGroup = "testmoderator"

-- List of DamageTypes that species can be immune to.
-- Damage Types can be found here: https://wiki.facepunch.com/gmod/Enums/DMG
Species.DamageTypes = {
	[DMG_BURN] = "Fire",
	[DMG_POISON] = "Poison",
	[DMG_DROWN] = "Drown",
	[DMG_NERVEGAS] = "Nerve Gas",
	[DMG_RADIATION] = "Radiation",
}
--gamemodes/starwarsrp/gamemode/config/sh_unarmed.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Unarmed | Config         --
---------------------------------------

-- Prop Pickup Rotate Key.
Unarmed.RotateKey = IN_RELOAD

-- Max Distance for Pickup.
Unarmed.PickupMaxDistance = 60

-- Max Distance for Dropping.
Unarmed.DropMaxDistance = 100

-- Max Mass for Pickup.
Unarmed.PickupMaxMass = 20

-- The bone, that is used, to carry ragdoll.
Unarmed.CarryBone = "ValveBiped.Bip01_Spine4"

-- The offset, that is used, to carry ragdoll.
Unarmed.CarryOffset = Vector(5, 45, 10)
Unarmed.CarryAngle = Angle(0, 180, -90)

-- Bone Manipulation for the carried ragdoll.
Unarmed.CarryBoneMods = {
	["ValveBiped.Bip01_Spine2"] = Angle(0, 75, 0),
	["ValveBiped.Bip01_R_Thigh"] = Angle(0, -70, 0),
	["ValveBiped.Bip01_L_Thigh"] = Angle(0, -70, 0),
	["ValveBiped.Bip01_R_Foot"] = Angle(0, 50, 0),
	["ValveBiped.Bip01_L_Foot"] = Angle(0, 50, 0),
	["ValveBiped.Bip01_R_Clavicle"] = Angle(45, 45, 0),
	["ValveBiped.Bip01_L_Clavicle"] = Angle(-45, 45, 0),
	["ValveBiped.Bip01_R_UpperArm"] = Angle(90, 0, 0),
	["ValveBiped.Bip01_L_UpperArm"] = Angle(-90, 0, 0),
}

-- Set the ID of the hidden carry animation below.
Unarmed.CarryAnimation = 12

-- Blacklist of models, that cannot be carried or cannnot carry ragdolls.
Unarmed.CarryBlacklist = {
	"models/vortigaunt.mdl",
	"models/dog.mdl",
	"models/lamarr.mdl",

	"models/combine_strider.mdl",
	"models/combine_scanner.mdl",
	"models/props_combine/combine_mine01.mdl",
	"models/combine_turrets/floor_turret.mdl",
	"models/advisor.mdl",
	"models/antlion.mdl",
	"models/antlion_guard.mdl",

	"models/headcrabclassic.mdl",
	"models/zombie/classic.mdl",
	"models/zombie/classic_legs.mdl",
	"models/zombie/classic_torso.mdl",
	"models/headcrab.mdl",
	"models/gibs/fast_zombie_torso.mdl",
	"models/zombie/fast.mdl",
	"models/gibs/fast_zombie_legs.mdl",
	"models/headcrabblack.mdl",
	"models/zombie/poison.mdl",

	"models/humans/charple01.mdl",
	"models/humans/charple02.mdl",
	"models/humans/charple03.mdl",
	"models/humans/charple04.mdl",
	"models/humans/corpse1.mdl",

	"models/props_c17/furnituremattress001a.mdl",

	"models/player/swcw/std_kraken.mdl",
	"models/pm_admiral_trench.mdl",
	"models/super_tactical_kalani/pm_droid_tactical_kalani.mdl",
	"models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl",
	"models/aussisengels/grievous/general_grievous.mdl",
	"models/player/hydro/b2_battledroid/b2_battledroid.mdl",
	"models/player/swcw/std_auto.mdl",
	"models/player/swcw/std_kalani.mdl",
	"models/player/swcw/std_kraken.mdl",
	"models/loic_buzzdroid/buzzdroid.mdl",
	"models/player/t3_01.mdl",
	"models/player/t3_02.mdl",
	"models/player/t3_03.mdl",
	"models/player/t3_04.mdl",
	"models/player/jellik/starwars/highsinger.mdl",
	"models/player/tiki/med_droid.mdl",
	"models/kingpommes/starwars/playermodels/astromech.mdl",
	"models/kingpommes/starwars/playermodels/gnk.mdl",
	"models/kingpommes/starwars/playermodels/lin.mdl",
	"models/kingpommes/starwars/playermodels/mouse.mdl",
	"models/kingpommes/starwars/playermodels/wed.mdl",
	"models/ace/sw/r4.mdl",
	"models/ace/sw/r2.mdl",
	"models/ace/sw/r5.mdl",
	"models/novux/023/novux_scp-023.mdl",
	"models/novux/023/novux_scp-023_white.mdl",
	"models/player/r2d2.mdl",
}

-- List of weapons you are allowed to switch to while carrying a ragdoll.
-- These are supposed to be right handed weapons with minimal left arm movement in their animations.
Unarmed.WeaponWhitelist = {
	"weapon_pistol",
	"weapon_bugbait",
	"weapon_crowbar",
	"weapon_slam",
	"weapon_frag",
	"weapon_stunstick",

	"bkeycard",
	"bkeypads_access_logs",
	"bkeypads_cracker",

	"lightsaber_inventory",
	"weapon_egmrp_breathingswep",
	"weapon_swrp_breathingswep",

	"weapon_jtrackingdevice",
	"weapon_trackingdevice_funk",
	"weapon_trackingdevice_massif",

	"weapon_swrp_pad_funk",
	"weapon_swrp_pad",
	"weapon_swrp_pad_medic",
	"weapon_swrp_pad_fc",
	"weapon_swrp_pad_st",
	"weapon_swrp_pad_blanko",
	"weapon_swrp_pad_locker",

	"weapon_swrp_dl44",
	"weapon_swrp_dt12",
	"weapon_swrp_nn14",
	"weapon_swrp_deathwatch",
	"weapon_swrp_dc15sa",
	"weapon_swrp_dc17",
	"weapon_swrp_dc17silenced",
	"weapon_swrp_dc17_stun",
	"weapon_swrp_wrist_blaster",
	"weapon_swrp_wrist_flame",
	"weapon_swrp_wrist_rocket",
	"b2_gun",

	"weapon_detonator_hb",
	"rw_sw_nade_bacta",
	"rw_sw_nade_dioxis",
	"rw_sw_nade_emp",
	"rw_sw_nade_flash",
	"rw_sw_nade_impact",
	"rw_sw_nade_incendiary",
	"rw_sw_nade_smoke",
	"rw_sw_nade_stun",
	"rw_sw_nade_dioxis_stun",
	"rw_sw_nade_thermal",
	"rw_sw_nade_training",
	"weapon_mine_antivehicle",
	"weapon_mine_antiperson",
	"weapon_mine_incendiary",
	"weapon_mine_emp",
	"weapon_mine_training",
	"weapon_swrp_det",
	"seal6(-c4)",
	"weapon_molotov",

	"weapon_cuff_elastic_single",
	"weapon_cuff_elastic",
	"weapon_leash_rope",
	"weapon_cuff_plastic",
	"weapon_cuff_tactical",

	"weapon_swrp_scalpel",
	"weapon_swrp_medic_kit",
	"weapon_swrp_medic_faidkit",
	"weapon_swrp_medic_injector",
	"weapon_swrp_medic_injector_swt",
	"weapon_swrp_medic_jedi",
	"weapon_swrp_medic_scanner",
	"weapon_swrp_medic_opkit",
	"weapon_defibrilator",
	"weapon_swrp_medic_repairkit",
	"weapon_swrp_medic_dropdrugs",
	"weapon_swrp_corpsebag",
	"weapon_swrp_flickzeug",
	"weapon_swrp_fusioncutter",

	"weapon_swrp_hiddenbladeswt",
	"weapon_swrp_hiddenblade",
	"weapon_swrp_cloakingdevice_event",
	"weapon_swrp_cloakingdevice_swt",

	"realistic_hook",

	"weapon_lightsaber_blade",
	"weapon_lightsaber_blade_clone",
	"weapon_lightsaber_longblade",
}

-- List of weapons, when active the player will not be asked, if they want to be picked up.
Unarmed.PickupNoAskWeapons = {
	"weapon_handcuffed",
}

-- List of all animations, that can be used.
Unarmed.Animations = {
	[1] = {
		Name = "Cross Arms (Infront)",
		Bones = {
			["ValveBiped.Bip01_R_Forearm"] = Angle(-43.779933929443,-107.18412780762,15.918969154358),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(20.256689071655, -57.223915100098, -6.1269416809082),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-28.913911819458, -59.408206939697, 1.0253102779388),
			["ValveBiped.Bip01_R_Thigh"] = Angle(4.7250719070435, -6.0294013023376, -0.46876749396324),
			["ValveBiped.Bip01_L_Thigh"] = Angle(-7.6583762168884, -0.21996378898621, 0.4060270190239),
			["ValveBiped.Bip01_L_Forearm"] = Angle(51.038677215576, -120.44165039063, -18.86986541748),
			["ValveBiped.Bip01_R_Hand"] = Angle(14.424224853516, -33.406204223633, -7.2624106407166),
			["ValveBiped.Bip01_L_Hand"] = Angle(25.959447860718, 31.564517974854, -14.979378700256),
		},
	},
	[2] = {
		Name = "Cross Arms (Back)",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(3.809, 15.382, 2.654),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-63.658, 1.8 , -84.928),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(3.809, 15.382, 2.654),
			["ValveBiped.Bip01_L_Forearm"] = Angle(53.658, -29.718, 31.455),

			["ValveBiped.Bip01_R_Thigh"] = Angle(4.829, 0, 0),
			["ValveBiped.Bip01_L_Thigh"] = Angle(-8.89, 0, 0),
		},
	},
	[3] = {
		Name = "Comlink",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(32.9448, -103.5211, 2.2273),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-90.3271, -31.3616, -41.8804),
			["ValveBiped.Bip01_R_Hand"] = Angle(0,0,-24),
		},
	},
	[4] = {
		Name = "Holo",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(10,-20),
			["ValveBiped.Bip01_R_Hand"] = Angle(0,1,50),
			["ValveBiped.Bip01_Head1"] = Angle(0,-30,-20),
			["ValveBiped.Bip01_R_Forearm"] = Angle(0,-65,39.8863),
		}
	},
	[5] = {
		Name = "Salute",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(80, -95, -77.5),
			["ValveBiped.Bip01_R_Forearm"] = Angle(35, -125, -5),
		},
	},
	[6] = {
		Name = "Surrender",
		AccessInventory = true, -- Inventory System Integration. When surrendering, a different player can access your inventory.
		Bones = {
			["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-25,-65,-25),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(70,-180,-70),
		},
		MaxSpeed = 150,
	},
	[7] = {
		Name = "Surrender (Down)",
		AccessInventory = true, -- Inventory System Integration. When surrendering, a different player can access your inventory.
		Bones = {
			["ValveBiped.Bip01_R_Calf"] = Angle(0, 120, 0),
			["ValveBiped.Bip01_L_Calf"] = Angle(0, 120, 0),
			["ValveBiped.Bip01_R_Thigh"] = Angle(0, -30, 0),
			["ValveBiped.Bip01_L_Thigh"] = Angle(0, -30, 0),
			["ValveBiped.Bip01_R_Foot"] = Angle(0, 30, 0),
			["ValveBiped.Bip01_L_Foot"] = Angle(0, 30, 0),
			["ValveBiped.Bip01_Pelvis"] = Vector(0, 0, -23),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(30, 0, 90),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-30, 0, -90),
			["ValveBiped.Bip01_R_ForeArm"] = Angle(0, -130, 0 ),
			["ValveBiped.Bip01_L_ForeArm"] = Angle(0, -120, 20 )
		}
	},
	[8] = {
		Name = "Raise Arm",
		Bones = {
			["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
		},
	},
	[9] = {
		Name = "Point",
		Bones = {
			["ValveBiped.Bip01_R_Finger2"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger21"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_Finger3"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger31"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_Finger4"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger41"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(25.019514083862, -87.288040161133, -0.0012286090059206),
		},
	},
	[10] = {
		Name = "Attention",
		Bones = {
			["ValveBiped.Bip01_Head1"] = Angle(0, 10, 0),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-6, -6, 0),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-9, 0, 0),
			["ValveBiped.Bip01_L_Forearm"] = Angle(9, 0, 0),
			["ValveBiped.Bip01_R_Thigh"] = Angle(-3, 0, 0),
			["ValveBiped.Bip01_L_Thigh"] = Angle(3, 5, 0),
			["ValveBiped.Bip01_R_Foot"] = Angle(20, 0, 0),
			["ValveBiped.Bip01_L_Foot"] = Angle(-20, 0, 0),
			["ValveBiped.Bip01_R_Hand"] = Angle(0, 0, 20),
			["ValveBiped.Bip01_L_Hand"] = Angle(0, 0, -20),
		}
	},
	[11] = {
		Name = "Ready Arms",
		Bones = {
			["ValveBiped.Bip01_L_Forearm"] = Angle(50,-90,5),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-50,-90,5),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-40,30,-20),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(40,30,20),
		}
	},
	[12] = {
		Name = "Carry Person",
		Hide = true,
		Bones = {
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70, 20, -20),
			["ValveBiped.Bip01_L_Forearm"] = Angle(-55, -90, -90),
			["ValveBiped.Bip01_L_Hand"] = Angle(0, -45, 45),
		},
	}
}
--addons/wos-passiveevent/lua/wos/pes/vgui/wos_viewnodes.lua:
local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")

local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)

local bgWhite = Color(200,200,200)

function PANEL:AddNode( id, input_data )
	self.EventID = id
	local id = #self.Nodes + 1
	local x,y = self:GetCenter()
	
    local dbutton = vgui.Create("DButton", self._background)
    dbutton.main = self

	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8

    dbutton:SetPos(x-50, y-50)
	dbutton:SetSize( wide, tall )
    dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )


	-- dbutton.Links = input_data.Links
	-- dbutton.Active = input_data.Active
	-- dbutton.Type = input_data.Type

	-- dbutton:SetPos( input_data.Pos.x, input_data.Pos.y )
	-- dbutton:SetText( "" )
	-- dbutton.TextName = input_data.Name


	dbutton.DoClick = function()
		local isActive = dbutton.Active
		if not isActive then return end
		if IsValid(nodeWatchingMenu) then
			nodeWatchingMenu:Remove()
		end

        local dummy_frame = vgui.Create( "DFrame" )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:ShowCloseButton( false )
        dummy_frame:SetDraggable( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
        end
        dummy_frame:MakePopup()

		nodeWatchingMenu = vgui.Create("DFrame")
		nodeWatchingMenu:MakePopup()
		nodeWatchingMenu:SetSize(ScrW() * 0.25, ScrH() *0.25)
		nodeWatchingMenu:Center()

		nodeWatchingMenu.Think = function()
			nodeWatchingMenu:MoveToFront()
			if !IsValid(self) or not self:GetParent():IsVisible() then 
				nodeWatchingMenu:Remove()
			end
		end

        dummy_frame.Think = function( pan ) 
            if not IsValid( nodeWatchingMenu ) then
                pan:Remove()
            end
        end

		local scroll = vgui.Create("DScrollPanel", nodeWatchingMenu)
		local bw,bh = nodeWatchingMenu:GetSize()

		scroll:SetSize(bw, bh * 0.5)
		scroll:Dock(TOP)

		local button = vgui.Create("DButton", scroll)
		button:SetText("")
		button:Dock(TOP)
		button.Paint = function(self, w, h)
			local a, b = draw.SimpleText("ACTIVATE TRIGGERS", "wOS.PES.NodeText", 5, h/2, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			if a != w and b != h then
				button:SetSize(a, b)
			end
			surface.SetDrawColor(255,255,255)
			surface.DrawLine(5, h-1, w*0.75, h-1)
		end
		
		local bg = vgui.Create("DPanel", scroll)
		bg:Dock(TOP)

		button.DoClick = function()
			if bg:GetTall() == 0 then
				bg:SizeToChildren()
			else
				bg:SetTall(0)
			end
		end

		local noTriggers = true

		if dbutton.Type then
			local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
			-- if chec
			local maxTriggers = #nodeData.Triggers
		
			for index, tdata in ipairs(nodeData.Triggers) do
				
				local trigger = tdata
				local trigger_name = trigger
				if istable( tdata ) then
					trigger = tdata.Type or trigger
					trigger_name = tdata.Name or trigger_name
				end

				local but = vgui.Create("DButton", bg)
				but:SetText( trigger_name )
				but:Dock(TOP)
				but.DoClick = function()
					wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
					nodeWatchingMenu:Remove()
				end
				noTriggers = false
			end
		end

		if noTriggers then
			local but = vgui.Create("DButton", bg)
			but:SetText("Instant")
			but:Dock(TOP)
			but.DoClick = function()
				wOS.PES.RequestTriggerStart(self.EventID, id, "Instant")
			end
		end

		bg:SizeToChildren()
		bg:SetTall(100)
	end

	dbutton.Links = {}

	local VGUI_NodeMeta = vgui.GetControlTable( "WOS_PES_NODE" )
	dbutton.EventViewerNode = true
	dbutton.TriggerColorHierarchy = VGUI_NodeMeta.TriggerColorHierarchy
	dbutton.GetTriggerPos = VGUI_NodeMeta.GetTriggerPos
	dbutton.Paint = VGUI_NodeMeta.Paint
	dbutton.FormLinks = self.FormLinks
	dbutton.DrawTriangleRight = VGUI_NodeMeta.DrawTriangleRight

	-- function dbutton:GetTriggerPos(triggerName)
	-- 	if self.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(self.Type)
	-- 		-- if check
	-- 		local maxTriggers = #nodeData.Triggers
	-- 		for index, trigger in ipairs(nodeData.Triggers) do
	-- 			if trigger == triggerName then
	-- 				return 50 + 16 *(index - (maxTriggers +1)/2)
	-- 			end
	-- 		end

	-- 		return false
	-- 	end

    -- 	return self:GetTall() * 0.5
	-- end

	-- function dbutton:Paint(w, h)
	-- 	if dbutton.Active then
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 255, 0, 255))	    
	-- 	else
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
	-- 	end
	--     draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))
	-- end

    self.Nodes[id] = dbutton

	return dbutton
end

function PANEL:Init()
    self.CreationType = WOS_PES.CREATOR.EVENT
	self._x = 0
	self.Nodes = {}
	self._y = 0

    self._tx = 0
    self._ty = 0

    self.Links = {}
	
	self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    self._background.Paint = function(sef, w, h)

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w,h)

        for id, pnl in pairs(self.Nodes) do
		    if !IsValid(pnl) then
                return
			end

            for triggerName, panelTable in pairs(pnl.Links) do
                for index, oid in ipairs(panelTable) do
                    local oPnl = self.Nodes[oid]
                    if !IsValid(oPnl) then
                        continue
                    end

					if not oPnl.MakeOtherLink then
						self:MakeOtherLink(triggerName, oPnl)
						oPnl.MakeOtherLink = true
					end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end
    end

    self._background.OnDepressed = function( s )
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end
end

function PANEL:StopDragging()
    self.Dragging = false
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = gui.MousePos()

    self.mousepos = {x = x, y = y}
end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

local speed = 100

function PANEL:Think()
    if not self.Dragging then return end
	
	local x,y = gui.MousePos()
	if !self.mousepos then
		self.mousepos = {x = x, y = y}
	end
	local dX = x - self.mousepos.x
	local dY = y - self.mousepos.y

	local oldMouseY = self.mousepos.y
	self.mousepos = {x = x, y = y}

	self._tx = dX + self._x
	self._ty = dY + self._y
	local posChanged = false

	if self.tx != self._x then
		posChanged = true
		self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
	end

	if self.ty != self._y then
		local x,y = self._background:GetPos()

		posChanged = true
		self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
	end

	if posChanged then
		local aX = self:GetWide()/2 -self._background:GetWide()/2
		local aY = self:GetTall()/2 -self._background:GetTall()/2
		local x,y = self._background:GetPos()

		self._background:SetPos( aX+self._x,  aY + self._y)
	end

end

function PANEL:MakeOtherLink(name, oNode)
	local link = vgui.Create("DPanel", oNode)
	link:SetSize( oNode:GetWide()*0.08, oNode:GetWide()*0.08 )
	link:SetPos( link:GetWide()*-0.5, oNode:GetTall()*0.5 - link:GetTall()*0.5 )
	link:SetText( "" )
	link.Name = name or "Output"
	link.TriggerColor = Color( 255, 255, 255 )
	
	link.Paint = function(s, w, h)
		local wasEnabled = DisableClipping( true )            
		local col = s.TriggerColor
		if s.Hovered then col = Color(150,150,150) end
		draw.RoundedBox( h*0.3, 0, 0, w, h, col )
		DisableClipping( wasEnabled )
	end
end

function PANEL:FormLinks()

    local function makeLink( name, trigger_label, trigger_description )
        local link = vgui.Create("DPanel", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )

        link.NLabel = trigger_label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip(name)
        link.Paint = function(s, w, h)
            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )
        end
    end

	-- for triggerName, panelTable in pairs(pnl.Links) do
	-- 	for index, oid in ipairs(panelTable) do
	-- 		local oPnl = self.Nodes[oid]
	-- 		if !IsValid(oPnl) then
	-- 			continue
	-- 		end

	-- 		local x,y = pnl:GetPos()
	-- 		local w,h = oPnl:GetPos()
	-- 		local posY, id, col = pnl:GetTriggerPos(triggerName)

	-- 		if !posY then
	-- 			self:RemoveLink(pnl, triggerName, oPnl)
	-- 			continue
	-- 		end

	-- 		h = h + oPnl:GetTall()*0.5
	-- 		y = y + posY

	-- 		x = x + pnl:GetWide() + pnl:GetWide()*0.04
	-- 		col = col or color_white

	-- 		surface.SetDrawColor( col )
	-- 		surface.DrawLine( x, y, w, h )
	-- 	end
	-- end

	-- 	if dbutton.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
	-- 		-- if chec
	-- 		local maxTriggers = #nodeData.Triggers
		
	-- 		for index, tdata in ipairs(nodeData.Triggers) do
				
	-- 			local trigger = tdata
	-- 			local trigger_name = trigger
	-- 			if istable( tdata ) then
	-- 				trigger = tdata.Type or trigger
	-- 				trigger_name = tdata.Name or trigger_name
	-- 			end

	-- 			local but = vgui.Create("DButton", bg)
	-- 			but:SetText( trigger_name )
	-- 			but:Dock(TOP)
	-- 			but.DoClick = function()
	-- 				wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
	-- 				nodeWatchingMenu:Remove()
	-- 			end
	-- 			noTriggers = false
	-- 		end
	-- 	end

    local nodeLinks = self.Links

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end
                makeLink(name, trigger_label, trigger_description )
            end
            return
        end
    end

    makeLink("Instant")
end

vgui.Register( "WOS_PES_ViewNodeBG", PANEL, "Panel" )
--addons/wos-passiveevent/lua/wos/pes/addons/display/cl_entsdisplay.lua:


hook.Add("HUDPaint", "wOS.PES.DrwaInteractableNames", function()

	local tr = util.TraceLine({
		start = LocalPlayer():EyePos(),
		endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 100,
		filter = LocalPlayer(),
		mask = MASK_SHOT
	})

	if !tr.Hit or !IsValid(tr.Entity)  then return end

	local ent = tr.Entity

	// Need to figure out how to tell if this ent has come from the same event that the player is in
	// we could use event ids, with nw ints but that can cause issues with nw lag 

	if !ent:GetNWString("PES.DisplayMessage") then return end

	local pos = ent:GetPos() + ent:OBBCenter()

	local text = ent:GetNWString("PES.DisplayMessage")
	local pos = pos:ToScreen()
	local x, y = pos.x, pos.y

	draw.DrawText(text, "wOS.PES.CapturePoint", x, y, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
end)

// should an addon be registered?

--addons/wos-passiveevent/lua/wos/pes/addons/snooze-randomevents/cl_core.lua:

local addon = {}

surface.CreateFont( "wOS.PES.SnoozeText", {
	font = "Arial",
	extended = false,
	size = ScreenScale(8),
	weight = 1300,
} )


net.Receive("wOS.PES.SnoozeEvent", function(len)
	local name = net.ReadString()
	local time = net.ReadFloat() + CurTime()
	local id = net.ReadFloat()

	addon.OpenSnoozeMenu( name, time, id )

end)

addon.OpenSnoozeMenu = function( name, time, id )
	local w, h = ScrW(), ScrH()
	local txtConfig = (wOS.PES.Config and wOS.PES.Config.SnoozeText)

	if !txtConfig then
		ErrorNoHalt("Looks like your PES Config is broken wOS.PES.Config.SnoozeText was not found")
		return
	end

	if istable(txtConfig) then
		txtConfig = txtConfig[math.random(#txtConfig)]
	end

	txtConfig = string.Replace(txtConfig, "[[name]]", name)

	local bool = hook.Call("wOS.PES.SnoozeButton", nil, name, time, id) -- Something else overrides are render

	if bool then return end

	local dframe = vgui.Create("DFrame")

	local size = 0.27*h

	dframe:SetSize(size, size)
	dframe:SetPos(0, h*0.5 - size*0.5 )
	dframe:MakePopup()
	dframe:ShowCloseButton(false)
	dframe:SetDraggable(false)
	dframe:SetTitle("")
	dframe.Paint = function(self, ww, hh)
		if time < CurTime() then self:Remove() return end

		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0, 0, ww, hh)

		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect(0, 0, ww, hh)

		local word = wOS.PES.WrapText( string.Replace(txtConfig, "[[time]]", string.FormattedTime(time - CurTime(), "%02i:%02i:%02i") ), "wOS.PES.SnoozeText", ww*0.94 )

		draw.DrawText( word, "wOS.PES.SnoozeText", ww*0.02, ww*0.02, color_white, TEXT_ALIGN_LEFT ) 
	end

	local yes = vgui.Create("DButton", dframe)
	yes:SetPos(size*0.2, size*0.92)
	yes:SetSize(size*0.3, size*0.08)
	yes:SetText("Yes")
	yes.DoClick = function()
		dframe:Remove()
		net.Start("wOS.PES.SnoozeEvent")
			net.WriteFloat(id)
		net.SendToServer()
	end

	local no = vgui.Create("DButton", dframe)
	no:SetPos(size*0.5, size*0.92)
	no:SetSize(size*0.3, size*0.08)
	no:SetText("No")
	no.DoClick = function()
		dframe:Remove()
	end
end

function TESTTHISDRIVE( name, time, id )
	addon.OpenSnoozeMenu( name, time, id )
end
--addons/wos-passiveevent/lua/wos/pes/vars/boolean.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Boolean"

VAR.IsValid = function(varTable, value)
    if not isbool(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local button = vgui.Create("DButton")
    button.Pressed = value

    local activeText = varTable.ActiveText or "Yes"
    local inactiveText = varTable.InactiveText or "No"

    button:SetText(button.Pressed and activeText or inactiveText)
    button.DoClick = function(pan)
        button.Pressed = not button.Pressed
        pan:SetText(button.Pressed and activeText or inactiveText)
    end

    return button
end

VAR.GetValue = function(button)
    return button.Pressed
end


return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/tentity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntity"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then
                value[index] = {
                    mapID = data.Index,
                }
            else
                value[index] = wOS.PES.ReadEntity(ent)
            end
        end
    end

    return true
end

VAR.UseTool = true

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local element = vgui.Create("DModelPanel")
    
    element.Data = {}
    for index, data in pairs( varData ) do
        if data.mapID then
            local ent = ents.GetByIndex( data.mapID )
            element.Data[ index ] =  {
                Position =  ent:GetPos(),
                Index = data.mapID,
            }
            continue
        end
        element.Data[ index ] = data
    end

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

VAR.OnStart = function(node, varData, var)
    local tEnts = {}
    for index, entData in ipairs(varData || {}) do
        local ent
        if entData.mapID then
            ent = ents.GetByIndex(entData.mapID)
        else
            ent = wOS.PES:SpawnEntity(entData)
        end

        if not ent then continue end 

        if not istable( ent ) then
            tEnts[#tEnts + 1] = ent
            continue
        end

        -- for _, entity in pairs( ent ) do
        --     if not IsValid( entity ) then continue end
        --     tEnts[#tEnts + 1] = entity
        -- end

    end
    
    node:SetVar(var.Name, tEnts)

    return #tEnts != 0

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    for index, ent in ipairs(varData || {}) do
        if IsValid(ent) and !ent:CreatedByMap() then
            ent:SetSaveValue( "m_bFadingOut", true )
            ent:Remove()
        end
    end
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/vector.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Vector"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Save the position you are AIMING AT", key = "gui/lmb.png", },
    { text = "Save your current EYE position", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Save your current STANDING position", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
}

VAR.IsValid = function(varTable, value)
    if not isvector(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isvector(self.Value) then
            draw.SimpleText("Vector set at: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Vector needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Value
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Value = pos
end

VAR.OnStart = function(node, value, var)
    if !isvector(value) then

        local vec = Vector(value)
        if vec then
            node:SetVar(var.Name, vec)
        end
    end
end

VAR.Draw3D = function(wep, ply, element)
    local vec = element.Value
    if not isvector(vec) then return end

    local top = Vector(vec.x, vec.y, vec.z + 200)
    render.DrawLine(vec, top, Color(255, 255, 255), false)
end


return VAR

--addons/wos-passiveevent/lua/wos/pes/core/cl_admin_menu.lua:

// This is the admin config in game editor
function wOS.PES:OpenAdminSettings()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = ScrH()*(512/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
	end

	local txtentry = vgui.Create("DTextEntry", pnl)
	txtentry:Dock(TOP)
	txtentry:DockMargin(10, 5, 10, 0)

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)
	scroll:DockMargin(5,5,5,5)

	local savebutton = vgui.Create("DButton", pnl)
	savebutton:Dock(BOTTOM)
	savebutton:SetText("Save Settings")
	savebutton:DockMargin(5,5,5,5)

	local varDerma = {}

	savebutton.DoClick = function()
		local changes = {}

		for name, data in pairs(wOS.PES.Settings.GetList()) do
			local varType = wOS.PES.Vars:Get(data.Type)
			if not varType then continue end
			local oldValue = wOS.PES.Settings.Get(name)
			local element = varDerma[name]
			local value = varType.GetValue(element)
			if value == oldValue then continue end
			changes[name] = value
		end

		local maxAmount = table.Count(changes)
		if maxAmount == 0 then
			ErrorNoHalt("Something went wrong no changes found, are you sure you changed something?")
		end
		
		net.Start("wOS.PES.RequestSettings")
			net.WriteUInt(table.Count(changes), 8)
			-- record the changes in a table

			for name, value in pairs(changes) do
				net.WriteString(name)
				net.WriteType(value) // might want to be changed to Table?
			end
		net.SendToServer()
	end

	for name, data in pairs(wOS.PES.Settings.GetList()) do
		local dbutton = vgui.Create("DButton", scroll)
		dbutton:Dock(TOP)
		dbutton:SetText(name)

		local varType = wOS.PES.Vars:Get(data.Type)
		local value = wOS.PES.Settings.Get(name)

		local element = varType.DermaElement(data, value)

        local back = vgui.Create("DPanel", scroll)

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

		varDerma[name] = element

		back:Dock(TOP)
		back:DockMargin(0, 0,0,30)

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Sadly we don't support this yet")
            useTool.DoClick = function() end
        end

		dbutton.DoClick = function()
			if back:GetTall() <= 0 then
				back:SetTall(back._OldSize)
			else
				back._OldSize = back:GetTall()
				back:SetTall(0)
			end
		end
	end

	return pnl
end

// Scheduled event manager
function wOS.PES:OpenScheduledMenu()
	local cur_pan = self:GetActiveMenu()
	if IsValid(cur_pan) then
		cur_pan:Remove()
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetTitle( "PES Admin Menu" )
	local size = 512*(ScrH()/1080)
	pnl:SetSize(size, size)
	pnl:Center()
	pnl:MakePopup()
    pnl:SetDraggable(false)
	pnl.Paint = function(self, w , h)
		surface.SetDrawColor(0,0,0)
		surface.DrawRect(0,0, w, h)
		
		if not self.Loaded then
			draw.SimpleText("Loading Data ...", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			return
		end
		if not self.NoData then return end
		draw.SimpleText("No events scheduled", "DermaDefault", w/2, h/2,  color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	wOS.PES.RequestSchedule(function(eventList)
		pnl.Selected = nil
		pnl.EventList = eventList
		if IsValid(pnl.Scroll) then
			pnl.Scroll:Remove()
		else
			if IsValid( pnl.selectButton ) then
				pnl.selectButton:Remove()
			end
			local selectButton = vgui.Create("DButton", pnl)
			selectButton:Dock(BOTTOM)
			selectButton:SetText("Remove Event")

			selectButton.DoClick = function()
				if not pnl.Selected then return end
				local id = pnl.Selected
				if not pnl.EventList then return end
				if not pnl.EventList[id] then return end
				net.Start("wOS.PES.RequestScheduleDelete")
					net.WriteString(pnl.EventList[id].Name)
					net.WriteDouble(pnl.EventList[id].Time)
				net.SendToServer()
			end
			pnl.selectButton = selectButton
		end

		pnl.Loaded = true
		if table.Count(pnl.EventList) == 0 then
			pnl.NoData = true
		else
			local scroll = vgui.Create("DScrollPanel", pnl)
			scroll:Dock(FILL)
			scroll:DockMargin(5,5,5,5)

			for index, data in SortedPairsByMemberValue(pnl.EventList, "Time", true) do
				local dbutton = vgui.Create("DButton", scroll)
				dbutton:Dock(TOP)
				dbutton:SetText(data.Name .. "    " .. data.Map .. "   " .. os.date( "%H:%M:%S - %d/%m/%Y" , data.Time ))
				dbutton.ID = index
				dbutton.DoClick = function( pan )
					pnl.Selected = pan.ID
				end
				dbutton.Paint = function(pan, w, h)
					if pnl.Selected != pan.ID then
						surface.SetDrawColor(255,255,255)
					else
						surface.SetDrawColor(200,200,200)
					end
					surface.DrawRect(0,0, w, h)
				end
			end
			pnl.Scroll = scroll
		end
	end)

	return pnl
end
--addons/wos-passiveevent/lua/wos/css/vgui/wos_css_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.SIMULATION

PANEL.BaseSettings = {
    ["Time Limit"] =  {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 60,
    },
    ["Maximum Players"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 1,
        Default = 4,
    },
    ["Prevent Damage from Outside"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Enable Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = false,
    },
    ["Player Lives"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
    ["Share Lives"] = {
        Type = WOS_CSS.CONFIG.BOOL,
        Default = true,
    },
    ["Respawn Time"] = {
        Type = WOS_CSS.CONFIG.NUMBER,
        MinCount = 0,
        Default = 0,
    },
}

PANEL.GameSettings = {
    ["Time Limit"] = 60,
    ["Maximum Players"] = 4,
    ["Prevent Damage from Outside"] = true,
    ["Enable Lives"] = false,
    ["Player Lives"] = 0,
    ["Share Lives"] = true,
    ["Respawn Time"] = 0
}

function PANEL:Init()

end

function PANEL:CreateStartNode()
    local start = self:AddNode("Player Spawn", true)
    start.Type = "Simulation Player Spawn"
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )
    start:RecalculateDirty()

    start.DeleteButton:Remove()
    return start
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan ) 
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Simulation Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 90)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave simulation name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.Settings = self:GetGameSettings()
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkSimulation(event_tbl)
        wOS.PES:GetActiveMenu():Remove()
        wOS.CombatSim:OpenToolMenu()
    end

    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)            
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:AddToolBox( tools )
    local gsetting = vgui.Create("DButton", tools)
    gsetting:SetSize(60, 60)
    gsetting:Dock(BOTTOM)
    gsetting:DockMargin(6,5,6,5)
    gsetting:SetText("Game\nSettings")
	gsetting.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    gsetting.DoClick = function( pan )
        local frame = wOS.CombatSim:OpenToolSettingsMenu( self:GetBaseSettings(), self:GetGameSettings() )

        local dummy_frame = vgui.Create( "DFrame", self )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:SetDraggable( false )
        dummy_frame:ShowCloseButton( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
            if not IsValid( frame ) then pan:Remove() return end
            frame:MoveToFront()
        end
        dummy_frame:MakePopup()
        frame:SetParent( dummy_frame )
    end
end

function PANEL:SetDefaultSettings()

end

function PANEL:SetupTool()
   net.Start( "wOS.CSS.ToolEditVar" )
   net.SendToServer()
end

function PANEL:GetBaseSettings()
    return self.BaseSettings
end

function PANEL:SaveGameSettings( settings )
    self.GameSettings = settings
end

function PANEL:GetGameSettings()
    return self.GameSettings or {}
end

vgui.Register( "WOS_CSS_NodeBG", PANEL, "WOS_PES_NodeBG" )
--addons/wos-passiveevent/lua/wos/css/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()

surface.CreateFont( "wOS.CombatSim.MainFont", {
	font = "Bebas Neue",
	extended = false,
	size = 40*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MainFontB", {
	font = "Bebas Neue",
	extended = false,
	size = 44*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.LeaderFont", {
	font = "Bebas Neue",
	extended = false,
	size = 36*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.MediumFont", {
	font = "Bebas Neue",
	extended = false,
	size = 32*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.SmallFont", {
	font = "Bebas Neue",
	extended = false,
	size = 30*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.CombatSim.DescFont", {
	font = "Bebas Neue",
	extended = false,
	size = 24*(h/1200),
	weight = 400,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:AddExitButton(backFunction)
	if not self.SimulatorMenu then return end
	
	local exitbutt = vgui.Create( "DButton", self.SimulatorMenu )
	exitbutt:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
	exitbutt:SetPos(  self.SimulatorMenu.SizeT.w * 0.92, h * 0.0125 )
	exitbutt:SetText( "" )
	exitbutt.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText("X", "wOS.CombatSim.MainFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end
	exitbutt.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()
	end
	
	if isfunction(backFunction) then
		local backButton = vgui.Create( "DButton", self.SimulatorMenu )
		backButton:SetSize( self.SimulatorMenu.SizeT.h * 0.08, h * 0.03 )
		backButton:SetPos(  self.SimulatorMenu.SizeT.w * 0.025 + w * 0.0125, h * 0.0125 )
		backButton:SetText( "" )
		backButton.Paint = function( pan, ww, hh )
			if pan:IsHovered() then
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText("<", "wOS.CombatSim.MainFontB", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
		backButton.DoClick = function( pan )
			if isfunction(backFunction) then
				backFunction()
			end
		end
	end
end

function wOS.CombatSim:OpenMenu(simulator)
	if IsValid(self.SimulatorMenu) then
		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		return
	end

	self.SelectedSimulator = simulator
	
	gui.EnableScreenClicker( true )
	
	self.SimulatorMenu = vgui.Create( "DFrame" )
	self.SimulatorMenu:SetSize( 0, 0 )
	self.SimulatorMenu:SetTitle( "" )
	self.SimulatorMenu:SetDraggable( false )
	self.SimulatorMenu:ShowCloseButton( false )
	self.SimulatorMenu:Center()
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.LastSize = { w = w*0.66, h = 0 }
	self.SimulatorMenu.Title = ""
	self.SimulatorMenu.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.FrameColor )
		surface.DrawPoly( background )
		DrawBlur( pan, 2 )
		
		draw.SimpleText( pan.Title, "wOS.CombatSim.MainFont", ww/2, h*0.04, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		surface.SetDrawColor( color_white )
		surface.DrawLine( ww*0.05, h*0.045, ww*0.95, h*0.045 )
	end
	self.SimulatorMenu.Think = function( pan )
		pan.LastSize.h = ( pan.LastSize.h == pan.SizeT.h and pan.LastSize.h ) or Lerp( FrameTime()*16, pan.LastSize.h, pan.SizeT.h )
		pan.LastSize.w = ( pan.LastSize.w == pan.SizeT.w and pan.LastSize.w ) or Lerp( FrameTime()*16, pan.LastSize.w, pan.SizeT.w )
		pan:SetSize( pan.LastSize.w, pan.LastSize.h )
		pan:Center()
	end
	self.SimulatorMenu.Clear = function( pan )
		local children = pan:GetChildren()
		for i=5, #children do
			children[i]:Remove()
		end
	end
	self.SimulatorMenu.ToggleClose = function( pan )
		pan:Clear()
		pan:SetKeyboardInputEnabled(false)
		pan:SetMouseInputEnabled(false)

		self.SimulatorMenu = nil

		gui.EnableScreenClicker( false )

		pan.SizeT.h = 8
		timer.Simple( 0.15, function()
			if not IsValid( pan ) then return end

			pan.SizeT.w = 0
			timer.Simple(0.15, function()
				if not IsValid( pan ) then return end
				pan:Remove()
			end)
		end )

		timer.Remove("WOS.CSS.LobbyTimer")
	end

	self.SimulatorMenu:MakePopup()
	
	self:AddExitButton()
end

function wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.88 }
	self.SimulatorMenu.Title = "SIMULATOR: " .. simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerFrameCurrent.XScroll = false
	self.InnerFrameCurrent:SetSize( rw*0.48, rh*0.9 )
	self.InnerFrameCurrent:SetPos( rw*0.01, rh*0.075 )
	self.InnerFrameCurrent:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerFrameCurrent:SetPanelSpacing(rw * 0.01)
	self.InnerFrameCurrent.ChallengeName = ""
	self.InnerFrameCurrent.GameType = ""
	self.InnerFrameCurrent.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}

		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Current Game: " .. pan.ChallengeName, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(pan.GameType, "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.05, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
	
	self.InnerframeQueue = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	self.InnerframeQueue.XScroll = false
	self.InnerframeQueue:SetSize( rw*0.48, rh*0.8 )
	self.InnerframeQueue:SetPos( rw*0.51, rh*0.135 )
	self.InnerframeQueue:SetPanelSize(rw * 0.46, rh * 0.06)
	self.InnerframeQueue:SetPanelSpacing(rw * 0.01)
	self.InnerframeQueue.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
		
		draw.SimpleText("Queue", "wOS.CombatSim.LeaderFont", ww*0.5, hh*0.01, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	self.CreatePartyButton = vgui.Create("DButton", self.SimulatorMenu)
	self.CreatePartyButton:SetSize( rw*0.15, rh*0.05 )
	self.CreatePartyButton:SetPos( rw*0.8, rh*0.065 )
	self.CreatePartyButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.CreatePartyButton:SetText( "Create Party" )

	self.CreatePartyButton.DoClick = function(pan)
		local challengeName = self.ChallengeSelector:GetValue()
		if isstring(challengeName) and challengeName ~= "" then
			if challengeName == "Select Challenge" then
				surface.PlaySound( "buttons/lightswitch2.wav" )
				notification.AddLegacy( "[wOS-CSS] You must select a challenge first!", NOTIFY_ERROR, 3 )
				return
			end

			net.Start("wOS.CombatSim.QueueParty")
				net.WriteEntity(simulator)
				net.WriteString(challengeName)
				net.WriteBool((self.OpenSelector:GetValue() or "") == "Open")
			net.SendToServer()

			self.SimulatorMenu.Clicked = true
			self.SimulatorMenu:ToggleClose()
		end
	end

	self.LeaveQueueButton = vgui.Create("DButton", self.SimulatorMenu)
	self.LeaveQueueButton:SetSize( rw*0.15, rh*0.05 )
	self.LeaveQueueButton:SetPos( rw*0.55, rh*0.065 )
	self.LeaveQueueButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.LeaveQueueButton:SetText( "Leave Party" )
	self.LeaveQueueButton:SetVisible(false)
	self.LeaveQueueButton.DoClick = function(pan)
		if pan.PartyLeader then
			net.Start("wOS.CombatSim.DequeueParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		else
			net.Start("wOS.CombatSim.LeaveParty")
				net.WriteEntity(simulator)
				net.WriteInt(pan.PartyId, 32)
			net.SendToServer()
		end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
	
	self.StartGameButton = vgui.Create("DButton", self.SimulatorMenu)
	self.StartGameButton:SetSize( rw*0.15, rh*0.05 )
	self.StartGameButton:SetPos( rw*0.8, rh*0.065 )
	self.StartGameButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.StartGameButton:SetText( "Start Game" )
	self.StartGameButton:SetVisible(false)
	self.StartGameButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.StartGame")
			net.WriteEntity(simulator)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end

	self.OpenSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.OpenSelector:SetSize( rw*0.1, rh*0.05 )
	self.OpenSelector:SetPos( rw*0.7, rh*0.065 )
	self.OpenSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.OpenSelector:SetValue( "Open" )
	self.OpenSelector:AddChoice("Open")
	self.OpenSelector:AddChoice("Invite")

	self.ChallengeSelector = vgui.Create("DComboBox", self.SimulatorMenu)
	self.ChallengeSelector:SetSize( rw*0.15, rh*0.05 )
	self.ChallengeSelector:SetPos( rw*0.55, rh*0.065 )
	self.ChallengeSelector:SetFont( "wOS.CombatSim.SmallFont" )
	self.ChallengeSelector:SetValue( "Select Challenge" )

	self.RefreshButton = vgui.Create("DButton", self.SimulatorMenu)
	self.RefreshButton:SetSize( rw*0.15, rh*0.03 )
	self.RefreshButton:SetPos( rw*0.675, rh*0.95 ) -- TODO
	self.RefreshButton:SetFont( "wOS.CombatSim.MediumFont" )
	self.RefreshButton:SetText( "Refresh" )
	self.RefreshButton.DoClick = function(pan)
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end

	for name, _ in pairs(challenges) do
		self.ChallengeSelector:AddChoice(name)
	end

	net.Start("wOS.CombatSim.GetGameInfo")
		net.WriteEntity(simulator)
	net.SendToServer()

	timer.Create("WOS.CSS.LobbyTimer", 10, 0,function()
		net.Start("wOS.CombatSim.GetGameInfo")
			net.WriteEntity(simulator)
		net.SendToServer()
	end)
end

function wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerframeQueue:Clear()

	for partyId, partyData in pairs(partyQueue) do
		if table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then
			if partyId == 1 and partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				self.StartGameButton:SetVisible(true)
				self.LeaveQueueButton.PartyLeader = true
				self.LeaveQueueButton:SetText("Close Party")
				
				self.OpenSelector:SetText(partyData.Open and "Open" or "Invite")
				self.OpenSelector.OnSelect = function(pan, i, text, data)
					net.Start("wOS.CombatSim.ChangePartyOpen")
						net.WriteEntity(simulator)
						net.WriteInt(partyId, 32)
						net.WriteBool(text == "Open")
					net.SendToServer()
					
					self.SimulatorMenu.Clicked = true
					self.SimulatorMenu:ToggleClose()
				end
			else
				self.OpenSelector:SetVisible(false)
			end

			self.CreatePartyButton:SetVisible(false)
			self.ChallengeSelector:SetVisible(false)

			self.LeaveQueueButton:SetVisible(true)
			self.LeaveQueueButton.PartyId = partyId
		end
		
		local ply = player.GetBySteamID64(partyData.CreatorSteamId64)
		if IsValid(ply) then
			local plyPanel = self.InnerframeQueue:CreatePanel("DPanel")
			plyPanel.Paint = function( pan, ww, hh )
				local background = {
					{ x = 0           , y = hh*0.05 },
					{ x = 0  + hh*0.05, y = 0       },
					{ x = ww - hh*0.05, y = 0       },
					{ x = ww          , y = hh*0.05 },
					{ x = ww          , y = hh*0.95 },
					{ x = ww - hh*0.05, y = hh      },
					{ x = 0  + hh*0.05, y = hh      },
					{ x = 0           , y = hh*0.95 },		
				}
				draw.NoTexture()
				surface.SetDrawColor( wOS.CombatSim.FrameColor )
				surface.DrawPoly( background )		
				DrawBlur( pan, 1 )

				draw.SimpleText("Queued by: " .. ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

				draw.SimpleText("Players: " .. #partyData.Players, "wOS.CombatSim.SmallFont", rw*0.01, rh*0.035, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				draw.SimpleText("Challenge: " .. partyData.QueuedChallenge, "wOS.CombatSim.SmallFont", rw*0.45, rh*0.035, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)

				if pan:IsHovered() then
					cam.Start2D()
						local x = gui.MouseX()
						local y = gui.MouseY()

						local n = #partyData.Players
						draw.RoundedBox(0, x, y, rw * 0.25, rh * 0.025 * n, Color(255, 255, 255))

						for i, plySteamId64 in pairs(partyData.Players) do
							local partyPly = player.GetBySteamID64(plySteamId64)
							if IsValid(partyPly) then
								draw.SimpleText(partyPly:GetName(), "wOS.CombatSim.SmallFont", x, y + rh * 0.025 * (i-1), Color(0, 0, 0), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							end

						end
					cam.End2D()
				end
			end

			if partyData.CreatorSteamId64 == LocalPlayer():SteamID64() then
				local inviteButton = vgui.Create("DButton", plyPanel)
				inviteButton:SetPos(rw*0.4, rh*0.01)
				inviteButton:SetFont( "wOS.CombatSim.SmallFont" )
				inviteButton:SetText( "Invite" )
				inviteButton.DoClick = function(pan) 
					self:OpenSimulatorInviteMenu(simulator, partyId, partyData)
				end
			else
				if partyData.Open or table.HasValue(partyData.InvitedPlayers, LocalPlayer():SteamID64()) then
					if not table.HasValue(partyData.Players, LocalPlayer():SteamID64()) then 
						local joinButton = vgui.Create("DButton", plyPanel)
						joinButton:SetPos(rw*0.4, rh*0.01)
						joinButton:SetFont( "wOS.CombatSim.SmallFont" )
						joinButton:SetText( "Join" )
						joinButton.DoClick = function(pan) 
							net.Start("wOS.CombatSim.JoinParty")
								net.WriteEntity(simulator)
								net.WriteInt(partyId, 32)
							net.SendToServer()
							
							self.SimulatorMenu.Clicked = true
							self.SimulatorMenu:ToggleClose()
						end	
					end
				end
			end
		end
	end
end

function wOS.CombatSim:OpenSimulatorInviteMenu(simulator, partyId, partyData)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "INVITE TO PARTY"
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.05)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end
	
	for _, ply in pairs(player.GetHumans()) do
		if ply:SteamID64() == partyData.CreatorSteamId64 then continue end

		local isInvited = table.HasValue(partyData.InvitedPlayers, ply:SteamID64())

		local plyPanel = innerframe:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(ply:GetName(), "wOS.CombatSim.MediumFont", rw*0.01, hh * 0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

		local selector = vgui.Create("DCheckBox", plyPanel)
		selector:SetSize(rh * 0.04, rh * 0.04)
		selector:SetPos(rw * 0.8, rh*0.0075)
		selector:SetValue(isInvited)
		selector.OnChange = function(pan, val)
			if val then
				table.insert(partyData.InvitedPlayers, ply:SteamID64())
			else
				table.RemoveByValue(partyData.InvitedPlayers, ply:SteamID64())
			end
		end
	end

	self.SetInviteButton = vgui.Create("DButton", self.SimulatorMenu)
	self.SetInviteButton:SetSize( rw*0.5, rh*0.05 )
	self.SetInviteButton:SetPos( rw*0.25, rh*0.925 )
	self.SetInviteButton:SetFont( "wOS.CombatSim.LeaderFont" )
	self.SetInviteButton:SetText( "Set Invites" )
	self.SetInviteButton.DoClick = function(pan)

		net.Start("wOS.CombatSim.SetPartyInvites")
			net.WriteEntity(simulator)
			net.WriteInt(partyId, 32)
			net.WriteTable(partyData.InvitedPlayers)
		net.SendToServer()

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
	end
end

function wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
	if not self.SimulatorMenu then
		-- TODO: Stop Auto Updating
		return
	end

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	self.InnerFrameCurrent.ChallengeName = gameInfo.ChallengeName
	self.InnerFrameCurrent.GameType = gameInfo.GameType

	self.InnerFrameCurrent:Clear()

	for _, plyName in pairs(gameInfo.PlayerNames) do
		local plyPanel = self.InnerFrameCurrent:CreatePanel("DPanel")
		plyPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )
			DrawBlur( pan, 1 )

			draw.SimpleText(plyName, "wOS.CombatSim.MediumFont", rw*0.01, hh*0.5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
end

hook.Add("HUDPaint", "wOS.CombatSim.HUDPaint", function()
	local ply = LocalPlayer()

	if !ply:Alive() then
		local respawnTime = ply:GetNW2Float("wOS.CombatSim.RespawnTime", 0)
		if respawnTime == 0 then return end
		local diff = math.max(math.floor(respawnTime - CurTime()), 0)
		draw.SimpleText(diff .. "s until you can respawn!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		return
	end

	local simulator = ply:GetNW2Entity("wOS.CombatSim.Entity")
	if !IsValid(simulator) then return end

	local endTime = simulator:GetEndTime()
	if endTime <= CurTime() then return end

	local diff = math.max(math.floor(endTime - CurTime()), 0)
	draw.SimpleText(diff .. "s until the simulation ends!", "wOS.CombatSim.LeaderFont", ScrW() * 0.5, ScrH() * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

end)
--addons/wos-passiveevent/lua/wos/css/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

//PES STUFF

net.Receive("wOS.CSS.OpenToolMenu", function()
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenToolMenu(simulator)
end)


net.Receive( "wOS.CSS.CreateNewSimulation", function( len, ply )
	local simulator = net.ReadEntity()
	if not IsValid( simulator ) then return end
	wOS.CombatSim:OpenSimulationCreator(simulator)
end )

net.Receive( "wOS.CSS.GetEditableChallenges", function(len, ply)
	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) or wep:GetClass() != "wos_simulation_tool" then return end
	
	local sim = wep:GetSelectedSimulator()
	if not IsValid( sim ) or sim == wep then return end

	local challenges = net.ReadTable()

	wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
end )

//CSS ORIGINAL STUFF


















net.Receive("wOS.CombatSim.GetChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()

	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		wOS.CombatSim:OpenToolMenu(simulator)
	end
end)

net.Receive("wOS.CombatSim.OpenChallenges", function()
	local ply = LocalPlayer()

	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local challenges = net.ReadTable()

		wOS.CombatSim:OpenSimulatorMenu(simulator, challenges)
	end
end)

net.Receive("wOS.CombatSim.UpdateWallCollisions", function()
	local wall = net.ReadEntity()
	if not IsValid( wall ) then return end
	local vertices = net.ReadTable()

	if IsValid(wall) and isfunction(wall.ApplyCustomCollisions) then
		wall:ApplyCustomCollisions(vertices)
	end
end)

net.Receive("wOS.CombatSim.GetGameInfo", function()
	local simulator = net.ReadEntity()
	if IsValid(simulator) and simulator:GetClass() == "wos_simulation_system" then
		local gameInfo = net.ReadTable()
		local partyQueue = net.ReadTable()

		wOS.CombatSim:UpdateSimulatorMenuGameInfo(simulator, gameInfo)
		wOS.CombatSim:UpdateSimulatorMenuQueue(simulator, partyQueue)
	end
end)
--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
end

function ENT:ApplyCustomCollisions(vertices)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)

	self:EnableCustomCollisions(true)

	self:PhysicsInitMultiConvex(vertices)
end

hook.Add("PhysgunPickup", "wOS.CombatSim.PreventWallPickup", function(ply, ent)
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

hook.Add("CanTool", "wOS.CombatSim.PreventWallToolgun", function(ply, tr)
	local ent = tr.Entity
	if IsValid(ent) and ent:GetClass() == "wos_simulation_wall" then
		return false
	end
end)

-- Clientside Initialize
function ENT:Initialize()
	net.Start("wOS.CombatSim.UpdateWallCollisions")
		net.WriteEntity(self)
	net.SendToServer()
end

-- Clientside Think
function ENT:Think()
end

-- Clientside OnRemove
function ENT:OnRemove()
end

-- Main Draw function.
function ENT:Draw()
end

scripted_ents.Register(ENT, "wos_simulation_wall")
--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--addons/scb_chatbox/lua/scb/sh_chatbox.lua:
if SCB_LOADED then return end

local scb = scb

local PLAYER = FindMetaTable("Player")
function PLAYER:IsTyping()
	return self:GetNWBool("SCB.IsTyping", false)
end

function PLAYER:SCB_GetTag()
	local tags = scb.tags
	return tags[self:SteamID()] or tags[self:SteamID64()] or tags[self:GetUserGroup()] or false
end

local permissions = scb.config.permissions
function scb.has_permission(ply, permission)
	if not IsValid(ply) then return true end

	permission = permissions[permission]
	return permission[1] or permission[ply:GetUserGroup()] or permission[ply:SteamID()] or permission[ply:SteamID64()]
end
--addons/scb_chatbox/lua/scb/cl_overrides.lua:
if SCB_LOADED then return end

local table = table
local gui = gui
local team = team
local chat = chat
local hook = hook

local tonumber = tonumber
local Color = Color
local SetClipboardText = SetClipboardText
local IsValid = IsValid
local date = os.date
local team_GetColor = team.GetColor

local scb = scb
local config = scb.config
local language = scb.language

chat.OldOpen = chat.OldOpen or chat.Open
chat.OldClose = chat.OldClose or chat.Close

-- sometimes default chatbox prevents opening the console???
chat.OldClose()

local TEAM = "(" .. language.team .. ") "

function chat.Open(mode)
	mode = tonumber(mode)

	local dont_open = hook.Run("StartChat", mode ~= 1)
	if dont_open == true then return end

	scb.create_chatbox()

	local chatbox = scb.chatbox
	if chatbox.hidden == false then return end

	chatbox.bteam = mode
	chatbox.text_entry:SetPlaceholder((mode ~= 1 and TEAM or "") .. language.type_something)

	chatbox:SetVisible(true)
	chatbox.text_entry:RequestFocus()
	chatbox.text_entry:InvalidateLayout()
	chatbox:MakePopup()

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		v:Stop()
		v:AlphaTo(255, 0)
	end

	net.Start("SCB.IsTyping")
		net.WriteBool(true)
	net.SendToServer()
end

function chat.Close()
	local chatbox = scb.chatbox
	if not chatbox then return end

	if IsValid(scb.emojis_menu) then
		scb.emojis_menu:Remove()
	end

	chatbox.text_entry:SetValue("")
	chatbox.text_entry:OnTextChanged() -- reset chat history

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		if v.can_hide == nil then
			v:Stop()
			v:AlphaTo(0, 0)
		end
	end

	chatbox:SetVisible(false)
	chatbox:SetMouseInputEnabled(false)
	chatbox:SetKeyboardInputEnabled(false)

	chatbox.scroll_panel:ScrollToBottom()

	hook.Run("FinishChat")

	net.Start("SCB.IsTyping")
		net.WriteBool(false)
	net.SendToServer()
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
function chat.GetChatBoxPos()
	if scb.chatbox then
		return scb.chatbox:GetPos()
	end
	return chat.OldGetChatBoxPos()
end

chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
function chat.GetChatBoxSize()
	if scb.chatbox then
		return scb.chatbox:GetSize()
	end
	return chat.OldGetChatBoxSize()
end

local fade_out_time = GetConVar("scb_message_fade_out_time"):GetFloat()
cvars.AddChangeCallback("scb_message_fade_out_time", function(_, _, value_new)
	fade_out_time = value_new
end)

chat.OldAddText = chat.OldAddText or chat.AddText
local AddText_queue = {}
local allow_parsing = config.parse_in_chat
function chat.AddText(...)
	local args
	if AddText_queue == true then
		args = ...
	else
		chat.OldAddText(...)
		args = {n = select("#", ...), ...}
	end

	if not scb.chatbox then
		table.insert(AddText_queue, args)
		return
	end

	local scroll_panel = scb.chatbox.scroll_panel
	local down = scroll_panel:ShouldScrollDown()

	local line = scroll_panel:Add("SCB.ChatLine")
	line:HideAfterTime(fade_out_time)

	line.parsing = true

	local current_color = line.text_color
	for i = 1, args.n do
		local v = args[i]
		local t = scb.type(v)
		if t == "Color" then
			current_color = v
		elseif t == "string" then
			if allow_parsing then
				line:Parse(v, current_color)
			else
				line:NewLabel(v, current_color)
			end
		elseif scb.isentity(v) and not IsValid(v) and not v:IsWorld() then
			line:NewLabel("NULL", current_color)
		elseif t == "Player" then
			line:NewLabel(v:Name(), team_GetColor(v:Team()))
		elseif t == "Entity" then
			line:NewLabel(v:GetClass(), current_color)
		end
	end

	line.parsing = nil

	line:SizeToChildren(false, true)

	if down then
		scroll_panel:ScrollToBottom()
	end
end

local gamemodes_OnPlayerChat = {}
do
	local add_say = function(key, func)
		gamemodes_OnPlayerChat[key] = func
	end

	local line_DoRightClick = function(s)
		local d_menu = DermaMenu()

		local text = s.text
		d_menu:AddOption(language.copy_text, function()
			SetClipboardText(text)
		end)

		local message = s.message
		d_menu:AddOption(language.copy_message, function()
			SetClipboardText(message)
		end)

		local steamid = s.steamid
		if steamid then
			d_menu:AddSpacer()

			d_menu:AddOption(language.copy_steamid, function()
				SetClipboardText(util.SteamIDFrom64(steamid))
			end)

			d_menu:AddOption(language.copy_steamid64, function()
				SetClipboardText(steamid)
			end)

			d_menu:AddOption(language.show_profile, function()
				gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid)
			end)
		end

		d_menu:AddSpacer()
		local time = s.time
		d_menu:AddOption(language.copy_time, function()
			SetClipboardText(time)
		end)

		d_menu:Open()
		d_menu:MakePopup()
	end

	local show_timestamps = GetConVar("scb_show_timestamps"):GetBool()
	cvars.AddChangeCallback("scb_show_timestamps", function(_, _, value_new)
		show_timestamps = tobool(value_new)
	end)

	local show_avatars = config.enable_avatars and GetConVar("scb_show_avatars"):GetBool() or false
	cvars.AddChangeCallback("scb_show_avatars", function(_, _, value_new)
		show_avatars = tobool(value_new)
	end)

	local default_say = function(ply, text, bteam, is_dead, name_replacement, name_color_replacement, text_color)
		local is_console = not ply:IsValid()

		local scroll_panel = scb.chatbox.scroll_panel
		local down = scroll_panel:ShouldScrollDown()

		local line = scroll_panel:Add("SCB.ChatLine")
		line:HideAfterTime(fade_out_time)

		line.parsing = true
		line.time = date(config.timestamps_format)

		if show_timestamps then
			line:SetFont(SCB_16)
			line:NewLabel(line.time .. " ", Color(164, 164, 164))
			line:SetFont(SCB_18)
		end

		local name, name_color
		if not is_console then
			if show_avatars then
				line:NewAvatar(ply)
			end

			if is_dead then
				line:NewLabel(language.dead, Color(244, 67, 54))
			end

			if bteam then
				line:NewLabel(TEAM, Color(76, 175, 80))
			end

			local tag = ply:SCB_GetTag()
			if tag then
				line.emoji_size = 18
				line:Parse(tag .. " ")
				line.emoji_size = 24
			end

			if name_replacement then
				name = name_replacement
			else
				name = ply:Name()
			end

			if name_color_replacement then
				name_color = name_color_replacement
			else
				name_color = team_GetColor(ply:Team())
			end

			line.steamid = ply:SteamID64()
		else
			line:NewLabel("*")
			name, name_color = language.console, Color(13, 130, 223)
		end

		line:NewLabel(name, name_color)
		line:NewLabel(": ")
		line:SetPlayer(ply)
		line:Parse(text, text_color)

		line.message = text
		line.DoRightClick = line_DoRightClick

		if down then
			scroll_panel:ScrollToBottom()
		end

		chat.OldAddText(Color(164, 164, 164), line.time .. " - ", name_color, name, line.text_color, ": ", text_color, text)

		return true
	end
	add_say(1, default_say)

	add_say("darkrp", function(ply, text, _, is_dead, prefix, col1, col2)
		return default_say(ply, text, false, is_dead, prefix, col1, col2 ~= color_white and col2 or nil)
	end)

	add_say("terrortown", function(ply, text, bteam, is_dead)
		if not IsValid(ply) then
			return default_say(ply, text, bteam, is_dead)
		end

		local is_spec = ply:Team() == TEAM_SPEC
		if is_spec then
			is_dead = true
		end

		if bteam and ((not is_spec and not ply:IsSpecial()) or is_spec) then
			bteam = false
		end

		local name_color
		if ply:GetTraitor() then
			name_color = Color(244, 67, 54)
		elseif ply:GetDetective() then
			name_color = Color(13, 130, 223)
		end

		return default_say(ply, text, bteam, is_dead, nil, name_color)
	end)
end

local OnPlayerChat_queue = {}
hook.Add("OnPlayerChat", "SCB", function(...)
	table.insert(OnPlayerChat_queue, {n = select("#", ...), ...})
	return true
end)

local OnPlayerChat
hook.Add("HUDPaint", "SCB", function()
	chat.Open(1)

	for _, v in ipairs(AddText_queue) do
		AddText_queue = true
		chat.AddText(v)
	end
	AddText_queue = nil

	hook.Remove("OnPlayerChat", "SCB")
	OnPlayerChat = gamemodes_OnPlayerChat[engine.ActiveGamemode()] or gamemodes_OnPlayerChat[1]
	function GAMEMODE:OnPlayerChat(...)
		return OnPlayerChat(...)
	end
	for _, v in ipairs(OnPlayerChat_queue) do
		OnPlayerChat(unpack(v, 1, v.n))
	end
	OnPlayerChat_queue = nil

	chat.Close()
	hook.Remove("HUDPaint", "SCB")
end)

hook.Add("PlayerButtonDown", "SCB", function()
	local chatbox = scb.chatbox
	if chatbox and not chatbox.hidden then
		chatbox.text_entry:RequestFocus()
	end
end)

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/game/client/clientmode_shared.cpp#L651
timer.Simple(5, function()
	local binds = {
		messagemode = 1,
		say = 1,

		messagemode2 = 0,
		say_team = 0
	}

	local old_PlayerBindPress = GAMEMODE.PlayerBindPress
	function GAMEMODE:PlayerBindPress(ply, bind, pressed)
		if old_PlayerBindPress(self, ply, bind, pressed) == true then
			return true
		end

		local team_mode = binds[bind]
		if team_mode then
			if pressed then
				chat.Open(team_mode)
			end
			return true
		end
	end
end)

timer.Simple(5, function()
	local types = {
		namechange = 1,
		servermsg = 1,
		teamchange = 1,
		none = 1,
	}

	if not config.enable_custom_join_messages and not config.enable_custom_leave_messages then
		types.joinleave = 1
	end

	local old_ChatText = GAMEMODE.ChatText
	function GAMEMODE:ChatText(index, name, text, type, ...)
		if old_ChatText(self, index, name, text, type) == true then
			return true
		end

		if types[type] then
			chat.AddText(text)
			return true
		end

		if type == "joinleave" then
			return true
		end
	end
end)

if config.enable_custom_join_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_join = {}
	gameevent.Listen("player_connect_client")
	hook.Add("player_connect_client", "SCB.JoinMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_joined:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_join[steamid] then
			printed_join[steamid] = true

			timer.Simple(4, function()
				printed_join[steamid] = nil
			end)

			chat.AddText((
				language.player_connecting:gsub("NAME", scb.escape(data.name)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

if config.enable_custom_leave_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_left = {}
	gameevent.Listen("player_disconnect")
	hook.Add("player_disconnect", "SCB.LeaveMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_left:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_left[steamid] then
			printed_left[steamid] = true

			timer.Simple(4, function()
				printed_left[steamid] = nil
			end)

			chat.AddText((
				language.player_left:gsub("NAME", scb.escape(data.name)):gsub("REASON", scb.escape(data.reason)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

hook.Add("HUDShouldDraw", "SCB", function(name)
	if name == "CHudChat" then
		return false
	end
end)

net.Receive("SCB.TTTRadio", function()
	local sender = net.ReadEntity()
	local msg = net.ReadString()
	local param = net.ReadString()
	if not IsValid(sender) and sender:IsPlayer() then return end

	GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

	local lang_param = LANG.GetNameParam(param)
	if lang_param then
		if lang_param == "quick_corpse_id" then
			param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
		else
			param = LANG.GetTranslation(lang_param)
		end
	end

	local text = LANG.GetParamTranslation(msg, {player = param})

	if lang_param then
		text = util.Capitalize(text)
	end

	OnPlayerChat(sender, text, false, false)
end)
--addons/scb_chatbox/lua/scb/vgui/scb_chat_line.lua:
if SCB_LOADED then return end

local timer = timer
local draw = draw
local surface = surface
local math = math
local table = table
local vgui = vgui

local Lerp = Lerp
local Color = Color
local DermaMenu = DermaMenu
local unpack = unpack
local IsValid = IsValid
local UnPredictedCurTime = UnPredictedCurTime
local RoundedBox = draw.RoundedBox
local sub = string.sub
local find = string.find
local gsub = string.gsub
local lower = string.lower

local scb = scb
local sui = sui
local SUI = scb.SUI
local config = scb.config
local language = scb.language

scb.chat_parsers = {}
local add_parser_example = function(title, example, output)
	table.insert(scb.chat_parsers, {title, example, output:format("change_me")})
end

do
	local available_colors = "\n\nAvailable Colors:\n"
	for k in pairs(config.colors) do
		available_colors = available_colors .. k .. " - "
	end
	available_colors = available_colors:sub(1, -4) .. "\n"

	add_parser_example("{cyan This text will be in cyan.}" .. available_colors, "{cyan What is this?}", "{cyan %s}")
end
add_parser_example("{#d4af37 This text will be in gold.}\nUsage: {#hex text}\n", "{#d4af37 Gold is my favourite color UwU}", "{#d4af37 %s}")
add_parser_example("{*This text will be in rainbow.}", "{*Nice rainbow text OwO}", "{*%s}")
add_parser_example("{!This text will be flashing in red.}", "{!OwO I like it ^-^}", "{!%s}")
add_parser_example("{!blue This text will be flashing in blue.}", "{!blue I love flashing blue ^~^}", "{!blue %s}")
add_parser_example("{!#d4af37 This text will be flashing in gold.}", "{!#d4af37 flashing & gold?}", "{!#d4af37 %s}")
add_parser_example("\\{*This text will be escaped.}", "\\{*This text will be escaped.}", "\\{*%s}")

local ESCAPE_CHAR = "\\"

local created_panels = {}

local Panel = {}

AccessorFunc(Panel, "m_bFont", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_bPlayer", "Player")

local current_x
local current_line
local current_y, line_h
function Panel:Init()
	self:Dock(TOP)
	self:SetFont(SCB_18)

	self:InvalidateParent(true)

	self:SetAlpha(0)
	self:AlphaTo(255, 0.5)

	self:SetCursor("hand")

	self.text_color = SUI.GetColor("text_entry")

	self.added = {}

	-- Methods
	local children = {}
	function self:Add(pnl)
		pnl = vgui.Create(pnl, self)
		pnl.line = current_line
		table.insert(children, pnl)
		return pnl
	end
	function self:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	function self:GetChildren()
		return children
	end
	--

	-- self.next_pos = 427482418

	self:ScaleChanged()
	table.insert(created_panels, self)
end

function Panel:ScaleChanged()
	self:Clear()
	self:InvalidateParent(true)
	self:InvalidateLayout(true)

	current_x = 0
	current_line = 0
	current_y, line_h = 0, 0

	self.max_w = -1
	self.max_h = {0}
	self.text = ""

	self.emoji_size = 24

	self.parsing = true

	local added = self.added
	self.added = {}
	for i = 1, #added do
		local v = added[i]
		local v_1 = v[1]

		local func = (v_1 == 1 and self.NewLabel) or (v_1 == 2 and self.NewEmoji) or (v_1 == 3 and self.NewAvatar)
		func(self, unpack(v, 2, table.maxn(v)))

		added[i] = nil
	end

	self.parsing = nil
	self:SizeToChildren(false, true)
end

local hovered = Color(50, 50, 50, 150)
function Panel:Paint(w, h)
	if self.Hovered then
		RoundedBox(3, 0, 0, w, h, hovered)
	end
end

function Panel:DoRightClick()
	local d_menu = DermaMenu()
	local text = self.text
	d_menu:AddOption(language.copy_text, function()
		SetClipboardText(text)
	end)
	d_menu:Open()
	d_menu:MakePopup()
end

function Panel:OnMouseReleased(mousecode)
	if self.Hovered and mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end
end

function Panel:IncrementLine()
	current_x = 0
	current_line = current_line + 1
	current_y, line_h = current_y + line_h, 0
	self.max_h[current_line + 1] = 0
end

function Panel:SetLineH(h)
	if h > line_h then
		line_h = h
		self.max_h[current_line + 1] = h

		local childs = self:GetChildren()
		for i = #childs, 1, -1 do
			local v = childs[i]
			if v.line ~= current_line then break end
			v.y = self:GetCurrentY(v:GetTall())
		end
	end
end

function Panel:SizeToChildren(width, height)
	if self.parsing then return end

	if width then
		self:SetWide(self.max_w)
	end

	if height then
		self:SetTall(self:GetTotalH())
	end
end

function Panel:GetTotalH()
	local h = 0
	local max_h = self.max_h
	if max_h then
		for i = 1, #max_h do
			h = h + max_h[i]
		end
	end
	return h
end

function Panel:GetCurrentY(_h)
	local y = current_y
	if _h == line_h then return y end
	return math.floor((y + ((line_h / 2) - (_h / 2))) + 0.5)
end

function Panel:AddW(w)
	current_x = current_x + w

	if current_x > self.max_w then
		self.max_w = current_x
	end

	if current_x >= self:GetWide() then
		self:IncrementLine()
	end
end

function Panel:GetMessageW()
	return self.max_w
end

do
	local label_time

	local underline_color = Color(23, 115, 196)
	local url_underline = function(s, w, h)
		if s:IsHovered() then
			s:SetTextColor(underline_color)
		else
			s:SetTextColor(s.text_color)
		end
		RoundedBox(0, 0, h - 1, w, 1, s:GetTextColor())
	end

	local url_click = function(s)
		gui.OpenURL(s.url)
	end

	local url_right_click = function(s)
		local d_menu = DermaMenu()
		local url = s.url
		d_menu:AddOption(language.copy_url, function()
			SetClipboardText(url)
		end)
		d_menu:Open()
		d_menu:MakePopup()
	end

	local disable_rainbow_colors = GetConVar("scb_disable_rainbow_colors"):GetBool()
	cvars.AddChangeCallback("scb_disable_rainbow_colors", function(_, _, value_new)
		disable_rainbow_colors = tobool(value_new)
	end)
	local label_rainbow = function(s)
		if disable_rainbow_colors then
			s:SetTextColor(s.text_color)
			return
		end

		local r, g, b = sui.hsv_to_rgb((s.time + UnPredictedCurTime()) % 360 * 0.6, 1, 1)
		s:SetFGColor(r, g, b, s.text_color_obj.a)
	end

	local disable_flashing_texts = GetConVar("scb_disable_flashing_texts"):GetBool()
	cvars.AddChangeCallback("scb_disable_flashing_texts", function(_, _, value_new)
		disable_flashing_texts = tobool(value_new)
	end)
	local label_flash = function(s)
		if disable_flashing_texts then
			s:SetTextColor(s.text_color)
			return
		end

		local col = s.text_color_obj
		s:SetFGColor(col.r, col.g, col.b, (s.time + UnPredictedCurTime()) * 300 % 255)
	end

	function Panel:AddLabel(text, color, url, is_hovered, font)
		if text == "" then return end

		local w, h = surface.GetTextSize(text)
		self:SetLineH(h)

		local label = self:Add("SCB.Label")
		label:SetFont(font)
		label:SetText(text:sub(1, 1) == "#" and ("#" .. text) or text)
		label:SetExpensiveShadow(1, color_black)
		label:SetSize(w, h)
		label:SetPos(current_x, self:GetCurrentY(h))

		label.text_color = scb.type(color) == "Color" and color or self.text_color

		if color == "rainbow" or self.flashing then
			label.text_color_obj = Color(label.text_color:Unpack())
			label.time = label_time
			label.Paint = color == "rainbow" and label_rainbow or label_flash
		else
			label:SetTextColor(label.text_color)
		end

		if url then
			label:SetMouseInputEnabled(true)
			label:SetCursor("hand")
			label.Paint = url_underline
			label.DoClick = url_click
			label.DoRightClick = url_right_click
			label.url = url
			label.IsHovered = is_hovered
		end

		self.text = self.text .. text
		self:AddW(w)

		-- if scb.type(color) ~= "Color" then
			-- hook.Add("SCB.ThemeChanged", label, function(s)
			-- 	s.text_color = SUI.GetColor("text_entry")
			-- 	s:SetTextColor(s.text_color)
			-- end)
		-- end

		return label
	end

	local AddLabel = Panel.AddLabel
	local IncrementLine = Panel.IncrementLine
	function Panel:NewLabel(text, color, is_url, font)
		if text == "" then return end

		font = font or self:GetFont()
		table.insert(self.added, {1, text, color, is_url, flashing, font})

		local url
		if is_url then
			url = text
		end

		local wide = self:GetWide()
		text = sui.wrap_text(text, font, wide, wide - current_x)

		local urls, is_hovered
		if is_url then
			urls, is_hovered = {}, function()
				for k, v in ipairs(urls) do
					if v.Hovered then
						return true
					end
				end
			end
		end

		label_time = math.sin(UnPredictedCurTime()) + math.random()

		local lines = text:Split("\n")
		local lines_n = #lines
		for i = 1, lines_n do
			local v = lines[i]

			local line = current_line

			local label = AddLabel(self, v, color, url, is_hovered, font)
			if urls then
				table.insert(urls, label)
			end

			if i ~= lines_n and line == current_line then
				IncrementLine(self)
			end
		end

		self:SizeToChildren(false, true)
	end
end

function Panel:NewEmoji(name, info, size)
	local _size = size or self.emoji_size
	table.insert(self.added, {2, name, info, _size})

	if scb.isnumber(_size) then
		size = SUI.ScaleEven(_size)
	else
		size = tonumber(_size)
	end

	if size >= self:GetWide() - current_x then
		self:IncrementLine()
	end

	self:SetLineH(size)

	local image = self:Add("SCB.Image")
	image:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. name .. ".png"))
	image:SetSize(size, size)
	image:SetPos(current_x, self:GetCurrentY(size))

	if size == SUI.ScaleEven(24) then
		image:SetMinus(2)
	end

	self:AddW(size)

	self.text = self.text .. (":" .. name .. ":")

	self:SizeToChildren(false, true)

	return image
end

function Panel:NewAvatar(ply, size)
	table.insert(self.added, {3, ply, size})

	size = SUI.ScaleEven(size or 26)

	self:SetLineH(size)

	local avatar = self:Add("Panel")
	avatar:SetSize(size, size)
	avatar:SetPos(current_x, self:GetCurrentY(size))
	avatar:SetMouseInputEnabled(false)
	avatar:SUI_TDLib()
		:CircleAvatar()

	if scb.isentity(ply) then
		avatar:SetPlayer(ply, size)
	else
		avatar:SetSteamID(ply, size)
	end

	surface.SetFont(self:GetFont())
	self:AddW(size + surface.GetTextSize(" "))
end

function Panel:HideAfterTime(time)
	self.can_hide = false
	timer.Simple(time, function()
		if not IsValid(self) then return end
		self.can_hide = nil
		if scb.chatbox.hidden then
			self:AlphaTo(0, 0.5)
		end
	end)
end

do
	local NewLabel = Panel.NewLabel

	local trim = function(s)
		return s:match("^%s*(.-)%s*$") or s
	end

	local parse_arg = function(text)
		local arg = ""
		local i, n = 1, #text
		while i <= n do
			local c = sub(text, i, i)
			if c == " " then break end
			if c == "}" then break end
			arg = arg .. c

			i = i + 1
		end
		return lower(arg), i + 1
	end

	local color_parsers = {}
	for k, v in pairs(config.colors) do
		color_parsers[k] = {
			permission = "colored_texts",
			callback = function(self, text, arg)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(v))
			end
		}
	end

	local parsers; parsers = {
		["$"] = {
			callback = function(self, emoji, ply, color)
				emoji = lower(emoji)

				local emoji_info = scb.emojis[emoji]
				if emoji_info and not (scb.is_custom_emoji(emoji_info) and not scb.has_permission(ply, "custom_emojis")) then
					self:NewEmoji(emoji, emoji_info)
				else
					return false, ":" .. emoji .. ":"
				end
			end
		},
		["#"] = {
			permission = "colored_texts",
			callback = function(self, text, _, color)
				local hex_col, start = parse_arg(text)
				if #hex_col < 3 or not find(hex_col, "^[%da-fA-F]+$") then
					return false
				end
				text = trim(sub(text, start))
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(hex_col), nil, flashing)
			end
		},
		["*"] = {
			permission = "rainbow",
			callback = function(self, text, ...)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, "rainbow")
			end
		},
		["@"] = {
			callback = function(self, text)
				if scb.find_url(text) then
					NewLabel(self, text, nil, true)
				else
					return false
				end
			end
		},
		["!"] = {
			permission = "flashing",
			callback = function(self, text, ply)
				local ret

				self.flashing = true

				local arg, start = parse_arg(text)
				if scb.has_permission(ply, "colored_texts") then
					if sub(arg, 1, 1) == "#" then
						ret = parsers["#"].callback(self, sub(text, 2))
						goto skip
					elseif color_parsers[arg] then
						color_parsers[arg].callback(self, sub(text, start), "flash")
						goto skip
					end
				end

				text = trim(text)
				if text == "" then
					ret = false
					goto skip
				end
				NewLabel(self, text, Color(255, 0, 0))
				::skip::

				self.flashing = false

				return ret
			end
		}
	}

	local parse_between_braces = function(text, pos, len)
		local tmp_text = ""
		local end_pos = pos
		local closed = false
		local escape = false
		for i = pos, len do
			end_pos = i
			local c = sub(text, i, i)
			if escape then
				tmp_text = tmp_text .. c
				escape = false
				continue
			end
			if c == ESCAPE_CHAR then
				escape = true
			elseif c == "}" then
				closed = true
				break
			else
				tmp_text = tmp_text .. c
			end
		end
		return tmp_text, closed, end_pos
	end

	function Panel:Parse(text, color)
		self.parsing = true

		text = gsub(text, "()%:([%w_]+)%:", function(start, found)
			if text[start - 1] ~= ESCAPE_CHAR then
				return "{$" .. found .. "}"
			end
		end)

		do
			local pos = 0
			while true do
				local start, url, _end = scb.find_url(text, pos + 1)
				if not start then break end
				if text:sub(start - 1, start - 1) ~= ESCAPE_CHAR then
					text = text:sub(1, start - 1) .. ("{@" .. url .. "}") .. text:sub(_end + 1)
				end
				pos = _end + 1
			end
		end

		local ply = self:GetPlayer()

		local len = #text
		local tmp_text = ""
		local i = 0
		while true do
			i = i + 1
			if i > len then break end

			local c = sub(text, i, i)
			if c == ESCAPE_CHAR then
				tmp_text = tmp_text .. sub(text, i + 1, i + 1)
				i = i + 1
				continue
			end

			if c ~= "{" then
				tmp_text = tmp_text .. c
				continue
			end

			local ret_text, closed, end_pos = parse_between_braces(text, i + 1, len)
			if not closed then
				tmp_text = tmp_text .. sub(text, i, end_pos)
				break
			end

			local tag, tag_end = sub(ret_text, 1 , 1), 1
			if not scb.is_letter_digit(tag) then
				tag = parsers[tag]
			else
				for i2 = 2, #ret_text do
					local c2 = sub(ret_text, i2, i2)
					if not scb.is_letter_digit(c2) then break end
					tag = tag .. c2
					tag_end = tag_end + 1
				end
				tag_end = tag_end + 1
				tag = color_parsers[tag]
			end

			i = end_pos

			local failed_text = "{" .. ret_text .. "}"

			if tag == nil then
				tmp_text = tmp_text .. failed_text
				continue
			end

			local permission = tag.permission
			if permission and not scb.has_permission(ply, permission) then
				tmp_text = tmp_text .. failed_text
				continue
			end

			ret_text = sub(ret_text, tag_end + 1)

			NewLabel(self, tmp_text, color)
			local done, ret = tag.callback(self, ret_text, ply, color)
			if done == false then
				if ret then
					NewLabel(self, ret, color)
				else
					NewLabel(self, failed_text, color)
				end
			end
			tmp_text = ""
		end

		NewLabel(self, tmp_text, color)
		self.parsing = nil
		self:SizeToChildren(false, true)
	end
end

do
	local AnimationThink = function(s)
		local anim = s.anim
		if not anim then return end

		local time = UnPredictedCurTime()
		if time >= anim.start_time then
			local frac = math.TimeFraction(anim.start_time, anim.end_time, time)
			frac = math.Clamp(frac, 0, 1)

			s:SetAlpha(Lerp(frac ^ (1 - (frac - 0.5)), s:GetAlpha(), anim.alpha))

			if frac == 1 then
				s.anim = nil
				s.AnimationThink = nil
			end
		end
	end

	function Panel:AlphaTo(alpha, length)
		local time = UnPredictedCurTime()

		self.anim = {
			start_time = time,
			end_time = time + length,

			alpha = alpha
		}

		self.AnimationThink = AnimationThink
	end

	function Panel:Stop()
		self.anim = nil
	end
end

function Panel:OnRemove()
	for i = 1, #created_panels do
		if created_panels[i] == self then
			table.remove(created_panels, i)
			break
		end
	end
end

SUI.OnScaleChanged("ChatLines", function()
	timer.Simple(0, function()
		for i = 1, #created_panels do
			local v = created_panels[i]
			if v:IsValid() then
				v:ScaleChanged()
			end
		end
	end)
end)

sui.register("ChatLine", Panel, "Panel")
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/treatments/plate.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Metallplatte"
Treatment.Description = "Dies ist eine Metallplatte."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Repairkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "HL1/ambience/port_suckin1.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	if not patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" brachte eine ",
		self.Name,
		" an ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" an."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("plate", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/treatments/pliers.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Zange"
Treatment.Description = "Dies ist eine Zange."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Repairkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "HL1/ambience/port_suckin1.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	if not patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" verwendete eine Zange. ",
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("pliers", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/anticeptind.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Anticeptin-D"
Treatment.Description = "Anticeptin-D ist ein Wunddesinfektionsmittel."

Treatment.TreatmentTime = 4
Treatment.UseMessage = "verwendet Anticeptin-D."

Treatment.Type = {["Kit"] = true, ["FirstAid"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "player/sprayer.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" sprühte ",
		self.Name,
		" auf ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("anticeptind", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/antishock.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Anti-Shock"
Treatment.Description = "Wird für Gehirnerschütterungen verwendet."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Anti-Shock."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if injury.name == "Gehirnerschütterung" then return true end

	return false
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" träufelte ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" eine Dosis ",
		self.Name,
		" in den Mund. "
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("antishock", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/cardinex.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Cardinex"
Treatment.Description = "Dies ist ein bekanntes Gegengift."

Treatment.TreatmentTime = 5
Treatment.UseMessage = "verwendet Cardinex."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Medicsystem:RegisterTreatment("cardinex", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/coagulin.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Coagulin"
Treatment.Description = "Coagulin ist ein Medikament, das die Blutgerinnung fördert."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Coagulin."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" schmierte ",
		self.Name,
		" über ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("coagulin", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/enkephalin.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Enkephalin"
Treatment.Description = "Ein Gel, welches zur Behandlung von Brandwunden verwendet werden kann."

Treatment.TreatmentTime = 3
Treatment.UseMessage = "verwendet Enkephalin."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" schmierte ",
		self.Name,
		" über ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("enkephalin", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/kouhunin.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Kouhunin"
Treatment.Description = "Kouhunin ist ein starkes Schmerzmittel, das in der Chirurgie Anwendung findet."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Kouhunin."

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.Type = {["Injector"] = true}

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.Hooks = {
	["Medicsystem.IsTreated"] = function(availableTreatments, injury)
		if availableTreatments["nullicaine"] == false and injury.treatmentsApplied["kouhunin"] then
			availableTreatments["nullicaine"] = true
		end
	end
}

Medicsystem:RegisterTreatment("kouhunin", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/nullicaine.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Nullicaine"
Treatment.Description = "Nullicaine ist ein starkes Anästhetikum das auf Verbände oder Verletzungen gesprüht werden kann, um Schmerzen zu lindern."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Nullicaine."

Treatment.TreatmentSound = function(self, ply)
	if ply:GetActiveWeapon().ItemType == "Injector" then
		return "medkit/squirt.wav"
	else
		return "player/sprayer.wav"
	end
end

Treatment.Type = {["Kit"] = true, ["Injector"] = true, ["FirstAid"] = true}

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	if ply:GetActiveWeapon().ItemType == "Injector" then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" injizierte ",
			self.Name,
			" in ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	else
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" sprühte ",
			self.Name,
			" über ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	end

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	if ply:GetActiveWeapon().ItemType == "Injector" then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" injizierte ",
			self.Name,
			" in den/das ",
			hitgroup,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	else
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" sprühte ",
			self.Name,
			" über den/das ",
			hitgroup,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	end

	return true
end

Medicsystem:RegisterTreatment("nullicaine", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/wake.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Macht-Wecken"
Treatment.Description = "Weckt einen ."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	if patient:GetNWBool("Medicsystem.IsDead", false) then return false end
	if patient:IsPlayer() and not patient:Alive() then return true end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end

		if not IsValid(patient) then return end
		if patient:Alive() then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" weckte ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		DeathSystem:Revive(patient)
		Medicsystem:CalculateHealth(patient)

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Medicsystem:RegisterTreatment("wake", Treatment)




--addons/prone_mod_wos/lua/prone/sh_prone.lua:
local PLAYER = FindMetaTable("Player")

---------------------------------
-- PLAYER.GetProneAnimationState
---------------------------------
-- Desc:		Gets the prone animation state of the given player.
-- Returns:		PRONE enum.
function PLAYER:GetProneAnimationState()
	return self:GetNWInt("prone.AnimationState", PRONE_NOTINPRONE)
end

---------------------------------
-- PLAYER.SetProneAnimationState
---------------------------------
-- Desc:		Sets the prone animation state of the given player.
-- Arg One:		PRONE enum.
function PLAYER:SetProneAnimationState(state)
	return self:SetNWInt("prone.AnimationState", state)
end

----------------------------------
-- PLAYER.GetProneAnimationLength
----------------------------------
-- Desc:		Returns the time when the current prone animation will end.
-- 				This value is: CurTime at start of anim + length of anim
-- Returns:		Number
function PLAYER:GetProneAnimationLength()
	return self:GetNWFloat("prone.AnimationLength", 0)
end

----------------------------------
-- PLAYER.SetProneAnimationLength
----------------------------------
-- Desc:		Sets at what time, relative to CurTime, the given prone animation will end.
-- Arg One:		Number, time.
function PLAYER:SetProneAnimationLength(length)
	self:SetNWFloat("prone.AnimationLength", length)
end

------------------
-- PLAYER.IsProne
------------------
-- Desc:		Is the player in prone.
-- Returns:		Boolean.
function PLAYER:IsProne()
	return self:GetProneAnimationState() ~= PRONE_NOTINPRONE
end

---------------------------
-- PLAYER.ProneIsGettingUp
---------------------------
-- Desc:		Is the player getting up out of prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingUp()
	return self:GetProneAnimationState() == PRONE_GETTINGUP
end

-----------------------------
-- PLAYER.ProneIsGettingDown
-----------------------------
-- Desc:		Is the player getting down into prone.
-- Returns:		Boolean.
function PLAYER:ProneIsGettingDown()
	return self:GetProneAnimationState() == PRONE_GETTINGDOWN
end

------------------------
-- prone.HasRoomToGetUp
------------------------
-- Desc:		Does the player have enough room to get up, out of prone.
-- Arg One:		Player.
-- Returns:		Boolean.
function prone.HasRoomToGetUp(ply)
	if not ply:IsProne() then
		return true
	end

	local tr = util.TraceEntity({
		start = ply:GetPos(),
		endpos = ply:GetPos() + Vector(0, 0, 65 - prone.Config.HullHeight),
		filter = ply
	}, ply)
	
	if tr.Hit then
		if CLIENT and IsFirstTimePredicted() then
			prone.CantGetUpWarning()
		end
		return false
	else
		return true
	end
end

------------------
-- prone.CanEnter
------------------
-- Desc:		Can the given player enter prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanEnter(ply)
	-- prone.CanEnter hook takes precedence.
	local hookresult = hook.Run("prone.CanEnter", ply)
	if hookresult ~= nil then
		return hookresult

	-- Then check the player's state.
	elseif not ply:IsPlayer() or not ply:Alive() or ply:GetMoveType() == MOVETYPE_NOCLIP or not ply:OnGround() or ply:WaterLevel() > 1 then
		return false
	end

	return true
end

-----------------
-- prone.CanExit
-----------------
-- Desc:		Can the given player exit prone.
-- Arg One:		Player
-- Returns:		Boolean
function prone.CanExit(ply)
	if not (ply:IsPlayer() and ply:Alive()) then
		return false
	end

	local hookresult = hook.Run("prone.CanExit", ply)
	if hookresult ~= nil then
		return hookresult
	elseif not prone.HasRoomToGetUp(ply) then
		return false
	end

	return true
end

---------------
-- prone.Enter
---------------
-- Desc:		Begins the animation putting the given player into prone.
-- Arg One:		Player.
function prone.Enter(ply)
	local plyProneStateData = prone.PlayerStateData:New(ply)
	prone.PlayerStateDatas[ply:SteamID()] = plyProneStateData
	plyProneStateData:UpdateDataOnProneEnter()

	ply:SetHull(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))
	ply:SetHullDuck(Vector(-16, -16, 0), Vector(16, 16, prone.Config.HullHeight))

	local getDownTime = plyProneStateData:GetGetDownTime()
	ply:SetProneAnimationLength(getDownTime)

	-- Make sure they can't shoot while prone.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getDownTime)
		weapon:SetNextSecondaryFire(getDownTime)
	end

	ply:SetProneAnimationState(PRONE_GETTINGDOWN)
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	hook.Run("prone.OnPlayerEntered", ply, plyProneStateData:GetEnterProneAnimLength())
end

-------------
-- prone.End
-------------
-- Desc:		Begins the animation taking the given player out of prone.
-- Arg One:		Player.
function prone.End(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
	if not plyProneStateData then
		plyProneStateData = prone.PlayerStateData:New(ply)
	end
	plyProneStateData:UpdateOnProneEnd()

	local getUpTime = plyProneStateData:GetGetUpTime()
	ply:SetProneAnimationLength(getUpTime)

	-- Make sure they can't shoot while getting up.
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(getUpTime)
		weapon:SetNextSecondaryFire(getUpTime)
	end

	-- Play the animation.
	ply:DoCustomAnimEvent(PLAYERANIMEVENT_CUSTOM, PRONE_CUSTOM_ANIM_EVENT_NUM)
	ply:SetProneAnimationState(PRONE_GETTINGUP)
end

--------------
-- prone.Exit
--------------
-- Desc:		Forces the player immediately out of prone with no animation.
-- Arg One:		Player.
function prone.Exit(ply)
	local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]

	if plyProneStateData then
		ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
		ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
	else
		-- Best guess in-case we somehow lose state data.
		ply:SetViewOffset(Vector(0, 0, 64))
		ply:SetViewOffsetDucked(Vector(0, 0, 28))
	end
	ply:ResetHull()

	prone.PlayerStateDatas[ply:SteamID()] = nil

	ply:SetProneAnimationState(PRONE_NOTINPRONE)
	hook.Run("prone.OnPlayerExitted", ply)
end

----------------
-- prone.Handle
----------------
-- Desc:		Toggles between the player entering and ending prone.
function prone.Handle(ply)
	if not IsValid(ply) then
		return
	end

	if ply:IsProne() then
		if prone.CanExit(ply) then
			prone.End(ply)
		end
	else
		if prone.CanEnter(ply) then
			prone.Enter(ply)
		end
	end
end

local proneMoveSpeed = CreateConVar("prone_movespeed", tostring(prone.Config.MoveSpeed), {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Sets the move speed while prone.")


-- Disable jumping in prone, set prone movement speed, handle weapon fire.
hook.Add("SetupMove", "prone.Handle", function(ply, cmd, cuc)
	if ply:IsProne() then
		-- Disables jumping, thanks meep.
		if cmd:KeyDown(IN_JUMP) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_JUMP)))
		end
		-- Disabled crouching.
		if cmd:KeyDown(IN_DUCK) then
			cmd:SetButtons(bit.band(cmd:GetButtons(), bit.bnot(IN_DUCK)))
		end

		-- If they are getting up or down then set their speed to TransitionSpeed
		if ply:GetProneAnimationLength() >= CurTime() then
			cmd:SetMaxClientSpeed(prone.Config.TransitionSpeed)
			cmd:SetMaxSpeed(prone.Config.TransitionSpeed)

			-- SetMaxClientSpeed doesn't work if you are setting it to 0 so also do this.
			if prone.Config.TransitionSpeed <= 0 and ply:IsOnGround() then
				cmd:SetForwardSpeed(0)
				cmd:SetSideSpeed(0)
				cmd:SetVelocity(Vector(0, 0, 0))
			end
			return
		else	-- If they are in prone set their speed to MoveSpeed
			local moveSpeed = proneMoveSpeed:GetInt()
			if not isnumber(moveSpeed) then
				moveSpeed = prone.Config.MoveSpeed
			end

			cmd:SetMaxClientSpeed(moveSpeed)
			cmd:SetMaxSpeed(moveSpeed)
		end

		-- Make sure they can't shoot while prone and moving if that setting is enabled.
		local attack1 = cmd:KeyDown(IN_ATTACK)
		if attack1 or cmd:KeyDown(IN_ATTACK2) and prone.Config.MoveShoot_Restrict then
			local weapon = ply:GetActiveWeapon()
			if not IsValid(weapon) then
				return
			end

			local weaponclass = weapon:GetClass()
			if not prone.Config.MoveShoot_Whitelist[weaponclass] then
				local shouldStopMovement = true
				if attack1 then
					shouldStopMovement = weapon:Clip1() > 0
				else
					shouldStopMovement = weapon:Clip2() > 0
				end

				if (shouldStopMovement or weaponclass == "weapon_crowbar") and ply:IsOnGround() then
					cmd:SetForwardSpeed(0)
					cmd:SetSideSpeed(0)
					cmd:SetVelocity(Vector(0, 0, 0))
				end
			end
		end
	end

	if cuc:GetImpulse() == PRONE_IMPULSE and (ply:GetProneAnimationLength() < CurTime() + 0.5) then
		prone.Handle(ply)
	end
end)

-- Handles pose parameters and playback rates of animations.
hook.Add("UpdateAnimation", "prone.Animations", function(ply, velocity, maxSeqGroundSpeed)
	if ply:IsProne() then
		local length = velocity:Length()

		local rate = 1
		local plyAnimState = ply:GetProneAnimationState()
		if plyAnimState ~= PRONE_GETTINGDOWN and plyAnimState ~= PRONE_GETTINGUP then
			if not ply:IsOnGround() and length >= 750 then
				rate = 0.1
			else
				if length > 0.2 then
					rate = math.min(length / maxSeqGroundSpeed, 2)
				else
					rate = 1
				end
			end
		end

		if CLIENT then
			local EyeAngP = ply:EyeAngles().p
			if EyeAngP < 89 then
				ply:SetPoseParameter("body_pitch", math.Clamp(-EyeAngP, -10, 50))
				ply:SetPoseParameter("body_yaw", 0)
				ply:InvalidateBoneCache()
			end
		end

		-- Interesting code I saw in NutScript, doesn't seem to do anything in my case though.
		--local eyeAngles = ply:EyeAngles()
		--local yaw = velocity:Angle()[2]
		--local normalized = math.NormalizeAngle(yaw - eyeAngles[2])
		--ply:SetPoseParameter("move_yaw", normalized)

		ply:SetPlaybackRate(rate)
	end
end)

-- The animation handler of the addon.
local function GetSequenceForWeapon(holdtype, ismoving)
	return ismoving and prone.Animations.WeaponAnims.moving[holdtype] or prone.Animations.WeaponAnims.idle[holdtype]
end
local GetMainActivityAnimation = {
	[PRONE_GETTINGDOWN] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			ply:SetViewOffset(prone.Config.View)
			ply:SetViewOffsetDucked(prone.Config.View)
			ply:SetProneAnimationState(PRONE_INPRONE)
		end
		
		return prone.Animations.gettingdown
	end,

	[PRONE_GETTINGUP] = function(ply)
		if ply:GetProneAnimationLength() <= CurTime() then
			local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
			if plyProneStateData then
				ply:SetViewOffset(plyProneStateData:GetOriginalViewOffset())
				ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
			else
				-- Best guess in-case we somehow lose state data.
				ply:SetViewOffset(Vector(0, 0, 64))
				ply:SetViewOffsetDucked(Vector(0, 0, 28))
			end

			prone.Exit(ply)

			-- If they get stuck in anything while exitting put them back in prone.
			local scanPos = ply:GetPos()
			local tr = util.TraceEntity({
				start = scanPos,
				endpos = scanPos,
				filter = ply
			}, ply)

			if tr.Hit then
				if CLIENT and ply == LocalPlayer() then
					prone.CantGetUpWarning()
				end
				prone.Enter(ply)
			end
		end

		return prone.Animations.gettingup
	end,

	[PRONE_INPRONE] = function(ply, velocity)
		local weapon = ply:GetActiveWeapon()
		local WeaponHoldType

		if IsValid(weapon) then
			WeaponHoldType = weapon:GetHoldType()
			if WeaponHoldType == "" then
				WeaponHoldType = weapon.HoldType
			end
		end

		return GetSequenceForWeapon(WeaponHoldType or "normal", velocity:LengthSqr() >= 225)
	end,

	-- Just in case this gets called for some reason.
	[PRONE_NOTINPRONE] = function()
		return prone.Animations.passive
	end
}
hook.Add("CalcMainActivity", "prone.Animations", function(ply, velocity)
	if IsValid(ply) and ply:IsProne() then
		local seq = GetMainActivityAnimation[ply:GetProneAnimationState()](ply, velocity)

		-- NEVER let this hook's second return parameter be a number less than 0.
		-- That crashes Linux servers for some reason.
		local seqid = ply:LookupSequence(seq or "")
		if seqid < 0 then
			return
		end

		return -1, seqid or nil
	end
end)

-- Fixes a bug where other players (not the one proning) might see the proning player's get up/down
-- animations starting at a random point in the animation.
hook.Add("DoAnimationEvent", "prone.ResetAnimation", function(ply, event, data)
	if event == PLAYERANIMEVENT_CUSTOM then
		if data == PRONE_CUSTOM_ANIM_EVENT_NUM then
			ply:AnimRestartMainSequence()
		end
	end
end)

------------------------------------------------------------
-- Check if the player should still be prone at these events
------------------------------------------------------------
hook.Add("Player.Administrate", "prone.ExitOnNoclip", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
hook.Add("VehicleMove", "prone.ExitOnVehicleEnter", function(ply)
	if ply:IsProne() then
		prone.Exit(ply)
	end
end)
timer.Create("prone.Manage", 0.5, 0, function()
	for i, v in ipairs(player.GetAll()) do
		if v:IsProne() and (
			(v:WaterLevel() > 1 and not v:ProneIsGettingUp())
			or v:GetMoveType() == MOVETYPE_NOCLIP
			or v:GetMoveType() == MOVETYPE_LADDER
		) then
			prone.Exit(v)
		end
	end
end)

----------------
-- API Functions
----------------
-- Notice: Any API functions should be called in or after the prone.Initialized hook has been called.
function prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
	prone.Animations.WeaponAnims.moving[holdtype] = movingSequenceName
	prone.Animations.WeaponAnims.idle[holdtype] = idleSequenceName
end

function prone.GetIdleAnimation(holdtype)
	return prone.Animations.WeaponAnims.idle[holdtype]
end
function prone.GetMovingAnimation(holdtype)
	return prone.Animations.WeaponAnims.moving[holdtype]
end