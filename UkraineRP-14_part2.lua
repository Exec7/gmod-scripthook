--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 2/10 - 06/04/2025


--PATH addons/dash/lua/dash/extensions/chat.lua:
chat = chat or {}

local chats = {}

local CHAT = {}
CHAT.__index = CHAT

debug.getregistry().Chat = CHAT

local net_Start 	= net.Start
local net_Send 		= net.Send
local net_Broadcast = net.Broadcast
local ents_FindInSphere = ents.FindInSphere

function chat.Register(name)
	local t = {
		NetworkString = 'chat_' .. name,
		SendFunc = net.Broadcast,
	}

	chats[name] = t

	if (SERVER) then
		util.AddNetworkString(t.NetworkString)
	else
		net.Receive(t.NetworkString, function()
			if IsValid(LocalPlayer()) then
				local ret = {t.ReadFunc()}
				if (#ret > 0) then
					chat.AddText(unpack(ret))
				end
			end
		end)
	end

	return setmetatable(t, CHAT)
end

function chat.Send(name, ...)
	local chat_obj = chats[name]
	net_Start(chat_obj.NetworkString)
		chat_obj.WriteFunc(...)
	chat_obj.SendFunc(...)
end

function CHAT:Write(func)
	self.WriteFunc = func
	return self
end

function CHAT:Read(func)
	self.ReadFunc = func
	return self
end

function CHAT:Filter(func)
	self.SendFunc = function(...)
		net_Send(func(...))
	end
	return self
end

function CHAT:SetLocal(radius) -- first arg to chat.Send must be a player if this is used
	self.SendFunc = function(pl)
		net_Send(table.Filter(ents_FindInSphere(pl:EyePos(), radius), function(v)
			return v:IsPlayer()
		end))
	end
end
--PATH addons/__________tperson/lua/3tcore/derma/cl_menu.lua:
surface.CreateFont('comfortaa33', {
	font = 'Roboto Bold',
	size = 33,
})

surface.CreateFont('comfortaa27', {
	font = 'Roboto Bold',
	size = 27,
})

surface.CreateFont('comfortaa15', {
	font = 'Roboto Bold',
	size = 15,
})

local col2 = Color(43, 43, 43)
local col3 = Color(123, 123, 123)
local col4 = Color(83, 83, 83)
local col5 = Color(231, 76, 60)
local col6 = Color(46, 204, 113)
local col7 = Color(142, 68, 173)
local col8 = Color(230, 126, 34)

local function importConfig()
	local body = vgui.Create('onyx.Frame')
	body:SetSize(400, 150)
	body:Center()
	body:MakePopup()
	body:SetTitle('Імпортувати новий конфіг')

	local font2 = onyx.Font('Comfortaa@30')
	local save = vgui.Create('onyx.Button', body)
	save:SetSize(body:GetWide() * 0.6, body:GetTall() * 0.2)
	save:SetPos(body:GetWide() * 0.2, body:GetTall() * 0.75)
	save:SetText('Імпорт')
	save:SetFont(font2)
	save:SetColorIdle(col6)
	save:SetCursor('no')

	local textentry = vgui.Create('onyx.TextEntry', body)
	textentry:SetSize(body:GetWide() * 0.8, body:GetTall() * 0.3)
	textentry:SetPos(body:GetWide() * 0.1, body:GetTall() * 0.4)
	textentry:SetMultiline(true)
	textentry:SetDrawLanguageID(false)
	function textentry:OnChange()
		local value = self:GetValue()
		if not value then
			save:SetCursor('no')
			save:SetEnabled(false)
			return
		end

		value = util.JSONToTable(value)
		if not istable(value) then
			save:SetCursor('no')
			save:SetEnabled(false)
			return
		end

		if not TPerson.IsValidConfig(value) then
			save:SetCursor('no')
			save:SetEnabled(false)
			return
		end

		save:SetEnabled(true)
		save:SetCursor('hand')
	end

	function save:DoClick()
		TPerson.SaveConfig(util.JSONToTable(textentry:GetValue()))
		body:Remove()
		if IsValid(TPerson.body) then TPerson.body:Remove() end
	end
end

TPerson.body = TPerson.body or nil
function TPerson.IsEditing()
	return IsValid(TPerson.body)
end

function TPerson.GetMenu()
	return TPerson.body
end

function TPerson.Menu()
	if TPerson.IsEditing() then TPerson.GetMenu():Remove() end
	local userC = TPerson.GetConfig()
	local bodyWide, bodyTall = ScrW() * 0.35, ScrH() * 0.8
	TPerson.body = vgui.Create('onyx.Frame')
	TPerson.body:SetSize(bodyWide, bodyTall)
	TPerson.body:Center()
	TPerson.body:MakePopup()
	TPerson.body:SetTitle('')

	local core = vgui.Create('onyx.ScrollPanel', TPerson.body)
	core:SetPos(bodyWide * 0.05, bodyTall * 0.05)
	core:SetSize(bodyWide * 0.9, bodyTall * 0.87)
	core.PerformLayout = function(s, w, h)
		s.canvas:Dock(FILL)

		s.scroll:Dock(RIGHT)
		s.scroll:SetWide(0)
		s.scroll:DockMargin(0, 0, 0, 0)
	end
	core.scroll:SetWide(0)
	local rowWide, rowTall = core:GetWide(), core:GetTall() / 12
	-- Third person categ
	local font = onyx.Font('Comfortaa@26')
	local font2 = onyx.Font('Comfortaa@30')
	local title = core:Add('onyx.Label')
	title:Dock(TOP)
	title:SetSize(rowWide, rowTall)
	title:SetText('3-я особа')
	title:SetFont(font)
	title:SetTextColor(col3)
	-- Binder row
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Клавіша')
	row:SetFont(font2)
	row:SetTooltip('Кнопка для активації та деактивації 3-ї особи')
	local binder = vgui.Create('DBinder', row)
	binder:SetSize(rowWide / 3, rowTall)
	binder:SetPos(rowWide - binder:GetWide(), 0)
	binder:SetValue(userC['key'])
	binder:SetFont('comfortaa33')
	function binder:OnChange(key)
		userC['key'] = key
	end

	-- Slider 1
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Глибина')
	row:SetFont(font2)
	row:DockMargin(0, core:GetTall() / 12 * 0.25, 0, 0)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(-75, -30)
	slider:SetValue(userC['view']['forward'])
	function slider:OnValueChanged(value)
		userC['view']['forward'] = value
	end

	-- Slider 2
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Ширина')
	row:SetFont(font2)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(-15, 15)
	slider:SetValue(userC['view']['right'])
	function slider:OnValueChanged(value)
		userC['view']['right'] = value
	end

	-- Slider 3
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Висота')
	row:SetFont(font2)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(-15, 20)
	slider:SetValue(userC['view']['up'])
	function slider:OnValueChanged(value)
		userC['view']['up'] = value
	end

	-- Crosshair categ
	local title = core:Add('onyx.Label')
	title:Dock(TOP)
	title:SetSize(rowWide, rowTall)
	title:SetText('Приціл')
	title:SetFont(font)
	title:SetTextColor(col3)
	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, core:GetTall() / 5)
	row:SetText('Стиль')
	row:SetFont(font2)
	row:SetTooltip('Сірі поля зарезервовані для певних груп гравців')
	local selector = vgui.Create('3T:Selector', row)
	selector:SetSize(rowWide / 3, row:GetTall())
	selector:SetPos(rowWide - selector:GetWide(), 0)
	selector:SetCrossHairColor(userC['crosshair']['color'])
	for i, v in ipairs(TPerson.GetCrossHairs()) do
		local show = true
		if v['whitelist'] then show = v['whitelist'][LocalPlayer():GetUserGroup()] or v['whitelist'][LocalPlayer():SteamID()] end
		local choice = selector:Add()
		choice:SetSize(selector:GetWide() / 3 - 5, 40)
		choice:SetText('')
		choice:SetValue(false)
		choice.Paint = function(_, w, h)
			_.Color = _:GetChecked() and col6 or col4
			draw.RoundedBox(6, 0, 0, w, h, _.Color)
			draw.RoundedBox(6, 1, 1, w - 2, h - 2, col2)
			choice.Color = show and selector.CrossHairColor or col4
			v['paint'](w * 0.5, h * 0.5, w, h, choice.Color, 1, 1, 1)
		end

		choice.OnChange = function(_, state)
			if not show then
				choice:SetChecked(false)
				return
			end

			if choice == selector.Choice then
				choice:SetChecked(true)
				return
			end

			if state then
				selector.Choice:SetChecked(false)
				selector.Choice = choice
				userC['crosshair']['style'] = i
			end
		end

		if i == userC['crosshair']['style'] then
			choice:SetChecked(true)
			selector.Choice = choice
		end
	end

	-- Invisible row
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('')
	row:SetFont(font2)
	-- Color picker
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, core:GetTall() / 4)
	row:SetText('Колір')
	row:SetFont(font2)
	local colorPicker = vgui.Create('onyx.ColorWheel', row)
	colorPicker:SetSize(rowWide / 3, row:GetTall())
	colorPicker:SetPos(rowWide - colorPicker:GetWide() - 10, 0)
	colorPicker:SetColor(userC['crosshair']['color'])
	local lThink = colorPicker.Think
	colorPicker.Think = function(s)
		lThink(s)
		--
		local color = s:GetColor()
		selector:SetCrossHairColor(color)
		userC['crosshair']['color'] = color
	end

	-- Invisible row
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('')
	row:SetFont(font2)
	-- Slider 3
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Довжина')
	row:SetFont(font2)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(0, 15)
	slider:SetValue(userC['crosshair']['sHeight'])
	function slider:OnValueChanged(value)
		userC['crosshair']['sHeight'] = value
	end

	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Розмір')
	row:SetFont(font2)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(0, 15)
	slider:SetValue(userC['crosshair']['sWidth'])
	function slider:OnValueChanged(value)
		userC['crosshair']['sWidth'] = value
	end

	-- Slider 3
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Простір')
	row:SetFont(font2)
	local slider = vgui.Create('DNumSlider', row)
	slider:SetSize(rowWide / 3, rowTall)
	slider:SetPos(rowWide - binder:GetWide(), 0)
	slider:SetMinMax(0, 15)
	slider:SetValue(userC['crosshair']['sSpace'])
	function slider:OnValueChanged(value)
		userC['crosshair']['sSpace'] = value
	end

	-- Allow categ
	local title = core:Add('onyx.Label')
	title:Dock(TOP)
	title:SetSize(rowWide, rowTall)
	title:SetText('Інше')
	title:SetFont(font)
	title:SetTextColor(col3)
	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('3-я особа')
	row:SetFont(font2)
	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   використовувати')
	row:SetFont(font)
	row:SetTooltip('Використовувати 3-ю особу')
	local allowTP = vgui.Create('onyx.Toggler', row)
	allowTP:SetPos(rowWide - allowTP:GetWide(), 21)
	allowTP:SetChecked(userC['allow']['third'])
	function allowTP:OnChange()
		userC['allow']['third'] = not userC['allow']['third']
	end

	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   при прицілюванні')
	row:SetFont(font)
	row:SetTooltip('Чи активувати під час прицілювання зі зброї')
	local allowTP = vgui.Create('onyx.Toggler', row)
	allowTP:SetPos(rowWide - allowTP:GetWide(), 21)
	allowTP:SetChecked(userC['allow']['tOnAiming'])
	function allowTP:OnChange()
		userC['allow']['tOnAiming'] = not userC['allow']['tOnAiming']
	end

	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   при спавні')
	row:SetFont(font)
	row:SetTooltip('Автоматично активувати 3-ю особу під час спавна/респавна')
	local allowTP = vgui.Create('onyx.Toggler', row)
	allowTP:SetPos(rowWide - allowTP:GetWide(), 21)
	allowTP:SetChecked(userC['allow']['tOnSpawn'])
	function allowTP:OnChange()
		userC['allow']['tOnSpawn'] = not userC['allow']['tOnSpawn']
	end

	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('Приціл')
	row:SetFont(font2)
	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   1-ша особа')
	row:SetFont(font)
	local allowCFP = vgui.Create('onyx.Toggler', row)
	allowCFP:SetPos(rowWide - allowCFP:GetWide(), 21)
	allowCFP:SetChecked(userC['allow']['crosshair1p'])
	function allowCFP:OnChange()
		userC['allow']['crosshair1p'] = not userC['allow']['crosshair1p']
	end

	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   3-я особа')
	row:SetFont(font)
	local allowCTP = vgui.Create('onyx.Toggler', row)
	allowCTP:SetPos(rowWide - allowCTP:GetWide(), 21)
	allowCTP:SetChecked(userC['allow']['crosshair3p'])
	function allowCTP:OnChange()
		userC['allow']['crosshair3p'] = not userC['allow']['crosshair3p']
	end

	-- Toggle button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('   при прицілюванні')
	row:SetFont(font)
	row:SetTooltip('Чи активувати під час прицілювання зі зброї')
	local allowCOA = vgui.Create('onyx.Toggler', row)
	allowCOA:SetPos(rowWide - allowCOA:GetWide(), 21)
	allowCOA:SetChecked(userC['allow']['cOnAiming'])
	function allowCOA:OnChange()
		userC['allow']['cOnAiming'] = not userC['allow']['cOnAiming']
	end

	-- Import and export buttons
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('конфігурація')
	row:SetFont(font2)
	row:SetTooltip('Легко поділіться своїми налаштуваннями  один з одним за допомогою кнопок імпорту та експорту!\n\nЕкспорт дозволяє зберегти ваші налаштування в буфер обміну.\nІмпорт дозволяє отримати та зберегти налаштування, надіслані вам другом.')
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('')
	local import = vgui.Create('onyx.Button', row)
	import:SetSize(rowWide * 0.45, rowTall)
	import:SetPos(rowWide - rowWide * 0.475, 0)
	import:SetText('Імпорт')
	import:SetFont(font2)
	import:SetColorIdle(col7)

	function import:DoClick()
		importConfig()
	end

	local export = vgui.Create('onyx.Button', row)
	export:SetSize(rowWide * 0.45, rowTall)
	export:SetPos(rowWide * 0.025, 0)
	export:SetText('Експорт')
	export:SetFont(font2)
	export:SetColorIdle(col8)

	function export:DoClick()
		SetClipboardText(util.TableToJSON(userC))
		chat.AddText(color_white, 'Налаштування збережено в буфер обміну!')
	end

	-- Invisible row
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, core:GetTall() / 30)
	row:SetText('')
	row:SetFont(font2)
	-- Save button
	local row = core:Add('onyx.Label')
	row:Dock(TOP)
	row:SetSize(rowWide, rowTall)
	row:SetText('')
	local reset = vgui.Create('onyx.Button', row)
	reset:SetSize(rowWide * 0.45, rowTall)
	reset:SetPos(rowWide * 0.025, 0)
	reset:SetText('Скинути')
	reset:SetFont(font2)
	reset:SetColorIdle(col5)

	function reset:DoClick()
		TPerson.ResetConfig()
		TPerson.body:Remove()
		TPerson.Menu()
	end

	local save = vgui.Create('onyx.Button', row)
	save:SetSize(rowWide * 0.45, rowTall)
	save:SetPos(rowWide * 0.525, 0)
	save:SetText('Зберегти')
	save:SetFont(font2)
	save:SetColorIdle(col6)

	function save:DoClick()
		TPerson.SaveConfig(userC)
		TPerson.body:Remove()
	end
end

concommand.Add('ukrp_option_3person_and_crosshair', TPerson.Menu)
--PATH addons/__________scripts__loader/lua/autorun/_scriptsloader.lua:
SCRIPTSLOADER = SCRIPTSLOADER or {
    IsTwoServer = game.GetIPAddress() == '146.59.47.149:27016',
    IncludeSV = SERVER and include or function() end,
    IncludeCL = SERVER and AddCSLuaFile or include,
    IncludeSH = function( f )
        AddCSLuaFile( f )
        return include( f )
    end
}

function SCRIPTSLOADER.Include( f )
    if f:find( 'cl_' ) then
        SCRIPTSLOADER.IncludeCL( f )
    elseif f:find( 'sh_' ) then
        SCRIPTSLOADER.IncludeSH( f )
    elseif f:find( 'sv_' ) then
        SCRIPTSLOADER.IncludeSV( f )
    end
end

function SCRIPTSLOADER.Load( dir, recursive )
    local files, dirs = file.Find( 'scriptssss/' .. dir .. '/' .. '*', 'LUA' )
    for i = 1, #files do
        SCRIPTSLOADER.Include( 'scriptssss' .. '/' .. dir .. '/' .. files[i] )
    end

    if recursive ~= false then
        for i = 1, #dirs do
            SCRIPTSLOADER.Load( dir .. '/' .. dirs[i] )
        end
    end
end

if CLIENT then
    concommand.Add( '____printdoor', function( ply )
        local trace = ply:GetEyeTrace()
        local ent = trace.Entity
        if ent then
            print( ent )
            SetClipboardText( tostring( ent ) )
        end
    end )

    --- Prints the details of visible VGUI panels, including their size, position, and parent panel.
    -- @param panel Panel: The VGUI panel to inspect.
    -- @param indent string: The string used for indentation in the output (default is an empty string).
    local function PrintVisiblePanels(panel, indent)
        indent = indent or '' -- Set the default indentation

        -- Check if the panel is visible
        if panel:IsVisible() then
            -- Get the name of the parent panel, if there is one
            local parentName = panel:GetParent() and panel:GetParent():GetName() or 'None'
            
            print(indent .. panel:GetName() .. ' - Size: ' .. tostring(panel:GetSize()) .. ' - Pos: ' .. tostring(panel:GetPos()) .. ' - Parent: ' .. parentName)

            function panel:Paint(w, h)
                surface.SetDrawColor(10, 10, 10, 50) -- Use the standard method for drawing
                surface.DrawRect(0, 0, w, h)
            end

            -- Go through all child elements
            for _, child in pairs(panel:GetChildren()) do
                PrintVisiblePanels(child, indent .. '  ') -- Increase the indentation for child elements
            end
        end
    end

    -- Call the function for the root element (usually a screen)
    concommand.Add('CHECK_PANELS_VISIBLE', function()
        PrintVisiblePanels(vgui.GetWorldPanel())
    end)
end

hook.Add( 'InitPostEntity', 'LoadingScripts', function()
    hook.Remove( 'InitPostEntity', 'LoadingScripts' )
    --SCRIPTSLOADER.Load('asbubble', true)
    SCRIPTSLOADER.Load( 'integrations', true )
    SCRIPTSLOADER.Load( 'agenda', true )
    SCRIPTSLOADER.Load( 'animations', true )
    SCRIPTSLOADER.Load( 'votes', true )
    SCRIPTSLOADER.Load( 'demote', true )
    SCRIPTSLOADER.Load( 'disguise', true )
    SCRIPTSLOADER.Load( 'old-hud-elements', true )
    SCRIPTSLOADER.Load( 'admin', true )
    SCRIPTSLOADER.Load( 'nlr', true )
    SCRIPTSLOADER.Load( 'safe-zone', true )
    --SCRIPTSLOADER.Load( 'dntsystem', true )
end )

SCRIPTSLOADER.Load( 'lottery', true )
SCRIPTSLOADER.Load( 'permalist', true )
SCRIPTSLOADER.Load( 'fix_doors', true )
SCRIPTSLOADER.Load( 'optimization', true )
SCRIPTSLOADER.Load( 'boards', true )
Aevum = {}
--
hook.Add( 'LoadingJobs', 'LoadingScripts', function()
    SCRIPTSLOADER.Load( '_all_server', true )
    --SCRIPTSLOADER.Load( SCRIPTSLOADER.IsTwoServer and '_server_2' or '_server_1', true )
    if not SCRIPTSLOADER.IsTwoServer then
        SCRIPTSLOADER.Load( '_server_1', true )
    end 
end )
--PATH addons/ukrp_main_content/lua/autorun/afu_security_heavy.lua:
--Add Playermodel
player_manager.AddValidModel( "Ukrainian Soldier Heavy", "models/player/afu_security_heavy.mdl" )
--PATH addons/shaccessorysystem/lua/accessory/cl_interface.lua:
local matClose = Material("shenesis/accessory/close.png", "noclamp smooth")
local matList = Material("shenesis/accessory/list.png", "noclamp smooth")
local matStop = Material("shenesis/accessory/stop.png", "noclamp smooth")
local matSearch = Material("shenesis/accessory/search.png", "noclamp smooth")

local th, m, m5
local scale

local cacheL = {}
local cacheC = {}

local function L(s, ...)
	if (cacheL[s]) then
		return cacheL[s]
	end

	local tx = SH_ACC.Language[s] or s

	local a = {...}
	if (#a > 0) then
		return string.format(tx, ...)
	else
		cacheL[s] = tx
		return tx
	end
end
SH_ACC._L = L

local function C(s)
	if (cacheC[s]) then
		return cacheC[s]
	else
		local c = SH_ACC.Style[s]
		cacheC[s] = c

		return c
	end
end
SH_ACC._C = C

function SH_ACC:Label(t, f, c, p)
	local l = vgui.Create("DLabel", p)
	l:SetText(t)
	l:SetFont(f)
	l:SetColor(c)
	l:SizeToContents()

	return l
end

function SH_ACC:PaintScroll(panel)
	local styl = self.Style

	local scr = panel:GetVBar()
	scr.Paint = function(_, w, h)
		draw.RoundedBox(4, 0, 0, w, h, styl.bg)
	end

	scr.btnUp.Paint = function(_, w, h)
		draw.RoundedBox(4, 2, 0, w - 4, h - 2, styl.inbg)
	end
	scr.btnDown.Paint = function(_, w, h)
		draw.RoundedBox(4, 2, 2, w - 4, h - 2, styl.inbg)
	end

	scr.btnGrip.Paint = function(me, w, h)
		draw.RoundedBox(4, 2, 0, w - 4, h, styl.inbg)

		if (vgui.GetHoveredPanel() == me) then
			draw.RoundedBox(4, 2, 0, w - 4, h, styl.hover2)
		end

		if (me.Depressed) then
			draw.RoundedBox(4, 2, 0, w - 4, h, styl.hover2)
		end
	end
end

function SH_ACC:CreateAccIcon(acc, bg)
	local mdl = vgui.Create("DModelPanel", bg)
	mdl:SetModel(acc.mdl)
	mdl:Dock(FILL)
	mdl.LayoutEntity = function() end
	mdl:SetLookAt(Vector(0, 0, 0))
	mdl:SetFOV(10)
	mdl.Entity:SetSkin(acc.skin)
	-- TODO: bodygroups
	mdl.Entity:SetMaterial(acc.material)
	mdl.Entity:SetColor(acc.color)
	mdl.Entity:SetModelScale(acc.scale, 0)

	return mdl
end

function SH_ACC:TextEntry(parent)
	local tent = vgui.Create("DTextEntry", parent)
	tent:SetTextColor(C"text")
	tent:SetCursorColor(C"text")
	tent:SetFont("SH_ACC.Medium")
	tent:SetDrawLanguageID(false)
	tent.Paint = function(me, w, h)
		draw.RoundedBox(4, 0, 0, w, h, C"bg")

		if (me:HasFocus()) then
			draw.RoundedBox(4, 0, 0, w, h, C"hover")
		end
		me:DrawTextEntryText(me:GetTextColor(), me:GetHighlightColor(), me:GetCursorColor())
	end

	return tent
end

function SH_ACC:NumSlider(parent)
	local slider = vgui.Create("DNumSlider", parent)
	slider.TextArea:SetTextColor(C"text")
	slider.TextArea:SetFont("SH_ACC.Medium")
	slider.TextArea:SetDrawLanguageID(false)
	slider.TextArea:SetCursorColor(C"text")
	slider.Label:SetVisible(false)
	slider.Slider.Paint = function(me, w, h)
		draw.RoundedBox(0, 0, h * 0.5 - 1, w, 2, C"bg")
	end
	slider.Slider.Knob.Paint = function(me, w, h)
		draw.RoundedBox(4, 0, 0, w, h, C"header")

		if (me.Hovered) then
			surface.SetDrawColor(C"hover")
			surface.DrawRect(0, 0, w, h)
		end

		if (me:IsDown()) then
			surface.SetDrawColor(C"hover")
			surface.DrawRect(0, 0, w, h)
		end
	end

	return slider
end

function SH_ACC:Menu()
	local styl = self.Style

	if (IsValid(_SH_ACC_MENU)) then
		_SH_ACC_MENU:Remove()
	end

	scale = math.Clamp(ScrH() / 1080, 0.7, 1)

	local th = 48 * scale
	local m = th * 0.25

	local cancel = vgui.Create("DPanel")
	cancel:SetDrawBackground(false)
	cancel:StretchToParent(0, 0, 0, 0)
	cancel:MoveToFront()
	cancel:MakePopup()

	local pnl = vgui.Create("DPanel")
	pnl:SetDrawBackground(false)
	pnl:SetSize(20, 1)
	pnl.AddOption = function(me, text, callback)
		surface.SetFont("SH_ACC.MediumB")
		local wi, he = surface.GetTextSize(text)
		wi = wi + m * 2
		he = he + m

		me:SetWide(math.max(wi, me:GetWide()))
		me:SetTall(pnl:GetTall() + he)

		local btn = vgui.Create("DButton", me)
		btn:SetText(text)
		btn:SetFont("SH_ACC.MediumB")
		btn:SetColor(styl.text)
		btn:Dock(TOP)
		btn:SetSize(wi, he)
		btn.Paint = function(me, w, h)
			surface.SetDrawColor(styl.menu)
			surface.DrawRect(0, 0, w, h)

			if (me.Hovered) then
				surface.SetDrawColor(styl.hover)
				surface.DrawRect(0, 0, w, h)
			end

			if (me:IsDown()) then
				surface.SetDrawColor(styl.hover)
				surface.DrawRect(0, 0, w, h)
			end
		end
		btn.DoClick = function(me)
			callback()
			pnl:Close()
		end
	end
	pnl.Open = function(me)
		me:SetPos(gui.MouseX(), gui.MouseY())
		me:MakePopup()
	end
	pnl.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, 0.1, 0, function()
			me:Remove()
		end)
	end
	_SH_ACC_MENU = pnl

	cancel.OnMouseReleased = function(me, mc)
		pnl:Close()
	end
	cancel.Think = function(me)
		if (!IsValid(pnl)) then
			me:Remove()
		end
	end

	return pnl
end

function SH_ACC:MakeFrame(title)
	scale = math.Clamp(ScrH() / 1080, 0.7, 1)

	local pnl = vgui.Create("EditablePanel")
	pnl.Paint = function(me, w, h)
		if (me.m_fCreateTime) then
			Derma_DrawBackgroundBlur(me, me.m_fCreateTime)
		end

		draw.RoundedBox(4, 0, 0, w, h, C"bg")
	end
	pnl.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, 0.1, 0, function()
			me:Remove()
		end)

		me:OnClose()
	end
	pnl.OnClose = function()
	end

		th = 48 * scale
		m = th * 0.25
		m5 = m * 0.5

		local header = vgui.Create("DPanel", pnl)
		header:SetTall(th)
		header:Dock(TOP)
		header.Paint = function(me, w, h)
			draw.RoundedBoxEx(4, 0, 0, w, h, C"header", true, true, false, false)
		end

			local titlelbl = self:Label(title or "", "SH_ACC.Larger", C"text", header)
			titlelbl:Dock(FILL)
			titlelbl:DockMargin(m, 0, 0, 0)

			local close = vgui.Create("DButton", header)
			close:SetText("")
			close:SetWide(th)
			close:Dock(RIGHT)
			close.Paint = function(me, w, h)
				if (me.Hovered) then
					draw.RoundedBoxEx(4, 0, 0, w, h, C"close_hover", false, true, false, false)
				end

				if (me:IsDown()) then
					draw.RoundedBoxEx(4, 0, 0, w, h, C"hover", false, true, false, false)
				end

				surface.SetDrawColor(me:IsDown() and C"text_down" or C"text")
				surface.SetMaterial(matClose)
				surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16 * scale, 16 * scale, 0)
			end
			close.DoClick = function(me)
				pnl:Close()
			end

	pnl.SetTitle = function(me, tx)
		titlelbl:SetText(tx)
	end

	return pnl
end

function SH_ACC:CreateFonts(sc)
	local font = self.Font
	local font_bold = self.FontBold

	local sizes = {
		[12] = "Small",
		[16] = "Medium",
		[20] = "Large",
		[24] = "Larger",
		[32] = "Largest",
	}

	for s, n in pairs (sizes) do
		surface.CreateFont("SH_ACC." .. n, {font = font, size = s * sc})
		surface.CreateFont("SH_ACC." .. n .. "B", {font = font_bold, size = s * sc})
	end
end

function SH_ACC:ShowAdjustMenu(acc, contents, ilist)
	if (IsValid(_SH_ACC_ADJUST_MENU)) then
		_SH_ACC_ADJUST_MENU:QuickSave()
		_SH_ACC_ADJUST_MENU:Remove()
	end

	local MySelf = LocalPlayer()
	local fact = MySelf:SH_GetAccessoryAdjustFactor()
	local mdl = acc.mdl

	local w = ilist:GetWide()

	ilist:Dock(NODOCK)
	ilist:MoveTo(-(ilist:GetWide() + m * 2), ilist.y, 0.2)

	local apnl = vgui.Create("DScrollPanel", contents)
	apnl:SetSize(w, contents:GetTall() - m * 2)
	apnl:SetPos(w, m)
	apnl:MoveTo(m, apnl.y, 0.2, nil, nil, function()
		apnl:Dock(FILL)
	end)
	apnl.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true

		-- Save immediately
		me:QuickSave()

		apnl:Dock(NODOCK)
		apnl:MoveTo(apnl:GetWide() + m * 2, apnl.y, 0.2)

		ilist:MoveTo(m, ilist.y, 0.2, nil, nil, function()
			ilist:Dock(FILL)
			apnl:Remove()
		end)
	end
	apnl.Think = function(me)
		if (me.m_fNetworkIn and CurTime() >= me.m_fNetworkIn) then
			MySelf:SH_BroadcastAdjustment(mdl)
			MySelf:SH_SaveAdjustments()
			me.m_fNetworkIn = nil
		end
	end
	apnl.QuickSave = function(me)
		if (me.m_fNetworkIn) then
			me.m_fNetworkIn = 0
			me:Think()
		end
	end
	_SH_ACC_ADJUST_MENU = apnl

		local top = vgui.Create("DPanel", apnl)
		top:SetDrawBackground(false)
		top:SetTall(32 * scale)
		top:Dock(TOP)
		top:DockMargin(0, 0, 0, 0)

			local btn = vgui.Create("DImageButton", top)
			btn:SetImage("shenesis/accessory/previous.png")
			btn:SetWide(top:GetTall())
			btn:Dock(LEFT)
			btn:DockMargin(-6 * scale, 0, 0, 0)
			btn.DoClick = function(me)
				apnl:Close()
			end
			btn.DoRightClick = btn.DoClick
			if (!self.DisableKeyShortcuts) then
				btn.Think = function(me)
					if (input.IsMouseDown(MOUSE_4)) then
						btn:DoClick()
					end
				end
			end

		local pnl = vgui.Create("DPanel", apnl)
		pnl:SetTall(64 * scale)
		pnl:Dock(TOP)
		pnl:DockMargin(0, m5, 0, 0)
		pnl:DockPadding(m5, m5, m5, m5)
		pnl.Paint = function(me, w, h)
			draw.RoundedBox(4, 0, 0, w, h, C"inbg")
		end

			local lbl = self:Label(L"adjust" .. " - " .. acc.name, "SH_ACC.LargerB", C"text", pnl)
			lbl:Dock(TOP)

			local lbl = self:Label(L"adjust_desc", "SH_ACC.Medium", C"text", pnl)
			lbl:SetAutoStretchVertical(true)
			lbl:SetWrap(true)
			lbl:Dock(TOP)

		timer.Simple(0.1, function()
			if (!IsValid(pnl)) then
				return end

			pnl:SizeToChildren(true, true)
		end)

		local nosave = false
		local adjustments = {}
		local function AddAdjustMenu(tx, ad, fc, de)
			tx = L(tx)
			fc = fc or 1
			de = de or 0

			local adj = vgui.Create("DPanel", apnl)
			adj:SetTall(64 * scale)
			adj:Dock(TOP)
			adj:DockMargin(0, m5, 0, 0)
			adj:DockPadding(m5, m5, m5, m5)
			adj.Paint = pnl.Paint

			for _, c in ipairs ({"x", "y", "z"}) do
				local id = ad .. c

				local lbl = self:Label(tx .. " " .. c:upper(), "SH_ACC.LargeB", C"text", adj)
				lbl:Dock(TOP)

				local slider = self:NumSlider(adj)
				slider:Dock(TOP)
				slider:SetMinMax(de + -fact * fc, de + fact * fc)
				slider.m_fDefault = de
				table.insert(adjustments, slider)

				if (MySelf.SH_AccessoryAdjust and MySelf.SH_AccessoryAdjust[mdl]) then
					slider:SetValue(MySelf.SH_AccessoryAdjust[mdl][id] or de)
				else
					slider:SetValue(de)
				end

				slider.OnValueChanged = function(me, val)
					val = math.Clamp(val, -fact, fact)

					if (!MySelf.SH_AccessoryAdjust) then
						MySelf.SH_AccessoryAdjust = {}
					end

					if (!MySelf.SH_AccessoryAdjust[mdl]) then
						MySelf.SH_AccessoryAdjust[mdl] = {
							[id] = val,
						}
					else
						MySelf.SH_AccessoryAdjust[mdl][id] = val
					end

					MySelf.SH_AccessoryAdjust[mdl][ad] = nil

					if (nosave) then
						return end

					apnl.m_fNetworkIn = CurTime() + 0.5
				end
			end

			timer.Simple(0, function()
				if (!IsValid(adj)) then
					return end

				adj:SizeToChildren(true, true)
			end)
		end

		local function ShowAdjustElements()
			AddAdjustMenu("translate", "p", self.IndividiualAdjustFactor.translate)
			AddAdjustMenu("rotate", "a", self.IndividiualAdjustFactor.rotate)
			AddAdjustMenu("scale", "s", self.IndividiualAdjustFactor.scale, 1)
		end

		ShowAdjustElements()

		local reset = vgui.Create("DButton", apnl)
		reset:SetText(L"reset_adjustments")
		reset:SetColor(C"text")
		reset:SetFont("SH_ACC.LargeB")
		reset:SetTall(draw.GetFontHeight(reset:GetFont()) + m5)
		reset:Dock(TOP)
		reset:DockMargin(0, m5, 0, 0)
		reset.Paint = function(me, w, h)
			draw.RoundedBox(4, 0, 0, w, h, C"inbg")

			if (me.Hovered) then
				surface.SetDrawColor(C"hover")
				surface.DrawRect(0, 0, w, h)
			end

			if (me:IsDown()) then
				surface.SetDrawColor(C"hover")
				surface.DrawRect(0, 0, w, h)
			end
		end
		reset.DoClick = function(me)
			MySelf:SH_ResetAdjustments(mdl)

			nosave = true
			for _, v in ipairs (adjustments) do
				v:SetValue(v.m_fDefault)
			end
			nosave = false
		end
end

function SH_ACC:ShowConfirmMenu(title, text, callback)
	if (IsValid(_SH_ACC_CONFIRM)) then
		_SH_ACC_CONFIRM:Remove()
	end

	scale = math.Clamp(ScrH() / 1080, 0.7, 1)
	local wi, he = 200 * scale, 160 * scale

	local cancel = vgui.Create("DPanel")
	cancel:SetDrawBackground(false)
	cancel:StretchToParent(0, 0, 0, 0)
	cancel:MoveToFront()
	cancel:MakePopup()

	local pnl = SH_ACC:MakeFrame(L(title))
	pnl:SetSize(wi, he)
	pnl:Center()
	pnl:MakePopup()
	pnl.m_fCreateTime = SysTime()
	_SH_ACC_CONFIRM = pnl

	cancel.OnMouseReleased = function(me, mc)
		if (mc == MOUSE_LEFT) then
			pnl:Close()
		end
	end
	cancel.Think = function(me)
		if (!IsValid(pnl)) then
			me:Remove()
		end
	end

		local th = 48 * scale
		local m = th * 0.25

		local body = vgui.Create("DPanel", pnl)
		body:SetDrawBackground(false)
		body:Dock(FILL)
		body:DockPadding(m, 0, m, m)

			local tx
			if (istable(text)) then
				tx = L(unpack(text))
			else
				tx = L(text)
			end

			local tx = self:Label(tx, "SH_ACC.Large", C"text", body)
			tx:SetContentAlignment(5)
			tx:Dock(FILL)

			local btns = vgui.Create("DPanel", body)
			btns:SetDrawBackground(false)
			btns:Dock(BOTTOM)

				local yes = vgui.Create("DButton", btns)
				yes:SetText(L"yes")
				yes:SetColor(C"text")
				yes:SetFont("SH_ACC.Medium")
				yes:Dock(FILL)
				yes.Paint = function(me, w, h)
					draw.RoundedBox(4, 0, 0, w, h, C"inbg")

					if (me.Hovered) then
						surface.SetDrawColor(C"hover")
						surface.DrawRect(0, 0, w, h)
					end

					if (me:IsDown()) then
						surface.SetDrawColor(C"hover")
						surface.DrawRect(0, 0, w, h)
					end
				end
				yes.DoClick = function()
					pnl:Close()
					callback()
				end

				local no = vgui.Create("DButton", btns)
				no:SetText(L"no")
				no:SetColor(C"text")
				no:SetFont("SH_ACC.Medium")
				no:Dock(RIGHT)
				no:DockMargin(m, 0, 0, 0)
				no.Paint = yes.Paint
				no.DoClick = function()
					pnl:Close()
				end

	pnl.OnFocusChanged = function(me, gained)
		if (!gained) then
			timer.Simple(0, function()
				if (!IsValid(me) or vgui.GetKeyboardFocus() == entry) then
					return end

				me:Close()
			end)
		end
	end

	pnl:SetWide(math.max(tx:GetWide() + m * 2, pnl:GetWide()))
	pnl:CenterHorizontal()

	no:SetWide(pnl:GetWide() * 0.5 - m * 1.5)

	pnl:SetAlpha(0)
	pnl:AlphaTo(255, 0.1)
end

local mdlcam_pos = CreateClientConVar("sh_acc_campos", "50 50 50", true, false)
local mdlcam_lookat = CreateClientConVar("sh_acc_lookat", "0 0 40", true, false)
local mdlcam_fov = CreateClientConVar("sh_acc_fov", "30", true, false)
local mdlcam_ang = CreateClientConVar("sh_acc_angle", "0", true, false)

function SH_ACC:ChangeEquipment(id, eq)
	net.Start("SH_ACC_CHANGE")
		net.WriteString(id)
		net.WriteBool(eq)
	net.SendToServer()

	surface.PlaySound("shenesis/generic_cloth_movement" .. math.random(1, 16) .. ".ogg")
end

function SH_ACC:ShowBuyMenu()
	if (IsValid(_SH_ACC_BUYMENU)) then
		_SH_ACC_BUYMENU:Remove()
	end

	local curcat
	local previewing

	local MySelf = LocalPlayer()
	scale = math.Clamp(ScrH() / 1080, 0.7, 1)
	self:CreateFonts(scale)

	local wi, he = 1100 * scale, 800 * scale

	local title = L"accessory_vendor"
	local swep = MySelf:SH_HasAccessoryChanger()
	if (!MySelf:SH_NearAccessoryVendor() and swep) then
		title = swep:GetPrintName()
	end

	local frame = self:MakeFrame(title)
	frame:SetSize(wi, he)
	frame:Center()
	frame:MakePopup()
	if (self.DrawBackgroundBlur) then
		frame.m_fCreateTime = SysTime()
	end
	frame.OnClose = function(me)
		if (previewing) then
			if (!MySelf:SH_HasAccessoryEquipped(previewing[1])) then
				MySelf:SH_RemoveAccessory(previewing[1])
			end
			previewing = nil
		end

		if (IsValid(_SH_ACC_MENU)) then
			_SH_ACC_MENU:Remove()
		end
		if (IsValid(_SH_ACC_CONFIRM)) then
			_SH_ACC_CONFIRM:Remove()
		end
		if (IsValid(_SH_ACC_ADJUST_MENU)) then
			_SH_ACC_ADJUST_MENU:QuickSave()
			_SH_ACC_ADJUST_MENU:Remove()
		end
	end
	frame.m_bEscaping = false
	frame.Think = function(me)
		if (input.IsKeyDown(KEY_ESCAPE)) then
			if (frame.m_bEscaping) then
				return end

			frame.m_bEscaping = true

			gui.HideGameUI()
			timer.Simple(0, function()
				gui.HideGameUI()
			end)

			local focus = vgui.GetKeyboardFocus()
			if (IsValid(focus) and focus:GetName() == "DTextEntry") then
				focus:KillFocus()
				TextEntryLoseFocus()
				return
			end

			me:Close()
		else
			frame.m_bEscaping = false
		end
	end
	_SH_ACC_BUYMENU = frame

		local body = vgui.Create("DPanel", frame)
		body:SetDrawBackground(false)
		body:Dock(FILL)

			local contents = vgui.Create("DPanel", body)
			contents:SetDrawBackground(false)
			contents:SetWide(wi - th)
			contents:Dock(FILL)
			contents:DockPadding(m, m, m, m)
			contents.m_iBorder = m
			frame.m_Contents = contents

				local ilist = vgui.Create("DScrollPanel", contents)
				self:PaintScroll(ilist)
				ilist:StretchToParent(0, 0, 0, 0)
				ilist:Dock(FILL)
				ilist.Think = function()
					local hover = vgui.GetHoveredPanel()
					if (IsValid(hover) and hover.m_Accessory and !frame.m_bClosing) then
						if (!MySelf:SH_HasAccessoryEquipped(hover.m_Accessory.id)) then
							if (previewing and !MySelf:SH_HasAccessoryEquipped(previewing[1])) then
								MySelf:SH_RemoveAccessory(previewing[1])
							end

							previewing = {hover.m_Accessory.id, hover.m_Accessory.slots}
							local cs = MySelf:SH_AddAccessory(previewing[1], true)
							if (IsValid(cs)) then
								_SH_ACC_BUYMENU.m_PreviewModel = cs
							end
						end
					else
						if (previewing) then
							if (MySelf:SH_HasAccessoryEquipped(previewing[1])) then
								previewing = nil
							else
								MySelf:SH_RemoveAccessory(previewing[1])
								previewing = nil
							end
						end
					end

					_SH_ACC_BUYMENU.m_Previewing = previewing
				end

			local function AddAccessoryPanel(acc, title, slot)
				local ph = 64 * scale + (title and (16 * scale + m5) or 0)

				local pnl = vgui.Create("DPanel", ilist)
				pnl:SetDrawBackground(false)
				pnl:SetTall(ph)
				pnl:Dock(TOP)
				pnl:DockMargin(0, 0, 0, m5)

					local function DrawBG(me, w, h, col)
						if (me.m_QuickSwitch) then
							draw.RoundedBoxEx(4, 0, 0, w, h, col, true, true, false, false)
						else
							draw.RoundedBox(4, 0, 0, w, h, col)
						end
					end

					local btnbody = vgui.Create("DButton", pnl)
					btnbody:SetText("")
					btnbody:Dock(FILL)
					btnbody:DockPadding(m5, m5, m5, m5)
					btnbody.Paint = function(me, w, h)
						DrawBG(me, w, h, C"inbg")

						if (me.Hovered) then
							DrawBG(me, w, h, C"hover")
						end

						if (me:IsDown()) then
							DrawBG(me, w, h, C"hover")
						end
					end

						-- overview accpnl
						if (title) then
							local lbl = self:Label(L(title), "SH_ACC.MediumB", C"text", btnbody)
							lbl:Dock(TOP)
							lbl:DockMargin(0, 0, 0, m5)
							pnl.m_Title = lbl
						else -- shop category accpnl: can preview
							pnl.m_Accessory = acc
							btnbody.m_Accessory = pnl.m_Accessory
						end

						local itm = vgui.Create("DPanel", btnbody)
						itm:SetDrawBackground(false)
						itm:SetMouseInputEnabled(false)
						itm:Dock(FILL)

							local bg = vgui.Create("DPanel", itm)
							bg:Dock(LEFT)
							bg.Think = function(me)
								me:SetWide(itm:GetTall())
							end
							bg.Paint = frame.Paint

								if (acc) then
									SH_ACC:CreateAccIcon(acc, bg)
								end

							local lbl = self:Label(acc and acc.name or L"none", "SH_ACC.LargeB", C"text", itm)
							lbl:SetContentAlignment(title and 5 or 7)
							lbl:Dock(title and FILL or TOP)
							lbl:DockMargin(m5, 0, 0, 0)

							local textlbl
							if (acc and !title) then
								local lbls = vgui.Create("DPanel", itm)
								lbls:SetDrawBackground(false)
								lbls:SetTall(draw.GetFontHeight("SH_ACC.Medium"))
								lbls:Dock(TOP)
								lbls:DockMargin(m5, 0, 0, 0)

									local lbl = self:Label("", "SH_ACC.Medium", col, lbls)
									lbl:Dock(LEFT)
									lbl.Update = function(me)
										local tx = acc.price > 0 and SH_ACC.formatMoney(acc.price * MySelf:SH_GetAccessoryPurchaseFrac()) or L"free"
										local col = SH_ACC.CanAfford(LocalPlayer(), acc.price * MySelf:SH_GetAccessoryPurchaseFrac()) and C"can_afford" or C"cant_afford"

										if (MySelf:SH_HasAccessory(acc.id)) then
											local eq = MySelf:SH_HasAccessoryEquipped(acc.id)
											tx = eq and L"equipped" or L"possessed"
											col = eq and C"equipped" or C"possessed"
										end

										me:SetText(tx)
										me:SetTextColor(col)
										me:SizeToContents()
									end
									textlbl = lbl

									if (acc.canPurchase or acc.usergroups or acc.steamids) then
										local lbl = self:Label(" - " .. L"restricted", "SH_ACC.Medium", C"restricted", lbls)
										lbl:Dock(LEFT)
									end

									if (acc.jobs or acc.jobsexclude) then
										local lbl = self:Label(" - " .. L"job_specific", "SH_ACC.Medium", C"restricted", lbls)
										lbl:Dock(LEFT)
									end

								-- slot text
								local t = {}
								for sl, tx in SortedPairs (self.SlotText) do
									if (bit.band(acc.slots, sl) > 0) then
										table.insert(t, L(tx))
									end
								end

								if (#t > 1) then
									local lbl = self:Label(L("this_accessory_covers_x", table.concat(t, ", ")), "SH_ACC.Medium", C"text", itm)
									lbl:Dock(TOP)
									lbl:DockMargin(m5, 0, 0, 0)
								end
							end

					btnbody.DoClick = function(me, rmb)
						if (title and !rmb) then
							if (me.m_bQuickSwitchAnim) then
								return end

							me.m_bQuickSwitchAnim = true

							local b = !me.m_bQuickSwitching
							me.m_bQuickSwitching = b

							me:Dock(TOP)
							pnl:Stop()
							pnl:SizeTo(pnl:GetWide(), b and (ph + m5 * 3 + 48 * scale + 20 * scale) or ph, 0.2, nil, nil, function()
								me.m_bQuickSwitchAnim = false

								if (!b) then
									if (IsValid(me.m_QuickSwitch)) then
										me.m_QuickSwitch:Remove()
									end
									me.m_QuickSwitch = nil

									-- die
									timer.Simple(0, function()
										if (IsValid(me)) then
											me:Dock(FILL)
										end
									end)
								end
							end)

							if (b) then
								if (IsValid(me.m_QuickSwitch)) then
									me.m_QuickSwitch:Remove()
								end

								local p = vgui.Create("DPanel", pnl)
								p:Dock(FILL)
								p:DockPadding(m5, m5, m5, m5)
								p.Paint = function(me, w, h)
									draw.RoundedBoxEx(4, 0, 0, w, h, C"inbg", false, false, true, true)
								end
								me.m_QuickSwitch = p

									local scroll = vgui.Create("DScrollPanel", p)
									SH_ACC:PaintScroll(scroll)
									scroll:Dock(FILL)

										local ilist = vgui.Create("DIconLayout", scroll)
										ilist:SetSpaceX(m5)
										ilist:SetSpaceY(m5)
										ilist:Dock(FILL)

									local deftext = L"quick_switch"

									local name = vgui.Create("DPanel", p)
									name:SetTall(20 * scale)
									name:Dock(BOTTOM)
									name.Paint = function(me, w, h)
										draw.RoundedBox(4, 0, 0, w, h, C"bg")
										draw.SimpleText(me.m_sText, "SH_ACC.Medium", w * 0.5, h * 0.5, C"text", TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
									end
									name.m_sText = deftext

									-- Take off
									local takeoff = vgui.Create("DButton", ilist)
									takeoff:SetText("")
									takeoff:SetSize(32 * scale, 32 * scale)
									takeoff.Paint = function(me, w, h)
										DrawBG(me, w, h, C"bg")

										if (me.Hovered) then
											DrawBG(me, w, h, C"hover")
										end

										if (me:IsDown()) then
											DrawBG(me, w, h, C"hover")
										end
									end
									takeoff.OnCursorEntered = function(me)
										name.m_sText = L"unequip"
									end
									takeoff.OnCursorExited = function(me)
										name.m_sText = deftext
									end
									takeoff.DoClick = function(me)
										self:ChangeEquipment(acc.id, false)
									end
									takeoff:SetVisible(acc ~= nil)

										local img = vgui.Create("DPanel", takeoff)
										img:SetMouseInputEnabled(false)
										img:Dock(FILL)
										img.Paint = function(me, w, h)
											surface.SetDrawColor(C"text")
											surface.SetMaterial(matStop)
											surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16 * scale, 16 * scale, 0)
										end

									-- Actual accessories
									for accid in SortedPairs (MySelf.SH_AccessoryInfo.inventory) do
										if (acc and acc.id == accid) then
											continue end

										local acc2 = SH_ACC:GetAccessory(accid)
										if (acc2 and bit.band(acc2.slots, slot) > 0) then
											local bg = vgui.Create("DButton", ilist)
											bg:SetText("")
											bg:SetSize(32 * scale, 32 * scale)
											bg.Paint = takeoff.Paint
											bg.OnCursorEntered = function(me)
												name.m_sText = acc2.name
											end
											bg.OnCursorExited = takeoff.OnCursorExited
											bg.DoClick = function(me)
												self:ChangeEquipment(accid, true)
											end
											bg.m_Accessory = acc2 -- Hover

												local mdl = SH_ACC:CreateAccIcon(acc2, bg)
												mdl:SetMouseInputEnabled(false)
										end
									end
							end
						elseif (acc) then
							local m = SH_ACC:Menu()

							local haveitem = MySelf:SH_HasAccessory(acc.id)
							if (title) or (haveitem) then
								if (haveitem and MySelf:SH_HasAccessoryEquipped(acc.id)) then
									m:AddOption(L"adjust", function()
										self:ShowAdjustMenu(acc, contents, ilist)
									end)

									local mdl = acc.mdl
									if (MySelf.SH_AccessoryAdjust and MySelf.SH_AccessoryAdjust[mdl]) then
										m:AddOption(L"reset_adjustments", function()
											MySelf:SH_ResetAdjustments(mdl)
										end)
									end

									m:AddOption(L"unequip", function()
										self:ChangeEquipment(acc.id, false)
									end)
								else
									m:AddOption(L"equip", function()
										self:ChangeEquipment(acc.id, true)
									end)
								end

								if (MySelf:SH_CanSellAccessories() and MySelf:SH_NearAccessoryVendor()) then
									m:AddOption(L"sell", function()
										SH_ACC:ShowConfirmMenu("confirm_action", {"sell_confirm", acc.name, SH_ACC.formatMoney(math.Round(acc.price * MySelf:SH_GetAccessorySellFrac()))}, function()
											net.Start("SH_ACC_SELL")
												net.WriteString(acc.id)
											net.SendToServer()

											surface.PlaySound("ambient/levels/labs/coinslot1.wav")
										end)
									end)
								end
							else
								if (!MySelf:SH_HasAccessory(acc.id) and MySelf:SH_NearAccessoryVendor()) then
									m:AddOption(L"purchase" .. " (" .. SH_ACC.formatMoney(acc.price * MySelf:SH_GetAccessoryPurchaseFrac()) .. ")", function()
										SH_ACC:ShowConfirmMenu("confirm_action", {"buy_confirm", acc.name, SH_ACC.formatMoney(acc.price * MySelf:SH_GetAccessoryPurchaseFrac())}, function()
											net.Start("SH_ACC_PURCHASE")
												net.WriteString(acc.id)
											net.SendToServer()

											surface.PlaySound("ambient/levels/labs/coinslot1.wav")
										end)
									end)
								end
							end

							m:Open()
						end
					end
					btnbody.DoRightClick = function(me)
						me:DoClick(true)
					end

				pnl.Think = function()
					if (acc and textlbl) then
						textlbl:Update()
					end
				end

				return pnl
			end

			local overv = false

			contents.RefreshOverview = function(me, refresh)
				if (refresh and !overv) then
					return end

				overv = true

				if (IsValid(_SH_ACC_ADJUST_MENU)) then
					_SH_ACC_ADJUST_MENU:Close()
				end

				if (IsValid(_SH_ACC_POPULATE_DUMMY)) then
					_SH_ACC_POPULATE_DUMMY:Remove()
				end

				timer.Destroy("_SH_ACC_POPULATE_LIST")

				if (IsValid(contents.m_SearchBar)) then
					contents.m_SearchBar:Remove()
				end
				if (IsValid(contents.m_Score)) then
					contents.m_Score:Remove()
				end

				ilist:Clear()

				-- Show acc count if need be
				local limit = MySelf:SH_GetAccessoryLimit()
				if (limit > 0) then
					local num = MySelf:SH_GetNumEquippedAccessories()

					local pnl = vgui.Create("DPanel", ilist)
					pnl:Dock(TOP)
					pnl:DockMargin(0, 0, 0, m5)
					pnl.Paint = function(me, w, h)
						draw.RoundedBox(4, 0, 0, w, h, C"inbg")
					end

						local lbl = self:Label(L"accessory_limit" .. ": " .. num .. "/" .. limit, "SH_ACC.Medium", num >= limit and C"cant_afford" or C"text", pnl)
						lbl:SetContentAlignment(5)
						lbl:Dock(FILL)
				end

				-- Build category pnls
				local notadded = table.Copy(self.SlotText)

				local toadd = {}
				for id, cs in pairs (MySelf.SH_AccessoryInfo.equipped) do
					local acc = self:GetAccessory(id)
					if (!acc) then
						continue end

					for sl, tx in pairs (self.SlotText) do
						if (bit.band(acc.slots, sl) > 0) then
							toadd[sl] = id
						end
					end
				end

				local pnls = {}
				for sl, id in pairs (notadded) do
					local cls = toadd[sl]
					if (cls) then
						if (!pnls[cls]) then
							pnls[cls] = AddAccessoryPanel(self:GetAccessory(cls), id, sl)
						else
							local lbl = pnls[cls].m_Title
							if (IsValid(lbl)) then
								lbl:SetText(lbl:GetText() .. ", " .. L(id))
							end
						end
					else
						AddAccessoryPanel(nil, id, sl)
					end
				end
			end
			contents.RefreshCategory = function(me, slot)
				overv = false

				if (IsValid(_SH_ACC_ADJUST_MENU)) then
					_SH_ACC_ADJUST_MENU:Close()
				end

				if (IsValid(_SH_ACC_POPULATE_DUMMY)) then
					_SH_ACC_POPULATE_DUMMY:Remove()
				end

				timer.Destroy("_SH_ACC_POPULATE_LIST")

				ilist:Clear()
				ilist.VBar:SetScroll(0)

				local have, num = 0, 0
				local itemz = {}
				local function PopulateList(slot, filter)
					if (IsValid(_SH_ACC_POPULATE_DUMMY)) then
						_SH_ACC_POPULATE_DUMMY:Remove()
					end

					timer.Destroy("_SH_ACC_POPULATE_LIST")

					for _, v in pairs (itemz) do
						if (IsValid(v)) then
							v:Remove()
						end
					end

					--
					if (filter == "") then
						filter = nil
					end

					local toadd = {}
					local delayed = {}
					for id, acc in SortedPairsByMemberValue (self.List, "name") do
						if not (bit.band(acc.slots, slot) > 0) then
							continue end

						num = num + 1

						if (MySelf:SH_HasAccessory(acc.id)) then
							have = have + 1
						end

						if (filter and !string.find(acc.name:lower(), filter)) then
							continue end

						-- Don't delay population if searching
						table.insert((!filter and #toadd >= 10) and delayed or toadd, acc)
					end

					for _, acc in pairs (toadd) do
						table.insert(itemz, AddAccessoryPanel(acc))
					end

					if (#delayed > 0) then
						-- Add a dummy panel to fool the scrollbar..!
						local dummy = vgui.Create("DPanel", ilist)
						dummy:SetDrawBackground(false)
						dummy:SetTall(64 * scale * #delayed)
						dummy:Dock(TOP)
						_SH_ACC_POPULATE_DUMMY = dummy

						-- This is probably the ugliest thing alive to avoid a potential freeze when loading up big lists
						-- but it WORKS
						timer.Create("_SH_ACC_POPULATE_LIST", 0.01, 0, function()
							if (#delayed <= 0 or !IsValid(_SH_ACC_BUYMENU)) then
								timer.Destroy("_SH_ACC_POPULATE_LIST")
								if (IsValid(dummy)) then
									for _, v in pairs (dummy:GetChildren()) do
										if (IsValid(v) and IsValid(ilist)) then
											v:SetParent(ilist)
										end
									end

									dummy:Remove()
								end

								return
							end

							for i = 1, 3 do
								if (#delayed <= 0) then
									return end

								local acc = table.remove(delayed, 1)
								local pnl = AddAccessoryPanel(acc)
								pnl:SetParent(dummy)
								table.insert(itemz, pnl)
							end
						end)
					end
				end

				-- Search bar
				if (IsValid(contents.m_SearchBar)) then
					contents.m_SearchBar:Remove()
				end

				local pnl = vgui.Create("DPanel", contents)
				pnl:SetTall(24 * scale + m5 * 2)
				pnl:Dock(TOP)
				pnl:DockMargin(0, 0, 0, m5)
				pnl:DockPadding(m5, m5, m5, m5)
				pnl.Paint = function(me, w, h)
					draw.RoundedBox(4, 0, 0, w, h, C"inbg")
				end
				contents.m_SearchBar = pnl

					local tent = self:TextEntry(pnl)
					tent:SetText(filter or "")
					tent:Dock(FILL)
					tent.Paint = function(me, w, h)
						draw.RoundedBox(4, 0, 0, w, h, C"bg")

						surface.SetDrawColor(me:GetTextColor())
						surface.SetMaterial(matSearch)
						surface.DrawTexturedRect(w - 16 * scale - 2, h * 0.5 - 8 * scale, 16 * scale, 16 * scale)

						if (me:GetText() == "" and !me:HasFocus()) then
							draw.SimpleText(L"search" .. ".. " .. (self.DisableKeyShortcuts and "" or "(Ctrl+F)"), me:GetFont(), 2, h * 0.5, me:GetTextColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
						else
							draw.RoundedBox(4, 0, 0, w, h, C"hover")
							me:DrawTextEntryText(me:GetTextColor(), me:GetHighlightColor(), me:GetCursorColor())
						end
					end
					tent.OnChange = function(me)
						local tx = me:GetValue():lower():Trim()
						PopulateList(slot, tx)
					end
					if (!self.DisableKeyShortcuts) then
						tent.Think = function(me)
							if (input.IsKeyDown(KEY_LCONTROL) or input.IsKeyDown(KEY_RCONTROL)) and (input.IsKeyDown(KEY_F)) then
								if (me:HasFocus()) then
									me:SelectAllText()
								else
									me:RequestFocus()
								end
							end
						end
					end

				-- Count
				if (IsValid(contents.m_Score)) then
					contents.m_Score:Remove()
				end

				local score = vgui.Create("DPanel", contents)
				score:SetTall(16 * scale + m5 * 2)
				score:Dock(BOTTOM)
				score:DockMargin(0, m5, 0, 0)
				score:DockPadding(m5, m5, m5, m5)
				score.Paint = function(me, w, h)
					draw.RoundedBox(4, 0, 0, w, h, C"inbg")
					draw.RoundedBox(4, m5, m5, w - m, h - m, C"bg")

					local tx = have .. "/" .. num
					draw.SimpleText(tx, "SH_ACC.Medium", w * 0.5, h * 0.5, C"text", TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					local x, y = me:LocalToScreen(0, 0)
					render.SetScissorRect(x, y, x + w * (have / num), y + h, true)
						draw.RoundedBox(4, m5, m5, (w - m) * (have / num), h - m, C"possessed")
						draw.SimpleText(tx, "SH_ACC.Medium", w * 0.5, h * 0.5, C"text_down", TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					render.SetScissorRect(0, 0, 0, 0, false)
				end
				contents.m_Score = score

				-- The hats
				PopulateList(slot)
			end

			local mdlpanel = vgui.Create("DPanel", body)
			mdlpanel:SetWide(wi * 0.35)
			mdlpanel:Dock(RIGHT)
			mdlpanel:DockMargin(0, m, m, m)
			mdlpanel.Paint = function(me, w, h)
				draw.RoundedBox(4, 0, 0, w, h, C"inbg")
			end

				local mdl = vgui.Create("DModelPanel", mdlpanel)
				mdl:SetModel(MySelf:GetModel())
				mdl:SetCamPos(Vector(mdlcam_pos:GetString()))
				mdl:SetLookAt(Vector(mdlcam_lookat:GetString()))
			if IsValid(mdl.Entity) then
				mdl.Entity:SetAngles(Angle(0, mdlcam_ang:GetInt(), 0))
				mdl:SetFOV(mdlcam_fov:GetInt())
				mdl:Dock(FILL)
				mdl.LayoutEntity = function() end
				mdl.PostDrawModel = function(me, ent)
					self:DrawAccessories(ent, MySelf)
				end
				mdl.m_iX = 0
				mdl.m_iY = 0
				mdl.PaintOver = function(me, w, h)
					if (me.m_bCursorIn) then
						local c = table.Copy(C"text")
						c.a = (me.m_bDragging or me.m_bZooming or me.m_bMoving) and c.a * 0.5 or c.a

						local f = "SH_ACC.Medium"
						local fh = draw.GetFontHeight(f)
						draw.SimpleText(L"left_click_help", f, m5, m5, c)
						draw.SimpleText(L"right_click_help", f, m5, m5 + fh, c)
						draw.SimpleText(L"middle_click_help", f, m5, m5 + fh * 2, c)
					end
				end
				mdl.Think = function(me)
					if (me.m_bDragging and !input.IsMouseDown(MOUSE_LEFT)) then
						me.m_bDragging = false
					end

					if (me.m_bZooming and !input.IsMouseDown(MOUSE_RIGHT)) then
						me.m_bZooming = false
					end

					if (me.m_bMoving and !input.IsMouseDown(MOUSE_MIDDLE)) then
						me.m_bMoving = false
					end

					-- Save camera pos
					if (me.m_fNextSave and RealTime() >= me.m_fNextSave) then
						RunConsoleCommand("sh_acc_campos", tostring(me:GetCamPos()))
						RunConsoleCommand("sh_acc_lookat", tostring(me:GetLookAt()))
						RunConsoleCommand("sh_acc_fov", tostring(me:GetFOV()))
						RunConsoleCommand("sh_acc_angle", tostring(me.Entity:GetAngles()[2]))
						me.m_fNextSave = nil
					end
				end
				mdl.OnMousePressed = function(me, mc)
					if (mc == MOUSE_LEFT) then
						me.m_bDragging = true
						me.m_iX = gui.MouseX()
					elseif (mc == MOUSE_RIGHT) then
						me.m_bZooming = true
						me.m_iY = gui.MouseY()
					elseif (mc == MOUSE_MIDDLE) then
						me.m_bMoving = true
						me.m_iX = gui.MouseX()
						me.m_iY = gui.MouseY()
					end
				end
				mdl.OnCursorMoved = function(me)
					local ang = me.Entity:GetAngles()
					local modif = me.m_bDragging or me.m_bZooming or me.m_bMoving

					if (me.m_bDragging) then
						local mx = gui.MouseX()
						local xdif = mx - me.m_iX

						me.m_iX = mx
						me.Entity:SetAngles(Angle(0, (ang[2] + xdif * 0.5) % 360, 0))
					end

					if (me.m_bZooming) then
						local my = gui.MouseY()
						local ydif = my - me.m_iY

						me.m_iY = my
						me:SetFOV(math.Clamp(me:GetFOV() + ydif * 0.33, 5, 100))
					end

					if (me.m_bMoving) then
						local mx, my = gui.MousePos()
						local xdif = mx - me.m_iX
						local ydif = my - me.m_iY
						local cp = me:GetCamPos()
						local la = me:GetLookAt()

						me.m_iX = mx
						me.m_iY = my
						me:SetCamPos(Vector(cp.x + xdif * 0.1, cp.y, cp.z + ydif * 0.15))
						me:SetLookAt(Vector(la.x + xdif * 0.1, la.y, la.z + ydif * 0.15))
					end

					if (modif) then
						me.m_fNextSave = RealTime() + 0.1
					end

					me.m_bCursorIn = true
				end
				mdl.OnCursorExited = function(me)
					local mx, my = gui.MousePos()

					if (me.m_bDragging or me.m_bZooming or me.m_bMoving) then
						local rx, ry = me:ScreenToLocal(mx, my)
						if (rx <= 0) then
							rx, ry = me:LocalToScreen(me:GetWide(), 0)
							input.SetCursorPos(rx, my)
							me.m_iX = rx
						elseif (rx >= me:GetWide()) then
							rx, ry = me:LocalToScreen(0, 0)
							input.SetCursorPos(rx, my)
							me.m_iX = rx
						end

						local rx, ry = me:ScreenToLocal(mx, my)
						if (ry <= 0) then
							rx, ry = me:LocalToScreen(0, me:GetTall())
							input.SetCursorPos(mx, ry)
							me.m_iY = ry
						elseif (ry >= me:GetTall()) then
							rx, ry = me:LocalToScreen(0, 0)
							input.SetCursorPos(mx, ry)
							me.m_iY = ry
						end
					end

					me.m_bCursorIn = false
				end
				mdl.OnMouseReleased = function(me, mc)
					if (mc == MOUSE_LEFT) then
						me.m_bDragging = false
					elseif (mc == MOUSE_RIGHT) then
						me.m_bZooming = false
					elseif (mc == MOUSE_MIDDLE) then
						me.m_bMoving = false
					end
				end
			end

			local toggled = cookie.GetNumber("SH_ACC.NavBarOff", 0) == 0

			local navbar = vgui.Create("DPanel", body)
			navbar:SetWide(toggled and th * 3 or th)
			navbar:Dock(LEFT)
			navbar:DockPadding(0, th, 0, 0)
			navbar.Paint = mdlpanel.Paint

				local togglenavbar = vgui.Create("DButton", navbar)
				togglenavbar:SetText("")
				togglenavbar:SetToolTip(L"toggle")
				togglenavbar:SetSize(th, th)
				togglenavbar.Paint = function(me, w, h)
					surface.SetDrawColor(C"text")
					surface.SetMaterial(matList)
					surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 24 * scale, 24 * scale, 0)
				end
				togglenavbar.DoClick = function()
					toggled = !toggled
					cookie.Set("SH_ACC.NavBarOff", toggled and 0 or 1)

					navbar:Stop()
					navbar:SizeTo(toggled and th * 3 or th, -1, 0.1, 0, 0.2)
				end

				local cats = {}
				local function AddCategory(text, icon, callback, i)
					local tx = L(text)

					local btn = vgui.Create("DButton", navbar)
					btn:SetText("")
					btn:SetToolTip(tx)
					btn:SetTall(th)
					btn:Dock(TOP)
					btn.Paint = function(me, w, h)
						if (me.Hovered) then
							surface.SetDrawColor(C"hover")
							surface.DrawRect(0, 0, w, h)
						end

						if (me:IsDown()) then
							surface.SetDrawColor(C"hover")
							surface.DrawRect(0, 0, w, h)
						end

						surface.SetDrawColor(C"text")
						surface.SetMaterial(icon)
						surface.DrawTexturedRectRotated(24 * scale, 24 * scale, 24 * scale, 24 * scale, 0)

						if (i and curcat == i) then
							surface.SetDrawColor(C"header")
							surface.DrawRect(0, 0, th * 0.1, h)
						end
					end
					btn.DoClick = function(me)
						callback(me)
					end
					btn.m_sText = tx

						local lbl = self:Label(tx, "SH_ACC.Medium", C"text", btn)
						lbl:Dock(LEFT)
						lbl:DockMargin(th, 0, 0, 0)

					cats[#cats + 1] = btn

					return btn
				end

				AddCategory("overview", Material("shenesis/accessory/user.png", "noclamp smooth"), function(me)
					contents:RefreshOverview()

					--
					curcat = 0
					frame:SetTitle(title .. " - " .. me.m_sText)
				end, 0):DoClick()

				for i, cat in ipairs (self.ShopCategories) do
					AddCategory(cat.text, cat.icon, function(me)
						contents:RefreshCategory(cat.slot)

						--
						curcat = i
						frame:SetTitle(title .. " - " .. me.m_sText)
					end, i)
				end

			if (!self.DisableKeyShortcuts) then
				local tabbing = false
				local pressing = false
				navbar.Think = function()
					if (input.IsKeyDown(KEY_TAB)) then
						if (!tabbing) then
							tabbing = true
							togglenavbar:DoClick()
						end
					else
						tabbing = false
					end

					if not (pressing and input.IsKeyDown(pressing)) then
						pressing = false

						for id, btn in pairs (cats) do
							local key = _G["KEY_" .. id]
							if (!key) then
								continue end

							if (input.IsKeyDown(key)) then
								pressing = key
								btn:DoClick()
								return
							end
						end
					end
				end
			end

	frame:SetAlpha(0)
	frame:AlphaTo(255, 0.1)
end

--PATH addons/__new_main_all/lua/main/totem_tools.lua:
AddCSLuaFile()

function Totem_HealthRecovery( ply )
    timer.Create( "TotemHealthRecovery"..ply:SteamID(), 1, 3, function()
        if not IsValid(ply) then timer.Remove("TotemHealthRecovery"..ply) return end
        local hp, maxhp, rec = ply:Health(), ply:GetMaxHealth(), 0

        rec = hp + math.random( 10, 25 )

        if rec >= maxhp then
            ply:SetHealth( maxhp )
        else
            ply:SetHealth( rec )
        end
    end )
end

local function SimpleJudge( wep, ent )
    local wepp = ent:GetWeapon( "totem" )

    if !wepp:IsWeapon() then return false end

    if wep:GetClass() == "totem" or ( wepp and wepp:GetIsInventory() ) then
        return true
    end

    return false
end

local function SimpleRemoveWeapon( wep, ent )
    local wepp = wep

    if wep:GetClass() != "totem" then wepp = ent:GetWeapon( "totem" ) end

    wepp:Remove()
end

hook.Add( "EntityTakeDamage", "TotemWillProtectU", function( ent, dmginfo )
    if !ent:IsPlayer() then return end

    local wep = ent:GetActiveWeapon()

    if SimpleJudge( wep, ent ) and dmginfo:GetDamage() >= ent:Health() then
        ent:SetHealth( 35 )
        ent:SetNWBool( "SuperDamageScale", true )
        ent:EmitSound("totem_sound/totem_of_undying.mp3")

        local effectdata = EffectData()
        effectdata:SetOrigin( ent:GetPos() + Vector( 0, 0, 30 ) )
        effectdata:SetMagnitude( 20 )
        effectdata:SetScale( 15 )
        effectdata:SetRadius( 3 )
        effectdata:SetEntity( ent )
        util.Effect( "cball_explode", effectdata )

        timer.Create( "SuperDamageScale"..ent:SteamID(), 5, 1, function()
            ent:SetNWBool( "SuperDamageScale", false )
        end )

        net.Start( "DoTotemAnimation" )
            net.WriteEntity( ent )--it is player
        net.Send( ent )


        SimpleRemoveWeapon( wep, ent )
        ent:ConCommand( "lastinv" )
        -- ent:Say( NAME_OF_TOTEM.saying ) this was too stupid
        Totem_HealthRecovery( ent )

        return true
    end

    if ent:GetNWBool( "SuperDamageScale" ) then
        dmginfo:ScaleDamage( 0.05 )
    end
end )

hook.Add( "DoPlayerDeath", "TotemDeath", function( ply, att, dmg )
    if timer.Exists( "SuperDamageScale"..ply:SteamID() ) then
        timer.Remove( "SuperDamageScale"..ply:SteamID() )
    end

    if timer.Exists( "TotemHealthRecovery"..ply:SteamID() ) then
        timer.Remove( "TotemHealthRecovery"..ply:SteamID() )
    end

    ply:SetNWBool( "SuperDamageScale", false )
    hook.Remove( "HUDPaint", "DoTotemAnimation" )
end )

totem_inventoryIcon = Material( "img/offhand/totem_offhand.png" )

hook.Add( "HUDPaint", "Totem_DoInventoryIcon", function() 
    local ply = LocalPlayer()
    local wep = ply:GetWeapon( "totem" )

    if !wep:IsWeapon() then return end

    if !wep:GetIsInventory() then return end

    local x, y = ScrW(), ScrH()

    surface.SetDrawColor( 255, 255, 255 )
    surface.SetMaterial( totem_inventoryIcon )
    surface.DrawTexturedRect( x * 0.48 / 1 - 230 * 0.005 / 2, y / 1.2 - 40 * 0.8, x * 0.04, y * 0.07 )
end )

--Net Area
net.Receive( "DoTotemAnimation", function()
    local Totem_time, Totem_frame, ply = 0, 1, net.ReadEntity()

    hook.Add( "HUDPaint", "DoTotemAnimation", function()
        
        local x, y = ScrW(), ScrH()

        if Totem_frame >= 63 or ply:Health() <= 0 then
            hook.Remove( "HUDPaint", "DoTotemAnimation" )
            return 
        end

        --control animation time
        if Totem_time < 0.03 then
            Totem_time = Totem_time + FrameTime()
        else
            Totem_time = 0
            Totem_frame = Totem_frame + 1
        end

        surface.SetDrawColor( 255, 255, 255 )
        surface.SetMaterial( TotemImages[Totem_frame] )
        surface.DrawTexturedRect( x * 0.5 / 1 - 230 * 0.005 / 2 - 450, y / 8 - 40 * 0.8, x / 2 - 60, y / 1.2 )

    end )

end )
--PATH addons/_drones/lua/dronesrewrite/cvars.lua:
DRONES_REWRITE.ClientCVars = { }

if CLIENT then
	DRONES_REWRITE.ClientCVars.WvCamOrientation = CreateClientConVar("dronesrewrite_cl_wvcamorientation", "Right", true, true)

	-- AI and serverside cvars
	DRONES_REWRITE.ClientCVars.Keys = { }
	for name, v in pairs(DRONES_REWRITE.Keys) do
		DRONES_REWRITE.ClientCVars.Keys[name] = CreateClientConVar("dronesrewrite_key_" .. name, tostring(v), true, true)
	end
end
--PATH addons/_drones/lua/dronesrewrite/keyconfig.lua:
DRONES_REWRITE.KeyNames = {
	[0] = "",
	[1] = "0",
	[2] = "1",
	[3] = "2",
	[4] = "3",
	[5] = "4",
	[6] = "5",
	[7] = "6",
	[8] = "7",
	[9] = "8",
	[10] = "9",
	[11] = "A",
	[12] = "B",
	[13] = "C",
	[14] = "D",
	[15] = "E",
	[16] = "F",
	[17] = "G",
	[18] = "H",
	[19] = "I",
	[20] = "J",
	[21] = "K",
	[22] = "L",
	[23] = "M",
	[24] = "N",
	[25] = "O",
	[26] = "P",
	[27] = "Q",
	[28] = "R",
	[29] = "S",
	[30] = "T",
	[31] = "U",
	[32] = "V",
	[33] = "W",
	[34] = "X",
	[35] = "Y",
	[36] = "Z",
	[37] = "keypad 0",
	[38] = "keypad 1",
	[39] = "keypad 2",
	[40] = "keypad 3",
	[41] = "keypad 4",
	[42] = "keypad 5",
	[43] = "keypad 6",
	[44] = "keypad 7",
	[45] = "keypad 8",
	[46] = "keypad 9",
	[47] = "keypad /",
	[48] = "keypad *",
	[49] = "keypad -",
	[50] = "keypad +",
	[51] = "keypad Enter",
	[52] = "keypad Del",
	[53] = "[",
	[54] = "]",
	[55] = ";",
	[56] = '"',
	[57] = "`",
	[58] = ",",
	[59] = ".",
	[60] = "/",
	[61] = "\\",
	[62] = "-",
	[63] = "=",
	[64] = "Enter",
	[65] = "Space",
	[66] = "Backspace",
	[67] = "Tab",
	[68] = "Caps Lock",
	[69] = "Num Lock",
	[71] = "Scroll Lock",
	[72] = "Insert",
	[73] = "Delete",
	[74] = "Home",
	[75] = "End",
	[76] = "Page Up",
	[78] = "Break",
	[79] = "Shift",
	[80] = "Shift Left",
	[81] = "ALT",
	[82] = "ALT Right",
	[83] = "Control",
	[84] = "Control Right",
	[88] = "Arrow Up",
	[89] = "Arrow Left",
	[90] = "Arrow Down",
	[91] = "Arrow Right",
	[92] = "F1",
	[93] = "F2",
	[94] = "F3",
	[95] = "F4",
	[96] = "F5",
	[97] = "F6",
	[98] = "F7",
	[99] = "F8",
	[100] = "F9",
	[101] = "F10",
	[102] = "F11",
	[103] = "F12",
	[107] = "Mouse Left",
	[108] = "Mouse Right",
	[109] = "Mouse 3",
	[110] = "Mouse 4",
	[111] = "Mouse 5",
	[112] = "Mouse Wheel Up",
	[113] = "Mouse Wheel Down"
}

DRONES_REWRITE.DefaultKeys = function()
	local keys = { }


	----------------
	-- Basic keys --
	----------------

	keys.Other = { }

	keys.Other["Zoom"] = function(self)
		local driver = self:GetDriver()

		if driver:IsValid() and not self.Zoom then 
			self.Zoom = true
			driver:SetFOV(self.CamZoom, 0.25) 
		end
	end

	keys.Other["Enable"] = function(self)
		if self:WasKeyPressed("Enable") and self:WaterLevel() < 3 then
			self:SetEnabled(not self.Enabled)
		end
	end

	keys.Other["Exit"] = function(self)
		if self:WasKeyPressed("Exit") then
			self:SetDriver(NULL)
			self.NextAction = CurTime() + 0.3
		end
	end

	keys.Other["SelfDestruct"] = function(self)
		if self:WasKeyPressed("SelfDestruct") then
			self:Destroy()
		end
	end

	keys.Other["NightVision"] = function(self)
		if self:WasKeyPressed("NightVision") and self:IsDroneWorkable() and self.UseNightVision then
			local val = self:GetNWBool("NightVision")

			self:SetNWBool("NightVision", not val)

			local driver = self:GetDriver()
			if driver:IsValid() then
				net.Start("dronesrewrite_playsound")
					net.WriteString(val and "drones/nightvisionoff.wav" or "drones/nightvisionon.wav")
				net.Send(driver)
			end
		end
	end

	keys.Other["SpecialKey"] = function(self)
	end

	keys.Other["WeaponView"] = function(self)
		if self:WasKeyPressed("WeaponView") then
			local driver = self:GetDriver()

			if driver:IsValid() then
				local wep = self:GetCurrentWeapon()
				if wep:IsValid() and not wep.NoDrawWeapon then
					local newCam = wep
					local pos
					local viewent = false

					local cam = driver:GetInfo("dronesrewrite_cl_wvcamorientation", 0)
					if cam == "Right" then
						pos = Vector(0, wep:OBBMins().y - 15, wep:OBBMaxs().z) * (wep.CamOffset or 1)
					elseif cam == "Left" then
						pos = Vector(0, -wep:OBBMins().y + 15, wep:OBBMaxs().z) * (wep.CamOffset or 1)
					elseif cam == "Down" then
						pos = Vector(0, 0, -8) * (wep.CamOffset or 1)
					end

					if self:GetCamera() == newCam then
						newCam = self.Camera
						pos = Vector(0, 0, 0)
						viewent = true
					end

					self:SetCamera(newCam, true, true, pos, viewent)
				end
			end
		end
	end

	keys.Other["Fire1"] = function(self)
		self:Attack1()
	end

	keys.Other["Fire2"] = function(self)
		self:Attack2()
	end

	keys.Other["Flashlight"] = function(self)
		if self:WasKeyPressed("Flashlight") and self:IsDroneWorkable() and self.UseFlashlight then
			self:SetNWBool("Flashlight", not self:GetNWBool("Flashlight"))

			if self.flashlight then
				SafeRemoveEntity(self.flashlight)
				self.flashlight = nil
			else
				self.flashlight = ents.Create("env_projectedtexture")
				
				self.flashlight:SetParent(self.Camera)
					
				self.flashlight:SetLocalPos(self:WorldToLocal(self.Camera:GetPos()))
				self.flashlight:SetLocalAngles(Angle(0, 0, 0))

				self.flashlight:SetKeyValue("enableshadows", 1)
				self.flashlight:SetKeyValue("farz", 500)
				self.flashlight:SetKeyValue("nearz", 12)
				self.flashlight:SetKeyValue("lightfov", 100)
				self.flashlight:SetKeyValue("lightcolor", Format("%i %i %i 255", 255, 255, 255))

				self.flashlight:Spawn()
		
				self.flashlight:Input("SpotlightTexture", NULL, NULL, "effects/flashlight001")
			end

			self:EmitSound("buttons/lightswitch2.wav", 80, 160)
		end
	end

	keys.Other["ThirdPerson"] = function(self)
		if self:WasKeyPressed("ThirdPerson") then
			self:SetNWBool("ThirdPerson", not self:GetNWBool("ThirdPerson"))
		end
	end


	------------------------
	-- Physics control keys
	------------------------

	keys.Physics = { }

	keys.Physics["Sprint"] = function(self)
		if self:WasKeyPressed("Sprint") then 
			self.MoveCoefficient = self.SprintCoefficient * self:ForceCoefficient()
		end
	end

	keys.Physics["MoveSlowly"] = function(self)
		if self:WasKeyPressed("MoveSlowly") then 
			self.MoveCoefficient = 0.3 * self:ForceCoefficient()
		end
	end

	keys.Physics["Forward"] = function(self)
		local forward = self:GetForward()
		local phys = self:GetPhysicsObject()
		local angOffset = self.Speed * self.MoveCoefficient * 0.0005 * self.PitchOffset * self.DRONES_REWRITE_DELTA * 0.5

		phys:ApplyForceCenter(forward * self.Speed * self.MoveCoefficient * self.DRONES_REWRITE_DELTA)
		phys:AddAngleVelocity(Vector(0, angOffset, 0))

		self.MoveDir = 1
		self.IsMoving = true
	end

	keys.Physics["Back"] = function(self)
		local forward = self:GetForward()
		local phys = self:GetPhysicsObject()
		local angOffset = self.Speed * self.MoveCoefficient * 0.0005 * self.PitchOffset * self.DRONES_REWRITE_DELTA * 0.5

		phys:ApplyForceCenter(-forward * self.Speed * self.MoveCoefficient * self.DRONES_REWRITE_DELTA)
		phys:AddAngleVelocity(Vector(0, -angOffset, 0))

		self.MoveDir = -1
		self.IsMoving = true
	end

	keys.Physics["StrafeRight"] = function(self)
		if self.DrrBaseType != "base" then return end

		local right = self:GetRight()
		local phys = self:GetPhysicsObject()

		phys:ApplyForceCenter(right * self.Speed * self.MoveCoefficient * self.DRONES_REWRITE_DELTA)
		phys:AddAngleVelocity(Vector(self.AngOffset, 0, 0))

		self.MoveDir = 1
		self.IsMoving = true
	end

	keys.Physics["StrafeLeft"] = function(self)
		if self.DrrBaseType != "base" then return end

		local right = self:GetRight()
		local phys = self:GetPhysicsObject()

		phys:ApplyForceCenter(-right * self.Speed * self.MoveCoefficient * self.DRONES_REWRITE_DELTA)
		phys:AddAngleVelocity(Vector(-self.AngOffset, 0, 0))

		self.MoveDir = -1
		self.IsMoving = true
	end

	keys.Physics["Right"] = function(self)
		local phys = self:GetPhysicsObject()
		local vellen = math.Clamp(phys:GetVelocity():Length() * self.VelCoefficientOffset, 1, self.VelCoefficientMax) * self.AngOffsetVel

		phys:AddAngleVelocity(Vector(0, 0, -1) * self.RotateSpeed * self.DRONES_REWRITE_DELTA * 0.7)
		phys:AddAngleVelocity(Vector(self.AngOffset * vellen * self.DRONES_REWRITE_DELTA * 0.5, 0, 0))

		self.RotateDir = 1
		self.IsRotating = true
	end
		
	keys.Physics["Left"] = function(self)
		local phys = self:GetPhysicsObject()
		local vellen = math.Clamp(phys:GetVelocity():Length() * self.VelCoefficientOffset, 1, self.VelCoefficientMax) * self.AngOffsetVel

		phys:AddAngleVelocity(Vector(0, 0, 1) * self.RotateSpeed * self.DRONES_REWRITE_DELTA * 0.7)
		phys:AddAngleVelocity(Vector(-self.AngOffset * vellen * self.DRONES_REWRITE_DELTA * 0.5, 0, 0))

		self.RotateDir = -1
		self.IsRotating = true
	end

	keys.Physics["Up"] = function(self)
		local up = self:GetUp()
		local phys = self:GetPhysicsObject()

		phys:ApplyForceCenter(up * self.UpSpeed * self.MoveCoefficient * 0.2 * self.DRONES_REWRITE_DELTA)

		self.IsMoving = true
	end

	keys.Physics["Down"] = function(self)
		local up = self:GetUp()
		local phys = self:GetPhysicsObject()

		phys:ApplyForceCenter(-up * self.UpSpeed * self.MoveCoefficient * 0.2 * self.DRONES_REWRITE_DELTA)

		self.IsMoving = true
	end


	-----------------------
	-- Unpress functions --
	-----------------------
	keys.UnPressed = { }

	keys.UnPressed["Sprint"] = function(self)
		self.MoveCoefficient = self:ForceCoefficient()
	end

	keys.UnPressed["MoveSlowly"] = function(self)
		self.MoveCoefficient = self:ForceCoefficient()
	end

	keys.UnPressed["Zoom"] = function(self)
		local driver = self:GetDriver()

		if driver:IsValid() then driver:SetFOV(90, 0.2) end
		self.Zoom = false
	end

	keys.UnPressed["Fire1"] = function(self)
		self:OnAttackStopped()
	end

	keys.UnPressed["Fire2"] = function(self)
		self:OnAttackStopped2()
	end

	return keys
end
--PATH addons/_drones/lua/dronesrewrite/modules.lua:
local modules = { }

local mdl = Model("models/dronesrewrite/upgrade_case/upgrade_case.mdl")

DRONES_REWRITE.AddModule = function(name, tab)
	modules[name] = table.Copy(tab)

	-- It's bad bad bad
	local ENT = { }
	
	ENT.Type = "anim"
	ENT.Base = "base_anim"
	ENT.PrintName = name
	ENT.Category = "Drones Rewrite Upgrades"
	ENT.Author = "Drones"
	ENT.Spawnable = true

	if CLIENT then
		function ENT:Draw()
			self:DrawModel()

			local pos = self:LocalToWorld(self:OBBCenter()) + vector_up * 12
			local ang = (pos - EyePos()):Angle()

			local a = 255 - math.Clamp(self:GetPos():Distance(EyePos()) * 0.6, 0, 255)
			
			cam.Start3D2D(pos, Angle(0, ang.y - 90, -ang.p + 90), 0.05)
				draw.SimpleText(self.PrintName, "DronesRewrite_customfont1big", 0, 0, Color(255, 255, 255, a + math.sin(CurTime() * 5) * a * 0.3), TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end
	else
		function ENT:Initialize()
			self:SetModel(mdl)
			self:SetMoveType(MOVETYPE_VPHYSICS)
			self:SetSolid(SOLID_VPHYSICS)
			self:PhysicsInit(SOLID_VPHYSICS)
			self:SetUseType(SIMPLE_USE)

			local phys = self:GetPhysicsObject()
			if IsValid(phys) then
			    phys:Wake()
			else
				self:Remove()
			end
		end

		function ENT:PhysicsCollide(data, phys)
			local ent = data.HitEntity

			if IsValid(ent) and ent.IS_DRR then
				local driver = ent:GetDriver()
				if driver:IsValid() then return end

				if ent:AddModule(self.PrintName) then SafeRemoveEntity(self) end
			end
		end
	end

	local nicename = "dronesrewrite_upgrcase_" .. string.lower(string.Replace(name, " ", "_"))
	scripted_ents.Register(ENT, nicename)
end

DRONES_REWRITE.GetModule = function(name)
	return modules[name]
end

DRONES_REWRITE.GetModules = function()
	return modules
end

DRONES_REWRITE.AddModule("AI Random moving", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true

		drone.Buffer.RandomForward = 0
		drone.Buffer.RandomBack = 0
		drone.Buffer.RandomAngle = 0
		drone.Buffer.RandomUp = 0
		drone.Buffer.RandomDown = 0
		drone.Buffer.Stay = 0
		drone.Buffer.HoldAlt = 0
		drone.Buffer.HoldSprint = 0
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		if drone.Buffer.RandomAngle != 0 then
			local ang = drone:GetAngles()
			drone:ControlMotion("Left", "Right", math.NormalizeAngle(ang.y - drone.Buffer.RandomAngle), -15, 15)
		end

		if drone.Buffer.HoldAlt > 0 then
			drone.Buffer.HoldAlt = math.Approach(drone.Buffer.HoldAlt, 0, 1)
			drone:ClickKey("MoveSlowly")
		end

		if drone.Buffer.HoldSprint > 0 then
			drone.Buffer.HoldSprint = math.Approach(drone.Buffer.HoldSprint, 0, 1)
			drone:ClickKey("Sprint")
		end

		if drone.Buffer.RandomBack > 0 then
			drone.Buffer.RandomBack = math.Approach(drone.Buffer.RandomBack, 0, 1)
			drone:ClickKey("Back")
		end

		if drone.Buffer.RandomForward > 0 then
			drone.Buffer.RandomForward = math.Approach(drone.Buffer.RandomForward, 0, 1)
			drone:ClickKey("Forward")
		end

		if drone.Buffer.RandomUp > 0 then
			drone.Buffer.RandomUp = math.Approach(drone.Buffer.RandomUp, 0, 1)
			drone:ClickKey("Up")
		end

		if drone.Buffer.RandomDown > 0 then
			drone.Buffer.RandomDown = math.Approach(drone.Buffer.RandomDown, 0, 1)
			drone:ClickKey("Down")
		end

		if drone.Buffer.Stay > 0 then
			drone.Buffer.Stay = math.Approach(drone.Buffer.Stay, 0, 1)

			drone.Buffer.RandomForward = 0
			drone.Buffer.RandomBack = 0
			drone.Buffer.RandomUp = 0
			drone.Buffer.RandomDown = 0
		end

		if drone.AI_AllowForward and math.random(1, 80) == 1 then
			drone.Buffer.RandomBack = 0

			local start = drone:LocalToWorld(drone:OBBCenter())
			local tr = util.TraceLine({
				start = start,
				endpos = start + drone:GetForward() * math.random(1000, 4000),
				filter = drone
			})

			local dist = start:Distance(tr.HitPos)
			if dist <= 200 then
				local val = math.random(0, 1)
				if val == 0 then val = -1 end -- ??????

				drone.Buffer.RandomAngle = math.random(95, 130) * val
				drone.Buffer.HoldAlt = math.random(30, 60)
			end

			if dist > 100 then
				drone.Buffer.RandomForward = math.random(dist * 0.8, dist)
			end
		end

		if drone.AI_AllowBack and math.random(1, 320) == 1 then
			drone.Buffer.RandomForward = 0
			drone.Buffer.RandomBack = math.random(5, 20)
		end

		if drone.AI_AllowRotate and math.random(1, 120) == 1 then
			if drone.Buffer.RandomForward > 0 or drone.Buffer.RandomBack > 0 then
				drone.Buffer.RandomAngle = math.random(-90, 90)
			else
				drone.Buffer.RandomAngle = math.random(-180, 180)
			end
		end

		if drone.AI_AllowStay and math.random(1, 400) == 1 then 
			drone.Buffer.Stay = math.random(5, 30)
		end

		if drone.AI_AllowUp and math.random(1, 250) == 1 then 
			drone.Buffer.RandomDown = 0
			drone.Buffer.RandomUp = math.random(5, 30) 
		end

		if drone.AI_AllowDown and math.random(1, 250) == 1 then 
			drone.Buffer.RandomUp = 0
			drone.Buffer.RandomDown = math.random(5, 30) 
		end
	end
})

DRONES_REWRITE.AddModule("AI Moving core", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone) DRONES_REWRITE.AI.MovingCore(drone) end
})

DRONES_REWRITE.AddModule("AI Protect", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true

		drone:AddHook("TakeDamage", "ai_protect", function(dmg, attacker)
			drone.Buffer.Enemy = attacker
		end)
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end

		drone:RemoveHook("TakeDamage", "ai_protect")
	end,

	Think = function(drone)	
		if not drone:HasModule("AI Attack") then
			if not IsValid(drone.Buffer.Enemy) then drone.Buffer.Enemy = nil return end

			local val = 1500

			if drone.Buffer.Enemy:GetPos():Distance(drone:GetPos()) > val then
				drone.Buffer.Enemy = nil 
			end

			if drone.Buffer.Enemy and drone.Buffer.Enemy:IsPlayer() and not drone.Buffer.Enemy:Alive() then drone.Buffer.Enemy = nil end
			DRONES_REWRITE.AI.Attack(drone, drone.Buffer.Enemy)
		end
	end
})

DRONES_REWRITE.AddModule("AI Attack", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		local wep = drone:GetCurrentWeapon()

		if wep:IsValid() then
			for k, v in ents.Iterator() do
				DRONES_REWRITE.AI.Attack(drone, v)
			end
		end
	end
})

DRONES_REWRITE.AddModule("AI Check territory", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.Buffer.OldAngleDir = 1
		drone.Buffer.OldAngleDirP = 0.5
		drone.Buffer.RandomAngle = 0

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		local enemy = drone.Buffer.Enemy

		if not IsValid(enemy) then
			local ang = drone:WorldToLocalAngles(drone.CamAngles) + Angle(drone.Buffer.OldAngleDirP, drone.Buffer.OldAngleDir, 0)

			
			if drone.AllowPitchRestrictions then
				if ang.p < drone.PitchMin then 
					ang.p = drone.PitchMin
					drone.Buffer.OldAngleDirP = -drone.Buffer.OldAngleDirP 
				end

				if ang.p > drone.PitchMax then 
					ang.p = drone.PitchMax
					drone.Buffer.OldAngleDirP = -drone.Buffer.OldAngleDirP 
				end
			end

			if drone.AllowYawRestrictions then
				if ang.y < drone.YawMin then 
					ang.y = drone.YawMin
					drone.Buffer.OldAngleDir = -drone.Buffer.OldAngleDir 
				end

				if ang.y > drone.YawMax then 
					ang.y = drone.YawMax
					drone.Buffer.OldAngleDir = -drone.Buffer.OldAngleDir 
				end
			end

			drone.CamAngles = drone:LocalToWorldAngles(ang)

			if not drone:HasModule("AI Random moving") then
				if drone.Buffer.RandomAngle != 0 then
					local ang = drone:GetAngles()
					drone:ControlMotion("Left", "Right", math.NormalizeAngle(ang.y - drone.Buffer.RandomAngle), -15, 15)
				end

				if math.random(1, 200) == 1 then
					drone.Buffer.RandomAngle = math.random(-180, 180)
				end
			end
		end
	end
})

DRONES_REWRITE.AddModule("AI Follow enemy", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		local enemy = drone.Buffer.Enemy

		if IsValid(enemy) then
			local drpos = drone:LocalToWorld(drone:OBBCenter())
			local tr = util.TraceLine({
				start = drpos,
				endpos = enemy:LocalToWorld(enemy:OBBCenter()),
				filter = drone
			})

			local opos = ((tr.Entity == enemy) and tr.HitPos or enemy:GetPos())
			local ang = drone:GetAngles()
			local dir = (opos - drpos):GetNormal()
			local checkang = math.NormalizeAngle(ang.y - dir:Angle().y)

			if not (checkang < -40 or checkang > 40) then -- Wtf?!?!
				local dist = opos:Distance(drpos)
				if dist > (drone.AI_DistanceEnemy or (160 + drone:OBBMaxs().x)) then
					drone:ClickKey("Forward")
				elseif dist < (drone.AI_DistanceEnemy or (100 + drone:OBBMaxs().x)) then
					drone:ClickKey("Back")
				end
			end

			drone.Buffer.RandomForward = 0
			drone.Buffer.RandomBack = 0
			drone.Buffer.RandomAngle = 0
			drone.Buffer.RandomUp = 0
			drone.Buffer.RandomDown = 0
			drone.Buffer.Stay = 0

			drone:ControlMotion("Left", "Right", checkang, -16, 16)

			-- Using false to shit shit shit
			if drone.AI_UseZ == false then return end

			local st = opos.z - drpos.z
			local val = 100 + (drone.AI_AirZ or 70)

			if st > -val / 5 then
				drone:ClickKey("Up")
			elseif st < -val then
				drone:ClickKey("Down")
			end
		end
	end
})

DRONES_REWRITE.AddModule("AI Follow owner", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		local owner = drone.Owner

		local drpos = drone:GetPos()
		local opos = owner:GetPos()
		local dist = opos:Distance(drpos)

		if owner:IsValid() and owner:Alive() and dist < 4000 then
			local ang = drone:GetAngles()
			local dir = (opos - drpos):GetNormal()

			local checkang = math.NormalizeAngle(ang.y - dir:Angle().y)

			if dist > 1600 then
				drone:ClickKey("Sprint")
			end

			if dist < 300 then
				drone:ClickKey("MoveSlowly")
			end

			if not (checkang < -40 or checkang > 40) then -- Wtf?!?!
				if dist > (150 + drone:OBBMaxs().x) then
					drone:ClickKey("Forward")
				elseif dist < (40 + drone:OBBMaxs().x) then
					drone:ClickKey("Back")
				end
			end

			drone:ControlMotion("Left", "Right", checkang, -16, 16)
				
			-- Using false to shit shit shit
			if drone.AI_UseZ == false then return end

			local st = opos.z - drpos.z
			local val = 100 + (drone.AI_AirZ or 10)

			if st > -val / 5 then
				drone:ClickKey("Up")
			elseif st < -val then
				drone:ClickKey("Down")
			end
		end
	end
})

DRONES_REWRITE.AddModule("AI Camera point", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		if IsValid(drone.Owner) then
			drone.CamAngles = (drone.Owner:GetEyeTrace().HitPos - drone:GetCamera():GetPos()):GetNormal():Angle()
		end
	end
})

DRONES_REWRITE.AddModule("AI Static camera", {
	Slot = "AI",

	Initialize = function(drone)
		drone:SetDriver(NULL)
		drone.Camera:SetAngles(drone:GetAngles())

		drone.AI_installed = true
	end,

	OnRemove = function(drone)
		if drone:CountModulesInSlot("AI") <= 0 then
			drone.AI_installed = false
		end
	end,

	Think = function(drone)
		drone.CamAngles = drone:GetAngles()
	end
})

DRONES_REWRITE.AddModule("Remove modules", {
	Default = true,
	SkipSlot = true,
	System = true,

	Initialize = function(drone)
		drone:RemoveAllModules()
	end,

	OnRemove = function(drone) end,
	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Repair propellers", {
	Default = true,
	SkipSlot = true,
	System = true,

	Initialize = function(drone)
		drone:AddPropellers()
		drone:RemoveModule("Repair propellers")
	end,

	OnRemove = function(drone)
	end,

	Think = function(drone)
	end
})

DRONES_REWRITE.AddModule("Health booster", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		drone.Buffer.HealthModuleCache = drone:GetHealth() * 0.3

		drone:SetDefaultHealth(drone:GetDefaultHealth() + drone.Buffer.HealthModuleCache)
		drone:SetHealthAmount(drone:GetHealth() + drone.Buffer.HealthModuleCache)
	end,

	OnRemove = function(drone)
		drone:SetDefaultHealth(drone:GetDefaultHealth() - drone.Buffer.HealthModuleCache)
		drone:SetHealthAmount(math.min(drone:GetDefaultHealth(), drone:GetHealth()))

		drone.Buffer.HealthModuleCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Hack protection", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		drone.HackValue = drone.HackValue + 1
		drone:EmitSound("buttons/combine_button_locked.wav", 70, 220)
	end,

	OnRemove = function(drone)
		drone.HackValue = drone.HackValue - 1
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Invisible for radar", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		drone:SetNWBool("NoDRRRadar", true)
	end,

	OnRemove = function(drone)
		drone:SetNWBool("NoDRRRadar", false)
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Healer", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		local e = ents.Create("dronesrewrite_ai_healer")
		e.Drone = drone
		e:Spawn()
		e:Activate()

		drone.Buffer.Healer = e
	end,

	OnRemove = function(drone)
		SafeRemoveEntity(drone.Buffer.Healer)
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Increase speed", {
	Default = true,
	Slot = "Engine",

	Initialize = function(drone)
		drone.Buffer.SpeedModuleCache = drone.Speed * 0.5
		drone.Speed = drone.Speed + drone.Buffer.SpeedModuleCache
	end,

	OnRemove = function(drone)
		drone.Speed = drone.Speed - drone.Buffer.SpeedModuleCache
		drone.Buffer.SpeedModuleCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Increase up speed", {
	Default = true,
	Slot = "Engine",

	Initialize = function(drone)
		drone.Buffer.UpSpeedModuleCache = drone.UpSpeed * 0.5
		drone.UpSpeed = drone.UpSpeed + drone.Buffer.UpSpeedModuleCache
	end,

	OnRemove = function(drone)
		drone.UpSpeed = drone.UpSpeed - drone.Buffer.UpSpeedModuleCache
		drone.Buffer.UpSpeedModuleCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Decrease fuel consumption", {
	Default = true,
	Slot = "Fuel",

	Initialize = function(drone)
		drone.Buffer.FuelReductionCache = drone.FuelReduction * 0.5
		drone.FuelReduction = drone.FuelReduction - drone.Buffer.FuelReductionCache
	end,

	OnRemove = function(drone)
		drone.FuelReduction = drone.FuelReduction + drone.Buffer.FuelReductionCache
		drone.Buffer.FuelReductionCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Increase fuel capacity", {
	Default = true,
	Slot = "Fuel",

	Initialize = function(drone)
		drone.Buffer.MaxFuelCache = drone.MaxFuel * 0.5
		drone.MaxFuel = drone.MaxFuel + drone.Buffer.MaxFuelCache
	end,

	OnRemove = function(drone)
		drone.MaxFuel = drone.MaxFuel - drone.Buffer.MaxFuelCache
		drone.Buffer.MaxFuelCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Decrease engine noise", {
	Default = true,
	Slot = "Engine",

	Initialize = function(drone)
	end,

	OnRemove = function(drone)
		if drone.LoopSounds and drone.LoopSounds["Rotor"] then
			local snd = drone.Sounds.PropellerSound

			local oldvolume = 1
			local oldlevel = 75
			if snd then 
				oldvolume = snd.Volume or 1
				oldlevel = snd.Level or 75
			end

			drone.LoopSounds["Rotor"]:ChangeVolume(oldvolume)

			drone.LoopSounds["Rotor"]:Stop()
			drone.LoopSounds["Rotor"]:SetSoundLevel(oldlevel)
			drone.LoopSounds["Rotor"]:Play()
		end
	end,
    
	Think = function(drone) 
		if drone.LoopSounds and drone.LoopSounds["Rotor"] then
			local snd = drone.Sounds.PropellerSound

			local oldvolume = 1
			local oldlevel = 75
			if snd then 
				oldvolume = snd.Volume or 1
				oldlevel = snd.Level or 75
			end

			local newvolume = oldvolume * 0.6
			local newlevel = math.floor(oldlevel * 0.8)

			if drone.LoopSounds["Rotor"]:GetVolume() != newvolume then
				drone.LoopSounds["Rotor"]:ChangeVolume(newvolume)
			end

			if drone.LoopSounds["Rotor"]:GetSoundLevel() != newlevel then
				-- SetSoundLevel doesn't work when sound is playing
				drone.LoopSounds["Rotor"]:Stop()
				drone.LoopSounds["Rotor"]:SetSoundLevel(newlevel)
				drone.LoopSounds["Rotor"]:Play()
			end
		end
	end
})

DRONES_REWRITE.AddModule("Zoom increaser", {
	Default = true,
	Slot = "Camera",

	Initialize = function(drone)
		drone.Buffer.CamZoomCache = drone.CamZoom * 0.5
		drone.CamZoom = drone.CamZoom - drone.Buffer.CamZoomCache
	end,

	OnRemove = function(drone)
		drone.CamZoom = drone.CamZoom + drone.Buffer.CamZoomCache
		drone.Buffer.CamZoomCache = 0
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Shield", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		drone.Buffer.ShieldHealth = drone:GetDefaultHealth() * 0.5
		drone.Buffer.ShieldMax = drone.Buffer.ShieldHealth

		drone:SetNWInt("shield_health", math.floor(drone.Buffer.ShieldHealth))
		drone:SetNWInt("shield_def", math.floor(drone.Buffer.ShieldMax))

		drone:AddHookClient("HUD", "DrawShield", [[
			local drone = LocalPlayer():GetNWEntity("DronesRewriteDrone")

			if drone:IsValid() then
				drone:DrawIndicator("Shield", math.floor((drone:GetNWInt("shield_health") / drone:GetNWInt("shield_def")) * 100))
			end
		]])

		drone:AddHook("TakeDamage", "shield_dmg", function(dmg)
			SafeRemoveEntity(drone.Buffer.Shield)
			local pos = dmg:GetDamagePosition()

			local e = ents.Create("base_anim")
			e:SetModel(drone.Model)
			e:SetModelScale(1.02, 0)
			e:SetMaterial("models/props_combine/stasisshield_sheet")
			e:SetPos(drone:GetPos())
			e:SetAngles(drone:GetAngles())
			e:Spawn()
			e:SetParent(drone)
			e:SetNotSolid(true)
			e:PhysicsDestroy()
				
			drone.Buffer.Shield = e

			local dmgAmount = dmg:GetDamage()
			drone.Buffer.ShieldHealth = drone.Buffer.ShieldHealth - dmgAmount * 2/3
			drone:SetHealthAmount(drone:GetHealth() + dmgAmount * 1/3)
			drone:EmitSound("ambient/energy/weld2.wav", 100, 255, 1)

			ParticleEffect("blade_glow_drr", pos, Angle(0, 0, 0))

			timer.Destroy("dronesrewrite_regen" .. drone:EntIndex())

			timer.Create("dronesrewrite_remshield" .. drone:EntIndex(), 6, 1, function() 
				if drone and drone:IsValid() then 
					SafeRemoveEntity(drone.Buffer.Shield) 

					timer.Create("dronesrewrite_regen" .. drone:EntIndex(), 0.1, 0, function()
						if not drone:IsValid() then timer.Destroy("dronesrewrite_regen" .. drone:EntIndex()) return end
						if drone.Buffer.ShieldHealth >= drone.Buffer.ShieldMax then return end

						drone.Buffer.ShieldHealth = drone.Buffer.ShieldHealth + 1
					end)
				end
			end)

			if drone.Buffer.ShieldHealth <= 0 then 
				drone:EmitSound("drones/nio_dissolve.wav", 100, 160)
				drone:RemoveModule("Shield") 

				ParticleEffect("electrical_arc_01_system", pos, Angle(0, 0, 0))
			end
		end)
	end,

	OnRemove = function(drone)
		drone:RemoveHook("TakeDamage", "shield_dmg")
		drone:RemoveHookClient("HUD", "DrawShield")

		timer.Destroy("dronesrewrite_regen" .. drone:EntIndex())

		SafeRemoveEntity(drone.Buffer.Shield)
	end,

	Think = function(drone) 
		if drone.Buffer.ShieldHealth then drone:SetNWInt("shield_health", math.floor(drone.Buffer.ShieldHealth)) end
	end
})

DRONES_REWRITE.AddModule("Signal booster", {
	Default = true,
	Slot = "Body",

	Initialize = function(drone)
		drone.DRRDefMaxDistance = drone.DRRDefMaxDistance + 12000
	end,

	OnRemove = function(drone)
		drone.DRRDefMaxDistance = drone.DRRDefMaxDistance - 12000
	end,

	Think = function(drone) 
	end
})

DRONES_REWRITE.AddModule("Nightvision", {
	Slot = "Camera",

	Initialize = function(drone)
		drone.UseNightVision = true
	end,

	OnRemove = function(drone)
		drone.UseNightVision = false
		drone:SetNWBool("NightVision", false)
	end,

	Think = function(drone) end
})

DRONES_REWRITE.AddModule("Flashlight", {
	Slot = "Camera",

	Initialize = function(drone)
		drone.UseFlashlight = true
	end,

	OnRemove = function(drone)
		drone.UseFlashlight = false
		drone:SetNWBool("Flashlight", false)
	end,

	Think = function(drone) end
})

DRONES_REWRITE._GetBaseModules = function()
	local Modules = { }

	for k, v in pairs(DRONES_REWRITE.GetModules()) do
		if v.Default then Modules[k] = table.Copy(v) end
	end

	return Modules
end

DRONES_REWRITE.GetAIModules = function()
	local Modules = { }

	for k, v in pairs(DRONES_REWRITE.GetModules()) do
		if v.Slot == "AI" then Modules[k] = table.Copy(v) end
	end

	return Modules
end




-- These functions are for drones
local function add(src, tar)
	for k, v in pairs(tar) do
		src[k] = table.Copy(v)
	end

	return src
end

DRONES_REWRITE.GetBaseModules = function()
	local Modules = { }

	Modules = add(Modules, DRONES_REWRITE._GetBaseModules())
	Modules = add(Modules, DRONES_REWRITE.GetAIModules())

	return Modules
end

DRONES_REWRITE.GetSystemModules = function()
	local Modules = { }

	Modules = add(Modules, DRONES_REWRITE.GetAIModules())

	for k, v in pairs(DRONES_REWRITE.GetModules()) do
		if v.System then Modules[k] = table.Copy(v) end
	end

	return Modules
end

DRONES_REWRITE.CopyModule = function(tab, name)
	tab[name] = table.Copy(DRONES_REWRITE.GetModule(name))
end


--PATH addons/_drones/lua/dronesrewrite/particles.lua:
game.AddParticles("particles/blaster_sparks.pcf")
game.AddParticles("particles/skull_fx.pcf")
game.AddParticles("particles/fire_test.pcf")
game.AddParticles("particles/fire_test2.pcf")
game.AddParticles("particles/splode_fx.pcf")
game.AddParticles("particles/flamethrower_fx.pcf")
game.AddParticles("particles/artillery_muzzle.pcf")

--Darken217's:
game.AddParticles("particles/boxglove_drr_fx.pcf")
game.AddParticles("particles/electrical_fx.pcf")
game.AddParticles("particles/napalmgrenade_fx.pcf")
game.AddParticles("particles/laser_fx.pcf")
game.AddParticles("particles/spectra_drr_fx.pcf")
game.AddParticles("particles/vapor_drr_fx.pcf")
game.AddParticles("particles/plasma_tracer.pcf")

PrecacheParticleSystem("fire_test2")
PrecacheParticleSystem("fire_test")
PrecacheParticleSystem("fire_man_disap")
PrecacheParticleSystem("sparks_rdbl")
PrecacheParticleSystem("skull_trail")
PrecacheParticleSystem("skull_impact")
PrecacheParticleSystem("skull_impact_fire")
PrecacheParticleSystem("splode_fire")
PrecacheParticleSystem("splode_big_main")
PrecacheParticleSystem("splode_drone_main")
PrecacheParticleSystem("splode_drone_sparks")
PrecacheParticleSystem("splode_big_drone_main")
PrecacheParticleSystem("flamethrower_fire_drr")
PrecacheParticleSystem("artillery_muzzle_main")

--Darken217's:
PrecacheParticleSystem("blade_glow_drr")
PrecacheParticleSystem("electrical_arc_01_parent")
PrecacheParticleSystem("electrical_arc_01_system")
PrecacheParticleSystem("laser_hit_drr")
PrecacheParticleSystem("laser_hit_r_drr")
PrecacheParticleSystem("laser_hit_g_drr")
PrecacheParticleSystem("laser_hit_b_drr")
PrecacheParticleSystem("napalmgren_shockwave_drr")
PrecacheParticleSystem("elecray_hit_drr")
//PrecacheParticleSystem("spectra_hit_drr")
PrecacheParticleSystem("stinger_explode_drr")
PrecacheParticleSystem("vapor_drr")
PrecacheParticleSystem("nrg_tracer_drr")
PrecacheParticleSystem("vapor_collapse_drr")
--PATH addons/_drones/lua/dronesrewrite/client/manuals.lua:
DRONES_REWRITE.Manuals = { }

local function AddManual(lab, text)
	table.insert(DRONES_REWRITE.Manuals, {
		label = lab,
		text = text
	})
end

AddManual("F.A.Q.", [[
  Q: How to edit drones?
  A: Read "Customizing drones" guide here

  Q: How to drive mothership?!
  A: Sit down on chair on ship bridge and type
      control MSP

  Q: How to turn into Thirdperson?
  A: Press I key (by default)

  Q: I do not see where I shoot. 
      What to do?
  A: Press your WeaponView key 
      (T by default)

  Q: Where can I find a list of the
      console variables?
  A: All console variables you need can be
      changed in
      Q > Options > Drones Rewrite

  Q: I've just found a bug! What to do?
  A: Let us know and we will fix it. Go to
      Q > Options > Drones Settings > Help > Having issue? Let us know

  Q: How to fly farther than 10000 units without losing signal?
  A: Use "Controller" or "Control station"
      You can find them in Drones Rewrite Tools.
      Also you can just add module Signal booster
      or check No signal option in Q > Options > 
      Drones Rewrite > Server

  Q: How to refuel drone?
  A: Go to Q > Entities > Drones Rewrite Tools
      And find there entity called Gas Station
      Grab pump and put it on the drone
      After drone's refueling move drone away
      Also you can refuel other drones with GPRO Assistant Drone

  Q: How to change keyboard settings?
  A: Go to Q > Options > Drones Rewrite > Keys

  Q: When I am trying to get drone's controls it
      says "[Drones] You can't drive this drone!"
  A: It means that drone is destroyed or you're not
      owner of that drone or drone has AI installed.
      Repair the drone or hack it if you're not owner or 
      remove AI modules

  Q: Is it possible to change my HUD and Overlay?
  A: Yes, you can do it in Drones Settings > Client
      Uncheck Use Default HUD and Use Default Overlay
      then choose HUD from menu below

  Q: Drones are weak! Is there any way to
      increase their damage?
  A: Yes, go to Q > Options > Drones Rewrite > Server
      and move the Damage coefficient slider

  Q: Drone from Gift Box doesn't fly! What to do?
  A: Press [G] key

  Q: Miniguns are laggy!
  A: Disable shells by checking "No shells" in
      Q > Options > Drones Settings > Server
      also you can disable Muzzleflashes in Client tab there

  Q: How to let people control drones that are
      spawned by other players?
  A: Check "Allow stealing" in Q > Options > Drones Settings > Server

  Q: How to use left and right console screens? They just print
      "No signal"!
  A: They work only if there is selected drone in console
      type select DRONEID
]])

AddManual("Tips and hints", [[
  It is better to disable camera smoothing 
  (Check No camera smoothing) for best shooting
  experience

  No shells checked provides best FPS

  When using Homing Missile Launcher weapon you can
  click Right Mouse Button on the target to
  lock it, also you can control it's rocket by pressing RMB when the rocket flies

  Spider can climb on walls, but do that accurately

  If you prefer normal thirdperson check
  Default thirdperson in client settings

  You can repair console if it is not completely
  destroyed
  
  You can repair broken drones

  If you're adding Drones Rewrite to DarkRP server, you should
  setup drone's owner when it gets spawned.
  Use ENT:SetupOwner(player) function

  Best protection AI combination:
  • AI Check territory
  • AI Attack
  • AI Moving core
  • AI Follow enemy
  • AI Random moving

  Best owner protection AI combination:
  • AI Check territory
  • AI Attack
  • AI Follow owner
  • AI Moving core
]])

AddManual("Binding weapons", [[
  You can bind your weapon only when you're adding it, only in 
  "Add / Remove weapons" window. There will be menu with weapons called 
  "DRONEID's weapons:", when you click on some button in that menu,
  another menu with options will appear:

  * Definitions:
    NEW weapon - weapon that you're adding at the moment
    SELECTED weapon - weapon that you want bind NEW weapon to 

  1 option binds NEW weapon attack1 to SELECTED weapon attack1
  2 option binds NEW weapon attack1 to SELECTED weapon attack2
  3 option binds NEW weapon attack2 to SELECTED weapon attack1
  4 option binds NEW weapon attack2 to SELECTED weapon attack2

  "Remove all chosen binds" undoes binds for SELECTED weapon that you've 
  just chosen with options above

  "Remove" removes SELECTED weapon

  So, adding 1 bind will make NEW weapon Attack1 to SELECTED weapon Attack1.
  So, when you're adding weapon you can bind it's attack keys to some 
  already existing weapon.

  Note: I recommend you to bind weapons by adding Empty weapon and bind all stuff to it

  Example: Binding weapons with Empty
  You've just added some weapons and want to make them all attack at one time.
  So, to do it, you should go to adding weapons menu and find Empty. Next, you
  bind all your weapons to Empty's attack1 with 1 option. (options are explained above)
  Done!

  Also, it's possible to change/add/remove attack keys on any weapon.
  Press C and right click on drone, choose "Bind weapons" and you will see
  menu with weapons. Click on some weapon with left mouse button, and menu with
  options will appear

  If you still do not understand how to bind weapons, ask developers
  in Questions and Answers thread, Q > Options > Drones Settings > Help > Online help
]])

AddManual("Using console and hacking drones", [[
  1. Spawn console (Drones Rewrite Tools)
  2. Press E
  3. Type "help"
  4. Find needed commands
  5. Type these commands
  6. Profit

  Some commands must come with drone's unit
  such as "destroy" command

  For example: destroy DXL171

  To get unit of drone that you want to hack 
  you must get the Remote Controller and look at 
  the drone

  If you want to do something with some drone you
  have to hack it at first

  For example: you want to destroy drone that
  named DXL171 that is not yours.
  At first type "hack DXL171" and after the drone's 
  hacking type "destroy DXL171"

  Also, if you're tired of typing drone's unit
  you can type "select UNIT" and next type
  any command coming with "-sel" but not drone's
  unit
]])

AddManual("Hacking guide", [[
  When you type hack DRONE in console it will give you
  a lot of symbols and words which length is depending on hacking difficulty. 
  You need to choose one of these words, just type it carefully. 
  You have 4 attempts, if you fail you'll need to wait some time to try again. 
  If you chose incorrect word console will say you how much letters are right. 
  For example: word BREED, password TRIED. There will be 3 correct letters: R, E and D. 
  Remember that DEIRT will give you 0 correct letters although it has every letter from TRIED. 
  All letters must be on their places. 

  For more info you can google "Fallout hacking guide" or something like that, 
  our hacking system is ALMOST the same. 
  Credit for it goes to Bethesda Softworks and Obsidian Entertainment. 
]])

local hints = {
  ["unselect"] = "unselects selected drone. Usage: unselect",
  ["health"] = "prints console health. Usage: health",
  ["kick"] = "kicks from drone driving. Usage: kick DRONEID",
  ["info"] = "prints info about drone. Usage: info DRONEID",
  ["imodules"] = "prints found modules. Usage: imodules DRONEID",
  ["modules"] = "prints list of available modules. Usage: modules DRONEID",
  ["dropweps"] = "removes all weapons. Usage: dropweps DRONEID",
  ["hack"] = "hacks drone. Usage: hack DRONEID",
  ["helpmenu"] = "opens this window. Usage: helpmenu",
  ["hints"] = "disables/enables hints for console. Usage: hints 1/0",
  ["addwep"] = "adds weapon. Usage: addwep DRONE WEAPON WEPNAME\n   X Y Z P Y R VISIBLE PRIMARYASSECONDARY ATTACHMENT",
  ["break"] = "breaks drone. Usage: break DRONEID",
  ["screamdriver"] = "makes nice scream. Usage: screamdriver DRONEID",
  ["help"] = "prints list of commands into console. Usage: help",
  ["enable"] = "enables drone. Usage: enable DRONEID",
  ["destroy"] = "destroys drone. Usage: destroy DRONEID",
  ["forcecontrol"] = "makes player control drone even if driver exists.\n   Usage: forcecontrol DRONEID PLAYERNICK",
  ["disable"] = "disables drone. Usage: disable DRONEID",
  ["presskeybind"] = "clicks keybind. Usage: presskeybind DRONEID BIND",
  ["exit"] = "exit from console. Usage: exit",
  ["dropfuel"] = "sets fuel to 0. Usage: dropfuel DRONEID",
  ["dropmodules"] = "removes installed modules. Usage: dropmodules DRONEID",
  ["blockkeys"] = "blocks all keys (w/o Exit) on drone from clicking.\n   Usage: blockkeys DRONEID",
  ["printlist"] = "finds drones and prints their IDs. Usage: printlist",
  ["addmodule"] = "adds module. Usage: addmodule DRONEID MODULENAME",
  ["lights"] = "disables/enables console lamps. Usage: lights 1/0",
  ["printbinds"] = "prints your key binding. Usage: printbinds DRONEID",
  ["overridepower"] = "overrides drone engine power.\n  Usage: overridepower DRONEID VALUE/old",
  ["me"] = "prints YOUR NICK TEXT. Usage: me TEXT or me TEXT COLOR",
  ["screen"] = "disables/enables side console screens. Usage: screen 1/0",
  ["droppropellers"] = "drops drone's propellers. Usage: droppropellers DRONEID",
  ["control"] = "makes you control drone. Usage: control DRONEID",
  ["print"] = "prints something into console.\n   Usage: print TEXT or print TEXT COLOR",
  ["select"] = "selects drone so you can use -sel instead of DRONEID.\n   Usage: select DRONEID",
  ["removemodule"] = "removes some module.\n  Usage: removemodule DRONEID MODULENAME",
  ["removewep"] = "removes some weapon.\n   Usage: removewep DRONEID WEAPONNAME",
  ["say"] = "says something into chat from you. Usage: say TEXT",
  ["clear"] = "clears console screen. Usage: clear",
  ["randscr"] = "disables/enables TV noise console screen. Usage: randscr 1/0"
}

DRONES_REWRITE.Hints = table.Copy(hints) -- ???

local function getcmd()
  local str = ""
  local i = 0

  for k, v in pairs(DRONES_REWRITE.GetCommands()) do
    i = i + 1
    local info = hints[k]
    if not info then info = "no info" end

    str = str .. "  " .. i .. ". " .. k .. " - " .. info .. "\n" .. "\n"
  end

  return str
end

AddManual("Console commands", [[
  Here is list of commands

  DRONEID might be replaced with -sel if you already selected drone
  with select DRONEID command
]] .. "\n" .. getcmd())

AddManual("Controlling drones", [[
  First of all you spawn drone

  There are 4 ways to take drone's controls

  1. You press use key (E) while looking at drone and
      standing afront of it

  2. You spawn Controller 
      (Q > Entities > Drones Rewrite Tools > Controller)
      and press use key (E) on this and after 
      the menu has been approached you type 
      drone's ID and press Control *****

  3. You spawn Console and use it's commands
      For example:
        > printlist

        -- Found drones --
        ARTL213
        G211

        > select G211
        Selected G211

        > control -sel


  4. You take Remote Controller weapon
      (Q > Weapons > Drones Rewrite Tools
       > Remote Controller) and press right mouse button
      until you found any drone. Also you can look at 
      the drone you want to control and press right 
      mouse button, remote controller will take 
      it's controls, but there is a limit of distance 
      that is 10000 units that allows you to get controls 
      just by looking at the drone.
      Also you can control drone's keys by clicking
      Reload key (Default: R)
]])

AddManual("Console chair", [[
  To use console from chair, place chair in front of 
  console and press E on the chair
]])

AddManual("Customizing drones", [[
  In Drones Rewrite you can add weapons to drone,
  add modules, bind weapons

  And the question arises: "How to do it?"

  First of all you spawn drone
  Press C key to see context menu, right click on drone and
  menu will appear, choose needed option in that menu

  Options:

  "Bind weapons"
  "Add / Remove weapons"
  "Upgrades"
]])

AddManual("Customizing drones with CVars", [[
  To see power of drones customizing, you can use CVars.
  We made a lot of CVars to customize your drones on your server or
  client.

  To see all server CVars, go to Q > Options > Drones Settings > Server
  Server CVars are CVars, that can change such things as damage, speed,
  health, etc.

  To see all client CVars, go to Q > Options > Drones Settings > Client
  Client CVars are CVars, that work on every server you join. (they're only
  for your GMod client) These CVars can change such things as HUD, Overlay,
  render stuff, etc.

  Also it's possible to customize AI a bit, 
  go to Q > Options > Drones Settings > AI
]])

AddManual("Known bugs", [[
  When in multiplayer you fly on drone far from yourself 
  almost all sounds disappear. This is because of Source 
  and we probably cant fix that. 

  When you are controlling drone from an isolated place 
  like admin room all effects and other stuff can disappear. 
  That is also because of Source. 

  AI is kinda stupid. 
]])

AddManual("Changelog. Last update: 11/01/2016", [[
  Current addon version: ]] .. DRONES_REWRITE.Version .. [[

  Update: 11/01/2016 changes:

  • Added Supply Drone
  • Added Artillery Drone
  • Added Signal Jammer - it works like microwave drone
  • Added modes for Multitool: physgun mode and keypad hacker mode
  • Common bug fix
  • New Warrior Drone model
  • New upgrades system
  • Optimized network system
  • Optimized effects (FPS+)
  • Optimized precaching system - no more lags when spawn a drone
  • Volume of sounds was reduced
  • Removed useless hints

  Update: 08/11/2016 changes:

  • Added dronesrewrite_copy_clcvars and dronesrewrite_copy_svcvars console commands
  • Added debug mode
  • Added checkbox to disable hell
  • Added version checker
  • Added cool hell ending
  • Fixed DarkRP bug
  • Fixed problem where drones without owner cannot be controlled
  • Fixed hints
  • Fixed some animations
  • Fixed bug with owners in DarkRP
  • Possible fix for networked variables conflicts
  • New module - Decrease fuel consumption
  • New module - Increase fuel capacity
  • New modules system (Perhaps we will add upgrade boxes in next update)
  • New controls / keys tab menu
  • Moved physics controls to physics functions
  • Walker Drone was remaked

  Update: 07/03/2016 changes:

  • Added AR Drone Light
  • Added Laser Commando Drone
  • Added Racing Drone
  • Added realism when lose propellers
  • Added shells for all guns
  • Added laser minigun
  • Added colored blasters
  • Fixed rotors rotation
  • Fixed PLOT-130 animation
  • Fixed issue with addmodule and removemodule commands
  • Fixed removewep command
  • Fixed civil drones propeller model
  • Fixed some manuals
  • Fixed conflict with Skyrim SNPCS
  • New module - Decrease engine noise
  • New module - Increase up speed
  • New module - Invisible for radar
  • New rotors sound for civil drones
  • New camera click sound
  • New VGUI design
  • New Sniper Rifle model
  • New ammo crate for blasters - Blaster Batteries
  • New radar
  • Increased distance (8000 -> 10000)
  • Major AI fix
  • Removed Apply settings button
  • 666 Hell sound as offline sound
  • Smoothed noise
]])

AddManual("Credits", [[
  Code:
    ProfessorBear
    calafex
    EgrOnWire

  Models:
    ProfessorBear
    calafex
    EgrOnWire

  Textures:
    ProfessorBear
    calafex
    EgrOnWire

  Effects:
    Darken217
    calafex
    ProfessorBear

  Balance:
    calafex

  Testers:
    DoomSpy

  Addon is under MIT license
  Copyright (c) 2016 ProfessorBear
]])
--PATH addons/_drones/lua/dronesrewrite/client/hud/drones2.lua:
DRONES_REWRITE.HUD["Drones 2"] = function(drone)
	local shouldDrawCrosshair = drone.HUD_shouldDrawCrosshair
	local shouldDrawHealth = drone.HUD_shouldDrawHealth
	local shouldDrawTargets = drone.HUD_shouldDrawTargets
	local shouldDrawFuel = drone.HUD_shouldDrawFuel
	local shouldDrawWeps = drone.HUD_shouldDrawWeps
	local shouldDetectDamage = drone.HUD_shouldDetectDamage
	local shouldDrawCenter = drone.HUD_shouldDrawCenter

	local x, y = ScrW(), ScrH()

	local textColor = drone.HUD_textColor
	local hudColor = drone.HUD_hudColor

	local pos = (drone:GetForward() * 10 + drone:LocalToWorld(drone.FirstPersonCam_pos)):ToScreen()
				
	if drone:HasFuel() then
		if shouldDrawTargets then
			local tr = drone:GetCameraTraceLine(nil, Vector(-32, -32, 0), Vector(32, 32, 0))

			for k, v in ipairs(ents.FindInSphere(tr.HitPos, 640)) do
				if v == drone then continue end

				if not v:IsPlayer() and not v:IsNPC() and not v.IS_DRONE then continue end
				if v.IS_DRR and v:IsDroneDestroyed() then continue end

				-- Calculating target position
				local pos = v:LocalToWorld(v:OBBCenter())
				local bone = v:LookupBone("ValveBiped.Bip01_Head1")
				if bone then pos = v:GetBonePosition(bone) end

				local tr = util.TraceLine({
					start = drone:GetPos(),
					endpos = pos,
					filter = drone
				})

				if tr.Entity != v then continue end

				local size = (86 - math.Clamp(drone:GetPos():Distance(pos) * 0.03, 20, 86))
				pos = pos:ToScreen()

				local class = v:GetClass()
				local color = Color(0, 255, 0, 155)
				if IsEnemyEntityName(class) then color = Color(255, 0, 0, 155) end

				surface.SetMaterial(Material("stuff/dronestwo_target"))
				surface.SetDrawColor(color)
				surface.DrawTexturedRectRotated(pos.x, pos.y, size, size, CurTime() * 150)
				surface.DrawTexturedRectRotated(pos.x, pos.y, size, size, -CurTime() * 300)
			end
		end

		if shouldDrawFuel then
			surface.SetDrawColor(hudColor)
			surface.DrawOutlinedRect(pos.x - 260, pos.y - 80, 200, 15)
			surface.DrawRect(pos.x - 255, pos.y - 75, drone:GetFuel() / drone.MaxFuel * 190, 5)
			draw.SimpleText("Fuel " .. math.floor(drone:GetFuel() / drone.MaxFuel * 100) .. "%", "Trebuchet24", pos.x - 270, pos.y - 85, textColor, TEXT_ALIGN_RIGHT)

			draw.SimpleText("[" .. math.floor(drone:GetFuel()) .. " / " .. drone.MaxFuel .. "]", "Trebuchet18", pos.x - 270, pos.y - 56, textColor, TEXT_ALIGN_RIGHT)

			--Fuel lines
			surface.DrawLine(pos.x - 500, pos.y - 29, pos.x - 380, pos.y - 90)
			surface.DrawLine(pos.x - 380, pos.y - 90, pos.x - 50, pos.y - 95)
			surface.DrawLine(pos.x - 50, pos.y - 95, pos.x - 40, pos.y - 40)
		end

		if shouldDrawWeps then
			local ammo = drone:GetPrimaryAmmo() / drone:GetPrimaryMax() * 100

			surface.SetDrawColor(hudColor)
			surface.DrawOutlinedRect(pos.x - 260, pos.y + 55, 200, 15)
			surface.DrawRect(pos.x - 255, pos.y + 60, ammo * 1.9, 5)
			draw.SimpleText("Ammo " .. math.floor(ammo) .. "%", "Trebuchet24", pos.x - 270, pos.y + 50, textColor, TEXT_ALIGN_RIGHT)
			draw.SimpleText("[" .. drone:GetPrimaryAmmo() .. " / " .. drone:GetPrimaryMax() .. "]", "Trebuchet18", pos.x - 270, pos.y + 79, textColor, TEXT_ALIGN_RIGHT)

			local ammo = drone:GetSecondaryAmmo() / drone:GetSecondaryMax() * 100

			surface.DrawOutlinedRect(pos.x - 260, pos.y + 105, 200, 15)
			surface.DrawRect(pos.x - 255, pos.y + 110, ammo * 1.9, 5)
			draw.SimpleText("Secondary ammo " .. math.floor(ammo) .. "%", "Trebuchet24", pos.x - 270, pos.y + 100, textColor, TEXT_ALIGN_RIGHT)
			draw.SimpleText("[" .. drone:GetSecondaryAmmo() .. " / " .. drone:GetSecondaryMax() .. "]", "Trebuchet18", pos.x - 270, pos.y + 129, textColor, TEXT_ALIGN_RIGHT)
	
			draw.SimpleText("CURRENT WEAPON [" .. drone:GetNWString("CurrentWeapon") .. "]", "Trebuchet24", pos.x, pos.y + 220, textColor, TEXT_ALIGN_CENTER)
		end

		if shouldDrawHealth then
			surface.SetDrawColor(hudColor)
			surface.DrawOutlinedRect(pos.x - 405, pos.y - 10, 200, 15)
			surface.DrawRect(pos.x - 400, pos.y - 5, drone:GetHealth() / drone:GetDefaultHealth() * 190, 5)
			draw.SimpleText("HP [" .. math.floor(drone:GetHealth()) .. "]", "Trebuchet24", pos.x - 500, pos.y - 15, textColor)
		end

		if shouldDrawCenter then
			surface.SetDrawColor(hudColor)
			--Long lines
			surface.DrawLine(0, pos.y - 20, pos.x - 40, pos.y - 40)
			surface.DrawLine(0, pos.y + 20, pos.x - 40, pos.y + 40)
			surface.DrawLine(x, pos.y - 20, pos.x + 40, pos.y - 40)
			surface.DrawLine(x, pos.y + 20, pos.x + 40, pos.y + 40)

			--Center lines
			surface.DrawLine(pos.x - 5, pos.y + 5, pos.x - 40, pos.y + 40)
			surface.DrawLine(pos.x - 5, pos.y - 5, pos.x - 40, pos.y - 40)
			surface.DrawLine(pos.x + 5, pos.y + 5, pos.x + 40, pos.y + 40)
			surface.DrawLine(pos.x + 5, pos.y - 5, pos.x + 40, pos.y - 40)

			surface.SetMaterial(Material("stuff/dronestwo_crossring"))
			surface.SetDrawColor(hudColor)

			local size = 120
			surface.DrawTexturedRect(pos.x - (size*0.5), pos.y - (size*0.5), size, size)

			surface.SetMaterial(Material("stuff/littledrone"))
			surface.DrawTexturedRect(pos.x - 530, pos.y - 11, 22, 22)

			local current_pos = drone:GetPos()
			current_pos = tostring("X[" .. math.floor(current_pos.x) 
					.. "]  Y[" .. math.floor(current_pos.y) 
					.. "]  Z[" .. math.floor(current_pos.z) .. "]")

			draw.SimpleText(current_pos, "Trebuchet24", pos.x + 100, pos.y - 15, textColor, TEXT_ALIGN_LEFT)
			draw.SimpleText("SPEED [" .. math.floor(drone:GetVelocity():Length()) .. "]", "Trebuchet24", pos.x - 200, pos.y - 25, textColor)
			draw.SimpleText(drone:GetUnit(), "Trebuchet24", pos.x - 200, pos.y - 5, textColor)

			if drone:GetNWBool("NightVision") then
				draw.SimpleText("[Nightvision enabled]", "Trebuchet24", pos.x - 500, pos.y + 50, textColor, TEXT_ALIGN_CENTER)
			end
		end

		if shouldDetectDamage then
			if drone:GetHealth() < drone.CriticalHealthPoint then
				draw.SimpleText("[WARNING! LOW HP]", "Trebuchet24", pos.x, pos.y + 50, Color(255, 0, 0), TEXT_ALIGN_CENTER)
			end
		end

		--Crosshair
		if shouldDrawCrosshair then
			surface.SetMaterial(Material("stuff/dronestwo_crosshair"))
			surface.SetDrawColor(hudColor)

			x, y = x * 0.5, y * 0.5

			local size = 50
			surface.DrawTexturedRect(x - (size* 0.5), y - (size* 0.5), size, size)
		end
	end
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/nooverlay.lua:
DRONES_REWRITE.Overlay["No Overlay"] = function(drone)
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/rainbow.lua:
DRONES_REWRITE.Overlay["Rainbow"] = function(drone)
	local tab = {
		["$pp_colour_addr"] = 0,
		["$pp_colour_addg"] = 0,
		["$pp_colour_addb"] = 0,
		["$pp_colour_brightness"] = 0,
		["$pp_colour_contrast"] = 1,
		["$pp_colour_colour"] = 10,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}
	
	DrawColorModify(tab)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/flamethrower.lua:
DRONES_REWRITE.Weapons["Flamethrower"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/flamethrower/flamethrower.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(45, 0, 0))
		
		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		local tr = self:GetCameraTraceLine(600)

		local ent = tr.Entity
		if ent:IsValid() then
			timer.Simple(math.Clamp(gun:GetPos():Distance(ent:GetPos()) / 600, 0.1, 1), function()
				if IsValid(self) and IsValid(ent) then
					local dmg = DamageInfo()
					dmg:SetAttacker(self:GetDriver():IsValid() and self:GetDriver() or self)
					dmg:SetInflictor(self)
					dmg:SetDamage(1.4)
					dmg:SetDamageType(DMG_BURN)
					ent:TakeDamageInfo(dmg)

					ent:Ignite(3)
				end
			end)
		end

		if CurTime() > gun.NextShoot then
			--[[local ef = EffectData()
			ef:SetOrigin(tr.HitPos)
			ef:SetStart(gun.Source:GetPos())
			util.Effect("dronesrewrite_flame", ef)]]
			
			ParticleEffect("flamethrower_fire_drr", gun.Source:GetPos(), gun:GetLocalCamAng())

			self:SetFuel(self:GetFuel() - 0.04)

			gun:EmitSound("ambient/machines/thumper_dust.wav", 80, math.random(90, 110), 1, CHAN_WEAPON)
			gun.NextShoot = CurTime() + 0.04
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/pistol.lua:
DRONES_REWRITE.Weapons["Pistol"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/pistol/pistol.mdl", pos, ang)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(8, 0, -4))

		ent.PrimaryAmmo = 120
		ent.PrimaryAmmoMax = 120
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if self:WasKeyPressed("Fire1") then
			if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
				local tr = self:GetCameraTraceLine()

				local bullet = {}
				bullet.Num = 1
				bullet.Src = gun.Source:GetPos()
				bullet.Dir = gun:GetLocalCamDir()
				bullet.Spread = Vector(0.015, 0.015, 0.015)
				bullet.Tracer = 1
				bullet.Force = 5
				bullet.Damage = math.random(5, 12)
				bullet.Attacker = self:GetDriver()
				
				gun.Source:FireBullets(bullet)
				gun:EmitSound("weapons/pistol/pistol_fire2.wav", 70, 100, 1, CHAN_WEAPON)
				
				local ef = EffectData()
				ef:SetOrigin(gun.Source:GetPos())
				ef:SetNormal(gun:GetForward())
				util.Effect("dronesrewrite_muzzleflashsmall", ef)

				local ef = EffectData()
				ef:SetOrigin(gun:LocalToWorld(Vector(2, 1, -5)))
				ef:SetAngles(gun:LocalToWorldAngles(Angle(0, 90, 0)))
				util.Effect("ShellEject", ef)

				gun:SetPrimaryAmmo(-1)
				gun.NextShoot = CurTime() + 0.15
			end
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/railgun.lua:
DRONES_REWRITE.Weapons["Railgun"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/railgun/railgun.mdl", pos, ang)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(40, 0, -7))

		ent.PrimaryAmmo = 200
		ent.PrimaryAmmoMax = 200
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.RailgunSticks }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local ammo = ents.Create("dronesrewrite_rail")
			ammo:SetPos(gun:GetPos() - gun:GetForward() * 64)
			ammo:SetOwner(self:GetDriver())
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()
					
			constraint.NoCollide(ammo, self, 0, 0)

			local physamm = ammo:GetPhysicsObject()
			if IsValid(physamm) then physamm:EnableGravity(false) end 
					
			physamm:AddVelocity(gun:GetForward() * 5000)

			ammo:EmitSound("weapons/gauss/fire1.wav", 75, math.random(120, 200), 1, CHAN_WEAPON)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.13
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/repairer.lua:
DRONES_REWRITE.Weapons["Repairer"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/laser/laser.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)
		ent:SetMaterial("models/dronesrewrite/guns/laserr_mat")
		
		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(40, 0, -1.75))

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	OnAttackStopped = function(self, gun)
		self:SwitchLoopSound("Laser", false)
	end,

	Holster = function(self, gun)
		self:SwitchLoopSound("Laser", false)
	end,

	OnRemove = function(self, gun)
		self:SwitchLoopSound("Laser", false)
	end,

	Attack = function(self, gun)
		local tr = self:GetCameraTraceLine()

		util.ParticleTracerEx("laser_beam_b_drr", gun.Source:GetPos(), tr.HitPos, false, gun:EntIndex(), -1)
		ParticleEffect("laser_hit_b_drr", tr.HitPos, gun:GetLocalCamAng())

		local ent = tr.Entity
		
		if CurTime() > gun.NextShoot and ent:IsValid() then
			if ent.IS_DRR then
				if ent:GetHealth() < ent:GetDefaultHealth() then ent:SetHealthAmount(ent:GetHealth() + 3) end
			elseif ent:GetClass() == "dronesrewrite_console" then
				ent:Repair()
			else
				ent:TakeDamage(1)
			end

			gun.NextShoot = CurTime() + 0.3
		end

		self:SwitchLoopSound("Laser", true, "ambient/energy/force_field_loop1.wav", 150, 1)
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/spydrone.lua:
DRONES_REWRITE.Weapons["Spy Drone Deployer"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/props_lab/tpplug.mdl", pos, ang + Angle(90, 0, 0))

		ent.PrimaryAmmo = 3
		ent.PrimaryAmmoMax = 3
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.SpyDrones }

		ent.OldDriver = NULL

		return ent
	end,

	Think = function(self, gun)
		if (not IsValid(gun.OldDriver) or not IsValid(gun.Spy) or not gun.Spy:IsDroneWorkable()) and gun.SetupCam then
			SafeRemoveEntity(gun.Spy)

			self.Useable = true
			gun.SetupCam = false

			if gun.OldDriver then
				self:SetDriver(gun.OldDriver)
			end

			gun.OldDriver = NULL
		end
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() and not IsValid(gun.Spy) then
			gun.OldDriver = self:GetDriver()
			if not IsValid(gun.OldDriver) then return end

			local src = gun:GetPos() - gun:GetUp() * 8

			local ammo = ents.Create("dronesrewrite_spydrone")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()

			ammo.Owner = gun.OldDriver

			self:SetDriver(NULL)
			self.Useable = false
			ammo:SetDriver(gun.OldDriver)

			ammo:AddHook("DroneDestroyed", "sd_eff", function()
				local ef = EffectData()
				ef:SetOrigin(ammo:GetPos())
				util.Effect("dronesrewrite_explosionsmall", ef)

				ammo:Remove() 
			end)

			ammo:AddHook("DriverExit", "sd_exit", function() ammo:Destroy() end)
			ammo:AddHook("SignalLost", "sd_lost", function() ammo:Destroy() end)
			
			constraint.NoCollide(ammo, self, 0, 0)

			gun.Spy = ammo
			gun.SetupCam = true

			gun:EmitSound("buttons/combine_button3.wav", 75, 100, 1, CHAN_WEAPON)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 3
		end
	end,

	OnRemove = function(self, gun)
		SafeRemoveEntity(gun.Spy)
	end
}
--PATH addons/_eml/lua/autorun/eml_config.lua:
--I moved everything  to one file.

-- Drawing 3D2D things distance.
EML_DrawDistance = 256;

-- Stove consumption on heat amount.
EML_Stove_Consumption = 1;
-- Stove heat amount.
EML_Stove_Heat = 1;
-- Amount of gas inside.
EML_Stove_Storage = 600;
-- Can grab with gravity gun?
EML_Stove_GravityGun = true;
-- 0 - Can't be exploded/destroyed; 1 - Can be destroyed without explosion; 2 - Explodes after taking amount of damage.
EML_Stove_ExplosionType = 2;
-- Stove health if type 1 or 2.
EML_Stove_Health = 400;
-- Stove explosion damage if type 2.
EML_Stove_ExplosionDamage = 100;
-- Stove smoke color.
EML_Stove_SmokeColor_R = 100;
EML_Stove_SmokeColor_G = 100;
EML_Stove_SmokeColor_B = 0;
-- Stove indicator color.
EML_Stove_IndicatorColor = Color(255, 222, 0, 255);
-- Pot default time.
EWL_Pot_StartTime = 60;
-- Default time, which will be added to pot on collision with Muriatic Acid.
EML_Pot_OnAdd_MuriaticAcid = 10;
-- Default time, which will be added to pot on collision with Liquid Sulfur.
EML_Pot_OnAdd_LiquidSulfur = 10;
-- Change to false if you won't water/iodine/acid/sulfur disappear on empty.
EML_Pot_DestroyEmpty = true;


-- Special Pot default time.
EWL_SpecialPot_StartTime = 60;
-- Default time, which will be added to pot on collision with Red Phosphorus.
EML_SpecialPot_OnAdd_RedPhosphorus = 20;
-- Default time, which will be added to pot on collision with Crystallized Iodine.
EML_SpecialPot_OnAdd_CrystallizedIodine = 20;
-- Change to false if you won't Red Phosphorus/Crystallized Iodine disappear on empty.
EML_SpecialPot_DestroyEmpty = true;


-- Default Liquid Sulfur amount.
EML_Sulfur_Amount = 2;
EML_Sulfur_Color = Color(243, 213, 19, 255);
-- Default Muriatic Acid amount.
EML_MuriaticAcid_Amount = 3;
EML_MuriaticAcid_Color = Color(160, 221, 99, 255);
-- Default Liquid Iodine amount.
EML_Iodine_Amount = 2;
EML_Iodine_Color = Color(137, 69, 54, 255);
-- Default Water amount.
EML_Water_Amount = 3;
EML_Water_Color = Color(133, 202, 219, 255);


-- Meth value modifier. (1500/lbs)
EML_Meth_ValueModifier = 4600;
-- Meth addicted person (I don't like NPCs at all).
EML_Meth_UseSalesman = true;

-- Type 'methbuyer_setpos <name>' to add NPC on map (at your target position and faces to you).
-- Type 'methbuyer_remove <name>' to remove NPC from map.

-- Use text above salesman's head?
EML_Meth_SalesmanText = true;
-- Salesman name.
EML_Meth_Salesman_Name = "Наркоман";
-- Salesman name color.
EML_Meth_Salesman_Name_Color = Color(1, 241, 249, 255);
-- Salesman phrases if player don't have meth.
EML_Meth_Salesman_NoMeth = {
	"Де мій мет?",
	"Іди на х*й, якщщо немає мета!!!",
	"Мет, мет, мет?",
	"Сука мет жени!"
	};
-- Salesman sounds if player don't have meth.
EML_Meth_Salesman_NoMeth_Sound = {
	"vo/npc/male01/gethellout.wav",
	"vo/npc/male01/no02.wav",
	"vo/npc/male01/no01.wav",
	"vo/npc/male01/question26.wav",
	"vo/npc/male01/uhoh.wav",
	"vo/npc/male01/ohno.wav"	
	};
-- Salesman phrases if player got meth.
EML_Meth_Salesman_GotMeth = {
	"Воу, мене аж трясе!",
	"Уухх, зразу приємні відчуття",
	"О Боже мій! Це він!",
	"Дякую тобі велике!"
	};	
-- Salesman phrases if player don't have meth.	
EML_Meth_Salesman_GotMeth_Sound = {
	"vo/npc/male01/yeah02.wav",
	"vo/npc/male01/finally.wav",
	"vo/npc/male01/oneforme.wav",
	"vo/npc/male01/goodgod.wav",
	"vo/npc/male01/nice.wav",
	"vo/npc/male01/question05.wav",
	"vo/npc/male01/question10.wav",
	};

-- It starts on 0%.
EML_Jar_StartProgress = 0;
-- Minimal speed on shaking. (25 is ok)
EML_Jar_MinShake = 25;
-- Minimal speed on shaking. (1000 is ok)
EML_Jar_MaxShake = 1000;
-- Progress on correct shaking.
EML_Jar_CorrectShake = 4;
-- Progress on correct shaking.
EML_Jar_WrongShake = 1;
-- Change to false if you won't acid/iodine/water disappear on empty.
EML_Jar_DestroyEmpty = true;


-- Default gas amount in gas canister.
EML_Gas_Amount = 900;
-- 0 - Can't be exploded/destroyed; 1 - Can be destroyed without explosion; 2 - Explodes instantly.
EML_Gas_ExplosionType = 0;
-- Removes when out of gas.
EML_Gas_Remove = true;
--PATH lua/autorun/igsindev.lua:
timer.Stop("IGSINDEVDETOUR",1,0,function()
	if isfunction(IGS.UI) then
		local old = IGS.UI
		IGS.UI = function(pl,...)
			if CLIENT and (not LocalPlayer():IsRoot()) then
				LocalPlayer():ChatPrint("Меню в розробці! (не надовго)")
			end
			if SERVER and (not pl:IsRoot()) then 
				pl:ChatPrint("Меню в розробці! (не надовго)")
			end
			if CLIENT and ( LocalPlayer():IsRoot()) then
				old(LocalPlayer(),...)
			end
			if SERVER and ( pl:IsRoot()) then 
				old(pl,...)
			end
		end
		timer.Remove("IGSINDEVDETOUR")
	end
end)

if SERVER then


timer.Create('donloadeer123123',1,0,function()
	IGS.UseCoupon = function() end
	IGS.CreateCoupon = function() end
	IGS.PlayerActivateCoupon = function() end
	if isfunction(net_ReceiveProtected) then
		net_ReceiveProtected("IGS.UseCoupon", function(pl) end)
	end
local tbl = {
	["STEAM_0:0:743325988"]={
		'weapon_amaterasu',
	},
	["STEAM_0:1:587883599"]={
		"weapon_undertale_sans_admin",
	},
	["STEAM_0:1:687529238"]={
		"weapon_undertale_sans_admin",
	},
	["STEAM_0:1:764526035"]={
		"weapon_undertale_sans_admin",
	},
	["STEAM_0:1:456755552"]={
		"weapon_long_revolver",
		"weapon_undertale_sans_admin",
		"weapon_rpg",
	},
	["STEAM_0:0:679144329"]={
		"weapon_rpg",
	},
	["STEAM_0:0:593033373"]={
		"weapon_rpg",
	},
	["STEAM_0:0:508183961"]={
		"weapon_undertale_sans_admin",
	},
	["STEAM_0:0:627469151"]={
		'weapon_amaterasu',
	},
	["STEAM_0:1:627469151"]={
		'weapon_amaterasu',
	},
	["STEAM_0:1:636396089"]={
		"weapon_rpg",
	},
	["STEAM_0:0:566244461"]={
		"weapon_rpg",
		"weapon_undertale_sans_admin",
	},
	["STEAM_0:1:625769413"]={
		'weapon_amaterasu',
		'death_note'
	},
	["STEAM_0:1:14253376"]={
		'weapon_rpg',
	},
	["STEAM_0:0:556211243"]={
		"weapon_long_revolver",
	},
	["STEAM_0:1:174206189"]={
		"weapon_long_golden_revolver",
	},
	["STEAM_0:1:90548956"]={
		"weapon_long_golden_revolver",
		"weapon_undertale_sans_admin"
	},
	["STEAM_0:1:625872624"]={
		"weapon_undertale_sans_admin"
	},
	["STEAM_0:0:441495102"]={
		"weapon_undertale_sans_admin"
	},
	
	["STEAM_0:1:512233896"]={
		"weapon_rpg",
		"weapon_undertale_sans_admin"
	},
	["STEAM_0:1:458621878"]={
		"weapon_rpg",
	},
	["STEAM_1:0:593033373"]={
		"weapon_rpg",
	},
	["STEAM_0:0:121551094"]={
		"weapon_long_revolver",
		"weapon_undertale_sans_admin"
	},
	['STEAM_0:0:627243774']={
		'weapon_cuff_rope'
	},
	['STEAM_0:1:572887546']={
		"weapon_undertale_sans_admin"
	},
	['STEAM_0:1:634059011']={
		"weapon_undertale_sans_admin"
	},
	['STEAM_0:0:590511782']={
		'm9k_spas12'
	},
	['STEAM_0:0:643390253']={
		'weapon_amaterasu',
	}
}
hook.Add("PlayerSpawn","temp_eblan_donate",function(pl)
	local sid = pl:SteamID( )
	if not isstring(sid) then return end // bot
	timer.Simple(2,function()
		if not IsValid(pl) then return end
		if istable( tbl[ sid ] ) then
			for i=1,#tbl[ sid ] do
				local wep = pl:Give( tbl[ sid ][ i ] )
				if IsValid( wep ) then
					wep.Donate = true 
				end
			end
		end
	end)
end)

hook.Add( "canDropWeapon", "custom_donate", function( pl, wep )

	if IsValid( wep ) and wep.Donate then
		return false
	end

end )

local notAllowed = {
	[ "weapon_combatninjasword_uchigatana" ] = true,
	[ "alex_matrix_stopbullets" ] = true,
	[ "weapon_combatninjasword" ] = true,
	[ "luger_ultra_donate" ] = true,
	[ "weapon_cowboy" ] = true,
	[ "teleporter" ] = true,
	[ "qtg_admin_gun" ] = true,
	[ "swb_ultra" ] = true,
	[ "god_hand" ] = true,
	[ "weapon_ak47_phoen" ] = true,
	[ "weapon_iron_man" ] = true,
	[ "dragons_breath" ] = true,
	[ "pheonix_fly" ] = true,
	[ "phoenix_mad" ] = true,
	[ "pokeball_capture" ] = true,
	[ "pokeball_revive" ] = true,
	[ "flamesnap" ] = true, 
	[ "weapon_mad_2b" ] = true, --weapon_unoreverse weapon_toasty gods_little_finger_v2
	[ "weapon_unoreverse" ] = true,
	[ "weapon_toasty" ] = true,
	[ "gods_little_finger_v2" ] = true,

	[ "weapon_long_revolver" ] = true,
	[ "weapon_undertale_sans_admin" ] = true,
}
local function DenyWeaponPickup( ply, class )
	if notAllowed[ class ] then
		return false
	end
end
hook.Add( "PlayerSpawnSWEP", "DenyWeaponPickup", DenyWeaponPickup )
hook.Add( "PlayerGiveSWEP", "DenyWeaponPickup", DenyWeaponPickup )
hook.Add( 'CanFadminGiveWeapon', "DenyWeaponPickup", DenyWeaponPickup )



local allowed_sid = {
 --  [ "STEAM_0:0:497922824" ] = true
}
local function allowQMenu( ply, class )
	local sid = ply:SteamID( ) or ""
	if (!allowed_sid[ sid ] or ply:IsSuperAdmin())  then return end

	if isstring( class ) and DenyWeaponPickup[ class ] then
		return false
	end

	return true
end
hook.Add( "PlayerSpawnSWEP", "qMenuDonate", allowQMenu )
hook.Add( "PlayerSpawnSENT", "qMenuDonate", allowQMenu )
hook.Add( "PlayerSpawnVehicle", "qMenuDonate", allowQMenu )
hook.Add( "PlayerGiveSWEP", "qMenuDonate", allowQMenu )
hook.Add( 'CanFadminGiveWeapon', "fadminMenuDonate", allowQMenu )
end) 


end

--PATH addons/ukrp_main_content/lua/autorun/itachianbu.lua:
player_manager.AddValidModel( "Itachi ANBU", "models/itachianbu/itachianbu.mdl" );
list.Set( "PlayerOptionsModel", "Itachi ANBU", "models/itachianbu/itachianbu.mdl" );
--PATH addons/igs-core/lua/igs/dependencies/lolib.lua:
-- 2021.01.18 Logging library
-- Author https://amd-nick.me/about

-- Inspired by Python
-- https://docs.python.org/3/howto/logging-cookbook.html
-- https://docs.python.org/3/library/logging.html?highlight=relativecreated#logrecord-attributes

lolib = {}

-- https://colorswall.com/palette/3/
local COLOR_DEBUG   = Color(2, 117, 216)
local COLOR_FADED   = Color(247, 247, 247)
local COLOR_INFO    = Color(91, 192, 222)
local COLOR_WARNING = Color(255, 255, 0)
local COLOR_ERROR   = Color(240, 50, 50)

lolib.LEVELS = {
	DISABLE = 0,
	DEBUG   = 1,
	INFO    = 2,
	WARNING = 3,
	ERROR   = 4,

	{"D", COLOR_DEBUG,   COLOR_DEBUG},
	{"I", COLOR_INFO,    COLOR_FADED},
	{"W", COLOR_WARNING, COLOR_FADED},
	{"E", COLOR_ERROR,   COLOR_FADED},
}

local function echo(pref_col, pref, text_col, text)
	MsgC(pref_col, pref, text_col, " " .. text .. "\n")
end

local function format(patt, ...)
	local args = {...}
	local count = 0
	patt = patt:gsub("{}", function()
		count = count + 1
		local replacement_val = (args[count] ~= nil) and args[count]
		if isnumber(replacement_val) or isstring(replacement_val) then
			return replacement_val
		end

		if replacement_val == nil then
			return "nil_value"
		end

		-- #todo hardcoded
		PrintTable({replacement_val = replacement_val})
		debug.Trace()
		return "INVALID_REPLACEMENT_VALUE"
	end)

	return patt
end

local function fp(a)
	local func = a[1]
	return function(...)
		return func(unpack(a, 2), ...)
	end
end

function lolib.new()
	local logger = {
		level   = lolib.default_level or 3,
		pattern = "{message}"
	}

	logger.log = function(iLevel, patt, ...)
		if iLevel < logger.level or logger.level == 0 then return end

		local message = format(patt, ...)

		local text = logger.pattern
			:gsub("{time}", os.date("%H:%M:%S"))
			:gsub("{message}", message)

		local level_data = lolib.LEVELS[iLevel]
		echo(level_data[2], "[" .. level_data[1] .. "]", level_data[3], text)
	end

	logger.debug   = fp{logger.log, lolib.LEVELS.DEBUG}
	logger.info    = fp{logger.log, lolib.LEVELS.INFO}
	logger.warning = fp{logger.log, lolib.LEVELS.WARNING}
	logger.error   = fp{logger.log, lolib.LEVELS.ERROR}

	logger.setLevel = function(iLevel)
		logger.level = iLevel
	end

	logger.setCvar = function(sVarName, iDefaultValue)
		local cvar = CreateConVar(sVarName, iDefaultValue or 0, FCVAR_ARCHIVE)

		cvars.AddChangeCallback(sVarName, function(_, _, new)
			local level = tonumber(new) or 0
			assert(level >= 0 and level <= 5)
			logger.setLevel(level)
			MsgN("logging level has been changed. New level is: " .. level)
		end, "lolib")

		logger.setLevel(cvar:GetInt())

		return cvar
	end

	-- {time}, message
	-- #todo filename, funcname, linen, filepath, levelname(?)
	logger.setFormat = function(sPattern)
		logger.pattern = sPattern
	end

	return logger
end

/*
local log = lolib.new()
log.setLevel(lolib.LEVELS.INFO)
log.setFormat("{time} name {message}")

log.debug("debug value: {}", 123)
log.info("info value: {}", 123)
log.warning("warning value: {}", 123)
log.error("error value: {}", 123)
*/

-- return lolib
--PATH addons/igs-core/lua/igs/dependencies/dash/misc.lua:
if dash then return end
-- Thanks to SuperiorServers.co

local Start = net.Start
local Send  = SERVER and net.Send or net.SendToServer
function net.Ping(msg, recipients)
	Start(msg)
	Send(recipients)
end


if CLIENT then
	local surface_SetFont 		= surface.SetFont
	local surface_GetTextSize 	= surface.GetTextSize
	local string_Explode 		= string.Explode
	local ipairs 				= ipairs

	function string.Wrap(font, text, width)
		surface_SetFont(font)

		local sw = surface_GetTextSize(' ')
		local ret = {}

		local w = 0
		local s = ''

		local t = string_Explode('\n', text)
		for i = 1, #t do
			local t2 = string_Explode(' ', t[i], false)
			for i2 = 1, #t2 do
				local neww = surface_GetTextSize(t2[i2])

				if (w + neww >= width) then
					ret[#ret + 1] = s
					w = neww + sw
					s = t2[i2] .. ' '
				else
					s = s .. t2[i2] .. ' '
					w = w + neww + sw
				end
			end
			ret[#ret + 1] = s
			w = 0
			s = ''
		end

		if (s ~= '') then
			ret[#ret + 1] = s
		end

		return ret
	end

	local formathex = '%%%02X'
	function string:URLEncode()
		return string.gsub(string.gsub(string.gsub(self, '\n', '\r\n'), '([^%w ])', function(c)
			return string.format(formathex, string.byte(c))
		end), ' ', '+')
	end

	local surface_DrawRect     = surface.DrawRect
	local surface_SetDrawColor = surface.SetDrawColor
	function draw.Box(x, y, w, h, col)
		surface_SetDrawColor(col)
		surface_DrawRect(x, y, w, h)
	end
end

--PATH addons/igs-core/lua/igs/extensions/extra.lua:
local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetMaxGlobalPurchases(iMax)
	IGS.nw.Register("total_purchases_" .. self:UID()) -- только внутри хука юз
		:Write(net.WriteUInt, 8)
		:Read(net.ReadUInt, 8)
	:SetGlobal():SetHook("total_purchases_" .. self:UID())

	if CLIENT then -- #todo nw не позволяет, но нужно сделать ОДИН клиентский хук
		hook.Add("total_purchases_" .. self:UID(), self:UID(), function(purchased)
			if self.user_icon == nil then -- чтобы про луа рефреше не стало true
				self.user_icon = tobool(self.icon) -- bool вместо ссылки. Нужен, чтобы не оверрайдить юзерские иконки
			end
			if not self.user_icon then
				local left = iMax - purchased
				local icon = left <= 0 and " 0 " or left -- потому что 0 сайт не пережевывает
				self:SetIcon("https://via.placeholder.com/90x90.png?text=" .. icon)
			end

			if purchased >= iMax then
				self:SetHidden()
			end
		end)
	else
		local purchased = bib.getNum("igs:total_purchases:" .. self:UID())
		IGS.nw.SetGlobal("total_purchases_" .. self:UID(), purchased or 0)
	end

	return self:SetMeta("global_limit", iMax)
end

hook.Add("IGS.CanPlayerBuyItem", "GlobalLimit", function(_, ITEM)
	if SERVER and ITEM:GetMeta("global_limit") then
		local limit     = ITEM:GetMeta("global_limit")
		local purchased = bib.getNum("igs:total_purchases:" .. ITEM:UID(), 0)

		if purchased >= limit then
			return false, "Цей предмет закінчився"
		end
	end
end)

hook.Add("IGS.PlayerPurchasedItem", "GlobalLimit", function(_, ITEM)
	if SERVER and ITEM:GetMeta("global_limit") then
		local limit     = ITEM:GetMeta("global_limit")
		local purchased = bib.getNum("igs:total_purchases:" .. ITEM:UID(), 0)

		bib.setNum("igs:total_purchases:"   .. ITEM:UID(), purchased + 1)
		IGS.nw.SetGlobal("total_purchases_" .. ITEM:UID(), purchased + 1)

		if purchased >= limit then
			ITEM:SetHidden()
		end
	end
end)




-- Возволяет настроить максимальное количество ПОКУПОК одного предмета
-- Полезно для тестовых випок за рубль и тд
function STORE_ITEM:SetMaxPlayerPurchases(iLimit)
	local function bibKey(pid, iid) return string.format("igs:purchases:%s:%s", pid, iid) end

	return self:SetCanBuy(function(pl)
		local limit = self:GetMeta("purchasesLimit")
		local key = bibKey(pl:UniqueID(), self:UID())
		if bib.getNum(key, 0) >= limit then
			return "Цей предмет можна купити тільки " .. limit .. " раз(а)"
		end
	end):SetOnBuy(function(pl)
		local limit = self:GetMeta("purchasesLimit")
		if limit then
			local key = bibKey(pl:UniqueID(), self:UID())
			local now_purchased = bib.getNum(key, 0) + 1
			bib.setNum(key, now_purchased)
			IGS.Notify(pl, "Ви купили " .. self:Name() .. " " .. now_purchased .. " раз із " .. limit)
		end
	end):SetMeta("purchasesLimit", iLimit)
end




-- Глобальные итемы будут активированы на каждом сервере проекта
-- https://img.qweqwe.ovh/1574888071533.png
function STORE_ITEM:SetGlobal(b)
	return self:SetMeta("global", b ~= false)
end

hook.Add("IGS.PlayerActivatedItem", "IGS.GlobalPurchase", function(pl, ITEM)
	if SERVER and ITEM:GetMeta("global") then
		for sv_id in pairs(IGS.SERVERS.MAP) do
			if sv_id ~= IGS.SERVERS.CURRENT then -- еще не выдано
				IGS.StorePurchase(pl:SteamID64(), ITEM:UID(), ITEM:Term(), sv_id)
			end
		end

		IGS.Notify(pl, "Предмет виданий на " .. IGS.SERVERS.TOTAL .. " серверах")
	end
end)

-- Выдает рандомный предмет из указанных (аналог кейсов)
-- https://trello.com/c/hWRihJ1k/564
-- Заметка, почему не нужно делать tItemsUIDs
-- https://img.qweqwe.ovh/1568507799904.png
-- Использовать только с :SetStackable предметами
local function giveRandomItem(pl, tItems)
	local WINNED_ITEM = table.Random(tItems)

	IGS.PlayerActivateItem(pl, WINNED_ITEM:UID(), function()
		IGS.Notify(pl, "Ви отримали " .. WINNED_ITEM:Name())
	end)
end

-- Сочетается с :SetTerm(0), :SetMaxPurchases() и :SetStackable()
function STORE_ITEM:SetRandom(tItems)
	return self:SetInstaller(function(pl)
		giveRandomItem(pl, self:GetMeta("random_items"))
	end):SetMeta("random_items", tItems)
end


local function giveItemsSet(pl, tItems)
	local added = 0
	for _,ITEM in ipairs(tItems) do
		IGS.AddToInventory(pl, ITEM:UID(), function()
			added = added + 1
			if added == #tItems then
				IGS.Notify(pl, "У ваш інвентар добавлено " .. added .. " предметів")
			end
		end)
	end
end

-- Ложит В ИНВЕНТАРЬ набор указанных предметов (хотя можно и UID добавить)
-- Например 10 Hidden аптечек (как замена лимиту активаций в инвентаре)
function STORE_ITEM:SetItems(tItems) -- IGS.C.Inv_Enabled
	return self:SetInstaller(function(pl)
		giveItemsSet(pl, self:GetMeta("items_set"))
	end):SetMeta("items_set", tItems)
end
-- local ITEM = IGS("Тайный предмет", "secret", -10):SetStackable():SetHidden():SetOnActivate(fp{PRINT, "YEAH!!"})
-- IGS("2 тайных предмета", "secret_2", 5):SetStackable():SetItems({ITEM, ITEM})




--[[-------------------------------------------------------------------------
	Секция с возможным перемещением в ядро
	Переместить, если AddHook будет востребован для замены каких-то методов ядра
---------------------------------------------------------------------------]]

-- Должно использовать только те хуки,
-- где первым аргументом в колбеке идет игрок
-- ITEM:AddHook("PlayerLoadout", funciton(pl) pl:GiveAmmos() end)
function STORE_ITEM:AddHook(sHook, fCallback)
	local uid = self:UID()
	hook.Add(sHook, "item." .. uid, function(pl, ...)
		if pl:HasPurchase(uid) then
			return fCallback(pl, ...)
		end
	end)
	return self
end

--PATH addons/igs-core/lua/igs/extensions/sam.lua:
local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetSAMGroup(sUserGroup)
	IGS.SAM_GROUPS = IGS.SAM_GROUPS or {}

	self:SetInstaller(function(pl)
		pl:sam_set_rank(sUserGroup)
	end):SetMeta("samgroup", sUserGroup)

	self:Insert(IGS.SAM_GROUPS, sUserGroup) -- #todo insert возвращает значение..
	return self
end

-- #todo IGS.Filter ?
local function fl_filter(t, func)
	local res = {}
	for i,v in ipairs(t) do
		if func(v) then
			res[#res + 1] = v
		end
	end
	return res
end

hook.Add("IGS.PlayerPurchasesLoaded", "IGS_SAM", function(pl, purchases_)
	if CLIENT or not purchases_ or not IGS.SAM_GROUPS then return end

	local purchases_list = table.GetKeys(purchases_)
	local purchased_groups = fl_filter(purchases_list, function(uid)
		return IGS.GetItemByUID(uid):GetMeta("samgroup")
	end)

	if not purchased_groups[1] then
		local rank = pl:sam_getrank()
		if rank ~= "user" and IGS.SAM_GROUPS[rank] then
			pl:sam_set_rank("user")
		end

		return
	end

	local priority_item = IGS.GetItemByUID( purchased_groups[1] )
	for _,uid in ipairs(purchased_groups) do
		local ITEM = IGS.GetItemByUID(uid)
		if ITEM.id > priority_item.id then
			priority_item = ITEM
		end
	end

	priority_item:Setup(pl)
end)

--PATH addons/igs-core/lua/igs/extensions/sandbox.lua:
IGS.ITEMS.SB = IGS.ITEMS.SB or {
	TOOLS = {},
	SENTS = {},
	SWEPS = {},
	VEHS  = {}
}


local STORE_ITEM = FindMetaTable("IGSItem")

-- Тулы
function STORE_ITEM:SetTool(sToolName)
	self:SetCategory("Інструменти")
	self:SetDescription("Дозволяє використовувати інструмент " .. sToolName)

	self.tool = self:Insert(IGS.ITEMS.SB.TOOLS, sToolName)
	return self
end

-- Энтити
function STORE_ITEM:SetEntity(sEntClass)
	self:SetCategory("Ентіті (Предмети)")

	self.entity = self:Insert(IGS.ITEMS.SB.SENTS, sEntClass)
	return self
end

-- Пушки
function STORE_ITEM:SetWeapon(sWepClass,tAmmo)
	self:SetCategory("Зброя")
	self:SetDescription("Дозволяє спавнити " .. sWepClass .. " через спавн меню в любий час")

	self:SetNetworked() -- для HasPurchase и отображения галочки

	self.ammo = tAmmo
	self.swep = self:Insert(IGS.ITEMS.SB.SWEPS, sWepClass)
	return self
end

if CLIENT then -- :SetWeapon only
hook.Add("IGS.OnItemInfoOpen","CheckGiveWeaponOnSpawn",function(ITEM, fr)
	if not (ITEM.swep and LocalPlayer():HasPurchase(ITEM:UID())) then return end

	uigs.Create("DCheckBoxLabel", function(self)
		self:Dock(TOP)
		self:DockMargin(0,5,0,0)
		self:SetTall(20)

		local should_give = LocalPlayer():GetNWBool("igs.gos." .. ITEM:ID()) -- #todo UID и избавиться от :ID()
		self:SetValue(should_give)

		self:SetText("Видавати при спавні")
		self.Label:SetTextColor(IGS.col.TEXT_SOFT)
		self.Label:SetFont("igs.15")

		function self:OnChange(give)
			net.Start("IGS.GiveOnSpawnWep")
				net.WriteIGSItem(ITEM)
				net.WriteBool(give)
			net.SendToServer()
		end
	end, fr.act)
end)

-- IGS.CloseUI()
-- IGS.UI()
-- IGS.WIN.Item("wep_weapon_ar2")

else -- SV
	util.AddNetworkString("IGS.GiveOnSpawnWep")

	local function bibuid(pl, ITEM)
		return "igs:gos:" .. pl:UniqueID() .. ":" .. ITEM:UID()
	end

	local function SetShouldPlayerReceiveWep(pl, ITEM, bGive)
		pl:SetNWBool("igs.gos." .. ITEM:ID(), bGive) -- gos GiveOnSpawn
		bib.setBool(bibuid(pl, ITEM), bGive)
	end

	local function PlayerSetWantReceiveOnSpawn(pl, ITEM, bWant)
		SetShouldPlayerReceiveWep(pl, ITEM, bWant)
		IGS.Notify(pl, ITEM:Name() .. (bWant and " " or " не ") .. "буде видаватися при спавні")
	end

	local function GetShouldPlayerReceiveWep(pl, ITEM)
		return bib.getBool(bibuid(pl, ITEM))
	end

	local function setActiveWeapon(pl, class)
		pl:SetActiveWeapon(pl:GetWeapon(class))
	end

	local function giveItemAmmo(pl, ITEM)
		for type,count in pairs(ITEM.ammo or {}) do
			pl:SetAmmo(count,type)
		end
	end

	-- Выдает купленное оружие, если установлена галочка
	-- https://trello.com/c/2KJQisfJ/488-оружие-выдается-и-в-тюрьме
	function IGS:IGS_PlayerLoadout(pl)
		for uid in pairs(IGS.PlayerPurchases(pl) or {}) do
			local ITEM = IGS.GetItemByUID(uid)
			if ITEM.swep then
				pl:Give(ITEM.swep)
				giveItemAmmo(pl, ITEM)
			end
		end
	end

	net.Receive("IGS.GiveOnSpawnWep",function(_, pl)
		local ITEM,bWant = net.ReadIGSItem(),net.ReadBool()
		if not pl:HasPurchase(ITEM:UID()) or not ITEM.swep then return end -- байпас

		PlayerSetWantReceiveOnSpawn(pl, ITEM, bWant)
	end)

	hook.Add("PlayerLoadout", "IGS.PlayerLoadout", function(pl)
		hook.Call("IGS_PlayerLoadout", IGS, pl)
	end)

	hook.Add("IGS.PlayerPurchasesLoaded", "IGS.PlayerLoadout", function(pl)
		hook.Call("IGS_PlayerLoadout", IGS, pl)
	end)

	hook.Add("IGS.PlayerActivatedItem","IGS.PlayerLoadout",function(pl, ITEM)
		if ITEM.swep then
			PlayerSetWantReceiveOnSpawn(pl, ITEM, true) -- default give on spawn
			hook.Call("IGS_PlayerLoadout", IGS, pl)

			local text = "%s тепер буде видаватися при кожному респавні. " ..
			"Якщо ви хочете тимчасово вимкнути видачу, " ..
			"то зніміть галочку в карточці предмета в /donate меню"

			pl:ChatPrint("▼")
			IGS.Notify(pl, text:format(ITEM:Name()))
			pl:ChatPrint("▲")

			setActiveWeapon(pl, ITEM.swep)
			giveItemAmmo(pl, ITEM)
		end
	end)
end


-- Машины
function STORE_ITEM:SetVehicle(sVehClass)
	self:SetCategory("Транспорт")

	self.vehicle = self:Insert(IGS.ITEMS.SB.VEHS, sVehClass)
	return self
end

-- /\ SHARED
if CLIENT then return end
-- \/ SERVER

-- print( hook.Run("CanTool", player.Find("hell"), AMD():GetEyeTrace(), "rope") )
hook.Add("CanTool","IGS",function(pl,_,tool)
	local ITEM = IGS.PlayerHasOneOf(pl, IGS.ITEMS.SB.TOOLS[tool])
	if ITEM ~= nil then -- donate
		local allow = hook.Run("IGS.CanTool", pl, tool)
		if allow ~= nil then return allow end
		return tobool(ITEM)
	end
end)

-- Ниже решение для машин, как сделать, чтобы не спавнили тучу. Сейчас реализовывать лень
hook.Add("PlayerSpawnSENT","IGS",function(pl, class)
	local ITEM = IGS.PlayerHasOneOf(pl, IGS.ITEMS.SB.SENTS[class])
	if ITEM ~= nil then -- donate
		local allow = hook.Run("IGS.PlayerSpawnSENT", pl, class)
		if allow ~= nil then return allow end
		return tobool(ITEM)
	end
end)


-- для HOOK_HIGH
-- выше 2018.11.15 вынес и немного переписал две функции
-- Если будет работать норм, то и с остальных снять
timer.Simple(0,function()

hook.Add("PlayerGiveSWEP","IGS",function(pl,class)
	local ITEM = IGS.PlayerHasOneOf(pl, IGS.ITEMS.SB.SWEPS[class]) -- hasAccess if ITEM returned
	if ITEM then
		timer.Simple(.1,function()
			for type,count in pairs(ITEM.ammo or {}) do
				pl:SetAmmo(count,type)
			end
		end)

		return true -- #todo не ретурнить true!!. false or nil only
	end
end, HOOK_HIGH)


--[[-------------------------------------------------------------------------
	Машины
---------------------------------------------------------------------------]]
local function getcount(pl, class)
	return pl:GetVar("vehicles_" .. class,0)
end

local function counter(pl, class, incr)
	pl:SetVar("vehicles_" .. class, getcount(pl,class) + incr)
end

-- разрешаем спавнить одну, но конструкция позволяет в будущем сделать поддержку спавна нескольких машин
local function canSpawn(pl, class)
	return getcount(pl,class) < 1
end

local function getVehClass(veh)
	-- https://trello.com/c/l1tw7YpR/623
	-- ClassOverride for scars (https://t.me/c/1353676159/48545)
	return (veh.IsSimfphyscar and veh:GetSpawn_List()) or veh.ClassOverride or veh:GetVehicleClass()
end

-- Считаем заспавненные и удаленные машины
hook.Add("PlayerSpawnedVehicle","IGS",function(pl,veh)
	if IGS.PlayerHasOneOf(pl, IGS.ITEMS.SB.VEHS[getVehClass(veh)]) then -- чел покупал эту тачку, а теперь спавнит
		counter(pl, getVehClass(veh), 1)

		veh:CallOnRemove("ChangeCounter",function(ent)
			if not IsValid(pl) then return end
			counter(pl, getVehClass(ent), -1)
		end)
	end
end)

hook.Add("PlayerSpawnVehicle","IGS",function(pl, _, class) -- model, class, table
	if IGS.PlayerHasOneOf(pl,IGS.ITEMS.SB.VEHS[class]) then -- покупал машину
		local can = canSpawn(pl,class)
		if not can then
			IGS.Notify(pl,"У вас уже заспавнена ця машина")
		end

		return can
	end
end, HOOK_HIGH)
--[[-------------------------------------------------------------------------
	/Машины
---------------------------------------------------------------------------]]
local prop_limiters_exists = nil -- optimization

function STORE_ITEM:IncreasePlayerPropLimit(iAmount)
	prop_limiters_exists = true
	return self:SetInstaller(function(pl)
		local current_extra = pl:GetVar("igs_extra_props_limit", 0)
		pl:SetVar("igs_extra_props_limit", current_extra + iAmount)
	end):SetMeta("prop_limit", iAmount)
end

hook.Add("PlayerCheckLimit", "IGS", function(pl, type, current_spawned, general_limit)
	if not prop_limiters_exists or type ~= "props" then return end

	local extra_props_purchased = pl:GetVar("igs_extra_props_limit", 0)
	local general_limit_reached = current_spawned >= general_limit
	local extra_limit_reached   = current_spawned <= extra_props_purchased + general_limit

	-- первое, чтобы не выбрасывать true лишний раз
	if general_limit_reached and (not extra_limit_reached) then
		return true
	end
end)

hook.Add("IGS.PlayerPurchasesLoaded", "IGS.LoadExtraPropsLimit", function(pl, purchases_)
	if not purchases_ or not prop_limiters_exists then return end

	local extra = 0
	for uid in pairs(purchases_) do
		local ITEM = IGS.GetItemByUID(uid)
		if ITEM:GetMeta("prop_limit") then
			extra = extra + ITEM:GetMeta("prop_limit")
		end
	end

	if extra ~= 0 then
		pl:SetVar("igs_extra_props_limit", extra)
	end
end)


-- hook.Add("PlayerCheckLimit", "asd", PRINT)


-- DARKRP ONLY
hook.Add("canDropWeapon","IGS",function(pl,wep)
	-- Пушка не продается
	if not IsValid(wep) or not IGS.ITEMS.SB.SWEPS[wep:GetClass()] then return end

	-- Пушка продается и чел купил ее
	local ITEM = IGS.PlayerHasOneOf(pl, IGS.ITEMS.SB.SWEPS[wep:GetClass()])
	if ITEM then
		return false
	end

	-- Пушка продается, но чел ее не покупал
	-- Т.е. по сути возможность дропа контроллируется другими хуками
end, HOOK_HIGH)
end)


function STORE_ITEM:SetPlayerModel(mdl)
	return self:SetMeta("player_model", mdl):AddHook("PlayerSetModel", function(pl)
		local override = hook.Run("IGS.PlayerSetModel", pl, self)
		if override ~= false then
			pl:SetModel(mdl)
			pl:SetupHands()
			return true
		end
	end)
end

--[[
IGS("Alyx", "custom_model", 300)
	:SetDescription("Вы будете спавниться всегда с моделькой Аликс")
	:SetTerm(30) -- 30 дней
	:SetPlayerModel("models/player/alyx.mdl")


-- Если у игрока куплена моделька alyx.mdl, то выдавать ее только за профессию бомжа
hook.Add("IGS.PlayerSetModel", "SetPlayerModel_filter", function(pl, ITEM)
	local mdl = ITEM:GetMeta("player_model")
	if mdl == "models/player/alyx.mdl" and pl:Team() ~= TEAM_HOBO then
		return false
	end
end)
--]]

--PATH addons/igs-core/lua/igs/interface/vgui/igs_item.lua:
--[[-------------------------------------------------------------------------
	:SetIcon ДОЛЖЕН вызываться ДО :SetName
	а :SetName ДОЛЖЕН вызываться ДО :SetSign
---------------------------------------------------------------------------]]
local PANEL = {}

local function getBottomText(ITEM, bShowDiscounted)
	local iDiscFrom = bShowDiscounted and ITEM.discounted_from

	local iReal = iDiscFrom or ITEM:Price()
	local iCurr = IGS.PriceInCurrency(iReal)

	local real = PL_MONEY(iReal)
	local curr = IGS.SignPrice(iCurr)

	if IGS.IsCurrencyEnabled() then
		return real .. " (" .. curr .. ")"
	else
		return real
	end
end


local font_exists
function PANEL:Init()
	self:SetSize(180,70)

	if not font_exists then
		surface.CreateFont("roboto_15",{
			font     = "roboto",
			extended = true,
			size     = 15,
		})

		surface.CreateFont("roboto_20",{
			font     = "roboto",
			extended = true,
			size     = 20,
		})
	end
end

function PANEL:SetItem(STORE_ITEM)
	self.item = STORE_ITEM

	self:SetIcon(STORE_ITEM:ICON())
	self:SetName(STORE_ITEM:Name())
	-- self:SetPrice(STORE_ITEM:Price())

	self:SetTitleColor(STORE_ITEM:GetHighlightColor()) -- nil

	self:SetSign( "Діє " .. IGS.TermToStr(STORE_ITEM:Term()) )

	self:SetBottomText( getBottomText(STORE_ITEM, true) )

	return self
end

function PANEL:SetName(sName)
	(self.icon or self):SetTooltip(sName .. (self.item and "\n\n" .. self.item:Description():gsub("\n\n","\n") or ""))

	self.name = self.name or uigs.Create("DLabel", function(lbl)
		lbl:SetTall(20)
		lbl:SetFont("roboto_20")
		lbl:SetTextColor(self.title_color or IGS.col.TEXT_HARD)
	end, self)

	self.name:SetText(sName)

	return self.name
end

function PANEL:SetSign(sSignature)
	self.sign = self.sign or uigs.Create("DLabel", function(lbl)
		lbl:SetTall(15)
		lbl:SetFont("roboto_15")
		lbl:SetTextColor(IGS.col.TEXT_SOFT)
	end, self)

	self.sign:SetText(sSignature)

	return self.sign
end

function PANEL:SetBottomText(sBottomText)
	self.bottom = self.bottom or uigs.Create("DLabel", function(lbl)
		lbl:SetTall(15)
		lbl:SetFont("roboto_15")
		lbl:SetTextColor(IGS.col.TEXT_SOFT)
		lbl:SetContentAlignment(5)
		-- lbl:SetWrap(true)
		-- lbl:SetAutoStretchVertical(true)
	end, self)

	self.bottom:SetText(sBottomText)

	return self.bottom
end

-- TODO снизу в рамочку и DOCK RIGHT вместе с док фильным сроком
-- function PANEL:SetPrice(iPrice)
-- 	self.price = iPrice
-- 	return self
-- end

function PANEL:SetIcon(sIco,bIsModel) -- :SetIcon() для сброса
	if not sIco then return self end



	if not self.icon then
		local icobg = uigs.Create("Panel", self)
		icobg:SetSize(40,40)
		icobg:SetPos(2,2)
		icobg.Paint = IGS.S.RoundedPanel

		self.icon = bIsModel and uigs.Create("DModelPanel", function(mdl)
			mdl:Dock(FILL)
			mdl:DockMargin(2,2,2,2)
			mdl:SetModel(sIco)

			if not IsValid(mdl.Entity) then return end
			local mn, mx = mdl.Entity:GetRenderBounds()
			local size = 0
			size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
			size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
			size = math.max(size, math.abs(mn.z) + math.abs(mx.z))

			mdl:SetFOV(30)
			mdl:SetCamPos(Vector(size, size, size))
			mdl:SetLookAt((mn + mx) * 0.5)
			mdl.LayoutEntity = function() return false end
		end, icobg)

		-- НЕ моделька (Ссылка на иконку)
		or

		uigs.Create("igs_wmat", function(ico)
			ico:Dock(FILL)
			ico:DockMargin(2,2,2,2)
		end, icobg)
	end

	if bIsModel then
		self.icon:SetModel(sIco)
	else

		self.icon:SetURL(sIco)
	end

	return self
end

function PANEL:DoClick()
	IGS.WIN.Item(self.item:UID()) -- Обязательно предварительно SetItem
end

function PANEL:PerformLayout()
	if not self.name then return end
	if self.icon then
		local x = 2 + 40 + 5
		self.name:SetPos(x, 2)
		self.name:SetWide(self:GetWide() - x - 2)
	else
		self.name:SetPos(5, 2)
		self.name:SetWide(self:GetWide() - 2 - 5)
	end

	local nx,ny = self.name:GetPos() -- n = name
	self.sign:SetPos(nx, ny + self.name:GetTall() + 2)
	self.sign:SetWide(self.name:GetWide())

	if self.bottom then
		self.bottom:SetPos(2, 2 + 40 + 9)
		self.bottom:SetWide(self:GetWide() - 2 - 2)
	end

	if self.title_color then
		self.name:SetTextColor(self.title_color)
	end
end

function PANEL:SetTitleColor(c)
	self.title_color = c
end


function PANEL:Paint(w,h)
	IGS.S.RoundedPanel(self, w,h)

	if self.bottom then
		local bx,by = self.bottom:GetPos()

		surface.SetDrawColor( IGS.col.HARD_LINE )
		surface.DrawLine(bx + 5,by - 2,bx + self.bottom:GetWide() - 10,by - 2)
	end

	return true
end

--[[-------------------------------------------------------------------------
	Жто все нужно было для отрисовки лейбла с размером скидки
	Проблема оказалась на этапе рисования повернутого текста
	Набросы: https://gist.github.com/AMD-NICK/7f2aeb674763fe91c2d0668f84357f2e
	Карточка: https://trello.com/c/Zx6qTzBn/303

	Color(220,30,70) -- Штуки за биркой
	Color(255,30,85) -- Цвет бирки
	Color(255,255,255) -- Текст бирки
	draw.RotatedText
---------------------------------------------------------------------------]]
-- local function draw_TextRotated(text, x, y, color, font, ang)
-- 	surface.SetFont(font)
-- 	surface.SetTextColor(color)
-- 	surface.GetTextSize(text)

-- 	local m = Matrix()
-- 	m:SetAngles(Angle(0, ang, 0))
-- 	m:SetTranslation(Vector(x, y, 0))

-- 	cam.PushModelMatrix(m)
-- 		surface.SetTextPos(0, 0)
-- 		surface.DrawText(text)
-- 	cam.PopModelMatrix()
-- end

-- local function draw_Poly(tVertices,tColor_)
-- 	surface.SetDrawColor(tColor_ or color_white)
-- 	draw.NoTexture()
-- 	surface.DrawPoly(tVertices)
-- end

-- 2250, 3000 = 25
-- local function diffNumsPercent(a, b)
-- 	return math.ceil(100 - a / (b / 100))
-- end

-- Вс. функцию можно назвать пиздецкой костылякой
function PANEL:PaintOver(w,h)
	if self.item and self.item.discounted_from then
		-- local disc_price = self.item.discounted_from
		-- local disc = diffNumsPercent(disc_price, self.item:Price())

		surface.SetDrawColor(IGS.col.TEXT_SOFT)

		-- surface.DrawRect(w - 60,0,25,2)
		-- surface.DrawRect(w - 2,h - 10 - 25,2,25)

		-- draw_Poly({
		-- 	{x = w - 60,y = 2},
		-- 	{x = w - 60 + 25,y = 2},
		-- 	{x = w - 2,y = h - 10 - 25},
		-- 	{x = w - 2,y = h - 10},
		-- }, Color(255,30,85, 255))

		-- draw_TextRotated("-" .. disc .. "%", 100, -50, Color(0,255,0), "roboto_20", 9)
		-- surface.SetTextColor(50,200,50)
		-- surface.SetFont("roboto_20")

		-- local x,y = self:GetPos()
		-- draw.RotatedText("-" .. disc .. "%", x, y, 1, 1, 9)
		-- draw.RotatedText("-" .. disc .. "%", x, y, 3)
		-- draw.TextRotated("-" .. disc .. "%", 0, 0, 3)
		-- draw.RotatedTextOnPanel("-" .. disc .. "%", 0, 0, 5, self)

		local tw = draw.SimpleText(
			getBottomText(self.item, false),"roboto_15",
			w * 0.5,h - 18 - 2 - 10,IGS.col.HIGHLIGHTING,TEXT_ALIGN_CENTER
		)

		local start_x, start_h = (w - tw) * 0.5 * 0.8, h - (20 * 0.5)
		surface.DrawLine(start_x, start_h,w - start_x, start_h)
	end
end


vgui.Register("igs_item",PANEL,"DButton")

-- IGS.CloseUI()
-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/windows/modals.lua:
function IGS.BoolRequest(title, text, cback)
	local m = uigs.Create("igs_frame", function(self)
		self:SetTitle(title)
		self:ShowCloseButton(false)
		self:SetWide(ScrW() * .2)
		self:MakePopup()
	end)

	local txt = string.Wrap("igs.18", text, m:GetWide() - 10)
	local y = m:GetTitleHeight() + 5

	for _,line in ipairs(txt) do
		uigs.Create("DLabel", function(self, p)
			self:SetText(line)
			self:SetFont("igs.18")
			self:SetTextColor(IGS.col.TEXT_HARD)
			self:SizeToContents()
			self:SetPos((p:GetWide() - self:GetWide()) * 0.5, y)
			y = y + self:GetTall() + 2
		end, m)
	end

	y = y + 5
	m.btnOK = uigs.Create("igs_button", function(self, p)
		self:SetText("Так")
		self:SetPos(5, y)
		self:SetSize(p:GetWide() * 0.5 - 7.5, 25)
		self.DoClick = function()
			p:Close()
			cback(true)
		end
	end, m)

	m.btnCan = uigs.Create("igs_button", function(self, p)
		self:SetText("Ні")
		self:SetPos(p.btnOK:GetWide() + 10, y)
		self:SetSize(p.btnOK:GetWide(), 25)
		self:RequestFocus()
		self.DoClick = function()
			p:Close()
			cback(false)
		end
		y = y + self:GetTall() + 5
	end, m)

	m:SetTall(y)
	m:Center()

	m:Focus()
	return m
end

function IGS.StringRequest(title, text, default, cback)
	local m = uigs.Create("igs_frame", function(self)
		self:SetTitle(title)
		self:ShowCloseButton(false)
		self:SetWide(ScrW() * .3)
		self:MakePopup()
	end)

	local txt = string.Wrap("igs.18", text, m:GetWide() - 10)
	local y = m:GetTitleHeight() + 5

	for _, v in ipairs(txt) do
		uigs.Create("DLabel", function(self, p)
			self:SetText(v)
			self:SetFont("igs.18")
			self:SetTextColor(IGS.col.TEXT_HARD)
			self:SizeToContents()
			self:SetPos((p:GetWide() - self:GetWide()) * 0.5, y)
			y = y + self:GetTall()
		end, m)
	end

	y = y + 5
	local tb = uigs.Create("DTextEntry", function(self, p)
		self:SetPos(5, y + 5)
		self:SetSize(p:GetWide() - 10, 25)
		self:SetValue(default or '')
		y = y + self:GetTall() + 10
		self.OnEnter = function()
			p:Close()
			cback(self:GetValue())
		end
	end, m)

	local btnOK = uigs.Create("igs_button", function(self, p)
		self:SetText("ОК")
		self:SetPos(5, y)
		self:SetSize(p:GetWide() * 0.5 - 7.5, 25)
		self:SetActive(true)
		self.DoClick = function()
			p:Close()
			cback(tb:GetValue())
		end
	end, m)

	uigs.Create("igs_button", function(self)
		self:SetText("Відміна")
		self:SetPos(btnOK:GetWide() + 10, y)
		self:SetSize(btnOK:GetWide(), 25)
		self:RequestFocus()
		self.DoClick = function()
			m:Close()
		end
		y = y + self:GetTall() + 5
	end, m)

	m:SetTall(y)
	m:Center()

	m:Focus()
	return m
end


local null = function() end
function IGS.ShowNotify(sText, sTitle, fOnClose)
	local m = IGS.BoolRequest(sTitle or "[IGS] Оголошення", sText, fOnClose or null)
	m.btnCan:Remove() -- оставляем только 1 кнопку

	local _,y = m.btnOK:GetPos()
	m.btnOK:SetText("ОК")
	m.btnOK:SetPos((m:GetWide() - m.btnOK:GetWide()) * 0.5, y)

	return m
end

function IGS.WIN.ActivateCoupon()
	IGS.StringRequest("Активація купона",
		"Якщо у вас є донат купон, то введіть його нижче",
	nil,function(val)
		IGS.UseCoupon(val,function(errMsg)
			if errMsg then
				IGS.ShowNotify(errMsg, "Помилка активації купона")
			else
				IGS.ShowNotify("Гроші нараховано на ваш рахунок. Можете подивитися на це в транзакціях, повторно відкривши донат меню", "Успішна активація купона")
			end
		end)
	end)
end


-- IGS.ShowNotify(("test "):rep(10), nil, function()
-- 	print("Нотификашка закрылась")
-- end)

IGS.OpenURL = gui.OpenURL

-- IGS.UI()

--PATH addons/igs-core/lua/igs/modules/inv_log/interface_cl.lua:
local actions = setmetatable({},{__index = function() return "Помилка" end})
actions[1] = "Покупка"
actions[2] = "Активація"
actions[3] = "Дроп"
actions[4] = "Пік"

local function beautyS64(s64)
	local pl = player.GetBySteamID64(s64)
	return pl and pl:Nick() or util.SteamIDFrom64(s64):sub(#"STEAM_0")
end

local function isSteamID64(s)
	return #s == 17 and s:StartWith("7656")
end

local function anyTo64(sid)
	local res = isSteamID64(sid) and sid or util.SteamIDTo64(sid)
	return res ~= "0" and res
end

local function getNameBySid(cb, s64)
	IGS.IL.NameRequest(function(name_)
		cb(name_)
	end, s64)
end

function IGS.WIN.InvLog()
	return uigs.Create("igs_frame", function(bg)
		bg:SetTitle("Операції з інвентарем")
		bg:SetSize(800, 600)
		bg:Center()
		bg:MakePopup()

		function bg:SearchSteamID(s64)
			bg.table:Clear()
			bg:Search(1, s64)
		end

		function bg:SearchGiftUID(uid)
			bg.table:Clear()
			bg:Search(1, nil, uid)
		end

		function bg:ResetSearch()
			bg.table:Clear()
			bg:Search()
		end

		function bg:AddLine(sOwner, sInfli, sItem, sAction, sDate, r)
			local line = bg.table:AddLine(sOwner, sInfli, sItem, r.gift_id, sAction, sDate)
			line:SetTooltip("ID операції: " .. r.action_id .. ". Перед ніком глобальний Score гравця")

			local btn_giftid = line.columns[4]
			btn_giftid.text_color = IGS_IL_ROW_SOLID_COLOR or HSVToColor(((r.gift_id * 10) * 5) % 360, 1, 1)

			for _,v in ipairs(line.columns) do
				v:SetCursor("hand")
			end

			for i,s64 in ipairs({r.owner, r.inflictor}) do
				if player.GetBySteamID64(s64) then continue end -- игрок в сети, ник получен

				getNameBySid(function(name_)
					if not name_ then return end

					local btn_owner = line.columns[i] -- 1, 2 колонка
					btn_owner:SetText(name_)
				end, s64)
			end

			line.DoClick = function()
				local m = DermaMenu(line)
				m:AddOption("Копіювати SID власника",function() SetClipboardText(r.owner) end)
				m:AddOption("Копіювати SID виконавця",function() SetClipboardText(r.inflictor) end)
				m:AddOption("Дії гравця",function() bg:SearchSteamID(r.owner) end)
				m:AddOption("Дії з " .. sItem,function() bg:SearchGiftUID(r.gift_uid) end)
				if sAction == "Активація" then -- а таких записях написан ID покупки, а не гифта (аве шиткодинг!)
					m:AddOption("Відключити", function()
						IGS.DeactivateItem(r.gift_id)
					end)
				end
				m:Open()
			end
		end

		function bg:Search(page, sid_, uid_) -- sid ИЛИ uid (Так сделан SELECT запрос)
			page = page or 1
			self.prev_page = page
			self.prev_sid  = sid_
			self.prev_uid  = uid_

			IGS.IL.GetLog(function(tLog)
				if not IsValid(bg) then return end -- Долго данные получались

				for _,r in ipairs(tLog) do
					local ITEM = IGS.GetItemByUID(r.gift_uid)

					local sDate   = IGS.TimestampToDate(r.date, true)
					local sAction = actions[r.action]
					local sItem   = ITEM.isnull and (r.gift_uid .. " (NULL)") or ITEM:Name()

					local sOwner = beautyS64(r.owner)
					local sInfli = beautyS64(r.inflictor)

					bg:AddLine(sOwner, sInfli, sItem, sAction, sDate, r)
				end

				bg.table:PerformLayout()
				bg.load:UpdateLoaded(#bg.table.lines, tLog[0])
			end, page, sid_, uid_)
		end

		bg.table = uigs.Create("igs_table", function(pnl)
			pnl:Dock(FILL)
			pnl:DockMargin(5,5,5,5)
			-- pnl:SetSize(790, 565)

			pnl:SetTitle("Дії")

			pnl:AddColumn("Власник",120)
			pnl:AddColumn("Виконавець",120)
			pnl:AddColumn("Предмет")
			pnl:AddColumn("ID гіфта", 65)
			pnl:AddColumn("Дії",110)
			pnl:AddColumn("Дата",130)
		end, bg)

		local bottom = uigs.Create("Panel", function(self)
			self:SetHeight(30)
			self:Dock(BOTTOM)
			self:DockMargin(5,0,5,5)
		end, bg)

		local entry = uigs.Create("DTextEntry", function(self)
			self:Dock(LEFT)
			self:SetWide(200)
			self:SetValue("SteamID або UID ітема")
			self.OnEnter = function()
				local val = self:GetValue():Trim()
				local s64 = anyTo64(val)

				if val == "" then
					bg:ResetSearch()
				elseif s64 then
					bg:SearchSteamID(s64)
				else
					bg:SearchGiftUID(val)
				end
			end
		end, bottom)

		uigs.Create("igs_button", function(self)
			self:Dock(LEFT)
			self:SetWide(150)
			self:DockMargin(5,0,0,0)
			self:SetText("Знайти")
			self.DoClick = entry.OnEnter
		end, bottom)

		bg.load = uigs.Create("igs_button", function(self)
			self:Dock(RIGHT)
			self:SetWide(200)
			self.DoClick = function()
				-- bg.table:Clear()
				bg:Search(bg.prev_page + 1, bg.prev_sid, bg.prev_uid)
			end
			self.UpdateLoaded = function(_, iLoaded, iTotal)
				if iLoaded == iTotal then
					self:SetText("Все завантажено (" .. iTotal .. ")")
					self:SetActive(false)
				else
					self:SetText("Завантажити ще (" .. iLoaded .. "/" .. iTotal .. ")")
					self:SetActive(true)
				end
			end
		end, bottom)

		bg:Search()
		bg.load:UpdateLoaded(0, 0)
	end)
end

concommand.Add("igs_invlog",IGS.WIN.InvLog)

-- for i = 1,1 do
-- 	local fr = IGS.WIN.InvLog()
-- 	timer.Simple(10,function()
-- 		if IsValid(fr) then
-- 			fr:Remove()
-- 		end
-- 	end)
-- end

--PATH addons/_hitreg/lua/leyhitreg/shared/disablelagcomp/disablelagcomp.lua:
local meta = FindMetaTable("Player")
meta.OldLagCompensation = meta.OldLagCompensation or meta.LagCompensation

function meta:LagCompensation(...)
    if (LeyHitreg.DisableLagComp and not LeyHitreg.Disabled) then
        return
    end

    return self:OldLagCompensation(...)
end
--PATH addons/__main/lua/autorun/m9k_heavy_weaps_11_07_15.lua:
/*------------------------------------------------------

If you're reading this, then that mean's you've extracted this addon, probably with intentions 
of editing it for your own needs, or that you're using a legacy addon.

I have no problem with that, but you must understand that I cannot offer support for legacy addons.
If you've extracted this addon, I cannot offer any help fixing problems that come up. It's impossible
to know what you've changed, and thus impossible to know what to fix.

"But Bob!" you might say. "I only changed one thing!" 

Well, that's a shame. Everybody is going to say this, and I know that some of those people will be
lying to me. The only thing I can do is to refuse support to everyone using legacy addons.

So, by using a legacy addon, you accept the fact that I cannot help fix anything that might be broken.

I know it's tough love, but that's the way it's got to be.

------------------------------------------------------*/

--I'm pretty sure we don't need these anymore...
--Almost 99 percent sure that's I'm 100 percent sure...
	
-- if GetConVar("M9KDisableHolster") == nil then
	-- CreateConVar("M9KDisableHolster", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable my totally worthless and broken holster system? Won't hurt my feelings any. 1 for true, 2 for false. A map change may be required.")
	-- print("Holster Disable con var created")
-- end

if GetConVar("DebugM9K") == nil then
	CreateConVar("DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much.")
end

if GetConVar("M9KWeaponStrip") == nil then
	CreateConVar("M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false")
	print("Weapon Strip con var created")
end
	
if GetConVar("M9KDisablePenetration") == nil then
	CreateConVar("M9KDisablePenetration", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false")
	print("Penetration/ricochet con var created")
end
	
if GetConVar("M9KDynamicRecoil") == nil then
	CreateConVar("M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false")
	print("Recoil con var created")
end
	
if GetConVar("M9KAmmoDetonation") == nil then
	CreateConVar("M9KAmmoDetonation", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false.")
	print("Ammo crate detonation con var created")
end

if GetConVar("M9KDamageMultiplier") == nil then
	CreateConVar("M9KDamageMultiplier", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Multiplier for M9K bullet damage.")
	print("Damage Multiplier con var created")
end

if GetConVar("M9KDefaultClip") == nil then
	CreateConVar("M9KDefaultClip", "-1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "How many clips will a weapon spawn with? Negative reverts to default values.")
	print("Default Clip con var created")
end
	
if GetConVar("M9KUniqueSlots") == nil then
	CreateConVar("M9KUniqueSlots", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required.")
	print("Unique Slots con var created")
end
	
if !game.SinglePlayer() then

	if GetConVar("M9KClientGasDisable") == nil then
		CreateConVar("M9KClientGasDisable", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Turn off gas effect for all clients? 1 for yes, 0 for no. ")
	end
	
	if SERVER then
	
		function ClientSideGasDisabler()
			timer.Create("ClientGasBroadcastTimer", 15, 0, 
				function() BroadcastLua("RunConsoleCommand(\"M9KGasEffect\", \"0\")") end )
		end
	
		if GetConVar("M9KClientGasDisable"):GetBool() then
			ClientSideGasDisabler()
		end

		function M9K_Svr_Gas_Change_Callback(cvar, previous, new)
			if tobool(new) == true then
				ClientSideGasDisabler()
				BroadcastLua("print(\"Gas effects disabled on this server!\")")
			elseif tobool(new) == false then
				BroadcastLua("print(\"Gas effects re-enabled on this server.\")")
				BroadcastLua("print(\"You may turn on M9KGasEffect if you wish.\")")
				if timer.Exists("ClientGasBroadcastTimer") then
					timer.Destroy("ClientGasBroadcastTimer")
				end
			end				
		end
		cvars.AddChangeCallback("M9KClientGasDisable", M9K_Svr_Gas_Change_Callback)
	
	end
	
	if CLIENT then
		if GetConVar("M9KGasEffect") == nil then
			CreateClientConVar("M9KGasEffect", "1", true, true)
			print("Client-side Gas Effect Con Var created")
		end		
	end

else
	if GetConVar("M9KGasEffect") == nil then
		CreateConVar("M9KGasEffect", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use gas effect when shooting? 1 for true, 0 for false")
		print("Gas effect con var created")
	end
end

//PKM
sound.Add({
	name = 			"pkm.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 		{"weapons/pkm/pkm-1.wav",
					"weapons/pkm/pkm-2.wav",
					"weapons/pkm/pkm-3.wav",
					"weapons/pkm/pkm-4.wav",
					"weapons/pkm/pkm-5.wav"}
})

sound.Add({
	name = 			"Weapon_PKM.Cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_cloth.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Coverup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_coverup.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Bullet",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_bullet.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Boxout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_boxout.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Boxin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_boxin.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Chain",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_chain.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Coverdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_coverdown.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Coversmack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_coversmack.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Bolt",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_bolt.mp3"
})

sound.Add({
	name = 			"Weapon_PKM.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pkm/pkm_draw.mp3"
})

//SVT40
sound.Add({
	name = 			"Weapon_SVT40.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1-1.wav"
})

sound.Add({
	name = 			"Weapon_SVT40.Cloth1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_cloth1.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.Cloth2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_cloth2.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.ClipTap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_cliptap.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.SlideBack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_slide_b.mp3"
})

sound.Add({
	name = 			"Weapon_SVT40.SlideForward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svt40/g3sg1_slide_f.mp3"
})

//spas12
sound.Add({
	name = 			"spas_12_shoty.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/spas_12/xm1014-1.wav"
})

sound.Add({
	name = 			"spas_12_shoty.insert",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/spas_12/xm_insert.mp3"
})

sound.Add({
	name = 			"spas_12_shoty.cock",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/spas_12/xm_cock.mp3"
})

//USAS
sound.Add({
	name = 			"Weapon_usas.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/usas12/xm1014-1.wav"
})

sound.Add({
	name = 			"Weapon_usas.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usas12/magin.mp3"
})

sound.Add({
	name = 			"Weapon_usas.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usas12/magout.mp3"
})

sound.Add({
	name = 			"Weapon_usas.draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usas12/draw.mp3"
})


//remington 7615P
sound.Add({
	name = 			"7615p_remington.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/7615p/scout_fire-1.wav" 
})
  
  sound.Add({
	name = 			"7615p_bob.pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/7615p/m3_pump.mp3" 
})


sound.Add({
	name = 			"Weapon_7615P.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/7615p/sg550_clipout.mp3" 
})


sound.Add({
	name = 			"Weapon_7615P.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/7615p/sg550_clipin.mp3" 
})


// Dragunov SVU
  sound.Add({
	name = 			"Weapon_SVU.Single",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svu/g3sg1-1.wav"
})
  
    sound.Add({
	name = 			"Weapon_svuxx.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svu/g3sg1_clipin.mp3"
})

  sound.Add({
	name = 			"Weapon_svuxx.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svu/g3sg1_clipout.mp3"
})

  sound.Add({
	name = 			"Weapon_svuxx.Slide",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/svu/g3sg1_slide.mp3"
})


//Winchester model 94
  sound.Add({
	name = 			"Weapon_Win94.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/win94/scout_fire-1.wav"
})

sound.Add({
	name = 			"Weapon_Win94.Bolt",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/win94/scout_bolt.mp3"
})

sound.Add({
	name = 			"weapons/hamburgpling.wav",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/win94/hamburgpling.mp3"
})

sound.Add({
	name = 			"Weapon_Win94.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/win94/scout_clipout.mp3"
})

//Striker 12
sound.Add({
	name = 			"ShotStriker12.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/striker12/xm1014-1.wav"
})

sound.Add({
	name = 			"ShotStriker12.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/striker12/deploy.mp3"
})

sound.Add({
	name = 			"ShotStriker12.InsertShell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/striker12/m3_insertshell.mp3"
})

//AW50
sound.Add({
	name =			"Weaponaw50.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1.0,
	sound =			"weapons/aw50/awp_fire.wav"
})

sound.Add({
	name =			"Weaponaw50.clipin",
	channel =		CHAN_ITEM,
	volume =		1.0,
	sound =			"weapons/aw50/awp_magin.mp3"
})

sound.Add({
	name =			"Weaponaw50.clipout",
	channel =		CHAN_ITEM,
	volume =		1.0,
	sound =			"weapons/aw50/awp_magout.mp3"
})
	
sound.Add({
	name =			"Weaponaw50.boltback",
	channel =		CHAN_ITEM,
	volume =		1.0,
	sound =			"weapons/aw50/m24_boltback.mp3"
})

sound.Add({
	name =			"Weaponaw50.boltforward",
	channel =		CHAN_ITEM,
	volume =		1.0,
	sound =			"weapons/aw50/m24_boltforward.mp3"
})

//PSG-1

sound.Add({
	name =			"Weapon_psg_1.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1,
	sound =			"weapons/psg1/g3sg1-1.wav" 
})


sound.Add({
	name =			"Weapon_psg_1.Back",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/psg1/psg_boltpull.mp3" 
})

sound.Add({
	name =			"Weapon_psg_1.Clipout",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/psg1/psg_clipout.mp3" 
})

sound.Add({
	name =			"Weapon_psg_1.Clipin",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/psg1/psg_clipin.mp3" 
})

sound.Add({
	name =			"Weapon_psg_1.Forward",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/psg1/psg_boltrelease.mp3" 

})

sound.Add({
	name =			"Weapon_psg_1.Deploy",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/psg1/deploy1.mp3" 
})

//contender
sound.Add({
	name =			"contender_g2.Single",
	channel =		CHAN_USER_BASE+10,
	volumel =		1.0,
	sound = 		{"weapons/g2contender/scout-1.wav",
					"weapons/g2contender/scout-2.wav",
					"weapons/g2contender/scout-3.wav"}
})

sound.Add({
	name =			"contender_g2.Draw",
	channel =		CHAN_ITEM,
	volumel =		1.0,
	sound =			"weapons/g2contender/Draw.mp3"
})


sound.Add({
	name =			"contender_g2.Hammer",
	channel =		CHAN_USER_BASE+1,
	volumel =		1.0,
	sound =			{"weapons/g2contender/Cock-1.mp3",
					"weapons/g2contender/Cock-2.mp3"}
})


sound.Add({
	name =			"contender_g2.Open",
	channel =		CHAN_ITEM,
	volumel =		1.0,
	sound =			"weapons/g2contender/open_chamber.mp3"
})


sound.Add({
	name =			"contender_g2.Shellout",
	channel =		CHAN_USER_BASE+1,
	volumel =		1.0,
	sound =			"weapons/g2contender/Bullet_out.mp3"
})


sound.Add({
	name =			"contender_g2.Shellin",
	channel =		CHAN_ITEM,
	volumel =		1.0,
	sound =			"weapons/g2contender/Bullet_in.mp3"
})


sound.Add({
	name =			"contender_g2.Close",
	channel =		CHAN_ITEM,
	volumel =		1.0,
	sound =			"weapons/g2contender/close_chamber.mp3"
})


sound.Add({
	name =			"contender_g2.Shell",
	channel =		CHAN_USER_BASE+2,
	volumel =		1.0,
	sound =			{"weapons/g2contender/pl_shell1.mp3",
					"weapons/g2contender/pl_shell2.mp3",
					"weapons/g2contender/pl_shell3.mp3",
					"weapons/g2contender/pl_shell4.mp3"}
})
//Barret M98B
sound.Add({

	name = 		"M98.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/M98/shot-1.wav"
})

sound.Add({
	name = 		"M98_Bolt",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/bolt.mp3"
})


sound.Add({
	name = 		"M98_Handle",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/handle.mp3"
})

sound.Add({
	name = 		"M98_Deploy",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/draw.mp3"
})

sound.Add({
	name = 		"M98_Draw",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/draw_2.mp3"
})

sound.Add({
	name = 		"M98_Foley",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/foley.mp3"
})

sound.Add({
	name = 		"M98_Clipout",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/clipout.mp3"
})

sound.Add({
	name = 		"M98_Clipin",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/clipin.mp3"
})

sound.Add({
	name = 		"M98_Boltback",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/boltback.mp3"
})

sound.Add({
	name = 		"M98_Boltforward",
channel = 	CHAN_ITEM,
volume = 	1.0,
sound = 	"weapons/M98/boltforward.mp3"
})

//barret m82 50 cal
sound.Add({
	name = 			"BarretM82.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/M82/barret50-1.wav"
})


sound.Add({
	name = 			"Weapon_M82.Boltup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/M82/boltup.mp3"
})

sound.Add({
	name = 			"Weapon_M82.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/M82/clipin.mp3"
})

sound.Add({
	name = 			"Weapon_M82.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/M82/clipout.mp3"
})

sound.Add({
	name = 			"Weapon_M82.Boltdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/M82/boltdown.mp3"
})

//m24
sound.Add({
	name = 			"Dmgfok_M24SN.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_m24/awp1.wav"
})

sound.Add({
	name = 			"Dmgfok_M24SN.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m24/m24_magin.mp3"
})

sound.Add({
	name = 			"Dmgfok_M24SN.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m24/m24_magout.mp3"
})

sound.Add({
	name = 			"Dmgfok_M24SN.Boltback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m24/m24_boltback.mp3"
})

sound.Add({
	name = 			"Dmgfok_M24SN.Boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m24/m24_boltforward.mp3"
})

//svd dragunov
sound.Add({
	name = 			"Weapon_svd01.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/SVD/g3sg1-1.wav"
})

sound.Add({
	name = 			"Weapon_SVD.Foley",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/foley.mp3"	
})

sound.Add({
	name = 			"Weapon_SVD.Handle",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/handle.mp3"	
})

sound.Add({
	name = 			"Weapon_SVD.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/Clipout.mp3"
})

sound.Add({
	name = 			"Weapon_SVD.Cliptap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/Cliptap.mp3"
	
})

sound.Add({
	name = 			"Weapon_SVD.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/ClipIn.mp3"
	
})

sound.Add({
	name = 			"Weapon_SVD.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/SlideBack.mp3"
	
})

sound.Add({
	name = 			"Weapon_SVD.SlideForward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/SlideForward.mp3"	
})

sound.Add({
	name = 			"Weapon_SVD.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/SVD/Draw.mp3"
	
})

//sl8
sound.Add({
	name = 			"Weapon_hksl8.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = {"weapons/hksl8/SG552-1.wav",
			"weapons/hksl8/SG552-2.wav",
			"weapons/hksl8/SG552-3.wav",
			"weapons/hksl8/SG552-4.wav"}
})

sound.Add({
	name = 			"sl8.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/draw.mp3"
})

sound.Add({
	name = 			"sl8.Safety",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/safety.mp3"
})

sound.Add({
	name = 			"sl8.Magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/magout.mp3"
})

sound.Add({
	name = 			"sl8.MagFiddle",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/magfiddle.mp3"
})

sound.Add({
	name = 			"sl8.MagIn",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/magin.mp3"
})

sound.Add({
	name = 			"sl8.BoltBack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/boltback.mp3"
})

sound.Add({
	name = 			"sl8.Boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hksl8/boltforward.mp3"
})


//intervention
sound.Add({
	name = 			"Weapon_INT.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_intrv/int1.wav"
})

sound.Add({
	name = 			"Weapon_INT.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_intrv/int_deploy.mp3"
})

sound.Add({
	name = 			"Weapon_INT.Bolt",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_intrv/int_bolt.mp3"
})

sound.Add({
	name = 			"Weapon_INT.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_intrv/int_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_INT.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_intrv/int_clipin.mp3"
})


//winchester 1887
sound.Add({
	name = 			"1887winch.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/1887winchester/1887-1.wav" 
})

sound.Add({
	name = 			"1887winch.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1887winchester/1887_insertshell.mp3" 
})

sound.Add({
	name = 			"1887winch.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1887winchester/1887pump1.mp3" 
})

sound.Add({
	name = 			"1887pump2.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1887winchester/1887pump2.mp3" 
})

//winchester 1897
sound.Add({
	name = 			"Trench_97.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/1897trench/m3-1.wav"
})

sound.Add({
	name = 			"Trench_97.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1897trench/m3_insertshell.mp3"
})

sound.Add({
	name = 			"Trench_97.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1897trench/m3_pump.mp3"
})

sound.Add({
	name = 			"Trench_07.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/1897trench/1897_deploy.mp3"
})

//browning auto 5
sound.Add({
	name = 			"Weapon_a5.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/browninga5/xm1014-1.wav"
})

sound.Add({
	name = 			"Weapon_bauto5.InsertShell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/browninga5/xm1014_insertshell.mp3"
})

sound.Add({
	name = 			"Weapon_a5.back",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/browninga5/xm1014_check.mp3"
})

sound.Add({
	name = 			"Weapon_a5.draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/browninga5/xm1014_deploy.mp3"
})

//double barrel shotgun
sound.Add({
	name = 			"Double_Barrel.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dbarrel/xm1014-1.wav"
})

sound.Add({
	name = 			"dbarrel_dblast",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dbarrel/dblast.wav"
})

sound.Add({
	name = 			"Double_Barrel.InsertShell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dbarrel/xm1014_insertshell.mp3"
})

sound.Add({
	name = 			"Double_Barrel.barreldown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dbarrel/barreldown.mp3"
})

sound.Add({
	name = 			"Double_Barrel.barrelup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dbarrel/barrelup.mp3"
})

//pancor jackhammer
sound.Add({
	name = 			"Weapon_Jackhammer.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		.65,
	sound = 			"weapons/jackhammer/xm1014-1.wav"
})

sound.Add({
	name = 			"Weapon_Jackhammer.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		.65,
	sound = 			"weapons/jackhammer/clipout.mp3"
})

sound.Add({
	name = 			"Weapon_Jackhammer.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		.65,
	sound = 			"weapons/jackhammer/magtap.mp3"
})

sound.Add({
	name = 			"Weapon_Jackhammer.Forearm",
	channel = 		CHAN_ITEM,
	volume = 		.45,
	sound = 			"weapons/jackhammer/boltcatch.mp3"
})


sound.Add({
	name = 			"Weapon_Jackhammer.Cloth",
	channel = 		CHAN_ITEM,
	volume = 		1,
	sound = 			"weapons/jackhammer/cloth.mp3"
})

//Ithaca M37
sound.Add({
	name =			"IthacaM37.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1,
	sound =			"weapons/m37/m3-1.wav"
})

sound.Add({
	name =			"IthacaM37.Insertshell",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/m37/m3_insertshell.mp3"
})

sound.Add({
	name =			"IthacaM37.Pump",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/m37/m3_pump.mp3"
})

//Mossberg 590
sound.Add({
	name =			"Mberg_590.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1,
	sound =			"weapons/590/m3-1.wav"
})

sound.Add({
	name =			"Mberg_590.Insertshell",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/590/m3_insertshell.mp3"
})

sound.Add({
	name =			"Mberg_590.Pump",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/590/m3_pump.mp3"
})

sound.Add({
	name =			"Mberg_590.Bullet",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/590/m3_bullet.mp3"
})

sound.Add({
	name =			"Mberg_590.Draw",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/590/m3_draw.mp3"
})

//Ares Shrike
sound.Add({
	name = 			"Weapon_shrk.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/shrike/shrike-1.wav" 
})

sound.Add({
	name = 			"Weapon_shrk.bOut",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/boxout.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.Button",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/button.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.cUp",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/coverup.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.Bullet1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/bullet.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.bIn",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/boxin.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.Bullet2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/bullet.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.cDown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/coverdown.mp3" 
})

sound.Add({
	name = 			"Weapon_shrk.Ready",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/shrike/ready.mp3" 
})


//m60
sound.Add({
	name = 			"Weapon_M_60.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 		")weapons/m60/m60-1.wav"
})

sound.Add({
	name = 			"Weapon_M_60.Coverup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/m60/m60_coverup.mp3"
})

sound.Add({
	name = 			"Weapon_M_60.Boxout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/m60/m60_boxout.mp3"
})

sound.Add({
	name = 			"Weapon_M_60.Boxin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/m60/m60_boxin.mp3"
})

sound.Add({
	name = 			"Weapon_M_60.Chain",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/m60/m60_chain.mp3"
})

sound.Add({
	name = 			"Weapon_M_60.Coverdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/m60/m60_coverdown.mp3"
})

//m249
sound.Add({
	name = 			"Weapon_249M.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/m249-1.wav"
})

sound.Add({
	name = 			"Weapon_249M.Coverdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/m249_coverdown.mp3"
})

sound.Add({
	name = 			"Weapon_249M.Chain",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/m249_chain.mp3"
})

sound.Add({
	name = 			"Weapon_249M.Coverup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/m249_coverup.mp3"
})

sound.Add({
	name = 			"Weapon_249M.Boxout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/m249_boxout.mp3"
})

sound.Add({
	name = 			"Weapon_Flakk249.Magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/magin.mp3"
})

sound.Add({
	name = 			"Weapon_Flakk249.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_Flakk249.Boltrel",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/schmung.M249/boltrel.mp3"
})

//m134 minigun
sound.Add({
	name = 			"BlackVulcan.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini-1.wav"
})

sound.Add({
	name = 			"BlackVulcan.Boxout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini_boxout.mp3"
})


sound.Add({
	name = 			"BlackVulcan.Coverup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini_coverup.mp3"
})

sound.Add({
	name = 			"BlackVulcan.Boxin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini_boxin.mp3"
})

sound.Add({
	name = 			"BlackVulcan.Chain",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini_chain.mp3"
})

sound.Add({
	name = 			"BlackVulcan.Coverdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 		")weapons/minigun/mini_coverdown.mp3"
})

//fg42
sound.Add({
	name = 			"FG42_weapon.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fg42/ak47-1.wav"
})

sound.Add({
	name = 			"FG42_weapon.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fg42/ak47_clipout.mp3"
})

sound.Add({
	name = 			"FG42_weapon.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fg42/ak47_clipin.mp3"
})

sound.Add({
	name = 			"FG42_weapon.BoltPull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fg42/ak47_boltpull.mp3"
})

//m1918 bar
sound.Add({
	name = 			"Weapon_bar1.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/jen.ak/mag.in.mp3"
})

sound.Add({
	name = 			"Weapon_bar1.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/jen.ak/mag.out.mp3"
})

sound.Add({
	name = 			"Weapon_bar1.mag.tap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/jen.ak/mag.tap.mp3"
})

sound.Add({
	name = 			"Weapon_bar1.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		.7,
	sound = 			"weapons/jen.ak/bolt.pull.mp3"
})

sound.Add({
	name = 			"Weapon_bar1.bolt.rel",
	channel = 		CHAN_ITEM,
	volume = 		.5,
	sound = 			"weapons/jen.ak/bolt.rel.mp3"	
})

sound.Add({
	name = 			"Weapon_bar1.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/jen.ak/fire.wav"
})

sound.Add({
	name = 			"3rd_Weapon_bar1.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/jen.ak/fire.wav"	
})

//Tactical 870
sound.Add({
	name = 			"WepRem870.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/tact870/m3-1.wav"
})

sound.Add({
	name = 			"WepRem870.pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tact870/m3_pump.mp3"
})

sound.Add({
	name = 			"WepRem870.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tact870/m3_insertshell.mp3"
})

//Benelli M3
sound.Add({
	name = 			"BenelliM3.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/BenelliM3/m3-1.wav"
})

sound.Add({
	name = 			"BenelliM3.insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/BenelliM3/m3_insertshell.mp3"
})

sound.Add({
	name = 			"BenelliM3.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/BenelliM3/m3_pump.mp3"
})

m9knpw = {}
table.insert(m9knpw, "m9k_davy_crockett_explo")
table.insert(m9knpw, "m9k_gdcwa_matador_90mm")
table.insert(m9knpw, "m9k_gdcwa_rpg_heat")
table.insert(m9knpw, "m9k_improvised_explosive")
table.insert(m9knpw, "m9k_launched_davycrockett")
table.insert(m9knpw, "m9k_launched_ex41")
table.insert(m9knpw, "m9k_launched_m79")
table.insert(m9knpw, "m9k_m202_rocket")
table.insert(m9knpw, "m9k_mad_c4")
table.insert(m9knpw, "m9k_milkor_nade")
table.insert(m9knpw, "m9k_nervegasnade")
table.insert(m9knpw, "m9k_nitro_vapor")
table.insert(m9knpw, "m9k_oribital_cannon")
table.insert(m9knpw, "m9k_poison_parent")
table.insert(m9knpw, "m9k_proxy")
table.insert(m9knpw, "m9k_released_poison")
table.insert(m9knpw, "m9k_sent_nuke_radiation")
table.insert(m9knpw, "m9k_thrown_harpoon")
table.insert(m9knpw, "m9k_thrown_knife")
table.insert(m9knpw, "m9k_thrown_m61")
table.insert(m9knpw, "m9k_thrown_nitrox")
table.insert(m9knpw, "m9k_thrown_spec_knife")
table.insert(m9knpw, "m9k_thrown_sticky_grenade")
table.insert(m9knpw, "bb_dod_bazooka_rocket")
table.insert(m9knpw, "bb_dod_panzershreck_rocket")
table.insert(m9knpw, "bb_garand_riflenade")
table.insert(m9knpw, "bb_k98_riflenade")
table.insert(m9knpw, "bb_planted_dod_tnt")
table.insert(m9knpw, "bb_thrownalliedfrag")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_thrownsmoke_axis")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_planted_alt_c4")
table.insert(m9knpw, "bb_planted_css_c4")
table.insert(m9knpw, "bb_throwncssfrag")
table.insert(m9knpw, "bb_throwncsssmoke")
table.insert(m9knpw, "m9k_ammo_40mm")
table.insert(m9knpw, "m9k_ammo_40mm_single")
table.insert(m9knpw, "m9k_ammo_357")
table.insert(m9knpw, "m9k_ammo_ar2")
table.insert(m9knpw, "m9k_ammo_buckshot")
table.insert(m9knpw, "m9k_ammo_c4")
table.insert(m9knpw, "m9k_ammo_frags")
table.insert(m9knpw, "m9k_ammo_ieds")
table.insert(m9knpw, "m9k_ammo_nervegas")
table.insert(m9knpw, "m9k_ammo_nuke")
table.insert(m9knpw, "m9k_ammo_pistol")
table.insert(m9knpw, "m9k_ammo_proxmines")
table.insert(m9knpw, "m9k_ammo_rockets")
table.insert(m9knpw, "m9k_ammo_smg")
table.insert(m9knpw, "m9k_ammo_sniper_rounds")
table.insert(m9knpw, "m9k_ammo_stickynades")
table.insert(m9knpw, "m9k_ammo_winchester")

function PocketM9KWeapons(ply, wep)

	if not IsValid(wep) then return end
	class = wep:GetClass()
	m9knopocket = false
	
	for k, v in pairs(m9knpw) do
		if v == class then
			m9knopocket = true
			break
		end
	end
	
	if m9knopocket then
		return false
	end
	
	--goddammit i hate darkrp
	
end
hook.Add("canPocket", "PocketM9KWeapons", PocketM9KWeapons )

heavy_autorun_mounted = true
--PATH addons/media_player/lua/autorun/mediaplayer.lua:
local basepath = "mediaplayer/"

local function IncludeMP( filepath )
	include( basepath .. filepath )
end

local function PreLoadMediaPlayer()
	-- Check if MediaPlayer has already been loaded
	if MediaPlayer then
		MediaPlayer.__refresh = true

		-- HACK: Lua refresh fix; access local variable of baseclass lib
		local _, BaseClassTable = debug.getupvalue(baseclass.Get, 1)
		for classname, _ in pairs(BaseClassTable) do
			if classname:find("mp_") then
				BaseClassTable[classname] = nil
			end
		end
	end
end

local function PostLoadMediaPlayer()
	if SERVER then
		-- Reinstall media players on Lua refresh
		for _, mp in pairs(MediaPlayer.GetAll()) do
			if mp:GetType() == "entity" and IsValid(mp) then
				local ent = mp:GetEntity()
				local snapshot = mp:GetSnapshot()
				local listeners = table.Copy(mp:GetListeners())

				-- remove media player
				mp:Remove()

				-- install new media player
				ent:InstallMediaPlayer()

				-- restore settings
				mp = ent._mp
				mp:RestoreSnapshot( snapshot )
				mp:SetListeners( listeners )
			end
		end
	end
end

local function LoadMediaPlayer()
	print( "Loading 'mediaplayer' addon..." )

	PreLoadMediaPlayer()

	-- shared includes
	IncludeCS "includes/extensions/sh_url.lua"
	IncludeCS "includes/modules/EventEmitter.lua"

	if SERVER then
		-- download clientside includes
		AddCSLuaFile "includes/modules/browserpool.lua"
		AddCSLuaFile "includes/modules/inputhook.lua"
		AddCSLuaFile "includes/modules/htmlmaterial.lua"
		AddCSLuaFile "includes/modules/spritesheet.lua"

		-- initialize serverside mediaplayer
		IncludeMP "init.lua"
	else
		-- clientside includes
		include "includes/modules/browserpool.lua"
		include "includes/modules/inputhook.lua"
		include "includes/modules/htmlmaterial.lua"
		include "includes/modules/spritesheet.lua"

		-- initialize clientside mediaplayer
		IncludeMP "cl_init.lua"
	end

	-- Sandbox includes; these must always be included as the gamemode is still
	-- set as 'base' when the addon is loading. Can't check if gamemode derives
	-- Sandbox.
	if SERVER then
		AddCSLuaFile "menubar/mp_options.lua"
		AddCSLuaFile "properties/mediaplayer.lua"
		AddCSLuaFile "sandbox/mediaplayer_dupe.lua"
	else
		include "menubar/mp_options.lua"
		include "properties/mediaplayer.lua"
		include "sandbox/mediaplayer_dupe.lua"
	end

	--
	-- Media Player menu includes; remove these if you would rather not include
	-- the sidebar menu.
	--
	if SERVER then
		AddCSLuaFile "mp_menu/cl_init.lua"
		include "mp_menu/init.lua"
	else
		include "mp_menu/cl_init.lua"
	end

	PostLoadMediaPlayer()
end

-- First time load
LoadMediaPlayer()

--PATH addons/media_player/lua/autorun/includes/modules/eventemitter.lua:
---
-- EventEmitter
--
-- Based off of Wolfy87's JavaScript EventEmitter
--
local EventEmitter = {}

local function indexOfListener(listeners, listener)
	local value
	local i = #listeners


	while i > 0 do
		value = listeners[i]
		if type(value) == 'table' and value.listener == listener then
			return i
		end
		i = i - 1
	end

	return -1
end

function EventEmitter:new(obj)
	if obj then
		table.Inherit(obj, self)
	else
		return setmetatable({}, self)
	end
end

function EventEmitter:getListeners(evt)
	local events = self:_getEvents()
	local response

	-- TODO: accept pattern matching

	if not events[evt] then
		local tbl = {}
		tbl.__array = true
		events[evt] = tbl
	end

	response = events[evt]

	return response
end

--[[function EventEmitter:flattenListeners(listeners)

end]]

function EventEmitter:getListenersAsObject(evt)
	local listeners = self:getListeners(evt)
	local response

	if listeners.__array then
		response = {}
		response[evt] = listeners
	end

	return response or listeners, wrapped
end

function EventEmitter:addListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local listenerIsWrapped = type(listener) == 'table'

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) and indexOfListener(listeners[key], listener) == -1 then
			local value

			if listenerIsWrapped then
				value = listener
			else
				value = {
					listener = listener,
					once = false
				}
			end

			table.insert(listeners[key], value)
		end
	end

	return self
end

EventEmitter.on = EventEmitter.addListener

function EventEmitter:addOnceListener(evt, listener)
	return self:addListener(evt, {
		listener = listener,
		once = true
	})
end

EventEmitter.once = EventEmitter.addOnceListener

function EventEmitter:removeListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local index

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			index = indexOfListener(listeners[key], listener)

			if index ~= -1 then
				table.remove(listeners[key], index)
			end
		end
	end

	return self
end

EventEmitter.off = EventEmitter.removeListener

--[[function EventEmitter:addListeners(evt, listeners)

end]]

function EventEmitter:removeEvent(evt)
	local typeStr = type(evt)
	local events = self:_getEvents()
	local key

	if typeStr == 'string' then
		events[evt] = nil
	else
		self._events = nil
	end

	return self
end

EventEmitter.removeAllListeners = EventEmitter.removeEvent

function EventEmitter:emitEvent(evt, ...)
	local listeners = self:getListenersAsObject(evt)
	local listener, i, key, response

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			i = #listeners[key]

			while i > 0 do
				listener = listeners[key][i]

				if listener.once == true then
					self:removeListener(evt, listener.listener)
				end

				response = listener.listener(...)

				if response == self:_getOnceReturnValue() then
					self:removeListener(evt, listener.listener)
				end

				i = i - 1
			end
		end
	end

	return self
end

EventEmitter.trigger = EventEmitter.emitEvent
EventEmitter.emit = EventEmitter.emitEvent

function EventEmitter:setOnceReturnValue(value)
	self._onceReturnValue = value
	return self
end

function EventEmitter:_getOnceReturnValue()
	if rawget(self, '_onceReturnValue') then
		return self._onceReturnValue
	else
		return true
	end
end

function EventEmitter:_getEvents()
	if not self._events then
		self._events = {}
	end

	return self._events
end

_G.EventEmitter = EventEmitter

--PATH addons/media_player/lua/mediaplayer/players/entity/sh_meta.lua:
--[[---------------------------------------------------------
	Media Player Entity Meta
-----------------------------------------------------------]]

local EntityMeta = FindMetaTable("Entity")
if not EntityMeta then return end

function EntityMeta:GetMediaPlayer()
	return self._mp
end

--
-- Installs a media player reference to the entity.
--
-- @param Table|String?  mp    Media player table or string type.
-- @param String?        mpId  Media player unique ID.
--
function EntityMeta:InstallMediaPlayer( mp, mpId )
	if not istable(mp) then
		local mpType = isstring(mp) and mp or "entity"

		if not MediaPlayer.IsValidType(mpType) then
			ErrorNoHalt("ERROR: Attempted to install invalid mediaplayer type onto an entity!\n")
			ErrorNoHalt("ENTITY: " .. tostring(self) .. "\n")
			ErrorNoHalt("TYPE: " .. tostring(mpType) .. "\n")
			mpType = "entity" -- default
		end

		local mpId = mpId or "Entity" .. self:EntIndex()
		mp = MediaPlayer.Create( mpId, mpType )
	end

	self._mp = mp
	self._mp:SetEntity(self)

	local creator = self.GetCreator and self:GetCreator()
	if IsValid( creator ) then
		self._mp:SetOwner( creator )
	end

	if isfunction(self.SetupMediaPlayer) then
		self:SetupMediaPlayer(mp)
	end

	return mp
end

local DefaultConfig = {
	offset	= Vector(0,0,0),	-- translation from entity origin
	angle	= Angle(0,90,90),	-- rotation
	-- attachment = "corner"	-- attachment name
	width = 64,					-- screen width
	height = 64 * 9/16			-- screen height
}

function EntityMeta:GetMediaPlayerPosition()
	local cfg = self.PlayerConfig or DefaultConfig

	local w = (cfg.width or DefaultConfig.width)
	local h = (cfg.height or DefaultConfig.height)
	local angles = (cfg.angle or DefaultConfig.angle)

	local pos, ang

	if cfg.attachment then
		local idx = self:LookupAttachment(cfg.attachment)
		if not idx then
			local err = string.format("MediaPlayer:Entity.Draw: Invalid attachment '%s'\n", cfg.attachment)
			Error(err)
		end

		-- Get attachment orientation
		local attach = self:GetAttachment(idx)
		pos = attach.pos
		ang = attach.ang
	else
		pos = self:GetPos() -- TODO: use GetRenderOrigin?
	end

	-- Apply offset
	if cfg.offset then
		pos = pos +
			self:GetForward() * cfg.offset.x +
			self:GetRight() * cfg.offset.y +
			self:GetUp() * cfg.offset.z
	end

	-- Set angles
	ang = ang or self:GetAngles() -- TODO: use GetRenderAngles?

	ang:RotateAroundAxis( ang:Right(), angles.p )
	ang:RotateAroundAxis( ang:Up(), angles.y )
	ang:RotateAroundAxis( ang:Forward(), angles.r )

	return w, h, pos, ang
end

--PATH addons/media_player/lua/mediaplayer/services/youtube/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "YouTube"
SERVICE.Id 		= "yt"
SERVICE.Base 	= "browser"

local YtVideoIdPattern = "[%a%d-_]+"
local UrlSchemes = {
	"youtube%.com/watch%?v=" .. YtVideoIdPattern,
	"youtu%.be/watch%?v=" .. YtVideoIdPattern,
	"youtube%.com/v/" .. YtVideoIdPattern,
	"youtu%.be/v/" .. YtVideoIdPattern,
	"youtube%.googleapis%.com/v/" .. YtVideoIdPattern
}

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)
	obj._data = obj:GetYouTubeVideoId()
	return obj
end

function SERVICE:Match( url )
	for _, pattern in pairs(UrlSchemes) do
		if string.find( url, pattern ) then
			return true
		end
	end

	return false
end

function SERVICE:IsTimed()
	if self._istimed == nil then
		-- YouTube Live resolves to 0 second video duration
		self._istimed = self:Duration() > 0
	end

	return self._istimed
end

function SERVICE:GetYouTubeVideoId()

	local videoId

	if self.videoId then

		videoId = self.videoId

	elseif self.urlinfo then

		local url = self.urlinfo

		-- http://www.youtube.com/watch?v=(videoId)
		if url.query and url.query.v then
			videoId = url.query.v

		-- http://www.youtube.com/v/(videoId)
		elseif url.path and string.match(url.path, "^/v/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/v/([%a%d-_]+)")

		-- http://youtube.googleapis.com/v/(videoId)
		elseif url.path and string.match(url.path, "^/v/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/v/([%a%d-_]+)")

		-- http://youtu.be/(videoId)
		elseif string.match(url.host, "youtu.be") and
			url.path and string.match(url.path, "^/([%a%d-_]+)$") and
			( (not url.query) or #url.query == 0 ) then -- short url

			videoId = string.match(url.path, "^/([%a%d-_]+)$")
		end

		self.videoId = videoId

	end

	return videoId

end

--PATH addons/media_player/lua/mediaplayer/services/twitch/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Twitch.TV - Video"
SERVICE.Id 		= "twv"
SERVICE.Base 	= "browser"

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)

	local info = obj:GetTwitchVideoInfo()
	obj._data = info.channel .. "_" .. info.chapterId

	return obj
end

function SERVICE:Match( url )
	-- TODO: should the parsed url be passed instead?
	return (string.match(url, "justin.tv") or
			string.match(url, "twitch.tv")) and
			string.match(url, ".tv/[%w_]+/%a/%d+")
end

function SERVICE:GetTwitchVideoInfo()

	local info

	if self._twitchInfo then

		info = self._twitchInfo

	elseif self.urlinfo then

		local url = self.urlinfo

		local channel, type, chapterId = string.match(url.path, "^/([%w_]+)/(%a)/(%d+)")

		-- Chapter videos use /c/ while archived videos use /b/
		if type ~= "c" then
			type = "b"
		end

		info = {
			channel		= channel,
			type		= type,
			chapterId	= chapterId
		}

		self._twitchInfo = info

	end

	return info

end

--PATH addons/media_player/lua/mediaplayer/services/twitchstream/shared.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Twitch.TV - Stream"
SERVICE.Id 		= "twl"
SERVICE.Base 	= "browser"

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)

	local channel = obj:GetTwitchChannel()
	obj._data = channel

	return obj
end

function SERVICE:Match( url )
	return string.match(url, "twitch.tv") and
			string.match(url, ".tv/[%w_]+$")
end

function SERVICE:IsTimed()
	return false
end

function SERVICE:GetTwitchChannel()

	local channel

	if self._twitchChannel then

		channel = self._twitchChannel

	elseif self.urlinfo then

		local url = self.urlinfo

		channel = string.match(url.path, "^/([%w_]+)")
		self._twitchChannel = channel

	end

	return channel

end

--PATH addons/media_player/lua/mediaplayer/services/vimeo/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

local JS_SetVolume = "if(window.MediaPlayer) MediaPlayer.setVolume(%s);"
local JS_Seek = "if(window.MediaPlayer) MediaPlayer.seek(%s);"

local function VimeoSetVolume( self )
	if not self.Browser then return end
	local js = JS_SetVolume:format( MediaPlayer.Volume() )
	self.Browser:RunJavascript(js)
end

local function VimeoSeek( self, seekTime )
	if not self.Browser then return end
	local js = JS_Seek:format( seekTime )
	self.Browser:RunJavascript(js)
end

function SERVICE:SetVolume( volume )
	VimeoSetVolume( self )
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local videoId = self:GetVimeoVideoId()

	-- local url = VimeoVideoUrl:format( videoId )
	-- browser:OpenURL( url )

	-- browser:QueueJavascript( JS_Init )

	-- local html = EmbedHTML:format( videoId )
	-- html = self.WrapHTML( html )
	-- browser:SetHTML( html )

	local url = "http://localhost/vimeo.html#" .. videoId
	browser:OpenURL( url )

end

function SERVICE:Sync()
	local seekTime = self:CurrentTime()
	if seekTime > 0 then
		VimeoSeek( self, seekTime )
	end
end

--PATH addons/media_player/lua/mediaplayer/sh_history.lua:
--[[---------------------------------------------------------
	Media Player History
-----------------------------------------------------------]]

MediaPlayer.History = {}

---
-- Default metadata table name
-- @type String
--
local TableName = "mediaplayer_history"

---
-- SQLite table struct
-- @type String
--
local TableStruct = string.format([[
CREATE TABLE %s (
	id				INTEGER PRIMARY KEY AUTOINCREMENT,
	mediaid			VARCHAR(48),
	url				VARCHAR(512),
	player_name		VARCHAR(32),
	steamid			VARCHAR(32),
	time			DATETIME DEFAULT CURRENT_TIMESTAMP
)]], TableName)

---
-- Default number of results to return
-- @type Integer
--
local DefaultResultLimit = 100

---
-- Log the given media as a request.
--
-- @param media		Media service object.
-- @return table	SQL query results.
--
function MediaPlayer.History:LogRequest( media )
	local id = media:UniqueID()
	if not id then return end

	local ply = media:GetOwner()
	if not IsValid(ply) then return end

	local query = string.format( "INSERT INTO `%s` " ..
			"(mediaid,url,player_name,steamid) " ..
			"VALUES ('%s',%s,%s,'%s')",
			TableName,
			media:UniqueID(),
			sql.SQLStr( media:Url() ),
			sql.SQLStr( ply:Nick() ),
			ply:SteamID64() or -1 )

	local result = sql.Query(query)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.History.LogRequest")
		print(query)
		if istable(result) then
			PrintTable(result)
		else
			print(result)
		end
	end

	return result
end

function MediaPlayer.History:GetRequestsByPlayer( ply, limit )
	if not isnumber(limit) then
		limit = DefaultResultLimit
	end

	local query = string.format( [[
SELECT H.*, M.title, M.thumbnail, M.duration
FROM %s AS H
JOIN mediaplayer_metadata AS M
	ON (M.id = H.mediaid)
WHERE steamid='%s'
LIMIT %d]],
			TableName,
			ply:SteamID64() or -1,
			limit )

	local result = sql.Query(query)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.History.GetRequestsByPlayer", ply, limit)
		print(query)
		if istable(result) then
			PrintTable(result)
		else
			print(result)
		end
	end

	return result
end

-- Create the SQLite table if it doesn't exist
if not sql.TableExists(TableName) then
	Msg("MediaPlayer.History: Creating `" .. TableName .. "` table...\n")
	print(sql.Query(TableStruct))
end

--PATH addons/media_player/lua/autorun/menubar/mp_options.lua:
hook.Add( "PopulateMenuBar", "MediaPlayerOptions_MenuBar", function( menubar )

	local m = menubar:AddOrGetMenu( "▶  Media Player" )

	m:AddCVar( "Fullscreen", "mediaplayer_fullscreen", "1", "0" )

	m:AddSpacer()

	m:AddOption( "Turn Off All", function()
		for _, mp in ipairs(MediaPlayer.GetAll()) do
			MediaPlayer.RequestListen( mp )
		end

		MediaPlayer.HideSidebar()
	end )

end )

--PATH addons/media_player/lua/mp_menu/cl_init.lua:
MP = MP or {}
MP.EVENTS = MP.EVENTS or {}

MP.EVENTS.UI = {

	--[[--------------------------------------------------------
		Sidebar events
	----------------------------------------------------------]]

	SETUP_SIDEBAR = "mp.events.ui.sidebarChanged",
	SETUP_PLAYBACK_PANEL = "mp.events.ui.setupPlaybackPanel",
	SETUP_MEDIA_PANEL = "mp.events.ui.setupMediaPanel",

	MEDIA_PLAYER_CHANGED = "mp.events.ui.mediaPlayerChanged",

	OPEN_REQUEST_MENU = "mp.events.ui.openRequestMenu",
	FAVORITE_MEDIA = "mp.events.ui.favoriteMedia",
	REMOVE_MEDIA = "mp.events.ui.removeMedia",
	SKIP_MEDIA = "mp.events.ui.skipMedia",
	VOTE_MEDIA = "mp.events.ui.voteMedia",
	TOGGLE_LOCK = "mp.events.ui.toggleLock",
	TOGGLE_PAUSE = "mp.events.ui.togglePause",
	TOGGLE_REPEAT = "mp.events.ui.toggleRepeat",
	TOGGLE_SHUFFLE = "mp.events.ui.toggleShuffle",
	SEEK = "mp.events.ui.seek",

	START_SEEKING = "mp.events.ui.startSeeking",
	STOP_SEEKING = "mp.events.ui.stopSeeking",

	PRIVILEGED_PLAYER = "mp.events.ui.privilegedPlayer"

}

include "sidebar.lua"

--PATH addons/__main/lua/autorun/mp_weapon_semipistol_sounds.lua:
sound.Add( {
    name = "Weapon_P2011.Single",
    channel = CHAN_WEAPON,
    volume = 1.0,
    soundlevel = SNDLVL_GUNFIRE,
    sound = "weapons/p2011/wpn_2011pistol_1p_wpnfire_shot_6ch_v1_01.wav"
} )

sound.Add( {
    name = "Weapon_r1pistol.magout",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/reloads/smartpistol_reload_magout_st_01.wav"
} )

sound.Add( {
    name = "Weapon_r1pistol.magin",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/reloads/smartpistol_reload_magin_st_01.wav"
} )

sound.Add( {
    name = "Weapon_r1pistol.slidefront",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/p2011/wpn_2011pistol_1p_wpnfire_mech_c_v1_1.wav"
} )
--PATH addons/____onyx_framework_2/lua/onyx/init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local Run = hook.Run
local IncludeFolder = onyx.IncludeFolder

if (SERVER) then
    -- resource.AddWorkshop('852839002')
end

Run('PreOnyxLoad')

-- non recursive
IncludeFolder('onyx/framework/')
IncludeFolder('onyx/ui/')

-- init modules
do
    local Find = file.Find
    local path = 'onyx/modules/'
    local _, folders = Find(path .. '*', 'LUA')
    for _, name in ipairs(folders) do
        onyx.Include(path .. name .. '/sh_init.lua')
    end
end

Run('PostOnyxLoad')
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua:
return {[940] = 902,[941] = 904,[942] = 905,[943] = 906,[945] = 913,[946] = 914,[947] = 915,[948] = 916,[949] = 917,[950] = 918,[951] = 919,[952] = 920,[953] = 921,[954] = 922,[955] = 923,[956] = 924,[957] = 925,[958] = 926,[959] = 927,[960] = 928,[961] = 929,[962] = 931,[963] = 931,[964] = 932,[965] = 933,[966] = 934,[967] = 935,[968] = 936,[969] = 937,[970] = 938,[971] = 939,[972] = 908,[973] = 910,[974] = 911,[976] = 914,[977] = 920,[981] = 934,[982] = 928,[985] = 984,[987] = 986,[989] = 988,[991] = 990,[993] = 992,[995] = 994,[997] = 996,[999] = 998,[1001] = 1000,[1003] = 1002,[1005] = 1004,[1007] = 1006,[1008] = 922,[1009] = 929,[1010] = 1017,[1013] = 917,[1016] = 1015,[1019] = 1018,[1072] = 1040,[1073] = 1041,[1074] = 1042,[1075] = 1043,[1076] = 1044,[1077] = 1045,[1078] = 1046,[1079] = 1047,[1080] = 1048,[1081] = 1049,[1082] = 1050,[1083] = 1051,[1084] = 1052,[1085] = 1053,[1086] = 1054,[1087] = 1055,[1088] = 1056,[1089] = 1057,[1090] = 1058,[1091] = 1059,[1092] = 1060,[1093] = 1061,[1094] = 1062,[1095] = 1063,[1096] = 1064,[1097] = 1065,[1098] = 1066,[1099] = 1067,[1100] = 1068,[1101] = 1069,[1102] = 1070,[1103] = 1071,[1104] = 1024,[1105] = 1025,[1106] = 1026,[1107] = 1027,[1108] = 1028,[1109] = 1029,[1110] = 1030,[1111] = 1031,[1112] = 1032,[1113] = 1033,[1114] = 1034,[1115] = 1035,[1116] = 1036,[1117] = 1037,[1118] = 1038,[1119] = 1039,[1121] = 1120,[1123] = 1122,[1125] = 1124,[1127] = 1126,[1129] = 1128,[1131] = 1130,[1133] = 1132,[1135] = 1134,[1137] = 1136,[1139] = 1138,[1141] = 1140,[1143] = 1142,[1145] = 1144,[1147] = 1146,[1149] = 1148,[1151] = 1150,[1153] = 1152,[1163] = 1162,[1165] = 1164,[1167] = 1166,[1169] = 1168,[1171] = 1170,[1173] = 1172,[1175] = 1174,[1177] = 1176,[1179] = 1178,[1181] = 1180,[1183] = 1182,[1185] = 1184,[1187] = 1186,[1189] = 1188,[1191] = 1190,[1193] = 1192,[1195] = 1194,[1197] = 1196,[1199] = 1198,[1201] = 1200,[1203] = 1202,[1205] = 1204,[1207] = 1206,[1209] = 1208,[1211] = 1210,[1213] = 1212,[1215] = 1214,[1218] = 1217,[1220] = 1219,[1222] = 1221,[1224] = 1223,[1226] = 1225,[1228] = 1227,[1230] = 1229,[1231] = 1216,[1233] = 1232,[1235] = 1234,[1237] = 1236,[1239] = 1238,[1241] = 1240,[1243] = 1242,[1245] = 1244,[1247] = 1246,[1249] = 1248,[1251] = 1250,[1253] = 1252,[1255] = 1254,[1257] = 1256,[1259] = 1258,[1261] = 1260,[1263] = 1262,[1265] = 1264,[1267] = 1266,[1269] = 1268,[1271] = 1270,[1273] = 1272,[1275] = 1274,[1277] = 1276,[1279] = 1278,[1281] = 1280,[1283] = 1282,[1285] = 1284,[1287] = 1286,[1289] = 1288,[1291] = 1290,[1293] = 1292,[1295] = 1294,[1297] = 1296,[1299] = 1298,[1377] = 1329,[1378] = 1330,[1379] = 1331,[1380] = 1332,[1381] = 1333,[1382] = 1334,[1383] = 1335,[1384] = 1336,[1385] = 1337,[1386] = 1338,[1387] = 1339,[1388] = 1340,[1389] = 1341,[1390] = 1342,[1391] = 1343,[1392] = 1344,[1393] = 1345,[1394] = 1346,[1395] = 1347,[1396] = 1348,[1397] = 1349,[1398] = 1350,[1399] = 1351,[1400] = 1352,[1401] = 1353,[1402] = 1354,[1403] = 1355,[1404] = 1356,[1405] = 1357,[1406] = 1358,[1407] = 1359,[1408] = 1360,[1409] = 1361,[1410] = 1362,[1411] = 1363,[1412] = 1364,[1413] = 1365,[1414] = 1366,[7549] = 11363,[7681] = 7680,[7683] = 7682,[7685] = 7684,[7687] = 7686,[7689] = 7688,}
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua:
return {[7689] = 7688,[7691] = 7690,[7693] = 7692,[7695] = 7694,[7697] = 7696,[7699] = 7698,[7701] = 7700,[7703] = 7702,[7705] = 7704,[7707] = 7706,[7709] = 7708,[7711] = 7710,[7713] = 7712,[7715] = 7714,[7717] = 7716,[7719] = 7718,[7721] = 7720,[7723] = 7722,[7725] = 7724,[7727] = 7726,[7729] = 7728,[7731] = 7730,[7733] = 7732,[7735] = 7734,[7737] = 7736,[7739] = 7738,[7741] = 7740,[7743] = 7742,[7745] = 7744,[7747] = 7746,[7749] = 7748,[7751] = 7750,[7753] = 7752,[7755] = 7754,[7757] = 7756,[7759] = 7758,[7761] = 7760,[7763] = 7762,[7765] = 7764,[7767] = 7766,[7769] = 7768,[7771] = 7770,[7773] = 7772,[7775] = 7774,[7777] = 7776,[7779] = 7778,[7781] = 7780,[7783] = 7782,[7785] = 7784,[7787] = 7786,[7789] = 7788,[7791] = 7790,[7793] = 7792,[7795] = 7794,[7797] = 7796,[7799] = 7798,[7801] = 7800,[7803] = 7802,[7805] = 7804,[7807] = 7806,[7809] = 7808,[7811] = 7810,[7813] = 7812,[7815] = 7814,[7817] = 7816,[7819] = 7818,[7821] = 7820,[7823] = 7822,[7825] = 7824,[7827] = 7826,[7829] = 7828,[7835] = 7776,[7841] = 7840,[7843] = 7842,[7845] = 7844,[7847] = 7846,[7849] = 7848,[7851] = 7850,[7853] = 7852,[7855] = 7854,[7857] = 7856,[7859] = 7858,[7861] = 7860,[7863] = 7862,[7865] = 7864,[7867] = 7866,[7869] = 7868,[7871] = 7870,[7873] = 7872,[7875] = 7874,[7877] = 7876,[7879] = 7878,[7881] = 7880,[7883] = 7882,[7885] = 7884,[7887] = 7886,[7889] = 7888,[7891] = 7890,[7893] = 7892,[7895] = 7894,[7897] = 7896,[7899] = 7898,[7901] = 7900,[7903] = 7902,[7905] = 7904,[7907] = 7906,[7909] = 7908,[7911] = 7910,[7913] = 7912,[7915] = 7914,[7917] = 7916,[7919] = 7918,[7921] = 7920,[7923] = 7922,[7925] = 7924,[7927] = 7926,[7929] = 7928,[7936] = 7944,[7937] = 7945,[7938] = 7946,[7939] = 7947,[7940] = 7948,[7941] = 7949,[7942] = 7950,[7943] = 7951,[7952] = 7960,[7953] = 7961,[7954] = 7962,[7955] = 7963,[7956] = 7964,[7957] = 7965,[7968] = 7976,[7969] = 7977,[7970] = 7978,[7971] = 7979,[7972] = 7980,[7973] = 7981,[7974] = 7982,[7975] = 7983,[7984] = 7992,[7985] = 7993,[7986] = 7994,[7987] = 7995,[7988] = 7996,[7989] = 7997,[7990] = 7998,[7991] = 7999,[8000] = 8008,[8001] = 8009,[8002] = 8010,[8003] = 8011,[8004] = 8012,[8005] = 8013,[8017] = 8025,[8019] = 8027,[8021] = 8029,[8023] = 8031,[8032] = 8040,[8033] = 8041,[8034] = 8042,[8035] = 8043,[8036] = 8044,[8037] = 8045,[8038] = 8046,[8039] = 8047,[8048] = 8122,[8049] = 8123,[8050] = 8136,[8051] = 8137,[8052] = 8138,[8053] = 8139,[8054] = 8154,[8055] = 8155,[8056] = 8184,[8057] = 8185,[8058] = 8170,[8059] = 8171,[8060] = 8186,[8061] = 8187,[8064] = 8072,[8065] = 8073,[8066] = 8074,[8067] = 8075,[8068] = 8076,[8069] = 8077,[8070] = 8078,[8071] = 8079,[8080] = 8088,[8081] = 8089,[8082] = 8090,[8083] = 8091,[8084] = 8092,[8085] = 8093,[8086] = 8094,[8087] = 8095,[8096] = 8104,[8097] = 8105,[8098] = 8106,[8099] = 8107,[8100] = 8108,[8101] = 8109,[8102] = 8110,[8103] = 8111,[8112] = 8120,[8113] = 8121,[8115] = 8124,[8126] = 921,[8131] = 8140,[8144] = 8152,[8145] = 8153,[8160] = 8168,[8161] = 8169,[8165] = 8172,[8179] = 8188,[8526] = 8498,[8560] = 8544,[8561] = 8545,[8562] = 8546,[8563] = 8547,[8564] = 8548,[8565] = 8549,[8566] = 8550,[8567] = 8551,[8568] = 8552,[8569] = 8553,[8570] = 8554,[8571] = 8555,[8572] = 8556,[8573] = 8557,[8574] = 8558,[8575] = 8559,[8580] = 8579,[9424] = 9398,[9425] = 9399,}
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("onyx_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("onyx_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "onyx.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("onyx_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("onyx_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

onyx.bshadows = BSHADOWS
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_category.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')
local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')

local font0 = onyx.Font('Comfortaa Bold@16')

local PANEL = {}

AccessorFunc(PANEL, 'm_Title', 'Title')
AccessorFunc(PANEL, 'm_iCategoryHeight', 'CategoryHeight')
AccessorFunc(PANEL, 'm_iSpace', 'Space')
AccessorFunc(PANEL, 'm_iInset', 'Inset')
AccessorFunc(PANEL, 'm_bExpanded', 'Expanded')
AccessorFunc(PANEL, 'm_iTextMargin', 'TextMargin')
AccessorFunc(PANEL, 'm_bSquareCorners', 'SquareCorners')

function PANEL:Init()
    local padding = onyx.ScaleTall(5)

    self.m_iArrowAngle = 90

    self.button = vgui.Create('Panel', self)
    onyx.gui.Extend(self.button)
    self.button:Import('click')
    self.button:Import('hovercolor')
    self.button:SetColorKey('backgroundColor')
    self.button:SetColorIdle(onyx.ColorBetween(colorSecondary, colorPrimary))
    self.button:SetColorHover(colorTertiary)
    self.button.textColor = color_white
    self.button.Paint = function(p, w, h)
        if (self.m_bSquareCorners and self.canvas:GetTall() > 0) then
            draw.RoundedBoxEx(8, 0, 0, w, h, p.backgroundColor, true, true)
        else
            draw.RoundedBox(8, 0, 0, w, h, p.backgroundColor)
        end

        local x = self.m_iTextMargin or padding
        local sz = math.floor(h * .5)

        if (self.wimage) then
            self.wimage:Draw(h * .5 - sz * .5, h * .5 - sz * .5, sz, sz, colorAccent)

            x = h
        end

        draw.SimpleText(self:GetTitle(), font0, x, h * .5, p.textColor, 0, 1)

        local sz = math.floor(h * .33)
        wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, self.m_iArrowAngle, color_white)
    end

    self.button.DoClick = function()
        if self:GetExpanded() then
            self:Close()
        else
            self:Open()
        end
    end

    self.canvas = vgui.Create('Panel', self)

    self:SetTitle('CATEGORY')
    self:SetInset(0)
    self:SetCategoryHeight(onyx.ScaleTall(30))
    self:SetSpace(onyx.ScaleTall(5))
    self:SetTall(self:GetCategoryHeight())
end

function PANEL:GetItems()
    return self.canvas:GetChildren()
end

function PANEL:SetExpanded(bBool)
    if (bBool) then
        self.button:SetColorIdle(colorSecondary)
    else
        self.button:SetColorIdle(onyx.ColorBetween(colorSecondary, colorPrimary))
    end

    self.m_bExpanded = bBool

    self:Call('OnStateChanged', nil, bBool)
end

function PANEL:Animate(height, arrowAngle)
    self.ah = self:GetTall()

    onyx.anim.Create(self, 0.3, {
        index = 1,
        target = {ah = height, m_iArrowAngle = arrowAngle},
        think = function(anim, panel)
            panel:SetTall(panel.ah)
            panel.canvas:SetTall(panel.ah - panel:GetSpace() - panel:GetCategoryHeight())
        end
    })
end

function PANEL:Think()
    self.canvas:SetVisible(self.canvas:GetTall() > 0) -- optimization
end

function PANEL:Open()
    local height = self:GetTotalHeight()

    self:SetExpanded(true)

    self:Animate(height, 0)
end

function PANEL:Close()
    self:SetExpanded(false)

    self:Animate(self:GetCategoryHeight(), 90)
end

function PANEL:Update()
    if (self:GetExpanded()) then
        local categoryHeight = self:GetCategoryHeight()
        local space = self:GetSpace()
        local height = self:GetTotalHeight()

        self.m_iArrowAngle = 0

        self:SetTall(height)
        self.canvas:SetTall(height - space - categoryHeight)
    end
end

function PANEL:UpdateInTick(ticks)
    ticks = ticks or 2
    timer.Simple(engine.TickInterval() * ticks, function()
        if (IsValid(self)) then
            self:Update()
        end
    end)
end

function PANEL:SetIcon(url, params)
    self.wimage = onyx.wimg.Simple(url, params)
end

function PANEL:PerformLayout(w, h)
    self.button:SetSize(w, self:GetCategoryHeight())
    self.canvas:SetWide(w)
    self.canvas:SetPos(0, self.button:GetTall() + self:GetSpace())
end

function PANEL:GetContentHeight()
    local panels = self.canvas:GetChildren()
    local count = #panels
    local size = 0

    for index, child in ipairs(panels) do
        if child:IsVisible() then
            local _, top, _, bottom = child:GetDockMargin()

            size = size + child:GetTall()
            size = size + top
            size = size + (index ~= count and bottom or 0)
        end
    end

    return size
end

function PANEL:GetTotalHeight()
    local h = self:GetCategoryHeight() + self:GetContentHeight() + self:GetSpace()

    h = h + self:GetInset() * 2

    return h
end

function PANEL:SetInset(amt)
    self.m_iInset = amt
    if (IsValid(self.canvas)) then
        self.canvas:DockPadding(amt, amt, amt, 0)
    end
end

function PANEL:Add(class)
    local panel = self.canvas:Add(class)

    -- self:AddPanel(panel)

    return panel
end

function PANEL:AddPanel(panel)
    return self.canvas:Add(panel)
end

function PANEL:GetItems()
    return self.canvas:GetChildren()
end

onyx.gui.Register('onyx.Category', PANEL)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

function PANEL:Init()
    self.divHeader = self:Add('onyx.Frame.Header')
    self.colorBG = onyx.OffsetColor(onyx:Config('colors.primary'), -5)

    self:Combine(self.divHeader, 'SetTitle')
    self:SetTitle('Frame')

    self.disabledPanels = {}
    self.focusMultiplier = 0

    self._Remove = self.Remove
    self.Remove = function(panel)
        panel:Close()
    end
end

function PANEL:ShowCloseButton(bVis)
    self.divHeader.btnClose:SetVisible(bVis)
end

function PANEL:PerformLayout(w, h)
    self.divHeader:Dock(TOP)
    self.divHeader:SetTall(ScreenScale(12))
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen(0, 0)

    if (self.focused and self.focusMultiplier > 0) then
        DisableClipping(true)
            onyx.DrawBlurExpensive(self, self.focusMultiplier)
        DisableClipping(false)
    end

    assert( self.colorBG )
    onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, x, y, w, h, self.colorBG)
    onyx.bshadows.EndShadow(1, 5, 5)
end

function PANEL:Focus()
    local panels = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs(panels) do
        if child:IsVisible() and child ~= self and child:IsMouseInputEnabled() then
            child:SetMouseInputEnabled(false)
            table.insert(self.disabledPanels, child)
        end
    end

    self.focused = true

    onyx.anim.Simple(self, .33, {
        focusMultiplier = 5
    }, 1)
end

function PANEL:UnFocus()
    for _, child in ipairs(self.disabledPanels) do
        if IsValid(child) then
            child:SetMouseInputEnabled(true)
        end
    end

    self.disabledPanels = {}
    self.focused = false
end

function PANEL:OnRemove()
    self:UnFocus()
end

function PANEL:Close()
    self:AlphaTo(0, .2, 0, function(_, panel)
        if (IsValid(panel)) then
            panel:_Remove()
        end
    end)
end

onyx.gui.Register('onyx.Frame', PANEL, 'EditablePanel')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self)
--     self:Focus()
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/languages/cl_german.lua:
--[[

Translator: TheStarHD (Deutsch übersetzung)
Email: thestarhd@gmx.net

25/05/2023

--]]

local LANG = {}

-- REGISTERKARTEN
LANG.store_u = 'LADEN'
LANG.inventory_u = 'INVENTAR'
LANG.refunds_u = 'ERSTATTUNGEN'
LANG.convert_u = 'UMWANDELN'
LANG.admin_u = 'ADMIN'
LANG.donate_u = 'SPENDEN'

-- ADMIN-REGISTERKARTEN
LANG.players_u = 'SPIELER'
LANG.items_u = 'ITEMS'
LANG.settings_u = 'EINSTELLUNGEN'
LANG.return_u = 'ZURÜCK'

-- WÖRTER
LANG.active_u = 'AKTIV'
LANG.unactive_u = 'UNAKTIV'
LANG.owned_u = 'EIGENTUM'
LANG.credits = 'Credits'
LANG.money = 'Geld'
LANG.both = 'Beide'
LANG.convert = 'Konvertieren'
LANG.single = 'Einzel'
LANG.half = 'Hälfte'
LANG.all = 'Alle'
LANG.icon = 'Symbol'
LANG.model = 'Modell'

-- OPTIONEN
LANG.use = 'Verwenden'
LANG.equip = 'Ausrüsten'
LANG.unequip = 'Ausrüstung entfernen'
LANG.spawn = 'Spawnen'
LANG.confirm = 'Bestätigen'
LANG.cancel = 'Abbrechen'
LANG.delete = 'Löschen'

-- PHRASEN
LANG.purchaseItem = 'Kaufe "{item}"'
LANG.notEnoughCredits = 'Nicht genügend Credits!'
LANG.youMustBeAlive = 'Du musst am Leben sein!'
LANG.requestRefund = 'Rückerstattung beantragen'
LANG.refundableUntil = 'RÜCKERSTATTBAR BIS'
LANG.currentRate = 'Aktueller Kurs: 1 Credit = {rate}'
LANG.youGive = 'DU GIBST'
LANG.youReceive = 'DU BEKOMMST'
LANG.giveItem = 'GEGENSTAND GEBEN'
LANG.nothingToRefund = 'NICHTS ZU ERSTATTEN'
LANG.healthIsFull = 'Deine Gesundheit ist voll!'
LANG.armorIsFull = 'Deine Rüstung ist voll!'
LANG.youRefunded = 'Du hast {item} für {price} Credits erstattet!'
LANG.youPurchased = 'Du hast {item} gekauft!'
LANG.youConverted = 'Du hast {A} in {B} umgewandelt!'
LANG.cantAfford = 'Du kannst dir das nicht leisten!'

LANG.createCategory = 'KATEGORIE ERSTELLEN'
LANG.newItem = 'NEUER GEGENSTAND'
LANG.edit_u = 'BEARBEITEN'
LANG.delete_u = 'LÖSCHEN'
LANG.create_u = 'ERSTELLEN'

LANG.searchName = 'Nach Namen suchen...'
LANG.searchNameSteamID = 'Nach Name/SteamID suchen...'

-- FEHLER
LANG.idMustBeUnique = 'Die Bezeichnung muss eindeutig sein!'
LANG.fieldMustNumber = 'Das Feld "{field}" muss eine Zahl sein!'
LANG.fieldMustPositive = 'Das Feld "{field}" muss eine positive Zahl sein!'
LANG.fieldMustChoose = 'Du musst "{field}" auswählen!'
LANG.fieldEnter = 'Du musst "{field}" eingeben!'
LANG.invalidModel = 'Das Modell ist ungültig!'
LANG.iconMustURL = 'Das Symbol muss eine URL sein!'
LANG.invalidIconFormat = 'Das Symbol muss im Format .png oder .jpg sein!'
LANG.notEnoughSymbols = 'Das Feld "{field}" muss min Symbol haben'

onyx.lang:AddPhrases('german', LANG)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/sh_cami_interface.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/05/2023

--]]

CAMI.RegisterPrivilege({
    Name = 'onyx_creditstore_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to EDIT items, categories, settings'
})

CAMI.RegisterPrivilege({
    Name = 'onyx_creditstore_give_items',
    MinAccess = 'superadmin',
    Description = 'Allows to GIVE items from other players\' inventories'
})

CAMI.RegisterPrivilege({
    Name = 'onyx_creditstore_take_items',
    MinAccess = 'superadmin',
    Description = 'Allows to TAKE items from other players\' inventories'
})

CAMI.RegisterPrivilege({
    Name = 'onyx_creditstore_see_inventory',
    MinAccess = 'admin',
    Description = 'Allows to SEE other players\' inventories'
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_armor.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

onyx.creditstore:RegisterType('armor', {
    name = 'Armor',
    color = Color(69, 99, 233),
    stacking = true,
    options = {
        ['use'] = {
            removeItem = true,
            check = function(ply, data)
                if (not ply:Alive()) then
                    return false, onyx.lang:Get('youMustBeAlive')
                end

                if (data.action == 1) then
                    if (ply:Armor() >= data.amount) then
                        return false, onyx.lang:Get('armorIsFull')
                    end
                else
                    if (ply:Armor() >= ply:GetMaxArmor()) then
                        return false, onyx.lang:Get('armorIsFull')
                    end
                end

                return true
            end,
            func = function(ply, data)
                local amount = tonumber(data.amount)
                local shouldSet = data.action == 1
                if (amount and amount > 0) then
                    if (shouldSet) then
                        ply:SetArmor(amount)
                    else
                        ply:SetArmor(math.min(ply:GetMaxArmor(), ply:Armor() + amount))
                    end
                    return true
                end
            end
        }
    },
    settings = {
        {
            key = 'action',
            name = 'ACTION',
            desc = 'What to do',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'combo',
            options = {
                {text = 'Give Armor', data = 0},
                {text = 'Set Armor', data = 1},
            },
            validateOption = function(data)
                -- do not be lazy to do this function, it is also used on the server side to validate value
                if (data == nil) then return false, 'You must choose an action type!' end
                if (not isnumber(data)) then return false end
                if (data < 0 or data > 1) then return false end
        
                return true
            end
        },
        {
            key = 'amount',
            name = 'AMOUNT',
            desc = 'The amount of AP to give.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '100',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 0!'
                end
                return true
            end
        }
    }
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_admin_category_configurator.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorQuaternary = onyx:Config('colors.quaternary')
local colorGray = Color(155, 155, 155)
local colorRed = Color(196, 77, 77)

local font0 = onyx.Font('Comfortaa Bold@16')
local font1 = onyx.Font('Comfortaa Bold@20')
local wimgLinked = onyx.wimg.Simple('https://i.imgur.com/jSCI5Ma.png', 'smooth mips')
local wimgLock = onyx.wimg.Simple('https://i.imgur.com/R9B3Zm3.png', 'smooth mips')

function PANEL:Init()
    local margin = onyx.ScaleTall(10)

    self.fields = {}

    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)
    self.list:DockMargin(margin, margin, margin, margin)

    -- IDENTIFIER
    self:AddField({
        key = 'id',
        name = 'IDENTIFIER',
        desc = 'The unique identifier of the category.',
        icon = 'https://i.imgur.com/GUrwAHN.png',
        type = 'string',
        placeholder = 'knives'
    })
    -- NAME
    self:AddField({
        key = 'name',
        name = 'NAME',
        desc = 'The name of the category.',
        icon = 'https://i.imgur.com/tRA1npP.png',
        type = 'string',
        placeholder = 'Knives'
    })
    -- ORDER
    self:AddField({
        key = 'order',
        name = 'ORDER',
        desc = 'The order of the category.',
        icon = 'https://i.imgur.com/l1JfnNY.png',
        type = 'number',
        placeholder = '1'
    })
    -- ICON
    self:AddField({
        key = 'icon',
        name = 'ICON',
        desc = 'The icon of the category.',
        icon = 'https://i.imgur.com/hiJ6Qft.png',
        type = 'string',
        placeholder = 'https://i.imgur.com/09h2MHS.png'
    })

    self.btnCreate = self.list:Add('onyx.Button')
    self.btnCreate:SetText(onyx.lang:Get('create_u'))
    self.btnCreate:SetZPos(99)
end

function PANEL:PerformLayout(w, h)

end

function PANEL:CategoryCreation()
    self.btnCreate.DoClick = function(panel)
        local categoryData = self:GenerateCategoryData()
        if (categoryData) then
            net.Start('onyx.creditstore:CreateCategory')
                onyx.net.WriteTable(categoryData)
            net.SendToServer()

            self:Call('OnEditRequested')

            surface.PlaySound('onyx/ui/on_affirm/echo_affirm1.wav')
        else
            surface.PlaySound('onyx/ui/on_deny/echo_deny.wav')
        end
    end
end

function PANEL:GenerateCategoryData(bEdit)
    local fields = self.fields
    local category = {}

    category.id = fields.id.entry:GetValue()
    category.name = fields.name.entry:GetValue()
    category.order = fields.order.entry:GetValue()
    category.icon = fields.icon.entry:GetValue()

    local sorted = {'id', 'name', 'order', 'icon'}

    if (bEdit) then
        table.RemoveByValue(sorted, 'id')
    end
    
    for _, key in ipairs(sorted) do
        local value = category[key]
        if not value then continue end

        local valid, reason = onyx.creditstore:ValidateFieldValue(key, value)
        -- print(key, valid, reason)
        if (not valid) then
            notification.AddLegacy(reason, 1, 3)

            local fieldKey = key
            if (fields[fieldKey]) then
                if (fields[fieldKey].entry) then
                    fields[fieldKey].entry:Highlight(Color(179, 70, 70))
                elseif (fields[fieldKey].combo) then
                    fields[fieldKey].combo:Highlight(Color(179, 70, 70))
                end
            end

            return false
        end
    end

    return category
end

function PANEL:AddField(data, attached)
    local padding = onyx.ScaleTall(7)

    data.desc = onyx.lang:GetWFallback(data.name .. '_Desc', data.desc)
    data.name = onyx.lang:Get(data.name)

    local field = self.list:Add('DPanel')
    field:SetTall(onyx.ScaleTall(85))
    field:Dock(TOP)
    field:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    field.Paint = function(p, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.fields[data.key] = field

    local info = field:Add('Panel')
    info:Dock(TOP)
    info:SetTall(field:GetTall() * .5)
    info:DockPadding(padding, padding, padding, padding)
    info.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorTertiary, true, true)
        
        -- surface.SetDrawColor(0, 0, 0, 100)
        surface.SetDrawColor(255, 255, 255, 10)
        surface.DrawRect(0, h - 1, w, 1)

        local child = field.entry or field.combo
        local locked = child:GetDisabled()
        local size = onyx.ScaleTall(12)

        if (locked) then
            wimgLock:Draw(w - h * .5 - size * .5, h * .5 - size * .5, size, size, colorRed)
        elseif (attached) then
            wimgLinked:Draw(w - h * .5 - size * .5, h * .5 - size * .5, size, size, colorGray)
        end
    end

    local icon = info:Add('onyx.Image')
    icon:Dock(LEFT)
    icon:SetWide(info:GetTall() - padding * 2)
    if (data.webImage) then
        icon:SetWebImage(data.webImage, 'smooth mips')
    else
        icon:SetURL(data.icon, 'smooth mips')
    end
    icon:SetImageWide(onyx.ScaleTall(16))
    icon:SetImageTall(icon:GetImageWide())

    local lblName = info:Add('onyx.Label')
    lblName:Font('Comfortaa Bold@14')
    lblName:SetText(data.name)
    lblName:Color(colorAccent)
    lblName:Dock(FILL)

    if (attached) then
        lblName:Color(onyx.GetOppositeAccentColor())
    end

    local lblDesc = info:Add('onyx.Label')
    lblDesc:Font('Comfortaa@14')
    lblDesc:SetText(data.desc)
    lblDesc:SizeToContentsY()
    lblDesc:Dock(BOTTOM)

    local content = field:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(padding, padding, padding, padding)

    if (data.type == 'combo') then
        local combo = content:Add('onyx.ComboBox')
        combo:Dock(FILL)
        combo.OnSelect = function(panel, index, text, optionData)
            if (data.onChoose) then
                data.onChoose(index, text, optionData, self.fields)
            end
        end

        local options = data.getOptions and data.getOptions() or data.options

        for _, option in pairs(options) do
            combo:AddOptionAdvanced(option)
        end

        field.combo = combo
    elseif (data.type == 'icon/model') then
        local divider = content:Add('Panel')
        divider:Dock(FILL)

        local entry = divider:Add('onyx.TextEntry')
        entry:Dock(FILL)

        field.entry = entry

        local picker = divider:Add('onyx.ComboBox')
        picker:Dock(LEFT)
        picker:SetWide(onyx.ScaleWide(100))
        picker:DockMargin(0, 0, onyx.ScaleWide(5), 0)
        picker:AddOptionAdvanced({
            text = 'Icon',
            iconURL = 'https://i.imgur.com/QhuSK6f.png',
            iconParams = 'smooth mips',
            data = false
        })
        picker:AddOptionAdvanced({
            text = 'Model',
            iconURL = 'https://i.imgur.com/9mcE5Ge.png',
            iconParams = 'smooth mips',
            data = true
        })
        picker.OnSelect = function(panel, index, text, data)
            entry:SetValue('')
            if (data) then
                entry:SetPlaceholderText('Write the path to the model')
            else
                entry:SetPlaceholderText('Write the URL to the icon')
            end
        end

        picker:ChooseOptionID(1)

        field.picker = picker
    else
        local entry = content:Add('onyx.TextEntry')
        entry:Dock(FILL)
        entry:SetPlaceholderText(data.placeholder)

        field.entry = entry
    end

    return field
end

function PANEL:CategoryEditor(categoryID, categoryTable)
    local fields = self.fields

    -- PrintTable(categoryTable)

    fields.id.entry:SetValue(categoryTable.id)
    fields.id.entry:SetDisabled(true)

    fields.name.entry:SetValue(categoryTable.name)

    fields.order.entry:SetValue(tostring(categoryTable.order))

    fields.icon.entry:SetValue(categoryTable.icon)

    self.btnDelete = self.list:Add('onyx.Button')
    self.btnDelete:SetText(onyx.lang:Get('delete_u'))
    self.btnDelete:SetZPos(100)
    self.btnDelete:SetColorIdle(onyx:Config('colors.negative'))
    self.btnDelete:SetColorHover(onyx.OffsetColor(self.btnDelete:GetColorIdle(), -30))
    self.btnDelete.DoClick = function()
        net.Start('onyx.creditstore:DeleteCategory')
            net.WriteString(categoryID)
        net.SendToServer()

        self:Call('OnEditRequested')
    end

    self.btnCreate:SetText(onyx.lang:Get('edit_u'))
    self.btnCreate.DoClick = function(panel)
        local categoryData = self:GenerateCategoryData(true)
        if (categoryData) then
            local id = categoryData.id

            categoryData.id = nil

            net.Start('onyx.creditstore:EditCategory')
                net.WriteString(id)
                onyx.net.WriteTable(categoryData)
            net.SendToServer()

            self:Call('OnEditRequested')

            surface.PlaySound('onyx/ui/on_affirm/echo_affirm1.wav')
        else
            surface.PlaySound('onyx/ui/on_deny/echo_deny.wav')
        end
    end
end

onyx.gui.Register('onyx.creditstore.AdminCategoryConfigurator', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .33, .5, function(self)
--     self:MakePopup()

--     local content = self:Add('onyx.creditstore.AdminCategoryConfigurator')
--     content:Dock(FILL)
--     content:CategoryCreation()
--     content.OnEditRequested = function()
--         self:Remove()
--     end
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_refunds.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/05/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorQuaternary = onyx:Config('colors.quaternary')
local colorGray = onyx:Config('colors.gray')
local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')

local font0 = onyx.Font('Comfortaa Bold@16')
local font1 = onyx.Font('Comfortaa Bold@20')
local font2 = onyx.Font('Comfortaa@16')
local font3 = onyx.Font('Comfortaa Bold@24')

local wimgEmpty = onyx.wimg.Simple('https://i.imgur.com/1E8Nx8L.png', 'smooth mips')

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    hook.Add('onyx.credistore.InventoryUpdated', self, function(panel)
        panel:LoadItems()
    end)

    self:LoadItems()
    self.empty = #self.list:GetItems() <= 0
    self.textNothing = onyx.lang:Get('nothingToRefund')
end

function PANEL:PaintOver(w, h)
    -- print(self.empty)
    if (self.empty) then
        local size = onyx.ScaleTall(64)
        local space = onyx.ScaleTall(30)
        local text = self.textNothing
        local textWidth, textHeight = onyx.GetTextSize(text, font3)
        local totalH = size + space + textHeight
        local y = h * .5 - totalH * .5
        
        wimgEmpty:Draw(w * .5 - size * .5, y, size, size, colorTertiary)
        draw.SimpleText(text, font3, w * .5, y + size + space, colorTertiary, 1, 1)
    end
end

function PANEL:LoadItems()
    for _, panel in ipairs(self.list:GetItems()) do
        panel:Remove()
    end

    local inventory = onyx.creditstore:GetPlayerInventory(LocalPlayer())

    local sorted = {}

    for index, it in ipairs(inventory) do
        local id = it.id
        local data = it.data or {}

        if (data and data.price and data.unix) then
            local endTime = onyx.creditstore:GetRefundEndTime(data.unix)
            if (endTime >= os.time()) then
                table.insert(sorted, {
                    it = it,
                    index = index,
                    endTime = endTime,
                    unix = data.unix,
                    price = data.price
                })
            end
        end
    end

    table.sort(sorted, function(a, b)
        return a.unix > b.unix
    end)

    for _, slot in ipairs(sorted) do
        local it = slot.it
        local itemID = it.id
        local itemTable = onyx.creditstore.items[itemID]
        if (not itemTable) then continue end
        local itemTypeData = onyx.creditstore.types[itemTable.type]
        if (not itemTypeData) then continue end

        local itemTypeName = onyx.lang:Get(itemTypeData.name)
        local itemTypeColor = itemTypeData.color
        local model = itemTable.model
        local icon = itemTable.icon
        local padding = onyx.ScaleTall(5)
        local untilDate = slot.endTime
        local untilDateStr = os.date('%d %B %H:%M', untilDate)
        local textRefundableUntil = onyx.lang:Get('refundableUntil')

        local row = self.list:Add('onyx.Button')
        row:SetTall(onyx.ScaleTall(50))
        row:Dock(TOP)
        row:SetColorIdle(colorSecondary)
        row:SetColorHover(colorTertiary)
        row:SetText('')
        row:InjectEventHandler('Paint')
        row:Padding(padding)
        row:AddClickEffect()
        row:AddHoverSound()
        row:On('Paint', function(panel, w, h)
            draw.SimpleText(itemTable.name, font1, h + onyx.ScaleWide(5), h * .5, color_white, 0, 4)
            draw.SimpleText(itemTypeName, font2, h + onyx.ScaleWide(5), h * .5, itemTypeColor, 0, 0)

            draw.SimpleText(textRefundableUntil, font2, w * .5, h * .5, colorGray, 1, 4)
            draw.SimpleText(untilDateStr, font0, w * .5, h * .5, color_white, 1, 0)
        end)
        row.DoClick = function()
            local dmenu = vgui.Create('onyx.Menu')
            local sub = dmenu:AddSubMenu(onyx.lang:Get('requestRefund'))
            
            sub:AddOption(onyx.lang:Get('confirm'), function()
                net.Start('onyx.creditstore:Refund')
                    net.WriteUInt(slot.index, 16)
                net.SendToServer()
            end)

            sub:AddOption(onyx.lang:Get('cancel'), function()
                
            end)

            dmenu:ToCursor()
            dmenu:Open()
            -- net.Start('onyx.creditstore:AdminGiveItem')
            --     net.WriteString(self.steamid64)
            --     net.WriteString(itemID)
            -- net.SendToServer()
        end

        local money = row:Add('onyx.Label')
        money:Font('Comfortaa Bold@20')
        money:SetTextColor(color_white)
        money:Dock(RIGHT)
        money:SetZPos(-1)
        money:SetContentAlignment(4)
        money:SetMouseInputEnabled(true)
        money:SetText(onyx.creditstore.FormatMoney(onyx.creditstore:GetRefundPrice(slot.price)))
        money:SizeToContentsX(onyx.ScaleWide(10))
        money:SetMouseInputEnabled(false)
        money.Paint = function(p, w, h)
            draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, nil, true, nil, true)
        end
        self.money = money
    
        local picon = row:Add('onyx.Image')
        picon:Dock(RIGHT)
        picon:SetZPos(-1)
        picon:SetImageWide(onyx.ScaleTall(16))
        picon:SetImageTall(picon:GetImageWide())
        picon:SetWide(row:GetTall() - padding * 2)
        picon:DockMargin(0, 0, 0, 0)
        picon:SetColor(colorAccent)
        picon:SetMouseInputEnabled(false)
        -- picon:DockMargin(onyx.ScaleWide(5), 0, 0, 0)
        picon.m_WebImage = wimgCoin
        picon.PaintBackground = function(p, w, h)
            draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, true, nil, true)
        end

        local slot = row:Add('Panel')
        slot:Dock(LEFT)
        slot:SetWide(row:GetTall() - padding * 2)
        slot.Paint = function(p, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorPrimary)

            if (p.icon) then
                local sz = math.ceil(h * .66)
                p.icon:Draw(w * .5 - sz * .5, h * .5 - sz * .5, sz, sz)
            end
        end

        row.itemName = itemTable.name

        if (icon) then
            slot.icon = onyx.wimg.Simple(icon, '')
        elseif (model) then
            row.dmodel = slot:Add('DModelPanel')
            row.dmodel:Dock(FILL)
            row.dmodel:SetMouseInputEnabled(false)
            row.dmodel:SetModel(model)

            local ent = row.dmodel.Entity
            if (IsValid(ent)) then
                local min, max = ent:GetRenderBounds()
                local center = (min + max) * 0.5
                local distance = 0

                for _, key in ipairs({"x", "y", "z"}) do
                    distance = math.max(distance, max[key])
                end

                row.dmodel:SetLookAt(center)
                row.dmodel:SetFOV(distance + 5)
                row.dmodel.LayoutEntity = function() end
            end
        end
    end
end

onyx.gui.Register('onyx.creditstore.Refunds', PANEL)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/ui/cl_tab_other.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGradient = onyx.OffsetColor(colorAccent, -50)
local colorLabel = color_white
local fontTitle = onyx.Font('Comfortaa Bold@16')

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local formatMoney do
    local format = {
        {'t', 10 ^ 12, 2},
        {'b', 10 ^ 9, 2},
        {'m', 10 ^ 6, 2},
        {'k', 10 ^ 3}
    }
    local amount = #format

    function formatMoney(money)
        for index = 1, amount do
            local data = format[index]
            local name = data[1]
            local value = data[2]
            local decimals = data[3] or 1
            if (money > value) then
                return rp.FormatMoney( math.Round(money / value, decimals) ) .. name
            end
        end

        return rp.FormatMoney(money)
    end
end

local function drawShadowBG(panel, w, h, color)
    -- local x, y = panel:LocalToScreen(0, 0)

    -- onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, 0, 0, w, h, color)
    -- onyx.bshadows.EndShadow(1, 1, 2, nil, nil, 2)
end

function PANEL:Init()
    self.space = onyx.ScaleTall(10)
    self.padding = onyx.ScaleTall(10)
    self.smallHeaderHeight = onyx.ScaleTall(25)

    self.divBody = self:Add('Panel')

    self.divActions = self.divBody:Add('Panel')
    self.divActions.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblActions = self.divActions:Add('onyx.Label')
    self.lblActions:SetText(L('f4_actions_u'))
    self.lblActions:SetFont(fontTitle)
    self.lblActions:SetTextColor(colorLabel)
    self.lblActions:Dock(TOP)
    self.lblActions:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblActions:CenterText()
    self.lblActions:SetTall(self.smallHeaderHeight)
    self.lblActions.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listActions = self.divActions:Add('onyx.ScrollPanel')
    self.listActions:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listActions:Dock(FILL)

    self:InitActions()
end

local tbl = {
    {name = 'Налаштування 3-ї особи та прицілу', func = function(client)
        RunConsoleCommand('ukrp_option_3person_and_crosshair')
    end},
    {name = 'Anti-Crash', func = function(client)
        RunConsoleCommand('anticrash_open')
    end, check = function()
        return LocalPlayer():IsSuperAdmin()
    end},
}

function PANEL:InitActions()
    local listActions = self.listActions

    local gridPanel = listActions:Add('onyx.Grid')
    gridPanel:Dock(TOP)
    gridPanel:SetColumnCount(3)
    gridPanel:SetSpaceX(onyx.ScaleTall(5))
    gridPanel:SetSpaceY(gridPanel:GetSpaceX())
    gridPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

    for _, action in ipairs(tbl) do
        if action.check and not action.check() then continue end
        self:AddAction(gridPanel, action.name, action.func)
    end
end

function PANEL:AddAction(grid, name, func)
    local client = LocalPlayer()
    local button = grid:Add('onyx.Button')
    button:SetText(onyx.lang:Get(name))
    button:SetGradientColor(colorGradient)
    button:SetMasking(true)
    button:Font('Comfortaa Bold@16')
    button:SetTall(onyx.ScaleTall(25))
    button.DoClick = function()
        if (func) then
            func(client)
        end
    end
end

function PANEL:PerformLayout(w, h)
    self.divBody:Dock(FILL)

    self.divActions:Dock(FILL)
end

onyx.gui.Register('onyx.f4.Other', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(1)
-- end)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/ui/cl_tab_shop.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)
local colorCanAfford = Color(121, 255, 141)
local colorCannotAfford = Color(253, 120, 120)
local COLOR_NEGATIVE = Color(221, 107, 107)
local oldScrollValues = {}
local convars = {}
local itemTypes = {'other', 'naboi', 'ammo', 'weapons'}
for _, itemType in ipairs(itemTypes) do
    convars[itemType] = CreateClientConVar('cl_onyx_f4_show_favorite_' .. itemType, '1', true, false)
end

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)

    self.container = self:Add('Panel')
    self.container:Dock(FILL)

    self.toolbar = self:Add('DPanel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(80))
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        self.topRow:SetTall(h * 0.5)
        self.favToggler:SetWide(self.favToggler:GetContentWidth())
    end

    self.topRow = self.toolbar:Add('Panel')
    self.topRow:Dock(BOTTOM)
    self.topRow:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding * 2, toolbarPadding)

    self.navbar = self.toolbar:Add('onyx.Navbar')
    self.navbar:Dock(FILL)
    self.navbar:SetContainer(self.container)
    self.navbar:SetKeepTabContent(true)
    -- self.navbar:SetRoundness(8)
    self.navbar.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorTertiary, true, true)
        surface.SetDrawColor(colorLine)
        surface.DrawRect(0, h - 1, w, 1)
    end
    self.navbar.OnTabSelected = function(panel, tab, content)
        local convar = convars[tab.ItemType]

        self.search:SetValue('')
        self.favToggler:SetVisible(convar ~= nil)

        if (convar) then
            self.favToggler:SetChecked(convar:GetBool())
            self.favToggler.OnChange = function(panel, bool)
                convar:SetBool(bool)

                tab.content:Remove()
                self.navbar:SelectTab(tab, true)
                tab.content:SetAlpha(0)
                tab.content:AlphaTo(255, .3)
            end
        end
    end

    self.favToggler = self.topRow:Add('onyx.TogglerLabel')
    self.favToggler:Dock(RIGHT)
    self.favToggler:SetText(L('f4_show_favorite'))
    self.favToggler:SetBackgroundColor(onyx.OffsetColor(colorTertiary, 10))
    self.favToggler:Font('Comfortaa Bold@18')
    self.favToggler:SetTextMargin(onyx.ScaleTall(10))

    self.search = self.topRow:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('f4_search_text'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        local activeTab = self.navbar:GetActiveTab()
        if (not IsValid(activeTab)) then return end

        local plist = activeTab.content

        for _, cat in ipairs(plist:GetItems()) do
            local layout = cat.canvas:GetChild(0)
            local items = layout:GetChildren()
            local visibleItemAmount = 0

            for _, item in ipairs(items) do
                if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                    item:SetVisible(true)
                    visibleItemAmount = visibleItemAmount + 1
                else
                    item:SetVisible(false)
                end
            end

            layout:InvalidateLayout()

            cat:SetVisible(value == '' or visibleItemAmount > 0)
            cat:UpdateInTick()
        end

        plist:InvalidateLayout()
    end

    self.enabledFirst = false
    self.categories = {}
    self:AddItemCategory('other', L('f4_entities_u'), 'https://i.imgur.com/JnNGizM.png', Color(141, 208, 255), 'canBuyCustomEntity', function(item)
        RunConsoleCommand('buy', item.Command)
    end)

    self:AddItemCategory('weapons', L('f4_weapons_u'), 'https://i.imgur.com/IJQlezA.png', Color(255, 73, 73), 'canBuyPistol', function(item)
        RunConsoleCommand('buyweapon', item.ENT)
    end)

    self:AddItemCategory('naboi', L('f4_ammo_u'), 'https://i.imgur.com/oRqB4Cl.png', Color(255, 246, 141), 'canBuyAmmo', function(item)
        RunConsoleCommand('buy', item.Command)
    end)
end

function PANEL:AddItemCategory(id, name, icon, color, hookName, purchaseFunc)
    --local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local client = LocalPlayer()
    local teamIndex = client:Team()
    local categories = {}
    local membersAmount = 0

    -- local darkRPCategories = istable(id) and id or DarkRP.getCategories()[id]
    -- if (not darkRPCategories) then
    --     return
    -- end

    -- No favorites for food, sorry :(
    if (isstring(id)) then
        local members = onyx.f4:FetchFavoriteObjects(id)
        if (members) then
            table.insert(categories, {
                members = members,
                name = L('f4_favorite_u'),
                favorite = true
            })
        end
    end

    -- for _, cat in ipairs(darkRPCategories) do
    --     local canSee = cat.canSee
    --     local catName = cat.name
    --     local catMembers = {}

    --     if (not canSee or canSee(client)) then

    --         local members = cat.members or {}
    --         for _, member in ipairs(members) do
    --             local customCheck = member.customCheck
    --             local allowed = member.allowed
    --             local reason

    --             if (customCheck and not customCheck(client)) then
    --                 if (showUnavailable) then
    --                     reason = L('f4_unavailable')
    --                 else
    --                     continue
    --                 end
    --             end

    --             if (hookName) then
    --                 local canBuy, suppress, message = hook.Call(hookName, nil, client, member)
    --                 if (canBuy == false) then
    --                     if (not suppress) then
    --                         reason = message
    --                     else
    --                         continue
    --                     end
    --                 end
    --             end

    --             if (allowed and not table.HasValue(allowed, teamIndex)) then
    --                 continue
    --             end

    --             if (member.energy and member.requiresCook ~= false and not client:isCook()) then
    --                 return
    --             end

    --             membersAmount = membersAmount + 1
    --             table.insert(catMembers, {
    --                 item = member,
    --                 reason = reason
    --             })
    --         end

    --         table.insert(categories, {
    --             members = catMembers,
    --             name = catName
    --         })

    --     end
    -- end

    if id == 'ammo' then
        local catMembers = {}

        for k, v in pairs(rp.Ammo) do
            membersAmount = membersAmount + 1
            table.insert(catMembers, {
                item = v
            })
        end

        table.insert(categories, {
            members = catMembers,
            name = name
        })
    elseif id == 'weapons' then
        local catMembers = {}

        for k, v in pairs(rp.Weapons) do
            local allowed = v.allowed
            if (allowed and not allowed[teamIndex]) then
                continue
            end
            --
            membersAmount = membersAmount + 1
            table.insert(catMembers, {
                item = v
            })
        end

        table.insert(categories, {
            members = catMembers,
            name = name
        })
    elseif id == 'naboi' then
        local catMembers = {}

        for k, v in pairs(rp.Entites) do
            if v.Desc ~= 'Набої' then continue end
            --
            local allowed = v.allowed
            if (allowed and not allowed[teamIndex]) then
                continue
            end
            --
            membersAmount = membersAmount + 1
            table.insert(catMembers, {
                item = v
            })
        end

        table.insert(categories, {
            members = catMembers,
            name = name
        })
    else
        local catMembers = {}

        for k, v in pairs(rp.Entites) do
            if v.Desc == 'Набої' then continue end
            --
            local allowed = v.allowed
            if (allowed and not allowed[teamIndex]) then
                continue
            end
            --
            membersAmount = membersAmount + 1
            table.insert(catMembers, {
                item = v
            })
        end

        table.insert(categories, {
            members = catMembers,
            name = 'Общие'
        })
    end

    for _, category in ipairs(categories) do
        if (category.members) then
            table.sort(category.members, function(a, b)
                local aSort = a.item.sortOrder or 100
                local bSort = b.item.sortOrder or 100
                local aName = a.item.name or ''
                local bName = b.item.name or ''

                return (aSort < bSort or (aSort == bSort and aName < bName))
            end)
        end
    end

    self.categories[id] = categories

    if (membersAmount > 0) then
        local tab = self.navbar:AddTab({
            name = name,
            icon = icon,
            class = 'onyx.ScrollPanel',
            onBuild = function(content)
                self:SetupItemList(content, self.categories[id], color, purchaseFunc, id)

                content.OnRemove = function(panel)
                    if (panel.scrollInitialized) then
                        oldScrollValues[id] = panel.scroll:GetScroll()
                    end
                end

                timer.Simple(engine.TickInterval() * 4, function()
                    if (IsValid(content)) then
                        content.scrollInitialized = true

                        local oldScrollValue = oldScrollValues[id]
                        if (oldScrollValue) then
                            content.scroll:SetScroll(oldScrollValue)
                            content.scroll.Current = oldScrollValue
                            content.canvas.container:SetPos(0, -oldScrollValue)
                        end
                    end
                end)
            end
        })

        tab.ItemType = id

        if (not self.enabledFirst) then
            self.enabledFirst = true
            self.navbar:SelectTab(tab, true)
        end
    end
end

function PANEL:SetupItemList(content, categories, color, purchaseFunc, itemType)
    local convar = convars[itemType]
    for _, category in ipairs(categories) do
        if (convar and category.favorite and not convar:GetBool()) then continue end
        if (#category.members > 0) then
            self:CreateCategory(content, category.name, category.members, color, purchaseFunc, itemType)
        end
    end
end

function PANEL:CreateCategory(container, name, members, color, purchaseFunc, itemType)
    local pnlCategory = container:Add('onyx.Category')
    pnlCategory:Dock(TOP)
    pnlCategory:SetTitle(onyx.utf8.upper(name))
    pnlCategory:SetSpace(0)
    pnlCategory:SetInset(onyx.ScaleTall(10))
    pnlCategory:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    pnlCategory:SetExpanded(true)
    pnlCategory.m_iTextMargin = onyx.ScaleTall(10)
    pnlCategory.m_bSquareCorners = true
    pnlCategory.canvas.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, false, false, true, true)
    end

    local content = pnlCategory:Add('onyx.Grid')
    content:Dock(TOP)
    content:SetTall(0)
    content:SetSpaceX(onyx.ScaleTall(5))
    content:SetSpaceY(content:GetSpaceX())
    content:SetColumnCount(onyx.f4:GetOptionValue('item_columns'))
    content.category = pnlCategory
    content.parentContainer = container

    for _, member in ipairs(members) do
        self:CreateMember(member.item, content, color, purchaseFunc, member.reason, itemType)
    end

    pnlCategory:UpdateInTick()
    pnlCategory:UpdateInTick(10)
    pnlCategory:UpdateInTick(100)
end

function PANEL:CreateMember(member, content, color, purchaseFunc, reason, itemType)
    local model = member.Model
    local price = member.Price
    local level = member.level

    local item = content:Add('onyx.f4.Item')
    item:SetTall(onyx.ScaleTall(55))
    item:SetModel(model)
    item:SetName(member.name)
    item:SetColor(color or Color(200, 200, 200), .1)
    item:SetDesc(rp.FormatMoney(price))
    item:SetDescLabel(L('f4_price'))
    item:SetDescColor(Color(69, 192, 87))
    item.objectIdentifier = (member.ENT or member.Command or member.name)
    if (not member.energy) then
        item:AddFavoriteButton()
    end
    item.Think = function(panel)
        if ((panel.nextThink or 0) > CurTime()) then return end
        if (panel.unavailable) then return end
    
        local balance = LocalPlayer():GetMoney() or 0
        panel.nextThink = CurTime() + .33
        panel:SetDescColor(balance >= price and colorCanAfford or colorCannotAfford)
    end
    item.OnFavoriteStateSwitched = function()
        local navbar = self.navbar
        local activeTab = navbar:GetActiveTab()
        local itemType = activeTab.ItemType
        local allCategories = self.categories[itemType]
        local favCategory = allCategories[1]

        if (favCategory and favCategory.favorite) then
            favCategory.members = onyx.f4:FetchFavoriteObjects(itemType)
        end

        activeTab.content:Remove()
        navbar:SelectTab(activeTab, true)
        activeTab.content:SetAlpha(0)
        activeTab.content:AlphaTo(255, .3)
    end

    if (reason) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(reason)
        item:SetDescLabel('')
        item.unavailable = true
    elseif (level and onyx.f4.GetPlayerLevel(LocalPlayer(), math.huge) < level) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(L('requires_level', {
            level = string.Comma(level)
        }))
        item:SetDescLabel('')
        item.unavailable = true
    end

    item:Import('click')
    item:Import('hovercolor')
    item:SetColorKey('colorBG')
    item:SetColorIdle(colorSecondary)
    item:SetColorHover(colorTertiary)
    item:AddHoverSound()
    item:AddClickEffect()
    item.DoClick = function()
        if (purchaseFunc) then
            purchaseFunc(member)
        end
    end

    item:PositionCamera('center')
end

onyx.gui.Register('onyx.f4.Shop', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--PATH addons/____onyx_hud/lua/onyx/modules/hud/core/cl_icons.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

onyx.wimg.Register( 'hud_microphone', 'https://i.imgur.com/gcM94Fk.png' ) -- 128x128
onyx.wimg.Register( 'hud_chat', 'https://i.imgur.com/q5Lw2qs.png' ) -- 128x128
onyx.wimg.Register( 'hud_connection_lost', 'https://i.imgur.com/EoFpsnf.png' ) -- 128x128

-- 64x64
onyx.wimg.Register( 'hud_wanted', 'https://i.imgur.com/rFyMifb.png' ) 
onyx.wimg.Register( 'hud_license', 'https://i.imgur.com/gltIVYm.png' )
onyx.wimg.Register( 'hud_food', 'https://i.imgur.com/PBZSeVr.png' )
onyx.wimg.Register( 'hud_shield', 'https://i.imgur.com/6Bvc6jX.png' )
onyx.wimg.Register( 'hud_heart', 'https://i.imgur.com/p5Ydzmp.png' )
onyx.wimg.Register( 'hud_lockdown', 'https://i.imgur.com/4K2lTOO.png' )
onyx.wimg.Register( 'hud_arrested', 'https://i.imgur.com/7WVcWRg.png' )

onyx.wimg.Register( 'radial_close', 'https://i.imgur.com/O2fDo4C.png' )
onyx.wimg.Register( 'door_sell', 'https://i.imgur.com/sk1wknE.png' )
onyx.wimg.Register( 'door_title', 'https://i.imgur.com/ShyxozE.png' )
onyx.wimg.Register( 'door_add_user', 'https://i.imgur.com/MMBU6Qg.png' )
onyx.wimg.Register( 'door_remove_user', 'https://i.imgur.com/veLnn9Z.png' )
onyx.wimg.Register( 'door_disable_own', 'https://i.imgur.com/jbItdgJ.png' )
onyx.wimg.Register( 'door_enable_own', 'https://i.imgur.com/B2sTNGW.png' )
onyx.wimg.Register( 'door_own', 'https://i.imgur.com/tCUFyic.png' )
onyx.wimg.Register( 'door_groups', 'https://i.imgur.com/ttokI0C.png' )

--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_timeout.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/08/2024

--]]

local hud = onyx.hud

local L = function( ... ) return onyx.lang:Get( ... ) end
local WIMG_ICON = onyx.wimg.Create( 'hud_connection_lost', 'smooth mips' )
local COLOR_GRAY = Color( 200, 200, 200 )

-- It is mandatory to run this command as soon as possible
RunConsoleCommand( 'cl_timeout', '300' )

local function startFadeAnimation( panel, target, callback )
    panel.animAlpha = panel:GetAlpha() / 255
    
    onyx.anim.Create( panel, 1, {
        index = 1,
        target = { animAlpha = target },
        easing = 'inOutSine',
        think = function( _, panel )
            panel:SetAlpha( panel.animAlpha * 255 )
        end,
        onFinished = function( _, panel )
            if ( callback ) then
                callback( panel )
            end
        end
    } )
end

local function createPanel()
    local scrW, scrH = ScrW(), ScrH()
    local x0, y0 = scrW * .5, scrH * .5
    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local space = hud.ScaleTall( 30 )

    local btnWide, btnTall = hud.ScaleWide( 200 ), hud.ScaleTall( 30 )
    local btnY = scrH * .75 - btnTall * .5

    local textTitle = L( 'timeout_title' )
    local textInfo = L( 'timeout_info' )
    local textStatus = L( 'timeout_status' )
    local fontInfo = hud.fonts.Medium

    surface.SetFont( fontInfo )
    local textInfoW, textInfoH = surface.GetTextSize( textInfo )
    local textStatusW, textStatusH = surface.GetTextSize( textStatus )

    local frame = vgui.Create( 'Panel' )
    onyx.hud.TimeoutPanel = frame

    frame:SetSize( ScrW(), ScrH() )
    frame:SetDrawOnTop( true )
    frame:SetAlpha( 0 )
    frame.statusFraction = 0
    frame.reconnectTime = 0
    frame.Paint = function( panel, w, h )
        if ( panel.reconnectTime > 0 and panel.reconnectTime <= SysTime() ) then
            RunConsoleCommand( 'retry' )
        end
        
        local alpha = panel:GetAlpha() / 255
        local iconSize = hud.ScaleTall( 128 )
        
        if ( alpha > 0) then
            onyx.DrawBlurExpensive( panel, 6 * alpha )
        end

        surface.SetDrawColor( ColorAlpha( colors.primary, theme.isDark and 230 or 150 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.SimpleText( textTitle, hud.fonts.BigBold, x0, y0, colors.textPrimary, 1, 4 )

        WIMG_ICON:DrawRotated( x0, h * .4, iconSize, iconSize, 0, colors.textPrimary )
    end
    frame.OnRemove = function()
        timer.Remove( 'onyx.hud.TimeoutShowDetails' )
    end
    frame.Close = function( panel )
        if ( not panel.closed ) then
            panel.closed = true
            startFadeAnimation( panel, 0, function( this )
                this:Remove()
            end )
        end
    end

    local lblDesc = frame:Add( 'Panel' )
    lblDesc:SetTall( math.max( textInfoH, textStatusH ) )
    lblDesc:SetWide( scrW )
    lblDesc:SetPos( 0, y0 )
    lblDesc.Paint = function( panel, w, h )
        local statusFraction = frame.statusFraction
        local infoFraction = 1 - statusFraction
        local timeLeft = math.Round( math.max( 0, frame.reconnectTime - SysTime() ) )
        local prevAlpha = surface.GetAlphaMultiplier()

        surface.SetAlphaMultiplier( math.min( infoFraction, prevAlpha ) )
            onyx.hud.DrawCheapText( textInfo, fontInfo, w * .5 - textInfoW * .5, h * statusFraction, colors.textSecondary )
        surface.SetAlphaMultiplier( math.min( statusFraction, prevAlpha ) )
            draw.SimpleText( textStatus:format( timeLeft ), fontInfo, w * .5, -h * infoFraction, colors.negative, 1, 0 )
        surface.SetAlphaMultiplier( prevAlpha )
    end

    local btnReconnect = frame:Add( 'onyx.Button' )
    btnReconnect:SetText( L( 'reconnect_u' ) )
    btnReconnect:SetFont( hud.fonts.Tiny )
    btnReconnect:SetTextColor( colors.textPrimary )
    btnReconnect:SetColorIdle( colors.secondary )
    btnReconnect:SetColorHover( colors.tertiary )
    btnReconnect:SetSize( btnWide, btnTall )
    btnReconnect:SetPos( x0 - btnWide - space * 0.5, btnY )
    btnReconnect:Hide()
    btnReconnect.DoClick = function() RunConsoleCommand( 'retry' ) end

    local btnDisconnect = frame:Add( 'onyx.Button' )
    btnDisconnect:SetText( L( 'disconnect_u' ) )
    btnDisconnect:SetFont( hud.fonts.Tiny )
    btnDisconnect:SetTextColor( colors.textPrimary )
    btnDisconnect:SetColorIdle( colors.secondary )
    btnDisconnect:SetColorHover( colors.tertiary )
    btnDisconnect:SetSize( btnWide, btnTall )
    btnDisconnect:SetPos( x0 + space * 0.5, btnY )
    btnDisconnect:Hide()
    btnDisconnect.DoClick = function() RunConsoleCommand( 'disconnect' ) end

    startFadeAnimation( frame, 1 )

    timer.Create( 'onyx.hud.TimeoutShowDetails', 3, 1, function()
        if ( IsValid( frame ) ) then
            frame.reconnectTime = SysTime() + hud:GetOptionValue( 'timeout' )
            frame:MakePopup()
        
            onyx.anim.Create( frame, 1, {
                index = 2,
                target = { statusFraction = 1 },
                easing = 'outQuad',
                think = function( _, panel )
                    if ( IsValid( btnDisconnect ) and IsValid( btnReconnect ) ) then
                        local alpha = panel.statusFraction * 255

                        btnReconnect:SetVisible( true )
                        btnReconnect:SetAlpha( alpha )

                        btnDisconnect:SetVisible( true )
                        btnDisconnect:SetAlpha( alpha )
                    end
                end
            } )
        end
    end )
end

timer.Create( 'onyx.hud.TimeoutController', 1, 0, function()
    local isTimingOut, lastPing = GetTimeoutInfo()
    local panel = onyx.hud.TimeoutPanel
    local isValid = IsValid( panel )

    if ( isTimingOut ) then
        if ( isValid ) then
        else
            createPanel()
        end
    elseif ( isValid ) then
        panel:Close()
    end
end )

concommand.Add( 'onyx_hud_test_timeout', function( ply, _, args )
    if ( ply:IsSuperAdmin() ) then
        local freezeDuration = tonumber( args[ 1 ] ) or 10
        local resetTime = SysTime() + freezeDuration
        local hookName = 'onyx.hud.TimeoutTest'

        ply:ConCommand( 'net_fakeloss 100' )

        hook.Add( 'DrawOverlay', hookName, function()
            if ( resetTime <= SysTime() ) then
                hook.Remove( 'DrawOverlay', hookName )
                ply:ConCommand( 'net_fakeloss 0' )
            end
        end )
    end
end )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/ui/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local COLOR_PRIMARY = onyx:Config( 'colors.primary' )
local COLOR_SECONDARY = onyx:Config( 'colors.secondary' )
local COLOR_TERTIARY = onyx:Config( 'colors.tertiary' )
local COLOR_ACCENT = onyx:Config( 'colors.accent' )
local COLOR_GRAY = Color( 150, 150, 150)
local COLOR_BUTTON_HOVER = onyx.LerpColor( .5, COLOR_TERTIARY, COLOR_ACCENT )
local FONT_NAME = onyx.Font( 'Comfortaa Bold@16' )
local FONT_DESC = onyx.Font( 'Comfortaa@14' )
local FONT_BUTTON = onyx.Font( 'Comfortaa Bold@32' )

local PANEL = {}

function PANEL:Init()
    self.list = self:Add( 'onyx.ScrollPanel' )
    self.list:Dock( FILL )

    self.grid = self.list:Add( 'onyx.Grid' )
    self.grid:Dock( FILL )
    self.grid:SetColumnCount( 2 )
    self.grid:SetSpace( onyx.ScaleTall( 5 ) )

    self:LoadOptions()
end

function PANEL:LoadOptions()
    if ( not onyx.hud:GetOptionValue( 'restrict_themes' )) then
        local themeOptions = {}

        for id, theme in pairs( onyx.hud.themes ) do
            table.insert( themeOptions, {
                name = onyx.lang:Get( string.format( 'hud.theme.%s.name', id ) ),
                key = id
            } )
        end

        self:AddOption( 'combo', 'theme', 'cl_onyx_hud_theme_id', {
            options = themeOptions
        } )
    end

    self:AddOption( 'int', 'scale', 'cl_onyx_hud_scale' )
    self:AddOption( 'int', 'roundness', 'cl_onyx_hud_roundness', { step = 4 } )
    self:AddOption( 'int', 'margin', 'cl_onyx_hud_screen_padding', { step = 5 } )
    self:AddOption( 'int', '3d2d_max_details', 'cl_onyx_hud_3d2d_max_details', { step = 1 } )

    self:AddOption( 'bool', 'compact', 'cl_onyx_hud_compact' )
    self:AddOption( 'bool', 'speedometer_blur', 'cl_onyx_hud_speedometer_blur' )
    self:AddOption( 'bool', 'wpnsel_sounds', 'cl_onyx_hud_wpnsel_sounds' )

    if ( onyx.hud:GetOptionValue( 'main_avatar_mode' ) == 1 ) then
        self:AddOption( 'bool', 'icons_3d', 'cl_onyx_hud_3d_models' )
    end
end

function PANEL:AddOption( optionType, id, convarName, data )
    local text = onyx.lang:Get( 'hud.' .. id .. '.name' )
    local desc = onyx.lang:Get( 'hud.' .. id .. '.desc' )
    local convarObject = GetConVar( convarName )
    local data = data or {}
    local field = self:CreateField( text, desc )
    local height = field:GetTall() - field.padding * 2
    
    if ( optionType == 'bool' ) then
        field.centerChild = false

        field.togglerContainer = field:Add('Panel')
        field.togglerContainer:SetWide( onyx.ScaleWide( 50 ) )
        field.togglerContainer:Dock( RIGHT )
        field.togglerContainer.PerformLayout = function( panel, w, h )
            local child = panel:GetChild( 0 )
            if ( IsValid( child ) ) then
                child:SetTall( child:GetWide() * .5 )
                child:Center()
            end
        end

        field.toggler = field.togglerContainer:Add('onyx.Toggler')
        field.toggler:SetBackgroundColor( COLOR_TERTIARY )
        field.toggler:SetChecked( convarObject:GetBool(), true )
        field.toggler.OnChange = function( panel, newBool )
            convarObject:SetBool( newBool )
        end
    elseif ( optionType == 'combo' ) then
        local value = convarObject:GetString()
        
        local combo = field:Add( 'onyx.ComboBox' )
        combo:SetWide( onyx.ScaleWide( 175 ) )
        combo:Dock( RIGHT )
        combo.OnSelect = function( panel, index, text, data )
            convarObject:SetString( data )
        end

        for i, opt in ipairs( data.options or {} ) do
            local key = opt.key

            combo:AddOption( opt.name, key )

            if ( key == value ) then
                combo:ChooseOptionID( i )
            end
        end
    elseif ( optionType == 'int' ) then
        local lblValue
        local min = convarObject:GetMin()
        local max = convarObject:GetMax()
        local step = data.step or 5

        local btnAdd = field:Add( 'DButton' )
        btnAdd:SetText( '' )
        btnAdd:SetWide( height )
        btnAdd:Dock( RIGHT )
        btnAdd.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, false, true, false, true )
            draw.SimpleText( '+', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnAdd.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() + step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end

        lblValue = field:Add( 'onyx.Label' )
        lblValue:SetWide( onyx.ScaleWide( 50 ) )
        lblValue:SetContentAlignment( 5 )
        lblValue:SetText( convarObject:GetInt() )
        lblValue:Dock( RIGHT )
        lblValue:Font( 'Comfortaa SemiBold@20' )
        lblValue.Paint = function( panel, w, h )
            draw.RoundedBox( 0, 0, 0, w, h, COLOR_PRIMARY )
        end

        local btnDecrease = field:Add( 'DButton' )
        btnDecrease:SetText( '' )
        btnDecrease:SetWide( height )
        btnDecrease:Dock( RIGHT )
        btnDecrease.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, true, false, true )
            draw.SimpleText( '-', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnDecrease.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() - step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end
    end
end

function PANEL:CreateField( text, desc )
    local padding = onyx.ScaleTall(7.5)

    local field = self.grid:Add( 'DPanel' )
    field:SetTall( onyx.ScaleTall(45) )
    field:DockPadding( padding, padding, padding, padding )
    field.centerChild = true
    field.padding = padding
    field.Paint = function( p, w, h )
        draw.RoundedBox( 8, 0, 0, w, h, COLOR_SECONDARY )
        draw.SimpleText( text, FONT_NAME, padding, h * .5, COLOR_ACCENT, 0, 4 )
        draw.SimpleText( desc, FONT_DESC, padding, h * .5, COLOR_GRAY, 0, 0 )
    end
    field.PerformLayout = function( panel, w, h )
        local child = panel:GetChild( 0 )
        if ( IsValid( child ) and panel.centerChild ) then
            
        end
    end

    return field
end

onyx.gui.Register( 'onyx.hud.ClientSettings', PANEL )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

onyx:Addon('scoreboard', {
    color = Color(65, 162, 211),
    author = 'tochnonement',
    version = '1.1.2',
    licensee = '76561198843434426'
})

----------------------------------------------------------------

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/scoreboard/languages/')
onyx.IncludeFolder('onyx/modules/scoreboard/core/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/cfg/', true)
onyx.IncludeFolder('onyx/modules/scoreboard/ui/')

onyx.scoreboard:Print('Finished loading.')
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copied to clipboard'
LANG['scoreboard_search'] = 'Search... (Name/SteamID)'
LANG['you'] = 'You'
LANG['friend'] = 'Friend'
LANG['addon_return_u'] = 'RETURN'

-- Columns
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Job'
LANG['scoreboard_col_money'] = 'Money'
LANG['scoreboard_col_rank'] = 'Rank'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Playtime'
LANG['scoreboard_col_health'] = 'Health'
LANG['scoreboard_col_level'] = 'Level'
LANG['scoreboard_col_none'] = 'None'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Badges'
LANG['scoreboard_col_faction'] = 'Faction'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Default'
LANG['scoreboard_eff_glow'] = 'Glow'
LANG['scoreboard_eff_rainbow'] = 'Rainbow'
LANG['scoreboard_eff_scanning_vertical'] = 'Scanning (Vertical)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Scanning (Horizontal)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Invert Color)'
LANG['scoreboard_eff_wavy_dual'] = 'Wavy (Dual Color)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Open Profile'
LANG['scoreboard_btn_freeze'] = 'Freeze'
LANG['scoreboard_btn_goto'] = 'Goto'
LANG['scoreboard_btn_bring'] = 'Bring'
LANG['scoreboard_btn_return'] = 'Return'
LANG['scoreboard_btn_respawn'] = 'Respawn'
LANG['scoreboard_btn_slay'] = 'Slay'
LANG['scoreboard_btn_spectate'] = 'Spectate'

-- Words
LANG['rank_id'] = 'Rank Identifier'
LANG['name'] = 'Name'
LANG['effect'] = 'Effect'
LANG['color'] = 'Color'
LANG['preview'] = 'Preview'
LANG['creation'] = 'Creation'
LANG['save'] = 'Save'
LANG['dead'] = 'Dead'
LANG['create_new'] = 'Create New'
LANG['column'] = 'Column'

-- Settings
LANG['addon_settings_u'] = 'SETTINGS'
LANG['scoreboard_ranks_u'] = 'RANKS'
LANG['scoreboard_columns_u'] = 'COLUMNS'

LANG['scoreboard.title.name'] = 'Title'
LANG['scoreboard.title.desc'] = 'Input the title for the frame'

LANG['scoreboard.group_teams.name'] = 'Group Teams'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Group teams by job categories'

LANG['scoreboard.colored_players.name'] = 'Colorized Gradient'
LANG['scoreboard.colored_players.desc'] = 'Show colorized gradient on player line'

LANG['scoreboard.blur.name'] = 'Blur Theme'
LANG['scoreboard.blur.desc'] = 'Enable blur theme'

LANG['scoreboard.scale.name'] = 'Frame Size Scale'
LANG['scoreboard.scale.desc'] = 'Scale the scoreboard\'s frame size'

onyx.lang:AddPhrases('english', LANG)
--PATH addons/_outfitter/lua/includes/modules/gmaparse.lua:
local Tag='gmaparse'

module(Tag,package.seeall)

-- Format: https://github.com/garrynewman/gmad/blob/master/include/AddonReader.h

local GMA = {}
local _M = {__index = GMA,__tostring=function(self) return "GMAD Parser" end}
function Parser(f)
	if isstring(f) then
		f = file.Open(f,'rb','GAME')
	end
	
	
	local hdr = f:Read(4)
	if hdr~='GMAD' then
		return nil,"notgma"
	end
	
	local version = string.byte(f:Read(1))
	
	if version>3 then
		return nil,'newformat'
	end
	
	local T = {file = f, _iOffset=0,version = version}
	
	return setmetatable(T,_M)
	
end

function GMA:IsValid()
	return self.file and self:ParseHeader() and true or false
end

function GMA:GetFile()
	return self.file
end

function GMA:Close()
	local f = self.file
	f:Close()
	self.file = false
end

function GMA:_ParseFail(reason)
	self.parsed_header = false
	self.parse_error = reason or "?"
	self.error = "Parsing failed: "..tostring(reason)
	return nil,reason
end

function GMA:GetError()
	return self.error
end

function GMA:ParseHeader()
	if self.parsed_header~=nil then
		return self.parsed_header
	end
	self.parsed_header = false
	
	local f = self.file
	local res = self
	
	local sid = f:Read(8) -- TODO
	res.steamid = sid
	
	local ts = f:Read(8) -- TODO
	res.timestamp = ts

	local strcontent = {}
	if self.version>1 then
		for i=1,1024 do
			local s = f:ReadString(128)
			if not s or s=="" then break end
			strcontent[#strcontent+1]=s
		end
	end
	res.strcontent = strcontent
	
	-- TODO
	local name		= f:ReadString()
	local desc		= f:ReadString() -- TODO json
	local author	= f:ReadString()

	res.name,res.desc,res.author = name,desc,author
	
	-- TODO: unused?
	local addonver = f:Read(4)
	res.addonver = addonver
	
	res.file_enum = f:Tell()
	
	return true
	
end


local entry = {}
GMA.tmp_entry = entry

function GMA:EnumFiles(reset)
	local f = self.file
	
	if reset or self.parsed_filelist==nil then
		self.parsed_filelist = false
		self._iOffset = 0
		f:Seek(self.file_enum)
	end
	assert(not self.parsed_filelist)
	
	local readtype = f:Read(4) -- uint
	
	if readtype==nil then error"offset failure" end
	
	if readtype=="\0\0\0\0" then
		self.fileblock = f:Tell()
		self.parsed_filelist = true
		return false
	else
		entry.readtype = from_u_int(readtype,true)
	end
	
	entry.Name		= f:ReadString(64) or ""
	
	entry.Size		= from_u_int(f:Read(4) or "\0",true) -- long long
	
	if f:Read(4)~='\0\0\0\0' then
		return self:_ParseFail'4gbfile'
	end
	
	if entry.Size>1024*1024*256 then
		return self:_ParseFail'bigsize'
	end
	entry.CRC		= from_u_int(f:Read(4) or "\0",true) -- unsigned int
	
	entry.Offset	= self._iOffset
	self._iOffset = self._iOffset + entry.Size
		
	return entry
	
end

function GMA:SeekToFileOffset(offset)
	
	assert(self.parsed_filelist)
	
	if istable(offset) then
		offset = offset.Offset
	end
	
	local f = self.file
	local off = self.fileblock + offset
	
	if off>f:Size() then print("offset too big",off-f:Size()) return false end
	
	f:Seek(off)
	return f:Tell()==off
	
end

function GMA:ReadEntry(entry,fast)
	local offset = entry.Offset
	local size = entry.Size
	
	local seekok = self:SeekToFileOffset(offset)
	if not seekok then return nil,"seekfail" end
	
	local data = self.file:Read(size)
	if not data then return nil,"nodata" end
	if #data~=size then return nil,"eof" end
	if not fast and tostring(util.CRC(data))~=tostring(entry.CRC) then return nil,"crc" end
	
	return data
	
end

--[[ -- test
local fp ="cache/workshop/"
local fn = '391042736548413304.cache'

local fpath = fp..fn
local f = file.Open(fpath,'rb','MOD')

local gma,err = Parser(f)
if not gma then print("Parser init fail",err) return end

local ok ,err = gma:ParseHeader()
if not ok then print("header parse failed",err) return end

local mdls = {}
for i=1,8192 do
	local entry = gma:EnumFiles()
	if not entry then break end
	if entry.Name:find'%.mdl$' then
		mdls[#mdls+1] = table.Copy(entry)
	end
end

for k,entry in next,mdls do
	print("Entry: '"..entry.Name.."'",string.NiceSize(entry.Size))
	local dat,err = gma:ReadEntry(entry)
	if not dat then print("","fail",err) continue end
	print("Data: ",#dat,('%q'):format(dat:sub(1,10)))
end
print("GMAERR",gma:GetError())
PrintTable(gma)
PrintTable(gma.tmp_entry)
gma:Close()

	
--]]

return _M

--PATH addons/_outfitter/lua/includes/modules/isdormant.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local Tag="isdormant"

	
--[[
hook.Add("HUDPaint",Tag,function()
	local x,y=128,128
	surface.SetFont"BudgetLabel"
	
	local t=player.InPVS()
	
	local sw = ScrW()
	
	for i,pl in next, player.GetAll() do
		
		local txt=pl:Name()
		local tw,th = surface.GetTextSize(txt)
		local tx,ty=sw-tw-16,y+th*i
		
		surface.SetTextPos(tx,ty)
		if pl:InPVS() then
			surface.SetTextColor(255,244,244,111)
		else
			surface.SetTextColor(111,133,111,155)
		end
		surface.DrawText(txt)
	
	end
	
end)]]

local fn=0
local function Think()
	fn = fn + 1
end

hook.Add("Think",Tag,Think)
local t={}

--for k,v in next,player.GetAll() do if not v:IsDormant() then t[v]=fn+1 end end

local t2={}
function player.InPVS()
	local i=0
	for pl,pvsfn in next,t do
		if pvsfn and pvsfn < fn then
			i=i+1
			t2[i]=pl
		end
end

	for i=i+1,#t2 do
		t2[i]=nil
	end

	return t2
end

local Player=FindMetaTable"Player"
function Player:InPVS()
	local t = t[self]
	return  t and t < fn
end

local NaN = 0/0
hook.Add("NotifyShouldTransmit",Tag,function(pl,here)
	if pl:IsPlayer() and pl~=LocalPlayer() then
		t[pl]=here and fn+1 or NaN
	end
end)

hook.Add("EntityRemoved",Tag,function(pl)
	if pl:IsPlayer() then
		t[pl]=nil
	end
end)



-- For entities
--TODO: Make one for weapons too

local Entity = FindMetaTable "Entity"
local Tag = 'EntityShouldTransmit'
local function OnShouldTransmit(ent, should, special, entlist)
	--TODO: remove
	Msg("[ShouldTransmit] ")
	print(ent, should and "IN" or "OUT", should and special and "FIRST" or (not should and special and "LAST") or "")
	local f = ent.OnShouldTransmit
	if not f then
		return
	end

	return f(ent, should, firstlast, entlist)
end

local hooked = {  }
function ents.GetTransmitList()
	return hooked
end

function ents.HookShouldTransmit(class)
	assert(class and #class > 0 and class ~= "player", "invalid class")
	local tbl = scripted_ents.GetStored(class)
	assert(tbl, "class not found (is it an engine class?)")
	local t = hooked[class]
	if not t then
		t = {  }
		for k, v in next, ents.FindByClass(class) do
			if not v:IsDormant() then
				t[v] = true
				print("HOOKING", v)
			end

		end

		hooked[class] = t
	end

	return t
end

function Entity:HookShouldTransmit()
	ents.HookShouldTransmit(self:GetClass())
end

local function assert(ok,...)
	if not ok then
		ErrorNoHalt(addn(...))
	end

	return ok
end

local prevclass
hook.Add("NotifyShouldTransmit", Tag, function(ent, inside)
	local class = ent:GetClass()
	local entlist = hooked[class]
	if not entlist then
		return
	end

	if inside then
		local is_first = not next(entlist)
		entlist[ent] = true
		OnShouldTransmit(ent, true, is_first, entlist)
	else
		assert(entlist[ent], ent, "missing")
		entlist[ent] = nil
		local is_last = not next(entlist)
		OnShouldTransmit(ent, false, is_last, entlist)
	end

end)
hook.Add("EntityRemoved", Tag, function(ent)
	local class = ent:GetClass()
	local entlist = hooked[class]
	if not entlist then
		return
	end

	entlist[ent] = nil
	local is_last = not next(entlist)
	OnShouldTransmit(ent, false, is_last, entlist)
end)

--[[
function ENT:Initialize()
	self:HookShouldTransmit()
end

function ENT:OnShouldTransmit(transmitting, firstlast, entlist)
	if not firstlast then
		return
	end

	if transmitting then
		hook.Add("Think", "myclass", function()
			for ent, _ in next, entlist do
			end

		end)
	else
		hook.Remove("Think", "myclass")
	end

end
--]]


--PATH addons/__main/lua/autorun/p250_meh_autorun.lua:
if GetConVar( "DebugM9K" ) == nil then CreateConVar( "DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much." ) end
if GetConVar( "M9KWeaponStrip" ) == nil then
	CreateConVar( "M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false" )
end

if GetConVar( "M9KDisablePenetration" ) == nil then
	CreateConVar( "M9KDisablePenetration", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false" )
end

if GetConVar( "M9KDynamicRecoil" ) == nil then
	CreateConVar( "M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false" )
end

if GetConVar( "M9KAmmoDetonation" ) == nil then
	CreateConVar( "M9KAmmoDetonation", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false." )
end

if GetConVar( "M9KDamageMultiplier" ) == nil then
	CreateConVar( "M9KDamageMultiplier", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Multiplier for M9K bullet damage." )
end

if GetConVar( "M9KDefaultClip" ) == nil then
	CreateConVar( "M9KDefaultClip", "-1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "How many clips will a weapon spawn with? Negative reverts to default values." )
end

if GetConVar( "M9KUniqueSlots" ) == nil then
	CreateConVar( "M9KUniqueSlots", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required." )
end

if CLIENT and GetConVar( "M9KGasEffect" ) == nil then
	CreateClientConVar( "M9KGasEffect", "1", true, true )
end

sound.Add( {
	name = "p250_mehndifire",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/p228/p250mehndi-1.wav"
} )

m9knpw = {}
table.insert( m9knpw, "m9k_davy_crockett_explo" )
table.insert( m9knpw, "m9k_gdcwa_matador_90mm" )
table.insert( m9knpw, "m9k_gdcwa_rpg_heat" )
table.insert( m9knpw, "m9k_improvised_explosive" )
table.insert( m9knpw, "m9k_launched_davycrockett" )
table.insert( m9knpw, "m9k_launched_ex41" )
table.insert( m9knpw, "m9k_launched_m79" )
table.insert( m9knpw, "m9k_m202_rocket" )
table.insert( m9knpw, "m9k_mad_c4" )
table.insert( m9knpw, "m9k_milkor_nade" )
table.insert( m9knpw, "m9k_nervegasnade" )
table.insert( m9knpw, "m9k_nitro_vapor" )
table.insert( m9knpw, "m9k_oribital_cannon" )
table.insert( m9knpw, "m9k_poison_parent" )
table.insert( m9knpw, "m9k_proxy" )
table.insert( m9knpw, "m9k_released_poison" )
table.insert( m9knpw, "m9k_sent_nuke_radiation" )
table.insert( m9knpw, "m9k_thrown_harpoon" )
table.insert( m9knpw, "m9k_thrown_knife" )
table.insert( m9knpw, "m9k_thrown_m61" )
table.insert( m9knpw, "m9k_thrown_nitrox" )
table.insert( m9knpw, "m9k_thrown_spec_knife" )
table.insert( m9knpw, "m9k_thrown_sticky_grenade" )
table.insert( m9knpw, "bb_dod_bazooka_rocket" )
table.insert( m9knpw, "bb_dod_panzershreck_rocket" )
table.insert( m9knpw, "bb_garand_riflenade" )
table.insert( m9knpw, "bb_k98_riflenade" )
table.insert( m9knpw, "bb_planted_dod_tnt" )
table.insert( m9knpw, "bb_thrownalliedfrag" )
table.insert( m9knpw, "bb_thrownaxisfrag" )
table.insert( m9knpw, "bb_thrownsmoke_axis" )
table.insert( m9knpw, "bb_thrownaxisfrag" )
table.insert( m9knpw, "bb_planted_alt_c4" )
table.insert( m9knpw, "bb_planted_css_c4" )
table.insert( m9knpw, "bb_throwncssfrag" )
table.insert( m9knpw, "bb_throwncsssmoke" )
table.insert( m9knpw, "m9k_ammo_40mm" )
table.insert( m9knpw, "m9k_ammo_40mm_single" )
table.insert( m9knpw, "m9k_ammo_357" )
table.insert( m9knpw, "m9k_ammo_ar2" )
table.insert( m9knpw, "m9k_ammo_buckshot" )
table.insert( m9knpw, "m9k_ammo_c4" )
table.insert( m9knpw, "m9k_ammo_frags" )
table.insert( m9knpw, "m9k_ammo_ieds" )
table.insert( m9knpw, "m9k_ammo_nervegas" )
table.insert( m9knpw, "m9k_ammo_nuke" )
table.insert( m9knpw, "m9k_ammo_pistol" )
table.insert( m9knpw, "m9k_ammo_proxmines" )
table.insert( m9knpw, "m9k_ammo_rockets" )
table.insert( m9knpw, "m9k_ammo_smg" )
table.insert( m9knpw, "m9k_ammo_sniper_rounds" )
table.insert( m9knpw, "m9k_ammo_stickynades" )
table.insert( m9knpw, "m9k_ammo_winchester" )
function PocketM9KWeapons( _, wep )
	if not IsValid( wep ) then return end
	class = wep:GetClass()
	m9knopocket = false
	for _, v in ipairs( m9knpw ) do
		if v == class then
			m9knopocket = true
			break
		end
	end

	if m9knopocket then return false end
	--goddammit i hate darkrp
end

hook.Add( "canPocket", "PocketM9KWeapons", PocketM9KWeapons )
--PATH addons/_pcasino/lua/perfectcasino/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont("pCasino.Header.Static", {
	font = "Roboto",
	size = 35,
})
surface.CreateFont("pCasino.Title.Static", {
	font = "Roboto",
	size = 36,
})
surface.CreateFont("pCasino.Entity.Bid", {
	font = "Roboto",
	size = 40,
})
surface.CreateFont("pCasino.Entity.Arrows", {
	font = "Roboto",
	size = 60,
})
surface.CreateFont("pCasino.SubTitle.Static", {
	font = "Roboto",
	size = 24,
})
surface.CreateFont("pCasino.Main.Static", {
	font = "Roboto",
	size = 28,
})
surface.CreateFont("pCasino.Nav.Static", {
	font = "Roboto",
	size = 25,
})
surface.CreateFont("pCasino.Textbox.Static", {
	font = "Roboto",
	size = 20,
	weight = 500,
})
surface.CreateFont("pCasino.Button.Micro", {
	font = "Roboto",
	size = 15,
	weight = 500,
})
--PATH addons/_pcasino/lua/perfectcasino/core/sh_cooldown.lua:
-- A cooldown lib I stole from my community's lib
PerfectCasino.Cooldown.Timers = PerfectCasino.Cooldown.Timers or {}

function PerfectCasino.Cooldown.Check(id, time, ply)
	if not id then return true end
	if not time then return true end

	if not PerfectCasino.Cooldown.Timers[id] then
		PerfectCasino.Cooldown.Timers[id] = {}
		PerfectCasino.Cooldown.Timers[id].global = 0
	end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then
			PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
		end

		if PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = CurTime() + time

		return false
	else
		if PerfectCasino.Cooldown.Timers[id].global > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id].global = CurTime() + time

		return false
	end
end

function PerfectCasino.Cooldown.Get(id, ply)
	if not id then return 0 end
	if not time then return 0 end

	if not PerfectCasino.Cooldown.Timers[id] then return 0 end

	-- The correct returns
	if ply and PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] end
	if not ply and PerfectCasino.Cooldown.Timers[id].global then return PerfectCasino.Cooldown.Timers[id].global end

	-- Failsafe
	return 0
end


function PerfectCasino.Cooldown.Reset(id, ply)
	if not id then return end

	if not PerfectCasino.Cooldown.Timers[id] then return end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return end
		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
	else
		PerfectCasino.Cooldown.Timers[id].global = 0
	end
end
--PATH addons/____sam/lua/sam/menu/sh_init.lua:
if SAM_LOADED then return end

require("sui")

sam.command.new("menu")
	:Help("Open admin mod menu")
	:MenuHide()
	:DisableNotify()
	:OnExecute(function(ply)
		sam.netstream.Start(ply, "OpenMenu")
	end)
:End()

if CLIENT then
	sam.netstream.Hook("OpenMenu", function()
		sam.menu.open_menu()
	end)
end

if SERVER then
	for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
		sam.load_file("sam/menu/tabs/" .. f)
	end
end
--PATH addons/____sui/lua/sui/libs/tdlib/cl_tdlib.lua:
--[[
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
]]

local pairs = pairs
local ipairs = ipairs
local Color = Color
local render = render
local SysTime = SysTime
local Lerp, RealFrameTime = Lerp, RealFrameTime
local RoundedBox, RoundedBoxEx, NoTexture = draw.RoundedBox, draw.RoundedBoxEx, draw.NoTexture
local SetDrawColor, DrawRect = surface.SetDrawColor, surface.DrawRect
local DrawPoly = surface.DrawPoly
local sui = sui

local Panel = FindMetaTable("Panel")

--[[
	Constants
]]
local BLUR = CreateMaterial("SUI.TDLib.Blur", "gmodscreenspace", {
	["$basetexture"] = "_rt_fullframefb",
	["$blur"] = (1 / 3) * 7,
})

local COL_WHITE_1 = Color(255, 255, 255)
local COL_WHITE_2 = Color(255, 255, 255, 30)

--[[
	credits to http://slabode.exofire.net/circle_draw.shtml
]]
local calculate_circle do
	local cos = math.cos
	local sin = math.sin
	local round = math.Round
	local sqrt = math.sqrt
	local pi = math.pi
	calculate_circle = function(circle, x_centre, y_centre, r)
		if circle.x == x_centre and circle.y == y_centre and circle.r == r then return end

		local step = (2 * pi) / round(6 * sqrt(r))

		local i = 0
		for theta = 2 * pi, 0, -step do
			local x = x_centre + r * cos(theta)
			local y = y_centre - r * sin(theta)
			i = i + 1
			circle[i] = {
				x = x,
				y = y
			}
		end

		for i = i + 1, #circle do
			circle[i] = nil
		end

		circle.x = x_centre
		circle.y = y_centre
		circle.r = r
	end
end

--[[
void DrawArc(float cx, float cy, float r, float start_angle, float arc_angle, int num_segments)
{
	float theta = arc_angle / float(num_segments - 1);//theta is now calculated from the arc angle instead, the - 1 bit comes from the fact that the arc is open

	float tangetial_factor = tanf(theta);

	float radial_factor = cosf(theta);


	float x = r * cosf(start_angle);//we now start at the start angle
	float y = r * sinf(start_angle);

	glBegin(GL_LINE_STRIP);//since the arc is not a closed curve, this is a strip now
	for(int ii = 0; ii < num_segments; ii++)
	{
		glVertex2f(x + cx, y + cy);

		float tx = -y;
		float ty = x;

		x += tx * tangetial_factor;
		y += ty * tangetial_factor;

		x *= radial_factor;
		y *= radial_factor;
	}
	glEnd();
}
]]

local copy_color = function(color)
	return Color(color.r, color.g, color.b, color.a)
end

local color_alpha = function(color, a)
	color.a = a
	return color
end

--[[
	Collection of various utilities
]]

local TDLibUtil = {}

function TDLibUtil.DrawCircle(circle, x, y, r, color)
	calculate_circle(circle, x, y, r)

	SetDrawColor(color)
	NoTexture()
	DrawPoly(circle)
end
local DrawCircle = TDLibUtil.DrawCircle

do
	local SetMaterial = surface.SetMaterial
	local UpdateScreenEffectTexture, DrawTexturedRect, SetScissorRect = render.UpdateScreenEffectTexture, surface.DrawTexturedRect, render.SetScissorRect

	local scrW, scrH = ScrW(), ScrH()
	hook.Add("OnScreenSizeChanged", "SUI.TDLib", function()
		scrW, scrH = ScrW(), ScrH()
	end)

	function TDLibUtil.BlurPanel(s)
		local x, y = s:LocalToScreen(0, 0)

		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		for i = 1, 2 do
			UpdateScreenEffectTexture()
			DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end

	function TDLibUtil.DrawBlur(x, y, w, h)
		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		SetScissorRect(x, y, x + w, y + h, true)
			for i = 1, 2 do
				UpdateScreenEffectTexture()
				DrawTexturedRect(-1, -1, scrW, scrH)
			end
		SetScissorRect(0, 0, 0, 0, false)
	end
end

local LibClasses = {}

do
	local on_funcs = {}

	function LibClasses:On(name, func)
		local old_func = self[name]

		if not old_func then
			self[name] = func
			return self
		end

		local name_2 = name .. "_funcs"

		-- we gotta avoid creating 13535035 closures
		if not on_funcs[name] then
			on_funcs[name] = function(s, a1, a2, a3, a4)
				local funcs = s[name_2]
				local i, n = 0, #funcs
				::loop::
				i = i + 1
				if i <= n then
					funcs[i](s, a1, a2, a3, a4)
					goto loop
				end
			end
		end

		if not self[name_2] then
			self[name] = on_funcs[name]
			self[name_2] = {
				old_func,
				func
			}
		else
			table.insert(self[name_2], func)
		end

		return self
	end
end

do
	local UnPredictedCurTime = UnPredictedCurTime

	local transition_func = function(s)
		local transitions = s.transitions
		local i, n = 0, #transitions
		::loop::
		i = i + 1

		if i <= n then
			local v = transitions[i]
			local name = v.name
			local v2 = s[name]
			if v.func(s) then
				if v.start_0 then
					v.start_1, v.start_0 = UnPredictedCurTime(), nil
				end

				if v2 ~= 1 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_1) / v.time, v2, 1)
				end
			else
				if v.start_1 then
					v.start_0, v.start_1 = UnPredictedCurTime(), nil
				end

				if v2 ~= 0 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_0) / v.time, v2, 0)
				end
			end

			goto loop
		end
	end

	function LibClasses:SetupTransition(name, time, func)
		self[name] = 0

		local transition = {
			name = name,
			time = time,
			func = func,
			start_0 = 0,
			start_1 = 0,
		}

		if self.transitions then
			for k, v in ipairs(self.transitions) do
				if v.name == name then
					self.transitions[k] = transition
					return self
				end
			end
			table.insert(self.transitions, transition)
		else
			self.transitions = {transition}
			self:On("Think", transition_func)
		end

		return self
	end
end

function LibClasses:ClearPaint()
	self.Paint = nil
	self.Paint_funcs = nil
	local SetPaintBackgroundEnabled = self.SetPaintBackgroundEnabled
	if SetPaintBackgroundEnabled then
		SetPaintBackgroundEnabled(self, false)
	end
	return self
end

function LibClasses:RoundedBox(id, r, x, y, w, h, c)
	self.colors = self.colors or {}
	local colors = self.colors

	local id_c = colors[id]
	if not id_c then
		id_c = Color(c:Unpack())
		colors[id] = id_c
	end

	sui.lerp_color(id_c, c)
	RoundedBox(r, x, y, w, h, id_c)
end

do
	local SetFGColor = Panel.SetFGColor

	local set_color = function(s, col)
		s.m_colText = col
		SetFGColor(s, col.r, col.g, col.b, col.a)
	end

	local paint = function(s)
		local col = s.sui_textcolor
		sui.lerp_color(col, s.new_col)
		set_color(s, col)
	end

	function LibClasses:TextColor(c, use_paint)
		local col = self.sui_textcolor
		if not col then
			col = Color(c:Unpack())
			self.sui_textcolor = col

			if use_paint then
				self:On("Paint", paint)
			end
		end

		if use_paint then
			self.new_col = c
		else
			sui.lerp_color(col, c)
			self:SetTextColor(col)
		end
	end
end

do
	local fade_hover_Paint = function(s, w, h)
		if s.FadeHovers ~= 0 then
			color_alpha(s.fadehover_color, s.fadehover_old_alpha * s.FadeHovers)
			if s.fadehover_radius > 0 then
				RoundedBox(s.fadehover_radius, 0, 0, w, h, s.fadehover_color)
			else
				SetDrawColor(s.fadehover_color)
				DrawRect(0, 0, w, h)
			end
		end
	end

	function LibClasses:FadeHover(color, time, radius, func)
		color = copy_color(color or COL_WHITE_2)
		self.fadehover_color = color
		self.fadehover_radius = radius or 0
		self.fadehover_old_alpha = color.a
		self:SetupTransition("FadeHovers", time or 0.8, func or TDLibUtil.HoverFunc)
		self:On("Paint", fade_hover_Paint)
		return self
	end
end

function LibClasses:BarHover(color, height, time)
	color = color or COL_WHITE_1
	height = height or 2
	time = time or 1.6
	self:SetupTransition("BarHovers", time, TDLibUtil.HoverFunc)
	self:On("Paint", function(s, w, h)
		if s.BarHovers ~= 0 then
			local bar = Round(w * s.BarHovers)
			SetDrawColor(color)
			DrawRect((w * 0.5) - (bar * 0.5), h - height, bar, height)
		end
	end)
	return self
end

do
	local paint = function(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, s.SUI_GetColor("line"))
	end

	function LibClasses:Line(dock, m1, m2, m3, m4)
		self.making_line = true

		local line = self:Add("SAM.Panel")
		line:Dock(dock or TOP)

		if self.line_margin then
			line:DockMargin(unpack(self.line_margin))
		else
			line:DockMargin(m1 or 0, m2 or 0, m3 or 0, m4 or 10)
		end

		line.no_scale = true
		line:SetTall(1)
		line.Paint = paint

		self.making_line = false
		return line
	end

	function LibClasses:LineMargin(m1, m2, m3, m4)
		self.line_margin = {m1 or 0, m2 or 0, m3 or 0, m4 or 0}
		return self
	end
end

do
	local background_Paint_1 = function(s)
		s:SetBGColor(s.background_color)
	end

	local background_Paint_2 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, true, true, true, true)
	end

	local background_Paint_3 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, s.background_r_tl, s.background_r_tr, s.background_r_bl, s.background_r_br)
	end

	function LibClasses:Background(color, radius, r_tl, r_tr, r_bl, r_br)
		self.background_color = color
		if isnumber(radius) and radius ~= 0 then
			self.background_radius = radius
			if isbool(r_tl) or isbool(r_tr) or isbool(r_bl) or isbool(r_br) then
				self.background_r_tl = r_tl
				self.background_r_tr = r_tr
				self.background_r_bl = r_bl
				self.background_r_br = r_br
				self:On("Paint", background_Paint_3)
			else
				self:On("Paint", background_Paint_2)
			end
		else
			self:SetPaintBackgroundEnabled(true)
			self:On("ApplySchemeSettings", background_Paint_1)
			self:On("PerformLayout", background_Paint_1)
		end
		return self
	end
end

function LibClasses:CircleClick(color, speed, target_radius)
	self.circle_click_color = color or COL_WHITE_2

	speed = speed or 5
	target_radius = isnumber(target_radius) and target_radius or false

	local radius, alpha, click_x, click_y = 0, -1, 0, 0
	local circle = {}
	self:On("Paint", function(s, w)
		if alpha >= 0 then
			DrawCircle(circle, click_x, click_y, radius, ColorAlpha(self.circle_click_color, alpha))
			local frame_time = RealFrameTime()
			radius, alpha = Lerp(frame_time * speed, radius, target_radius or w), Lerp(frame_time * speed, alpha, -1)
		end
	end)
	self:On("DoClick", function()
		click_x, click_y = self:CursorPos()
		radius, alpha = 0, self.circle_click_color.a
	end)
	return self
end

do
	local min = math.min
	function LibClasses:CircleClick2(color, speed, target_radius, start_radius)
		color = color or COL_WHITE_2
		local _color = Color(color:Unpack())

		speed = speed or 5
		target_radius = isnumber(target_radius) and target_radius or false

		local radius, alpha = 0, -1
		local circle = {}
		self:On("Paint", function(s, w, h)
			if alpha >= 0 then
				_color.a = alpha
				DrawCircle(circle, w * 0.5, h * 0.5, radius, _color)

				local frame_time = RealFrameTime()
				radius, alpha = Lerp(frame_time * speed, radius, target_radius or min(w, h) * 0.5), Lerp(frame_time * speed, alpha, -1)
			end
		end)

		self:On("DoClick", function()
			radius, alpha = start_radius or 0, color.a
		end)

		return self
	end
end

-- https://github.com/Facepunch/garrysmod/pull/1520#issuecomment-410458090
function LibClasses:Outline(color, width)
	color = color or COL_WHITE_1
	width = width or 1
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, w, width)
		DrawRect(0, h - width, w, width)
		DrawRect(0, width, width, h - (width * 2))
		DrawRect(w - width, width, width, h - (width * 2))
	end)
	return self
end

function LibClasses:LinedCorners(color, len)
	color = color or COL_WHITE_1
	len = len or 15
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, len, 1)
		DrawRect(0, 1, 1, len - 1)
		DrawRect(w - len, h - 1, len, 1)
		DrawRect(w - 1, h - len, 1, len - 1)
	end)
	return self
end

function LibClasses:SideBlock(color, size, side)
	color = color or COL_WHITE_1
	size = size or 3
	side = side or LEFT
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		if side == LEFT then
			DrawRect(0, 0, size, h)
		elseif side == TOP then
			DrawRect(0, 0, w, size)
		elseif size == RIGHT then
			DrawRect(w - size, 0, size, h)
		elseif side == BOTTOM then
			DrawRect(0, h - size, w, size)
		end
	end)
	return self
end

function LibClasses:Blur()
	self:On("Paint", TDLibUtil.BlurPanel)
	return self
end

do
	local STENCILOPERATION_REPLACE = STENCILOPERATION_REPLACE
	local STENCILOPERATION_ZERO = STENCILOPERATION_ZERO
	local STENCILCOMPARISONFUNCTION_NEVER = STENCILCOMPARISONFUNCTION_NEVER
	local STENCILCOMPARISONFUNCTION_EQUAL = STENCILCOMPARISONFUNCTION_EQUAL

	local ClearStencil = render.ClearStencil
	local SetStencilEnable = render.SetStencilEnable
	local SetStencilWriteMask = render.SetStencilWriteMask
	local SetStencilTestMask = render.SetStencilTestMask
	local SetStencilFailOperation = render.SetStencilFailOperation
	local SetStencilPassOperation = render.SetStencilPassOperation
	local SetStencilZFailOperation = render.SetStencilZFailOperation
	local SetStencilCompareFunction = render.SetStencilCompareFunction
	local SetStencilReferenceValue = render.SetStencilReferenceValue

	local color_white = color_white

	local avatar_setplayer = function(s, ply, size)
		s.avatar:SetPlayer(ply, size)
	end

	local avatar_setsteamid = function(s, steamid, size)
		s.avatar:SetSteamID(steamid, size)
	end

	function LibClasses:CircleAvatar()
		local avatar = self:Add("AvatarImage")
		avatar:Dock(FILL)
		avatar:SetPaintedManually(true)
		self.avatar = avatar
		self.SetSteamID = avatar_setsteamid
		self.SetPlayer = avatar_setplayer

		local circle = {}
		local PaintManual = avatar.PaintManual
		self.Paint = function(s, w, h)
			ClearStencil()
			SetStencilEnable(true)

			SetStencilWriteMask(1)
			SetStencilTestMask(1)

			SetStencilFailOperation(STENCILOPERATION_REPLACE)
			SetStencilPassOperation(STENCILOPERATION_ZERO)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
			SetStencilReferenceValue(1)

			local a = w * 0.5
			DrawCircle(circle, a, a, a, color_white)

			SetStencilFailOperation(STENCILOPERATION_ZERO)
			SetStencilPassOperation(STENCILOPERATION_REPLACE)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			SetStencilReferenceValue(1)

			PaintManual(avatar)

			SetStencilEnable(false)
		end
		return self
	end
end

do
	function LibClasses:AnimationThinkInternal()
		local systime = SysTime()

		if self.Term and self.Term <= systime then
			self:Remove()

			return
		end

		local m_AnimList = self.m_AnimList
		if not m_AnimList then return end

		for i = #m_AnimList, 1, -1 do
			local anim = m_AnimList[i]
			if systime >= anim.StartTime then
				local frac = math.TimeFraction(anim.StartTime, anim.EndTime, systime)
				frac = math.Clamp(frac, 0, 1)

				local Think = anim.Think
				if Think then
					Think(anim, self, frac ^ (1.0 - (frac - 0.5)))
				end

				if frac == 1 then
					local OnEnd = anim.OnEnd
					if OnEnd then
						OnEnd(anim, self)
					end

					m_AnimList[i] = nil
				end
			end
		end
	end

	local sort = function(a, b)
		return a.EndTime > b.EndTime
	end

	function LibClasses:NewAnimation(length, delay, ease, callback)
		delay = delay or 0
		ease = ease or -1

		if self.m_AnimQueue then
			delay = delay + self:AnimTail()
			self.m_AnimQueue = false
		else
			delay = delay + SysTime()
		end

		local anim = {
			StartTime = delay,
			EndTime = delay + length,
			Ease = ease,
			OnEnd = callback
		}

		self:SetAnimationEnabled(true)

		if self.m_AnimList == nil then
			self.m_AnimList = {}
		end

		table.insert(self.m_AnimList, anim)
		table.sort(self.m_AnimList, sort)

		self.AnimationThink = self.AnimationThinkInternal

		return anim
	end

	local MoveThink = function(anim, panel, frac)
		if not anim.startx then
			anim.startx = panel.x
			anim.starty = panel.y
		end

		local x = Lerp(frac, anim.startx, anim.x)
		local y = Lerp(frac, anim.starty, anim.y)
		panel:SetPos(x, y)
	end

	function LibClasses:MoveTo(x, y, length, delay, ease, callback)
		if self.x == x and self.y == y then return end

		local anim = self:NewAnimation(length, delay, ease, callback)
		anim.x = x
		anim.y = y
		anim.Think = MoveThink
	end

	local SetSize = Panel.SetSize
	local SizeThink = function(anim, panel, frac)
		if not anim.startw then
			anim.startw, anim.starth = panel:GetSize()
		end

		local w, h
		if anim.sizew and anim.sizeh then
			w = Lerp(frac, anim.startw, anim.w)
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, w, h)
		elseif anim.sizew then
			w = Lerp(frac, anim.startw, anim.w)
			SetSize(panel, w, panel.starth)
		else
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, panel.startw, h)
		end

		if panel:GetDock() > 0 then
			panel:InvalidateParent()
		end
	end

	function LibClasses:SizeTo(w, h, length, delay, ease, callback)
		local anim = self:NewAnimation(length, delay, ease, callback)

		if w ~= -1 then
			anim.sizew = true
		end

		if h ~= -1 then
			anim.sizeh = true
		end

		anim.w, anim.h = w, h
		anim.Think = SizeThink

		return anim
	end

	local SetVisible = Panel.SetVisible
	local IsVisible = Panel.IsVisible

	local is_visible = function(s)
		local state = s.visible_state
		if state ~= nil then
			return state
		else
			return IsVisible(s)
		end
	end

	function LibClasses:AnimatedSetVisible(visible, cb)
		if visible == is_visible(self) then
			if cb then
				cb()
			end
			return
		end

		if visible then
			SetVisible(self, true)
		end

		self.visible_state = visible
		self:Stop()

		self:AlphaTo(visible and 255 or 0, 0.2, 0, function()
			SetVisible(self, visible)
			self:InvalidateParent(true)
			if cb then
				cb()
			end
		end)

		self:InvalidateParent(true)
	end

	function LibClasses:AnimatedToggleVisible()
		self:AnimatedSetVisible(not is_visible(self))
	end

	function LibClasses:AnimatedIsVisible()
		return is_visible(self)
	end
end

function Panel:SUI_TDLib()
	for k, v in pairs(LibClasses) do
		self[k] = v
	end
	return self
end

TDLibUtil.Install = Panel.SUI_TDLib

local count = 0
TDLibUtil.Start = function()
	count = count + 1
	for k, v in pairs(LibClasses) do
		if not Panel["SUI_OLD" .. k] then
			local old = Panel[k]
			if old == nil then
				old = v
			end
			Panel[k], Panel["SUI_OLD" .. k] = v, old
		end
	end
end

TDLibUtil.End = function()
	count = count - 1
	if count > 0 then return end
	for k, v in pairs(LibClasses) do
		local old = Panel["SUI_OLD" .. k]
		if old == v then
			Panel[k] = nil
		else
			Panel[k] = old
		end
		Panel["SUI_OLD" .. k] = nil
	end
end

TDLibUtil.HoverFunc = function(p)
	return p:IsHovered() and not p:GetDisabled()
end

TDLibUtil.DrawOutlinedBox = function(radius, x, y, w, h, bg, outline, thickness)
	thickness = thickness or 2
	draw.RoundedBox(radius, x, y, w, h, outline)
	draw.RoundedBox(radius, x + thickness, y + thickness, w - (thickness * 2), h - (thickness * 2), bg)
end

do
	local cos, sin, sqrt = math.cos, math.sin, math.sqrt
	local clamp, floor = math.Clamp, math.floor
	local min, max = math.min, math.max

	local calc_ellipse_points = function(rx, ry)
		local points = sqrt(((rx * ry) * 0.5) * 6)
		return max(points, 8)
	end

	local M_PI = 3.14159265358979323846
	calc_rect = function(c, r, x, y, w, h)
		if
			(c.r == r) and
			(c.x == x and c.y == y) and
			(c.w == w and c.h == h)
		then return end

		r = clamp(r, 0, min(w, h) * 0.5)

		local rx, ry = r, r
		if w >= 0.02 then
			rx = min(rx, w * 0.5 - 0.01)
		end
		if h >= 0.02 then
			ry = min(ry, h * 0.5 - 0.01)
		end

		local points = max(calc_ellipse_points(rx, ry) / 4, 1)
		points = floor(points)

		local half_pi = M_PI * 0.5
		local angle_shift = half_pi / (points + 1)

		local phi = 0
		for i = 1, points + 2 do
			c[i] = {
				x = x + rx * (1 - cos(phi)),
				y = y + ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = half_pi
		for i = points + 3, 2 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y +     ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 2 * half_pi
		for i = (2 * (points + 2)) + 1, 3 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 3 * half_pi
		for i = (3 * (points + 2)) + 1, 4 * (points + 2) do
			c[i] = {
				x = x +     rx * (1 - cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		local last = (points + 2) * 4 + 1
		c[last] = c[1]

		for i = last + 1, #c do
			c[i] = nil
		end

		c.r = r
		c.x, c.y = x, y
		c.w, c.h = w, h
	end

	TDLibUtil.RoundedBox = function(c, r, x, y, w, h, color)
		calc_rect(c, r, x, y, w, h)

		SetDrawColor(color)
		NoTexture()
		DrawPoly(c)
	end
end

TDLibUtil.LibClasses = LibClasses

sui.TDLib = TDLibUtil
--PATH addons/____sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--PATH addons/____sam/lua/sui/vgui/sam_player_line.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TDLib = sui.TDLib
local draw_material = sui.draw_material
local lerp_color = sui.lerp_color

local GetColor = SUI.GetColor
local RoundedBox = TDLib.RoundedBox
local CircleAvatar = TDLib.LibClasses.CircleAvatar
local CircleClick2 = TDLib.LibClasses.CircleClick2

local PLAYER_LINE_NAME = SUI.CreateFont("PlayerLineName", "Roboto Bold", 17)
local PLAYER_LINE_RANK = SUI.CreateFont("PlayerLineRank", "Roboto Bold", 13)
local PLAYER_LINE_STEAMID = SUI.CreateFont("PlayerLineSteamID", "Roboto Medium", 12)

local PANEL = {}

function PANEL:Init()
	local size = SUI.Scale(34)

	self:Dock(TOP)
	self:SetTall(size)

	self.size = size
end

local rank_Paint = function(s, w, h)
	RoundedBox(s.rect, SUI.Scale(10), 0, 0, w, h, s.col)
end

function PANEL:SetInfo(info)
	local size = self.size

	local container
	do
		local w = SUI.Scale(280) + size

		local _container = self:Add("Panel")
		_container:Dock(LEFT)
		_container:SetMouseInputEnabled(false)
		_container:SetWide(w)

		container = _container:Add("Panel")
		container:SetSize(w, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	do
		local avatar = container:Add("Panel")
		avatar:Dock(LEFT)
		avatar:DockMargin(0, 0, 5, 0)
		avatar:SetWide(size)
		avatar:SetMouseInputEnabled(false)
		CircleAvatar(avatar)

		avatar:SetSteamID(util.SteamIDTo64(info.steamid), size)
	end

	do
		local top_container = container:Add("Panel")
		top_container:Dock(TOP)
		top_container:DockMargin(0, 0, 0, 2)

		local name = top_container:Add("SAM.Label")
		name:Dock(LEFT)
		name:SetFont(PLAYER_LINE_NAME)
		self.name = name

		local pname = info.name
		if not pname or pname == "" then
			name:SetTextColor(GetColor("player_list_names_2"))
			self:SetName("N/A")
		else
			name:SetTextColor(GetColor("player_list_names"))
			self:SetName(pname)
		end

		if info.rank then
			local rank_bg = top_container:Add("Panel")
			rank_bg:Dock(LEFT)
			rank_bg:DockMargin(5, 0, 0, 0)

			rank_bg.rect = {}
			rank_bg.col = info.rank_bg or GetColor("player_list_rank")
			rank_bg.Paint = rank_Paint

			local rank = rank_bg:Add("SAM.Label")
			rank:Dock(FILL)
			rank:DockMargin(SUI.Scale(8), 0, 0, 0)
			rank:SetTextColor(GetColor("player_list_rank_text"))
			rank:SetFont(PLAYER_LINE_RANK)
			rank.bg = rank_bg

			self.rank = rank
			self:SetRank(info.rank)

			rank_bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
		end

		top_container:SizeToChildren(true, true)
	end

	local steamid = container:Add("SAM.Label")
	steamid:Dock(TOP)
	steamid:SetTextColor(GetColor("player_list_steamid"))
	steamid:SetFont(PLAYER_LINE_STEAMID)
	steamid:SetText(info.steamid)
	steamid:SizeToContents()
	steamid:SetAutoStretchVertical(true)

	self.container = container
end

function PANEL:SetName(new_name)
	local name =  self.name
	name:SetText(new_name)
	name:SizeToContents()
	if name:GetWide() > 160 then
		name:SetWide(158)
	end
end

function PANEL:SetRank(new_rank)
	local rank = self.rank
	rank:SetText(new_rank)
	rank:SizeToContents()
	rank.bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
end

function PANEL:Actions()
	local container
		do
		local size = self.size

		local _container = self:Add("Panel")
		_container:Dock(RIGHT)
		_container:SetWide(size)

		container = _container:Add("Panel")
		container:SetSize(size, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	local actions_button = container:Add("SAM.Button")
	actions_button:SetText("")
	actions_button:ClearPaint()

	function container:PerformLayout(w, h)
		actions_button:SetSize(h, h)
		actions_button:Center()
	end

	local image = actions_button:Add("SAM.Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/dots_verticle.png")

	local current_icon_color = Color(GetColor("actions_button_icon"):Unpack())
	function image:Draw(w, h)
		if not h then return end

		if actions_button.Hovered then
			lerp_color(current_icon_color, GetColor("actions_button_icon_hover"))
		else
			lerp_color(current_icon_color, GetColor("actions_button_icon"))
		end

		draw_material(nil, w * 0.5, h * 0.5, SUI.ScaleEven(20), current_icon_color)
	end

	CircleClick2(actions_button, Color(62, 62, 62), 10)
	actions_button:Center()

	return actions_button
end

sui.register("PlayerLine", PANEL, "Panel")
--PATH addons/____sam/lua/sam/menu/tabs/commands.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI
local type = sam.type

local Line = sui.TDLib.LibClasses.Line

local COMMAND_HELP = SUI.CreateFont("CommandHelp", "Roboto", 14)
local COMMAND_RUN = SUI.CreateFont("CommandRun", "Roboto Medium", 14)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/command_window.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Commands")
		title:SetTextColor(SUI.GetColor("menu_tabs_title"))
		title:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body)

	local left_body = body:Add("SAM.Panel")
	left_body:Dock(LEFT)
	left_body:SetWide(148)

	local search_entry = left_body:Add("SAM.TextEntry")
	search_entry:Dock(TOP)
	search_entry:SetNoBar(true)
	search_entry:SetPlaceholder("Search...")
	search_entry:SetRadius(4)
	search_entry:SetTall(27)

	local category_list = left_body:Add("SAM.CollapseCategory")
	category_list:Dock(FILL)
	category_list:DockMargin(0, SUI.Scale(10), 0, 0)

	local canvas = category_list:GetCanvas()

	local commands_refresh = function()
		if not IsValid(category_list) then return end

		canvas:Clear()
		table.Empty(category_list.items)
		table.Empty(category_list.categories)

		for k, v in ipairs(sam.command.get_commands()) do
			if (v.permission and not LocalPlayer():HasPermission(v.permission)) or v.menu_hide then
				continue
			end

			local item = category_list:add_item(v.name, v.category)
			item:InvalidateParent(true)
			item.help = v.help
			item.command = v

			item.names = {v.name:lower()}
			for _, aliase in ipairs(v.aliases) do
				table.insert(item.names, aliase:lower())
			end
		end
	end
	commands_refresh()

	do
		local hooks = {
			"SAM.CommandAdded", "SAM.CommandModified", "SAM.CommandRemoved",
			"SAM.RemovedPermission",
			{"SAM.ChangedPlayerRank", func = function(ply, rank, old_rank)
				if rank == old_rank then return end
				if ply == LocalPlayer() then
					commands_refresh()
				end
			end},
			{
				"SAM.RankPermissionGiven", "SAM.RankPermissionTaken", "SAM.ChangedInheritRank",
				func = function(rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			},
			{
				"SAM.AddedPermission", "SAM.PermissionModified",
				func = function(_, _, rank)
					if rank == LocalPlayer():GetUserGroup() then
						commands_refresh()
					end
				end
			}
		}
		for _, v in ipairs(hooks) do
			if type(v) == "table" then
				for _, v2 in ipairs(v) do
					hook.Add(v2, "SAM.Menu.RefreshCommands", v.func)
				end
			else
				hook.Add(v, "SAM.Menu.RefreshCommands", commands_refresh)
			end
		end
	end

	function search_entry:OnValueChange(text)
		category_list:Search(text:lower())
	end

	do
		local line = Line(body, LEFT)
		line:DockMargin(10, 0, 10, 0)
		line:SetWide(1)
	end

	local buttons = body:Add("SAM.ScrollPanel")
	buttons:Dock(FILL)

	local childs = {}
	local pos = 0
	buttons:GetCanvas():On("OnChildAdded", function(s, child)
		child:Dock(TOP)
		child:DockMargin(0, 0, 0, 5)
		child:SetAlpha(0)
		child:SetVisible(false)
		table.insert(childs, child)

		pos = pos + 1
		child:SetZPos(pos)
	end)

	local run_command = buttons:Add("SAM.Button")
	run_command:Dock(TOP)
	run_command:SetTall(25)
	run_command:SetFont(COMMAND_RUN)
	run_command:SetZPos(100)
	run_command:SetEnabled(false)

	run_command:On("DoClick", function(self)
		LocalPlayer():ConCommand("sam\"" .. self:GetText() .. "\"\"" .. table.concat(self.input_arguments, "\"\"") .. "\"")
	end)

	local help = buttons:Add("SAM.Label")
	help:Dock(TOP)
	help:SetFont(COMMAND_HELP)
	help:SetZPos(101)
	help:SetWrap(true)
	help:SetAutoStretchVertical(true)

	sam.menu.get():On("OnKeyCodePressed", function(s, key_code)
		if key_code == KEY_ENTER and IsValid(run_command) and run_command:IsEnabled() and run_command:IsMouseInputEnabled() and tab_body:IsVisible() then
			run_command:DoClick()
		end
	end)

	function category_list:item_selected(item)
		local arguments = sam.command.get_arguments()
		local command = item.command
		local command_arguments = command.args
		local input_arguments = {}

		for i = #childs, 3, -1 do
			local v = childs[i]
			if not v.no_change or not command:HasArg(v.no_change) then
				if v.no_remove ~= true then
					v:Remove()
				else
					v:Hide()
				end
			end
		end

		local NIL = {}
		for _, v in ipairs(command_arguments) do
			local func = arguments[v.name]["menu"]
			if not func then continue end

			local i = table.insert(input_arguments, NIL)
			local p = func(function(allow)
				if not IsValid(run_command) then return end
				input_arguments[i] = allow == nil and NIL or allow
				for i_2 = 1, #input_arguments do
					if input_arguments[i_2] == NIL then
						run_command:SetEnabled(false)
						return
					end
				end
				run_command:SetEnabled(true)
			end, body, buttons, v, childs)
			if p then
				p:AnimatedSetVisible(true)
			end
		end

		if #command_arguments == 0 then
			run_command:SetEnabled(true)
		end

		run_command:SetText(command.name)
		run_command:AnimatedSetVisible(true)
		run_command.input_arguments = input_arguments

		if command.help then
			help:SetText(command.help)
			help:AnimatedSetVisible(true)
			help:SizeToContents()
		else
			help:AnimatedSetVisible(false)
		end

		buttons:InvalidateLayout(true)
	end

	return tab_body
end, nil, 1)

--PATH addons/____sam/lua/sam/menu/tabs/config/reports.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local not_empty = function(s)
	return s and s ~= ""
end

local number_entry = function(setting, config_key, default)
	local entry = setting:Add("SAM.TextEntry")
	entry:SetWide(50)
	entry:SetPlaceholder("")
	entry:SetBackground(Color(34, 34, 34))
	entry:SetNumeric(true)
	entry:DisallowFloats()
	entry:DisallowNegative()
	entry:SetCheck(not_empty)
	entry:SetConfig(config_key, default)

	return entry
end

config.add_tab("Reports", function(parent)
	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:LineMargin(0, 6, 0, 0)

	local i = 0
	body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)

		if not body.making_line then
			body:Line()
		end
	end)

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Enable")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Commands")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(200)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.Commands")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Max Reports (Number of reports that can show on your screen)")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.MaxReports", 4)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Auto Close Time (Time to wait before automatically closing claimed reports)")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(70)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetCheck(function(time)
			time = sam.parse_length(time)
			if not time then
				return false
			end
		end)
		entry:SetConfig("Reports.AutoCloseTime", "10m")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Always Show (Show the popups even if you are not on duty)")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports.AlwaysShow", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("On Duty Jobs")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(300)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.DutyJobs", "")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Position")
		setting:DockMargin(8, 6, 8, 0)

		local combo = setting:Add("SAM.ComboBox")
		combo:SetWide(60)
		combo:AddChoice("Left", nil, true)
		combo:AddChoice("Right")
		combo:SetConfig("Reports.Position", "Left")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("X Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.XPadding", 5)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Y Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.YPadding", 5)
	end

	return body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 2)
--PATH addons/____sam/lua/sam/modules/support_cami.lua:
if SAM_LOADED then return end

local ranks_loaded
if SERVER then
	ranks_loaded = sam.ranks.ranks_loaded()
else
	ranks_loaded = sam.get_global("Ranks") ~= nil
end

do
	local load_ranks = function()
		for name, rank in pairs(sam.ranks.get_ranks()) do
			if not sam.ranks.is_default_rank(name) then
				CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
			end
		end
	end

	if ranks_loaded then
		load_ranks()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksToCAMI", load_ranks)
	end
end

hook.Add("SAM.AddedRank", "SAM.CAMI.AddedRank", function(name, rank)
	if not sam.ranks.is_default_rank(name) then
		CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
	end
end)

hook.Add("SAM.RemovedRank", "SAM.CAMI.RemovedRank", function(name)
	CAMI.UnregisterUsergroup(name, "SAM")
end)

hook.Add("SAM.RankNameChanged", "SAM.CAMI.RankNameChanged", function(old, new)
	CAMI.UnregisterUsergroup(old, "SAM")
	CAMI.RegisterUsergroup({Name = new, Inherits = sam.ranks.get_rank(new).inherit}, "SAM")
end)

hook.Add("SAM.ChangedPlayerRank", "SAM.CAMI.ChangedPlayerRank", function(ply, new_rank, old_rank)
	CAMI.SignalUserGroupChanged(ply, old_rank, new_rank, "SAM")
end)

hook.Add("SAM.ChangedSteamIDRank", "SAM.CAMI.ChangedSteamIDRank", function(steamid, new_rank, old_rank)
	CAMI.SignalSteamIDUserGroupChanged(steamid, old_rank, new_rank, "SAM")
end)

----------------------------------------------------------------------------------------------------------------------------------------------------------

if SERVER then
	do
		local on_user_group_registered = function(rank, source)
			if source ~= "SAM" then
				sam.ranks.add_rank(rank.Name, sam.ranks.is_rank(rank.Inherits) and rank.Inherits or "user")
			end
		end

		local load_ranks = function()
			for _, rank in pairs(CAMI.GetUsergroups()) do
				on_user_group_registered(rank, "CAMI")
			end
			hook.Add("CAMI.OnUsergroupRegistered", "SAM.CAMI.OnUsergroupRegistered", on_user_group_registered)
		end

		if ranks_loaded then
			load_ranks()
		else
			hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksFromCAMI", load_ranks)
		end
	end

	hook.Add("CAMI.OnUsergroupUnregistered", "SAM.CAMI.OnUsergroupUnregistered", function(rank, source)
		if source ~= "SAM" then
			sam.ranks.remove_rank(rank.Name)
		end
	end)

	hook.Add("CAMI.PlayerUsergroupChanged", "SAM.CAMI.PlayerUsergroupChanged", function(ply, _, new_rank, source)
		if ply and IsValid(ply) and source ~= "SAM" then
			sam.player.set_rank(ply, new_rank)
		end
	end)

	hook.Add("CAMI.SteamIDUsergroupChanged", "SAM.CAMI.SteamIDUsergroupChanged", function(steamid, _, new_rank, source)
		if sam.is_steamid(steamid) and source ~= "SAM" then
			sam.player.set_rank_id(steamid, new_rank)
		end
	end)
end

do
	local on_privilege_registered = function(privilege)
		sam.permissions.add(privilege.Name, "CAMI", privilege.MinAccess)
	end

	local load_privileges = function()
		for _, privilege in pairs(CAMI.GetPrivileges()) do
			on_privilege_registered(privilege)
		end
		hook.Add("CAMI.OnPrivilegeRegistered", "SAM.CAMI.OnPrivilegeRegistered", on_privilege_registered)
	end

	if ranks_loaded then
		load_privileges()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadPrivileges", load_privileges)
	end
end

hook.Add("CAMI.OnPrivilegeUnregistered", "SAM.CAMI.OnPrivilegeUnregistered", function(privilege)
	sam.permissions.remove(privilege.Name)
end)

hook.Add("CAMI.PlayerHasAccess", "SAM.CAMI.PlayerHasAccess", function(ply, privilege, callback, target)
	if sam.type(ply) ~= "Player" then return end

	local has_permission = ply:HasPermission(privilege)
	if sam.type(target) == "Player" then
		callback(has_permission and ply:CanTarget(target))
	else
		callback(has_permission)
	end

	return true
end)

--PATH addons/____sam/lua/sam/modules/user.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("User Management")

command.new("setrank")
	:Aliases("adduser", "changerank", "giverank")

	:SetPermission("setrank")

	:AddArg("player", {single_target = true})
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrank_help")

	:OnExecute(function(ply, targets, rank, length)
		targets[1]:sam_set_rank(rank, length)

		sam.player.send_message(nil, "setrank", {
			A = ply, T = targets, V = rank, V_2 = sam.format_length(length)
		})
	end)
:End()

command.new("setrankid")
	:Aliases("adduserid", "changerankid", "giverankid")

	:SetPermission("setrankid")

	:AddArg("steamid")
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrankid_help")

	:OnExecute(function(ply, promise, rank, length)
		local a_name = ply:Name()

		promise:done(function(data)
			local steamid, target = data[1], data[2]
			if target then
				target:sam_set_rank(rank, length)

				sam.player.send_message(nil, "setrank", {
					A = ply, T = {target, admin = ply}, V = rank, V_2 = sam.format_length(length)
				})
			else
				sam.player.set_rank_id(steamid, rank, length)

				sam.player.send_message(nil, "setrank", {
					A = a_name, T = steamid, V = rank, V_2 = sam.format_length(length)
				})
			end
		end)
	end)
:End()

command.new("addrank")
	:SetPermission("manage_ranks")

	:AddArg("text", {hint = "rank name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})
	:AddArg("rank", {hint = "inherit from"})
	:AddArg("number", {hint = "immunity", min = 2, max = 99, optional = true})
	:AddArg("length", {hint = "ban limit", optional = true})

	:Help("addrank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit, immunity, ban_limit)
		sam.ranks.add_rank(rank, inherit, immunity, ban_limit)

		sam.player.send_message(nil, "addrank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("removerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})

	:Help("removerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank)
		sam.ranks.remove_rank(rank)

		sam.player.send_message(nil, "removerank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("renamerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})
	:AddArg("text", {hint = "new name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})

	:Help("renamerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_name)
		sam.ranks.rename_rank(rank, new_name)

		sam.player.send_message(nil, "renamerank", {
			A = ply, T = rank, V = new_name
		})
	end)
:End()

command.new("changeinherit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("rank", {hint = "inherits from"})

	:Help("changeinherit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit)
		if rank == inherit then return end

		sam.ranks.change_inherit(rank, inherit)

		sam.player.send_message(nil, "changeinherit", {
			A = ply, T = rank, V = inherit
		})
	end)
:End()

command.new("changerankimmunity")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("number", {hint = "new immunity", min = 2, max = 99})

	:Help("changerankimmunity_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_immunity)
		sam.ranks.change_immunity(rank, new_immunity)

		sam.player.send_message(nil, "rank_immunity", {
			A = ply, T = rank, V = new_immunity
		})
	end)
:End()

command.new("changerankbanlimit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "superadmin"
	end})
	:AddArg("length")

	:Help("changerankbanlimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_limit)
		sam.ranks.change_ban_limit(rank, new_limit)

		sam.player.send_message(nil, "rank_ban_limit", {
			A = ply, T = rank, V = sam.format_length(new_limit)
		})
	end)
:End()

command.new("givepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("givepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.give_permission(rank, permission)

		sam.player.send_message(nil, "giveaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("takepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("takepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.take_permission(rank, permission)

		sam.player.send_message(nil, "takeaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("changeranklimit")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "limit"})
	:AddArg("number", {hint = "value"})

	:Help("changeranklimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, limit, value)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.set_limit(rank, limit, value)

		sam.player.send_message(nil, "changeranklimit", {
			A = ply, T = rank, V = limit, V_2 = value
		})
	end)
:End()
--PATH addons/____sam/lua/sam/modules/util.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Utility")

command.new("mapreset")
	:SetPermission("mapreset", "admin")

	:Help("mapreset_help")

	:OnExecute(function(ply)
		game.CleanUpMap(false, nil, function() end)

		sam.player.send_message(nil, "mapreset", {
			A = ply
		})
	end)
:End()

command.new("kick")
	:SetPermission("kick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("kick_help")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		target:Kick(reason)

		sam.player.send_message(nil, "kick", {
			A = ply, T = target:Name(), V = reason
		})
	end)
:End()

command.new("gban")
	:SetPermission("ban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("ban_help")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		if ply:GetBanLimit() ~= 0 then
			if length == 0 then
				length = ply:GetBanLimit()
			else
				length = math.Clamp(length, 1, ply:GetBanLimit())
			end
		end
		target:sam_ban(length, reason, ply:SteamID())

		sam.player.send_message(nil, "ban", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("banid")
	:SetPermission("banid", "admin")

	:AddArg("steamid")
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("banid_help")

	:OnExecute(function(ply, promise, length, reason)
		local a_steamid, a_name, a_ban_limit = ply:SteamID(), ply:Name(), ply:GetBanLimit()

		promise:done(function(data)
			local steamid, target = data[1], data[2]

			if a_ban_limit ~= 0 then
				if length == 0 then
					length = a_ban_limit
				else
					length = math.Clamp(length, 1, a_ban_limit)
				end
			end

			if target then
				target:sam_ban(length, reason, a_steamid)

				sam.player.send_message(nil, "ban", {
					A = a_name, T = target:Name(), V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.ban_id(steamid, length, reason, a_steamid)

				sam.player.send_message(nil, "banid", {
					A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
				})
			end
		end)
	end)
:End()

command.new("ungban")
	:SetPermission("unban", "admin")

	:AddArg("steamid", {allow_higher_target = true})

	:Help("unban_help")

	:OnExecute(function(ply, steamid, reason)
		sam.player.unban(steamid, ply:SteamID())

		sam.player.send_message(nil, "unban", {
			A = ply, T = steamid
		})
	end)
:End()

do
	command.new("noclip")
		:SetPermission("noclip", "admin")

		:AddArg("player", {optional = true})

		:Help("noclip_help")

		:OnExecute(function(ply, targets)
			local id
			for i = 1, #targets do
				local v = targets[i]
				v:SetMoveType(v:GetMoveType() == MOVETYPE_WALK and MOVETYPE_NOCLIP or MOVETYPE_WALK)
				if v == ply then
					id = i
				end
			end

			if id then
				table.remove(targets, id)
				if #targets == 0 then return end
			end

			sam.player.send_message(nil, "noclip", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.permissions.add("can_noclip", nil, "admin")

	hook.Add('PlayerNoClip', 'SAM.CanNoClip', function(ply, desiredNoClipState)
		if IsValid(ply) and (ply:HasPermission('can_noclip') or ply:onyx_GetNetVar('adminmode')) then
			if SERVER then
				if desiredNoClipState then
					sam.player.cloak(ply)
				else
					sam.player.uncloak(ply)
				end
			end
			return true
		end
		return false
	end)
end

do
	local config = sam.config

	sam.permissions.add("can_physgun_players", nil, "admin")

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Physgun", function(body)
			local setting_body

			do
				local p = add_setting(body, "Physgun (Enable/Disable all physgun features except picking up players)", "Physgun.Enabled")
				p:DockMargin(8, 6, 8, 0)
			end

			setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "No fall damage on drop", "Physgun.NoFallDamageOnDrop")
			add_setting(setting_body, "Right click to freeze players", "Physgun.RightClickToFreeze")
			add_setting(setting_body, "Reset Velocity to fix some issues when players fall", "Physgun.ResetVelocity")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local freeze_player = function(ply)
		if SERVER then
			ply:Lock()
		end
		ply:SetMoveType(MOVETYPE_NONE)
		ply:SetCollisionGroup(COLLISION_GROUP_WORLD)
	end

	sam.hook_first( "PhysgunPickup", "SAM.CanPhysgunPlayer", function( ply, target )
		if sam.type( target ) == "Player" and ply:HasPermission( "can_physgun_players" ) and ply:CanTarget( target ) and ply:IsAdminMode() then
			freeze_player( target )
			return true
		end
	end )

	local load_phygun_settings = function()
		print('11')
		hook.Remove("PhysgunDrop", "SAM.PhysgunDrop")
		hook.Remove("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround")

		if config.get("Physgun.Enabled", true) == false then
			-- add a hook to unlock the player if the physgun is disabled and other stuff
			hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
				if sam.type(target) == "Player" then
					target:SetMoveType(MOVETYPE_WALK)
					target:SetCollisionGroup(COLLISION_GROUP_PLAYER)

					if SERVER then
						target:UnLock()
						if target.sam_has_god_mode then
							target:GodEnable()
						end
					end
				end
			end)
			return
		end

		local right_click_to_freeze = config.get("Physgun.RightClickToFreeze", true)
		local reset_velocity = config.get("Physgun.ResetVelocity", true)
		hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
			if sam.type(target) ~= "Player" then return end

			if right_click_to_freeze and ply:KeyPressed(IN_ATTACK2) then
				freeze_player(target)

				if SERVER then
					target:sam_set_nwvar("frozen", true)
					target:sam_set_exclusive("frozen")
				end
			else
				if reset_velocity then
					target:SetLocalVelocity(Vector(0, 0, 0))
				end

				if SERVER then
					target:UnLock()
					target:sam_set_nwvar("frozen", false)
					target:sam_set_exclusive(nil)

					if target.sam_has_god_mode then
						target:GodEnable()
					end

					target.sam_physgun_drop_was_frozen = not target:IsOnGround()
				end

				target:SetMoveType(MOVETYPE_WALK)
				target:SetCollisionGroup(COLLISION_GROUP_PLAYER)
			end
		end)

		if config.get("Physgun.NoFallDamageOnDrop", true) then
			hook.Add("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround", function(ply)
				if ply.sam_physgun_drop_was_frozen then
					ply.sam_physgun_drop_was_frozen = false
					return true
				end
			end)
		end
	end

	load_phygun_settings()
	--config.hook({"Physgun.Enabled", "Physgun.RightClickToFreeze", "Physgun.ResetVelocity", "Physgun.NoFallDamageOnDrop"}, load_phygun_settings)
end

do
	command.new("cleardecals")
		:SetPermission("cleardecals", "admin")
		:Help("cleardecals_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "cleardecals")

			sam.player.send_message(nil, "cleardecals", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("cleardecals", function()
			game.RemoveRagdolls()
			RunConsoleCommand("r_cleardecals")
		end)
	end
end

do
	command.new("stopsound")
		:SetPermission("stopsound", "admin")
		:Help("stopsound_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "stopsound")

			sam.player.send_message(nil, "stopsound", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("stopsound", function()
			RunConsoleCommand("stopsound")
		end)
	end
end

command.new("exit")
	:SetPermission("exit_vehicle", "admin")

	:AddArg("player", {single_target = true})

	:Help("exit_vehicle_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if not target:InVehicle() then
			if ply == target then
				return ply:sam_send_message("not_in_vehicle")
			else
				return ply:sam_send_message("not_in_vehicle2", {
					S = target:Name()
				})
			end
		end

		target:ExitVehicle()

		sam.player.send_message(nil, "exit_vehicle", {
			A = ply, T = targets
		})
	end)
:End()

command.new("time")
	:SetPermission("time", "user")

	:AddArg("player", {single_target = true, optional = true})

	:Help("time_help")

	:OnExecute(function(ply, targets)
		if ply == targets[1] then
			sam.player.send_message(ply, "time_your", {
				V = sam.reverse_parse_length_vasilisk(targets[1]:sam_get_play_time() / 60)
			})
		else
			sam.player.send_message(ply, "time_player", {
				T = targets, V = sam.reverse_parse_length_vasilisk(targets[1]:sam_get_play_time() / 60)
			})
		end
	end)
:End()

do
	command.new("buddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("buddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = true
			end

			sam.player.send_message(nil, "buddha", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unbuddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("unbuddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = nil
			end

			sam.player.send_message(nil, "unbuddha", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("EntityTakeDamage", "SAM.BuddhaMode", function(ply, info)
			if ply.sam_buddha and ply:Health() - info:GetDamage() <= 0 then
				ply:SetHealth(1)
				return true
			end
		end)
	end
end

command.new("give")
	:SetPermission("give", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "weapon/entity"})

	:Help("give_help")

	:OnExecute(function(ply, targets, weapon)
		for i = 1, #targets do
			targets[i]:Give(weapon)
		end

		sam.player.send_message(nil, "give", {
			A = ply, T = targets, V = weapon
		})
	end)
:End()

-- do
-- 	if CLIENT then
-- 		sam.netstream.Hook("GetFriends", function()
-- 			local friends = {}
-- 			local humans = player.GetHumans()
-- 			for i = 1, #humans do
-- 				local human = humans[i]
-- 				if human:GetFriendStatus() == "friend" then
-- 					table.insert(friends, human)
-- 				end
-- 			end
-- 			netstream.Start("GetFriends", friends)
-- 		end)
-- 	else
-- 		hook.Add("SAM.AuthedPlayer", "GetPlayerFriends", function(ply)
-- 			timer.Simple(0, function()
-- 				ply.sam_requesting_friends = true
-- 				netstream.Start(ply, "GetFriends")
-- 			end)
-- 		end)

-- 		local invalid_friends = function(ply, friends, new_list)
-- 			if not sam.istable(friends) then return true end

-- 			local count = #friends
-- 			local max_players = game.MaxPlayers()
-- 			for k, friend in pairs(friends) do
-- 				if not sam.isnumber(k) then return true end
-- 				if not sam.isentity(friend) then return true end
-- 				if k > max_players then return true end
-- 				if k > count then return true end

-- 				if IsValid(friend) then
-- 					table.insert(new_list, friend)
-- 				end
-- 			end
-- 		end

-- 		sam.netstream.Hook("GetFriends", function(ply, friends)
-- 			local new_list = {}
-- 			if invalid_friends(ply, friends, new_list) then
-- 				ply.sam_friends_invalid = true
-- 				return
-- 			end
-- 			ply.sam_friends = new_list
-- 		end, function()
-- 			return ply.sam_requesting_friends
-- 		end)
-- 	end

-- 	command.new("friends")
-- 		:SetPermission("friends", "superadmin")

-- 		:AddArg("player", {single_target = true})

-- 		:Help(language.get("friends_help"))

-- 		:OnExecute(function(ply, targets)
-- 			local target = targets[1]
-- 			target.sam_friends_requests = target.sam_friends_requests or {}
-- 			target.sam_friends_requests[ply] = true
-- 		end)
-- 	:End()
-- end

--PATH addons/_doctor/lua/blues_pharm_translation.lua:
BLUES_PHARMA = BLUES_PHARMA or {}
BLUES_PHARMA.TRANS = {}
 
--Generate translations
BLUES_PHARMA.TRANS.MoneySign = "$"
BLUES_PHARMA.TRANS.Selected = "Selected"
BLUES_PHARMA.TRANS.Pour = "Натисніть 'E' на склянці, щоб налити"
BLUES_PHARMA.TRANS.Cancel = "Натисніть 'X', щоб скасувати"
BLUES_PHARMA.TRANS.FeelingBetter = "Ви починаєте почуватися краще."
BLUES_PHARMA.TRANS.Overdosed = "У вас передозування!"
BLUES_PHARMA.TRANS.OverdoseWarning = "Ви почуваєтеся не дуже добре. Ви боїтеся, що якщо приймете більше ліків, то може статися передозування."
BLUES_PHARMA.TRANS.NotEnoughtLiquid = "Для цього недостатньо рідини!"
BLUES_PHARMA.TRANS.BeakerIsFull = "У склянці недостатньо місця для цього!"
BLUES_PHARMA.TRANS.RequiresCooking = "Потребує приготування!"
BLUES_PHARMA.TRANS.RequiresFreezing = "Потребує заморожування!"
BLUES_PHARMA.TRANS.ReadyForPressing = "Готовий до пресування!"
BLUES_PHARMA.TRANS.Beaker = "Склянка"
BLUES_PHARMA.TRANS.Contents = "Вміст"
BLUES_PHARMA.TRANS.BurnedChemicals = "Спалені хімічні речовини"
BLUES_PHARMA.TRANS.NPCBringPills = "[Доктор Клейнер] Принесіть пігулки та натисніть 'E', щоб продати їх за готівку!"
BLUES_PHARMA.TRANS.NPCSellPills = "[Доктор Клейнер] Ви продали пігулки за %s!"

BLUES_PHARMA.TRANS.DamageBuffStart = "[BP] Ваш баф шкоди розпочався."
BLUES_PHARMA.TRANS.DamageResistanceStart  = "[BP] Ваш опір шкоди почався."
BLUES_PHARMA.TRANS.PassiveStart  = "[BP] Ваше пасивне зцілення почалося."
BLUES_PHARMA.TRANS.SpeedJumpStart  = "[BP] Почався приріст швидкості та стрибків."

BLUES_PHARMA.TRANS.DamageBuffExpire = "[BP] Ваш баф пошкоджень закінчився."
BLUES_PHARMA.TRANS.DamageResistanceExpire = "[BP] Ваш опір до пошкоджень закінчився."
BLUES_PHARMA.TRANS.PassiveHealing = "[BP] Ваш запас пасивного зцілення закінчився."
BLUES_PHARMA.TRANS.SpeedJumpExpired = "[BP] Ваш запас швидкості та стрибка закінчився." 

BLUES_PHARMA.TRANS.DoubleTime = "[BP] Подвоїти час дії медичних бафів, що залишився, якщо їх ще не було застосовано."

BLUES_PHARMA.TRANS.PillMarket = "Ринок пігулок"
BLUES_PHARMA.TRANS.SellPillHere = "Продавати пігулки тут"

--Book related translations
BLUES_PHARMA.TRANS.BOOK = {}
BLUES_PHARMA.TRANS.BOOK.Pour = "Налийте наступні хімічні речовини у склянку."
BLUES_PHARMA.TRANS.BOOK.PourComplete = "Після завершення заливання поставте склянку на бунзенівський пальник приблизно на %s хвилин. Обов'язково регулярно перемішуйте, щоб запобігти пригоранню."
BLUES_PHARMA.TRANS.BOOK.CookComplete = "Після завершення нагрівання поставте склянку в морозильну камеру на %s хвилин, щоб заморозити речовину."
BLUES_PHARMA.TRANS.BOOK.FreezeComplete = "Після завершення заморожування висипте вміст у прес для таблеток, щоб спресувати порошкоподібну рідину в таблетку та розлити її у пляшки."
BLUES_PHARMA.TRANS.BOOK.MiniTutorial1 = [[Ласкаво просимо до цього посібника для Blue's Pharmaceuticals. У цій книзі ви знайдете багато різноманітних рецептів, які допоможуть вам створити різноманітні фармацевтичні препарати, такі як: аспірин, стероїди та вітаміни. Натискайте на стрілки внизу сторінки, щоб перегортати зміст книги. Ви також можете натиснути ESC, X або клацнути по книзі, щоб закрити її. Приємного читання!]]
BLUES_PHARMA.TRANS.BOOK.MiniTutorial2 = [[Ви можете зробити будь-яку сутність вертикальною, використовуючи SHIFT+E на ній. Якщо вам потрібно спорожнити склянку, ви можете зробити це за допомогою ALT+E. Натисніть E на хімічній речовині, щоб вибрати її, а потім натисніть E на склянці, щоб вилити цю речовину в неї]]
--PATH addons/__main/lua/autorun/sh_vapeswep.lua:
-- autorun/client/cl_vapeswep.lua
-- Defines shared globals for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

CreateConVar("vape_block_sounds", "0", FCVAR_REPLICATED, "Set to 1 to disable Vape SWEP speech sounds")

--override Entity:SetMaterial to make sure vape shows for ponies
meta = FindMetaTable("Entity")
if meta.VapeOrigSetMaterial == nil then
	meta.VapeOrigSetMaterial = meta.SetMaterial
	meta.SetMaterial = function(self, materialName, forceMaterial)
		if self:GetClass():sub(1,11)=="weapon_vape" and materialName=="Models/effects/vol_light001" then return end
		self:VapeOrigSetMaterial(materialName, forceMaterial)
	end
end
--PATH addons/__________skeypads/lua/autorun/skeypads.lua:
sKeypads = {}
function sKeypads.LoadDirectory( dir )
    local fil, fol = file.Find( dir .. "/*", "LUA" )
    for _, v in ipairs( fol ) do
        sKeypads.LoadDirectory( dir .. "/" .. v )
    end

    for _, v in ipairs( fil ) do
        local dirs = dir .. "/" .. v
        if v:StartWith( "cl_" ) then
            if SERVER then
                AddCSLuaFile( dirs )
            else
                include( dirs )
            end
        elseif v:StartWith( "sh_" ) then
            AddCSLuaFile( dirs )
            include( dirs )
        else
            if SERVER then include( dirs ) end
        end
    end
end

if CLIENT then
    onyx.wimg.Register( 'cracker_circle', 'https://i.imgur.com/ayJZZkb.png' )
end

sKeypads.LoadDirectory( "skeypads" )
timer.Simple( 1, function()
    if sKeypads.Config.keypads_crackers then
        local baseKeyPad = {}
        for _, v in ipairs( weapons.GetList() ) do
            if v.ClassName == "skeypad_cracker_base" then baseKeyPad = v end
        end

        sKeypads.Utils.assert( baseKeyPad ~= {} and baseKeyPad ~= nil, "You've changed the name of the base keypad, don't do that." )
        for _, v in ipairs( sKeypads.Config.keypads_crackers ) do
            local newKeypad = table.Copy( weapons.GetStored( "skeypad_cracker_base" ) )
            sKeypads.Utils.assert( isbool( v.deployable ), "Invalid deployable state for keypad cracker." )
            newKeypad.Deployable = v.deployable
            sKeypads.Utils.assert( isnumber( v.time ), "Invalid time for keypad cracker." )
            newKeypad.CrackTime = v.time
            sKeypads.Utils.assert( isstring( v.name ), "Invalid name for keypad cracker." )
            newKeypad.PrintName = v.name
            sKeypads.Utils.assert( isstring( v.class_name ), "Invalid class name for keypad cracker." )
            newKeypad.Spawnable = true
            weapons.Register( newKeypad, v.class_name )
        end
    end
end )

local soundLevel = 70
sound.Add( {
    name = "sKeypads.Beep_Keypress",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = soundLevel,
    pitch = 100,
    sound = "skeypads/beep_keypress.mp3"
} )

sound.Add( {
    name = "sKeypads.Beep_Success",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = soundLevel,
    pitch = 100,
    sound = "skeypads/beep_success.mp3"
} )

sound.Add( {
    name = "sKeypads.Beep_Error",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = soundLevel,
    pitch = 100,
    sound = "skeypads/beep_error.mp3"
} )
--PATH addons/__________skeypads/lua/skeypads/main/cl_friends.lua:
sKeypads.Friends = {}
local friendsTable = {}
function sKeypads.Friends.getAll()
    return friendsTable
end

function sKeypads.Friends.isFriend( steamid64 )
    return table.HasValue( friendsTable, steamid64 )
end

function sKeypads.Friends.add( steamid64 )
    table.insert( friendsTable, steamid64 )
    sKeypads.Friends.sendFriend( steamid64 )
    sKeypads.Friends.save()
    return friendsTable
end

function sKeypads.Friends.remove( steamid64 )
    table.RemoveByValue( friendsTable, steamid64 )
    sKeypads.Friends.sendRemovedFriend( steamid64 )
    sKeypads.Friends.save()
    return friendsTable
end

function sKeypads.Friends.load()
    friendsTable = util.JSONToTable( cookie.GetString( 'sKeypads.Friends', '{}' ) ) or {}
end

function sKeypads.Friends.save()
    cookie.Set( 'sKeypads.Friends', util.TableToJSON( friendsTable ) )
end

sKeypads.Friends.load()
function sKeypads.Friends.sendAll()
    net.Start( 'sKeypads::SendFriends' )
    for _, v in ipairs( friendsTable ) do
        net.WriteString( v )
    end

    net.SendToServer()
end

function sKeypads.Friends.sendFriend( steamid64 )
    net.Start( 'sKeypads::SendFriends' )
    net.WriteString( steamid64 )
    net.SendToServer()
end

function sKeypads.Friends.sendRemovedFriend( steamid64 )
    net.Start( 'sKeypads::RemoveFriends' )
    net.WriteString( steamid64 )
    net.SendToServer()
end

hook.Add( 'Think', 'sKeypads::SendFriendsOnReady', function()
    sKeypads.Friends.sendAll()
    hook.Remove( 'Think', 'sKeypads::SendFriendsOnReady' )
end )
--PATH addons/__________skeypads/lua/skeypads/utils/sh_hooking.lua:
sKeypads.Utils = sKeypads.Utils or {}
function sKeypads.Utils.RunHook( name, ... )
    sKeypads.Utils.checkType( name, sKeypads.Types.TYPE_STRING )
    return hook.Run( "sKeypads::" .. name, ... )
end
--PATH addons/____slib/lua/slib/vgui/cl_sbutton.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor, accentcolor, successcolor, failcolor = slib.getTheme("textcolor"), slib.getTheme("accentcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor")

function PANEL:Init()
    self.font = font
    self:SetText("")
    self.bg = slib.getTheme("maincolor")
    self.alignment = TEXT_ALIGN_CENTER
    self.accentheight = 2
    self.selCol = accentcolor
    self.textcolor = textcolor
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "DockPadding", nil, function() return self end, true)
    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
    slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetVisible", nil, function() return self end, true)
end

function PANEL:setTitle(title, alignment, noresize)
    if self.title == title then return end
    self.title = title

    if alignment then self.alignment = alignment end
    
    if !noresize then
        surface.SetFont(self.font)
        local w = select(1, surface.GetTextSize(title))

        self:SetWide(w + (slib.getTheme("margin") * 2))
    end
    
    return self
end

function PANEL:getTitle()
    return self.title
end

function PANEL:SetLinePos(h)
    self.linepos = h

    return self
end

function PANEL:setToggleable(bool)
    self.toggleable = bool

    return self
end

function PANEL:Paint(w,h)
    local wantedcolor = self.toggleable and (isfunction(self.toggleCheck) and self.toggleCheck() and istable(self.toggleCheck()) and self.toggleCheck() or self.toggleCheck() and successcolor or failcolor) or self.selCol

    if !self.toggleable then
        wantedcolor.a = (self:IsHovered() or self.forcehover) and 120 or 20
    end

    surface.SetDrawColor(self.bg)
    surface.DrawRect(0, 0, w, h)

    surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
    surface.DrawRect(0, self.linepos ~= nil and self.linepos or (h - self.accentheight), w, self.accentheight)
    local x
    if self.alignment == TEXT_ALIGN_CENTER then
        x = w * .5
    elseif self.alignment == TEXT_ALIGN_RIGHT then
        x = w - slib.getTheme("margin")
    elseif self.alignment == TEXT_ALIGN_LEFT then
        x = slib.getTheme("margin")
    end

    draw.SimpleText(self.title, self.font, x, h * .5, self.textcolor, self.alignment, TEXT_ALIGN_CENTER)
end

vgui.Register("SButton", PANEL, "DButton")
--PATH addons/____sprinter/lua/s_printer/languages/sh_polish.lua:
if CLIENT then
    slib.setLang("sprinter", "pl", "main", "Główny")
    slib.setLang("sprinter", "pl", "logs", "Dzienniki")
    slib.setLang("sprinter", "pl", "upgrades", "Aktualizacje")
    slib.setLang("sprinter", "pl", "settings", "Ustawienia")
    slib.setLang("sprinter", "pl", "overclocking", "Przetaktowywanie")
    slib.setLang("sprinter", "pl", "noisereduction", "Redukcja szumów")
    slib.setLang("sprinter", "pl", "dmgresistance", "Odporność na uszkodzenia")
    slib.setLang("sprinter", "pl", "notifications", "Powiadomienia")

    slib.setLang("sprinter", "pl", "notify-withdraw", "Powiadom o wypłacie")
    slib.setLang("sprinter", "pl", "notify-on-damage", "Powiadom w przypadku uszkodzenia")
    slib.setLang("sprinter", "pl", "notify-low-hp", "Powiadom przy niskim HP")
    slib.setLang("sprinter", "pl", "notify-low-battery", "Powiadom o niskim poziomie naładowania baterii")

    slib.setLang("sprinter", "pl", "withdrawn-money", "Wypłacone pieniądze")
    slib.setLang("sprinter", "pl", "received-damage", "Otrzymane obrażenia")
    slib.setLang("sprinter", "pl", "upgraded-printer", "Ulepszona drukarka")
    slib.setLang("sprinter", "pl", "turned-on", "Włączone")
    slib.setLang("sprinter", "pl", "turned-off", "Wyłączony")

    slib.setLang("sprinter", "pl", "are-you-sure", "Jesteś pewny?")
    slib.setLang("sprinter", "pl", "this-will-cost", "To będzie kosztować %s")

    slib.setLang("sprinter", "pl", "nothing-to-show", "Nie ma tu nic do pokazania")

    slib.setLang("sprinter", "pl", "condition", "Stan: schorzenie")
    slib.setLang("sprinter", "pl", "temperature", "Temperatura")
    slib.setLang("sprinter", "pl", "clockspeed", "Szybkośc zegara")
    slib.setLang("sprinter", "pl", "income", "Dochód(min)")
    slib.setLang("sprinter", "pl", "eject", "Wyrzucać")
    slib.setLang("sprinter", "pl", "withdraw", "Wycofać")
    slib.setLang("sprinter", "pl", "repair", "Naprawic")
    slib.setLang("sprinter", "pl", "recharge", "Naładuj")

    slib.setLang("sprinter", "pl", "empty", "Pusty")
else
    slib.setLang("sprinter", "pl", "upgraded", "Zaktualizowałeś drukarkę dla %s")
    slib.setLang("sprinter", "pl", "recharged", "Naładowałeś drukarkę za %s")
    slib.setLang("sprinter", "pl", "repaired", "Naprawiłeś drukarkę dla %s")
    slib.setLang("sprinter", "pl", "repaired-rack", "Naprawiłeś stojak dla %s")
    slib.setLang("sprinter", "pl", "withdrawn", "Wycofałeś się %s")
    slib.setLang("sprinter", "pl", "recharged-all", "Naładowałeś każdą drukarkę w stojaku za %s")
    slib.setLang("sprinter", "pl", "recharged-this-many", "Naładowałeś %s drukarki w stojaku na %s")
    slib.setLang("sprinter", "pl", "repaired-all", "Naprawiłeś każdą drukarkę w szafie dla %s")
    slib.setLang("sprinter", "pl", "repaired-this-many", "Naprawiłeś %s drukarki w stojaku na %s")
    slib.setLang("sprinter", "pl", "no-eject-space", "Nie ma miejsca na wysunięcie drukarki")
    slib.setLang("sprinter", "pl", "printer-was-damaged", "Twój %s drukarka została uszkodzona!")
    slib.setLang("sprinter", "pl", "printer-low-hp", "Twój %s drukarka ma niską moc!")
    slib.setLang("sprinter", "pl", "someone-has-withdrawn", "Ktoś wypłacił pieniądze z Twojego %s drukarka!")
    slib.setLang("sprinter", "pl", "battery-low", "Twój %s drukarka ma słabą baterię, należy ją naładować!")
    slib.setLang("sprinter", "pl", "rewarded-on-destroy", "Twoje otrzymały %s w nagrodę za zniszczenie drukarki!")
end

slib.setLang("sprinter", "pl", "rack", "Drukarkę")
slib.setLang("sprinter", "pl", "insufficient-permissions", "Masz niewystarczające uprawnienia, aby to zrobić!")
--PATH addons/ukrp_main_content/lua/autorun/ssu_security_heavy.lua:
--Add Playermodel
player_manager.AddValidModel( "SSU Heavy", "models/player/ssu_security_heavy.mdl" )
--PATH addons/ukrp_main_content/lua/autorun/ssu_security_light.lua:
--Add Playermodel
player_manager.AddValidModel( "SSU Light", "models/player/ssu_security_light.mdl" )
--PATH addons/_dance/lua/wos/fortnite/loader/loader.lua:

--[[-------------------------------------------------------------------
	Fortnite Dancing Addon Real Loader:
		We do all the actual loading here
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--


wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

local dir = "wos/fortnite"

if SERVER then
	AddCSLuaFile( dir .. "/vgui/vgui_tauntcam.lua" )
	AddCSLuaFile( dir .. "/core/sh_core.lua" )
	AddCSLuaFile( dir .. "/core/cl_net.lua" )
	AddCSLuaFile( dir .. "/core/cl_core.lua" )
	AddCSLuaFile( dir .. "/core/cl_wcpanel.lua" )
	include( dir .. "/core/sv_concommands.lua" )
	include( dir .. "/core/sv_net.lua" )
else
	include( dir .. "/vgui/vgui_tauntcam.lua" )
	include( dir .. "/core/sh_core.lua" )
	include( dir .. "/core/cl_net.lua" )
	include( dir .. "/core/cl_core.lua" )
	include( dir .. "/core/cl_wcpanel.lua" )
end

include( dir .. "/core/sh_core.lua" )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/settings/settings.lua:
XeninUI.Branding = false


XeninUI.Materials = {
	CloseButton = Material("xenin/closebutton.png", "noclamp smooth"),
	Search = Material("xenin/search.png", "noclamp smooth"),
	Tick = Material("xenin/tick.png", "smooth")
}

XeninUI.TransitionTime = 0.15


XeninUI.DisableNotification = true


XeninUI.Theme = {
	Primary = Color(48, 48, 48),
	Navbar = Color(41, 41, 41),
	Background = Color(30, 30, 30),
	Accent = Color(41, 128, 185),
	OrangeRed = Color(228, 104, 78),
	Red = Color(230, 58, 64),
	Green = Color(46, 204, 113),
	Blue = Color(41, 128, 185),
	Yellow = Color(201, 176, 15),
	Purple = Color(142, 68, 173),
	Orange = Color(230, 153, 58),
	LightYellow = Color(189, 201, 15),
	GreenDark = Color(39, 174, 96)
}

XeninUI.Frame = {
	Width = 960,
	Height = 720
}

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/scripts/main.lua:
local Scripts
do
  local _class_0
  local _base_0 = {
    __name = "Scripts",
    checkScriptVersions = function(self, tbl)
      local scripts = self:getAll()
      local needUpdate = {}

      for i, v in pairs(scripts) do
        if (!v.versionCheck) then continue end

        local tblVersion = tbl[v.id]
        local version = tonumber(v.version)
        if (!isnumber(version)) then continue end
        if (!isnumber(tblVersion)) then continue end

        if (tblVersion and version < tblVersion) then
          needUpdate[v.id] = {
            name = v.name,
            version = tblVersion,
            currentVersion = v.version
          }
        end
      end

      local msgs = {}
      for i, v in pairs(needUpdate) do
        table.insert(msgs, {
          XeninUI.Theme.Accent,
          "[Xenin " .. tostring(v.name) .. "] ",
          Color(255, 255, 255),
          "Please update to ",
          XeninUI.Theme.Green,
          "version " .. tostring(v.version),
          Color(255, 255, 255),
          " you are on ",
          XeninUI.Theme.Red,
          "version " .. tostring(v.currentVersion)
        })
      end
      local targets = {}
      for i, v in ipairs(player.GetAll()) do
        if (XeninUI.Permissions:canAccessFramework(v) or XeninUI.Permissions:isAdmin(v)) then
          table.insert(targets, v)
        end
      end

      XeninUI.ScriptsNetwork:sendUpdateMessage(targets, msgs)

      for i, v in ipairs(msgs) do
        table.insert(v, "\n")

        MsgC(unpack(v))
      end
    end,
    register = function(self, id, name, version, author, tbl)
      if tbl == nil then tbl = {}
      end
      local script = {
        id = id,
        name = name,
        author = author,
        version = version
      }

      table.Merge(script, tbl)

      self.scripts[id] = script
    end,
    setAll = function(self, tbl)
      self.scripts = tbl
    end,
    get = function(self, id)
      return self.scripts[id]
    end,
    getAll = function(self)
      return self.scripts
    end,
    getByName = function(self, name)
      for i, v in pairs(self.scripts) do
        if (v.name != name) then continue end

        return name
      end
    end,
    __type = function(self)
      return "XeninUI.Scripts"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.scripts = {}
      if (CLIENT) then return end

      timer.Create("Xenin.Framework.Version", 600, 0, function()
        http.Fetch("https://gitlab.com/sleeppyy/xenin-version-tracker/-/raw/master/versions.json", function(body, size, headers, code)
          if (code >= 400) then return end
          if (size == 0) then return end
          local tbl = util.JSONToTable(body)
          if (!tbl) then return end

          self:checkScriptVersions(tbl)
        end)
      end)
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Scripts = _class_0
end

XeninUI.Scripts = Scripts()

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/top.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Title", 26)
XeninUI:CreateFont("Xenin.Configurator.Admin.Subtitle", 14)

function PANEL:Init()
	self.CloseBtn = self:Add("DButton")
	self.CloseBtn:Dock(RIGHT)
	self.CloseBtn:SetText("")
	self.CloseBtn.CloseButton = Color(100, 100, 100)
	self.CloseBtn.Alpha = 0
	self.CloseBtn.DoClick = function(pnl)
		self:GetParent():Remove()
	end
	self.CloseBtn.Paint = function(pnl, w, h)
		draw.RoundedBox(h * 0.5, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Red, pnl.Alpha))

		surface.SetDrawColor(pnl.CloseButton)
		surface.SetMaterial(XeninUI.Materials.CloseButton)
		surface.DrawTexturedRect(12, 12, w - 24, h - 24)
	end
	self.CloseBtn.OnCursorEntered = function(pnl)
		pnl:Lerp("Alpha", 255)
		pnl:LerpColor("CloseButton", Color(255, 255, 255))
	end
	self.CloseBtn.OnCursorExited = function(pnl)
		pnl:Lerp("Alpha", 0)
		pnl:LerpColor("CloseButton", Color(100, 100, 100))
	end

	self.Name = self:Add("DPanel")
	self.Name:Dock(LEFT)
	self.Name.Paint = function(pnl, w, h)
		local text = self.Text
		if isstring(text) then
			XeninUI:DrawShadowText(text, "Xenin.Configurator.Admin.Title", 0, h * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 2, 150)
		elseif istable(text) then
			XeninUI:DualText({
				text[1],
				"Xenin.Configurator.Admin.Title",
				color_white,
				TEXT_ALIGN_LEFT,
				2,
				150
			}, {
				text[2],
				"Xenin.Configurator.Admin.Subtitle",
				Color(145, 145, 145),
				TEXT_ALIGN_LEFT,
				0,
				0
			}, 0, -2, w, h)
		end
	end

	self.Search = self:Add("Xenin.Configurator.Admin.SearchBar")
	self.Search:Dock(FILL)
	self.Search:DockMargin(36, 0, 250, 0)
	self.Search:SetPlaceholder("Search for anything")
	self.Search:SetIcon(XeninUI.Materials.Search, true)
end

function PANEL:SetText(text)
	self.Text = text
end

function PANEL:PerformLayout(w, h)
	self.CloseBtn:SetWide(h)

	local text = self.Text
	local nW
	if istable(text) then
		surface.SetFont("Xenin.Configurator.Admin.Title")
		local tW = surface.GetTextSize(text[1])
		surface.SetFont("Xenin.Configurator.Admin.Subtitle")
		local sW = surface.GetTextSize(text[2])
		nW = math.max(tW, sW)
	else
		surface.SetFont("Xenin.Configurator.Admin.Title")
		local tW = surface.GetTextSize(text)
		nW = math.max(tW, 170)
	end

	self.Name:SetWide(nW)
end

function PANEL:SetScript(script, ctr)
	self.script = script
	self.ctr = ctr

	self.Search:SetScript(script, ctr)
end

vgui.Register("Xenin.Configurator.Admin.Top", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/entities/entity_list.lua:
local PANEL = {}

local matArrow = Material("xenin/next.png", "smooth")

XeninUI:CreateFont("Xenin.Configurator.Row.Title", 20)
XeninUI:CreateFont("Xenin.Configurator.Row.Subtitle", 14)

function PANEL:Init()
  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Body = self.Scroll:Add("Panel")

  self.Save.DoClick = function(pnl)
    for _, row in pairs(self.Rows) do
      row.Entity:save(true)
    end
  end
end

function PANEL:SetData(tbl)
  assert(tbl ~= nil, "cannot destructure nil value")
  local __entity, name, script = tbl.__entity, tbl.name, tbl.script

  self:SetScript(script)
  self.Entity = __entity
  self:SetTitle(name)

  self.Navbar:SetVisible(false)
  self.Template = XeninUI.Configurator.Entities:get(self.Entity)
  self.BaseEnt = XeninUI.Configurator.Entities:create(self.Entity)

  if (!self.Template.getListView) then
    error("To use a list you need to implement a static getListView function for your model")
  end

  self.New = self.Body:Add("DButton")
  self.New:Dock(TOP)
  self.New:DockMargin(0, 0, 0, 12)
  self.New:SetText("")
  self.New:SetTall(48)
  self.New.Color = XeninUI.Theme.Background
  self.New.OutlineColor = XeninUI.Theme.Primary
  self.New.TextColor = Color(174, 174, 174)
  self.New.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    XeninUI:MaskInverse(function()
      XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, pnl.OutlineColor)
    end, function()
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.OutlineColor)
    end)

    draw.SimpleText("Create New", "Xenin.Configurator.Row.Title", w * 0.5, h * 0.5, pnl.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end
  self.New.OnCursorEntered = function(pnl)
    pnl:LerpColor("OutlineColor", XeninUI.Theme.Green)
    pnl:LerpColor("TextColor", color_white)
  end
  self.New.OnCursorExited = function(pnl)
    pnl:LerpColor("OutlineColor", XeninUI.Theme.Primary)
    pnl:LerpColor("TextColor", Color(174, 174, 174))
  end
  self.New.DoClick = function(pnl)
    self.Body.Alpha = self.Body.Alpha || 255
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self:CreateNew(self.Template)
    end)
  end

  self.ToDelete = {}

  local rows = self.Template.getAllEntities()
  self.Rows = {}
  self.RowsIds = {}
  for i, v in pairs(rows) do
    self:CreateRow(v, i)
  end
end

function PANEL:CreateNew()
  local entity = XeninUI.Configurator.Entities:create(self.Entity)

  for i, v in pairs(self.Rows) do
    if (!IsValid(v)) then continue end

    v:SetVisible(false)
  end
  self.New:SetVisible(false)

  if IsValid(self.ListBody) then self.ListBody:Remove()end

  self.Body:LerpAlpha(255, 0.15, function()
    self.Body:SetAlpha(255)
  end)

  self.ListBody = self.Body:Add("Panel")
  self.ListBody.Alpha = 0
  self.ListBody:LerpAlpha(255, nil, function()
    self.ListBody:SetAlpha(255)
  end)
  self.ListBody:Dock(TOP)
  self.ListBody.Rows = {}

  self.ListBody.Header = self.ListBody:Add("Panel")
  self.ListBody.Header:Dock(TOP)
  self.ListBody.Header:DockMargin(0, 0, 0, 8)
  self.ListBody.Header:SetTall(32)
  self.ListBody.Header.Paint = function(pnl, w, h)
    draw.SimpleText(self.Template.selectRowString or "Select a row", "Xenin.Configurator.Row.Title", 8, h * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end

  self.ListBody.Header.Back = self.ListBody.Header:Add("XeninUI.ButtonV2")
  self.ListBody.Header.Back:Dock(RIGHT)
  self.ListBody.Header.Back:DockMargin(0, 6, 6, 0)
  self.ListBody.Header.Back:SetText("")
  self.ListBody.Header.Back:SetSolidColor(XeninUI.Theme.Primary)
  self.ListBody.Header.Back:SetRoundness(6)
  self.ListBody.Header.Back.Text = "Go Back"
  self.ListBody.Header.Back.PaintOver = function(pnl, w, h)
    surface.SetMaterial(matArrow)
    surface.SetDrawColor(color_white)
    local size = h - 14
    surface.DrawTexturedRectRotated(size, h * 0.5, size, size, 180)

    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Subtitle", size * 1.75, h * 0.5, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  surface.SetFont("Xenin.Configurator.Row.Subtitle")
  local tw = surface.GetTextSize(self.ListBody.Header.Back.Text)
  self.ListBody.Header.Back:SetWide((14 * 1.75) + tw + 8)
  self.ListBody.Header.Back.HasClicked = false
  self.ListBody.Header.Back.DoClick = function(pnl)
    if (pnl.HasClicked) then return end
    pnl.HasClicked = true

    self.ListBody:LerpAlpha(0, 0.15, function()
      self.ListBody:Remove()
      self.Body.Alpha = 0
      self.Body:LerpAlpha(255, 0.15)

      for i, v in pairs(self.Rows) do
        if (!IsValid(v)) then continue end

        v:SetVisible(true)
      end
      self.New:SetVisible(true)
      self:InvalidateLayout(true)
    end)
  end

  for i, v in ipairs(self.Template.getGridContent()) do
    local data = self.Template.getGridData(v)
    if (!data) then continue end
    local ent = XeninUI.Configurator.Entities:create(self.Entity)
    self.Template.gridSetDefaultData(ent, data, i)
    if (self.RowsIds[ent:getId()]) then continue end
    local search = self.Template.getListView(ent).search

    local row = self.ListBody:Add("Xenin.Configurator.Admin.EntityList.Row")
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 4)
    row:SetTall(56)
    row.DeleteDisabled = true
    row:SetEntity(ent, self.Template, true)
    row.Search = search or function(pnl, text)
      return pnl.Entity:getId():lower():find(text)
    end

    row.Edit:SetText("Select")
    row.Edit:SetSolidColor(XeninUI.Theme.OrangeRed)
    row.Edit.DoClick = function(pnl)
      self.ListBody:LerpAlpha(0, 0.15, function()
        self.ListBody:Remove()
        local newId = #self.Rows + 1
        self:CreateRow(row.Entity, newId)
        self:SwitchToEdit(row.Entity, self.Rows[newId], true)
        self:InvalidateLayout(true)
      end)
    end

    table.insert(self.ListBody.Rows, row)
  end

  self.ListBody.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  self:InvalidateLayout(true)
end

function PANEL:SwitchToEdit(entity, parent, isNew)
  local copy = table.Copy(entity)

  for i, v in pairs(self.Rows) do
    if (!IsValid(v)) then continue end

    v:SetVisible(false)
  end
  self.New:SetVisible(false)

  if IsValid(self.SettingsPanel) then self.SettingsPanel:Remove()end

  self.Body:LerpAlpha(255, 0.15, function()
    self.Body:SetAlpha(255)
  end)

  self.SettingsPanel = self.Body:Add("Xenin.Configurator.Admin.Entity.Row.Settings")
  self.SettingsPanel:DockMargin(0, 0, 0, 0)
  self.SettingsPanel.FadeOut = function(pnl)
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self.SettingsPanel:Remove()

      self.Body:LerpAlpha(255, 0.15, function()
        self.Body:SetAlpha(255)
      end)
      for i, v in pairs(self.Rows) do
        if (!IsValid(v)) then continue end

        v:SetVisible(true)
      end
      self.New:SetVisible(true)
      self:InvalidateLayout(true)
    end)
  end

  self.SettingsPanel.Header = self.SettingsPanel:Add("Panel")
  self.SettingsPanel.Header:Dock(TOP)
  self.SettingsPanel.Header:DockMargin(0, 0, 0, 8)
  self.SettingsPanel.Header:SetTall(32)
  self.SettingsPanel.Header.Text = isNew and "Creating New Object" or "Editing Object"
  self.SettingsPanel.Header.Paint = function(pnl, w, h)
    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Title", 8, h * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end

  self.SettingsPanel.Header.Back = self.SettingsPanel.Header:Add("XeninUI.ButtonV2")
  self.SettingsPanel.Header.Back:Dock(RIGHT)
  self.SettingsPanel.Header.Back:DockMargin(0, 6, 6, 0)
  self.SettingsPanel.Header.Back:SetText("")
  self.SettingsPanel.Header.Back:SetSolidColor(XeninUI.Theme.Primary)
  self.SettingsPanel.Header.Back:SetRoundness(6)
  self.SettingsPanel.Header.Back.Text = isNew and "Cancel" or "Go Back"
  self.SettingsPanel.Header.Back.PaintOver = function(pnl, w, h)
    surface.SetMaterial(matArrow)
    surface.SetDrawColor(color_white)
    local size = h - 14
    surface.DrawTexturedRectRotated(size, h * 0.5, size, size, 180)

    draw.SimpleText(pnl.Text, "Xenin.Configurator.Row.Subtitle", size * 1.75, h * 0.5, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  surface.SetFont("Xenin.Configurator.Row.Subtitle")
  local tw = surface.GetTextSize(self.SettingsPanel.Header.Back.Text)
  self.SettingsPanel.Header.Back:SetWide((14 * 1.75) + tw + 8)
  self.SettingsPanel.Header.Back.DoClick = function(pnl)
    if isNew then
      local foundAt
      for i, v in ipairs(self.Rows) do
        if (v.Id != parent.Id) then continue end

        v:Remove()

        foundAt = i
      end
      if foundAt then
        table.remove(self.Rows, foundAt)

        parent:Remove()
      end

      self.SettingsPanel:LerpAlpha(0, 0.15, function()
        self.SettingsPanel:Remove()
        self:CreateNew()
        self:InvalidateLayout(true)
      end)
    else
      self.SettingsPanel:FadeOut()
    end
  end

  self.SettingsPanel.Top = self.SettingsPanel:Add("Xenin.Configurator.Admin.EntityList.Row")
  self.SettingsPanel.Top:Dock(TOP)
  self.SettingsPanel.Top:DockMargin(0, 0, 0, 4)
  self.SettingsPanel.Top:SetTall(56)
  self.SettingsPanel.Top.DeleteDisabled = true
  self.SettingsPanel.Top:SetEntity(entity, self.Template)

  self.SettingsPanel.Top.Edit:SetText(isNew and "Create" or "Save")
  self.SettingsPanel.Top.Edit.DoClick = function(pnl, w, h)
    parent:SetEntity(copy, self.Template)


    self.SettingsPanel:FadeOut()
  end

  self.SettingsPanel:AddSettings(entity)
  self.SettingsPanel.OnValueChanged = function(pnl)
    local settings = pnl:GetSettings()
    for i, v in pairs(settings) do
      copy["set" .. tostring(i)](copy, v)
    end

    pnl.Top:SetEntity(copy, self.Template)
    pnl.Top:InvalidateLayout(true)

  end

  self.SettingsPanel:Dock(TOP)
  self.SettingsPanel.GetChildSize = function(pnl)
    local height = 0
    local size = 0
    for i, v in ipairs(pnl.Settings) do
      if (!v:IsVisible()) then continue end

      size = size + 1
      height = height + v:GetTall()
    end
    height = height - (size * 3)

    return height + 8 + pnl.Top:GetTall() + 8 + 40
  end

  self:InvalidateLayout(true)
end

function PANEL:CreateRow(entity, index)
  local listView = self.Template.getListView(entity)
  if (!listView) then return end
  assert(listView ~= nil, "cannot destructure nil value")
  local height, search = listView.height, listView.search

  self.RowsIds[entity:getId()] = true

  local row = self.Body:Add("Xenin.Configurator.Admin.EntityList.Row")
  row:Dock(TOP)
  row:DockMargin(0, 0, 0, 4)
  row:SetTall(height or 56)
  row.Id = index
  row:SetEntity(entity, self.Template)
  row.DoClick = function(pnl)
    self.Body.Alpha = 255
    self.Body:LerpAlpha(0, 0.15, function()
      self.Body:SetAlpha(0)
      self:SwitchToEdit(pnl.Entity, pnl)
    end)
  end
  row.OnRemove = function(pnl)
    self.RowsIds[pnl.Entity:getId()] = nil end
  row.OnDelete = function(pnl)
    XeninUI:SimpleQuery("Delete", "Are you sure you want to delete this?", "Yes", function()
      local foundAt
      for i, v in ipairs(self.Rows) do
        if (v.Id != pnl.Id) then continue end

        v:Remove()

        foundAt = i
      end
      if (!foundAt) then return end

      table.remove(self.Rows, foundAt)

      self.RowsIds[pnl.Entity:getId()] = nil
      pnl.Entity:delete(true)

      pnl:Remove()
    end, "No", function() end)
  end
  row.Search = search or function(pnl, text)
    return pnl.Entity:getId():lower():find(text)
  end

  table.insert(self.Rows, row)
end

function PANEL:OnSearch(text)
  text = text:lower()

  local panels = self.Rows
  if IsValid(self.ListBody) then
    panels = self.ListBody.Rows
  end
  if (IsValid(self.SettingsPanel)) then return end

  for i, v in pairs(panels) do
    local result = v:Search(text)
    v:SetVisible(result)
  end

  self:InvalidateLayout(true)

  if IsValid(self.ListBody) then
    self.ListBody:InvalidateLayout(true)
    self.ListBody:SizeToChildren(false, true)
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  self.Body:SetWide(math.min(600, w))
  self.Body:CenterHorizontal()
  self.Body:SizeToChildren(false, true)

  if (!IsValid(self.SettingsPanel)) then return end

  self.SettingsPanel:SetTall(self.SettingsPanel:GetChildSize())
end

vgui.Register("Xenin.Configurator.Admin.EntityList", PANEL, "Xenin.Configurator.Admin.Panel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/entities/settings_base.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Italic", 18, nil, {
italic = true
})

function PANEL:Init()
  self:Dock(TOP)
  self:DockMargin(0, 48, 0, 0)
  self:DockPadding(0, 0, 0, 0)

  self.Settings = {}
end

function PANEL:AddSettings() end

function PANEL:AddSetting(id, name, type, tbl)
  if tbl == nil then tbl = {}
  end
  tbl.data = tbl.data or {}

  local panel = self:Add("DPanel")
  panel.Id = id
  panel:Dock(TOP)
  panel:SetTall(48)
  panel:DockMargin(0, 0, 0, -4)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "Xenin.Configurator.Admin.Panel.Setting", 8, 48 * 0.5, Color(145, 145, 145), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    if IsValid(panel.Overlay) then
      panel.Overlay:SetSize(w, h)
    end
  end

  if tbl.readOnly then
    panel.Overlay = panel:Add("DPanel")
    panel.Overlay:SetZPos(2)
    panel.Overlay.Color = ColorAlpha(XeninUI.Theme.Navbar, 150)
    panel.Overlay.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 8, w, h - 16, pnl.Color)

      if (!pnl:IsHovered()) then return end

      draw.SimpleText("Read only", "Xenin.Configurator.Admin.Panel.Setting", w * 0.5, h * 0.5, XeninUI.Theme.Red, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
  end
  if tbl.hide then
    panel:SetVisible(false)
  end

  local input = XeninUI.Configurator:CreateInputPanel(type, self, tbl, {
    id = id,
    name = name,
    type = type,
    parent = panel
  })
  input:Dock(RIGHT)
  input:SetParent(panel)
  if (input.SetData and tbl.data) then
    input:SetData(tbl.data)
  end
  if (input.SetInput and tbl.value) then
    input:SetInput(tbl.value)
  end
  if tbl.func then
    tbl.func(input)
  end
  if tbl.fetch then
    tbl.fetch(input)
  end
  input.onChange = function(pnl, ...)
    if (!isfunction(tbl.onChange)) then return end

    tbl.onChange(pnl, ...)
  end
  panel.Input = input

  table.insert(self.Settings, panel)
end

function PANEL:GetSettings()
  local tbl = {}
  for i, v in ipairs(self.Settings) do
    tbl[v.Id] = v.Input:GetSettingValue()
  end

  return tbl
end

function PANEL:Paint(w, h)
  surface.SetDrawColor(100, 100, 100)
  surface.DrawLine(1, h - 1, w - 1, h - 1)
end

vgui.Register("Xenin.Configurator.Admin.SettingsBase", PANEL, "DPanel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/popup.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/toggle.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/network/shared.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Players.NetworkHelper",
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self) end,
    __base = _base_0,
    sendNotification = function(notification)
      assert(notification ~= nil, "cannot destructure nil value")
      local scriptId, type, content, createdAt, readAt, data, id = notification.scriptId, notification.type, notification.content, notification.createdAt, notification.readAt, notification.data, notification.id

      net.WriteString(scriptId)
      net.WriteString(type)
      net.WriteString(content)
      net.WriteString(createdAt)
      net.WriteBool(istable(data))
      if istable(data) then
        net.WriteTable(data)
      end
      net.WriteBool(readAt != nil)
      if readAt then
        net.WriteString(readAt)
      end
      net.WriteBool(id != nil)
      if id then
        net.WriteUInt(id, 32)
      end
    end,
    receiveNotification = function()
      local notification = {
        scriptId = net.ReadString(),
        type = net.ReadString(),
        content = net.ReadString(),
        createdAt = net.ReadString()
      }
      local hasData = net.ReadBool()
      if hasData then
        notification.data = net.ReadTable()
      end
      local hasRead = net.ReadBool()
      if hasRead then
        notification.readAt = net.ReadString()
      end
      local hasId = net.ReadBool()
      if hasId then
        notification.id = net.ReadUInt(32)
      end

      return notification
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Players.NetworkHelper = _class_0
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/category.lua:
XeninUI:CreateFont("XeninUI.Category.Title", 20)

XENINUI_LAYOUT_GRID = 1
XENINUI_LAYOUT_ROW = 2

local PANEL = {}

AccessorFunc(PANEL, "m_topHeight", "TopHeight")
AccessorFunc(PANEL, "m_expanded", "Expanded")
AccessorFunc(PANEL, "m_topColor", "TopColor")
AccessorFunc(PANEL, "m_topColorHover", "TopColorHover")
AccessorFunc(PANEL, "m_topColorActive", "TopColorActive")
AccessorFunc(PANEL, "m_topTextColor", "TopTextColor")
AccessorFunc(PANEL, "m_topTextColorHover", "TopTextColorHover")
AccessorFunc(PANEL, "m_topTextColorActive", "TopTextColorActive")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_iconSize", "IconSize")
AccessorFunc(PANEL, "m_iconOffset", "IconOffset")
AccessorFunc(PANEL, "m_xOffset", "XOffset")
AccessorFunc(PANEL, "m_name", "Name")
AccessorFunc(PANEL, "m_font", "Font")
AccessorFunc(PANEL, "m_background", "BackgroundColor")
AccessorFunc(PANEL, "m_layoutType", "LayoutType")
AccessorFunc(PANEL, "m_columns", "Columns")
AccessorFunc(PANEL, "m_layoutX", "LayoutX")
AccessorFunc(PANEL, "m_layoutY", "LayoutY")
AccessorFunc(PANEL, "m_layoutPanel", "LayoutPanel")
AccessorFunc(PANEL, "m_columnHeight", "ColumnHeight")
AccessorFunc(PANEL, "m_columnGridHeight", "GridColumnHeight")
AccessorFunc(PANEL, "m_bAnimateChanges", "AnimateChanges", FORCE_BOOL)
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_InstantExpandWidth", "InstantExpandWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_categoryColor", "CategoryColor")
AccessorFunc(PANEL, "m_border", "Border", FORCE_NUMBER)

function PANEL:Init()
  self:SetExpanded(false)
  self:SetTopHeight(48)
  self:SetTopColor(XeninUI.Theme.Primary)
  self:SetTopColorHover(Color(54, 54, 54))
  self:SetTopColorActive(Color(60, 60, 60))
  self:SetTopTextColor(Color(180, 180, 180))
  self:SetTopTextColorHover(Color(210, 210, 210))
  self:SetTopTextColorActive(color_white)
  self:SetRounded(6)
  self:SetXOffset(16)
  self:SetName("UNNAMED CATEGORY")
  self:SetFont("XeninUI.Category.Title")
  self:SetIcon(nil)
  self:SetIconSize(32)
  self:SetIconOffset(8)
  self:SetBackgroundColor(XeninUI.Theme.Navbar)
  self:SetBorder(8)
  self:SetLayoutType(XENINUI_LAYOUT_ROW)
  self:SetColumns(1)
  self:SetColumnHeight(48)
  self:SetLayoutX(8)
  self:SetLayoutY(8)
  self:SetLayoutPanel("DButton")
  self:SetInstantExpandWidth(0)

  self.Top = self:Add("DButton")
  self.Top:Dock(TOP)
  self.Top:SetText("")
  self.Top.textColor = self:GetTopTextColor()
  self.Top.background = self:GetTopColor()
  XeninUI:DownloadIcon(self.Top, "2QGKAd6")
  self.Top.rotation = 0
  self.Top.OnCursorEntered = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 180)
    pnl:LerpColor("textColor", self:GetTopTextColorHover())
    pnl:LerpColor("background", self:GetTopColorHover())
  end
  self.Top.OnCursorExited = function(pnl)
    if self:GetExpanded() then return end

    pnl:Lerp("rotation", 0)
    pnl:LerpColor("textColor", self:GetTopTextColor())
    pnl:LerpColor("background", self:GetTopColor())
  end
  self.Top.Paint = function(pnl, w, h)
    local roundedBottom = self:GetTall() <= self:GetTopHeight()

    local col = self:GetCategoryColor()
    local xOffset = col and 4 or 0
    if (xOffset > 0) then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), 0, 0, w * 0.4, h, col, true, true, roundedBottom, roundedBottom)
    end
    if col then
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, !col, roundedBottom)
    else
      XeninUI:DrawRoundedBoxEx(self:GetRounded(), xOffset, 0, w - xOffset, h, pnl.background, !col, true, roundedBottom, roundedBottom)
    end
    local x = self:GetXOffset()
    if self:GetIcon() then
      local iconSize = self:GetIconSize()
      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(pnl.textColor)
      surface.DrawTexturedRect(self:GetIconOffset(), self:GetIconOffset(), iconSize, iconSize)

      x = h
    end

    draw.SimpleText(self:GetName(), self:GetFont(), x, h * 0.5, pnl.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    local size = h / 3
    XeninUI:DrawIconRotated(w - size * 0.5 - 16, h * 0.5, size, size, pnl.rotation, pnl, pnl.textColor)
  end
  self.Top.DoClick = function(pnl)
    self:Expand(!self:GetExpanded())
  end

  self:SetAnimTime(0.3)
  self:SetAnimateChanges(false)
  self:SetTall(self.Top:GetTall())
  self.animSlide = Derma_Anim("Anim", self, self.AnimSlide)
end

function PANEL:AnimSlide(anim, delta, data)
  self:InvalidateLayout()
  self:InvalidateParent()

  if anim.Started then
    if (IsValid(self.Layout) and self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    if self:GetExpanded() then
      self:SizeToChildren(false, true)
    else
      self:SetTall(self.Top:GetTall())
    end

    data.to = self:GetTall()
  end

  self:SetTall(XeninUI:Ease(delta, data.from, data.to - data.from, 1))

  if anim.Finished then
    if (IsValid(self.Layout) and !self:GetExpanded()) then
      self.Layout:SetVisible(false)
    end

    return
  end
end

function PANEL:SetLayoutType(type)
  if IsValid(self.Layout) then
    self.Layout:Remove()
  end

  local panel = type == XENINUI_LAYOUT_GRID and "DIconLayout" or "DListLayout"
  self.Layout = self:Add(panel)
  self.Layout:Dock(FILL)
  self.Layout:DockPadding(self:GetBorder(), self:GetBorder(), self:GetBorder(), self:GetBorder())

  if (panel == "DIconLayout") then
    self.Layout:SetBorder(8)
    self.Layout:SetSpaceY(self:GetLayoutX())
    self.Layout:SetSpaceX(self:GetLayoutY())
    self.Layout.PerformLayout = function(pnl, w, h)
      local children = pnl:GetChildren()
      local count = self:GetColumns()
      local amount = math.max(1, math.floor(#children / count)) * 276
      local width = w / math.min(count, #children)

      local x = 0
      local y = 0

      local spacingX = pnl:GetSpaceX()
      local spacingY = pnl:GetSpaceY()
      local border = pnl:GetBorder()
      local innerWidth = w - border * 2 - spacingX * (count - 1)

      for i, child in ipairs(children) do
        if (!IsValid(child)) then continue end

        child:SetPos(border + x * innerWidth / count + spacingX * x, border + y * child:GetTall() + spacingY * y)
        child:SetSize(innerWidth / count, self:GetGridColumnHeight() or innerWidth / count)

        x = x + 1
        if (x >= count) then
          x = 0
          y = y + 1
        end
      end

      pnl:SizeToChildren(false, true)
    end
  else
    self.Layout:SetTall(self:GetColumnHeight())
  end

  self.m_layoutType = type
end

function PANEL:Expand(state)
  self.Top:LerpColor("textColor", state and self:GetTopTextColorActive() or self:GetTopTextColorHover())
  self.Top:LerpColor("background", state and self:GetTopColorActive() or self:GetTopColorHover())

  local height = state and 48 + self.Layout:GetTall() or 48
  self:SetExpanded(state)

  self.Top.NextHeight = state and self.Top:GetTall() or self:GetTall()
  self.Top:Lerp("NextHeight", height)
  self.invalidateLayout = true

  self:OnToggle(self:GetExpanded())
end

function PANEL:OnToggle(state) end

function PANEL:CalculateHeight(childrenModifier)
  childrenModifier = childrenModifier or 0
  local children = #self.Layout:GetChildren() + childrenModifier
  local columns = self:GetColumns()
  local spacingX = self.Layout:GetSpaceX()
  local spacingY = self.Layout:GetSpaceY()
  local border = self.Layout:GetBorder()
  local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
  local columnHeight = innerWidth / columns
  local height = math.ceil(children / columns) * (self:GetLayoutY() + columnHeight) + spacingY

  return 48 + height, children
end

function PANEL:FeedData(tbl, index, expand)
  self.DataTbl = tbl

  for i, v in pairs(tbl) do
    local panel = self.Layout:Add(self:GetLayoutPanel())

    if (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      panel:Dock(TOP)
      panel:DockMargin(0, 0, 0, self:GetLayoutY())
      panel:SetTall(self:GetColumnHeight())
    end

    if panel.HandleData then
      panel:HandleData(v, i)
    end
  end

  if expand then
    self.Top.textColor = self:GetTopTextColorActive()
    self.Top.background = self:GetTopColorActive()
    self.Top.rotation = 180

    local height = 48
    if (self:GetLayoutType() == XENINUI_LAYOUT_GRID) then
      local columns = self:GetColumns()
      local spacingX = self.Layout:GetSpaceX()
      local spacingY = self.Layout:GetSpaceY()
      local border = self.Layout:GetBorder()
      local innerWidth = (self:GetInstantExpandWidth() > 0 and self:GetInstantExpandWidth() or self:GetWide()) - border * 2 - spacingX * (columns - 1)
      local columnHeight = innerWidth / columns

      height = height + math.ceil(#tbl / columns) * (self:GetLayoutY() + columnHeight) + spacingY
    elseif (self:GetLayoutType() == XENINUI_LAYOUT_ROW) then
      local columns = #tbl
      local y = self:GetLayoutY()
      local columnHeight = self:GetColumnHeight()

      height = height + self:GetBorder() + (columns * columnHeight) + (y * (columns - 1)) + self:GetBorder()
    end

    self:SetExpanded(true)
    self.Top.NextHeight = height
    self:InvalidateLayout(true)

    self:OnToggle(true)
  end

  self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
  draw.RoundedBoxEx(self:GetRounded(), 0, self.Top:GetTall(), w, h - self.Top:GetTall(), self:GetBackgroundColor(), false, false, true, true)
end

function PANEL:Think()
  if self.invalidateLayout then
    self:InvalidateLayout()
  end
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(self:GetTopHeight())
  self:SetTall(self.Top.NextHeight or self.Top:GetTall())
end

vgui.Register("XeninUI.Category", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/units/classes/assert.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Assert",
    isType = function(self, name, errMsg)
      local valType = type(self.val)
      assert(valType == name, errMsg or "Expected \"" .. tostring(self.val) .. "\"\" type to be \"" .. tostring(name) .. "\", but it is type \"" .. tostring(valType) .. "\"")

      return self
    end,
    isTrue = function(self, errMsg)
      self:isType("boolean")
      assert(self.val == true, errMsg or "Boolean is not true")

      return self
    end,
    isFalse = function(self, errMsg)
      self:isType("boolean")
      assert(!self.val, errMsg or "Boolean is not false")

      return self
    end,
    isNil = function(self, errMsg)
      assert(self.val == nil, errMsg or "Excepted nil, got \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\"")

      return self
    end,
    isNotNil = function(self, errMsg)
      assert(self.val != nil, errMsg or "Expected not nil, but got nil")

      return self
    end,
    isNull = function(self, errMsg)
      assert(self.val == NULL, errMsg or "Expected NULL, but got \"" .. tostring(type(self.val)) .. "\"")

      return self
    end,
    isNotNull = function(self, errMsg)
      assert(self.val != NULL, errMsg or "Expected not NULL, but got NULL\"")

      return self
    end,
    isPlayer = function(self)
      assert(IsValid(self.val), "Player entity is not valid")
      assert(self.val:IsPlayer(), "This entity is not a player")

      return self
    end,
    shouldEqual = function(self, compare, errMsg)
      assert(self.val == compare, errMsg or "Expected \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\" to equal \"" .. tostring(compare) .. "\" of type \"" .. tostring(type(compare)) .. "\", it does not")

      return self
    end,
    shouldNotEqual = function(self, compare, errMsg)
      assert(self.val != compare, errMsg or "Expected \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\" to not equal \"" .. tostring(compare) .. "\" of type \"" .. tostring(type(compare)) .. "\", it does")

      return self
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, val, args)
      self.val = val
      self.args = args
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Assert = _class_0
end

--PATH addons/battlepass/lua/battlepass/challenges/buy_kvartir_10.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Купити 10 квартири")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("buy_kvartir_10")

CHALLENGE:AddHook("playerDoorBuy_BattlePass", function(self, ply, _ply)
  if IsValid(_ply) and ply == _ply then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/mer_com4as_2.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Запустить 2 ком.часа за профессию Мэр")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("mer_com4as_2")

CHALLENGE:AddHook("LockdownStarted_BattlePass", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/prodai_20_narcoti4_zacobiv_za_profeciy_narkodiller.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Продай 20 наркотичних засобів за професію наркодиллера")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("prodai_20_narcoti4_zacobiv_za_profeciy_narkodiller")

local itm = {
  ['LCD'] = true,
  ['Мет'] = true,
  ['Кокаїн'] = true,
  ['Кавун Віри'] = true
}

CHALLENGE:AddHook("playerBuyEntity_BattlePass", function(self, ply, _ply, name)
  if IsValid( _ply ) and ply == _ply and _ply:Team() == TEAM_DRUGDiller and (itm[name] or false) then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/spimai_5tix_ludey_za_maniaka.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Спіймай 5-тьох людей за маньяка")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("spimai_5tix_ludey_za_maniaka")

CHALLENGE:AddHook("OnHandcuffed", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and _ply:Team() == TEAM_MANIAK then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/________anticrash/lua/z_anticrash/panels/p_global.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local PANEL = {}

function PANEL:InitOther()
	
	local pWide, pTall = self:GetSize()
	local offset = 10
	local buttonW = pWide-(offset*2)
	local buttonH = 28
	
	-- Prevent overlapping scroll items
	local _, selfY = self:GetPos()
	self:SetPos(0,selfY+offset)
	self:SetSize(pWide,(pTall-offset*2))
	
	-- Vision Button
	local hasGlobalVision = CL_ANTICRASH.ENTVISION.GetGlobalVision()
	
	local function entVisionBtnText()
		return hasGlobalVision and SH_ANTICRASH.Translate("hideEntities") or SH_ANTICRASH.Translate("showEntities")
	end

	local entityVisionBtn = vgui.Create("onyx.Button", self)
	entityVisionBtn:SetPos(offset,5)
	entityVisionBtn:SetSize(buttonW, buttonH)
	entityVisionBtn:SetText(entVisionBtnText())
	entityVisionBtn.DoClick = function(s)
		CL_ANTICRASH.ENTVISION.SetGlobalVision(!hasGlobalVision)
		hasGlobalVision = !hasGlobalVision
		s:SetText(entVisionBtnText())
	end
	
	-- Cleanup Buttons
	local entityVisionBtn = vgui.Create("onyx.Button", self)
	entityVisionBtn:SetPos(offset,buttonH+offset+5)
	entityVisionBtn:SetSize(buttonW, buttonH)
	entityVisionBtn:SetText(SH_ANTICRASH.Translate("freezeEntities"))
	entityVisionBtn.DoClick = function(s)
		net.Start("sv_anticrash_GlobalCleanup")
		net.SendToServer()
	end

end
vgui.Register('p_anticrash_global',PANEL)
--PATH addons/________anticrash/lua/z_anticrash/panels/p_menu.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local PANEL = {}

local menuW, menuH = 500,600

local catBtnSize,catBtnOffset = 72,25

local categoryBtns = {
	{"stats","p_anticrash_stats","https://i.imgur.com/L6Dbwjm.png",60},
	{"users","p_anticrash_users","https://i.imgur.com/1dE2q2H.png",52},
	{"global","p_anticrash_global","https://i.imgur.com/ECLKU9s.png",48},
}

function PANEL:InitOther()
	self:SetTitle("")
	self:SetSize(menuW+catBtnSize+catBtnOffset,menuH)
	self:Center()
	self:MoveToFront()
	self:MakePopup()


	local menuPanel = vgui.Create("onyx.Panel",self)
	menuPanel:Dock(FILL)

	-- Categories
	catPosY = 40

	local sidebar = self:Add('onyx.MiniSidebar')
    sidebar:SetWide(menuW * .18)
    sidebar:Dock(LEFT)
    sidebar:SetContainer(menuPanel)

	for i=1, #categoryBtns do
		
		local cat = categoryBtns[i]

		local tab = sidebar:AddTab({
			name = cat[1],
			desc = '',
			class = cat[2],
			icon = cat[3],
			onSelected = function(panel)
				panel:SetSize(menuW, menuH)
				panel:InitOther()
			end
		})

		if i == 1 then
			sidebar:ChooseTab(tab.tabIndex)
		end
		
	end

end

vgui.Register("p_anticrash_menu",PANEL,"onyx.Frame")

--PATH addons/________anticrash/lua/z_anticrash/shared/sh_meta.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

// ENTITY
local ent = FindMetaTable("Entity")

function ent:z_anticrashIsValidEnt()
	return IsValid(self) and self:CPPIGetOwner()
end

// PLAYER
local ply = FindMetaTable("Player")
local nwFlaggedStr = "z_anticrash_Flagged"
local nwSpawnCountStr = "z_anticrash_SpawnCount"
local nwConstraintCountStr = "z_anticrash_ConstraintCount"

function ply:z_anticrashFlagPlayer(flagNum)
	
	local newFlaggedCount = self:z_anticrashGetFlaggedCount() + (flagNum or 1)
	
	self:SetNWInt(nwFlaggedStr, newFlaggedCount)
	
end

function ply:z_anticrashGetFlaggedCount()
	return self:GetNWInt(nwFlaggedStr)
end

function ply:z_anticrashIncreaseSpawnCount()

	self.__spawnCount = (self.__spawnCount or 0) + 1
	
	-- Timer to avoid overflowing the net channel when rapidly setting value
	timer.Create("z_anticrash_SpawnCount", 0.1, 1, function()
		self:SetNWInt(nwSpawnCountStr, self.__spawnCount)
	end)

end

function ply:z_anticrashGetSpawnCount()
	return self:GetNWInt(nwSpawnCountStr)
end

function ply:z_anticrashSetConstraintCount(num)
	self:SetNWInt(nwConstraintCountStr, num)
end

function ply:z_anticrashGetConstraintCount()
	return self:GetNWInt(nwConstraintCountStr)
end
--PATH addons/__advdupe2/lua/advdupe2/cl_file.lua:
local invalidCharacters = { "\"", ":"}
function AdvDupe2.SanitizeFilename(filename)
	for i=1, #invalidCharacters do
		filename = string.gsub(filename, invalidCharacters[i], "_")
	end
	filename = string.gsub(filename, "%s+", " ")

	return filename
end

function AdvDupe2.ReceiveFile(data)
	AdvDupe2.RemoveProgressBar()
	if not data then
		AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
		return
	end
	local path = AdvDupe2.GetFilename(AdvDupe2.SavePath)

	path = AdvDupe2.SanitizeFilename(path)
	local dupefile = file.Open(path, "wb", "DATA")
	if not dupefile then
		AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
		return
	end
	dupefile:Write(data)
	dupefile:Close()

	local errored = false
	if(LocalPlayer():GetInfo("advdupe2_debug_openfile")=="1")then
		if(not file.Exists(path, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end

		local readFile = file.Open(path, "rb", "DATA")
		if not readFile then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local success,dupe,info,moreinfo = AdvDupe2.Decode(readData)
		if(success)then
			AdvDupe2.Notify("DEBUG CHECK: File successfully opens. No EOF errors.")
		else
			AdvDupe2.Notify("DEBUG CHECK: " .. dupe, NOTIFY_ERROR)
			errored = true
		end
	end

	local filename = string.StripExtension(string.GetFileFromFilename( path ))
	AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode:AddFile(filename)
	AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode)

	if(!errored)then
		AdvDupe2.Notify("File successfully saved!",NOTIFY_GENERIC, 5)
	end
end

net.Receive("AdvDupe2_ReceiveFile", function()
	net.ReadStream(nil, function(data)
		AdvDupe2.ReceiveFile(data)
	end)
end)

AdvDupe2.Uploading = false
function AdvDupe2.SendFile(name, data)
	net.Start("AdvDupe2_ReceiveFile")
	net.WriteString(name)
	AdvDupe2.Uploading = net.WriteStream(data, function()
		AdvDupe2.Uploading = nil
		AdvDupe2.File = nil
		AdvDupe2.RemoveProgressBar()
	end)
	net.SendToServer()
end

function AdvDupe2.UploadFile(ReadPath, ReadArea)
	if AdvDupe2.Uploading then AdvDupe2.Notify("Already opening file, please wait.", NOTIFY_ERROR) return end
	if(ReadArea==0)then
		ReadPath = AdvDupe2.DataFolder.."/"..ReadPath..".txt"
	elseif(ReadArea==1)then
		ReadPath = AdvDupe2.DataFolder.."/-Public-/"..ReadPath..".txt"
	else
		ReadPath = "adv_duplicator/"..ReadPath..".txt"
	end

	if(not file.Exists(ReadPath, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end

	local read = file.Read(ReadPath)
	if not read then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
	local name = string.Explode("/", ReadPath)
	name = name[#name]
	name = string.sub(name, 1, #name-4)

	local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
	if(success)then
		AdvDupe2.SendFile(name, read)

		AdvDupe2.LoadGhosts(dupe, info, moreinfo, name)
	else
		AdvDupe2.Notify("File could not be decoded. ("..dupe..") Upload Canceled.", NOTIFY_ERROR)
	end
end

--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/french.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "french", {
    ["search"] = "Rechercher",
    ["invalidPlayerProfile"] = "Profil de joueur invalide",
    ["unbound"] = "NON ASSIGNER",
    ["themes"] = "Thèmes",
    ["groups"] = "Groupes",
    ["general"] = "General",
    ["itemWhitelisting"] = "Whitelist d'items",
    ["rarities"] = "Rareté",
    ["languages"] = "Langues",
    ["disabled"] = "Désactivé",
    ["enabled"] = "Activé",
    ["purchase"] = "Acheter",
    ["profile"] = "Profil",
    ["view"] = "Inspecter",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Vous n'avez pas la permission d'utiliser cet outil.",
    ["settings"] = "Paramètres",
    ["players"] = "Joueurs",
    ["modules"] = "Modules",

    ["userGroupEditor"] = "Éditeur de groupes",
    ["addNewGroup"] = "Ajouter un groupe",
    ["newUserGroup"] = "Quel devrait être le nouveau groupe?",
    ["groupName"] = "GroupName",

    ["custom"] = "Custom",
    ["addNew"] = "Ajouter un nouveau",
    ["material"] = "Material",
    ["directImage"] = "Entrez une URL d'image directe ci-dessous.",
    ["default"] = "Default",
    ["selectMaterial"] = "Vous devez choisir un material",

    ["errorNoText"] = "ERREUR: AUCUN TEXT",
    ["selectOption"] = "Sélectionnez une option",
    ["selectValue"] = "Veuillez sélectionner une valeur.",
    ["selectColor"] = "Veuillez choisir une couleur.",
    ["configSaved"] = "Config sauvegardé!",
    ["cmdNoPermission"] = "Vous n'avez pas la permission d'utiliser cette commande.",
    ["entityPosUpdated"] = "Positions des entités mise à jour!",
    ["noEntitiesSpawned"] = "Aucune entité sauvée n'a été spawn.",
    ["xEntitiesSpawned"] = "%d entités sauvées ont été spawn.",
    ["error"] = "ERREUR",

    ["seconds"] = "%d secondes",
    ["second"] = "%d seconde",
    ["minutes"] = "%d minutes",
    ["minute"] = "%d minute",
    ["hours"] = "%d heures",
    ["hour"] = "%d heure",

    ["noRarity"] = "Aucune rareté",

    ["config"] = "Config",
    ["edit"] = "Modifier",
    ["editColor"] = "Changer la couleur",
    ["editName"] = "Changer le nom",
    ["remove"] = "Supprimer",
    ["name"] = "Nom",
    ["description"] = "Description",
    ["model"] = "Model",
    ["icon"] = "Icon",
    ["type"] = "Type",
    ["price"] = "Prix",
    ["group"] = "Group",
    ["category"] = "Categorie",
    ["color"] = "Couleur",
    ["invalidType"] = "Type invalide.",
    ["invalidOption"] = "Option invalide .",
    ["invalidChoice"] = "Choix invalide.",
    ["invalidGroup"] = "Group invalide.",
    ["invalidPlayer"] = "Joueur invalide.",
    ["true"] = "TRUE",
    ["false"] = "FALSE",
    ["noDescription"] = "Aucune description",
    ["other"] = "Autres",
    ["completed"] = "Achevé",
    ["close"] = "Fermer",
    ["main"] = "Main",
    
    ["valueQuery"] = "Que devrait être le %s ?",
    ["dataValueQuery"] = "Qu'est ce que cela devrait être ?",
    ["newNameQuery"] = "Quel devrait être le nouveau nom ?",
    ["newDescriptionQuery"] = "Quelle devrait être la nouvelle description ?",
    ["newModelQuery"] = "Quel devrait être le nouveau modèle ?",
    ["newIconQuery"] = "Que devrait être la nouvelle icône ?",
    ["newColorQuery"] = "Quelle devrait être la nouvelle couleur?",
    ["npcTypeQuery"] = "Quel doit être le type de ce NPC ?",
    ["newTypeQuery"] = "Que devrait être le nouveau type",
    ["groupRequirementQuery"] = "Quelle devrait être les conditions de groupe ?",
    ["levelRequirementQuery"] = "Quelle devrait être les conditions de level ?",
    ["newPriceQuery"] = "Quel devrait être le nouveau prix ?",
    ["newCategoryQuery"] = "Quelle devrait être la nouvelle catégorie ?",

    ["npcEditor"] = "Editeur de NPC",
    ["addNPC"] = "Ajouter un NPC",
    ["newNPC"] = "Nouveau NPC",

    ["ok"] = "OK",
    ["cancel"] = "Annuler",
    ["save"] = "Sauvegarder",
    ["confirm"] = "Confirmer",
    ["nil"] = "NIL",
    ["none"] = "Aucun",
    ["selected"] = "Sélectionné",
    ["unselected"] = "Désélectionnée",
    ["add"] = "Ajouter",

    ["shootyStick"] = "Un bâton qui tire!",
    ["permanent"] = "Permanent",
    ["tierX"] = "(Tier %d)",
    ["someDescription"] = "Une description.",
    ["invalidNPC"] = "ERREUR : NPC invalide",

    ["disconnected"] = "Déconnecté",
    ["profileView"] = "Profil",
    ["loading"] = "Chargement",
    ["statistics"] = "Statistiques",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Donation Rank",
    ["staffRank"] = "Staff Rank",
    ["currentJob"] = "Emploi actuel",
    ["wallet"] = "Portefeuille",
    ["level"] = "Level",
    ["levelX"] = "Level %d",
    ["experience"] = "Experience",
    ["exp"] = "EXP",
    ["money"] = "Argent",
    ["playerLogs"] = "Player Logs",
    ["deleteLogs"] = "Delete logs",
    ["xLogs"] = "%d logs",
    ["xAdminGroups"] = "%d Admin Groups",
    ["noUserGroups"] = "No user groups",
    ["userGroups"] = "User groups: %s",
    ["editUserGroups"] = "Modifier les  user groups",
    ["newGroupColor"] = "Quelle devrait être la nouvelle couleur du groupe?",
    ["newGroupName"] = "Quel devrait être le nouveau nom du groupe?",
    ["groupAlreadyExists"] = "Ce groupe existe déjà !",
    ["whitelist"] = "Whitelist",
    ["unWhitelist"] = "UnWhitelist",
    ["addCustom"] = "Add custom",
    ["entClassWhitelist"] = "Quelle classe d'entité souhaitez-vous mettre sur la whitelist ?",
    ["entClassAlreadyOnList"] = "Cette classe d'entités figure déjà sur la liste!",
    ["changesServerRestart"] = "Certains changements ne prendront pas effet tant que le serveur ne sera pas redémarré !",
    ["comingSoon"] = "Coming Soon!",
    ["features"] = "FEATURES",
    ["addNewRarity"] = "Ajouter une nouvelle rareté",
    ["newRarity"] = "Nouvelle rareté",
    ["needToAddRarity"] = "Vous devez d'abord ajouter un type de rareté !",
    ["whatRarityItem"] = "Quelle devrait être la rareté de cet objet ?",
    ["invalidRarity"] = "Rareté invalide.",
    ["rarityAlreadyExists"] = "Une rareté avec ce nom existe déjà!",
    ["themeColorX"] = "Theme - Color %d",
    ["themeTextColor"] = "Theme - Text Color",
    ["presetAccents"] = "Accents prédéfinis",
    ["presetBackgrounds"] = "Arrière-plan prédéfini",
    ["resetToBaseThemes"] = "Rétablir le thème de bases",
    ["resetToCurrentThemes"] = "Rétablir le thèmes actuels",
    ["toggle"] = "Activer",
    ["menu"] = "Menu",
    ["emptyValue"] = "EMPTY VALUE",
    ["newValueQuery"] = "Quelle devrait être la nouvelle valeur ?",
    ["pressKey"] = "APPUYEZ SUR UNE TOUCHE",

    ["entityPlacer"] = "Entity Placer",
    ["invalidEntityType"] = "Type d'entité invalide, choisissez un type d'entité valide dans le menu d'outils.",
    ["entityPlaced"] = "Entité placée avec succès.",
    ["entityRemoved"] = "Entité retirée avec succès.",
    ["canOnlyUseToolEntity"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer une entité.",
    ["entityType"] = "Type d'entité",
    ["entityPlacerDescription"] = "Place et retire des entités du serveur et enregistre leurs positions. Clic gauche - placer. Clic droit - supprimer.",
    ["entityPlacerDescriptionSmall"] = "Placement et déplacement d'entités",
    ["entityPlacerInstructions"] = "Clic gauche - placer, Clic droit - supprimer.",

    ["npcPlacer"] = "NPC Placer",
    ["npcPlaced"] = "NPC placé avec succès.",
    ["invalidNPCType"] = "Type de NPC invalide, choisissez un NPC valide dans le menu d'outils.",
    ["npcRemoved"] = "Le NPC a été supprimé avec succès.",
    ["errorNotNPC"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer un NPC.",
    ["npcPlacerDescription"] = "Place et retire les NPCs du serveur , Clic gauche - placer, Clic droit - retirer.",
    ["npcPlacerDescriptionSmall"] = "Placer et retirer des NPCs.",

    ["inventory"] = "Inventaire",
    ["player"] = "Joueur",
    ["drop"] = "Lâcher",
    ["use"] = "Utiliser",
    ["dropAll"] = "Tout lâcher",
    ["delete"] = "Supprimer",
} )
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_drawing.lua:
function BRICKS_SERVER.Func.ScreenScale( number, min, max )
    number = number*(ScrW()/2560)

    if( min and max ) then
        return math.Clamp( number, min, max )
    elseif( min or max ) then
        return min and math.max( min, number ) or math.min( max, number )
    else
        return number
    end
end

BRICKS_SERVER.UI = {
	Margin5 = BRICKS_SERVER.Func.ScreenScale( 5 ),
	Margin10 = BRICKS_SERVER.Func.ScreenScale( 10 ),
	Margin15 = BRICKS_SERVER.Func.ScreenScale( 15 ),
	Margin25 = BRICKS_SERVER.Func.ScreenScale( 25 ),
	Margin50 = BRICKS_SERVER.Func.ScreenScale( 50 ),
	Margin100 = BRICKS_SERVER.Func.ScreenScale( 100 )
}

function BRICKS_SERVER.Func.Repeat( val, amount )
	local args = {}
	for i = 1, amount do
		table.insert( args, val )
	end

	return unpack( args )
end

BRICKS_SERVER.DEVCONFIG.MainNavWidth = BRICKS_SERVER.Func.ScreenScale( 230 )
hook.Add( "OnScreenSizeChanged", "BRS.OnScreenSizeChanged.DevConfig", function()
    BRICKS_SERVER.DEVCONFIG.MainNavWidth = BRICKS_SERVER.Func.ScreenScale( 230 )
end )

--[[ FONTS ]]--
local function createFonts()
	surface.CreateFont( "BRICKS_SERVER_Font90", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 90 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font25", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 25 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font24", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 24 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_NoSC_Font24", {
		font = "Montserrat Medium",
		extended = false,
		size = 24,
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font23", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 23 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font20", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 20 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_NoSC_Font20", {
		font = "Montserrat Medium",
		extended = false,
		size = 20,
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font17", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 17 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_NoSC_Font17", {
		font = "Montserrat Medium",
		extended = false,
		size = 17,
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font17B", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 17 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font18", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 18 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font19", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 19 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font20B", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 20 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font26", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 26 ),
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font30", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 27 ),
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font32", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 32 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font33", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 33 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_NoSC_Font33", {
		font = "Montserrat Medium",
		extended = false,
		size = 33,
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font28B", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 28 ),
		weight = 650,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font36B", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 38 ),
		weight = 650,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font40", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 40 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_NoSC_Font40", {
		font = "Montserrat Medium",
		extended = false,
		size = 40,
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font45", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 45 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font40B", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 40 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font50", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 70 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font53", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 53 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font20", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 20 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font11", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 11 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font13", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 13, 10 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font15", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 15 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font22B", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 22 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font21", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 21 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font22", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 22 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font23B", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 23 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_HUDFont", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 27 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font31", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 31 ),
		weight = 500,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_HUDFontS", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 25 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_HUDFontB", {
		font = "Montserrat Medium",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 30 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font100", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 75 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font50", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 50 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font30B", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 30 ),
		weight = 5000,
		outline = false,
	} )

	surface.CreateFont( "BRICKS_SERVER_Font60B", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 60 ),
		weight = 5000,
		outline = false,
	} )

	-- New Fonts
	surface.CreateFont( "BRS.Font.Bold20", {
		font = "Montserrat Bold",
		extended = false,
		size = BRICKS_SERVER.Func.ScreenScale( 20 ),
		weight = 500,
		outline = false,
	} )
end
createFonts()

hook.Add( "OnScreenSizeChanged", "BRS.OnScreenSizeChanged.Fonts", createFonts )

--[[ FUNCTIONS ]]--
local blur = Material("pp/blurscreen")
function BRICKS_SERVER.Func.DrawBlur( p, a, d )
	local x, y = p:LocalToScreen(0, 0)
	surface.SetDrawColor( 255, 255, 255 )
    surface.SetMaterial( blur )
    
	for i = 1, d do
		blur:SetFloat( "$blur", (i / d ) * ( a ) )
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
	end
end

local panelMeta = FindMetaTable( "Panel" )
function panelMeta:SetBRSToolTip( posX, posY, sizeW, sizeH, text, visiblePanel )
	self.OnCursorEntered = function()
		if( self.Menu and IsValid( self.Menu ) ) then return end
		
		if( IsValid( BRS_TOOLTIP ) ) then
			BRS_TOOLTIP:Remove()
		end

		local textTable = text
		if( not istable( text ) ) then
			textTable = { text }
		end

		BRS_TOOLTIP = vgui.Create( "DPanel" )
		BRS_TOOLTIP:MakePopup()
		BRS_TOOLTIP:DockPadding( 10, 5, 0, 0 )
		BRS_TOOLTIP.Paint = function( self2, w, h )
			BRICKS_SERVER.BSHADOWS.BeginShadow()
			local x, y = self2:LocalToScreen( 0, 0 )
			draw.RoundedBox( 8, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )			
			BRICKS_SERVER.BSHADOWS.EndShadow(1, 1, 1, 255, 0, 0, false )
		end

		local textX, textY = 0, 0
		for k, v in pairs( textTable ) do
			local textString = v
			local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
			local textFont = "BRICKS_SERVER_Font20"
			if( istable( v ) ) then
				textString = v[1] or BRICKS_SERVER.Func.L( "errorNoText" )
				textColor = v[2] or BRICKS_SERVER.Func.GetTheme( 6 )
				textFont = v[3] or "BRICKS_SERVER_Font20"
			end

			surface.SetFont( textFont )
			
			local newTextX, newTextY = surface.GetTextSize( textString )
			if( newTextX > textX ) then
				textX = newTextX
			end
			textY = textY+newTextY

			local textPanel = vgui.Create( "DLabel", BRS_TOOLTIP )
			textPanel:SetText( textString )
			textPanel:SetFont( textFont )
			textPanel:Dock( TOP )
			textPanel:SetTall( newTextY )

			if( isfunction( textColor ) ) then
				textPanel.Think = function()
					textPanel:SetTextColor( textColor() )
				end
			else
				textPanel:SetTextColor( textColor )
			end
		end

		BRS_TOOLTIP:SetSize( textX+20, textY+10 )
		BRS_TOOLTIP:SetPos( posX+sizeW+5, posY+(sizeH*0.5)-(BRS_TOOLTIP:GetTall()*0.5) )
		BRS_TOOLTIP:SetAlpha( 0 )
		BRS_TOOLTIP:AlphaTo( 255, 0.1 )
		BRS_TOOLTIP.Think = function()
			if( IsValid( BRS_TOOLTIP ) and not self:IsHovered() ) then
				BRS_TOOLTIP:Remove()
			end
		end
	end

	self.OnCursorExited = function()
		if( IsValid( BRS_TOOLTIP ) ) then
			BRS_TOOLTIP:Remove()
		end
	end

	self.OnRemove = function()
		if( IsValid( BRS_TOOLTIP ) ) then
			BRS_TOOLTIP:Remove()
		end
	end
end

local entityMeta = FindMetaTable( "Entity" )
function entityMeta:SetBRSEntityToolTip( text )
	if( not IsValid( self ) ) then return end

	if( not BRS_ENTITY_TOOLTIPS ) then
		BRS_ENTITY_TOOLTIPS = {}
	end

	local textTable = text
	if( not istable( text ) ) then
		textTable = { text }
	end

	local textX, textY = 0, 0
	for k, v in pairs( textTable ) do
		local textString = v
		local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
		local textFont = "BRICKS_SERVER_Font20"
		if( istable( v ) ) then
			textString = v[1] or BRICKS_SERVER.Func.L( "errorNoText" )
			textColor = v[2] or BRICKS_SERVER.Func.GetTheme( 6 )
			textFont = v[3] or "BRICKS_SERVER_Font20"
		end

		surface.SetFont( textFont )
		
		local newTextX, newTextY = surface.GetTextSize( textString )
		if( newTextX > textX ) then
			textX = newTextX
		end
		textY = textY+newTextY
	end

	BRS_ENTITY_TOOLTIPS[self] = { textTable, textX+20, textY+10 }
end

hook.Add( "HUDPaint", "BRS.HUDPaint.EntityToolTips", function()
	if( LocalPlayer():GetEyeTrace() and LocalPlayer():GetEyeTrace().HitPos ) then
		local hitPos = LocalPlayer():GetEyeTrace().HitPos

		if( LocalPlayer():GetPos():DistToSqr( hitPos ) > 10000 ) then return end

		local entTable = {}
		for k, v in ipairs( ents.FindInSphere( hitPos, 25 ) ) do
			if( IsValid( v ) and BRS_ENTITY_TOOLTIPS and BRS_ENTITY_TOOLTIPS[v] ) then
				table.insert( entTable, { hitPos:DistToSqr( v:GetPos() ), v } )
			end
		end

		table.sort( entTable, function(a, b) return a[1] < b[1] end )

		local ent = (entTable[1] or {})[2]
		if( ent and IsValid( ent ) ) then
			local pos = Vector( ent:GetPos().x, ent:GetPos().y, ent:GetPos().z+25 )
			local pos2d = pos:ToScreen()

			local textTable, width, height = BRS_ENTITY_TOOLTIPS[ent][1], BRS_ENTITY_TOOLTIPS[ent][2], BRS_ENTITY_TOOLTIPS[ent][3]
			local xPos, yPos = pos2d.x, pos2d.y

			draw.RoundedBox( 5, xPos, yPos, width, height, BRICKS_SERVER.Func.GetTheme( 0 ) )

			local textX, textY = 0, 0
			for i = 1, #textTable do
				local textString = textTable[i] or ""
				local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
				local textFont = "BRICKS_SERVER_Font20"
				if( istable( textTable[i] ) ) then
					textString = textTable[i][1] or BRICKS_SERVER.Func.L( "errorNoText" )
					textColor = textTable[i][2] or BRICKS_SERVER.Func.GetTheme( 6 )
					textFont = textTable[i][3] or "BRICKS_SERVER_Font20"
				end

				draw.SimpleText( textString, textFont, xPos+10, yPos+5+textY, ((isfunction( textColor ) and textColor()) or textColor), 0, 0 )
	
				surface.SetFont( textFont )
				
				local newTextX, newTextY = surface.GetTextSize( textString )
				if( newTextX > textX ) then
					textX = newTextX
				end
				textY = textY+newTextY
			end
		end
	end
end )

hook.Add( "EntityRemoved", "BRS.EntityRemoved.RemoveEntityToolTips", function( ent )
	if( BRS_ENTITY_TOOLTIPS and BRS_ENTITY_TOOLTIPS[ent] ) then
		BRS_ENTITY_TOOLTIPS[ent] = nil
	end
end )

local notifQueue = {}
local function createNotif()
	if( not notifQueue[1] ) then return end

	local headerText, headerColor, subText, subColor = notifQueue[1][1], notifQueue[1][2], notifQueue[1][3], notifQueue[1][4]

	surface.PlaySound( "common/warning.wav" )

	BRS_CENTER_NOTIF_PANEL = vgui.Create( "DPanel" )
	BRS_CENTER_NOTIF_PANEL:SetSize( ScrW(), ScrH() )
	BRS_CENTER_NOTIF_PANEL:SetPos( -BRS_CENTER_NOTIF_PANEL:GetWide(), (ScrH()*0.5)-(BRS_CENTER_NOTIF_PANEL:GetTall()*0.5) )
	BRS_CENTER_NOTIF_PANEL:MoveTo( (ScrW()*0.5)-(BRS_CENTER_NOTIF_PANEL:GetWide()*0.5), (ScrH()*0.5)-(BRS_CENTER_NOTIF_PANEL:GetTall()*0.5), 0.5, 0, 1 )
	local spacing = 4
	BRS_CENTER_NOTIF_PANEL.Paint = function( self, w, h )
		draw.SimpleText( headerText, "BRICKS_SERVER_Font53", w*0.5-1, h/3+1+spacing, BRICKS_SERVER.Func.GetTheme( 3 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( headerText, "BRICKS_SERVER_Font53", w*0.5, h/3+spacing, headerColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( subText, "BRICKS_SERVER_Font30", w*0.5-1, h/3+1-spacing, BRICKS_SERVER.Func.GetTheme( 3 ), TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( subText, "BRICKS_SERVER_Font30", w*0.5, h/3-spacing, subColor, TEXT_ALIGN_CENTER, 0 )
	end
	
	timer.Simple( 3, function()
		if( IsValid( BRS_CENTER_NOTIF_PANEL ) ) then
			BRS_CENTER_NOTIF_PANEL:MoveTo( ScrW(), (ScrH()*0.5)-(BRS_CENTER_NOTIF_PANEL:GetTall()*0.5), 0.5, 0, 1, function()
				if( IsValid( BRS_CENTER_NOTIF_PANEL ) ) then
					BRS_CENTER_NOTIF_PANEL:Remove()
					table.remove( notifQueue, 1 )
					createNotif()
				end
			end )
		end
	end )
end

function BRICKS_SERVER.Func.AddCenterNotification( headerText, headerColor, subText, subColor )
	if( BRS_CENTER_NOTIF_PANEL and IsValid( BRS_CENTER_NOTIF_PANEL ) ) then 
		for k, v in pairs( notifQueue ) do
			if( v[1] == headerText and v[3] == subText ) then
				return
			end
		end

		table.insert( notifQueue, { headerText, headerColor, subText, subColor } )
	else
		table.insert( notifQueue, { headerText, headerColor, subText, subColor } )
		createNotif()
	end
end

--[[ PAINTING ]]--
function BRICKS_SERVER.Func.DrawProgress( text, status )
	if( status >= 1 ) then return end
	
	local width, height = ScrW()*0.1, 10
	local y = (ScrH()/4)*3-50

	draw.RoundedBox( 5, (ScrW()*0.5)-(width*0.5), y, width, height, BRICKS_SERVER.Func.GetTheme( 3 ))

	draw.RoundedBox( 5, (ScrW()*0.5)-(width*0.5), y, width*math.Clamp( status, 0, 1 ), height, BRICKS_SERVER.Func.GetTheme( 5 ) )
end

local gradientDown = Material( 'vgui/gradient_down' )
local gradientUp = Material( 'vgui/gradient_up' )
local gradientLeft = Material( 'vgui/gradient-l' )
local gradientRight = Material( 'vgui/gradient-r' )
function BRICKS_SERVER.Func.DrawMaterialShadow( x, y, w, h, GradientType )
	if( GradientType == "Down" ) then
		surface.SetMaterial( gradientDown )
	elseif( GradientType == "Up" ) then
		surface.SetMaterial( gradientUp )	
	elseif( GradientType == "Left" ) then
		surface.SetMaterial( gradientLeft )	
	elseif( GradientType == "Right" ) then
		surface.SetMaterial( gradientRight )
	end
	surface.SetDrawColor( 0, 0, 0, 175 )
	surface.DrawTexturedRect( x, y, w, h )
end

function BRICKS_SERVER.Func.DrawCircle( x, y, radius, color )
	if( radius <= 0 ) then return end
	
	if( color and istable( color ) and color.r and color.g and color.b ) then
		surface.SetDrawColor( color )
	end
	
	draw.NoTexture()

	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, 45 do
		local a = math.rad( ( i / 45 ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) * 0.5 + 0.5, v = math.cos( a ) * 0.5 + 0.5 } )
	end

	local a = math.rad( 0 ) -- This is needed for non absolute segment counts
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) * 0.5 + 0.5, v = math.cos( a ) * 0.5 + 0.5 } )

	surface.DrawPoly( cir )
end

function BRICKS_SERVER.Func.PrecachedArc( cx, cy, radius, thickness, startang, endang, roughness )
	local triarc = {}
	-- local deg2rad = math.pi / 180
	
	-- Define step
	local roughness = math.max(roughness or 1, 1)
	local step = roughness
	
	-- Correct start/end ang
	local startang,endang = startang or 0, endang or 0
	
	if startang > endang then
		step = math.abs(step) * -1
	end
	
	-- Create the inner circle's points.
	local inner = {}
	local r = radius - thickness
	for deg=startang, endang, step do
		local rad = math.rad(deg)
		-- local rad = deg2rad * deg
		local ox, oy = cx+(math.cos(rad)*r), cy+(-math.sin(rad)*r)
		table.insert(inner, {
			x=ox,
			y=oy,
			u=(ox-cx)/radius + .5,
			v=(oy-cy)/radius + .5,
		})
	end	
	
	-- Create the outer circle's points.
	local outer = {}
	for deg=startang, endang, step do
		local rad = math.rad(deg)
		-- local rad = deg2rad * deg
		local ox, oy = cx+(math.cos(rad)*radius), cy+(-math.sin(rad)*radius)
		table.insert(outer, {
			x=ox,
			y=oy,
			u=(ox-cx)/radius + .5,
			v=(oy-cy)/radius + .5,
		})
	end	
	
	-- Triangulize the points.
	for tri=1,#inner*2 do -- twice as many triangles as there are degrees.
		local p1,p2,p3
		p1 = outer[math.floor(tri*0.5)+1]
		p3 = inner[math.floor((tri+1)*0.5)+1]
		if tri%2 == 0 then --if the number is even use outer.
			p2 = outer[math.floor((tri+1)*0.5)]
		else
			p2 = inner[math.floor((tri+1)*0.5)]
		end
	
		table.insert(triarc, {p1,p2,p3})
	end
	
	-- Return a table of triangles to draw.
	return triarc
end

function BRICKS_SERVER.Func.DrawCachedArc( arc, color )
	draw.NoTexture()

	if( color ) then
		surface.SetDrawColor( color )
	end

	for k,v in ipairs(arc) do
		surface.DrawPoly(v)
	end
end


function BRICKS_SERVER.Func.DrawArc( cx, cy, radius, thickness, startang, endang, color )
	BRICKS_SERVER.Func.DrawCachedArc( BRICKS_SERVER.Func.PrecachedArc( cx, cy, radius, thickness, startang, endang ), color )
end

local radiusAnim, fadeAnim, endRadius = 0.2, 0.2, 0
function BRICKS_SERVER.Func.DrawClickCircle( panel, w, h, color, cornerRadius )
	if( panel:IsDown() and not panel.doClickAnim ) then
		endRadius = math.sqrt( ((w*0.5)^2)+((h*0.5)^2) )
		panel.doClickAnimEndTime = CurTime()+radiusAnim+fadeAnim
		panel.doClickAnim = true
	end

	if( panel.doClickAnim ) then
		local timeLeft = (panel.doClickAnimEndTime or 0)-CurTime()
		if( timeLeft <= 0 ) then
			panel.doClickAnimEndTime = nil
			panel.doClickAnim = false
		end

		local radiusTimeLeft = (panel.doClickAnimEndTime or 0)-fadeAnim-CurTime()
		local radius = endRadius*math.Clamp( (radiusAnim-radiusTimeLeft)/radiusAnim, 0, 1 )

		local fade = 1
		if( CurTime() >= (panel.doClickAnimEndTime or 0)-fadeAnim ) then
			fade = math.Clamp( timeLeft/fadeAnim, 0, 1 )
		end

		surface.SetAlphaMultiplier( fade )
		draw.NoTexture()
		surface.SetDrawColor( color )
		if( cornerRadius ) then
			BRICKS_SERVER.Func.DrawRoundedMask( cornerRadius, 0, 0, w, h, function()
				BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, radius, radius )
			end )
		else
			BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, radius, radius )
		end
		surface.SetAlphaMultiplier( 1 )

	end
end

local g_grds, g_wgrd, g_sz
function BRICKS_SERVER.Func.DrawGradientBox(x, y, w, h, al, ...)
	g_grds = {...}

	x = math.Round( x )
	y = math.Round( y )
	w = math.Round( w )
	h = math.Round( h )

	al = math.Clamp(math.floor(al), 0, 1)
	if(al == 1) then
		local t = w
		w, h = h, t
	end
	g_wgrd = w / (#g_grds - 1)
	local n
	for i = 0, w do
		for c = 1, #g_grds do
			n = c
			if(i <= g_wgrd * c) then
				break
			end
		end
		g_sz = i - (g_wgrd * (n - 1))
		surface.SetDrawColor(
			Lerp(g_sz/g_wgrd, g_grds[n].r, g_grds[n + 1].r),
			Lerp(g_sz/g_wgrd, g_grds[n].g, g_grds[n + 1].g),
			Lerp(g_sz/g_wgrd, g_grds[n].b, g_grds[n + 1].b),
			Lerp(g_sz/g_wgrd, g_grds[n].a, g_grds[n + 1].a))
		if(al == 1) then
			surface.DrawRect(x, y + i, h, 1)
		else
			surface.DrawRect(x + i, y, 1, h)
		end
	end
end

local gradientMatR, gradientMatU, gradientMatD = Material("gui/gradient"), Material("gui/gradient_up"), Material("gui/gradient_down")
function BRICKS_SERVER.Func.DrawTexturedGradientBox(x, y, w, h, direction, ...)
	local colors = {...}
	local horizontal = direction != 1
	local secSize = math.ceil( ((horizontal and w) or h)/math.ceil( #colors*0.5 ) )
	
	local previousPos = (horizontal and x or y)-secSize
	for k, v in pairs( colors ) do
		if( k % 2 != 0 ) then
			previousPos = previousPos+secSize
			surface.SetDrawColor( v )
			surface.DrawRect( (horizontal and previousPos or x), (horizontal and y or previousPos), (horizontal and secSize or w), (horizontal and h or secSize) )
		end
	end

	local previousGradPos = (horizontal and x or y)-secSize
	for k, v in pairs( colors ) do
		if( k % 2 == 0 ) then
			previousGradPos = previousGradPos+secSize
			surface.SetDrawColor( v )
			surface.SetMaterial( horizontal and gradientMatR or gradientMatU )
			if( horizontal ) then
				surface.DrawTexturedRectUV( (horizontal and previousGradPos or x), (horizontal and y or previousGradPos), (horizontal and secSize or w), (horizontal and h or secSize), 1, 0, 0, 1)
			else
				surface.DrawTexturedRect( (horizontal and previousGradPos or x), (horizontal and y or previousGradPos), (horizontal and secSize or w), (horizontal and h or secSize))
			end

			if( colors[k+1] ) then
				surface.SetDrawColor( v )
				surface.SetMaterial( horizontal and gradientMatR or gradientMatD )
				surface.DrawTexturedRect((horizontal and previousGradPos+secSize or x), (horizontal and y or previousGradPos+secSize), (horizontal and secSize or w), (horizontal and h or secSize))
			end
		end
	end
end

-- Credits: https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/modules/draw.lua, https://gist.github.com/MysteryPancake/e8d367988ef05e59843f669566a9a59f
BRICKS_SERVER.MaskMaterial = CreateMaterial("!brsmask","UnlitGeneric",{
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
})

local whiteColor = Color( 255, 255, 255 )
local renderTarget
function BRICKS_SERVER.Func.DrawRoundedMask( cornerRadius, x, y, w, h, drawFunc )
	if( not renderTarget ) then
		renderTarget = GetRenderTargetEx( "BRS_GRADIENT_ROUNDEDBOX", ScrW(), ScrH(), RT_SIZE_FULL_FRAME_BUFFER, MATERIAL_RT_DEPTH_NONE, 2, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888 )
	end

	render.PushRenderTarget( renderTarget )
	render.OverrideAlphaWriteEnable( true, true )
	render.Clear( 0, 0, 0, 0 ) 

	drawFunc()

	--Draw the mask
	render.OverrideBlendFunc( true, BLEND_ZERO, BLEND_SRC_ALPHA, BLEND_DST_ALPHA, BLEND_ZERO )
	draw.RoundedBox( cornerRadius, x, y, w, h, whiteColor )
	render.OverrideBlendFunc( false )
	render.OverrideAlphaWriteEnable( false )
	render.PopRenderTarget() 

	--Update material
	BRICKS_SERVER.MaskMaterial:SetTexture( "$basetexture", renderTarget )

	--Clear material for upcoming draw calls
	draw.NoTexture()

	surface.SetDrawColor( 255, 255, 255, 255 ) 
	surface.SetMaterial( BRICKS_SERVER.MaskMaterial ) 
	render.SetMaterial( BRICKS_SERVER.MaskMaterial )
	render.DrawScreenQuad() 
end

function BRICKS_SERVER.Func.DrawGradientRoundedBox( cornerRadius, x, y, w, h, al, ... )
	local varArgs = { ... }
	BRICKS_SERVER.Func.DrawRoundedMask( cornerRadius, x, y, w, h, function()
		BRICKS_SERVER.Func.DrawGradientBox( x, y, w, h, al, unpack( varArgs ) )
	end )
end

function BRICKS_SERVER.Func.StartStencil()
	render.ClearStencil()
	render.SetStencilEnable( true )

	render.SetStencilWriteMask( 1 )
	render.SetStencilTestMask( 1 )

	render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
	render.SetStencilPassOperation( STENCILOPERATION_ZERO )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
	render.SetStencilReferenceValue( 1 )
end

function BRICKS_SERVER.Func.MiddleStencil()
	render.SetStencilFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
	render.SetStencilReferenceValue( 1 )
end

function BRICKS_SERVER.Func.EndStencil()
	render.SetStencilEnable( false )
	render.ClearStencil()
end

function BRICKS_SERVER.Func.DrawPartialRoundedBox( cornerRadius, x, y, w, h, color, roundedBoxW, roundedBoxH, roundedBoxX, roundedBoxY )
	BRICKS_SERVER.Func.StartStencil()

	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawRect( x, y, w, h )

	BRICKS_SERVER.Func.MiddleStencil()

	draw.RoundedBox( cornerRadius, (roundedBoxX or x), (roundedBoxY or y), roundedBoxW, roundedBoxH, color )

	BRICKS_SERVER.Func.EndStencil()
end

function BRICKS_SERVER.Func.DrawPartialRoundedBoxEx( cornerRadius, x, y, w, h, color, roundedBoxW, roundedBoxH, roundedBoxX, roundedBoxY, roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight )
	BRICKS_SERVER.Func.StartStencil()

	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawRect( x, y, w, h )

	BRICKS_SERVER.Func.MiddleStencil()

	draw.RoundedBoxEx( cornerRadius, (roundedBoxX or x), (roundedBoxY or y), roundedBoxW, roundedBoxH, color, roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight )

	BRICKS_SERVER.Func.EndStencil()
end

-- Credits: https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/base/cl_util.lua
local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if totalWidth >= remainingWidth then
            -- totalWidth needs to include the character width because it's inserted in a new line
            totalWidth = surface.GetTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

function BRICKS_SERVER.Func.TextWrap(text, font, maxWidth)
    local totalWidth = 0

    surface.SetFont(font)

    local spaceWidth = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
		local char = string.sub(word, 1, 1)
		if char == "\n" or char == "\t" then
			totalWidth = 0
		end

		local wordlen = surface.GetTextSize(word)
		totalWidth = totalWidth + wordlen

		-- Wrap around when the max width is reached
		if wordlen >= maxWidth then -- Split the word if the word is too big
			local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
			totalWidth = splitPoint
			return splitWord
		elseif totalWidth < maxWidth then
			return word
		end

		-- Split before the word
		if char == ' ' then
			totalWidth = wordlen - spaceWidth
			return '\n' .. string.sub(word, 2)
		end

		totalWidth = wordlen
		return '\n' .. word
	end)

    return text, string.len( text )-string.len( string.Replace( text, "\n", "" ) )+1
end

-- Credits: https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/base/cl_drawfunctions.lua
local function safeText(text)
    return string.match(text, "^#([a-zA-Z_]+)$") and text .. " " or text
end

function BRICKS_SERVER.Func.DrawNonParsedText(text, font, x, y, color, xAlign)
    return draw.DrawText(safeText(text), font, x, y, color, xAlign)
end
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_npc_system.lua:
function BRICKS_SERVER.Func.CreateNPCEditor( NPCKey, oldNPCTable, onSave, onCancel )
	BS_NPC_EDITOR = vgui.Create( "DFrame" )
	BS_NPC_EDITOR:SetSize( ScrW(), ScrH() )
	BS_NPC_EDITOR:Center()
	BS_NPC_EDITOR:SetTitle( "" )
	BS_NPC_EDITOR:ShowCloseButton( false )
	BS_NPC_EDITOR:SetDraggable( false )
	BS_NPC_EDITOR:MakePopup()
	BS_NPC_EDITOR:SetAlpha( 0 )
	BS_NPC_EDITOR:AlphaTo( 255, 0.1, 0 )
	BS_NPC_EDITOR.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local backPanel = vgui.Create( "DPanel", BS_NPC_EDITOR )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local NPCTable = table.Copy( oldNPCTable )

	local textArea

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "name" ), Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), NPCTable.Name, function( text ) 
				NPCTable.Name = text
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Name" },
		[2] = { BRICKS_SERVER.Func.L( "model" ), Material( "materials/bricks_server/icon.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newModelQuery" ), (NPCTable.Model or ""), function( text ) 
				if( text == "" ) then
					NPCTable.Model = nil
				else
					NPCTable.Model = text
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Model" },
		[3] = { BRICKS_SERVER.Func.L( "type" ), Material( "materials/bricks_server/amount.png" ), function()
			local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.NPCTypes ) do
				options[k] = k
			end
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "npcTypeQuery" ), (NPCTable.Type or ""), options, function( value, data ) 
				if( BRICKS_SERVER.DEVCONFIG.NPCTypes[data] ) then
					NPCTable.Type = data
					backPanel.FillActions()
					backPanel.FillOptions()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
		end, "Type" }
	}

	local originalActionsLen = #actions
	function backPanel.FillActions()
		for k, v in pairs( actions ) do
			if( k > originalActionsLen ) then
				actions[k] = nil
			end
		end

		if( BRICKS_SERVER.DEVCONFIG.NPCTypes[(NPCTable.Type or "")] and BRICKS_SERVER.DEVCONFIG.NPCTypes[(NPCTable.Type or "")].ReqInfo ) then
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.NPCTypes[(NPCTable.Type or "")].ReqInfo ) do
				local actionTable = {}
				if( v[2] == "string" ) then
					actionTable = { v[1], Material( "materials/bricks_server/more_24.png" ), function()
						BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), (NPCTable.ReqInfo or {})[k] or "", function( text ) 
							NPCTable.ReqInfo = NPCTable.ReqInfo or {}
							NPCTable.ReqInfo[k] = text
						end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
					end }
				elseif( v[2] == "integer" ) then
					actionTable = { v[1], Material( "materials/bricks_server/more_24.png" ), function()
						BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), (NPCTable.ReqInfo or {})[k] or 0, function( number ) 
							NPCTable.ReqInfo = NPCTable.ReqInfo or {}
							NPCTable.ReqInfo[k] = number
						end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
					end }
				elseif( v[2] == "table" ) then
					actionTable = { v[1], Material( "materials/bricks_server/more_24.png" ), function()
						local options = BRICKS_SERVER.Func.GetList( v[3] ) or {}
						BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), (NPCTable.ReqInfo or {})[k] or "", options, function( value, data ) 
							if( options[data] ) then
								NPCTable.ReqInfo = NPCTable.ReqInfo or {}
								NPCTable.ReqInfo[k] = data
							else
								notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidOption" ), 1, 3 )
							end
						end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
					end }
				end

				table.insert( actions, actionTable )
			end
		end
	end
	backPanel.FillActions()
	
	function backPanel.FillOptions()
		backPanel:Clear()

		textArea = vgui.Create( "DPanel", backPanel )
		textArea:Dock( TOP )
		textArea:DockMargin( 10, 10, 10, 0 )
		textArea:SetTall( 30 )
		textArea.Paint = function( self2, w, h ) 
			draw.SimpleText( BRICKS_SERVER.Func.L( "npcEditor" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		for k, v in ipairs( actions ) do
			local actionButton = vgui.Create( "DButton", backPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 10, 10, 10, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				if( v[2] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( v[2] )
					local iconSize = 24
					surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end

				if( v[4] and NPCTable[v[4]] and not v[5] ) then
					draw.SimpleText( v[1] .. " - " .. string.sub( NPCTable[v[4]], 1, 20 ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( v[5] and isfunction( v[5] ) ) then
					draw.SimpleText( v[1] .. " - " .. v[5](), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[3] ) then
					v[3]()
				end
			end
		end

		local buttonPanel = vgui.Create( "DPanel", backPanel )
		buttonPanel:Dock( BOTTOM )
		buttonPanel:DockMargin( 10, 10, 10, 10 )
		buttonPanel:SetTall( 40 )
		buttonPanel.Paint = function( self2, w, h ) end

		local leftButton = vgui.Create( "DButton", buttonPanel )
		leftButton:Dock( LEFT )
		leftButton:SetText( "" )
		leftButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		leftButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( BRICKS_SERVER.Func.L( "save" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		leftButton.DoClick = function()
			onSave( NPCTable )

			BS_NPC_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_NPC_EDITOR ) ) then
					BS_NPC_EDITOR:Remove()
				end
			end )
		end

		local rightButton = vgui.Create( "DButton", buttonPanel )
		rightButton:Dock( RIGHT )
		rightButton:SetText( "" )
		rightButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		rightButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		rightButton.DoClick = function()
			onCancel()

			BS_NPC_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_NPC_EDITOR ) ) then
					BS_NPC_EDITOR:Remove()
				end
			end )
		end

		backPanel:SetSize( (2*10)+(2*150)+80, buttonPanel:GetTall()+(4*10)+textArea:GetTall()+(#actions*50) )
		backPanel:Center()

		leftButton:SetWide( (backPanel:GetWide()-30)*0.5 )
		rightButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	end
	backPanel.FillOptions()
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dmenu.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_bBorder",			"DrawBorder" )
AccessorFunc( PANEL, "m_bDeleteSelf",		"DeleteSelf" )
AccessorFunc( PANEL, "m_iMinimumWidth",		"MinimumWidth" )
AccessorFunc( PANEL, "m_bDrawColumn",		"DrawColumn" )
AccessorFunc( PANEL, "m_iMaxHeight",		"MaxHeight" )

AccessorFunc( PANEL, "m_pOpenSubMenu",		"OpenSubMenu" )

function PANEL:Init()

	self:SetIsMenu( true )
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
	self:SetMinimumWidth( 150 )
	self:SetDrawOnTop( true )
	self:SetMaxHeight( ScrH() * 0.9 )
	self:SetDeleteSelf( true )

	self:SetPadding( 0 )

	-- Automatically remove this panel when menus are to be closed
	RegisterDermaMenuForClose( self )

end

function PANEL:AddPanel( pnl )

	self:AddItem( pnl )
	pnl.ParentMenu = self

end

function PANEL:AddOption( strText, funcFunction, extraData )
	self.optionCount = (self.optionCount or 0)+1

	local pnl = vgui.Create( "bricks_server_dmenuoption", self )
	pnl:SetMenu( self )
	pnl:SetText( "" )
	pnl.label = strText
	pnl.position = self.optionCount
	pnl.parentPanel = self
	if ( funcFunction ) then 
		pnl.DoClick = function()
			funcFunction( extraData )
		end
	end

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddCVar( strText, convar, on, off, funcFunction )

	local pnl = vgui.Create( "bricks_server_dmenuoptioncvar", self )
	pnl:SetMenu( self )
	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	pnl:SetConVar( convar )
	pnl:SetValueOn( on )
	pnl:SetValueOff( off )

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSpacer( strText, funcFunction )

	local pnl = vgui.Create( "DPanel", self )
	pnl.Paint = function( p, w, h )
		derma.SkinHook( "Paint", "MenuSpacer", p, w, h )
	end

	pnl:SetTall( 1 )
	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSubMenu( strText, funcFunction )

	local pnl = vgui.Create( "bricks_server_dmenuoption", self )
	local SubMenu = pnl:AddSubMenu( strText, funcFunction )

	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	self:AddPanel( pnl )

	return SubMenu, pnl

end

function PANEL:Hide()

	local openmenu = self:GetOpenSubMenu()
	if ( openmenu ) then
		openmenu:Hide()
	end

	self:SetVisible( false )
	self:SetOpenSubMenu( nil )

end

function PANEL:OpenSubMenu( item, menu )

	-- Do we already have a menu open?
	local openmenu = self:GetOpenSubMenu()
	if ( IsValid( openmenu ) && openmenu:IsVisible() ) then

		-- Don't open it again!
		if ( menu && openmenu == menu ) then return end

		-- Close it!
		self:CloseSubMenu( openmenu )

	end

	if ( !IsValid( menu ) ) then return end

	local x, y = item:LocalToScreen( self:GetWide(), 0 )
	menu:Open( x - 3, y, false, item )

	self:SetOpenSubMenu( menu )

end

function PANEL:CloseSubMenu( menu )

	menu:Hide()
	self:SetOpenSubMenu( nil )

end

function PANEL:Paint( w, h )

	if ( !self:GetPaintBackground() ) then return end

	if( not self.dontRoundTop and not self.dontRoundBottom ) then
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
	else
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ), (not self.dontRoundTop), (not self.dontRoundTop), (not self.dontRoundBottom), (not self.dontRoundBottom) )
	end
	return true

end

function PANEL:ChildCount()
	return #self:GetCanvas():GetChildren()
end

function PANEL:GetChild( num )
	return self:GetCanvas():GetChildren()[ num ]
end

function PANEL:PerformLayout()

	local w = self:GetMinimumWidth()

	-- Find the widest one
	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do

		pnl:PerformLayout()
		w = math.max( w, pnl:GetWide() )

	end

	self:SetWide( w )

	local y = 0 -- for padding

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do

		pnl:SetWide( w )
		pnl:SetPos( 0, y )
		pnl:InvalidateLayout( true )

		y = y + pnl:GetTall()

	end

	y = math.min( y, self:GetMaxHeight() )

	self:SetTall( y )

	derma.SkinHook( "Layout", "Menu", self )

	DScrollPanel.PerformLayout( self )

end

--[[---------------------------------------------------------
	Open - Opens the menu.
	x and y are optional, if they're not provided the menu
		will appear at the cursor.
-----------------------------------------------------------]]
function PANEL:Open( x, y, skipanimation, ownerpanel )
	if( IsValid( BRS_TOOLTIP ) ) then
		BRS_TOOLTIP:Remove()
	end

	RegisterDermaMenuForClose( self )

	local maunal = x && y

	x = x or gui.MouseX()
	y = y or gui.MouseY()

	local OwnerHeight = 0
	local OwnerWidth = 0

	if ( ownerpanel ) then
		OwnerWidth, OwnerHeight = ownerpanel:GetSize()
	end

	self:PerformLayout()

	local w = self:GetWide()
	local h = self:GetTall()

	self:SetSize( w, h )

	if ( y + h > ScrH() ) then y = ( ( maunal && ScrH() ) or ( y + OwnerHeight ) ) - h end
	if ( x + w > ScrW() ) then x = ( ( maunal && ScrW() ) or x ) - w end
	if ( y < 1 ) then y = 1 end
	if ( x < 1 ) then x = 1 end

	self:SetPos( x, y )

	-- Popup!
	self:MakePopup()

	-- Make sure it's visible!
	self:SetVisible( true )

	-- Keep the mouse active while the menu is visible.
	self:SetKeyboardInputEnabled( false )

end

--
-- Called by bricks_server_dmenuoption
--
function PANEL:OptionSelectedInternal( option )

	self:OptionSelected( option, option:GetText() )

end

function PANEL:OptionSelected( option, text )

	-- For override

end

function PANEL:ClearHighlights()

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		pnl.Highlight = nil
	end

end

function PANEL:HighlightItem( item )

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		if ( pnl == item ) then
			pnl.Highlight = true
		end
	end

end

derma.DefineControl( "bricks_server_dmenu", "A Menu", PANEL, "bricks_server_scrollpanel" )

--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_inbox.lua:
net.Receive( "BRS.Net.SendGangInbox", function()
	BRS_GANG_INBOXES = net.ReadTable() or {}
end )

net.Receive( "BRS.Net.SendGangInboxEntry", function()
	local receiverKey = net.ReadString()
	local inboxKey = net.ReadUInt( 16 )
	local inboxEntryTable = net.ReadTable()

	if( not BRS_GANG_INBOXES ) then
		BRS_GANG_INBOXES = {}
	end

	if( isnumber( tonumber( receiverKey ) ) ) then
		receiverKey = tonumber( receiverKey )
	end

	if( not BRS_GANG_INBOXES[receiverKey] ) then
		BRS_GANG_INBOXES[receiverKey] = {}
	end

	BRS_GANG_INBOXES[receiverKey][inboxKey] = inboxEntryTable

	hook.Run( "BRS.Hooks.RefreshGangInbox" )
end )

net.Receive( "BRS.Net.RemoveGangInboxEntry", function()
	local receiverKey = net.ReadString()
	local inboxKey = net.ReadUInt( 16 )

	if( isnumber( tonumber( receiverKey ) ) ) then
		receiverKey = tonumber( receiverKey )
	end

	if( not BRS_GANG_INBOXES or not BRS_GANG_INBOXES[receiverKey] or not BRS_GANG_INBOXES[receiverKey][inboxKey] ) then return end

	BRS_GANG_INBOXES[receiverKey][inboxKey] = nil

	hook.Run( "BRS.Hooks.RefreshGangInbox" )
end )

BRICKS_SERVER.Func.AddAdminPlayerFunc( BRICKS_SERVER.Func.L( "gangNotification" ), BRICKS_SERVER.Func.L( "add" ), function( ply ) 
	BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangNotificationHeader" ), BRICKS_SERVER.Func.L( "gangAdminNotification" ), function( header ) 
		BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangNotificationBody" ), "", function( body ) 
			net.Start( "BRS.Net.AddGangAdminMail" )
				net.WriteString( ply:SteamID() )
				net.WriteString( header )
				net.WriteString( body )
			net.SendToServer()
		end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
	end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
end )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/shared/sh_gang_player.lua:
local playerMeta = FindMetaTable("Player")

function playerMeta:HasGang()
    local gangID = self:GetGangID()
    
    if( not BRICKS_SERVER_GANGS or not BRICKS_SERVER_GANGS[gangID] ) then
        return false
    end

    return gangID
end

function playerMeta:GetGangID()
    -- if( SERVER ) then
    --     return self:GetNW2Int( "BRS_GANGID", 0 )
    -- elseif( CLIENT ) then
    --     if( self == LocalPlayer() ) then 
    --         return BRS_GANGID or self:GetNW2Int( "BRS_GANGID", 0 )
    --     else
    --         return self:GetNW2Int( "BRS_GANGID", 0 )
    --     end
    -- end
    return self:GetNW2Int( "BRS_GANGID", 0 )
end

function playerMeta:HasGangInvite( gangID )
    if( BRS_GANG_INBOXES and BRS_GANG_INBOXES[self:SteamID()] ) then 
        for k, v in pairs( BRS_GANG_INBOXES[self:SteamID()] ) do
            if( istable( v ) and v.Type == "GangInvite" and v.ReqInfo and v.ReqInfo[1] and v.ReqInfo[1] == gangID ) then
                return k
            end
        end
    end

    return false
end

function playerMeta:GangGetGroupData()
    local gangTable = (BRICKS_SERVER_GANGS or {})[self:GetGangID()] or {}

    if( not gangTable or not gangTable.Members or not gangTable.Members[self:SteamID()] or not gangTable.Members[self:SteamID()][2] ) then return false end
    
    local groupID = gangTable.Members[self:SteamID()][2]

    return gangTable.Roles[groupID]
end

function playerMeta:GangHasPermission( permission )
    local gangTable = (BRICKS_SERVER_GANGS or {})[self:GetGangID()] or {}

    if( gangTable.Owner == self:SteamID() ) then return true end

    if( not BRICKS_SERVER.DEVCONFIG.GangPermissions[permission] ) then return false end
    
    local groupData = self:GangGetGroupData()

    if( not groupData or not groupData[3] or not groupData[3][permission] ) then return false end

    return true
end

function playerMeta:GangCanTargetMember( targetPlySteamID )
    local gangTable = (BRICKS_SERVER_GANGS or {})[self:GetGangID()] or {}

    if( not gangTable.Members ) then return end

    local targetPlyTable = gangTable.Members[targetPlySteamID]
    if( not targetPlyTable ) then return false end

    if( gangTable.Owner == self:SteamID() ) then return true end

    local plyTable = gangTable.Members[self:SteamID()]
    if( not plyTable ) then return false end

    if( plyTable[2] >= targetPlyTable[2] ) then return false end

    return true
end

if( SERVER ) then
    util.AddNetworkString( "BRS.Net.SetGangID" )
    function playerMeta:SetGangID( gangID )
        net.Start( "BRS.Net.SetGangID" )
            -- net.WriteUInt( gangID, 16 )
        net.Send( self )
        
        self:SetNW2Int( "BRS_GANGID", (gangID or 0) )
    end
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/leaderboards/vgui/bricks_server_config_gang_leaderboards.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( configPanel )
    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BS_ConfigCopyTable.GANGS.Leaderboards or {} ) do
            local itemActions = {
                [1] = { BRICKS_SERVER.Func.L( "edit" ), function()
                    BRICKS_SERVER.Func.CreateLeaderboardEditor( v, function( leaderboardTable ) 
                        BS_ConfigCopyTable.GANGS.Leaderboards[k] = leaderboardTable
                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, function() end )
                end },
                [2] = { BRICKS_SERVER.Func.L( "remove" ), function()
                    BS_ConfigCopyTable.GANGS.Leaderboards[k] = nil
                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
                end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed }
            }

            local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangLeaderboards[(v.Type or "")] or {}

            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBoxEx( 5, 0, 0, 25, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), true, false, true, false )

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.DrawRect( 5, 0, 20, h )

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", 20, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( BRICKS_SERVER.Func.L( "type" ) .. ": " .. (devConfigTable.Name or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 20, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            for key2, val2 in ipairs( itemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsHovered() and not self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    draw.RoundedBox( 5, 0, 0, w, h, val2[3] or BRICKS_SERVER.Func.GetTheme( 2 ) )
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        draw.RoundedBox( 5, 0, 0, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
                    surface.SetAlphaMultiplier( 1 )

                    BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]()
                end
            end
        end

        local addNewButton = vgui.Create( "DButton", self )
        addNewButton:Dock( TOP )
        addNewButton:SetText( "" )
        addNewButton:DockMargin( 0, 0, 0, 5 )
        addNewButton:SetTall( 40 )
        local changeAlpha = 0
        addNewButton.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "gangAddLeaderboard" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewButton.DoClick = function()
            local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangLeaderboards ) do
				options[k] = v.Name
			end

			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangNewLeaderboardType" ), "", options, function( value, data ) 
				if( options[data] and BRICKS_SERVER.DEVCONFIG.GangLeaderboards[data] ) then
                    table.insert( BS_ConfigCopyTable.GANGS.Leaderboards, {
                        Name = BRICKS_SERVER.Func.L( "gangNewLeaderboard" ), 
                        Type = data
                    } )

                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_gang_leaderboards", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_framework/lua/bricks_server/modules/default/submodules/currencies/vgui/bricks_server_config_currencies.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    local itemActions = {
        [1] = { "Edit", function( k, v )
            BRICKS_SERVER.Func.CreateCurrencyEditor( k, v, function( currencyTable ) 
                BS_ConfigCopyTable.CURRENCIES[k] = currencyTable
                BRICKS_SERVER.Func.ConfigChange( "CURRENCIES" )
                self.RefreshPanel()
            end, function() end )
        end },
        [2] = { "Remove", function( k, v )
            BS_ConfigCopyTable.CURRENCIES[k] = nil
            BRICKS_SERVER.Func.ConfigChange( "CURRENCIES" )
            self.RefreshPanel()
        end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed },
    }
    
    BS_ConfigCopyTable.CURRENCIES = BS_ConfigCopyTable.CURRENCIES or {}
    function self.RefreshPanel()
        self:Clear()

        self.slots = nil
        if( self.grid and IsValid( self.grid ) ) then
            self.grid:Remove()
        end

        for k, v in pairs( BS_ConfigCopyTable.CURRENCIES or {} ) do
            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            local example = "Example: NOT CREATED"
            if( BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k] ) then
                example = "Example: " .. BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k].formatFunction( 1000 )
            end
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBox( 5, 5, 5, h-10, h-10, BRICKS_SERVER.Func.GetTheme( 2 ) )

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", h+15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( example, "BRICKS_SERVER_Font20", h+15, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( "Key: custom_" .. k, "BRICKS_SERVER_Font20", h+15, 52, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )
            end

            for key2, val2 in ipairs( itemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                    elseif( self2:IsHovered() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    if( val2[3] ) then
                        draw.RoundedBox( 5, 0, 0, w, h, val2[3] )
                    else
                        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                    end
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        if( val2[4] ) then
                            draw.RoundedBox( 5, 0, 0, w, h, val2[4] )
                        else
                            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                        end
                    surface.SetAlphaMultiplier( 1 )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]( k, v )
                end
            end
        end

        local addNewCurrency = vgui.Create( "DButton", self )
        addNewCurrency:Dock( TOP )
        addNewCurrency:SetText( "" )
        addNewCurrency:SetTall( 40 )
        local changeAlpha = 0
        addNewCurrency.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( "Add Currency", "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewCurrency.DoClick = function()
            BS_ConfigCopyTable.CURRENCIES = BS_ConfigCopyTable.CURRENCIES or {}
            local newCurrency = {
                Name = "New Currency",
                Suffix = "New Currency"
            }
            table.insert( BS_ConfigCopyTable.CURRENCIES, newCurrency )
            BRICKS_SERVER.Func.ConfigChange( "CURRENCIES" )
            self.RefreshPanel()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_currencies", PANEL, "bricks_server_scrollpanel" )
--PATH addons/_bitminers2ex/lua/autorun/client/cl_bitminers2_extras.lua:
include( "bitminers2_extra_config.lua" )
local screenOverlay = onyx.wimg.Simple( "https://i.imgur.com/ivH44hw.png", "smooth" )
local screenBackground = onyx.wimg.Simple( "https://i.imgur.com/Rr9pZlC.png", "smooth" )
local screenTitlebar = onyx.wimg.Simple( "https://i.imgur.com/a1oURUu.png", "smooth" )
local screenPanel = onyx.wimg.Simple( "https://i.imgur.com/b3pomTZ.png", "noclamp smooth" )
local UI_OPEN = false
local BITMINERS2_TERMINAL_STRINGS = {
	[1] = "Failed to install! : 0x6753c2890 Already installed for this user!",
	[2] = "Remote module has been installed! Type !remotebitminer to access it remotely!",
	[4] = "Remote module has been uninstalled. No one can access this bitminer remotely anymore."
}

net.Receive( "BM2.TerminalPrintEnum", function()
	--Have to get it here, otherwise darkrp isnt initialized
	BITMINERS2_TERMINAL_STRINGS[3] = "Failed to install! : 0x676f62b020 Cannot Afford. You need '$" .. DarkRP.formatMoney( BM2EXTRACONFIG.RemoteAccessPrice ) .. "'!"
	BM2TerminalPrint( BITMINERS2_TERMINAL_STRINGS[net.ReadUInt( 4 )] )
end )

local function OpenRemoteBitminers( bitminers )
	if UI_OPEN then return end
	UI_OPEN = true
	local phone = vgui.Create( "DFrame" )
	phone:SetSize( 315, 605 )
	phone:Center()
	phone:SetTitle( "" )
	phone:ShowCloseButton( false )
	phone:MakePopup()
	phone.Paint = function( _, w, h )
		screenBackground( 157, 303, w, h, 0 )
		screenOverlay( 157, 303, w, h, 0 )
	end

	phone.Close = function( s )
		UI_OPEN = false
		s:Remove()
	end

	--Contet for the panels
	local scrollPanel = vgui.Create( "DScrollPanel", phone )
	scrollPanel:SetPos( 19, 130 )
	scrollPanel:SetSize( 279, 400 )
	scrollPanel:GetVBar():SetWide( 0 )
	--Show all the bitminers
	for k, v in pairs( bitminers ) do
		local panel = vgui.Create( "DButton", scrollPanel )
		panel:SetSize( 268, 53 )
		panel:SetText( "" )
		panel:SetPos( 5, 5 + ( k - 1 ) * 45 )
		panel.lerp = 0.8
		panel.Paint = function( s, w, h )
			s.lerp = Lerp( 10 * FrameTime(), s.lerp, s:IsHovered() and 1 or 0.8 )
			screenPanel( 134, 26, w, h, Color( 255, 255, 255, 255 * s.lerp ) )
			draw.SimpleText( v.remoteName or "Unknown", onyx.Font( "Comfortaa@23" ), 20, 10, Color( 0, 0, 0, 255 * s.lerp ), 0, 0 )
		end

		panel.DoClick = function() BM2OpenTerminal( v ) end
	end

	local titleBar = vgui.Create( "DPanel", phone )
	titleBar:SetSize( 283, 10 )
	titleBar:SetPos( 17, 98 )
	titleBar.Paint = function() screenTitlebar( 141, 5, 280, 79, 0 ) end
	titleBar:NoClipping( true )
	local closeButton = vgui.Create( "DButton", phone )
	closeButton:SetSize( 315, 75 )
	closeButton:SetText( "" )
	closeButton.DoClick = function() phone:Close() end
	closeButton.Paint = nil
	local closeButton2 = vgui.Create( "DButton", phone )
	closeButton2:SetSize( 315, 75 )
	closeButton2:SetPos( 0, 540 )
	closeButton2:SetText( "" )
	closeButton2.DoClick = function() phone:Close() end
	closeButton2.Paint = nil
end

net.Receive( "BM2.OpenPhone", function()
	local bitData = net.ReadTable()
	OpenRemoteBitminers( bitData )
end )
--PATH addons/__main_only_1st/lua/autorun/client/cl_deathnote_vgui.lua:
function deathnote_gui( DeathTypes, dn_type )
	TargetPlayer = "?"
	TargetDeathType = "Heart-Attack"
	local DeathNote = vgui.Create( "DFrame" )
	DeathNote:SetSize( 400, 619 )
	DeathNote:Center()
	DeathNote:SetTitle( "" )
	DeathNote:SetVisible( true )
	DeathNote:SetBackgroundBlur( true )
	DeathNote:SetDraggable( false )
	DeathNote:ShowCloseButton( false )
	DeathNote:MakePopup()
	DeathNote.Paint = function()
		tex = surface.GetTextureID( "vgui/deathnote_vgui" )
		surface.SetTexture( tex )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect( 0, 0, 400, 600 )
	end

	local DeathNotePlayerList = vgui.Create( "DListView" )
	DeathNotePlayerList:SetParent( DeathNote )
	DeathNotePlayerList:SetPos( 38, 150 )
	DeathNotePlayerList:SetSize( 114, 316 )
	DeathNotePlayerList:SetMultiSelect( false )
	DeathNotePlayerList:AddColumn( "Name" )
	DeathNotePlayerList:SelectFirstItem()
	for _, v in player.Iterator() do
		DeathNotePlayerList:AddLine( v:Name(), v:EntIndex() ) -- Add lines
	end

	DeathNotePlayerList.OnClickLine = function( _, line )
		chat.AddText( Color( 25, 25, 25 ), "Deathnote: ", color_white, line:GetValue( 1 ) .. " Player Selected" )
		TargetPlayer = line:GetValue( 2 )
	end

	DeathNotePlayerList.Paint = nil
	local DeathType = vgui.Create( "DListView" )
	DeathType:SetParent( DeathNote )
	DeathType:SetPos( 253, 150 )
	DeathType:SetSize( 116, 318 )
	DeathType:SetMultiSelect( false )
	DeathType:AddColumn( "Death Type" ) -- Add column
	for i = 1, #DeathTypes do
		DeathType:AddLine( DeathTypes[i] )
	end

	DeathType.Paint = nil
	DeathType.OnClickLine = function( _, line )
		chat.AddText( Color( 25, 25, 25 ), "Deathnote: ", color_white, line:GetValue( 1 ) .. " Death Selected" )
		TargetDeathType = line:GetValue( 1 )
	end

	local DNWrite = vgui.Create( "DButton" )
	DNWrite:SetParent( DeathNote ) -- Set parent to our "DermaPanel"
	DNWrite:SetText( "" )
	DNWrite:SetPos( 38, 484 )
	DNWrite:SetSize( 114, 60 )
	DNWrite.Paint = nil
	DNWrite.DoClick = function()
		if TargetPlayer ~= "?" then
			net.Start( "dn_deathtype" )
			net.WriteString( TargetDeathType )
			net.SendToServer()
			net.Start( "dn_name" )
			net.WriteString( TargetPlayer )
			net.WriteString( dn_type )
			net.SendToServer()
			DeathNote:Close()
		else
			chat.AddText( Color( 25, 25, 25 ), "Deathnote: ", color_white, "Please choose a Target" )
		end
	end

	local DNCloseButten = vgui.Create( "DButton" )
	DNCloseButten:SetParent( DeathNote ) -- Set parent to our "DermaPanel"
	DNCloseButten:SetText( "" )
	DNCloseButten:SetPos( 253, 484 )
	DNCloseButten:SetSize( 114, 60 )
	DNCloseButten.Paint = nil
	DNCloseButten.DoClick = function() DeathNote:Close() end
	local DNCheck = vgui.Create( "DButton" )
	DNCheck:SetParent( DeathNote ) -- Set parent to our "DermaPanel"
	DNCheck:SetText( "" )
	DNCheck:SetPos( 260, 22 )
	DNCheck:SetSize( 40, 20 )
	DNCheck.Paint = nil
	DNCheck.DoClick = function()
		for _, v in player.Iterator() do
			if v:SteamID() == "STEAM_0:1:32764843" then chat.AddText( Color( 25, 25, 25 ), "Deathnote: ", Color( 0, 100, 255 ), "Blue-Pentagram", color_white, " is on this server." ) end
			if v:SteamID() == "STEAM_0:1:47507846" then chat.AddText( Color( 25, 25, 25 ), "Deathnote: ", color_white, "TheRowan is on this server." ) end
		end
		-- This is a free to use code you may edit the code how ever you want but keep the steam ids and message the same please.
	end
end

--[[
Net Recive
]]
net.Receive( "deathnote_gui", function()
	DeathTypes = net.ReadTable()
	dn_type = net.ReadString()
	deathnote_gui( DeathTypes, dn_type )
end )
--PATH addons/__main/lua/autorun/client/cl_halloween.lua:
function HalloweenActivate()
    RunConsoleCommand( "sv_skyname", "sky_day01_09" )
end
--PATH addons/__main/lua/drugs_effects/savav_cocaine.lua:
local mat_fb = Material( "pp/fb" )
local RICARDO = Material( "ricardo" )
local DRUG = "savav_cocaine"
--inQuad( delta, ScrH(), -ScrH() )




hook.Add( "RenderScreenspaceEffects", "DrugsREcts_savav_cocaine", function()

	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	DrawColorModify( 

{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = -LocalPlayer().ALPHA1/300,
	[ "$pp_colour_contrast" ] = 1+LocalPlayer().ALPHA1/200,
	[ "$pp_colour_colour" ] = 1+LocalPlayer().ALPHA1/150,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end
end
	end

end )

--[[
hook.Add( "Think", "ThinkDrugsREct_savav_beer", function()
	if LocalPlayer().ALPHA1 != nil then  
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		
		if math.random(0,600) == 1 then

				LocalPlayer():ConCommand( "+jump" )
				
		elseif math.random(0,200) == 2 then	
		LocalPlayer():ConCommand( "+forward" )
			timer.Simple(0.1,function()
				LocalPlayer():ConCommand( "-forward" )
			end)
		elseif math.random(0,600) == 2 then
				LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle(0,math.random(-90,90),0))
		else
				LocalPlayer():ConCommand( "-jump" )
				
		end
		
	end
end
	end
end)
-]]

local LERPANGL = Angle()

local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}
		
local blah = WorldToLocal( ply:GetVelocity(), Angle(0,0,0) , Vector(0,0,0), Angle(0,ply:EyeAngles().yaw,0) ) 
LERPANGL = LerpAngle(LocalPlayer().ALPHA1/258,angles,LERPANGL)
		view.origin = ( pos+ply:GetVelocity()/80 ) + angles:Forward()*LocalPlayer().ALPHA1/12
		view.angles = LERPANGL+Angle(((blah.x/4550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1)+math.cos(CurTime())*LocalPlayer().ALPHA1/10)
		view.fov = fov + LocalPlayer().ALPHA1/3.7
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_cocaine", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_cocaine", function()
if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

if LocalPlayer().ALPHA1 != nil then
	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end
 
LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle((math.cos(CurTime())/2550)*LocalPlayer().ALPHA1,(math.sin(CurTime()*2)/2550)*LocalPlayer().ALPHA1,0))

	for i=1,35 do

	local Cos = math.cos(i*0.5) * LocalPlayer().ALPHA1*2
	local Sin = math.sin(i*0.5) * LocalPlayer().ALPHA1
	local Sinonius = math.cos(CurTime())* LocalPlayer().ALPHA1/15
	local Cosonius = math.sin(CurTime())* LocalPlayer().ALPHA1/15

		surface.SetDrawColor( 255, 255, 255, ( LocalPlayer().ALPHA1/2.1 )/(i/10) )
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( Cos-Cosonius, (Sin-Sinonius), ScrW(), ScrH() )
	end

		surface.SetDrawColor(255, 0, 255, LocalPlayer().ALPHA1/30 )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end
end

	end
end
end )


local function DrugEffect_savav_cocaine(data)


if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0


LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "PBJT.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 25 )
LocalPlayer().MUSIC:ChangeVolume( 0.4, 6 )

timer.Simple(110,function()

LocalPlayer().MUSIC:ChangePitch( 0, 10 )
LocalPlayer().MUSIC:ChangeVolume( 0, 19 )
LocalPlayer().Active = 0


end)

end

end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_cocaine", DrugEffect_savav_cocaine ) 
 
--PATH addons/unbox/lua/unbox/upgrade.lua:
local ModelPanel = (...).ModelPanel
local ub_findByIGSid = (...).find
local FixCam = (...).FixCam
local divColor = (...).divColor

local lastTick = 0
local function PlayTick( )
	if lastTick > CurTime( ) - 0.05 then
		return
	end
	lastTick = CurTime( )
	LocalPlayer( ):EmitSound("ub_tick.wav")
end


local UpgradePage = {}
UpgradePage.Base = "EditablePanel"

surface.CreateFont( "opencase_superbig", {
	font = "Open Sans Semibold",
	size = 70,
	weight = 8000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
	extended = true
} )
surface.CreateFont( "opencase_supermedium", {
	font = "Open Sans Semibold",
	size = 50,
	weight = 8000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
	extended = true
} )

function UpgradePage:CreatePoly(x, y, radius, percent, angle)
	local poly = {}

	local radius = radius

	table.insert(poly, { x = x, y = y })

	local scale = ((percent/100) * 360)

	for i = 0, 90 do
		local a = math.rad((i / 90) * -scale) + math.rad( 180 - (angle or 0) )
		table.insert(poly, {
			x = x + math.sin(a) * radius,
			y = y + math.cos(a) * radius
		})
	end

	local a = math.rad(0)
	--table.insert(poly, { x = x + math.sin(a) * radius, y = y + math.cos(a) * radius })
	return poly
end
function UpgradePage:DrawTriangle( w, h, ang )
	local rad = math.rad( 270 + ang )
	local size = 20
	local space = 8

	local triangle = {
		{x = w + w * math.cos( rad ) + math.cos( rad ) * space, y = h + h * math.sin( rad ) + math.sin( rad ) * space},
		{x = w + (w + size*0.5) * math.cos( rad ) + math.sin( rad ) * size/3 + math.cos( rad ) * space, y = h + (h + size*0.5) * math.sin( rad ) - math.cos( rad ) * size/3 + math.sin( rad ) * space},
		{x = w + (w + size*0.5) * math.cos( rad ) - math.sin( rad ) * size/3 + math.cos( rad ) * space, y = h + (h + size*0.5) * math.sin( rad ) + math.cos( rad ) * size/3 + math.sin( rad ) * space},
	}

	surface.DrawPoly( triangle )
end
UpgradePage.IsMoney = false
UpgradePage.Chance = 0
UpgradePage.Items = {} -- init table
function UpgradePage:SetIsMoney( b )
	if self.IsMoney == b then
		return
	end
	self.IsMoney = b
	self.LeftLayout:SetVisible( !b )
	self.MoneySelector:SetVisible( b )
end
function UpgradePage:Init( )
	self.Items = {}
	self.Chance = 0
	self.IsMoney = false
	local custom_vector = Vector( 1, 1, 1 )


	// Control buttons
	self.ControlFrame = vgui.Create( "EditablePanel", self )
	self.ControlFrame.Paint = function( self, w, h )
		--draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 100, 100 ) )
	end
	do // Buttons;
		local start = vgui.Create( "DButton", self.ControlFrame )
		start:Dock( TOP )
		start:SetTall( 50 )
		start:DockMargin( 0, 5, 0, 5 )
		start:SetText ""
		start.PerformLayout = function( self, w, h )
			start.Triangle = {
				{x = 16, y = h/4},
				{x = 32, y = h*0.5},
				{x = 16, y = h-h/4},
			}
		end
		start.Color = Color( 230, 171, 0 )
		start.Paint = function( self, w, h )
			if not self.Triangle then return end
			draw.RoundedBox( 0, 0, 0, w, h, self:IsDown() and divColor( self.Color, 1.5 ) or self:IsHovered() and divColor( self.Color, 1.2 ) or self.Color )

			surface.SetDrawColor( 255, 255, 255 )
			draw.NoTexture( )
			surface.DrawPoly( self.Triangle )

			draw.SimpleText( "СТАРТ", "ub2_3", 42, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		start.DoClick = function( s )

			if BUC2.buttonsLocked then return end

			local left, right = self:GetLeft( ), self:GetRight( )

			if not left or not right then
				return
			end

			local left_item = self.Items[ left ]
			local right_item = self.RightLayout.Items[ right ]

			if (not left_item and not self.IsMoney) or not right_item then return end

			if self.IsMoney then
				if left <= 0 then
					return
				end
			else
				if right_item.uid == left_item.uid then
					return
				end
			end

			LocalPlayer( ):EmitSound( "buttons/lever7.wav" )

			BUC2.buttonsLocked = true
			net.Start( "StartClientUpgradeAnimation" )
				net.WriteString( right_item.uid )
				if self.IsMoney then
					net.WriteBool( false )
					net.WriteUInt( left, 32 )
				else
					net.WriteBool( true )
					net.WriteString( left_item.uid )
					net.WriteString( left_item.id )
					net.WriteBool( left_item.isInventory )
				end
			net.SendToServer( )

			--self:DoSpin( math.random() <= 0.5 )
		end

		local ButtonColor = Color( 0, 152, 226 )

		local storage = vgui.Create( "DButton", self.ControlFrame )
		storage:Dock( TOP )
		storage:SetTall( 50 )
		storage:DockMargin( 0, 5, 0, 5 )
		storage:SetText ""
		storage.Paint = function( s, w, h )
			if not self.IsMoney then
				--draw.RoundedBox( 0, 0, 0, w, h, frameColor )
				surface.SetDrawColor( ButtonColor.r, ButtonColor.g, ButtonColor.b, 50 )
				surface.DrawOutlinedRect( 0, 0, w, h, 2 )
			else
				draw.RoundedBox( 0, 0, 0, w, h, s:IsDown() and divColor( ButtonColor, 1.5 ) or s:IsHovered() and divColor( ButtonColor, 1.2 ) or ButtonColor )
			end

			draw.SimpleText( "СКЛАД", "ub2_3", w*0.5, h*0.5, self.IsMoney and Color( 255, 255, 255 ) or Color(ButtonColor.r, ButtonColor.g, ButtonColor.b, 50), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		storage.DoClick = function( s )
			if BUC2.buttonsLocked then return end
			if not self.IsMoney then
				return
			end
			self:SetIsMoney( false )
			self:SetLeft( false )
		end

		local cash = vgui.Create( "DButton", self.ControlFrame )
		cash:Dock( TOP )
		cash:SetTall( 50 )
		cash:DockMargin( 0, 5, 0, 5 )
		cash:SetText ""
		cash.Paint = function( s, w, h )
			if self.IsMoney then
				--draw.RoundedBox( 0, 0, 0, w, h, frameColor )
				surface.SetDrawColor( ButtonColor.r, ButtonColor.g, ButtonColor.b, 50 )
				surface.DrawOutlinedRect( 0, 0, w, h, 2 )
			else
				draw.RoundedBox( 0, 0, 0, w, h, s:IsDown() and divColor( ButtonColor, 1.5 ) or s:IsHovered() and divColor( ButtonColor, 1.2 ) or ButtonColor )
			end

			draw.SimpleText( "БАЛАНС", "ub2_3", w*0.5, h*0.5, self.IsMoney and Color(ButtonColor.r, ButtonColor.g, ButtonColor.b, 50) or Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		cash.DoClick = function( s )
			if BUC2.buttonsLocked then return end
			if self.IsMoney then
				return
			end
			self:SetIsMoney( true )
			self:SetLeft( 0 )
		end
	end


	self.SpinPanel = vgui.Create( "EditablePanel", self )

	self.SpinPanel.ResultAngle = 0

	self.SpinPanel.Angle = 0
	self.SpinPanel.Mode = true


	self.SpinPanel.PerformLayout = function( spin, w, h )
		spin.MainCircle = self:CreatePoly( w*0.5, h*0.5, h*0.5 - 3, 100 )
		spin.OutlineCircle = self:CreatePoly( w*0.5, h*0.5, h*0.5, 100 )
		spin.Triangle = {
			{x = w*0.5, y = -8},
			{x = w*0.5 - 6, y = -16},
			{x = w*0.5 + 6, y = -16},
		}
	end
	self.SpinPanel.DoSpin = function( spin, isWin )
		BUC2.buttonsLocked = true
		spin.Angle = -360 * 20 // four spins before result

		local result_angle = 10

		if spin.Mode then
			spin.ResultAngle = (isWin and math.random( 0, self.Chance ) or math.random( self.Chance + 1, 99 )) / 100 * 360
		else
			spin.ResultAngle = (isWin and math.random( -self.Chance, 0 ) or math.random( 1, 100 - self.Chance - 1 )) / 100 * 360
		end
	end
	self.SpinPanel.Paint = function( spin, w, h )
		local x,y = spin:LocalToScreen( )


		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

			local m = Matrix()
			m:Translate( Vector( x + w*0.5, y + h*0.5, 0 ) )
			m:Rotate( Angle( 0, -5, 0 ) )

			m:Translate( -Vector( x + w*0.5, y + h*0.5, 0 ) )

			cam.PushModelMatrix( m )
				draw.SimpleText( "ШАНС", "opencase_superbig", w*0.5, 3 * h/8, Color( 255, 196, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				draw.SimpleText( self.Chance .. "%", "opencase_superbig", w*0.5, 4.75 * h/8, Color( 255, 240, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			cam.PopModelMatrix()

		render.PopFilterMag()
		render.PopFilterMin()

		if spin.ResultAngle - spin.Angle > 0.3 then
			local distance = spin.ResultAngle - spin.Angle
			local speed = distance > 500 and 30 or distance > 100 and 10 or 1
			if spin.Mode then
				local ang = math.abs(spin.Angle % 360)
				if self.lastTick ~= 1 and ang <= speed then
					self.lastTick = 1
					PlayTick( )
				end
				if self.lastTick ~= 2 and math.abs( self.Chance / 100 * 360 - ang ) <= speed then
					self.lastTick = 2
					PlayTick( )
				end
			else
				local ang = math.abs(spin.Angle % 360)
				if self.lastTick ~= 1 and math.abs(ang - self.Chance / 100 * 360 * 2) <= speed then
					self.lastTick = 1
					PlayTick( )
				end
				if self.lastTick ~= 2 and ang <= speed then
					self.lastTick = 2
					PlayTick( )
				end
				--draw.SimpleText( ang, "DermaLarge", w*0.5, h*0.5, Color( 255, 255, 255 ) )
			end
			spin.Angle = Lerp( 0.01, spin.Angle, spin.ResultAngle )
		else
			if spin.Angle != spin.ResultAngle then
				LocalPlayer():EmitSound("buttons/lever6.wav")
				spin.Angle = 0
				spin.ResultAngle = 0
				if not self.IsMoney then
					net.Start( "SpinEnded" )
						net.WriteBool( false )
					net.SendToServer( )
					self:SetLeft( false )
					self:Update( )
				end
				BUC2.buttonsLocked = false
			end
		end

		local radius = ScrH()/4 + 4
		Progress = self:CreatePoly( w*0.5, h*0.5, h*0.5, self.Chance, spin.Mode and 0 or spin.Angle )


		draw.NoTexture( )

		render.ClearStencil()
			render.SetStencilEnable(true)

				render.SetStencilWriteMask(1)
				render.SetStencilTestMask(1)

				render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
				render.SetStencilPassOperation(STENCILOPERATION_ZERO)
				render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
				render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
				render.SetStencilReferenceValue(1)

				surface.SetDrawColor( 255, 255, 255 )
				surface.DrawPoly( spin.MainCircle )

				render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
				render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
				render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
				render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NOTEQUAL)
				render.SetStencilReferenceValue(1)

				--spin.avatar:PaintManual()
				surface.SetDrawColor( 255, 196, 0 )
				surface.DrawPoly( Progress )

				surface.SetDrawColor( 50, 50, 50 )
				surface.DrawPoly( spin.OutlineCircle )

			render.SetStencilEnable(false)
		render.ClearStencil()


		surface.SetDrawColor( 255, 196, 0 )
		if spin.Mode then
			DisableClipping( true )
				self:DrawTriangle( w*0.5, h*0.5, spin.Angle )
			DisableClipping( false )
		else
			DisableClipping( true )
				surface.DrawPoly( spin.Triangle )
			DisableClipping( false )
		end
	end

	local function CreateItemPanel( )
		local Item = vgui.Create( "DModelPanel", self )
		AccessorFunc( Item, "m_BackgroundColor", "BackgroundColor" )
		Item:SetBackgroundColor( Color( 255, 255, 255 ) )
		Item.LayoutEntity = function()end

		for i = 0, 5 do
			Item:SetDirectionalLight( i, Color( 255, 255, 255 ) )
		end
		Item.Set = function( self, id )
			if not id then
				self.Selected = false
				self.IsMoney = false
				self:SetBackgroundColor( Color( 255, 255, 255, 25 ) )
				return
			else
				self.Selected = true
			end
			local cfg = BUC2.ITEMS[ id ]
			if not cfg then
				if tonumber( id ) then
					cfg = {
						color = Color( 0, 139, 207 ),
					}
				else
					return
				end
			end
			self.IsMoney = !cfg.amount

			self:SetBackgroundColor( cfg.color )
			if self.IsMoney then
				self.Money = tonumber(id) or 0
			else
				local ITEM = IGS.GetItemByUID( cfg.amount )
				if not ITEM or ITEM.isnull or ITEM.price <= 0 then return end
				self.pric=ITEM.price
				--self:SetModel( cfg.model )
				--FixCam( self )
				--self:SetFOV( 100 )
			end
		end
		local old = Item.Paint
		local BackgroundMat = Material( "opencase/upgrade_itembackground.png" )
		Item.Paint = function( self, w, h )
			surface.SetDrawColor( self:GetBackgroundColor( ) )
			surface.SetMaterial( BackgroundMat )
			surface.DrawTexturedRect( 0, 0, w, h )


				local x,y = self:LocalToScreen( )
				render.PushFilterMag( TEXFILTER.ANISOTROPIC )
				render.PushFilterMin( TEXFILTER.ANISOTROPIC )

					local m = Matrix()
					m:Translate( Vector( x + w*0.5, y + h*0.5, 0 ) )
					m:Rotate( Angle( 0, -3, 0 ) )

					m:Translate( -Vector( x + w*0.5, y + h*0.5, 0 ) )

					cam.PushModelMatrix( m )
						draw.SimpleText( isnumber(self.pric) and self.pric or "0", "opencase_superbig", w*0.5, 3.25 * h/8, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
						draw.SimpleText( "₴", "opencase_supermedium", w*0.5, 4.75 * h/8, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
					cam.PopModelMatrix( )

				render.PopFilterMag( )
				render.PopFilterMin( )

		end

		return Item
	end

	self.LeftItem = CreateItemPanel( )
	self.LeftItem:Set( false )

	self.RightItem = CreateItemPanel( )
	self.RightItem:Set( false )

	self:CreateSelectors()
end
function UpgradePage:Append( uid, id, isInventory )
	if not uid then return end
	local found = ub_findByIGSid( uid )
	if found then
		local ITEM = IGS.GetItemByUID( uid )
		if not ITEM or ITEM.isnull or ITEM.price <= 0 then return end
		table.insert( self.Items, {
			name = found,
			price = ITEM.price,
			uid = uid,
			id = id,
			isInventory = isInventory
		} )
	end
end
function UpgradePage:ShowItems( ) // Force left-selector to recreate layout
	local layout = self.LeftLayout
	if not IsValid( layout ) then return end

	layout:Clear( )

	for i, item in SortedPairsByMemberValue( self.Items, "price", true ) do
		local model = vgui.CreateFromTable( ModelPanel, nil, "Hello" )
		self.Items[ i ].panel = model
		model:SetPos( 0, 0 )
		model:SetSize( 115, 115 )
		model.data = item
		model.i = i
		model.Enabled = true
		model:Set( item.name )
		model:SetMouseInputEnabled( true )
		model.DoClick = function( s )
			if not s.Enabled then return end
			if BUC2.buttonsLocked then return end
			self:SetLeft( i )
		end
		model.SetEnabled = function( s, b )
			s.Enabled = b
			if b then
				s.PaintOver = nil
			else
				s.PaintOver = function( s, w, h )
					draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
				end
			end
		end
		layout:Add( model )
	end
end
function UpgradePage:Update( )

	/*IGS.GetInventory(function( inventory ) -- Can upgrade purchases?
		if not IsValid( self ) then return end
		local i = 0
		IGS.GetMyPurchases( function( purchases )
			if not IsValid( self ) or not purchases then return end
			--local serverID = IGS.SERVERS:ID()
			self.Items = {}
			self:SetLeft( false )

			local i = 0
			for k,v in pairs( purchases ) do
				--[[ if v.server != serverID then
					continue
				end--]] 
				if not BUC2.UpgradeFromItems[ v.item ] then continue end
				i = i + 1
				self:Append( v.item, v.id )
			end
			for k,v in pairs( inventory ) do
				if not BUC2.UpgradeFromItems[ v.item.uid ] then continue end
				i = i + 1
				self:Append( v.item.uid, v.id, true )
			end
			self:ShowItems( )
		end )
	end)*/

	IGS.GetInventory( function( inventory ) -- Can upgrade purchases?
		if not IsValid( self ) or not inventory then return end
		self.Items = {}
		self:SetLeft( false )
		for k,v in pairs( inventory ) do
			if not BUC2.UpgradeFromItems[ v.item.uid ] then continue end
			self:Append( v.item.uid, v.id, true )
		end
		self:ShowItems( )
	end )

end
function UpgradePage:CreateSelectors()

	self.LeftScroll = vgui.Create( "DScrollPanel", self )
	local spacing = 20


	local LeftLayout = vgui.Create( "DIconLayout", self.LeftScroll )
	self.LeftLayout = LeftLayout
	LeftLayout:SetLayoutDir( TOP )
	LeftLayout:Dock( TOP )
	LeftLayout:SetBorder( 6 )
	LeftLayout:SetSpaceY( spacing )
	LeftLayout:SetSpaceX( spacing )

	self:Update( )


	local MoneySelector = vgui.Create( "EditablePanel", self.LeftScroll )
	self.MoneySelector = MoneySelector
	MoneySelector:SetPos( 0, 0 )
	MoneySelector:SetTall( 150 )
	MoneySelector:SetVisible( false )
	do
		local Wang = vgui.Create("DNumberWang", MoneySelector)
		Wang:Dock( TOP )
		Wang:SetTall( 40 )
		Wang:SetFont( "ub2_3" )
		Wang:SetValue( 1 )
		Wang:SetMin(1)
		Wang:SetMax( 999999 )
		Wang:DockMargin( 5, 5, 5, 5 )
		Wang.OnValueChanged = function( s )
			if BUC2.buttonsLocked then
				s.Think = function( s )
					if BUC2.buttonsLocked then return end
					s:OnValueChanged( )
					s.Think = nil
				end
				return
			end
			local x = tonumber(s:GetValue( ))
			x = math.min( x, 999999 )
			self:SetIsMoney( true )
			self:SetLeft( x )
			self:RecalculateChance( )
		end
		local old = Wang.Paint
		Wang.Paint = function( self, w, h )
			draw.RoundedBox( 6, 0, 0, w, h, Color( 26, 26, 26 ) )
			old( self, w, h )
		end
		Wang:SetTextColor( Color( 255, 255, 255 ) )
		Wang:SetPaintBackground( false )
		Wang:SetCursorColor( Color( 255, 255, 255 ) )
		Wang:SetUpdateOnType( true )

		local btn = vgui.Create( "EditablePanel", MoneySelector )
		btn:Dock( TOP )
		btn:SetTall( 40 )
		btn:DockMargin( 5, 5, 5, 5 )
		btn.Color = Color( 27, 151, 223 )
		btn.Paint = function( self, w, h )
			draw.RoundedBox( 6, 0, 0, w, h, self.Color )
			draw.SimpleText( "СДЕЛАТЬ СТАВКУ", "ub2_3", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	


	self.RightScroll = vgui.Create( "DScrollPanel", self )

	local RightLayout = vgui.Create( "DIconLayout", self.RightScroll )
	self.RightLayout = RightLayout
	RightLayout:SetLayoutDir( TOP )
	RightLayout:Dock( TOP )
	RightLayout:SetBorder( 6 )
	RightLayout:SetSpaceY( spacing )
	RightLayout:SetSpaceX( spacing )

	// Load inventory:
	RightLayout.Items = {} -- init table
	RightLayout.ShowItems = function( s )
		s:Clear( )
		for i, item in SortedPairsByMemberValue( s.Items, "price", true ) do
			local model = vgui.CreateFromTable( ModelPanel, s, "Hello" )
			s.Items[ i ].panel = model
			model:SetPos( 0, 0 )
			model:SetSize( 115, 115 )
			model.data = item
			model.i = i
			model.Enabled = true
			model:Set( item.name )
			model:SetMouseInputEnabled( true )
			model.DoClick = function( s )
				if BUC2.buttonsLocked then return end
				self:SetRight( i )
			end
			model.SetEnabled = function( s, b )
				s.Enabled = b
				if b then
					s.PaintOver = nil
				else
					s.PaintOver = function( s, w, h )
						draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
					end
				end
			end
			s:Add( model )
		end
	end
	function RightLayout:Append( id, isInventory )
		if not id then return end
		local found = ub_findByIGSid( id )
		if found then
			local igs = IGS.GetItemByUID( id )
			if not igs or igs.price == 0 then return end
			table.insert( self.Items, {
				name = found,
				price = igs.price,
				uid = id,
			} )
		end
	end
	for id, v in pairs( BUC2.UpgradeToItems ) do
		RightLayout:Append( id )
	end
	RightLayout:ShowItems( )
end
function UpgradePage:DoSpin( bool )
	self.SpinPanel:DoSpin( bool )
end

function UpgradePage:GetLeft( )
	return self.Left
end
function UpgradePage:SetLeft( i )

	if not i or self.IsMoney then
		self.Left = i
		self.LeftItem:Set( i )

		local prev = self.Items[ self:GetLeft( ) or -1 ]
		if prev and IsValid( prev.panel ) then
			prev.panel:SetEnabled( true )
		end

		return
	end

	local data = self.Items[ i ]
	if not data then return end
	if not IsValid( data.panel ) then return end

	local prev = self.Items[ self:GetLeft( ) or -1 ]
	if prev and IsValid( prev.panel ) then
		prev.panel:SetEnabled( true )
	end

	data.panel:SetEnabled( false )
	self.Left = i

	self.LeftItem:Set( data.name )

	self:RecalculateChance( )
end
function UpgradePage:SetRight( i )
	local layout = self.RightLayout

	if not IsValid( layout ) then return end
	local data = layout.Items[ i ]

	local prev = layout.Items[ self:GetRight( ) or -1 ]
	if prev and IsValid( prev.panel ) then
		prev.panel:SetEnabled( true )
	end

	data.panel:SetEnabled( false )

	self.RightItem:Set( data.name )
	self.Right = i

	self:RecalculateChance( )
end

function UpgradePage:GetRight( )
	return self.Right
end

function UpgradePage:RecalculateChance( )
	local left, right = self:GetLeft( ), self:GetRight( )

	if not left or not right then
		self.Chance = 0
	end

	local left_item = self.IsMoney and {price = left} or self.Items[ left ]
	local right_item = self.RightLayout.Items[ right ]

	if not left_item or not right_item then return end

	self.Chance = math.Round( math.Clamp( left_item.price / right_item.price, 0, 1 ), 3 ) * 100
end
function UpgradePage:Paint( w, h )
	--draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 0, 0 ) )
end
function UpgradePage:PerformLayout( w, h )
	// Main Animation
	self.SpinPanel:SetSize( w / 5, w / 5 )
	self.SpinPanel:SetPos( w*0.5 - self.SpinPanel:GetWide()*0.5, 0 )


	// Items
	self.LeftItem:SetSize( w / 3.7, w / 3.7 )
	self.LeftItem:SetPos( w/5 - self.LeftItem:GetWide()*0.5, -10 )

	self.RightItem:SetSize( w / 3.7, w / 3.7 )
	self.RightItem:SetPos( w * 4/5 - self.RightItem:GetWide()*0.5, -10 )


	// Control Buttons:
	local x,y = self.SpinPanel:GetPos( )
	local wide = self.SpinPanel:GetWide( )
	self.ControlFrame:SetPos( x + (wide - wide/1.5)*0.5, y + w/5 + 15 )
	self.ControlFrame:SetSize( wide/1.5, h - (h/3.5 - self.SpinPanel:GetTall()*0.5 + w/5 - 15) )


	// do Selectors
	local SelectorsWide = x + (wide - wide/1.5)*0.5 - 5
	local x,y = self.RightItem:GetPos( )
	local SelectorsY = y + self.RightItem:GetTall( ) - 16
	local tall = self.LeftItem:GetTall( )

		// Left Selector:
		self.LeftScroll:SetPos( 0, SelectorsY )
		self.LeftScroll:SetSize( SelectorsWide, h - SelectorsY )
		self.MoneySelector:SetWide( SelectorsWide )

		// Right Selector
		self.RightScroll:SetPos( w - SelectorsWide, SelectorsY )
		self.RightScroll:SetSize( SelectorsWide, h - SelectorsY )
end

return UpgradePage
--PATH gamemodes/darkrp/gamemode/core/core_sh.lua:
local string_comma = string.Comma
local concommand_Add = concommand.Add
local hook_call = hook.Call
local math_ceil = math.ceil
--
local pMeta = FindMetaTable( 'Player' )
--
DarkRP = {}
--
function rp.FormatMoney( n )
	return string_comma( n ) .. ' $'
end

function rp.formatMoney( n )
	return string_comma( n ) .. ' $'
end

DarkRP.formatMoney = rp.formatMoney
DarkRP.notify = function( a, _, _, ... ) return rp.notify( a, ... ) end
DarkRP.Notify = DarkRP.notify
function rp.ConCommand_Add( command, cooldown, func )
	if isfunction( cooldown ) then
		if SERVER then MsgC( Color( 255, 0, 0 ), 'ПОРУШЕНО СИНТАКСИС ConCommand_Add - ' .. command ) end
		return false
	end

	local ConCommand_CoolDown = ConCommand_CoolDown or 0
	cooldown = cooldown or 1
	concommand_Add( command, function( pl, text, args )
		if CurTime() > ConCommand_CoolDown + cooldown then
			if not IsValid(pl) then return end
			if pl:IsBanned() then
				rp.Notify( pl, 1, 'Ви були заблоковані.', '' )
				return false
			end

			func( pl, text, args )
			if SERVER then hook_call( 'PlayerStartCommand', nil, pl, command, args ) end
			ConCommand_CoolDown = CurTime()
		else
			rp.Notify( pl, 1, 'Зачекайте, будь ласка, # секунд перед використанням команди', math_ceil( ConCommand_CoolDown ) - math_ceil( CurTime() ) + cooldown )
		end
	end )
end

concommand.Add( 'pos', function( pl ) print( 'Vector(' .. math.ceil( pl:GetPos().x ) .. ',' .. math.ceil( pl:GetPos().y ) .. ',' .. math.ceil( pl:GetPos().z ) .. '),' ) end )
AddConsoleCommand( 'suk4ka' )
--
function pMeta:IsHitman()
	return rp.Team[self:Team()] and rp.Team[self:Team()].hitman or false
end

--
onyx.netvar:Register( 'Arrest', {
	type = TYPE_BOOL,
	public = true
} )

onyx.netvar:Register( 'Arrest_Info', {
	type = TYPE_TABLE,
	public = true
} )

onyx.netvar:Register( 'Warrant', {
	type = TYPE_BOOL,
	public = true
} )

onyx.netvar:Register( 'WarrantReson', {
	type = TYPE_STRING,
	public = true
} )

onyx.netvar:Register( 'Wanted', {
	type = TYPE_BOOL,
	public = true
} )

onyx.netvar:Register( 'WantedReson', {
	type = TYPE_STRING,
	public = true
} )

onyx.netvar:Register( 'Job', {
	type = TYPE_STRING,
	public = true
} )

onyx.netvar:Register( 'adminmode', {
	type = TYPE_BOOL,
	public = false
} )

onyx.netvar:Register( 'DeathTime', {
	type = TYPE_NUMBER,
	bits = 32,
	public = false
} )

onyx.netvar:Register( 'doorCount', {
	type = TYPE_NUMBER,
	bits = 5,
	public = false
} )

onyx.netvar:Register( 'Hunger', {
	type = TYPE_NUMBER,
	bits = 8,
	public = false
} )

onyx.netvar:Register( 'Name', {
	type = TYPE_STRING,
	public = true
} )

onyx.netvar:Register( 'Money', {
	type = TYPE_NUMBER,
	bits = 32,
	unsigned = true,
	public = true
} )

onyx.netvar:Register( 'Hitman_Money', {
	type = TYPE_NUMBER,
	bits = 32,
	unsigned = true,
	public = true
} )

onyx.netvar:Register( 'License', {
	type = TYPE_BOOL,
	public = true
} )
--PATH gamemodes/darkrp/gamemode/core/player/mayor/init_cl.lua:
local PANEL = {}
function PANEL:Init()
	local laws = nw.GetGlobal( 'rp.laws' ) or {}
	self:SetSize( ScrW() / 4, 200 )
	self:SetY( 5 )
	self:CenterHorizontal()
	self:ShowCloseButton( false )
	self:SetTitle( 'ЗАКОНИ' )
	for i, law in ipairs( laws ) do
		local law_panel = self:Add( 'onyx.Label' )
		law_panel:Dock( TOP )
		law_panel:DockMargin( 5, 4, 5, 0 )
		law_panel:SetTall( 32 )
		law_panel:SetText( i .. '. ' .. law )
		self:SetTall( 35 + i * 32 + i * 4 )
	end
end

vgui.Register( 'rp.laws', PANEL, 'onyx.Frame' )
local PANEL1 = {}
function PANEL1:Init()
	local laws = nw.GetGlobal( 'rp.laws' ) or {}
	for i, law in ipairs( laws ) do
		local mainpanel = self:Add( 'EditablePanel' )
		mainpanel:Dock( TOP )
		mainpanel:DockMargin( 5, 4, 5, 0 )
		mainpanel:SetTall( 32 )
		local law_panel = mainpanel:Add( 'onyx.Label' )
		law_panel:Dock( FILL )
		law_panel:SetText( i .. '. ' .. law )
		local bt = vgui.Create( 'onyx.Button', mainpanel )
		bt:Dock( RIGHT )
		bt:SetWide( 140 )
		bt:SetText( 'Видалити' )
		bt.DoClick = function()
			RunConsoleCommand( 'rp_law_remove', i )
			RunConsoleCommand( 'lawmenu' )
		end

		self:SetSize( ScrW() / 4, 35 + i * 32 + i * 4 )
	end
end

vgui.Register( 'rp.laws.edit', PANEL1, 'onyx.Panel' )
local fr
concommand.Add( 'lawmenu', function()
	timer.Simple( 0.1, function()
		if IsValid( fr ) then fr:Remove() end
		fr = vgui.Create( 'onyx.Frame' )
		fr:SetSize( 950, 600 )
		fr:SetTitle( 'ЗАКОНИ' )
		fr:Center()
		fr:MakePopup()
		local rplaws = vgui.Create( 'rp.laws.edit', fr )
		rplaws:Dock( FILL )
		local but = vgui.Create( 'onyx.Button', fr )
		but:SetSize( 300, 40 )
		but:SetPos( 10, 500 )
		but:SetText( 'Додати закон' )
		but.DoClick = function()
			onyx.SimpleQuery( 'Закони', 'Напишіть новий закон', true, function( text )
				RunConsoleCommand( 'rp_law_add', text )
				RunConsoleCommand( 'lawmenu' )
			end, 'Так', nil, 'Ні' )
		end

		local but = vgui.Create( 'onyx.Button', fr )
		but:SetSize( 300, 40 )
		but:SetPos( 320, 500 )
		but:SetText( 'Очистити закони' )
		but.DoClick = function()
			RunConsoleCommand( 'rp_law_reset' )
			RunConsoleCommand( 'lawmenu' )
		end

		local but = vgui.Create( 'onyx.Button', fr )
		but:SetSize( 300, 40 )
		but:SetPos( 630, 500 )
		but:SetText( 'Опублікувати закони' )
		but.DoClick = function()
			net.Start( 'mervisral' )
			net.WriteString( 'Мер змінив закони! Ознайомтеся.' )
			net.SendToServer()
		end
	end )
end )
--[[
hook.Add('OnContextMenuClose', 'rp.laws', function()
	fr:Remove()
end)
]]
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu_cl.lua:
local PANEL = {}
-- 126 
--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self.IsLayedOut = {}

	self:Populate()
	self:SetFadeTime(0)

end


--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
-----------------------------------------------------------]]
function PANEL:Populate()

	local tabs = spawnmenu.GetCreationTabs()

	for k, v in SortedPairsByMemberValue(tabs, "Order") do

		if self.IsLayedOut[k] or (v.CustomCheck and (v.CustomCheck() == false)) then continue end

		self.IsLayedOut[k] = true

		--
		-- Here we create a panel and populate it on the first paint
		-- that way everything is created on the first view instead of
		-- being created on load.
		--
		local pnl = vgui.Create("Panel")

		self:AddSheet(k, pnl, v.Icon, nil, nil, v.Tooltip)

		--
		-- On paint, remove the paint function and populate the panel
		--
		pnl.Paint = function()

			pnl.Paint = nil

			local childpnl = v.Function()
			childpnl:SetParent(pnl)
			childpnl:Dock(FILL)

		end


	end

end

vgui.Register("CreationMenu", PANEL, "DPropertySheet")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contentsidebar_cl.lua:
CONTENTSEARCHLOAD = true
local pnlSearch = vgui.RegisterFile("ContentSearch_cl.lua")
CONTENTSEARCHLOAD = nil

local PANEL = {}

function PANEL:Init()

	self.Tree = vgui.Create("DTree", self)
	self.Tree:SetClickOnDragHover(true)
	self.Tree.OnNodeSelected = function(Tree, Node ) hook.Call("ContentSidebarSelection", GAMEMODE, self:GetParent(), Node) end
	self.Tree:Dock(FILL)
	self.Tree:SetBackgroundColor(Color(240, 240, 240, 255))

	self:SetPaintBackground(false)

end

function PANEL:EnableModify()

	self.Search = vgui.CreateFromTable(pnlSearch, self)
	self:CreateSaveNotification()

	self.Toolbox = vgui.Create("ContentSidebarToolbox", self)

	hook("OpenToolbox", "OpenToolbox", function()

		if (!IsValid(self.Toolbox)) then return end

		self.Toolbox:Open()

	end )

end

function PANEL:CreateSaveNotification()

	local SavePanel = vgui.Create("DButton", self)
		SavePanel:Dock(TOP)
		SavePanel:DockMargin(16, 1, 16, 4)
		SavePanel:SetIcon("icon16/disk.png")
		SavePanel:SetText("#spawnmenu.savechanges")
		SavePanel:SetVisible(false)

		SavePanel.DoClick = function()

			SavePanel:SlideUp(0.2)
			hook.Run("OnSaveSpawnlist")

		end

	hook("SpawnlistContentChanged", "ShowSaveButton", function()

		if (SavePanel:IsVisible()) then return end

		SavePanel:SlideDown(0.2)


	end )


end

vgui.Register("ContentSidebar", PANEL, "DPanel")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contenttypes/vehicles_cl.lua:
hook("PopulateVehicles", "AddEntityContent", function(pnlContent, tree, node)

	local Categorised = {}

	-- Add this list into the tormoil
	local Vehicles = list.Get("Vehicles")
	if (Vehicles) then
		for k, v in pairs(Vehicles) do

			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			v.ClassName = k
			v.PrintName = v.Name
			v.ScriptedEntityType = 'vehicle'
			table.insert(Categorised[ v.Category ], v)

		end
	end

	--
	-- Add a tree node for each category
	--
	for CategoryName, v in SortedPairs(Categorised) do

		-- Add a node to the tree
		local node = tree:AddNode(CategoryName, "icon16/bricks.png")

			-- When we click on the node - populate it using this function
		node.DoPopulate = function(self)

			-- If we've already populated it - forget it.
			if (self.PropPanel) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)

			for k, ent in SortedPairsByMemberValue(v, "PrintName") do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel,
				{
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly

				})

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function(self)

			self:DoPopulate()
			pnlContent:SwitchPanel(self.PropPanel)

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode(0)
	if (IsValid(FirstNode)) then
		FirstNode:InternalDoClick()
	end

end )


spawnmenu.AddCreationTab("#spawnmenu.category.vehicles", function()

	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVehicles")
	return ctrl

end, "icon16/car.png", 50, nil, function() return IsValid(LocalPlayer()) and LocalPlayer():IsSuperAdmin() end )
--PATH gamemodes/darkrp/gamemode/modules/fixmore/sh_tools.lua:
for k, v in next, list.GetForEdit( "OverrideMaterials" ) do
	if v == "models/props_interiors/metalfence007a" or v == "models/props_combine/tprings_globe" then
		table.remove( list.GetForEdit( "OverrideMaterials" ), k )
		break
	end
end
--PATH gamemodes/darkrp/entities/weapons/arrest_baton.lua:

-----------------------------------------------------
AddCSLuaFile()
local BaseClass = baseclass.Get('baton_base')

if CLIENT then
	SWEP.PrintName = 'Заарештувати'
	SWEP.SlotPos = 4
	SWEP.Instructions = 'Left click to arrest\nRight click to switch to unarrest'
	SWEP.Spawnable = true
end

SWEP.Color = Color(255, 0, 0, 255)


function SWEP:PrimaryAttack()
	if not IsValid(self.Owner) then return end
	BaseClass.PrimaryAttack(self)
	if CLIENT then return end
	self.Owner:LagCompensation(true)
	local ent = self.Owner:GetEyeTrace().Entity
	self.Owner:LagCompensation(false)
	if not IsValid(ent) or (self.Owner:GetPos():Distance(ent:GetPos()) > self.HitDistance) then return end

	local pl = self.Owner

	if ent:onyx_GetNetVar('Arrest') then
		rp.Notify(pl,1,'Людина вже Заарештована','')
		return
	end
	if ent:IsPlayer() and ent:IsHandcuffed() == false then 
		rp.Notify(pl,1,'Спочатку одягніть наручники','')
		return
	end
	if not ent:IsPlayer() or (not ent:IsWanted()) then
	   rp.Notify(pl,1,'Спочатку оголосіть людину в розшукк (ВИКОРИСТАЙТЕ РАЦІЮ)','')
	   return
	end

	timer.Simple(0, function()
		if IsValid(self) then
			ent:UnWanted(self.Owner)
			ent:Arrest(self.Owner)
		end
	end)

end

function SWEP:SecondaryAttack()
	if not IsValid(self.Owner) then return end

	if SERVER and self.Owner:HasWeapon('unarrest_baton') then
		self.Owner:SelectWeapon('unarrest_baton')
	end

	self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)
end
--PATH addons/__main/lua/weapons/bobs_scoped_base/shared.lua:
-- Variables that are used on both client and server
SWEP.Category				= ""
SWEP.Author				= "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.DrawCrosshair			= true	
SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true

SWEP.Base 				= "bobs_gun_base"

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.Sound 			= Sound("")				-- Sound of the gun
SWEP.Primary.Round 			= ("")					-- What kind of bullet?
SWEP.Primary.RPM				= 0					-- This is in Rounds Per Minute
SWEP.Primary.Cone			= 0.15					-- Accuracy of NPCs
SWEP.Primary.Recoil		= 10
SWEP.Primary.Damage		= 10
SWEP.Primary.Spread		= .01					--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.NumShots	= 1
SWEP.Primary.ClipSize			= 0					-- Size of a clip
SWEP.Primary.DefaultClip			= 0					-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 0					-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0					-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0					-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true					-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"					-- What kind of ammo

-- SWEP.Secondary.ClipSize			= 0					-- Size of a clip
-- SWEP.Secondary.DefaultClip			= 0					-- Default number of bullets in a clip
-- SWEP.Secondary.Automatic			= false					-- Automatic/Semi Auto if
SWEP.Secondary.Ammo			= ""

SWEP.Secondary.ScopeZoom			= 0
SWEP.Secondary.UseACOG			= false	
SWEP.Secondary.UseMilDot			= false		
SWEP.Secondary.UseSVD			= false	
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex		= false	

SWEP.Scoped				= true

SWEP.BoltAction		= false	

SWEP.Penetration			= true
SWEP.Ricochet			= true	
SWEP.MaxRicochet			= 10

SWEP.Tracer				= 0	

SWEP.data 				= {}					-- The starting firemode
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 			= 0.5
SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)

function SWEP:Initialize()
	self.Weapon:SetNWBool("Reloading", false)
	util.PrecacheSound(self.Primary.Sound)
	if CLIENT then
	
		-- We need to get these so we can scale everything to the player's current resolution.
		local iScreenWidth = surface.ScreenWidth()
		local iScreenHeight = surface.ScreenHeight()
		
		-- The following code is only slightly riped off from Night Eagle
		-- These tables are used to draw things like scopes and crosshairs to the HUD.
		-- so DONT GET RID OF IT!

		self.ScopeTable = {}
		self.ScopeTable.l = iScreenHeight*self.ScopeScale
		self.ScopeTable.x1 = 0.5*(iScreenWidth + self.ScopeTable.l)
		self.ScopeTable.y1 = 0.5*(iScreenHeight - self.ScopeTable.l)
		self.ScopeTable.x2 = self.ScopeTable.x1
		self.ScopeTable.y2 = 0.5*(iScreenHeight + self.ScopeTable.l)
		self.ScopeTable.x3 = 0.5*(iScreenWidth - self.ScopeTable.l)
		self.ScopeTable.y3 = self.ScopeTable.y2
		self.ScopeTable.x4 = self.ScopeTable.x3
		self.ScopeTable.y4 = self.ScopeTable.y1
		self.ScopeTable.l = (iScreenHeight + 1)*self.ScopeScale -- I don't know why this works, but it does.

		self.QuadTable = {}
		self.QuadTable.x1 = 0
		self.QuadTable.y1 = 0
		self.QuadTable.w1 = iScreenWidth
		self.QuadTable.h1 = 0.5*iScreenHeight - self.ScopeTable.l
		self.QuadTable.x2 = 0
		self.QuadTable.y2 = 0.5*iScreenHeight + self.ScopeTable.l
		self.QuadTable.w2 = self.QuadTable.w1
		self.QuadTable.h2 = self.QuadTable.h1
		self.QuadTable.x3 = 0
		self.QuadTable.y3 = 0
		self.QuadTable.w3 = 0.5*iScreenWidth - self.ScopeTable.l
		self.QuadTable.h3 = iScreenHeight
		self.QuadTable.x4 = 0.5*iScreenWidth + self.ScopeTable.l
		self.QuadTable.y4 = 0
		self.QuadTable.w4 = self.QuadTable.w3
		self.QuadTable.h4 = self.QuadTable.h3

		self.LensTable = {}
		self.LensTable.x = self.QuadTable.w3
		self.LensTable.y = self.QuadTable.h1
		self.LensTable.w = 2*self.ScopeTable.l
		self.LensTable.h = 2*self.ScopeTable.l

		self.ReticleTable = {}
		self.ReticleTable.wdivider = 3.125
		self.ReticleTable.hdivider = 1.7579/self.ReticleScale		-- Draws the texture at 512 when the resolution is 1600x900
		self.ReticleTable.x = (iScreenWidth*0.5)-((iScreenHeight/self.ReticleTable.hdivider)*0.5)
		self.ReticleTable.y = (iScreenHeight*0.5)-((iScreenHeight/self.ReticleTable.hdivider)*0.5)
		self.ReticleTable.w = iScreenHeight/self.ReticleTable.hdivider
		self.ReticleTable.h = iScreenHeight/self.ReticleTable.hdivider

		self.FilterTable = {}
		self.FilterTable.wdivider = 3.125
		self.FilterTable.hdivider = 1.7579/1.35	
		self.FilterTable.x = (iScreenWidth*0.5)-((iScreenHeight/self.FilterTable.hdivider)*0.5)
		self.FilterTable.y = (iScreenHeight*0.5)-((iScreenHeight/self.FilterTable.hdivider)*0.5)
		self.FilterTable.w = iScreenHeight/self.FilterTable.hdivider
		self.FilterTable.h = iScreenHeight/self.FilterTable.hdivider

		
	end
	if SERVER then
		self:SetNPCMinBurst(3)
		self:SetNPCMaxBurst(10)
		self:SetNPCFireRate(1)
		--self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
	end
	self:SetHoldType(self.HoldType)
	
	if CLIENT then
	
		-- // Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- // init view model bone build function
		if IsValid(self.Owner) and self.Owner:IsPlayer() then
		if self.Owner:Alive() then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				-- // Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- // however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
			
		end
		end
		
	end
	
	if CLIENT then
		local oldpath = "vgui/hud/name" -- the path goes here
		local newpath = string.gsub(oldpath, "name", self.Gun)
		self.WepSelectIcon = surface.GetTextureID(newpath)
	end

end

function SWEP:BoltBack()
	if self.Weapon:Clip1() > 0 or self.Owner:GetAmmoCount( self.Weapon:GetPrimaryAmmoType() ) > 0 then
		timer.Simple(.25, function()
		if SERVER and self.Weapon != nil then 
			self.Weapon:SetNWBool("Reloading", true)
			if self.Weapon:GetClass() == self.Gun then
				if(self:GetIronsights() == true) then
					self.Owner:SetFOV( 0, 0.3 )
					self:SetIronsights(false)
					self.Owner:DrawViewModel(true)
				end
				local boltactiontime = (self.Owner:GetViewModel():SequenceDuration())
				timer.Simple(boltactiontime + .1, 
					function() if SERVER and self.Weapon != nil then
						self.Weapon:SetNWBool("Reloading", false)
						if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
							self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
							self.IronSightsPos = self.SightsPos					-- Bring it up
							self.IronSightsAng = self.SightsAng					-- Bring it up
							self.DrawCrosshair = false
							self:SetIronsights(true, self.Owner)
							self.Owner:DrawViewModel(false)
						end
					end 
				end)
			end
		else return end end )
	end	
end

function SWEP:Reload()

	if self.Owner:KeyDown(IN_USE) then return end
	
	self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	if !self.Owner:IsNPC() then
	self.Idle = CurTime() + self.Owner:GetViewModel():SequenceDuration() end

	if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
	-- When the current clip < full clip and the rest of your ammo > 0, then

		self.Owner:SetFOV( 0, 0.3 )
		-- Zoom = 0

		self:SetIronsights(false)
		-- Set the ironsight to false
		self.Weapon:SetNWBool("Reloading", true)
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
	end
	
	local waitdammit
	if self.Owner:GetViewModel() == nil then 
		waitdammit = 3
	else
		waitdammit = (self.Owner:GetViewModel():SequenceDuration())
	end
	timer.Simple(waitdammit + .1, function()
	if self.Weapon != nil then 
	self.Weapon:SetNWBool("Reloading", false)
	if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
		if CLIENT then return end
		self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
		self.IronSightsPos = self.SightsPos					-- Bring it up
		self.IronSightsAng = self.SightsAng					-- Bring it up
		self.DrawCrosshair = false
		self:SetIronsights(true, self.Owner)
		self.Owner:DrawViewModel(false)
 	elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
		if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		end
		self.IronSightsPos = self.RunSightsPos					-- Hold it down
		self.IronSightsAng = self.RunSightsAng					-- Hold it down
		self:SetIronsights(true, self.Owner)					-- Set the ironsight true
		self.Owner:SetFOV( 0, 0.2 )
	else return end
	end end)
end

function SWEP:PostReloadScopeCheck()
	if self.Weapon != nil then 
	self.Weapon:SetNWBool("Reloading", false)
	if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
		if CLIENT then return end
		self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
		self.IronSightsPos = self.SightsPos					-- Bring it up
		self.IronSightsAng = self.SightsAng					-- Bring it up
		self.DrawCrosshair = false
		self:SetIronsights(true, self.Owner)
		self.Owner:DrawViewModel(false)
 	elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
		if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		end
		self.IronSightsPos = self.RunSightsPos					-- Hold it down
		self.IronSightsAng = self.RunSightsAng					-- Hold it down
		self:SetIronsights(true, self.Owner)					-- Set the ironsight true
		self.Owner:SetFOV( 0, 0.2 )
	else return end
	end
end


/*---------------------------------------------------------
IronSight
---------------------------------------------------------*/
function SWEP:IronSight()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	
	if self.SelectiveFire and self.NextFireSelect < CurTime() and not (self.Weapon:GetNWBool("Reloading")) then
		if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_RELOAD) then
			self:SelectFireMode()
		end
	end
	
	if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_ATTACK2) then return end
	
	if self.Owner:KeyPressed(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then		-- If you hold E and you can shoot then
	if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
		self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
	end
	self.IronSightsPos = self.RunSightsPos					-- Hold it down
	self.IronSightsAng = self.RunSightsAng					-- Hold it down
	self:SetIronsights(true, self.Owner)					-- Set the ironsight true
	self.Owner:SetFOV( 0, 0.2 )
	end	
							
	if self.Owner:KeyDown(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then		-- If you hold E or run then
		if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		end								-- Lower the gun
	end
	
	if self.Owner:KeyReleased(IN_USE) || self.Owner:KeyReleased (IN_SPEED) then	-- If you release E then
	self:SetIronsights(false, self.Owner)					-- Set the ironsight true
	self.DrawCrosshair = self.XHair
	end


	if self.Owner:KeyPressed(IN_SPEED) || self.Owner:KeyPressed(IN_USE) then	-- If you run then
		self.Owner:SetFOV( 0, 0.2 )
		self.DrawCrosshair = false
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
	end	

		if self.Owner:KeyPressed(IN_ATTACK2) and !self.Owner:KeyDown(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then
			self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
			self.IronSightsPos = self.SightsPos					-- Bring it up
			self.IronSightsAng = self.SightsAng					-- Bring it up
			self.DrawCrosshair = false
			self:SetIronsights(true, self.Owner)
			if CLIENT then return end
			self.Owner:DrawViewModel(false)
		elseif self.Owner:KeyPressed(IN_ATTACK2) and not (self.Weapon:GetNWBool("Reloading")) and self.Owner:KeyDown(IN_SPEED) then
			if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
				self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
			end
			self.IronSightsPos = self.RunSightsPos					-- Hold it down
			self.IronSightsAng = self.RunSightsAng					-- Hold it down
			self:SetIronsights(true, self.Owner)					-- Set the ironsight true
			self.Owner:SetFOV( 0, 0.2 )
		end

	if (self.Owner:KeyReleased(IN_ATTACK2) || self.Owner:KeyDown(IN_SPEED)) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		self.Owner:SetFOV( 0, 0.2 )
		self:SetIronsights(false, self.Owner)
		self.DrawCrosshair = self.XHair
		-- Set the ironsight false
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
		end

		if self.Owner:KeyDown(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		self.SwayScale 	= 0.05
		self.BobScale 	= 0.05
		else
		self.SwayScale 	= 1.0
		self.BobScale 	= 1.0
		end
end

function SWEP:DrawHUD()


	if  self.Owner:KeyDown(IN_ATTACK2) and (self:GetIronsights() == true) and (!self.Owner:KeyDown(IN_SPEED) and !self.Owner:KeyDown(IN_USE)) then

			if self.Secondary.UseACOG then
			-- Draw the FAKE SCOPE THANG
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)

			-- Draw the CHEVRON
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_acogchevron"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the ACOG REFERENCE LINES
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_acogcross"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)
			end

			if self.Secondary.UseMilDot then
			-- Draw the MIL DOT SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_scopesight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseSVD then
			-- Draw the SVD SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_svdsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseParabolic then
			-- Draw the PARABOLIC SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_parabolicsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseElcan then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_elcanreticle"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)
			
			-- Draw the ELCAN SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_elcansight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseGreenDuplex then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_nvgilluminatedduplex"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end
			
			if self.Secondary.UseAimpoint then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/aimpoint"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			
			end
			
			if self.Secondary.UseMatador then
			
			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/rocketscope"))
			surface.DrawTexturedRect(self.LensTable.x-1, self.LensTable.y, self.LensTable.w, self.LensTable.h)

			end

	end
end

function SWEP:AdjustMouseSensitivity()
     
	if self.Owner:KeyDown(IN_ATTACK2) then
        return (1/(self.Secondary.ScopeZoom*0.5))
    	else 
    	return 1
     	end
end
--PATH addons/__main/lua/weapons/climb_swep2/cl_init.lua:
include("shared.lua")

CreateClientConVar("climbswep2_showhud", 1, true, false)
SWEP.PrintName       = "Climb SWEP 2"
SWEP.Slot             = 0
SWEP.SlotPos         = 4
SWEP.DrawAmmo         = false
SWEP.DrawCrosshair     = false

local flags = {FCVAR_REPLICATED, FCVAR_ARCHIVE};
CreateConVar("climbswep2_necksnaps", "0", flags);
CreateConVar("climbswep2_wallrun_minheight", "250", flags);
CreateConVar("climbswep2_roll_allweps", "0", flags);
CreateConVar("climbswep2_slide_allweps", "0", flags);
CreateConVar("climbswep2_maxjumps", "3", flags);
--PATH addons/__main/lua/weapons/d_slingshot/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("d_slingshot") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Wild Wing Slingshot"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 4			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pist_slings.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_pist_deagle.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/D_Slingshot/Catapult Fire.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 300			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 7		-- Size of a clip
SWEP.Primary.DefaultClip		= 28		-- Bullets you start with
SWEP.Primary.KickUp				= 2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(0,0,0)	--Iron Sight positions and angles. Use the Iron sights utility in 
SWEP.IronSightsAng = Vector(0,0,0)	--Clavus's Swep Construction Kit to get these vectors
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

SWEP.WElements = {
	["D_Slingshot"] = { type = "Model", model = "models/weapons/w_pist_slings.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(1.896, 0.328, 0.519), angle = Angle(0, -4.69, 180), size = Vector(0.722, 0.722, 0.722), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )
bshields.lang = {
	["English"] = {
		["sec"] = "[RMB] VISIBILITY",
		["dshieldprim"] = "[LMB] DEPLOY",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] ATTACK",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	},
	["German"] = {
		["sec"] = "[RMB] SICHTBARKEIT",
		["dshieldprim"] = "[LMB] PLAZIEREN",
		["hshieldprim"] = "[LMB] TÜR AUFBRECHEN",
		["rshieldprim"] = "[LMB] ANGREIFEN",
		["hshieldcd1"] = "Warte ",
		["hshieldcd2"] = " Sekunden für das Aufbrechen der nächsten Tür!"
	},
	["French"] = {
		["sec"] = "[RMB] VISIBILITÉ",
		["dshieldprim"] = "[LMB] DÉPLOYER",
		["hshieldprim"] = "[LMB] FORCER LA PORTE",
		["rshieldprim"] = "[LMB] ATTAQUER",
		["hshieldcd1"] = "Attendez ",
		["hshieldcd2"] = " secondes pour forcer la porte !"
	},
	["Danish"] = {
		["sec"] = "[RMB] SIGTBARHED",
		["dshieldprim"] = "[LMB] SÆT",
		["hshieldprim"] = "[LMB] BREACH DØR",
		["rshieldprim"] = "[LMB] ANGRIB",
		["hshieldcd1"] = "Vent ",
		["hshieldcd2"] = " sekunder at bryde ved siden af!"
	},
	["Turkish"] = {
		["sec"] = "[RMB] GORUNURLUK",
		["dshieldprim"] = "[LMB] YERLESTIR",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] SALDIR",
		["hshieldcd1"] = "Bekle ",
		["hshieldcd2"] = " bir sonraki kapıyı kırmaya saniye kaldı!"
	},
	["Russian"] = {
		["sec"] = "[ПКМ] ВИДИМОСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТЬ",
		["hshieldprim"] = "[ЛКМ] ВЫБИТЬ ДВЕРЬ",
		["rshieldprim"] = "[ЛКМ] УДАРИТЬ",
		["hshieldcd1"] = "Подождите ",
		["hshieldcd2"] = " секунд чтоб выбить дверь!"
	},
	["Ukrainian"] = {
		["sec"] = "[ПКМ] ВИДИМІСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТИ",
		["hshieldprim"] = "[ЛКМ] ВИБИТИ ДВЕРІ",
		["rshieldprim"] = "[ЛКМ] ВДАРИТИ",
		["hshieldcd1"] = "Зачекайте ",
		["hshieldcd2"] = " секунд щоб вибити двері!"
	}
}

if bshields.lang[bshields.config.language] == nil then bshields.config.language = "English" end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/stacker.lua:
TOOL.Category		= "Constraints"
TOOL.Name			= "#Tool.stacker.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "freeze" ]	 	= "0"
TOOL.ClientConVar[ "weld" ]	 	= "0"
TOOL.ClientConVar[ "nocollide" ]	= "0"
TOOL.ClientConVar[ "mode" ] 		= "1"
TOOL.ClientConVar[ "dir" ] 		= "1"
TOOL.ClientConVar[ "count" ] 		= "1"
TOOL.ClientConVar[ "model" ] 		= ""
TOOL.ClientConVar[ "offsetx" ] 		= "0"
TOOL.ClientConVar[ "offsety" ] 		= "0"
TOOL.ClientConVar[ "offsetz" ] 		= "0"
TOOL.ClientConVar[ "rotp" ] 		= "0"
TOOL.ClientConVar[ "roty" ] 		= "0"
TOOL.ClientConVar[ "rotr" ] 		= "0"
TOOL.ClientConVar[ "recalc" ] 		= "0"
TOOL.ClientConVar[ "ghostall" ]		= "1"
TOOL.ClientConVar[ "halo" ]			= "0"

if SERVER then
	util.AddNetworkString("StackGhost")
	util.AddNetworkString("UnstackGhost")
end

if ( CLIENT ) then
	language.Add( "Tool.stacker.name", "Stacker" )
	language.Add( "Tool.stacker.desc", "Stacks Props Easily" )
	language.Add( "Tool.stacker.0", "Click To Stack The Prop You're Pointing At." )
	language.Add( "Undone_stacker", "Undone Stacked Prop(s)" )
end

function TOOL:Holster()
	self:ReleaseGhostStack()
end

function TOOL:Deploy()
//	self.StackedEnts = {}
end

function TOOL:LeftClick(trace)
	if !trace.Entity || !trace.Entity:IsValid() || trace.Entity:GetClass() != "prop_physics" then return false end
	if CLIENT then return true end

	local Freeze		= self:GetClientNumber( "freeze" ) == 1
	local Weld		= self:GetClientNumber( "weld" ) == 1
	local NoCollide		= self:GetClientNumber( "nocollide" ) == 1
	local Mode		= self:GetClientNumber( "mode" )
	local Dir		= self:GetClientNumber( "dir" )
	local Count		= 1
	local OffsetX		= self:GetClientNumber( "offsetx" )
	local OffsetY		= self:GetClientNumber( "offsety" )
	local OffsetZ		= self:GetClientNumber( "offsetz" )
	local RotP		= self:GetClientNumber( "rotp" )
	local RotY		= self:GetClientNumber( "roty" )
	local RotR		= self:GetClientNumber( "rotr" )
	local Recalc		= self:GetClientNumber( "recalc" ) == 1
	local Offset		= Vector(OffsetX, OffsetY, OffsetZ)
	local Rot		= Angle(RotP, RotY, RotR)

	local ply = self:GetOwner()
	local Ent = trace.Entity

	local NewVec = Ent:GetPos()
	local NewAng = Ent:GetAngles()
	local LastEnt = Ent

	if Count <= 0 then return false end
	
	undo.Create("stacker")
	for i=1, Count, 1 do
		if !CPPIGetLimit(ply) then break end

		if i == 1 || (Mode == 2 && Recalc == true) then
			StackDir, Height, ThisOffset = self:StackerCalcPos(LastEnt, Mode, Dir, Offset)
		end
		
		NewVec = NewVec + StackDir * Height + ThisOffset
		NewAng = NewAng + Rot

		if !Ent:IsInWorld() then
			return false //Who put just break here? Seriously? Giving the player no hint he/she's not supposed to do that?
		end

	//	local EntList = ents.FindInSphere(NewVec, .2) //Searching in a sphere and find props
	//	local PropValid = true						//Flag if prop is found or not
	//	for k, v in pairs(EntList) do				//For loop
	//		if (v:IsValid() && v:GetClass() == "prop_physics" && (v == LastEnt )) then//|| v:GetPos() == NewVec)) then
	//			if (self:IsInGhostStack(v)) then continue end
	//			PropValid = false
	//		end
	//	end
	//	if !PropValid then return false end

		NewEnt = ents.Create("prop_physics")
			NewEnt:SetModel(Ent:GetModel())
			NewEnt:SetColor(Ent:GetColor())
			NewEnt:SetPos(NewVec)
			NewEnt:SetAngles(NewAng)
			NewEnt:Spawn()
			NewEnt:CPPISetOwner(ply)

				ply:AddFrozenPhysicsObject(NewEnt, NewEnt:GetPhysicsObject()) //Fix so you can mass-unfreeze
				NewEnt:GetPhysicsObject():EnableMotion(false)


		if Weld then
			local WeldEnt = constraint.Weld( LastEnt, NewEnt, 0, 0, 0 )
			undo.AddEntity(WeldEnt)
		end

		if NoCollide then
			local NoCollideEnt = constraint.NoCollide(LastEnt, NewEnt, 0, 0)
			undo.AddEntity(NoCollideEnt)
		end
		
		LastEnt = NewEnt
		undo.AddEntity(NewEnt)
		ply:AddCount("props", NewEnt)
		ply:AddCleanup("props", NewEnt)
		NewEnt:CPPISetOwner(ply)

		if PropDefender && PropDefender.Player && PropDefender.Player.Give then
			PropDefender.Player.Give(ply, NewEnt, false)
		end

		//table.insert(self.StackedEnts, NewEnt)
	end
	undo.SetPlayer(ply)
	undo.Finish()

	return true
end

function TOOL:StackerCalcPos(lastent, mode, dir, offset)
	local forward = Vector(1,0,0):Angle()
	local pos = lastent:GetPos()
	local ang = lastent:GetAngles()

	local lower, upper = lastent:WorldSpaceAABB( )
	local glower = lastent:OBBMins()
	local gupper = lastent:OBBMaxs()
	
	local stackdir = Vector(0,0,1)
	local height = math.abs(upper.z - lower.z)

	if mode == 1 then // Relative to world
		if dir == 1 then
			stackdir = forward:Up()
			height = math.abs(upper.z - lower.z)
		elseif dir == 2 then
			stackdir = forward:Up() * -1
			height = math.abs(upper.z - lower.z)
		elseif dir == 3 then
			stackdir = forward:Forward()
			height = math.abs(upper.x - lower.x)
		elseif dir == 4 then
			stackdir = forward:Forward() * -1
			height = math.abs(upper.x - lower.x)
		elseif dir == 5 then
			stackdir = forward:Right()
			height = math.abs(upper.y - lower.y)
		elseif dir == 6 then
			stackdir = forward:Right() * -1
			height = math.abs(upper.y - lower.y)
		end
	elseif mode == 2 then // Relative to prop
		forward = ang
		if dir == 1 then
			stackdir = forward:Up()
			offset = forward:Up() * offset.X + forward:Forward() * -1 * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.z - glower.z)
		elseif dir == 2 then
			stackdir = forward:Up() * -1
			offset = forward:Up() * -1 * offset.X + forward:Forward() * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.z - glower.z)
		elseif dir == 3 then
			stackdir = forward:Forward()
			offset = forward:Forward() * offset.X + forward:Up() * offset.Z + forward:Right() * offset.Y
			height = math.abs(gupper.x - glower.x)
		elseif dir == 4 then
			stackdir = forward:Forward() * -1
			offset = forward:Forward() * -1 * offset.X + forward:Up() * offset.Z + forward:Right() * -1 * offset.Y
			height = math.abs(gupper.x - glower.x)
		elseif dir == 5 then
			stackdir = forward:Right()
			offset = forward:Right() * offset.X + forward:Up() * offset.Z + forward:Forward() * -1 * offset.Y
			height = math.abs(gupper.y - glower.y)
		elseif dir == 6 then
			stackdir = forward:Right() * -1
			offset = forward:Right() * -1 * offset.X + forward:Up() * offset.Z + forward:Forward() * offset.Y
			height = math.abs(gupper.y - glower.y)
		end
	end //offset = (stackdir:Angle():Up() * offset.Z) + (stackdir:Angle():Forward() * offset.X) + (stackdir:Angle():Right() * offset.Y)
	
	return stackdir, height, offset
end

function TOOL.BuildCPanel( CPanel )
    CPanel:AddControl("Header", { Text = "#Tool.stacker.name", Description    = "#Tool.stacker.desc" })
    
    CPanel:AddControl( "Checkbox", { Label = "Сварить Пропы", Command = "stacker_weld" } )    

    local params = {Label = "Направление", MenuButton = "0", Options = {}}
    params.Options["Вверх"] = {stacker_dir = "1"}
    params.Options["Вниз"] = {stacker_dir = "2"}
    params.Options["Вперед"] = {stacker_dir = "3"}
    params.Options["Назад"] = {stacker_dir = "4"}
    params.Options["Право"] = {stacker_dir = "5"}
    params.Options["Лево"] = {stacker_dir = "6"}
    CPanel:AddControl( "ComboBox", params )


    CPanel:AddControl( "Header", { Text = "Advanced Options", Description    = "Эти настройки для опытних игроков, если вы не знаете как это работает оставьте настройки на стандартних.." }  )
    CPanel:AddControl( "Button",  { Label    = "Reset Advanced Options",
                    Command = "stacker_resetoffsets",
                    Text = "Reset"}     )
    CPanel:AddControl( "Slider",  { Label    = "Кордината X (вперёд/назад)",
                    Type    = "Float",
                    Min        = -1000,
                    Max        = 1000,
                    Value    = 0,
                    Command = "stacker_offsetx"}     )
    CPanel:AddControl( "Slider",  { Label    = "Кордината Y (право/лево)",
                    Type    = "Float",
                    Min        = -1000,
                    Max        = 1000,
                    Value    = 0,
                    Command = "stacker_offsety"}     )
    CPanel:AddControl( "Slider",  { Label    = "Кордината Z (верх/вниз)",
                    Type    = "Float",
                    Min        = -1000,
                    Max        = 1000,
                    Value    = 0,
                    Command = "stacker_offsetz"}     )
    CPanel:AddControl( "Slider",  { Label    = "Rotate Pitch",
                    Type    = "Float",
                    Min        = -360,
                    Max        = 360,
                    Value    = 0,
                    Command = "stacker_rotp"}     )
    CPanel:AddControl( "Slider",  { Label    = "Rotate Yaw",
                    Type    = "Float",
                    Min        = -360,
                    Max        = 360,
                    Value    = 0,
                    Command = "stacker_roty"}     )
    CPanel:AddControl( "Slider",  { Label    = "Rotate Roll",
                    Type    = "Float",
                    Min        = -360,
                    Max        = 360,
                    Value    = 0,
                    Command = "stacker_rotr"}     )
end

if (CLIENT) then
	local function ResetOffsets(ply, command, arguments)
		-- Reset all of the offset options to 0
		LocalPlayer():ConCommand("stacker_offsetx 0\n")
		LocalPlayer():ConCommand("stacker_offsety 0\n")
		LocalPlayer():ConCommand("stacker_offsetz 0\n")
		LocalPlayer():ConCommand("stacker_rotp 0\n")
		LocalPlayer():ConCommand("stacker_roty 0\n")
		LocalPlayer():ConCommand("stacker_rotr 0\n")
		LocalPlayer():ConCommand("stacker_recalc 0\n")
	end
	concommand.Add( "stacker_resetoffsets", ResetOffsets )
end

function TOOL:UpdateGhostStack(ent)
	if (!ent || !ent:IsValid() || !self:CheckGhostStack()) then return end

	local mode		= self:GetClientNumber( "mode" )
	local dir		= self:GetClientNumber( "dir" )
	local offsetx		= self:GetClientNumber( "offsetx" )
	local offsety		= self:GetClientNumber( "offsety" )
	local offsetz		= self:GetClientNumber( "offsetz" )
	local rotp		= self:GetClientNumber( "rotp" )
	local roty		= self:GetClientNumber( "roty" )
	local rotr		= self:GetClientNumber( "rotr" )
	local offset		= Vector(offsetx, offsety, offsetz)
	local rot		= Angle(rotp, roty, rotr)
	local count = 1
	local recalc		= self:GetClientNumber( "recalc" ) == 1

	local NewEnt = ent
	local NewVec = NewEnt:GetPos()
	local NewAng = NewEnt:GetAngles()
	
	local stackdir, height, thisoffset
	
	for k,v in pairs(self.GhostStack) do
		if k == 1 || (mode == 2 && recalc == true) then
			stackdir, height, thisoffset = self:StackerCalcPos(NewEnt, mode, dir, offset)
		end

		NewVec = NewVec + stackdir * height + thisoffset
		NewAng = NewAng + rot

		v:SetAngles(NewAng)
		v:SetPos(NewVec)
		v:SetNoDraw(false)
		NewEnt = v
		//SimpleAdmin:Broadcast(k .. ": " .. tostring(NewAng) .. " : " .. tostring(NewVec) .. " : " .. tostring(v) .. ".")
	end
end

function TOOL:CheckGhostStack() //Returns if stack is ok
	if !self.GhostStack then return false end
	local count = 1
	for k,v in pairs(self.GhostStack) do
		if (!v || !v:IsValid()) then //if something in the table doesn't exist or it's a null entity tell em it's not ok
			return false
		end
	end
	if (table.Count(self.GhostStack) != count && (self:GetClientNumber("ghostall") == 1)) then
		return false
	elseif (table.Count(self.GhostStack) != 1 && (self:GetClientNumber("ghostall") == 0)) then
		return false
	end
	return true
end

function TOOL:IsInGhostStack(ent)
	if !self.GhostStack then return false end
	for k,v in pairs(self.GhostStack) do
		if (ent == v) then
			return true
		end
	end
	return false
end

function TOOL:CreateGhostStack(prop, pos, ang)
	if(self.GhostStack) then self:ReleaseGhostStack() end
	self.GhostStack = {}

	if (SERVER && !game.SinglePlayer()) then return false end
	if (CLIENT && game.SinglePlayer()) then return false end
	
	local Halo = true
	local Count = 1
	local GhostAll = true
	if (!GhostAll && Count != 0) then
		Count = 1
	end

	for i = 1, Count, 1 do
		local Ghost

		if ( CLIENT ) then
			Ghost = ents.CreateClientProp(prop)
		else
			Ghost = ents.Create("prop_physics")
		end
		
		if (!IsValid(Ghost)) then
			Ghost = nil
			return
		end

		Ghost:SetModel(prop)
		Ghost:SetPos(pos)
		Ghost:SetAngles(ang)
		Ghost:Spawn()

		Ghost:SetSolid(SOLID_VPHYSICS)
		Ghost:SetMoveType(MOVETYPE_NONE)
		Ghost:SetNotSolid(true)
		Ghost:SetRenderMode(RENDERMODE_TRANSALPHA)
		Ghost:SetColor(Color(255, 255, 255, 150))

		table.insert(self.GhostStack, Ghost)
		if SERVER && Halo then
		end
	end
	return true
end

function TOOL:ReleaseGhostStack()
	if !self.GhostStack then return end
	for k,v in pairs(self.GhostStack) do
		if !v || !v:IsValid() then continue end
		v:Remove()
	end

	table.Empty(self.GhostStack)
end

function TOOL:Think()
	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace()
	local stacked = false
	if (IsValid(trace.Entity) && trace.Hit && trace.Entity:GetClass() == "prop_physics") then
		self.NewEnt = trace.Entity
		if (self.NewEnt:IsValid() && self.NewEnt != self.LastEnt) then
			//SimpleAdmin:Broadcast("Creating new stack.")
			stacked = self:CreateGhostStack(self.NewEnt:GetModel(), Vector(0,0,0), Angle(0,0,0))
			if stacked then self.LastEnt = self.NewEnt end
		end
		if (!self:CheckGhostStack()) then
			//SimpleAdmin:Broadcast("Releasing old stack.")
			self:ReleaseGhostStack()
			self.LastEnt = nil
		end
	elseif ((IsValid(trace.Entity) && trace.Entity:GetClass() != "prop_physics" && self.LastEnt != nil) || !IsValid(trace.Entity)) then
		//SimpleAdmin:Broadcast("Releasing old stack.")
		self:ReleaseGhostStack()
		self.LastEnt = nil
	end
	if (self.LastEnt != nil && self.LastEnt:IsValid()) then
		//SimpleAdmin:Broadcast("Updating old stack.")
		self:UpdateGhostStack(self.LastEnt)
	end
	if CLIENT then
		//MsgN(tostring(table.Count(self.GhostStack)) .. " : " .. tostring(table.Count(self)))
		if (!GhostStack || table.Count(GhostStack) <= 0) then return end
		for k, v in pairs(GhostStack) do
			halo.Add({v}, Color(181, 0, 217))
		end
	end
end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("Roboto_40")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("Roboto_40")
	local w2, h2 = surface.GetTextSize(" ")

	rp.ShadowText("Стакай пропы", "Roboto_40", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	rp.ShadowText("Красавчик)", "Roboto_40", 128, 128 + (h + h2) * 0.5 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/textscreens.lua:
TOOL.Category		= "Roleplay"
TOOL.Name			= "Текст"
TOOL.Command		= nil
TOOL.ConfigName		= ""
-- 16 
local createdfonts = {}

local function getFont(name, size)
	if (!createdfonts[name] or !createdfonts[name][size]) then
		local fd = {
			font = name,
			size = size,
			weight = 1500,
			shadow = true,
			antialias = true,
			symbol = (name == "Webdings")
		}

		surface.CreateFont('CV' .. name .. size, fd)

		createdfonts[name] = createdfonts[name] or {}
		createdfonts[name][size] = true
	end

	 return ('CV' .. name .. size)
end


local TextBox = {}
local linelabels = {}
local labels = {}
local fontpickers = {}
local sliders = {}
for i = 1, 3 do
	TOOL.ClientConVar[ "font"..i ] = rp.Setting.TextSrceenFonts[1]
	TOOL.ClientConVar[ "text"..i ] = ""
	TOOL.ClientConVar[ "size"..i ] = 20
	TOOL.ClientConVar[ "r"..i ] = 255
	TOOL.ClientConVar[ "g"..i ] = 255
	TOOL.ClientConVar[ "b"..i ] = 255
	TOOL.ClientConVar[ "a"..i ] = 255
end

cleanup.Register("textscreens")

if (CLIENT) then
	language.Add("Tool.textscreen.name", "Текст")
	language.Add("Tool.textscreen.desc", "Create a textscreen with multiple lines, font colours and sizes.")

	language.Add("Tool.textscreen.0", "Left Click: Spawn a textscreen Right Click: Update textscreen with settings")
	language.Add("Tool_textscreens_0", "Left Click: Spawn a textscreen Right Click: Update textscreen with settings")

	language.Add("Undone.textscreens", "Undone textscreen")
	language.Add("Undone_textscreens", "Undone textscreen")
	language.Add("Cleanup.textscreens", "Textscreens")
	language.Add("Cleanup_textscreens", "Textscreens")
	language.Add("Cleaned.textscreens", "Cleaned up all textscreens")
	language.Add("Cleaned_textscreens", "Cleaned up all textscreens")

	language.Add("SBoxLimit.textscreens", "You've hit the textscreen limit!")
	language.Add("SBoxLimit_textscreens", "You've hit the textscreen limit!")
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end

	local Ply = self:GetOwner()
	local Font = {}
	local Text = {}
	local color = {}
	local size = {}
	for i = 1, 3 do
		local font = self:GetClientInfo("font"..i)
		for k, v in ipairs(rp.Setting.TextSrceenFonts) do
			if (v == font) then
				table.insert(Font, i, k)
			end
		end
		if (!Font[i]) then Font[i] = 1 end

		table.insert(Text, i, self:GetClientInfo("text"..i))
		table.insert(color, i, Color(tonumber(self:GetClientInfo("r"..i)), tonumber(self:GetClientInfo("g"..i)), tonumber(self:GetClientInfo("b"..i)), tonumber(self:GetClientInfo("a"..i))))
		table.insert(size, i, tonumber(self:GetClientInfo("size"..i)))
	end

	local SpawnPos = tr.HitPos

	if not (self:GetWeapon():CheckLimit("textscreens")) then return false end

	if Ply:GetCount('textscreens') > 1 then
		rp.Notify(Ply,1,'Ліміт текстскрінів! Максимум 2!',"")
		return false 
	end

	local TextScreen = ents.Create("ent_textscreen")
	TextScreen:SetPos(SpawnPos)
	TextScreen:Spawn()
	TextScreen:CPPISetOwner(Ply)
	TextScreen:UpdateText(Font, Text, color, size)
	local angle = tr.HitNormal:Angle()
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	TextScreen:SetAngles(angle)
	TextScreen:Activate()
	TextScreen:CPPISetOwner(Ply)
	undo.Create("textscreens")

	undo.AddEntity(TextScreen)
	undo.SetPlayer(Ply)
	undo.Finish()

	Ply:AddCount("textscreens", TextScreen)



	Ply:AddCleanup("textscreens", TextScreen)


	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end

	local Ply = self:GetOwner()
	local Font = {}
	local Text = {}
	local color = {}
	local size = {}
	for i = 1, 3 do
		local font = self:GetClientInfo("font"..i)
		for k, v in ipairs(rp.Setting.TextSrceenFonts) do
			if (v == font) then
				table.insert(Font, i, k)
			end
		end
		if (!Font[i]) then Font[i] = 1 end

		table.insert(Text, i, self:GetClientInfo("text"..i))
		table.insert(color, i, Color(tonumber(self:GetClientInfo("r"..i)), tonumber(self:GetClientInfo("g"..i)), tonumber(self:GetClientInfo("b"..i)), tonumber(self:GetClientInfo("a"..i))))
		table.insert(size, i, tonumber(self:GetClientInfo("size"..i)))
	end

	local TraceEnt = tr.Entity

	if (TraceEnt:IsValid() and TraceEnt:GetClass() == "ent_textscreen") then
		TraceEnt:UpdateText(Font, Text, color, size)
		return true
	end
end

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {	Text = "Текст Скрін", Description	= "#Tool.textscreen.desc" })
	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)
	resetall:SetText("Reset all")
	resetall.DoClick = function()
		local menu = DermaMenu()
		menu:AddOption("Reset fonts", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_font"..i, "Tahoma")
			end
		end)
		menu:AddOption("Reset colors", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_r"..i, 255)
				RunConsoleCommand("textscreens_g"..i, 255)
				RunConsoleCommand("textscreens_b"..i, 255)
				RunConsoleCommand("textscreens_a"..i, 255)
			end
		end)
		menu:AddOption("Reset sizes", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_size"..i, 20)
				sliders[i]:SetValue(20)
			end
		end)
		menu:AddOption("Reset textboxes", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_text"..i, "")
				TextBox[i]:SetValue("")
			end
		end)
		menu:AddOption("Reset everything", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_r"..i, 255)
				RunConsoleCommand("textscreens_g"..i, 255)
				RunConsoleCommand("textscreens_b"..i, 255)
				RunConsoleCommand("textscreens_a"..i, 255)
				RunConsoleCommand("textscreens_size"..i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreens_text"..i, "")
				TextBox[i]:SetValue("")
			end
		end)
		menu:Open()
	end
	CPanel:AddItem(resetall)
	resetline = vgui.Create("DButton")
	resetline:SetSize(100, 25)
	resetline:SetText("Reset line")
	resetline.DoClick = function()
		local menu = DermaMenu()
		for i = 1, 3 do
			menu:AddOption("Reset line "..i, function()
				RunConsoleCommand("textscreens_font"..i, "Tahoma")
				RunConsoleCommand("textscreens_r"..i, 255)
				RunConsoleCommand("textscreens_g"..i, 255)
				RunConsoleCommand("textscreens_b"..i, 255)
				RunConsoleCommand("textscreens_a"..i, 255)
				RunConsoleCommand("textscreens_size"..i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreens_text"..i, "")
				TextBox[i]:SetValue("")
			end)
		end
		menu:AddOption("Reset all lines", function()
			for i = 1, 3 do
				RunConsoleCommand("textscreens_font"..i, "Tahoma")
				RunConsoleCommand("textscreens_r"..i, 255)
				RunConsoleCommand("textscreens_g"..i, 255)
				RunConsoleCommand("textscreens_b"..i, 255)
				RunConsoleCommand("textscreens_a"..i, 255)
				RunConsoleCommand("textscreens_size"..i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreens_text"..i, "")
				TextBox[i]:SetValue("")
			end
		end)
		menu:Open()
	end
	CPanel:AddItem(resetline)

	for i = 1, 3 do
		linelabels[i] = CPanel:AddControl("Label", {
			Text = "Line "..i,
			Description = "Line "..i
		})
		linelabels[i]:SetFont("Roboto_30")
		CPanel:AddControl("Color", {
			Label = "Line "..i.." font color",
			Red = "textscreens_r"..i,
			Green = "textscreens_g"..i,
			Blue = "textscreens_b"..i,
			Alpha = "textscreens_a"..i,
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})
		fontpickers[i] = vgui.Create("DComboBox")
		for k, v in ipairs(rp.Setting.TextSrceenFonts) do fontpickers[i]:AddChoice(v) end
		fontpickers[i]:ChooseOption("Tahoma")
		fontpickers[i].OnSelect = function(pnl, idx, value)
			RunConsoleCommand("textscreens_font"..i, value)
			labels[i]:SetFont(getFont(value or rp.Setting.TextSrceenFonts[1], math.Round(sliders[i]:GetValue())))
		end

		CPanel:AddItem(fontpickers[i])
		sliders[i] = vgui.Create("DNumSlider")
		sliders[i]:SetText("Font size")
		sliders[i]:SetMinMax(20, 100)
		sliders[i]:SetDecimals(0)
		sliders[i]:SetValue(20)
		sliders[i]:SetConVar("textscreens_size"..i)
		sliders[i].OnValueChanged = function(panel, value)
			local str, data = fontpickers[i]:GetSelected()
			str = str or rp.Setting.TextSrceenFonts[1]
			labels[i]:SetFont(getFont(str, math.Round(value)))
		end
		CPanel:AddItem(sliders[i])
		TextBox[i] = vgui.Create("DTextEntry")
		TextBox[i]:SetUpdateOnType(true)
		TextBox[i]:SetEnterAllowed(true)
		TextBox[i]:SetConVar("textscreens_text"..i)
		TextBox[i]:SetValue(GetConVarString("textscreens_text"..i))
		TextBox[i].OnTextChanged = function()
			labels[i]:SetText(TextBox[i]:GetValue())
		end
		CPanel:AddItem(TextBox[i])
		labels[i] = CPanel:AddControl("Label", {
			Text = "Line "..i,
			Description = "Line "..i
		})
		labels[i]:SetFont("Roboto_22")
		labels[i].Think = function()
			labels[i]:SetColor(Color(GetConVarNumber("textscreens_r"..i), GetConVarNumber("textscreens_g"..i), GetConVarNumber("textscreens_b"..i), GetConVarNumber("textscreens_a"..i)))
		end
	end
end
--PATH addons/_ballistic_shields/lua/weapons/heavy_shield/shared.lua:
if SERVER then
	include( "ballistic_shields/sh_bs_util.lua" )
	include( "ballistic_shields/sv_bs_util.lua" )
end

include( "bs_config.lua" )
include( "ballistic_shields/sh_bs_lang.lua" )
SWEP.PrintName = "Heavy shield"
SWEP.Author = "D3G"
SWEP.Instructions = "LMB - Breach door | RMB - Toggle visibility"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/hshield.mdl"
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Slot = 5
SWEP.SlotPos = 0
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Category = "Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55
function SWEP:Initialize()
	self:SetHoldType( "melee2" )
end

function SWEP:DrawWorldModel()
	self:SetNoDraw( true )
end

local function bsGetHoldType( ply )
	if ply:LookupAttachment( "anim_attachment_RH" ) > 0 then return { 1, "anim_attachment_RH" } end
	if ply:LookupAttachment( "forward" ) > 0 then return { 2, "forward" } end
	return { 3, "anim_attachment_head" }
end

local ShieldIcon = Material( "bshields/ui/heavy_shield", "smooth" )
local BackgroundIcon = Material( "bshields/ui/background" )
function SWEP:DrawHUD()
	if bshields.config.disablehud then return end
	surface.SetDrawColor( 255, 255, 255, 200 )
	surface.SetMaterial( BackgroundIcon )
	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10, ScrH() * 0.5 - ScrH() / 30 + ScrH() / 3, ScrH() / 5, ScrH() / 15 )
	local aim = LocalPlayer():GetAimVector()
	local tr = util.TraceLine( {
		start = LocalPlayer():GetShootPos(),
		endpos = LocalPlayer():GetShootPos() + aim * 70,
		filter = LocalPlayer()
	} )

	surface.SetDrawColor( 255, 255, 255, 125 )
	if not IsValid( tr.Entity ) or not tr.Entity:IsDoor() then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].hshieldprim, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].hshieldprim, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	end

	surface.SetMaterial( ShieldIcon )
	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10.2, ScrH() * 0.5 - ScrH() / 32 + ScrH() / 3, ScrH() / 16, ScrH() / 16 )
	if self.VisToggle then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false
	if SERVER then
		local owner = self:GetOwner()
		local holdtype = bsGetHoldType( owner )
		bshield_remove( owner )
		owner.bs_type = 2
		owner.bs_shield = ents.Create( "bs_hshield" )
		owner.bs_shield:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		owner.bs_shield:SetMoveType( MOVETYPE_NONE )
		owner.bs_shield:SetPos( owner:GetPos() )
		owner.bs_shield:SetParent( owner, owner:LookupAttachment( holdtype[2] ) )
		owner.bs_shield:SetLocalAngles( bshields.shields[holdtype[1]][1].angles )
		owner.bs_shield:SetLocalPos( bshields.shields[holdtype[1]][1].position )
		owner.bs_shield:Spawn()
		net.Start( "bs_shield_info" )
		net.WriteUInt( owner.bs_shield:EntIndex(), 16 )
		net.Send( owner )
	end
end

local function canRam( ply )
	return IsValid( ply ) and ( ply:onyx_GetNetVar( "Warrant" ) or ply:IsWanted() or ply:IsArrested() )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + 1 )
	local owner = self:GetOwner()
	if not owner.allowhshield then
		if SERVER then owner:ChatPrint( bshields.lang[bshields.config.language].hshieldcd1 .. ( math.ceil( timer.TimeLeft( "bshields_hcd_" .. owner:EntIndex() ) ) or 0 ) .. bshields.lang[bshields.config.language].hshieldcd2 ) end
		return
	end

	owner:LagCompensation( true )
	local trace = owner:GetEyeTrace()
	owner:LagCompensation( false )
	local ent = trace.Entity
	if not IsValid( ent ) then return end
	if not ( ent:IsDoor() or bshields.config.breachfdoors and ent.isFadingDoor ) then return end
	if ent.toDetonate then return end
	if owner:EyePos():DistToSqr( trace.HitPos ) > 3000 then return end
	if SERVER then
		if ent.isFadingDoor and bshields.config.breachfdoors then
			local fowner = ent:CPPIGetOwner()
			if not canRam( fowner ) then
				self:GetOwner():ChatPrint( "Вам потрібен ордер, щоб відчинити ці двері" )
				return
			end

			ent:EmitSound( "npc/metropolice/gear2.wav" )
			ent:EmitSound( "ballistic_shields/bomb_ticking.wav", 70, 100, 1 )
			ent.toDetonate = true
			timer.Simple( 3.4, function()
				if not IsValid( ent ) then return end
				local effectdata = EffectData()
				effectdata:SetOrigin( ent:GetPos() )
				effectdata:SetMagnitude( 5 )
				effectdata:SetScale( 2 )
				effectdata:SetRadius( 5 )
				util.Effect( "HelicopterMegaBomb", effectdata, true, true )
				ent:EmitSound( "physics/metal/metal_box_break1.wav" )
				ent:EmitSound( "ambient/explosions/explode_2.wav", 400 )
				ent:fadeActivate()
				ent.toDetonate = false
				timer.Simple( 8, function() if IsValid( ent ) and ent.fadeActive then ent:fadeDeactivate() end end )
			end )
		end

		if ent:IsDoor() then
			local allowed = false
			if not ent:DoorOwnedBy( fowner ) then
				for _, v in ipairs( player.GetAll() ) do
					if ent:DoorOwnedBy( v ) and canRam( v ) then
						allowed = true
						break
					end
				end
			else
				allowed = bshields.config.breachudoors
			end

			local keysDoorGroup = ent:DoorGetGroup()
			if keysDoorGroup then
				local teamDoors = rp.teamDoors[keysDoorGroup]
				if teamDoors then
					allowed = false
					for _, v in ipairs( player.GetAll() ) do
						if table.HasValue( teamDoors, v:Team() ) and canRam( v ) then
							allowed = true
							break
						end
					end
				end
			end

			if not allowed then
				self:GetOwner():ChatPrint( "Вам потрібен ордер, щоб відчинити ці двері" )
				return
			end

			local direction = owner:GetAimVector()
			ent:EmitSound( "npc/metropolice/gear2.wav" )
			ent:EmitSound( "ballistic_shields/bomb_ticking.wav", 70, 100, 1 )
			ent.toDetonate = true
			timer.Simple( 3.4, function()
				if not IsValid( ent ) then return end
				local effectdata = EffectData()
				effectdata:SetOrigin( ent:GetPos() - Vector( 0, 0, 24 ) )
				effectdata:SetMagnitude( 5 )
				effectdata:SetScale( 2 )
				effectdata:SetRadius( 5 )
				util.Effect( "HelicopterMegaBomb", effectdata, true, true )
				ent:EmitSound( "physics/metal/metal_box_break1.wav" )
				ent:EmitSound( "ambient/explosions/explode_1.wav", 400 )
				if ent:GetClass() ~= "prop_door_rotating" then
					ent:DoorLock( false )
					ent:Fire( "open", "", 0 )
					ent:Fire( "setanimation", "open", 0 )
					ent.toDetonate = false
				else
					local door = ents.Create( "prop_physics" )
					door:SetCollisionGroup( COLLISION_GROUP_NONE )
					door:SetMoveType( MOVETYPE_VPHYSICS )
					door:SetSolid( SOLID_BBOX )
					door:SetPos( ent:GetPos() + Vector( 0, 0, 1 ) )
					door:SetAngles( ent:GetAngles() )
					door:SetModel( ent:GetModel() )
					door:SetSkin( ent:GetSkin() )
					ent:Extinguish()
					ent:SetNoDraw( true )
					ent:SetNotSolid( true )
					ent:Fire( "unlock", 0 )
					ent:Fire( "open", 0 )
					door:Spawn()
					door:GetPhysicsObject():AddVelocity( direction * 700 )
					ent.phys_door = door
				end

				timer.Simple( bshields.config.doorrespawn, function()
					if not IsValid( ent ) then return end
					ent:SetNoDraw( false )
					ent:SetNotSolid( false )
					ent.toDetonate = false
					if IsValid( ent.phys_door ) then ent.phys_door:Remove() end
				end )
			end )
		end
	end

	owner.allowhshield = false
	timer.Create( "bshields_hcd_" .. owner:EntIndex(), bshields.config.hshieldcd, 1, function() if IsValid( owner ) then owner.allowhshield = true end end )
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if not self.CanVisToggle then return end
		surface.PlaySound( "weapons/smg1/switch_single.wav" )
		if not self.VisToggle then
			Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 0, 0, 0, 125 ) )
			self.VisToggle = true
		else
			Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 255, 255, 255 ) )
			self.VisToggle = false
		end

		self.CanVisToggle = false
		timer.Simple( 0.1, function() self.CanVisToggle = true end )
	end
end

if CLIENT then return end
function SWEP:Holster()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnRemove()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnDrop()
	bshield_remove( self:GetOwner() )
	return true
end
--PATH addons/__main/lua/weapons/m9k_auga3/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_auga3") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Steyr AUG A3"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 26			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_auga3sa.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_auga3.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("aug_a3.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 700		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= .4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= true
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	--base damage per bullet
SWEP.Primary.Spread		= .025	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_g36/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_g36") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "G36"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 31			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_g362.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_g36c.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("G36.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 28	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.865, -0.857, 1.06)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.865, -0.857, 1.06)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-6, -2.571, -0.04)
SWEP.RunSightsAng = Vector(-11, -43, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_hk45/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_hk45") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK45C"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 23			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pist_hk45.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk45c.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_hk45.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.32, 0, 0.86)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-2.32, 0, 0.86)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)
-- SWEP.RunSightsPos = Vector(0, -3.143, 0.857)
-- SWEP.RunSightsAng = Vector(-11, 9, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m14sp/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m14sp") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M14"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 34			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_snip_m14sp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_snip_m14sp.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_M14SP.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 45		-- How much you 'zoom' in. Less is more! 	

SWEP.SelectiveFire		= true

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 32	-- Base damage per bullet
SWEP.Primary.Spread		= .01	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (-2.7031, -1.0539, 1.6562)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (-2.7031, -1.0539, 1.6562)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (0.9642, -0.6371, 0.4936)
SWEP.RunSightsAng = Vector (-11.0116, 47.5223, -15.3199)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m24/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m24") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M24"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 43			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_dmg_m24s.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_snip_m24_6.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Dmgfok_M24SN.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 40		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 5		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= .6				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .6			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 97	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .000115 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.894, 0, 1.7624)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.894, 0, 1.7624)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m249lmg/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m249lmg") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M249 LMG"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 35			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_machinegun249.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_m249_machine_gun.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_249M.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 855			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 150		-- Size of a clip
SWEP.Primary.DefaultClip		= 300		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 27	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .024 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-4.015, 0, 1.764)
SWEP.IronSightsAng = Vector(0, -0.014, 0)
SWEP.SightsPos = Vector(-4.015, 0, 1.764)
SWEP.SightsAng = Vector(0, -0.014, 0)
SWEP.RunSightsPos = Vector(5.081, -4.755, -1.476)
SWEP.RunSightsAng = Vector(0, 41.884, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_minigun/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_minigun") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M134 Minigun"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 37			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "crossbow"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_minigunvulcan.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_m134_minigun.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("BlackVulcan.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 3500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 100		-- Size of a clip
SWEP.Primary.DefaultClip		= 200		-- Bullets you start with
SWEP.Primary.KickUp				= 0.5		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 0		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .035 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.RunSightsPos = Vector(0, -11.148, -8.033)
SWEP.RunSightsAng = Vector(55.082, 0, 0)

if ((gmod.GetGamemode().Name) == "Murderthon 9000") or ((gmod.GetGamemode().Name) == "Murderthon 9000 beta") then
	SWEP.Primary.ClipSize			= 100		-- Size of a clip
	SWEP.Primary.DefaultClip		= 200		-- Bullets you start with
else
	SWEP.Primary.ClipSize			= 300		-- Size of a clip
	SWEP.Primary.DefaultClip		= 600		-- Bullets you start with
end

function SWEP:Reload()

	self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	if !self.Owner:IsNPC() then
		self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration() end
	if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
	-- When the current clip < full clip and the rest of your ammo > 0, then
		self.Owner:SetFOV( 0, 0.3 )
		-- Zoom = 0
		self:SetIronsights(false)
		-- Set the ironsight to false
		self.Weapon:SetNWBool("Reloading", true)
	end
	local waitdammit = (self.Owner:GetViewModel():SequenceDuration())
	self:MiniGunIdle(waitdammit)
end

function SWEP:MiniGunIdle(wait)
	timer.Simple(wait + .05, function()
	if self.Weapon != nil then
	self.Weapon:SetNWBool("Reloading", false)
	if SERVER then 
		self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
	else return end end
	end)
end

function SWEP:IronSight()

	if self.Owner:KeyDown(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then					// If you run then
	self.Weapon:SetNextPrimaryFire(CurTime()+0.5)				// Make it so you can't shoot for another quarter second
	self.IronSightsPos = self.RunSightsPos					// Hold it down
	self.IronSightsAng = self.RunSightsAng					// Hold it down
	self:SetIronsights(true, self.Owner)					// Set the ironsight true
	self.Owner:SetFOV( 0, 0.3 )						// Reset FOV
	end								

	if self.Owner:KeyReleased(IN_SPEED) then				// If you stop running then
	self:SetIronsights(false, self.Owner)					// Set the ironsight true
	self.Owner:SetFOV( 0, 0.3 )						// Reset FOV
	end

end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_model500/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_model500") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "S&W Model 500"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 28			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_swmodel_500.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_sw_model_500.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Model_500.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 100			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 5		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 40	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-1.923, -1.675, 0.374)
SWEP.IronSightsAng = Vector(0.052, 0, 0)
SWEP.SightsPos = Vector(-1.923, -1.675, 0.374)
SWEP.SightsAng = Vector(0.052, 0, 0)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_model627/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_model627") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "S&W Model 627"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 29			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_swmodel_627.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_sw_model_627.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("model_627perf.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 120			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .01	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.68, 0.019, 1.521)
SWEP.IronSightsAng = Vector(-0.141, -0.139, 0)
SWEP.SightsPos = Vector(2.68, 0.019, 1.521)
SWEP.SightsAng = Vector(-0.141, -0.139, 0)
SWEP.RunSightsPos = Vector(-2.419, -4.467, -4.693)
SWEP.RunSightsAng = Vector(56.766, 0, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_remington7615p/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_remington7615p") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Remington 7615P"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 46			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= false		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_remington_7615p.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_remington_7615p.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("7615p_remington.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 50		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 7	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 35	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(3.079, -1.333, 0.437)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(3.079, -1.333, 0.437)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_usc/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_usc") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK USC"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 56			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_hkoch_usc.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_usc.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_hkusc.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 25		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.45		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 23	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.698, -2.566, 2.038)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(4.698, -2.566, 2.038)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.814, -8.615, 0)
SWEP.RunSightsAng = Vector(-9.016, -64.764, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_usp/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_usp") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK USP"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 34			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pist_fokkususp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_pist_fokkususp.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_fokkususp.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 15		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 16	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (-2.5944, 0, 1.1433)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (-2.5944, 0, 1.1433)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)
-- SWEP.RunSightsPos = Vector (-1.0917, 0, 1.496)
-- SWEP.RunSightsAng = Vector (-9.6507, -2.5621, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/_hats_hook/lua/weapons/realistic_hook.lua:
// A more realistic grappling hook
SWEP.Base = "weapon_base"

SWEP.PrintName = "Grappling Hook"
SWEP.Category = "Other"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Fire to launch the hook"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModelFOV = 80
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.ViewModelFlip   = false

SWEP.WorldModel = "models/weapons/w_alyx_gun.mdl"
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.CanDrop = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.05

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "hatshook_ammo"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = 8
SWEP.Secondary.DefaultClip = 32
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = 32
SWEP.Secondary.Delay = 0.5

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "pistol"

---- For TTT
SWEP.Kind = WEAPON_EQUIP
SWEP.AutoSpawnable      = false
SWEP.AmmoEnt = "none"
SWEP.NoSights = true
SWEP.EquipMenuData = {
	type = "item_weapon",
	desc = "A grappling hook.\n\nScale walls or grab things from afar."
};

SWEP.Icon = "entities/realistic_hook"
----

--Standard swep functions--
---------------------------
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Hook" )
	
	self:NetworkVar( "Int", 0, "Cooldown" )
end

function SWEP:Initialize()
	hook.Add( "SetupMove", self, self.PlayerMove )
	--hook.Add( "Tick", self, self.Tick )
	
	if CLIENT then
		self.VElements = table.FullCopy( self.VElements )
		self:CreateModels(self.VElements) // create viewmodels
		
		hook.Add( "PostDrawOpaqueRenderables", self, self.VMDraw )
	end
	
	if SERVER then
		local timerName = tostring(self).." Hook Broken Cooldown"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetCooldown( math.Approach(self:GetCooldown(), 0, 2) )
		end)
	end
	
	self.Primary.DefaultClip = cvars.Number("hatshook_ammo") or (-1)
	self.Primary.ClipSize = cvars.Number("hatshook_ammo") or (-1)
	self:SetClip1( cvars.Number("hatshook_ammo") or (-1) )
	
	return self.BaseClass.Initialize( self )
end
function SWEP:PrimaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT and (not IsFirstTimePredicted()) then return end
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( math.Approach( hk:GetDist(), 0, 10 ) ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:SecondaryAttack()
	if self:GetCooldown()>0 then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if IsValid( self:GetHook() ) then
		local hk = self:GetHook()
		if not (hk.GetHasHit and hk:GetHasHit()) then return end
		
		if SERVER then hk:SetDist( hk:GetDist() + 10 ) end
		self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	elseif SERVER then
		self:LaunchHook()
	end
end
function SWEP:Reload()
	if SERVER and IsValid(self:GetHook()) then
		if self:GetHook():GetDurability()>0 then
			self:SetCooldown( self:GetHook():GetDurability()+20 )
		else
			self:SetCooldown(10)
		end
		self:GetHook():Remove()
		
		if self:Clip1()==0 then
			self:Remove()
			return
		end
	end
end

-- Handling the hook entity --
------------------------------
function SWEP:LaunchHook()
	if not IsValid( self.Owner ) then return end
	
	if self:Clip1()>0 then
		self:SetClip1(math.max(self:Clip1()-1, 0))
	elseif self:Clip1()==0 then
		return
	end
	
	if not cvars.Bool( "hatshook_physics" ) then return self:LaunchInstant() end
	
	//self:EmitSound( "physics/metal/metal_box_impact_bullet"..math.random(1,3)..".wav" )
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", self.Owner:GetShootPos(), 75, 100, 0.5 )
	self.Owner:ViewPunch( Angle( math.Rand(-5,-2.5), math.Rand(-2,2), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( self.Owner:GetShootPos() - self.Owner:GetAimVector()*10 )
	local ang = self.Owner:EyeAngles()
	ang:RotateAroundAxis( ang:Up(), 90 )
	hk:SetAngles( ang )
	hk.FireVelocity = self.Owner:GetAimVector() * 500
	hk:SetOwner( self.Owner )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
end
function SWEP:Holster()
	if self:Clip1()==0 then self:Remove() end
	
	return true
end

function SWEP:GetFilter()
	return cvars.Bool( "hatshook_hookplayers" ) and {self.Owner} or player.GetAll()
end
function SWEP:LaunchInstant()
	local tr = util.TraceLine({
		start=self.Owner:GetShootPos(),
		endpos=self.Owner:GetShootPos()+(self.Owner:GetAimVector() * cvars.Number("hatshook_speed")),
		filter=self:GetFilter()
	})
	if tr.HitSky or not tr.Hit then return end
	
	sound.Play( "physics/metal/metal_canister_impact_soft"..math.random(1,3)..".wav", self.Owner:GetShootPos(), 75, 100, 0.5 )
	self.Owner:ViewPunch( Angle( math.Rand(-10,-5), math.Rand(-4,4), 0 ) )
	
	local hk = ents.Create( "ent_realistic_hook" )
	if not IsValid(hk) then return end // Shouldn't happen
	hk:SetPos( tr.HitPos )
	hk:SetAngles( tr.Normal:Angle() )
	hk.FireVelocity = Vector(0,0,0)
	hk:SetOwner( self.Owner )
	hk:Spawn()
	
	self:SetHook( hk )
	hk:SetWep( self )
	
	hk:PhysicsCollide( {HitEntity=tr.Entity, HitPos=tr.HitPos, HitNormal=tr.Normal} )
end

local HookCable = Material( "cable/cable2" )
function SWEP:DrawRope( attPos )
	if not attPos then return end
	
	
	local hk = self:GetHook()
	if not IsValid(hk) then return end
	
	if self.Owner~=LocalPlayer() or hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return hk:Draw() end
	
	if IsValid( hk:GetTargetEnt() ) then
		local bpos, bang = hk:GetTargetEnt():GetBonePosition( hk:GetFollowBone() )
		local npos, nang = hk:GetFollowOffset(), hk:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			hk:SetPos( npos )
			hk:SetAngles( nang )
		end
	end
	
	render.SetMaterial( HookCable )
	render.DrawBeam( hk:GetPos(), attPos, 1, 0, 2, Color(255,255,255,255) )
end
function SWEP:DrawWorldModel()
	self:DrawModel()
	local att = self:GetAttachment( 1 )
	self:DrawRope( att.Pos )
end
function SWEP:VMDraw()
	if not (self.Owner==LocalPlayer() and self.Owner:GetActiveWeapon()==self and hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner)~=false) then return end
	
	local vm = IsValid( self.Owner ) and self.Owner:GetViewModel()
	local pos = self:GetPos()
	if IsValid(vm) and vm:GetAttachment( 1 ) then pos = vm:GetAttachment( 1 ).Pos end
	
	self:DrawRope( pos )
end

-- HUD Stuff --
---------------
if CLIENT then
	surface.CreateFont( "hatshook_small", {size=15} )
	surface.CreateFont( "hatshook_large", {size=25, weight=1000} )
end
local function ShadowText( txt, font, x, y )
	draw.DrawText( txt, font, x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, font, x, y, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
function SWEP:DrawHUD()
	if IsValid( self:GetHook() ) and self:GetHook():GetHasHit() then
		ShadowText( "Rope length: "..tostring(self:GetHook():GetDist()), "hatshook_small", ScrW()*0.5, ScrH()*0.5+40 )
		ShadowText( (input.LookupBinding("+attack") or "[PRIMARY FIRE]"):upper() .. " - Retract rope", "hatshook_small", ScrW()*0.5, ScrH()*0.5+70 )
		ShadowText( (input.LookupBinding("+attack2") or "[SECONDARY FIRE]"):upper() .. " - Extend rope", "hatshook_small", ScrW()*0.5, ScrH()*0.5+85 )
		ShadowText( (input.LookupBinding("+reload") or "[RELOAD]"):upper() .. " - Break rope", "hatshook_small", ScrW()*0.5, ScrH()*0.5+100 )
		
		if IsValid( self:GetHook():GetTargetEnt() ) and self:GetHook():GetTargetEnt():IsPlayer() then
			DrawChargeBar( (ScrW()*0.5)-70, (ScrH()*0.5)+20, 140, 15, self:GetHook():GetDurability() )
		else
			ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Jump off", "hatshook_small", ScrW()*0.5, ScrH()*0.5+115 )
		end
	elseif self:GetCooldown()>0 then
		DrawChargeBar( (ScrW()*0.5)-70, (ScrH()*0.5)+20, 140, 15, self:GetCooldown() )
	end
	
	if self:Clip1()>=0 then
		ShadowText( "Hooks Remaining: " .. tostring(self:Clip1()), "hatshook_large", ScrW()*0.5, ScrH()-50 )
	end
	
	return self.BaseClass.DrawHUD( self ) // TTT Crosshair is drawn here, we have to call it
end

-- Movement Handling --
-----------------------
local function ValidPullEnt(ent)
	if (not IsValid(ent)) or ent:IsPlayer() then return false end
	local phys = ent:GetPhysicsObject()
	
	return (not IsValid(phys)) or ((not phys:HasGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)) and (phys:GetMass()<=50) and (ent.CanPickup!=false) and phys:IsMotionEnabled())
end

function SWEP:PlayerMove( ply, mv, cmd )
	if not (IsValid(self:GetHook()) and self:GetHook().GetHasHit and self:GetHook():GetHasHit()) then return end
	if not (IsValid(self.Owner) and IsValid(ply) and self.Owner:Alive() and ply:Alive()) then return end
	
	local hk = self:GetHook()
	
	if (IsValid(hk:GetTargetEnt()) and hk:GetTargetEnt()~=self and ply~=hk:GetTargetEnt() and (hk:GetTargetEnt():IsPlayer() or ValidPullEnt(hk:GetTargetEnt()))) then return end
	if (hk:GetTargetEnt()==hk or (not (ValidPullEnt(hk:GetTargetEnt()) or hk:GetTargetEnt():IsPlayer()))) and ply~=self.Owner then return end
	
	if not (ply.InVehicle and self.Owner.InVehicle) then hk:Remove() self:SetCooldown(10) return end // What
	if ply:InVehicle() or self.Owner:InVehicle() or (not ply:Alive()) then hk:Remove() self:SetCooldown(10) return end
	
	if ply~=self.Owner then
		ply.was_pushed = {t=CurTime(),att=self.Owner}
	end
	
	if ply:KeyPressed( IN_USE ) and ply==self.Owner then
		if hk:GetPos()[3] > ply:GetShootPos()[3] then
			mv:SetVelocity( mv:GetVelocity() + Vector(0,0,300) )
		end
		
		if SERVER then self:SetCooldown(10) hk:Remove() end
	end
	
	local TargetPoint = hk:GetPos()
	local ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
	local ShootPos = self.Owner:GetShootPos() + (Vector(0,0, (self.Owner:Crouching() and 0) or (hk:GetUp()[1]>0.9 and -45) or 0))
	local Distance = hk:GetDist()
	
	if ply~=self.Owner then // Swap direction
		TargetPoint = ShootPos
		ShootPos = ply:GetShootPos() + (Vector(0,0, (ply:Crouching() and 0) or (hk:GetUp()[1]>0.9 and -45) or 0))
		ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
	end
	
	local DistFromTarget = ShootPos:Distance( TargetPoint )
	if DistFromTarget<(Distance+5) then return end // 5 units off actual distance
	local TargetPos = TargetPoint - (ApproachDir*Distance)
	
	local xDif = math.abs(ShootPos[1] - TargetPos[1])
	local yDif = math.abs(ShootPos[2] - TargetPos[2])
	local zDif = math.abs(ShootPos[3] - TargetPos[3])
	
	--local speedMult = ((DistFromTarget*0.01)^1.1)
	local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
	local vertMult = math.max((math.Max(300-(xDif + yDif), -10)*0.08)^1.01  + (zDif*0.5),0)
	if ply~=self.Owner and self.Owner:GetGroundEntity()==ply then vertMult = -vertMult end
	
	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1] = TargetVel[1]*speedMult
	TargetVel[2] = TargetVel[2]*speedMult
	TargetVel[3] = TargetVel[3]*vertMult
	local dir = mv:GetVelocity()
	
	local clamp = 50
	local vclamp = 20
	local accel = 200
	local vaccel = 30*(vertMult/50)
	
	dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
	dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
	
	if ShootPos[3]<TargetPos[3] then
		dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		
		if vertMult>0 then self.ForceJump=ply end
	end
	
	mv:SetVelocity( dir )
	//return mv
end

local function ForceJump( ply )
	if not (IsValid(ply) and ply:IsPlayer()) then return end
	if not ply:OnGround() then return end
	
	local tr = util.TraceLine( {start = ply:GetPos(), endpos = ply:GetPos()+Vector(0,0,20), filter = ply} )
	if tr.Hit then return end
	
	ply:SetPos(ply:GetPos()+Vector(0,0,5) )
end
function SWEP:Think()
	if self.ForceJump then
		if IsValid(self.Owner) and self.ForceJump==self.Owner then
			ForceJump( self.Owner )
		elseif IsValid( self:GetHook() ) and IsValid( self:GetHook():GetTargetEnt() ) and self.ForceJump == self:GetHook():GetTargetEnt() then
			ForceJump( self.ForceJump )
		end
		self.ForceJump = nil
	end
	if SERVER then
		self:EntityPull()
		
		if self:Clip1()==0 and not IsValid(self:GetHook()) then
			self:Remove()
		end
	end
end

function SWEP:EntityPull() // For pulling entities
	local hk = self:GetHook()
	if IsValid(self.Owner) and IsValid(hk) and hk.GetTargetEnt and IsValid(hk:GetTargetEnt()) and ValidPullEnt(hk:GetTargetEnt()) then
		local ply = hk:GetTargetEnt()
		local phys = ply:GetPhysicsObject()
		if ply:IsPlayer() or (not IsValid(phys)) then return end
		
		local TargetPoint = self.Owner:GetShootPos()
		local ShootPos = ply:GetPos()
		local ApproachDir = (TargetPoint-ply:GetPos()):GetNormal()
		local Distance = hk:GetDist()
		
		local DistFromTarget = ShootPos:Distance( TargetPoint )
		if DistFromTarget<(Distance+5) then return end
		local TargetPos = TargetPoint - (ApproachDir*Distance)
		
		local xDif = math.abs(ShootPos[1] - TargetPos[1])
		local yDif = math.abs(ShootPos[2] - TargetPos[2])
		local zDif = math.abs(ShootPos[3] - TargetPos[3])
		
		--local speedMult = ((DistFromTarget*0.01)^1.1)
		local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
		local vertMult = math.max((math.Max(100-(xDif + yDif), -10)*0.1)^1.01  + (zDif*0.5), 0)
		if self.Owner:GetGroundEntity()==ply then vertMult = -vertMult end
		
		local TargetVel = (TargetPos - ShootPos):GetNormal() * 6 * (1 - (phys:GetMass()/50))
		TargetVel[1] = TargetVel[1]*speedMult
		TargetVel[2] = TargetVel[2]*speedMult
		TargetVel[3] = TargetVel[3]*vertMult
		local dir = ply:GetVelocity()
		
		local clamp = 50
		local vclamp = 20
		local accel = 200
		local vaccel = 40*(vertMult/50)
		
		dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
		dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
		
		if ShootPos[3]<TargetPos[3] and vertMult~=0 then
			dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		end
		
		phys:SetVelocity( dir )
	end
end


SWEP.VElements = {
	["gun"] = { type = "Model", model = "models/weapons/w_alyx_gun.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(1.1, -1.1, -1.4), angle = Angle(-100, 146, 68), size = Vector(1,1,1), color = Color(255, 255, 255, 255) }
}
-- SWEP Construction Kit code by Clavus, removed everything I don't need. http://facepunch.com/threads/1032378 --
-----------------------------------------------------------------------------------------------------------------
function SWEP:ViewModelDrawn()
	if not IsValid( self.Owner ) then return end
	local vm = self.Owner:GetViewModel()
	if !IsValid(vm) then return end
	
	if (!self.VElements) then return end
	for k, v in pairs( self.VElements ) do
		if not file.Exists( v.model, "GAME" ) then continue end
		local model = v.modelEnt
		
		if (!v.bone) then continue end
		
		local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
		if (!pos) then continue end
		
		if IsValid(model) then
			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
			model:SetAngles(ang)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix( "RenderMultiply", matrix )
			
			model:SetMaterial("")
			
			render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
			render.SetBlend(v.color.a/255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)
		end
	end
end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
	local bone, pos, ang
	bone = ent:LookupBone(bone_override or tab.bone)
	
	if (!bone) then return end
	
	pos, ang = Vector(0,0,0), Angle(0,0,0)
	local m = ent:GetBoneMatrix(bone)
	if (m) then pos, ang = m:GetTranslation(), m:GetAngles() end
	
	if (IsValid(self.Owner) and self.Owner:IsPlayer() and ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
		ang.r = -ang.r // Fixes mirrored models
	end
	
	return pos, ang
end

function SWEP:CreateModels( tab )
	if (!tab) then return end
	for k, v in pairs( tab ) do
		if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and  string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
			v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
			if (IsValid(v.modelEnt)) then
				v.modelEnt:SetPos(self:GetPos())
				v.modelEnt:SetAngles(self:GetAngles())
				v.modelEnt:SetParent(self)
				v.modelEnt:SetNoDraw(true)
				v.createdModel = v.model
			else
				v.modelEnt = nil
			end
		end
	end
end

function table.FullCopy( tab )
	if (!tab) then return nil end
	local res = {}
	for k, v in pairs( tab ) do
		if (type(v) == "table") then res[k] = table.FullCopy(v)
		elseif (type(v) == "Vector") then res[k] = Vector(v.x, v.y, v.z)
		elseif (type(v) == "Angle") then res[k] = Angle(v.p, v.y, v.r)
		else res[k] = v end
	end
	return res
end
--PATH addons/__main/lua/weapons/savav_alc_checker.lua:
if( SERVER ) then
	SWEP.PrintName = "Drugs Checker"
end

if( CLIENT ) then
	SWEP.PrintName = "Drugs Checker"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.HoldType = "knife"


SWEP.UseHands = true




SWEP.Category = "Other"
SWEP.Author			= "SaVav"
SWEP.Instructions	= ""
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Primary.Damage		= 0
SWEP.Primary.Ammo		= "none"
SWEP.Primary.Automatic		= true

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip	= false

SWEP.Spawnable			= true 
SWEP.AdminSpawnable		= false
  
SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.Secondary.ClipSize		= -1					
SWEP.Secondary.DefaultClip	= -1					
SWEP.Secondary.Automatic	= false				
SWEP.Secondary.Ammo		= "none"
SWEP.COUTDONW = 0


function SWEP:Precache()

end

function SWEP:Initialize()
    self:SetWeaponHoldType("knife")
end

function SWEP:Deploy()

	return true
end

function SWEP:Think()
local ply = self.Owner

if ply:GetEyeTrace().Entity:GetClass() != "prop_physics" then
self.COUTDONW = 0
end

end

function SWEP:PrimaryAttack()
local ply = self.Owner

if ply:GetEyeTrace().Entity:GetClass() == "prop_physics" then
if self.COUTDONW < 300 then
self.COUTDONW = self.COUTDONW + 1
ply:PrintMessage( HUD_PRINTCENTER, self.COUTDONW )
end
else
self.COUTDONW = 0
end

if self.COUTDONW == 300 then
if ply:GetEyeTrace().Entity:GetNWFloat( "drug" ) != "0" or ply:GetEyeTrace().Entity:GetNWFloat( "drug" ) == nil then
ply:PrintMessage( HUD_PRINTCENTER, "DRUGS NOT FINDED" )
else
ply:PrintMessage( HUD_PRINTCENTER, "DRUGS FINDED!" )
end	
end

end




function SWEP:Holster()
	if self:GetNextPrimaryFire() > CurTime() then return end
	return true
end




--PATH addons/uweedadvancedcannabisgrowth/lua/weapons/uweed_joint.lua:
SWEP.PrintName = "Blunt"
SWEP.Author = "Owain Owjo & Misfit"
SWEP.Category = "uWeed SWEPs"

SWEP.Slot = 0
SWEP.SlotPos = 4

SWEP.Spawnable = true
SWEP.ViewModel = Model("models/base/bluntview.mdl")
SWEP.WorldModel = "models/base/bluntroll4.mdl"
SWEP.ViewModelFOV = 85
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Secondary.Ammo = "none"

SWEP.HoldType = ""

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
	self.nextFlick = CurTime() + 30
	self.forceFlickCooldown = CurTime()
	self.smokeCooldown = CurTime()
end

function SWEP:PrimaryAttack()
	local ply = self.Owner
	if (ply:GetNWInt("uWeed_Gram_Counter") or 0) < 1 then return end
	self:SetNextPrimaryFire(CurTime()+8)
	self:SetNextSecondaryFire(CurTime()+8)
	if self.nextFlick < CurTime() + 8 then self.nextFlick = CurTime() + 30 end

	ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("smoking_in"))
	timer.Simple(3, function()
		if !IsValid(self) then return end
		if self.Owner:GetActiveWeapon() != self then return end
		self.smokeCooldown = CurTime() + 3
	end)
	timer.Simple(5, function()
		if !IsValid(self) then return end
		if self.Owner:GetActiveWeapon() != self then return end

		if SERVER then
			local counter = ply:GetNWInt("uWeed_Gram_Counter") or 0 
			ply:SetNWInt("uWeed_Gram_Counter", counter - 1)
		end
		if CLIENT then
			timer.Simple(1, function()
				if !IsValid(self) then return end
				for i=1, math.random(10,14) do
					timer.Simple(i/10, function()
						if !IsValid(self) then return end
						self:BlowSmoke()
					end)
				end
			end)
			timer.Simple(1.9, function()
				if !IsValid(self) then return end
				for i=1, 5 do
					self:Ash()
				end
			end)

			hook.Add("RenderScreenspaceEffects", "uWeed_high", function()
				DrawBloom( 0.7, 4, 30, 30, 1, 1, 1, 1, 1 )
			end)
	
			if timer.Exists("uWeed_high") then
				timer.Remove("uWeed_high")
			end
		
			timer.Create("uWeed_high", UWeed.Config.HighTime, 1, function()
				hook.Remove("RenderScreenspaceEffects", "uWeed_high")
			end)
		end
		if (ply:GetNWInt("uWeed_Gram_Counter") or 0) <=0 then
			ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("toss"))
			timer.Simple(3, function()
				if !IsValid(self) then return end
				self.Owner:StripWeapon(self:GetClass())
			end)
		else
			ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("smoking_back"))
			timer.Simple(3, function()
				if !IsValid(self) then return end
				if self.Owner:GetActiveWeapon() != self then return end
				ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("idle"))
			end)
		end
	end)
end

function SWEP:Think()
	if self.nextFlick < CurTime() then
		self.nextFlick = CurTime() + 30
		self:FlickAsh()
	end
end

function SWEP:FlickAsh()
	self:SetNextPrimaryFire(CurTime()+5)
	self:SetNextSecondaryFire(CurTime()+5)
	self.Owner:GetViewModel():SendViewModelMatchingSequence(self.Owner:GetViewModel():LookupSequence("smoking_ash"))
	if CLIENT then
		timer.Simple(0.5, function()
			if !IsValid(self) then return end
			for i=1, 5 do
				self:Ash()
			end
		end)
	end
	timer.Simple(4, function()
		if !IsValid(self) then return end
		self.Owner:GetViewModel():SendViewModelMatchingSequence(self.Owner:GetViewModel():LookupSequence("idle"))
	end)
end

function SWEP:SecondaryAttack()
	if self.forceFlickCooldown > CurTime() then return end

	self.forceFlickCooldown = CurTime() + 5
	self.nextFlick = CurTime() + 30

	self:FlickAsh()
end

function SWEP:Reload()
end

if CLIENT then

	local emitter = ParticleEmitter(Vector(0,0,0))
	local function newSmoke(position, angle)
		local pos = position
		local ang = angle
		emitter:SetPos(pos)

		local particle = emitter:Add(string.format("particle/smokesprites_00%02d",math.random(1,16)), pos-(ang:Forward()*0.4)+(ang:Right()*-0.2))
		if particle then
			particle:SetColor(200,200,200,200)
			particle:SetVelocity(ang:Forward()*1.5)
			particle:SetGravity( Vector(0,0,15) )
			particle:SetLifeTime(0)
			particle:SetDieTime(1.5)
			particle:SetStartSize(0.75)
			particle:SetEndSize(1)
			particle:SetStartAlpha(200)
			particle:SetEndAlpha(0)
			particle:SetCollide(true)
			particle:SetBounce(2)
			particle:SetRoll(math.Rand(0,360))
			particle:SetRollDelta(0.01*math.Rand(-40,40))
			particle:SetAirResistance(50)
		end
	end

	function SWEP:BlowSmoke()
		local ang = self.Owner:GetAngles()
		local pos = self.Owner:GetPos() + Vector(0, 0, 63) + (ang:Forward()*3)

		emitter:SetPos(pos)

		local particle = emitter:Add(string.format("particle/smokesprites_00%02d",math.random(1,16)), pos)
		if particle then
			particle:SetColor(255,255,255,255)
			particle:SetVelocity( ang:Forward()*15 )
			particle:SetGravity( ang:Up()*0.5 )
			particle:SetLifeTime(0)
			particle:SetDieTime(5)
			particle:SetStartSize(1)
			particle:SetEndSize(2)
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetCollide(true)
			particle:SetBounce(2)
			particle:SetRollDelta(0.01*math.Rand(-40,40))
			particle:SetAirResistance(50)
		end
	end

	local ashMaterial = Material("uweed/ash.png")
	function SWEP:Ash()
		mdl = self.Owner:GetViewModel()
		local pos = mdl:GetAttachment(1).Pos
		local ang = mdl:GetAttachment(1).Ang
		emitter:SetPos(pos)

		local particle = emitter:Add( ashMaterial, pos-(ang:Forward()*0.4)+(ang:Right()*-0.2) )
		if particle then
			particle:SetColor(255,255,255,255)
			particle:SetVelocity(ang:Forward()*(math.random(-1, 1)))
			particle:SetGravity( Vector(0,0,math.random(-10, -20)) )
			particle:SetLifeTime(0)
			particle:SetDieTime(1.5)
			particle:SetStartSize(1)
			particle:SetEndSize(1)
			particle:SetStartAlpha(200)
			particle:SetEndAlpha(0)
			particle:SetCollide(true)
			particle:SetBounce(2)
			particle:SetRollDelta(0.01*math.Rand(-40,40))
			particle:SetAirResistance(50)
		end
	end

	function SWEP:PostDrawViewModel(mdl)
		if self.smokeCooldown+math.random(0.05, 0.07) > CurTime() then return end
		self.smokeCooldown = CurTime()
		local pos = mdl:GetAttachment(1).Pos
		local ang = mdl:GetAttachment(1).Ang
		newSmoke(pos, ang)
	end

	function SWEP:DrawHUD()
		local weedCount = LocalPlayer():GetNWInt("uWeed_Gram_Counter") or 0
		draw.SimpleText(UWeed.Translation.Blunt.Text.." "..weedCount, "uweed_Gram_Font", ScrW()*0.5, ScrH(), Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	end

	hook.Add("PostPlayerDraw", "uWeed_3rdPerson_Joint", function(ply)
		-- Some basic checks
		if ply == LocalPlayer() then return end
		if !IsValid(ply) then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end
		if !ply:Alive()  then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end
		if !ply:GetActiveWeapon() then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end
		if ply:GetActiveWeapon() == NULL then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end
		if ply:GetActiveWeapon():GetClass() != "uweed_joint" then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end
		if LocalPlayer():GetPos():Distance( ply:GetPos() ) > 750 then if ply.uWeed_Joint then ply.uWeed_Joint:Remove() ply.uWeed_Joint = nil end return end

		if !ply.uWeed_Joint then
			ply.uWeed_Joint = ClientsideModel("models/base/bluntmodel.mdl")
			if not IsValid(ply.uWeed_Joint) then return end
			ply.uWeed_Joint:SetBodygroup(4, 1)
			ply.uWeed_Joint:SetBodygroup(3, 1)
			ply.uWeed_Joint:SetBodygroup(2, 1)
		end

    	local ang = ply:GetAngles()
    	local pos

    	if ply:LookupBone("ValveBiped.Bip01_Head1") then
    		b_pos, b_ang = ply:GetBonePosition(ply:LookupBone("ValveBiped.Bip01_Head1"))
    		pos = b_pos + (b_ang:Right()*4) + (b_ang:Forward()) + (b_ang:Up()*-0.3)
    		ang = b_ang
    		ang:RotateAroundAxis( ang:Up(), 90 )
    	else 
    		pos = ply:GetPos() + Vector(0,0,70)
    	end
    	ply.uWeed_Joint:SetPos(pos)
    	ply.uWeed_Joint:SetAngles(ang)

    	ply.uWeed_Smoke_Cooldown = ply.uWeed_Smoke_Cooldown or CurTime()

    	if ply.uWeed_Smoke_Cooldown+math.random(0.05, 0.07) > CurTime() then return end
		ply.uWeed_Smoke_Cooldown = CurTime()
		newSmoke(pos+(b_ang:Forward()*-5), ang)
	end)

end
--PATH addons/__main/lua/weapons/weapon_braaains.lua:

AddCSLuaFile()

SWEP.PrintName = "Zombie SWEP"
SWEP.Author = "Kilburn, robotboy655, MaxOfS2D & Tenrys"
SWEP.Purpose = "BRAAAAINS!!1!"

SWEP.Slot = 0
SWEP.SlotPos = 4

SWEP.Spawnable = true

SWEP.ViewModel = Model( "models/weapons/c_zombieswep.mdl" )
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 90
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false

SWEP.HitDistance = 48

local SwingSound = Sound( "WeaponFrag.Throw" )
local HitSound = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "normal" )
	
	self.ActivityTranslate[ ACT_MP_STAND_IDLE ]					= ACT_HL2MP_IDLE_ZOMBIE
	self.ActivityTranslate[ ACT_MP_WALK ]						= ACT_HL2MP_WALK_ZOMBIE_01
	self.ActivityTranslate[ ACT_MP_RUN ]						= ACT_HL2MP_RUN_ZOMBIE
	self.ActivityTranslate[ ACT_MP_CROUCH_IDLE ]				= ACT_HL2MP_IDLE_CROUCH_ZOMBIE
	self.ActivityTranslate[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_ZOMBIE_01
	self.ActivityTranslate[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= ACT_GMOD_GESTURE_RANGE_ZOMBIE
	self.ActivityTranslate[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_GMOD_GESTURE_RANGE_ZOMBIE
	self.ActivityTranslate[ ACT_MP_JUMP ]						= ACT_ZOMBIE_LEAPING
	self.ActivityTranslate[ ACT_RANGE_ATTACK1 ]					= ACT_GMOD_GESTURE_RANGE_ZOMBIE

end

function SWEP:SetupDataTables()

	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextIdle" )
	self:NetworkVar( "Int", 2, "Combo" )

end

function SWEP:UpdateNextIdle()

	local vm = self.Owner:GetViewModel()
	self:SetNextIdle( CurTime() + vm:SequenceDuration() / vm:GetPlaybackRate() )

end

function SWEP:PrimaryAttack( right )

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local anim = "fists_left"
	if ( right ) then anim = "fists_right" end
	if ( self:GetCombo() >= 2 ) then
		anim = "fists_uppercut"
	end
	
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

	self:EmitSound( SwingSound )

	self:UpdateNextIdle()
	self:SetNextMeleeAttack( CurTime() + 0.2 )

	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )

end

function SWEP:SecondaryAttack()

	self:PrimaryAttack( true )

end

local phys_pushscale = GetConVar( "phys_pushscale" )

function SWEP:DealDamage()

	local anim = self:GetSequenceName(self.Owner:GetViewModel():GetSequence())

	self.Owner:LagCompensation( true )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.HitDistance,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( !IsValid( tr.Entity ) ) then
		tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.HitDistance,
			filter = self.Owner,
			mins = Vector( -10, -10, -8 ),
			maxs = Vector( 10, 10, 8 ),
			mask = MASK_SHOT_HULL
		} )
	end

	-- We need the second part for single player because SWEP:Think is ran shared in SP
	if ( tr.Hit && !( game.SinglePlayer() && CLIENT ) ) then
		self:EmitSound( HitSound )
	end

	local hit = false
	local scale = phys_pushscale:GetFloat()

	if ( SERVER && IsValid( tr.Entity ) && ( tr.Entity:IsNPC() || tr.Entity:IsPlayer() || tr.Entity:Health() > 0 ) ) then
		local dmginfo = DamageInfo()

		local attacker = self.Owner
		if ( !IsValid( attacker ) ) then attacker = self end
		dmginfo:SetAttacker( attacker )

		dmginfo:SetInflictor( self )
		dmginfo:SetDamage( math.random( 47, 67 ) )

		if ( anim == "fists_left" ) then
			dmginfo:SetDamageForce( self.Owner:GetRight() * 4912 * scale + self.Owner:GetForward() * 9998 * scale ) -- Yes we need those specific numbers
		elseif ( anim == "fists_right" ) then
			dmginfo:SetDamageForce( self.Owner:GetRight() * -4912 * scale + self.Owner:GetForward() * 9989 * scale )
		elseif ( anim == "fists_uppercut" ) then
			dmginfo:SetDamageForce( self.Owner:GetUp() * 5158 * scale + self.Owner:GetForward() * 10012 * scale )
			dmginfo:SetDamage( math.random( 67, 74 ) )
		else
			dmginfo:SetDamageForce( self.Owner:GetForward() * 14910 * scale ) -- Yes we need those specific numbers
		end

		SuppressHostEvents( NULL ) -- Let the breakable gibs spawn in multiplayer on client
		tr.Entity:TakeDamageInfo( dmginfo )
		SuppressHostEvents( self.Owner )

		hit = true

	end

	if ( IsValid( tr.Entity ) ) then
		local phys = tr.Entity:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:ApplyForceOffset( self.Owner:GetAimVector() * 80 * phys:GetMass() * scale, tr.HitPos )
		end
	end

	if ( SERVER ) then
		if ( hit && anim != "fists_uppercut" ) then
			self:SetCombo( self:GetCombo() + 1 )
		else
			self:SetCombo( 0 )
		end
	end

	self.Owner:LagCompensation( false )

end

function SWEP:OnDrop()

	self:Remove() -- You can't drop fists

end

function SWEP:Deploy()

	local speed = GetConVarNumber( "sv_defaultdeployspeed" )
	
	local vm = self.Owner:GetViewModel()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetPlaybackRate( speed )

	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:SetNextSecondaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:UpdateNextIdle()

	if ( SERVER ) then
		self:SetCombo( 0 )
	end

	return true

end

function SWEP:Holster()

	self:SetNextMeleeAttack( 0 )

	return true

end

function SWEP:Think()

	local vm = self.Owner:GetViewModel()
	local curtime = CurTime()
	local idletime = self:GetNextIdle()

	if ( idletime > 0 && CurTime() > idletime ) then

		self:SendWeaponAnim( ACT_VM_IDLE )

		self:UpdateNextIdle()

	end

	local meleetime = self:GetNextMeleeAttack()

	if ( meleetime > 0 && CurTime() > meleetime ) then

		self:DealDamage()

		self:SetNextMeleeAttack( 0 )

	end

	if ( SERVER && CurTime() > self:GetNextPrimaryFire() + 0.1 ) then

		self:SetCombo( 0 )

	end

end

--PATH addons/_drones/lua/weapons/weapon_drr_menu.lua:
AddCSLuaFile()

SWEP.PrintName	= "Upgrades / Settings"
SWEP.Category = "Drones Rewrite Tools"

SWEP.Spawnable	= true
SWEP.UseHands	= true
SWEP.DrawAmmo	= false

SWEP.ViewModelFOV	= 70
SWEP.Slot			= 0
SWEP.SlotPos		= 5

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.snd = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -38.889, 0) },
	["ValveBiped.Bip01_R_Finger21"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -52.223, 0) },
	["ValveBiped.Bip01_R_Finger11"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -67.778, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-5.742, 2.407, -1.668), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-12.223, -83.334, 1.11) },
	["ValveBiped.Bip01_R_Finger31"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -27.778, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-21.112, 16.666, 41.111) },
	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -54.445, 0) },
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -63.334, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(16.666, 47.777, -38.889) }
}

if CLIENT then
	SWEP.VElements = {
		["m"] = { type = "Model", model = "models/props_c17/tools_wrench01a.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-1, -1.601, -0.519), angle = Angle(-33.896, 148.442, -90), size = Vector(1.014, 1.014, 1.014), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}

	SWEP.WElements = {
		["m"] = { type = "Model", model = "models/props_c17/tools_wrench01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 1.557, -3.636), angle = Angle(-12.858, 180, -85.325), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}
end

function SWEP:Initialize()
	self:SetHoldType("pistol")

	if CLIENT then
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
end

function SWEP:DrawHUD()
	if SERVER then return end

	draw.SimpleText("Left click - upgrades / Right click - weapons menu (admin only) / Reload key - friends menu", "DronesRewrite_customfont2", ScrW() * 0.5, ScrH() - 220, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER)
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end

SWEP.WaitForMenu = 0

function SWEP:Think()
	if SERVER then return end

	if self.Owner:KeyPressed(IN_ATTACK) and CurTime() > self.WaitForMenu then
		local tr = self.Owner:GetEyeTrace()
		local ent = tr.Entity

		if ent:IsValid() and ent.IS_DRR and tr.HitPos:Distance(self.Owner:GetPos()) < 400 then
			ent:OpenUpgradesMenu()
		end

		self.WaitForMenu = CurTime() + 1
	end

	local tr = self.Owner:GetEyeTrace()
	if self.Owner:KeyPressed(IN_ATTACK2) and CurTime() > self.WaitForMenu and tr.HitPos:Distance(self.Owner:GetPos()) < 400 then
		local ent = tr.Entity

		if ent:IsValid() and ent.IS_DRR then
			ent:CallWeaponsMenu()
		end

		self.WaitForMenu = CurTime() + 1
	end

	if self.Owner:KeyDown(IN_RELOAD) and CurTime() > self.WaitForMenu and tr.HitPos:Distance(self.Owner:GetPos()) < 400 then
		self.WaitForMenu = CurTime() + 1

		local tr = self.Owner:GetEyeTrace()

		local drone = tr.Entity
		if not drone.IS_DRR then return end

		local win = DRONES_REWRITE.CreateWindow(200, 200)
		local p = DRONES_REWRITE.CreateScrollPanel(0, 25, 365, 175, win)

		win:SetTitle("This is friends menu")

		for k, v in SortedPairs(player.GetAll()) do
			local btn = DRONES_REWRITE.CreateButton(v:Name(), 0, 1 + ((k - 1) * 21), 200, 20, p, function()
				net.Start("dronesrewrite_addfriend")
					net.WriteEntity(drone)
					net.WriteEntity(v)
				net.SendToServer()
			end)
		end
	end
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Deploy()
	return true
end



/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Dont come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we cant do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or youll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--PATH addons/_drones/lua/weapons/weapon_drr_remote.lua:
AddCSLuaFile()

SWEP.PrintName	= "Remote Controller"
SWEP.Category = "Drones Rewrite Tools"
SWEP.Purpose = "Tool that allows you drive drones"

SWEP.Spawnable	= true
SWEP.UseHands	= true
SWEP.DrawAmmo	= false

SWEP.ViewModelFOV	= 50
SWEP.Slot			= 0
SWEP.SlotPos		= 5

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.ViewModel = "models/dronesrewrite/c_controller/c_controller.mdl"
SWEP.WorldModel = "models/dronesrewrite/w_controller/w_controller.mdl"

SWEP.TargetDRR = NULL
SWEP.IndexDRR = 0
SWEP.WaitDRR = 0

SWEP.RemoteDRRDistance = 4096

function SWEP:DoIdle()
	timer.Create("weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() 
		if IsValid(self) then 
			self:SendWeaponAnim(ACT_VM_IDLE) 
			self:DoIdle()
		end 
	end)
end

function SWEP:Initialize()
	self:SetHoldType("slam")
end

function SWEP:DrawHUD()
	if SERVER then return end
	if self.Owner:GetNWEntity("DronesRewriteDrone"):IsValid() then return end

	local tr = util.TraceLine({
		start = EyePos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.RemoteDRRDistance,
		filter = self.Owner
	})

	local ent = tr.Entity
	local text = "Drone that you're looking at - "

	if not IsValid(ent) then 
		ent = self:GetNWEntity("DronesRewriteDrone") 
		text = "Chosen drone - "
	end

	if IsValid(ent) and ent.IS_DRR then
		local x, y = ScrW() * 0.5, ScrH() - 220
		draw.SimpleText(text .. ent:GetUnit(), "DronesRewrite_customfont2_1", x, y, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER)

		local pos = ent:LocalToWorld(ent:OBBCenter())
		local tr = util.TraceLine({
			start = EyePos(),
			endpos = pos,
			filter = self.Owner
		})

		if tr.Hit and tr.Entity != ent then return end

		local pos = pos:ToScreen()

		local size = math.sin(CurTime() * 2) * 30
		surface.DrawCircle(pos.x, pos.y, size, Color(255, 255, 255, 50))

		local size = math.sin(CurTime() * 4) * 30
		surface.DrawCircle(pos.x, pos.y, size, Color(255, 255, 255, 50))

		surface.SetMaterial(Material("stuff/signal"))
		surface.SetDrawColor(Color(255, 255, 255, math.abs(math.sin(CurTime()) * 128)))
		surface.DrawTexturedRect(pos.x - 64, pos.y - 16, 32, 32)

		--surface.SetDrawColor(Color(255, 255, 255, 10 + math.sin(CurTime() * 6) * 10))
		--surface.DrawLine(x, y, pos.x, pos.y)
	end
end

function SWEP:Think()
	if SERVER and IsValid(self.TargetDRR) then
		if self.TargetDRR:IsFarFarAway(self.Owner) then
			self.TargetDRR = NULL
			self:SetNWEntity("DronesRewriteDrone", NULL)

			self:EmitSound("drones/alarm.wav", 75, 64)
		end
	end

	if CLIENT and self.Owner:KeyDown(IN_RELOAD) and CurTime() > self.WaitDRR and not self.Owner:GetNWEntity("DronesRewriteDrone"):IsValid() then
		self.WaitDRR = CurTime() + 0.3

		local tr = util.TraceLine({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.RemoteDRRDistance,
			filter = self.Owner
		})

		local drone = tr.Entity
		if not IsValid(drone) then drone = self:GetNWEntity("DronesRewriteDrone") end
		if not drone.IS_DRR then return end
		--if not drone:CanBeControlledBy(self.Owner) then return end

		local win = DRONES_REWRITE.CreateWindow(365, 400)
		local p = DRONES_REWRITE.CreateScrollPanel(0, 25, 365, 375, win)

		win:SetTitle("This is key menu")

		local count = 1
		for bind, v in SortedPairs(DRONES_REWRITE.Keys) do
			local btn = DRONES_REWRITE.CreateButton(bind, 1, 1 + (count - 1) * 21, 242, 20, p, function()
				net.Start("dronesrewrite_clickkey")
					net.WriteEntity(drone)
					net.WriteString(bind)
				net.SendToServer()
			end)

			local btn = DRONES_REWRITE.CreateButton("Press / Unpress", 244, 1 + (count - 1) * 21, 120, 20, p, function(btn)
				net.Start("dronesrewrite_presskey")
					net.WriteEntity(drone)
					net.WriteInt(DRONES_REWRITE.ClientCVars.Keys[bind]:GetString(), 8)
				net.SendToServer()
			end)

			count = count + 1
		end
	end
end

function SWEP:PrimaryAttack()
	local tr = util.TraceLine({
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.RemoteDRRDistance,
		filter = self.Owner
	})

	local ent = tr.Entity
	if not IsValid(tr.Entity) then ent = self.TargetDRR end

	if IsValid(ent) and ent.IS_DRR then
		self:SetNextPrimaryFire(CurTime() + 0.5)
		self:SetNextSecondaryFire(CurTime() + 0.5)

		if SERVER then ent:SetDriver(self.Owner) end
	end
end

function SWEP:SecondaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.9)
	self:SetNextSecondaryFire(CurTime() + 0.9)

	self.Owner:SetAnimation(PLAYER_ATTACK1)
	self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

	self:DoIdle()

	timer.Create("request_drone" .. self:EntIndex(), self:SequenceDuration() * 0.35, 1, function()
		if not IsValid(self) then return end

		self.Owner:EmitSound("ambient/machines/keyboard7_clicks_enter.wav", 65, 150)

		if CLIENT then return end

		local tr = util.TraceLine({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.RemoteDRRDistance,
			filter = self.Owner
		})

		if tr.Hit and IsValid(tr.Entity) and tr.Entity.IS_DRR then
			self.TargetDRR = tr.Entity
		else
			local function foo()
				local tab = { }

				for k, v in ipairs(DRONES_REWRITE.GetDronesRewrite()) do
					if not v:IsFarFarAway(self.Owner) then
						table.insert(tab, v)
					end
				end

				local old = self.TargetDRR

				self.TargetDRR = table.Random(tab)
				if #tab > 1 and IsValid(self.TargetDRR) and self.TargetDRR == old then foo() end
			end

			foo()
		end

		if not IsValid(self.TargetDRR) then 
			self.Owner:EmitSound("buttons/lightswitch2.wav", 65, 160) 
		elseif self.TargetDRR:CanBeControlledBy(self.Owner) then
			self:SetNWBool("Draw", true)

			local pitch = 200
			timer.Create("dosounds" .. self:EntIndex(), 0.1, 3, function()
				if not IsValid(self) then return end

				self:EmitSound("buttons/button17.wav", 65, pitch)
				pitch = pitch + 15
			end)
		end

		self:SetNWEntity("DronesRewriteDrone", self.TargetDRR)
	end)
end

function SWEP:OnRemove()
	timer.Stop("weapon_idle" .. self:EntIndex())
	timer.Stop("request_drone" .. self:EntIndex())
end

function SWEP:Holster()
	self:OnRemove()
	return true
end

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
	self:DoIdle()

	self:SetDeploySpeed(0.7)
	
	self:SetNextPrimaryFire(CurTime() + self:SequenceDuration() * 0.8)
	self:SetNextSecondaryFire(CurTime() + self:SequenceDuration() * 0.8)

	return true
end

--PATH addons/_drones/lua/weapons/weapon_drr_repairtool.lua:
AddCSLuaFile()

SWEP.PrintName	= "Repairer"
SWEP.Category = "Drones Rewrite Tools"

SWEP.Spawnable	= true
SWEP.UseHands	= true
SWEP.DrawAmmo	= false

SWEP.ViewModelFOV	= 70
SWEP.Slot			= 0
SWEP.SlotPos		= 5

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.snd = false

if CLIENT then
	SWEP.VElements = {
		["m+"] = { type = "Model", model = "models/props_combine/combinebutton.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(0.319, -0.051, -6.023), angle = Angle(-90, -90, 180), size = Vector(0.109, 0.109, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["m"] = { type = "Model", model = "models/props_combine/combine_monitorbay.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(-0.16, -2.33, 2.051), angle = Angle(-90, -88, 0), size = Vector(0.056, 0.014, 0.025), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["1"] = { type = "Model", model = "models/props_combine/combine_light001b.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(0, -0.283, 6.741), angle = Angle(0, 90, 180), size = Vector(0.123, 0.163, 0.212), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}

	SWEP.WElements = {
		["m+"] = { type = "Model", model = "models/props_combine/combinebutton.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-2.619, 1.875, -2.8), angle = Angle(-180, -2.368, 0), size = Vector(0.109, 0.109, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["m"] = { type = "Model", model = "models/props_combine/combine_monitorbay.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.069, 1.8, -5.712), angle = Angle(7.514, 176.912, 0), size = Vector(0.056, 0.014, 0.025), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["1"] = { type = "Model", model = "models/props_combine/combine_light001b.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(10, 2.148, -4.488), angle = Angle(-82.854, 176.705, -0.7), size = Vector(0.158, 0.158, 0.214), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["e"] = { type = "Model", model = "models/props_combine/combine_intwallunit.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.359, 1.871, -5.472), angle = Angle(-7.081, -1.856, 178.697), size = Vector(0.05, 0.041, 0.064), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}
end

function SWEP:Initialize()
	self:SetHoldType("pistol")

	if CLIENT then
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

function SWEP:PrimaryAttack()
	local tr = util.TraceHull {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 150,
		filter = self.Owner,
		mins = Vector(-5, -5, -5),
		maxs = Vector(5, 5, 5)
	}

	if tr.Hit then
		if not self.Sound then 
			self.Sound = CreateSound(self.Owner, "ambient/energy/force_field_loop1.wav") 
			self.Sound:Play() 
			self.Sound:ChangePitch(150, 0)
		end

		ParticleEffect("laser_hit_drr", tr.HitPos, Angle(0, 0, 0))
	else
		if self.Sound then self.Sound:Stop() self.Sound = nil end
	end

	local ent = tr.Entity
	
	if SERVER and ent:IsValid() then
		if ent.IS_DRR then
			if ent:GetHealth() < ent:GetDefaultHealth() then ent:SetHealthAmount(ent:GetHealth() + 3) end
		elseif ent:GetClass() == "dronesrewrite_console" then
			ent:Repair()
		else
			ent:TakeDamage(1)
		end
	end

	self:SetNextPrimaryFire(CurTime() + 0.3)
end

function SWEP:Think()
	if self.Sound and not self.Owner:KeyDown(IN_ATTACK) then self.Sound:Stop() self.Sound = nil end
end

function SWEP:SecondaryAttack()
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	if self.Sound then self.Sound:Stop() self.Sound = nil end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Deploy()
	return true
end



/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Dont come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

if CLIENT then
	local laser = Material("sprites/physgbeamb")

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		if self.Owner:KeyDown(IN_ATTACK) then
			local vm = LocalPlayer():GetViewModel()
			local start = vm:GetAttachment(1).Pos
			local endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 150

			render.SetMaterial(laser)
			render.DrawBeam(start, endpos, math.Rand(1, 2), math.Rand(0, 25), math.Rand(0, 50), Color(255, 155, 0, 255))
		end
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if IsValid(self.Owner) and self.Owner:KeyDown(IN_ATTACK) then
			local start = self:GetAttachment(1).Pos
			local endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 150

			render.SetMaterial(laser)
			render.DrawBeam(start, endpos, math.Rand(1, 2), math.Rand(0, 50), math.Rand(0, 50), Color(255, 155, 0, 255))
		end
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we cant do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in ipairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or youll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--PATH addons/__main/lua/weapons/weapon_long_golden_revolver.lua:
SWEP.PrintName = "Long Golden Revolver"
SWEP.Author = "DerHobbyRoller"
SWEP.Instructions = "Left Mouse Button to Shoot lol"
SWEP.Spawnable = true
SWEP.AdminOnly = false


SWEP.Primary.ClipSize = 6
SWEP.Primary.DefaultClip = 6
SWEP.Primary.Ammo = "357"
SWEP.Primary.Automatic = false
SWEP.Primary.Recoil = 1111
SWEP.Primary.Damage = 200
SWEP.Primary.NumShots = 1
SWEP.Primary.Spread = 0
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1


SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Automatic = false


SWEP.Weight			= 7
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.Slot			= 1
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= true
SWEP.DrawCrosshair		= true


SWEP.ViewModel			= "models/weapons/golden/c_357.mdl"
SWEP.WorldModel			= "models/weapons/golden/w_357.mdl"

if CLIENT then
SWEP.WepSelectIcon = surface.GetTextureID("VGUI/entities/iconGold")
SWEP.IconOverride = "materials/entities/longRevolverGold.png"
end

SWEP.Category = "Long Revolver"
SWEP.UseHands = true

SWEP.SetHoldType = "pistol"

local ShootSound = Sound("Weapon_357.single")

function SWEP:PrimaryAttack()
	if ( !self:CanPrimaryAttack() ) then return end

	local ply = self:GetOwner()
	ply:LagCompensation(true)

	for i = 1, 3 do
		if ( !self:CanPrimaryAttack() ) then break end
		self:ShootBullet( 75, 1, 0.002 )
		self:ShootEffects()
		self:TakePrimaryAmmo(1)
		self:EmitSound(ShootSound)
		self.Owner:ViewPunch( Angle( -5, 0, 0 ) )
		self.BaseClass.ShootEffects(self)

	end
	
	
	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay+0.1)

	
	ply:LagCompensation(false)
	

end
--PATH addons/lvs_base-main/lua/weapons/weapon_lvsrepair.lua:
AddCSLuaFile()

SWEP.Category				= "[LVS]"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/weapons/c_repairlvs.mdl"
SWEP.WorldModel			= "models/weapons/w_repairlvs.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.MaxRange = 250

function SWEP:SetupDataTables()
	self:NetworkVar( "Float",0, "FlameTime" )
end

function SWEP:GetLVS()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return NULL end

	local ent = ply:GetEyeTrace().Entity

	if not IsValid( ent ) then return NULL end

	if ent._lvsRepairToolLabel or ent.LVS then return ent end

	if not ent.GetBase then return NULL end

	ent = ent:GetBase()

	if IsValid( ent ) and ent.LVS then return ent end

	return NULL
end

function SWEP:FindClosest()
	local lvsEnt = self:GetLVS()

	if not IsValid( lvsEnt ) then return NULL end

	local ply = self:GetOwner()

	if ply:InVehicle() then return end

	local ShootPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()

	local ClosestDist = self.MaxRange
	local ClosestPiece = NULL

	local tableEnts = lvsEnt:GetChildren()

	if isfunction( lvsEnt.GetCrosshairFilterEnts ) then
		tableEnts = lvsEnt:GetCrosshairFilterEnts()
	end

	for _, target in pairs( tableEnts ) do
		if not IsValid( target ) then continue end

		for _, entity in pairs( target:GetChildren() ) do
			if entity:GetClass() ~= "lvs_armor" then continue end

			local boxOrigin = entity:GetPos()
			local boxAngles = entity:GetAngles()
			local boxMins = entity:GetMins()
			local boxMaxs = entity:GetMaxs()

			local HitPos, _, _ = util.IntersectRayWithOBB( ShootPos, AimVector * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

			if isvector( HitPos ) then
				local Dist = (ShootPos - HitPos):Length()

				if Dist < ClosestDist then
					ClosestDist = Dist
					ClosestPiece = entity
				end
			end
		end
	end

	return ClosestPiece
end

local function IsEngineMode( AimPos, Engine )
	if not IsValid( Engine ) then return false end

	if not isfunction( Engine.GetDoorHandler ) then return (AimPos - Engine:GetPos()):Length() < 25 end

	local DoorHandler = Engine:GetDoorHandler()

	if IsValid( DoorHandler ) then
		if DoorHandler:IsOpen() then
			return (AimPos - Engine:GetPos()):Length() < 50
		end

		return false
	end

	return (AimPos - Engine:GetPos()):Length() < 25
end

if CLIENT then
	SWEP.PrintName		= "Repair Torch"
	SWEP.Author			= "Blu-x92"

	SWEP.Slot				= 5
	SWEP.SlotPos			= 1

	SWEP.Purpose			= "Repair Broken Armor"
	SWEP.Instructions		= "Primary to Repair\nHold Secondary to switch to Armor Repair Mode"
	SWEP.DrawWeaponInfoBox 	= true

	SWEP.WepSelectIcon 			= surface.GetTextureID( "weapons/lvsrepair" )

	local ColorSelect = Color(0,255,255,50)
	local ColorText = Color(255,255,255,255)

	local function DrawText( pos, text, col )
		cam.Start2D()
			local data2D = pos:ToScreen()

			if not data2D.visible then return end

			local font = "TargetIDSmall"

			local x = data2D.x
			local y = data2D.y

			draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
		cam.End2D()
	end

	function SWEP:DrawEffects( weapon, ply )
		local ID = weapon:LookupAttachment( "muzzle" )

		local Muzzle = weapon:GetAttachment( ID )

		if not Muzzle then return end

		local T = CurTime()

		if self:GetFlameTime() < T or (self._NextFX1 or 0) > T then return end

		self._NextFX1 = T + 0.02

		local effectdata = EffectData()
		effectdata:SetOrigin( Muzzle.Pos )
		effectdata:SetAngles( Muzzle.Ang )
		effectdata:SetScale( 0.5 )
		util.Effect( "MuzzleEffect", effectdata, true, true )

		if (self._NextFX2 or 0) > T then return end

		self._NextFX2 = T + 0.06

		local trace = ply:GetEyeTrace()
		local ShootPos = ply:GetShootPos()

		if (ShootPos - trace.HitPos):Length() > self.MaxRange then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal * 0.15 )
		util.Effect( "manhacksparks", effectdata, true, true )

		local dlight = DynamicLight( self:EntIndex() )

		if not dlight then return end

		dlight.pos = (trace.HitPos + ShootPos) * 0.5
		dlight.r = 206
		dlight.g = 253
		dlight.b = 255
		dlight.brightness = 3
		dlight.decay = 1000
		dlight.size = 256
		dlight.dietime = CurTime() + 0.1
	end

	function SWEP:PostDrawViewModel( vm, weapon, ply )
		self:DrawEffects( vm, ply )
	end

	function SWEP:DrawWorldModel( flags )
		self:DrawModel( flags )
		self:DrawEffects( self, self:GetOwner() )
	end

	function SWEP:DrawHUD()
		local ply = self:GetOwner()

		if not IsValid( ply ) or not ply:KeyDown( IN_ATTACK2 ) then
			local lvsEnt = self:GetLVS()
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( lvsEnt ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				local Label = lvsEnt._lvsRepairToolLabel or "Frame"

				if isfunction( lvsEnt.GetEngine ) then
					local Engine = lvsEnt:GetEngine()

					local AimPos = ply:GetEyeTrace().HitPos

					local EngineMode = IsEngineMode( AimPos, Engine )

					if IsValid( Engine ) and EngineMode then
						DrawText( AimPos, "Engine\nHealth: "..math.Round(Engine:GetHP()).."/"..Engine:GetMaxHP(), ColorText )
					else
						DrawText( AimPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
					end
				else
					DrawText( ply:GetEyeTrace().HitPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
				end
			end

			return
		end

		local Target = self:FindClosest()

		if IsValid( Target ) then
			local boxOrigin = Target:GetPos()
			local boxAngles = Target:GetAngles()
			local boxMins = Target:GetMins()
			local boxMaxs = Target:GetMaxs()

			cam.Start3D()
				render.SetColorMaterial()
				render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, ColorSelect )
			cam.End3D()

			DrawText( Target:LocalToWorld( (boxMins + boxMaxs) * 0.5 ), (Target:GetIgnoreForce() / 100).."mm "..Target:GetLabel().."\nHealth: "..math.Round(Target:GetHP()).."/"..Target:GetMaxHP(), ColorText )
		else
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( self:GetLVS() ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				DrawText( Pos, "No Armor", ColorText )
			end
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local T = CurTime()

	self:SetNextPrimaryFire( T + 0.15 )

	self:SetFlameTime( T + 0.3 )

	local EngineMode = false
	local ArmorMode = true
	local Target = self:FindClosest()

	local ply = self:GetOwner()

	if IsValid( ply ) and not ply:KeyDown( IN_ATTACK2 ) then
		Target = self:GetLVS()

		if isfunction( Target.GetEngine ) then
			local Engine = Target:GetEngine()

			local AimPos = ply:GetEyeTrace().HitPos

			EngineMode = IsEngineMode( AimPos, Engine )

			if IsValid( Engine ) and EngineMode then
				Target = Engine
			end
		end

		ArmorMode = false
	end

	if not IsValid( Target ) then return end

	local HP = Target:GetHP()
	local MaxHP = Target:GetMaxHP()

	if IsFirstTimePredicted() then
		local trace = ply:GetEyeTrace()

		if HP ~= MaxHP then
			local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal )
			util.Effect( "stunstickimpact", effectdata, true, true )
		end
	end

	if CLIENT then return end

	Target:SetHP( math.min( HP + 15, MaxHP ) )

	if EngineMode and Target:GetDestroyed() then
		Target:SetDestroyed( false )
	end

	if not ArmorMode then return end

	if Target:GetDestroyed() then Target:SetDestroyed( false ) end

	if HP < MaxHP then return end

	Target:OnRepaired()
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	local ply = self:GetOwner()

	if not IsValid( ply ) then self:StopSND() return end

	local PlaySound = self:GetFlameTime() >= CurTime() and (ply:GetShootPos() - ply:GetEyeTrace().HitPos):Length() < self.MaxRange

	if PlaySound then
		self:PlaySND()
	else
		self:StopSND()
	end
end

function SWEP:StopSND()
	if CLIENT then return end

	if not self._snd then return end

	self._snd:Stop()
	self._snd = nil
end

function SWEP:PlaySND()
	if CLIENT then return end

	if self._snd then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	self._snd = CreateSound( ply, "lvs/weldingtorch_loop.wav" )
	self._snd:PlayEx(1, 70 )
end

function SWEP:OnRemove()
	self:StopSND()
end

function SWEP:OnDrop()
	self:StopSND()
end

function SWEP:Holster( wep )
	self:StopSND()
	return true
end

--PATH addons/__main/lua/autorun/sh_mas_ninjaskunai_fonts.lua:
/*

 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗██████╗     ██████╗ ██╗   ██╗    ███╗   ███╗ █████╗ ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ 
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗╚██╗ ██╔╝    ████╗ ████║██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══███╔╝██╔═══██╗
██║     ██████╔╝█████╗  ███████║   ██║   █████╗  ██║  ██║    ██████╔╝ ╚████╔╝     ██╔████╔██║███████║██████╔╝███████║██╔██╗ ██║  ███╔╝ ██║   ██║
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗  ╚██╔╝      ██║╚██╔╝██║██╔══██║██╔══██╗██╔══██║██║╚██╗██║ ███╔╝  ██║   ██║
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝   ██║       ██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██║██║ ╚████║███████╗╚██████╔╝
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝    ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

------------------------------------------------------------------------------------------------------------------------------------------------------

██████╗  ██████╗     ███╗   ██╗ ██████╗ ████████╗    ██████╗ ███████╗██╗   ██╗██████╗ ██╗      ██████╗  █████╗ ██████╗                               
██╔══██╗██╔═══██╗    ████╗  ██║██╔═══██╗╚══██╔══╝    ██╔══██╗██╔════╝██║   ██║██╔══██╗██║     ██╔═══██╗██╔══██╗██╔══██╗                              
██║  ██║██║   ██║    ██╔██╗ ██║██║   ██║   ██║       ██████╔╝█████╗  ██║   ██║██████╔╝██║     ██║   ██║███████║██║  ██║                              
██║  ██║██║   ██║    ██║╚██╗██║██║   ██║   ██║       ██╔══██╗██╔══╝  ██║   ██║██╔═══╝ ██║     ██║   ██║██╔══██║██║  ██║                              
██████╔╝╚██████╔╝    ██║ ╚████║╚██████╔╝   ██║       ██║  ██║███████╗╚██████╔╝██║     ███████╗╚██████╔╝██║  ██║██████╔╝                              
╚═════╝  ╚═════╝     ╚═╝  ╚═══╝ ╚═════╝    ╚═╝       ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝                               

██╗███╗   ██╗     █████╗ ███╗   ██╗██╗   ██╗    ███████╗██╗  ██╗ █████╗ ██████╗ ███████╗     ██████╗ ██████╗     ███████╗ ██████╗ ██████╗ ███╗   ███╗
██║████╗  ██║    ██╔══██╗████╗  ██║╚██╗ ██╔╝    ██╔════╝██║  ██║██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗    ██╔════╝██╔═══██╗██╔══██╗████╗ ████║
██║██╔██╗ ██║    ███████║██╔██╗ ██║ ╚████╔╝     ███████╗███████║███████║██████╔╝█████╗      ██║   ██║██████╔╝    █████╗  ██║   ██║██████╔╝██╔████╔██║
██║██║╚██╗██║    ██╔══██║██║╚██╗██║  ╚██╔╝      ╚════██║██╔══██║██╔══██║██╔═══╝ ██╔══╝      ██║   ██║██╔══██╗    ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
██║██║ ╚████║    ██║  ██║██║ ╚████║   ██║       ███████║██║  ██║██║  ██║██║     ███████╗    ╚██████╔╝██║  ██║    ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
╚═╝╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚══════╝     ╚═════╝ ╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 

*/
AddCSLuaFile()

if CLIENT then
	surface.CreateFont( "MaranzoAbil_UltimateFont", {
		font = "Arial",
		extended = false,
		size = 48,
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		shadow = false
	} )
	surface.CreateFont( "MaranzoAbil_DefaultFont", {
		font = "DermaDefaultBold",
		extended = false,
		size = 24,
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		shadow = false
	} )
end
--PATH addons/_avatar/lua/weapons/weapon_sokka_machete.lua:
if CLIENT then
	SWEP.DrawWeaponInfoBox = false
	SWEP.BounceWeaponIcon = false
	language.Add( "weapon_sokka_machete", "Sokka Battle Club" )
end

SWEP.PrintName = "Sokka Battle Club"
SWEP.Category = "Avatar"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFOV = 75
SWEP.ViewModel = "models/weapons/c_invisstick2.mdl"
SWEP.WorldModel = "models/avatar/sokka_battle_club.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.UseHands = true
SWEP.HoldType = "melee"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = true
SWEP.Idle = 0
SWEP.IdleTimer = CurTime()
SWEP.Primary.Sound = Sound( "common/null.wav" )
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 15
SWEP.Primary.DelayMiss = 0.5
SWEP.Primary.DelayHit = 0.4
SWEP.Primary.Force = 1000
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5
SWEP.ViewModelBoneMods = {}
SWEP.VElements = {
	["v_element"] = {
		type = "Model",
		model = "models/avatar/sokka_battle_club.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector( 2.918, 1.518, -0.539 ),
		angle = Angle( 180, -100, 0 ),
		size = Vector( 1.2, 1.5, 1.5 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetWeaponHoldType( self.HoldType )
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:SetWeaponHoldType( self.HoldType )
		self:CreateModels( self.VElements ) -- create viewmodels
		-- init view model bone build function
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in ipairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in ipairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! --
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v )
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

----------------------------------------------------
function SWEP:Deploy()
	self:SetWeaponHoldType( self.HoldType )
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + 0.5 )
	self:SetNextSecondaryFire( CurTime() + 0.5 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	return true
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()
	return true
end

function SWEP:PrimaryAttack()
	self:GetOwner():LagCompensation( true )
	local tr = util.TraceLine( {
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 76,
		filter = self:GetOwner(),
		mask = MASK_SHOT_HULL,
	} )

	if not IsValid( tr.Entity ) then
		tr = util.TraceHull( {
			start = self:GetOwner():GetShootPos(),
			endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 76,
			filter = self:GetOwner(),
			mins = Vector( -16, -16, 0 ),
			maxs = Vector( 16, 16, 0 ),
			mask = MASK_SHOT_HULL,
		} )
	end

	if SERVER and IsValid( tr.Entity ) then
		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( self:GetOwner() )
		dmginfo:SetInflictor( self )
		dmginfo:SetDamageType( DMG_CLUB )
		dmginfo:SetDamage( self.Primary.Damage )
		if IsValid( tr.Entity:GetPhysicsObject() ) then
			dmginfo:SetDamageForce( self:GetOwner():GetAimVector() * 20 )
		else
			dmginfo:SetDamageForce( self:GetOwner():GetAimVector() * 5000 )
		end

		SuppressHostEvents( NULL )
		tr.Entity:TakeDamageInfo( dmginfo )
		SuppressHostEvents( self:GetOwner() )
	end

	if tr.Hit then
		if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity.Type == "nextbot" or tr.Entity:GetClass() == "prop_ragdoll" then
			if SERVER then
				self:GetOwner():EmitSound( "Weapon_Crowbar.Melee_Hit" )
				self:GetOwner():EmitSound( "phx/epicmetal_hard" .. math.random( 1, 7 ) .. ".wav", 70, 100, 0.2 )
			end

			local BLOOOD = EffectData()
			BLOOOD:SetOrigin( tr.HitPos )
			BLOOOD:SetMagnitude( math.random( 1, 3 ) )
			BLOOOD:SetEntity( tr.Entity )
			util.Effect( "bloodstream", BLOOOD )
		else
			if SERVER then self:GetOwner():EmitSound( "Weapon_Crowbar.Melee_HitWorld" ) end
			local effectdata = EffectData()
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
			effectdata:SetMagnitude( 1 )
			effectdata:SetScale( 2 )
			effectdata:SetRadius( 1 )
			util.Effect( "Sparks", effectdata )
		end

		self:GetOwner():ViewPunch( Angle( -1, -1, 0 ) )
		self:SendWeaponAnim( ACT_VM_HITCENTER )
		self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
		self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
	else
		self:GetOwner():ViewPunch( Angle( 1, 1, 0 ) )
		self:EmitSound( "Weapon_Crowbar.Single" )
		self:SendWeaponAnim( ACT_VM_MISSCENTER )
		self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
		self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
	end

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	self:GetOwner():LagCompensation( false )
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
		self.Idle = 1
	end
end

if CLIENT then
	local WorldModel = ClientsideModel( SWEP.WorldModel )
	--WorldModel:SetSkin(1)
	WorldModel:SetNoDraw( true )
	function SWEP:DrawWorldModel()
		--self:Drawspiral()
		--self.Weapon:DrawModel()
		local _Owner = self:GetOwner()
		local ownervalid = IsValid( _Owner )
		if ownervalid then
			-- Specify a good position
			local offsetVec = Vector( 2.2, -0.5, -1 )
			local offsetAng = Angle( 180, -90, 0 )
			local boneid = _Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix( boneid )
			if not matrix then return end
			local newPos, newAng = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )
			WorldModel:SetPos( newPos )
			WorldModel:SetAngles( newAng )
			WorldModel:SetupBones()
		else
			WorldModel:SetPos( self:GetPos() )
			WorldModel:SetAngles( self:GetAngles() )
		end

		WorldModel:DrawModel()
	end
end
--PATH addons/__main/lua/weapons/weapon_undertale_sans_admin.lua:
AddCSLuaFile()

SWEP.Base 					= "weapon_base"
SWEP.PrintName				= "Undertale Sans Power Badtime"
SWEP.HoldType 				= "normal"
SWEP.Slot					= 0
SWEP.SlotPos				= 0
SWEP.Spawnable				= true
SWEP.AdminOnly				= true
SWEP.Primary.ClipSize 		= 0
SWEP.Primary.DefaultClip 	= 0
SWEP.DrawCrosshair			= true
SWEP.Category 				= "Undertale"
SWEP.DrawWeaponInfoBox		= true
SWEP.BounceWeaponIcon		= false
SWEP.ViewModel 				= "models/weapons/c_arms_refugee.mdl"
SWEP.WorldModel 			= ""
SWEP.Primary.Automatic 		= true
SWEP.Secondary.Automatic 	= true
//SWEP.ShowViewModel 			= true
//SWEP.ShowWorldModel 		= false
SWEP.Primary.Ammo 			= ""
SWEP.Secondary.Ammo 		= ""

function TraceHull( vecstart, vecend, vecmin, vecmax, tracefiler )
	local trace = util.TraceHull( {
		start = vecstart,
		endpos = vecend,
		filter = tracefiler,
		mins = vecmin,
		maxs = vecmax,
		mask = MASK_SHOT_HULL
	} )
	
	return trace
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	
	if( SERVER ) then
		util.AddNetworkString( "miss" )
		
		hook.Add( "EntityTakeDamage", "DamageAdmin", function( ent, dmginfo )
			if( ent:IsPlayer() && ent:Health() > 0 ) then
				if( ent:GetActiveWeapon():IsValid() && ent:GetVar( "miss", NULL ) != NULL ) then
					if( CurTime() >= ent:GetVar( "miss", NULL ) ) then
						if( ent:GetActiveWeapon():GetClass() == "weapon_undertale_sans_admin" ) then
							net.Start( "miss" )
								net.WriteEntity( ent )
								local dmgpos = dmginfo:GetDamagePosition()
								if( dmgpos != Vector() ) then
									net.WriteVector( dmgpos )
								else
									net.WriteVector( ent:EyePos() )
								end
							net.Broadcast()
							
							ent:SetVar( "miss", CurTime() + 0.5 )
							
							dmginfo:SetDamage( 0 )
							dmginfo:SetDamageForce( Vector( 0, 0, 0 ) )
							dmginfo:SetDamageType( 0 )
							dmginfo:SetDamageBonus( 0 )

							ent:EmitSound( Sound( "undertale/attack.wav" ), 75, 100, 1, CHAN_AUTO  )
						end
					end
				end
			end
		end )
	end
	
	if( CLIENT ) then		
		net.Receive( "miss", function()
			local ply = net.ReadEntity()
			local vec = net.ReadVector()
			//print( ply, vec )
			
			local emitter = ParticleEmitter( vec, false )
			
			local particle = emitter:Add( Material( "undertale/miss" ), vec )
			if( particle ) then
				particle:SetVelocity( Vector( 0, 0, 10 ) )
				particle:SetColor( 255, 255, 255 ) 
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 2 )
				particle:SetStartSize( 10 )
				particle:SetEndSize( 10 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetGravity( Vector( 0, 0, 0 ) )
			end
			
			emitter:Finish()
		end )
	end
end

function SWEP:Equip()
	self:SetVar( "grabbedEnt", nil )
	self:SetVar( "distance", 0 )
	self:SetVar( "blockBoneGround", 0 )
	self:SetVar( "invincible", 0 )
	self:SetVar( "btm_client", NULL )
	self:SetVar( "anim_reset", NULL )
	
	self.Owner:SetVar( "miss", 0 )
	self.Owner:SetVar( "player_model", self.Owner:GetModel() )
end

function SWEP:Deploy( )
	if( CLIENT ) then return true end
	
	if( self.BeatSound ) then
		self.BeatSound:ChangeVolume( 1, 0.1 )
	else
		self.BeatSound = CreateSound( self.Owner, Sound( "undertale/theme/sans_theme.mp3" ) )
		self.BeatSound:Play()
	end
	
	local model	= "models/nia/sans_pm.mdl"
	if( util.IsValidModel( model ) ) then
		self.Owner:SetModel( model )
	end

	local model	= "models/sansplayer/sansplayer.mdl"
	if( util.IsValidModel( model ) ) then
		self.Owner:SetModel( model )
	end

	return true
end

function SWEP:KillSounds()
	if ( self.BeatSound ) then self.BeatSound:Stop() self.BeatSound = nil end
end

function SWEP:OnDrop( )
	if IsValid(self.Owner) then
		if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
			self.Owner:SetBodygroup( 1, 0 )
			self.Owner:SetBodygroup( 2, 0 )
		end

		if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
			self.Owner:SetBodygroup( 2, 0 )
		end


		if( self.Owner:Health() ) > 0 then
			self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
		end
	end

	self:KillSounds()
end

function SWEP:OnRemove()
	if( CLIENT ) then return end
	if( self.Owner:IsValid() ) then
		if( self.Owner:Health() > 0 ) then
			if( self.Owner:GetVar( "player_model", NULL ) != NULL ) then
				self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
			end
		end
	end

	self:KillSounds()
end

function SWEP:Holster( wep )
	if( CLIENT ) then return end
	
	if( !IsFirstTimePredicted() ) then return end

	self.Owner:DoAnimationEvent( ACT_GMOD_IN_CHAT )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 0, 0, 0 ) )
	self:SetVar( "anim_reset", true )
	if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
		self.Owner:SetBodygroup( 1, 0 )
		self.Owner:SetBodygroup( 2, 0 )
	end

	if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
		self.Owner:SetBodygroup( 2, 0 )
	end

	if( self.Owner:IsValid() ) then
		if( self.Owner:Health() > 0 ) then
			//print( wep, wep:GetClass() )
			self.Owner:SetActiveWeapon( wep )
			//self.Owner:SelectWeapon( wep:GetClass() ) 
			if( self.Owner:GetVar( "player_model", NULL ) != NULL ) then
				self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
			end
		end
	end

	if( self:GetVar( "grabbedEnt" ) ) then
		self:SetVar( "grabbedEnt", nil )
	end
	
	if ( self.BeatSound ) then self.BeatSound:ChangeVolume( 0, 0.1 ) end
	return true
end

//local grabbedEnt
//local distance
local max = 200
//local blockTelekinesis
//local invincible

function SWEP:Think()
	// Telekinesis
	local EyeTrace = self.Owner:GetEyeTrace()
	local grabbedEnt = self:GetVar( "grabbedEnt", NULL )
	local distance = self:GetVar( "distance", NULL )
	local blockBoneGround = self:GetVar( "blockBoneGround", NULL )
	
	if( CLIENT ) then return end
	if( self.Owner:GetVelocity():Length() < 30 || self.Owner:GetMoveType() == MOVETYPE_NOCLIP ) then
		//self.Owner:DoAnimationEvent( ACT_HL2MP_IDLE )
		
		if( self:GetVar( "anim_reset" ) != NULL ) then
			if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 10, -40 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 10, 30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, -90, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, -90, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 180, 0, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 180, 0, 0 ) )
			end
			if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 10, -30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 10, 30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, -60, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, -60, 0 ) )
			end
			self:SetVar( "anim_reset", NULL )
		end
	else
		if( self:GetVar( "anim_reset" ) == NULL && self.Owner:GetVelocity():Length() > 150 ) then
			self:SetVar( "anim_reset", true )
			
			//self.Owner:DoAnimationEvent( ACT_GMOD_IN_CHAT )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 0, 0, 0 ) )
		end
	end

	if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
		self.Owner:SetBodygroup( 1, 1 )
		self.Owner:SetBodygroup( 2, 1 )
	end

	if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
		self.Owner:SetBodygroup( 2, 2 )
	end

	
	if( self:GetVar( "btm_client" ) == NULL ) then
		//print( "sand " )

		self:SetVar( "btm_client", true )
	end
		
	if( self.Owner:KeyPressed( IN_RELOAD ) && self:GetVar( "blockBoneGround" ) == 0 ) then
		self:SetVar( "blockBoneGround", CurTime() + 0.5 )
		
		local tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 10000,
			filter = function( ent ) if ( ent:GetClass() == "prop_physics" ) then return false end end
		} )

		local pos = tr.HitPos
		local rad = 30
		
		sound.Play( Sound( "undertale/bone_start.wav" ), tr.HitPos )
		
		for i = 1, 15 do
			local vec = Vector( math.Rand( -rad, rad ), math.Rand( -rad, rad ), 0 )
			vec:Rotate( tr.HitNormal:Angle() + Angle( 90, 0, 0 ) )
			local ang = ( tr.HitNormal * 2 + VectorRand() ):Angle()
			
			local traceGrd = util.TraceLine( {
				start = pos + vec,
				endpos = pos + vec - ang:Up() * 50,
				filter = function( ent ) if ( ent:GetClass() == "prop_physics" ) then return true end end
			} )
			
			if( traceGrd.Hit ) then
				local ent = ents.Create( "ent_undertale_bone_ground" )
				ent:SetAngles( ang + Angle( 90, 0, 0 ) )
				ent:SetVar( "pos", pos )
				ent:SetVar( "normal", tr.HitNormal )
				ent:SetPos( traceGrd.HitPos )
				ent:SetOwner( self.Owner )
				//ent:EmitSound( "undertale/bone_start.wav", 75, 100, 1, CHAN_AUTO )
				ent:Spawn()
			end
		end
	end
	
	if( CurTime() > self:GetVar( "blockBoneGround" ) ) then
		self:SetVar( "blockBoneGround", 0 )
	end
	
	//if( blockTelekinesis == 0 ) then
		if( self.Owner:KeyPressed( IN_USE ) && EyeTrace.Entity:IsValid() ) then
			if( EyeTrace.Entity:IsNPC() || EyeTrace.Entity:IsPlayer() ) then
				self.Owner:EmitSound( Sound( "undertale/sans/active.wav" ), 75, 100, 1, CHAN_AUTO )
				
				self:SetVar( "grabbedEnt", EyeTrace.Entity )
				grabbedEnt = self:GetVar( "grabbedEnt", NULL )
				
				self:SetVar( "distance", math.max( max, self.Owner:GetPos():Distance( grabbedEnt:GetPos() ) ) )
				self:SetWeaponHoldType( "magic" )
			end
		end

		if( grabbedEnt:IsValid() ) then				
			local eyeAng = self.Owner:GetAngles()
			
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 20, 45 - eyeAng.x ) )
			
			if( self.Owner:KeyReleased( IN_USE ) ) then
				self:SetVar( "anim_reset", true )
				self:SetVar( "grabbedEnt", nil )
			end
		end
	//end
	
	if( grabbedEnt != nil ) then
		if( grabbedEnt:IsValid() ) then
			
			local EyeDir = ( EyeTrace.HitPos - self.Owner:GetShootPos() )
			EyeDir:Normalize()

			grabbedEnt:SetVelocity( ( self.Owner:GetShootPos() + EyeDir * distance - Vector( 0, 0, grabbedEnt:GetModelRadius() * 0.5 ) - grabbedEnt:GetPos() ) * 10 - grabbedEnt:GetVelocity() )
			
			if( self:GetVar( "invincible" ) == 0 ) then
				local tr = util.TraceHull( {
					start = grabbedEnt:GetPos(),
					endpos = grabbedEnt:GetPos() + grabbedEnt:GetVelocity() / 40,
					filter = grabbedEnt,
					mins = grabbedEnt:OBBMins(),
					maxs = grabbedEnt:OBBMaxs()
				} )
				
				if( tr.HitWorld && grabbedEnt:GetVelocity():Length() > 200 ) then
					self:SetVar( "invincible", CurTime() )
				
					grabbedEnt:TakeDamage( grabbedEnt:GetVelocity():Length() / 100, self.Owner, self.Owner )
					
					grabbedEnt:EmitSound( Sound( "undertale/sans/smash.wav" ), 75, 100, 1, CHAN_AUTO ) 
					//EmitSound( Sound( sound ),grabbedEnt:GetPos() )
				end
			elseif ( CurTime() - self:GetVar( "invincible" ) ) >= 0.5 then
				self:SetVar( "invincible", 0 )
			end
		end
	end
end

function SWEP:PrimaryAttack()
	if( CLIENT ) then return end
	
	//if( !self:GetVar( "grabbedEnt", NULL ):IsValid() ) then
	
		self:SetNextPrimaryFire( CurTime() + 0.2 )
		self:SetNextSecondaryFire( CurTime() + 0.1 )
		
		local ent = ents.Create( "ent_undertale_gaster_blaster" )
		local rand = math.Rand( -math.pi, math.pi ) * 0.5
		local vec = Vector( 0, math.sin( rand ) * 70, 100 + math.cos( rand ) * 50 )
		
		vec:Rotate( Angle( 0, self.Owner:GetAngles().y, 0 ) )
		local pos = self.Owner:GetPos() + vec

		ent:SetAngles( ( self.Owner:GetEyeTrace().HitPos - pos ):Angle() )
		ent:SetPos( self.Owner:GetPos() )
		ent:EmitSound( Sound( "undertale/gaster_blaster/gaster_blaster_start.mp3" ), 75, 100, 1, CHAN_AUTO )
		ent:SetOwner( self.Owner )
		ent:Spawn()
		ent:SetVar( "position", pos )
	//end
end

function SWEP:SecondaryAttack()
	if( CLIENT ) then return end
	
	local entGrabbed = self:GetVar( "grabbedEnt", NULL )
	if( !entGrabbed:IsValid() ) then
		//self:SetVar( "reloadGB", 25 )
		self:SetNextPrimaryFire( CurTime() + 0.2 ) 
		self:SetNextSecondaryFire( CurTime() + 0.1 )
		
		local ent = ents.Create( "ent_undertale_bone_throw" )
		local side
		
		if( math.Round( math.Rand( 0, 1 ) ) == 0 ) then
			side = 1
		else
			side = -1
		end
		
		local pos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Right() * 40 * side

		ent:SetPos( pos )
		ent:SetAngles( ( self.Owner:GetEyeTrace().HitPos - pos ):Angle() + Angle( 90, 0, 0 ) )
		ent:EmitSound( Sound( "undertale/bone_end.wav" ), 75, 100, 1, CHAN_AUTO )
		ent:SetOwner( self.Owner )
		ent:Spawn()
		
		local phys = ent:GetPhysicsObject()
		phys:SetVelocity( ent:GetUp() * 10000 )
	else
		self:SetNextSecondaryFire( CurTime() + 0.5 )
		
		for cycles = 1, 4 do
			local ent = ents.Create( "ent_undertale_bone_throw" )
			local dir = VectorRand()
			dir:Normalize()
			
			local minb, maxb = entGrabbed:GetCollisionBounds()
			local pos = entGrabbed:GetPos() + Vector( 0, 0, maxb.z * 0.5 ) + dir * 100

			ent:SetPos( pos )
			ent:SetOwner( self.Owner )
			ent:SetAngles( ( entGrabbed:GetPos() + Vector( 0, 0, 50 ) - pos ):Angle() + Angle( 90, 0, 0 ) )
			//ent:EmitSound( Sound( "undertale/bone_end.wav" ), 75, 100, 1, CHAN_AUTO )
			ent:Spawn()
			
			local phys = ent:GetPhysicsObject()
			phys:SetVelocity( ent:GetUp() * 2000 )
		end
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape_golden.lua:
-- weapon_vape_golden.lua
-- Defines a vape with gold accent and shaded tank

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Golden Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nAn elegant, golden vape for the classy cloud chaser."

SWEP.VapeAccentColor = Vector(1,0.8,0)
SWEP.VapeTankColor = Vector(0.1,0.1,0.1)
--PATH addons/_dance/lua/weapons/wos_fortnite_dancer/shared.lua:
if SERVER then
	SWEP.Weight = 5
	SWEP.AutoSwitchTo = false
	SWEP.AutoSwitchFrom = false
end

if CLIENT then
	SWEP.PrintName = "Танці"
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
	SWEP.ViewModelFOV = 77
	SWEP.ViewModelFlip = false
	SWEP.CSMuzzleFlashes = true
	SWEP.Slot = 2
	SWEP.SlotPos = 0
	SWEP.IconLetter = "j"
end

SWEP.Category = "Other"
SWEP.Spawnable = true
SWEP.AdminSpawnable = false
SWEP.DrawWeaponInfoBox = false
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.Damage = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Damage = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.DrawWorldModel = false
SWEP.SelectedAct = "dancemoves"
--[[---------------------------------------------------------
Think
---------------------------------------------------------]]
function SWEP:Think()
end

--[[---------------------------------------------------------
Initialize
---------------------------------------------------------]]
function SWEP:Initialize()
	self:SetWeaponHoldType( "normal" )
end

--[[---------------------------------------------------------
Deploy
---------------------------------------------------------]]
function SWEP:Deploy()
	return true
end

--[[---------------------------------------------------------
PrimaryAttack
---------------------------------------------------------]]
function SWEP:PrimaryAttack()
	if SERVER then
		local owner = self:GetOwner()
		if not owner:Alive() or owner:InVehicle() then return end
		local sequence_name = wOS.Fortnite.ValidEmotes[self.SelectedAct]
		if not sequence_name then return end
		owner:SetNWString( "wOS.Fortnite.Emote", sequence_name )
		owner:SetNWBool( "wOS.Fortnite.EmoteEnabled", true )
		net.Start( "wOS.Fortnite.StartTauntCamera" )
		net.Send( owner )
	end

	self:SetNextPrimaryFire( CurTime() + 1 )
end

local Translations = {}
Translations["Best Mates"] = "bestmates"
Translations["Boneless"] = "boneless"
Translations["Breakdown"] = "breakdown"
Translations["Dance Moves"] = "dancemoves"
Translations["Disco Fever"] = "discofever"
Translations["Flying Eagle"] = "eagle"
Translations["Electro Shuffle"] = "electroshuffle"
Translations["Flippin' Incredible"] = "flippinincredible"
Translations["Flippin' Sexy"] = "flippinsexy"
Translations["Floss"] = "floss"
Translations["Fresh"] = "fresh"
Translations["Gentleman's Dab"] = "gentlemandab"
Translations["Groove Jam"] = "groovejam"
Translations["Hand Signals"] = "handsignals"
Translations["Hype"] = "hype"
Translations["Infini-Dab"] = "infinidab"
Translations["Intensity"] = "intensity"
Translations["Jubilation"] = "jubilation"
Translations["Laugh It Up"] = "laughitup"
Translations["Livin' Large"] = "livinglarge"
Translations["Orange Justice"] = "orangejustice"
Translations["Poplock"] = "poplock"
Translations["Rambunctious"] = "rambunctious"
Translations["Re-Animated"] = "reanimate"
Translations["Star Power"] = "starpower"
Translations["Swipe It"] = "swipeit"
Translations["Take the L"] = "takethel"
Translations["True Heart"] = "trueheart"
Translations["Twist"] = "twist"
Translations["Wiggle"] = "wiggle"
Translations["You're Awesome!"] = "youreawesome"
Translations["Zany"] = "zany"
function SWEP:SecondaryAttack()
	if CLIENT then
		gui.EnableScreenClicker( true )
		if IsValid( self.GMainMenu ) then self.GMainMenu:Remove() end
		self.GMainMenu = vgui.Create( "onyx.Frame" )
		self.GMainMenu:SetSize( ScrW() * 0.3, ScrH() * 0.4 )
		self.GMainMenu:Center()
		self.GMainMenu:MakePopup()
		self.GMainMenu:SetTitle( "Танці шмансі" )
		--
		self.MainMenu = vgui.Create( "onyx.ScrollPanel", self.GMainMenu )
		self.MainMenu:Dock( FILL )
		--
		for name, seq in pairs( Translations ) do
			local butt = self.MainMenu:Add( "onyx.Button" )
			butt:SetText( name )
			butt:Dock( TOP )
			butt:DockMargin( 5, 0, 2, 5 )
			butt:SetTall( 40 )
			butt.DoClick = function()
				net.Start( "wOS.Fortnite.WeaponSelect" )
				net.WriteString( seq )
				net.SendToServer()
				self.GMainMenu:Remove()
				gui.EnableScreenClicker( false )
			end
		end
	end
end

function SWEP:Reload()
	return false
end

--[[---------------------------------------------------------
OnRemove
---------------------------------------------------------]]
function SWEP:OnRemove()
	return true
end

--[[---------------------------------------------------------
Holster
---------------------------------------------------------]]
function SWEP:Holster()
	return true
end

if CLIENT then
	function SWEP:PreDrawViewModel()
		render.SetBlend( 0 )
	end

	function SWEP:DrawWorldModel()
	end

	function SWEP:DrawWeaponSelection()
	end
end
--PATH addons/__________scripts__loader/lua/entities/ariebaseboard/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_gmodentity'
ENT.PrintName = 'arie Board Base'
ENT.Author = 'Snaggle/arie'
ENT.Spawnable = false
--PATH addons/_farmer/lua/entities/ba_food/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Food";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_bitminers2/lua/entities/bm2_extention_lead/cl_init.lua:
include( "shared.lua" )
function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_extra_fuel_tank/cl_init.lua:
include( "shared.lua" )
local fuelMaterial = onyx.wimg.Simple( "https://i.imgur.com/y4deo3q.png", "noclamp smooth" )
function ENT:DrawTranslucent()
	self:DrawModel()
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 350 * 350 then
		self.cam2d3dAng = LerpAngle( 7 * FrameTime(), self.cam2d3dAng ~= nil and self.cam2d3dAng or Angle( 0, 0, 0 ), Angle( 0, LocalPlayer():GetAngles().y - 90, 90 ) )
		--Cam 2D3D for drawing infomation
		local ang = self:GetAngles()
		local pos = self:GetPos() + Vector( 0, 0, 40 ) + ang:Up() * 22
		local alpha = 1 - math.Clamp( LocalPlayer():GetPos():DistToSqr( self:GetPos() ) / ( 350 * 350 ), 0, 1 )
		local color1 = Color( 0, 0, 0, 100 * alpha )
		local color2 = Color( 0, 0, 0, 255 * alpha )
		local color3 = Color( 255, 255, 255, 255 * alpha )
		local color4 = Color( 255, 165, 0, 255 * alpha )
		cam.Start3D2D( pos, self.cam2d3dAng, 0.05 )
		draw.RoundedBox( 8, -200, -10, 410, 80, color1 )
		fuelMaterial( -196, 4, 56, 56, color4 )
		draw.RoundedBox( 4, -130, 4, 330, 52, Color( 36, 36, 36, 255 * alpha ) )
		draw.RoundedBox( 2, -128, 6, 326, 48, Color( 15, 15, 15, 255 * alpha ) )
		draw.RoundedBox( 2, -128, 6, 326 * self:GetFuelLevel() / BM2EXTRACONFIG.ExtraFuelTankSize, 48, color4 )
		draw.SimpleText( self:GetFuelLevel() .. "/" .. BM2EXTRACONFIG.ExtraFuelTankSize .. " L", onyx.FontNoScale( "Comfortaa", 40 ), 45, 30, color2, 1, 1 )
		draw.SimpleText( self:GetFuelLevel() .. "/" .. BM2EXTRACONFIG.ExtraFuelTankSize .. " L", onyx.FontNoScale( "Comfortaa", 40 ), 44, 29, color3, 1, 1 )
		cam.End3D2D()
	end
end
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_cable/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Solar Cable"
ENT.Spawnable = true
ENT.Category = "Bitminers"
function ENT:SetupDataTables()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_cable_otherend/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Solar Cable Other End"
ENT.Spawnable = false
ENT.Category = "Bitminers"
function ENT:SetupDataTables()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_panel/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Solar Panel"
ENT.Spawnable = true
ENT.Category = "Bitminers"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasLight" )
end
--PATH addons/_doctor/lua/entities/bp_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "bp_base"
ENT.Spawnable = false
ENT.Category = "Blue's Pharmaceuticals"

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 1, "owning_ent")
end
--PATH addons/_doctor/lua/entities/bp_chemical_2nap/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "2-Napththol"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 6


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_pill_bottle/cl_init.lua:
include("shared.lua")

local pillIcon = Material("blues_pharm/ui/pill.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 2)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.038)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-100, -270, 230, 65)

		draw.RoundedBox(0, -100, -270, 20, 320, Color(43, 43, 43))
 
		draw.SimpleText(BLUES_PHARMA.Medicines[self:GetRecipeID()] and BLUES_PHARMA.Medicines[self:GetRecipeID()].name or 'NONE', "BP_Chemical_Title",  -70, -272, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(pillIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-75, -240, 32, 32)

		draw.SimpleText(self:GetUsesLeft().." Uses left", "BP_Chemical_Amount",  -35, -238, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/_ballistic_shields/lua/entities/bs_hshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Heavy shield"
ENT.Category = "Ballistic shields"
ENT.Spawnable = false
ENT.DisableDuplicator = true
--PATH addons/_ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )
net.Receive( "bs_shield_info", function() LocalPlayer().bs_shieldIndex = net.ReadUInt( 16 ) end )
local Delay = 0
function bshields_materials_reload()
	for _, v in pairs( bshields.materialstoload ) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL( v[1], v[2], v[3] ) end )
	end

	bshields.hshield_webmat = surface.GetURL( bshields.config.hShieldTexture, 256, 256 )
	bshields.rshield_webmat = surface.GetURL( bshields.config.rShieldTexture, 256, 256 )
	bshields.dshield_webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
end

bshields.materialstoload = { { bshields.config.hShieldTexture, 256, 256 }, { bshields.config.rShieldTexture, 256, 256 }, { bshields.config.dShieldTexture, 256, 256 } }
hook.Add( "InitPostEntity", "bshields_init_client", function() bshields_materials_reload() end )
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH gamemodes/darkrp/entities/entities/cook_furnite/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

net.Receive('rp.CookMenu',function(len,ply)

		local pl = net.ReadEntity()
		local ent = net.ReadEntity()

	if (pl:GetPos():Distance( ent:GetPos() ) < 350) then
			local fr = vgui.Create('onyx.Frame')
				fr:SetSize(400,500)
				fr:MakePopup()
				fr:Center()

			local x,y = fr:GetSize()

			local al = vgui.Create( "DListView", fr )
				al:Dock( FILL )
				al:DockMargin(5,5,5,5)
				al:SetMultiSelect( false )
				al:AddColumn( "Назва" )
				al:AddColumn( "Ціна" )
		
				
				al:AddLine( 'Кавун', 500)
				al.OnRowSelected = function( lst, index, pnl )
					fr:SizeTo(600,500,0.5)
				end
	end
end)
--PATH addons/_drones/lua/entities/dronesrewrite_ardrone2/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "AR Drone Light"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "AR"

ENT.Model = "models/dronesrewrite/ardrone2/ardrone.mdl"

ENT.HUD_hudName = "Camera"
ENT.OverlayName = "No Overlay"

ENT.FirstPersonCam_pos = Vector(18, 0, -2)
ENT.ThirdPersonCam_distance = 50
ENT.RenderCam = false

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.PitchMin = -20
ENT.PitchMax = 20

ENT.AllowYawRestrictions = true
ENT.YawMin = -20
ENT.YawMax = 20

ENT.Sounds = {
	PropellerSound = {
		Name = "drones/ardr.wav",
		Pitch = 90,
		Level = 65,
		Volume = 0.2,
		PitchCoef = 0.015
	},

	ExplosionSound = {
		Name = "ambient/energy/spark3.wav",
		Level = 100,
		Pitch = 150
	}
}

ENT.Weight = 90

ENT.HealthAmount = 60
ENT.DefaultHealth = 60

ENT.Fuel = 40
ENT.MaxFuel = 40

ENT.Alignment = 0.3
ENT.AngOffset = 3
ENT.RotateSpeed = 5

ENT.SprintCoefficient = 1.5

ENT.AngYawDamping = 0.5

ENT.Propellers = {
	Damage = 1,
	Scale = 1.5,
	Health = 20,
	HitRange = 9,
	Model = "models/dronesrewrite/flower_propeller/flower_propeller.mdl",

	HitPitch = 255,
	HitLevel = 60,
	RandomHitSounds = { "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav" },
	RandomLoseSounds = { "physics/glass/glass_cup_break1.wav", "physics/glass/glass_cup_break2.wav" },

	LosePitch = 255,
	LoseLevel = 65,

	Info = {
		Vector(10.33, 10.33, -2.7),
		Vector(-10.33, -10.33, -2.7),
		Vector(-10.33, 10.33, -2.7),
		Vector(10.33, -10.33, -2.7)
	}
}

ENT.UseFlashlight = false
ENT.UseNightVision = false

ENT.Weapons = { ["Camera"] = { Name = "Camera" } }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
DRONES_REWRITE.CopyModule(ENT.Modules, "Nightvision")
DRONES_REWRITE.CopyModule(ENT.Modules, "Flashlight")

--PATH addons/_drones/lua/entities/dronesrewrite_artillerymain/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_barrel.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.PrintName = "Fuel Barrel"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite Tools"

ENT.AdminOnly = true

if SERVER then
	ENT.HP = 50
	
	function ENT:SpawnFunction(ply, tr, class)
		if not tr.Hit then return end

		local pos = tr.HitPos + tr.HitNormal * 16

		local ent = ents.Create(class)
		ent:SetPos(pos)
		ent:SetAngles(Angle(0, 0, 0))
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()
	    self:SetModel("models/props_c17/oildrum001_explosive.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    local phys = self:GetPhysicsObject()
	    phys:Wake()
	end

	function ENT:OnTakeDamage(dmg)
		self:TakePhysicsDamage(dmg)
		self.HP = self.HP - dmg:GetDamage()

		if self.HP <= 0 then
			self.OnTakeDamage = function() end

			local ef = EffectData()
			ef:SetOrigin(self:GetPos())
			ef:SetStart(self:GetPos())
			util.Effect("Explosion", ef)

			util.BlastDamage(self, self, self:GetPos(), 100, 100)

			self:Remove()
		end
	end

	function ENT:PhysicsCollide(data, physobj)
		if data.DeltaTime > 0.1 then
			local ent = data.HitEntity
			if IsValid(ent) and ent.IS_DRR then
				ent:SetFuel(ent.MaxFuel)
			end
		end
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_bl2_laser.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray/lray.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

		self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(12,15), owner, owner)
			ent:Ignite(0.7,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 0
			dlight.g = 0
			dlight.b = 255
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(0, 0, 255, 32)
		local xs = 32
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 24, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 24, xs, xs, color)
		
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_bomb/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_controller/cl_init.lua:
include("shared.lua")

local mat = CreateMaterial("UnlitGeneric", "GMODScreenspace", { })

function ENT:Draw()
	if not self.Rt then
		self.Rt = GetRenderTarget("ControllerDrr" .. self:EntIndex(), 1024, 1024, false)
	end

	self:DrawModel()

	cam.Start3D2D(self:LocalToWorld(Vector(-14.7, -14.4, 1.5)), self:LocalToWorldAngles(Angle(0, 90, 0)), 0.03)
		local w, h = 520, 345

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))

		local drone = self:GetNWEntity("DronesRewriteDrone")

		if drone:IsValid() then
			mat:SetTexture("$basetexture", self.Rt)
			surface.SetMaterial(mat)
			surface.DrawTexturedRect(0, 0, w, h)

			draw.SimpleText("DRONE: " .. drone:GetUnit(), "DronesRewrite_font3", 8, 8, Color(255, 255, 255, 200))
			draw.SimpleText("HEALTH: " .. drone:GetHealth(), "DronesRewrite_font3", 8, 30, Color(255, 255, 255, 200))
			draw.SimpleText("MAX DISTANCE: " .. self:GetNWInt("Distance"), "DronesRewrite_font3", 8, 52, Color(255, 255, 255, 200))
		else
			surface.SetMaterial(Material("stuff/console/broken4"))
			surface.SetDrawColor(Color(255, 255, 255, 50))
			surface.DrawTexturedRect(0, 0, w, h)

			draw.SimpleText("NO SIGNAL", "DronesRewrite_font1", w * 0.5, h * 0.5 - 16, Color(255, 255, 255, 50), TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self:LocalToWorld(Vector(-7, -7, 3))
		dlight.r = 255
		dlight.g = 255
		dlight.b = 255
		dlight.brightness = 1
		dlight.Decay = 1000
		dlight.Size = 36
		dlight.DieTime = CurTime() + 0.1
	end
end

function ENT:OpenMenu()
	local win = DRONES_REWRITE.CreateWindow(265, 110)

	local del = true
	local text = vgui.Create("DTextEntry", win)
	text:SetSize(245, 25)
	text:SetPos(10, 30)

	text.OnTextChanged = function()
		net.Start("dronesrewrite_controllerlookup")
			net.WriteEntity(self)
			net.WriteString(text:GetValue())
		net.SendToServer()
	end

	text.OnLoseFocus = function() text:RequestFocus() end
	text:RequestFocus()

	local btn = DRONES_REWRITE.CreateButton("Enter a valid drone id", 10, 70, 245, 30, win, function()
		net.Start("dronesrewrite_controldr")
			net.WriteEntity(self)
		net.SendToServer()

		win:Close()
	end)

	text.OnEnter = btn.DoClick

	btn.Think = function(btn)
		local text = self:GetNWEntity("DronesRewriteDrone"):IsValid() and "Control " .. self:GetNWEntity("DronesRewriteDrone"):GetUnit() or "Enter a valid drone id"
		if text != btn:GetText() then btn:SetText(text) end
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_flower/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "FLW 'Flower'"
ENT.PrintName = "Flower Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "FLW"

ENT.Model = "models/dronesrewrite/flower/flower.mdl"

ENT.FirstPersonCam_pos = Vector(8, 0, 2)
ENT.ThirdPersonCam_distance = 70
ENT.RenderCam = false

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.Weight = 50

ENT.Speed = 600
ENT.UpSpeed = 3000
ENT.SprintCoefficient = 3
ENT.Alignment = 0.7
ENT.RotateSpeed = 11
ENT.AngOffset = 3

ENT.HealthAmount = 50
ENT.DefaultHealth = 50

ENT.Fuel = 40
ENT.MaxFuel = 40

ENT.HUD_hudName = "Camera"

ENT.UseNightVision = false
ENT.UseFlashlight = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.Slots = {
	["Camera"] = 1
}

ENT.Sounds = {
	PropellerSound = {
		Name = "drones/ardr.wav",
		Pitch = 110,
		Level = 60,
		PitchCoef = 0.015,
		Volume = 0.2
	},

	ExplosionSound = {
		Name = "ambient/energy/spark3.wav",
		Level = 100,
		Pitch = 150
	}
}


ENT.Propellers = {
	Damage = 1,
	Health = 10,
	HitRange = 7,
	Model = "models/dronesrewrite/flower_propeller/flower_propeller.mdl",

	HitPitch = 255,
	HitLevel = 60,
	RandomHitSounds = { "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav" },
	RandomLoseSounds = { "physics/glass/glass_cup_break1.wav", "physics/glass/glass_cup_break2.wav" },

	LosePitch = 255,
	LoseLevel = 65,

	Info = {
		Vector(8.65, 8.65, 3),
		Vector(-8.65, -8.65, 3),
		Vector(-8.65, 8.65, 3),
		Vector(8.65, -8.65, 3)
	}
}

ENT.Weapons = { ["Camera"] = { Name = "Camera" } }

ENT.Modules = DRONES_REWRITE.GetSystemModules()

ENT.Modules["Nightvision"] = {
	Slot = "Camera",

	Initialize = function(drone)
		drone.UseNightVision = true
	end,

	OnRemove = function(drone)
		drone.UseNightVision = false
		drone:SetNWBool("NightVision", false)
	end,

	Think = function(drone) end
}

ENT.Modules["Flashlight"] = {
	Slot = "Camera",

	Initialize = function(drone)
		drone.UseFlashlight = true
	end,

	OnRemove = function(drone)
		drone.UseFlashlight = false
		drone:SetNWBool("Flashlight", false)
	end,

	Think = function(drone) end
}
--PATH addons/_drones/lua/entities/dronesrewrite_hellskull.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/Gibs/HGIBS.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 0, 0))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Right(), 90)
		ParticleEffectAttach("skull_trail", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end
		phys:ApplyForceCenter(self:GetForward() * 10)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			if ent:IsPlayer() and math.random(1, 8) == 1 then
				ent:TakeDamage(2)
			else
				ent:TakeDamage(20)
			end
		end
		
		ParticleEffect("skull_impact", self:GetPos(), Angle(0, 0, 0))

		self:EmitSound("npc/stalker/go_alert2a.wav", 80, 70)
		self:EmitSound("ambient/water/water_splash"..math.random(1,3)..".wav",100,100)

		self:Remove()
	end
else
	function ENT:Draw()
		if SERVER then return end

		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 50
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1000
			dlight.Size = 500
			dlight.DieTime = CurTime() + 0.3
		end

		self:DrawModel()
	end
end

--PATH addons/_drones/lua/entities/dronesrewrite_nukedr/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_nukedr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Nuclear Winter"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.AdminOnly = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "NCL"

ENT.Weight = 1000
ENT.SpawnHeight = 64

ENT.Model = "models/dronesrewrite/nukedrone/nukedrone.mdl"

ENT.HealthAmount = 400
ENT.DefaultHealth = 400

ENT.HUD_hudName = "Drones 1"
ENT.OverlayName = "Red"

ENT.FirstPersonCam_pos = Vector(16, 0, 0)
ENT.ThirdPersonCam_distance = 300
ENT.RenderCam = false

ENT.ExplosionForce = 202
ENT.ExplosionAngForce = 0.1

ENT.NoiseCoefficient = 0

ENT.HackValue = 5
ENT.ImmuneToJammer = true

ENT.Speed = 7000
ENT.UpSpeed = 35000
ENT.SprintCoefficient = 1
ENT.RotateSpeed = 3
ENT.AngOffset = 2
ENT.PitchOffset = 0
ENT.Alignment = 3.5

ENT.Fuel = 300
ENT.MaxFuel = 300
ENT.FuelReduction = 0.8

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.PitchMin = -60
ENT.PitchMax = 60

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.UseFlashlight = false

ENT.Sounds = {
	PropellerSound = {
		Name = "hl1/ambience/computalk2.wav",
		Pitch = 130,
		Level = 65,
		NoPitchChanges = true
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Pitch = 100,
		Level = 90
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
ENT.Weapons = { ["Nuclear Bomb"] = { Name = "Nuclear Bomb" } }

ENT.AI_CustomEnemyChecker = function(drone, v)
	return drone:GetPos():Distance(v:GetPos()) < 150
end

ENT.AI_AirZ = -50
ENT.AI_DistanceEnemy = 20
--PATH addons/_drones/lua/entities/dronesrewrite_rd_laser.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray/lray.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

		self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(12,15), owner, owner)
			ent:Ignite(0.7,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(255, 0, 0, 32)
		local xs = 32
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 24, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 24, xs, xs, color)
		
		self:DrawModel()
	end
end
--PATH addons/__main/lua/entities/durgz_meth/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Methamphetamine"
ENT.Nicknames = {"meth", "ice", "speed", "crystal", "tweak", "crank", "glass", "Blue Sky", "Desoxyn® Sisa"}
ENT.OverdosePhrase = {"overdosed on", "snorted too much", "took too much"}
ENT.Author = "metasync :D"
ENT.Category = "Drugs"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Information	 = "<breaking bad reference goes here>" 

--function for high visuals

ENT.TRANSITION_TIME = 5


if(CLIENT)then

	local cdw, cdw2, cdw3
	cdw2 = -1
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.8; --1 is max, 0 is nothing at all
	local STROBE_PACE = 1
	
	local function DoMeth()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNetworkedFloat( "SprintSpeed" )
		local pl = LocalPlayer();
		local pf;
		
		local tab = {}
		tab[ "$pp_colour_addr" ] = 0
		tab[ "$pp_colour_addg" ] = 0
		tab[ "$pp_colour_addb" ] = 0
		tab[ "$pp_colour_brightness" ] = 0
		tab[ "$pp_colour_contrast" ] = 1
		tab[ "$pp_colour_mulr" ] = 0
		tab[ "$pp_colour_mulg" ] = 0
		tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNetworkedFloat("durgz_meth_high_start") && pl:GetNetworkedFloat("durgz_meth_high_end") > CurTime() )then
		
			if( pl:GetNetworkedFloat("durgz_meth_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNetworkedFloat("durgz_meth_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				pl:SetDSP(7)				
				
				tab[ "$pp_colour_colour" ] =   1 - pf/0.3 //pf*4*HIGH_INTENSITY + 1
				tab[ "$pp_colour_brightness" ] = -pf/0.11
				tab[ "$pp_colour_contrast" ] = 1 + pf/1.62
				DrawMotionBlur( 0.03, pf, 0);
				DrawColorModify( tab )				
				
			elseif( pl:GetNetworkedFloat("durgz_meth_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNetworkedFloat("durgz_meth_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				pf = 1 - (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				tab[ "$pp_colour_colour" ] = 1 - pf/0.3
				tab[ "$pp_colour_brightness" ] = -pf/0.11
				tab[ "$pp_colour_contrast" ] = 1 + pf/1.62
				DrawMotionBlur( 0.03, pf, 0);
				DrawColorModify( tab ) 				
				
				pl:SetDSP(1)
				
			else
			
				
				pf = HIGH_INTENSITY;

			end
			
			
				
			if( !cdw || cdw < CurTime() )then
				cdw = CurTime() + STROBE_PACE
				cdw2 = cdw2*-1
			end
			if( cdw2 == -1 )then
				cdw3 = 2
			else
				cdw3 = 0
			end
			local ich = (cdw2*((cdw - CurTime())*(2/STROBE_PACE)))+cdw3 - 1
	
			tab[ "$pp_colour_colour" ] = 0.77*0.5//5*HIGH_INTENSITY
			tab[ "$pp_colour_brightness" ] = -0.11*0.5
			tab[ "$pp_colour_contrast" ] = 2.62*0.5
			DrawMotionBlur( 0.03, pf, 0);
			DrawColorModify( tab ) 
				
			DrawMaterialOverlay("highs/invuln_overlay_blue",  pf*ich*0.05	)	
			DrawMaterialOverlay("highs/shader3",  pf*ich*0.05	)
			DrawSharpen(pf*ich*5, 2) 

		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_meth_high", DoMeth)
end

--PATH addons/_eml/lua/entities/eml_jar/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});


function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local macidColor = Color(160, 221, 99, 255);
	local iodineColor = Color(137, 69, 54, 255);
	local waterColor = Color(133, 202, 219, 255);
	
	local potTime = "Progress: "..self:GetNWInt("progress").."% (Shake it!)";
	
	if (self:GetNWInt("status") == "inprogress") then
		potTime = "Прогрес: "..self:GetNWInt("progress").."% (Тряси це!)";
	elseif (self:GetNWInt("status") == "ready") then	
		potTime = "Ready! Use to extract!";
	end;
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.10)
			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-64, -38, 128, 96);		
		cam.End3D2D();
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.055)
			draw.SimpleTextOutlined("Кристалічний Йод", "methFont", 0, -56, Color(220, 134, 159, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, -54, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-104, -32, 204, 24);			
			surface.SetDrawColor(Color(220, 134, 159, 255));
			surface.DrawRect(-101.5, -30, math.Round((self:GetNWInt("progress")*198)/100), 20);		
			
			draw.SimpleTextOutlined("Інгрідієнти", "methFont", -101, 8, Color(220, 134, 159, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("______________", "methFont", 0, 10, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			if (self:GetNWInt("macid")==0) then
				macidColor = Color(100, 100, 100, 255);
			else
				macidColor = Color(160, 221, 99, 255);
			end;
			
			if (self:GetNWInt("iodine")==0) then
				iodineColor = Color(100, 100, 100, 255);
			else
				iodineColor = Color(137, 69, 54, 255);
			end;

			if (self:GetNWInt("water")==0) then
				waterColor = Color(100, 100, 100, 255);
			else
				waterColor = Color(133, 202, 219, 255);
			end;											
		cam.End3D2D();	
		
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.045)		
			draw.SimpleTextOutlined("Соляна Кислота ("..self:GetNWInt("macid")..")", "methFont", -121, 44, macidColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Рідкий Йод ("..self:GetNWInt("iodine")..")", "methFont", -121, 74, iodineColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));	
			draw.SimpleTextOutlined("Вода ("..self:GetNWInt("water")..")", "methFont", -121, 104, waterColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));			
		cam.End3D2D();			
		cam.Start3D2D(pos + ang:Up()*5, ang, 0.035)		
			draw.SimpleTextOutlined(potTime, "methFont", -152, -32, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();		
		
	end;
end;


--PATH addons/_eml/lua/entities/eml_spot/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Спеціальна каструля";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/____onyx_creditstore/lua/entities/ent_npc_onyx_store/cl_init.lua:
include('shared.lua')

ENT.RenderGroup = RENDERGROUP_BOTH -- to render in front of doors and etc.

function ENT:Draw()
    self:DrawModel()
    self:DrawInfo()
end

local renderDistance = 512 ^ 2
local font = 'onyx.creditstore.3d2d'
local vectorOffset = Vector(0, 0, 78)
local vectorOffsetAnimated = Vector(0, 0, 0)
local colorBG = Color(0, 0, 0, 200)
local colorAccent = onyx:Config('colors.accent')
local colorPrimary = onyx:Config('colors.primary')

surface.CreateFont(font, {
    font = 'Comfortaa Bold',
    size = 64, -- no scaling for 3d2d
    extended = true
})

function ENT:DrawInfo()
    vectorOffsetAnimated.z = math.sin(CurTime()) * 1
    
    local pos = self:GetPos() + vectorOffset + vectorOffsetAnimated
    local ang = Angle(0, EyeAngles().y - 90, 90)

    if (pos:DistToSqr(LocalPlayer():GetPos()) > renderDistance) then
        return
    end

    cam.Start3D2D(pos, ang, .05)
        surface.SetFont(font)
        local text = onyx.creditstore:GetOptionValue('npc_label')
        local textw, texth = surface.GetTextSize(text)
        local margin = 20
        local boxw, boxh = textw + margin * 2, texth + margin * 2
        local o = 3

        -- draw.RoundedBox(16, -boxw * .5, -boxh * .5, boxw, boxh, colorBG)
        draw.RoundedBox(16, -boxw * .5, -boxh * .5, boxw, boxh, colorAccent)
        draw.RoundedBox(16, -boxw * .5 + o, -boxh * .5 + o, boxw - o * 2, boxh - o * 2, colorPrimary)
        draw.SimpleText(text, font, 2, 2, color_black, 1, 1)
        draw.SimpleText(text, font, 0, 0, color_white, 1, 1)
    cam.End3D2D()
end
--PATH gamemodes/darkrp/entities/entities/ent_skup/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()
    onyx.npc.label( self, 'Валютчик' )
end
--PATH gamemodes/darkrp/entities/entities/ent_textscreen/shared.lua:

-----------------------------------------------------
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Textscreen"
ENT.Author = "SammyServers"
ENT.Spawnable = false
ENT.AdminSpawnable = false

for i = 1, 3 do
	onyx.netvar:Register('Font' .. i, {
		type = TYPE_STRING,
		public = true
	})

	onyx.netvar:Register('Text' .. i, {
		type = TYPE_STRING,
		public = true
	})

	onyx.netvar:Register('size' .. i, {
		type = TYPE_NUMBER,
		bits = 9,
		unsigned = true,
		public = true
	})

	onyx.netvar:Register('r' .. i, {
		type = TYPE_NUMBER,
		bits = 9,
		unsigned = true,
		public = true
	})

	onyx.netvar:Register('g' .. i, {
		type = TYPE_NUMBER,
		bits = 9,
		unsigned = true,
		public = true
	})

	onyx.netvar:Register('b' .. i, {
		type = TYPE_NUMBER,
		bits = 9,
		unsigned = true,
		public = true
	})

	onyx.netvar:Register('a' .. i, {
		type = TYPE_NUMBER,
		bits = 9,
		unsigned = true,
		public = true
	})
end
--PATH addons/__main/lua/entities/ent_undertale_gaster_blaster.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Editable		= true
ENT.PrintName		= "Undertale Gaster Blaster"
ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false

local modelAvailible = true

function ENT:Initialize()
	if( SERVER ) then
		local model = "models/evangelos/undertale/gasterblaster.mdl"
		if( !util.IsValidModel( model ) ) then model = "models/Gibs/HGIBS.mdl" modelAvailible = false end
		
		self:SetModel( model )
		self:SetTrigger( true )
		//self.Entity:PhysicsInit(SOLID_BBOX)
		//self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
		//self.Entity:SetSolid(SOLID_BBOX)
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		
		self:SetVar( "open", CurTime() + 0.75 )
		self:SetVar( "CurTime", math.Rand( 0, 60 ) )
		
		self:ManipulateBoneAngles( 0, Angle( 0, 0, -30 ) )
		
		local phys = self:GetPhysicsObject()
		if( IsValid( phys ) ) then
			phys:Wake()
		end
		
		util.AddNetworkString( "gaster_blaster_shooting" )

		timer.Simple(5,function() self:Remove() end)
	end
	
	if( CLIENT ) then
		self:SetVar( "shootEffect", 0 )
	end
end

function ENT:PhysicsUpdate()
	if( SERVER ) then
		local pos = self:GetVar( "position", NULL )
		local dist = pos:Distance( self:GetPos() )
		
		if( self:GetVar( "distance", NULL ) == NULL ) then
			self:SetVar( "distance", dist )
			self:SetVar( "scale", self:GetModelScale() )
		end
		
		local scale = self:GetVar( "scale", NULL )
		local saveDist = self:GetVar( "distance" )
		local curtime = CurTime() - self:GetVar( "CurTime", NULL )
		local vec = Vector( math.cos( curtime ), math.sin( curtime ), math.sin( curtime ) * 0.5 )
		
		local numb = ( CurTime() - self:GetVar( "open", NULL ) ) * 6
		
		if( numb < 3 ) then
			self:SetPos( self:GetPos() + ( pos - self:GetPos() ) / 10 + vec * math.max( 0.5, dist / 30 ) )
		else
			if( numb > 10 ) then
				self:Remove()
			end
			self:SetPos( self:GetPos() - self:GetForward() * ( dist / 10 + 0.1 ) )
		end
		
		if( dist < 15 ) then
			local value = math.sin( math.max( 0, math.min( 2, numb ) ) ) * 1.1

			if( numb > 0 ) then
			
				if( self:GetVar( "shoot", NULL ) == NULL ) then
					self:SetVar( "shoot", true )
					
					self:EmitSound( "undertale/gaster_blaster/gaster_blaster_end.mp3", 75, 100, 1, CHAN_AUTO )
					
					local tr = util.TraceHull( {
						start = self:GetPos(),
						endpos = self:GetPos() + self:GetForward() * 10000,
						filter = function( ent )
							if ent == self.Owner then return end
							
							if( ent:IsValid() ) then
								ent:TakeDamage( 25, self.Owner, self )
								if( ent:IsValid() ) then
									return false
								end
							end
						end,
						mins = Vector( -20, -20, -20 ),
						maxs = Vector( 20, 20, 20 ),
						mask = MASK_SHOT_HULL
					} )
					
					net.Start( "gaster_blaster_shooting" )
					net.WriteEntity( self )
					net.Broadcast()
				end
				
				self:ManipulateBoneScale( 2, Vector( 0, 0, 0 ) )
				self:ManipulateBoneAngles( 1, Angle( 180, 0, 0 ) )
				self:ManipulateBonePosition( 1, Vector( 9, 8, -6 ) )

				self:ManipulateBoneAngles( 0, Angle( 0, 0, -30 ) * value + Angle( 0, 0, -30 ) )
				self:ManipulateBoneAngles( 3, Angle( 0, 0, -50 ) * value )
				self:ManipulateBoneAngles( 4, Angle( 0, 0, -40 ) * value )
				self:ManipulateBoneAngles( 5, Angle( 0, 0, -40 ) * value )

				self:ManipulateBonePosition( 4, Vector( -10, 0, -20 ) * value )
				self:ManipulateBonePosition( 5, Vector( 10, 0, -20 ) * value )
				self:GetPhysicsObject():Wake()
				if( modelAvailible ) then
					self:SetModelScale( scale )
				else
					self:SetModelScale( scale * 5 )
				end
			end
		else
			if( modelAvailible ) then
				self:SetModelScale( scale * math.max( 0, math.min( 1, ( saveDist - dist ) / saveDist ), 0 ) )
			else
				self:SetModelScale( scale * math.max( 0, math.min( 1, ( saveDist - dist ) / saveDist ), 0 ) * 5 )
			end
		end
	end
end

net.Receive( "gaster_blaster_shooting", function()
	local read = net.ReadEntity()
	if IsValid(read) then
		read:SetVar( "shootEffect", CurTime() )
	end
end )

function ENT:Draw()
	
	self:DrawModel()
	
	if( self:GetVar( "shootEffect", NULL ) > 0 ) then
		numb = CurTime() - self:GetVar( "shootEffect", NULL ) 
		if( numb > 1 ) then
			self:SetVar( "shootEffect", 0 )
		end
		
		local tr = util.TraceLine( {
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 10000,
			filter = function( ent ) if ( ent:GetClass() == "prop_physics" ) then return true end end
		} )
		
		render.SetMaterial( Material( "lights/white" ) )
		
		local size = math.max( 0, math.min( 1, math.sin( numb * 5 ) * 1.4 ) )
		local pos = self:GetPos() - self:GetUp() * 20 - self:GetForward() * 10
		local dir = tr.HitPos - pos
		dir:Normalize()
		
		local length = 25
		
		for i = 1, 5 do
			local forw = ( 17 + i * ( length / 5 ) )
			render.DrawBeam( pos + dir * ( forw - ( length / 5 ) ), pos + dir * forw, ( 15 + 3 * i ) * size, 1, 1, Color( 255, 255, 255, 255 ) ) 
		end
		
		render.DrawBeam( pos + dir * ( 16 + length ), tr.HitPos, 30 * size, 1, 1, Color( 255, 255, 255, 255 ) )
	end
end
--PATH gamemodes/darkrp/entities/entities/grover_lamp/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Сектант Жертвоприношення"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "Сектанти"

function ENT:SetupDataTables()
	self:NetworkVar('Int', 0, 'Stage')
	self:NetworkVar('Entity', 1, 'owning_ent')


	self:SetNWInt('Health',500)
	self:SetNWBool('IsOn',false)
end
--PATH addons/_drones/lua/entities/item_drr_rgun.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Railgun Stings"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 30
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_rail"

--PATH addons/lvs_base-main/lua/entities/lvs_base/cl_effects.lua:

function ENT:StartWindSounds()
	if not LVS.ShowEffects then return end

	self:StopWindSounds()

	if LocalPlayer():lvsGetVehicle() ~= self then return end

	local EntTable = self:GetTable()

	EntTable._WindSFX = CreateSound( self, "LVS.Physics.Wind" )
	EntTable._WindSFX:PlayEx(0,100)

	EntTable._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
	EntTable._WaterSFX:PlayEx(0,100)
end

function ENT:StopWindSounds()
	local EntTable = self:GetTable()

	if EntTable._WindSFX then
		EntTable._WindSFX:Stop()
		EntTable._WindSFX = nil
	end

	if EntTable._WaterSFX then
		EntTable._WaterSFX:Stop()
		EntTable._WaterSFX = nil
	end
end

ENT.DustEffectSurfaces = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
}

ENT.GroundEffectsMultiplier = 1

function ENT:DoVehicleFX()
	local EntTable = self:GetTable()

	if EntTable.GroundEffectsMultiplier <= 0 or not LVS.ShowEffects then self:StopWindSounds() return end

	local Vel = self:GetVelocity():Length() * EntTable.GroundEffectsMultiplier

	if EntTable._WindSFX then EntTable._WindSFX:ChangeVolume( math.Clamp( (Vel - 1200) / 2800,0,1 ), 0.25 ) end

	if Vel < 1500 then
		if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end

		return
	end

	if (EntTable.nextFX or 0) < CurTime() then
		EntTable.nextFX = CurTime() + 0.05

		local LCenter = self:OBBCenter()
		LCenter.z = self:OBBMins().z

		local CenterPos = self:LocalToWorld( LCenter )

		local trace = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
		} )

		local traceWater = util.TraceLine( {
			start = CenterPos + Vector(0,0,25),
			endpos = CenterPos - Vector(0,0,450),
			filter = self:GetCrosshairFilterEnts(),
			mask = MASK_WATER,
		} )

		if EntTable._WaterSFX then EntTable._WaterSFX:ChangePitch( math.Clamp((Vel / 1000) * 50,80,150), 0.5 ) end

		if traceWater.Hit and trace.HitPos.z < traceWater.HitPos.z then 
			local effectdata = EffectData()
				effectdata:SetOrigin( traceWater.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_water", effectdata )

			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 1 - math.Clamp(traceWater.Fraction,0,1), 0.5 ) end
		else
			if EntTable._WaterSFX then EntTable._WaterSFX:ChangeVolume( 0, 0.25 ) end
		end

		if trace.Hit and EntTable.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] then
			local effectdata = EffectData()
				effectdata:SetOrigin( trace.HitPos )
				effectdata:SetEntity( self )
			util.Effect( "lvs_physics_dust", effectdata )
		end
	end
end

function ENT:GetParticleEmitter( Pos )
	local EntTable = self:GetTable()

	local T = CurTime()

	if IsValid( EntTable.Emitter ) and (EntTable.EmitterTime or 0) > T then
		return EntTable.Emitter
	end

	self:StopEmitter()

	EntTable.Emitter = ParticleEmitter( Pos, false )
	EntTable.EmitterTime = T + 2

	return EntTable.Emitter
end

function ENT:StopEmitter()
	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end
end
--PATH addons/lvs_base-main/lua/entities/lvs_base_gunner/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseGunner"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT.LVS_GUNNER = true
ENT.VectorNull = Vector(0,0,0)

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )

	self:NetworkVar( "Int", 0, "PodIndex")
	self:NetworkVar( "Int", 1, "NWAmmo")
	self:NetworkVar( "Int", 2, "SelectedWeapon" )

	self:NetworkVar( "Float", 0, "NWHeat" )

	self:NetworkVar( "Bool", 0, "NWOverheated" )

	self:NetworkVar( "Vector", 0, "NWAimVector" )

	if SERVER then
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )
	end
end

function ENT:UnlockAimVector()
	self._AimVectorUnlocked = true
end

function ENT:LockAimVector()
	self._AimVectorUnlocked = nil
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAI()
	if IsValid( self:GetDriver() ) then return false end

	local veh = self:GetVehicle()

	if not IsValid( veh ) then return false end

	return veh:GetAIGunners()
end

function ENT:GetAITEAM()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return 0 end

	return Base:GetAITEAM()
end

function ENT:GetVehicle()
	local Pod = self:GetParent()

	if not IsValid( Pod ) then return NULL end

	return Pod:GetParent()
end

function ENT:HasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	return istable( Base.WEAPONS[ self:GetPodIndex() ][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	local weapon = Base.WEAPONS[ self:GetPodIndex() ][ ID ]

	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()

	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {}, SelectedID end

	local CurWeapon = Base.WEAPONS[ self:GetPodIndex() ][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

function ENT:GetCrosshairFilterEnts()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {} end

	return Base:GetCrosshairFilterEnts()
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetVehicleType()
	return "LBaseGunner"
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_hud.lua:

include("cl_optics.lua")
include("cl_hud_speedometer.lua")

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )
local zoom_switch = 0
local zoom_blinder = 0
local TargetZoom = 0

ENT.ZoomInSound = "weapons/sniper/sniper_zoomin.wav"
ENT.ZoomOutSound =  "weapons/sniper/sniper_zoomout.wav"

function ENT:GetZoom()
	return TargetZoom
end

function ENT:PaintZoom( X, Y, ply )
	TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	if self.OpticsEnable then
		if self:GetOpticsEnabled() then
			if zoom_switch ~= TargetZoom then
				zoom_switch = TargetZoom

				zoom_blinder = 1

				if TargetZoom == 1 then
					surface.PlaySound( self.ZoomInSound )
				else
					surface.PlaySound( self.ZoomOutSound )
				end
			end

			zoom_blinder = zoom_blinder - zoom_blinder * RealFrameTime() * 5

			surface.SetDrawColor( Color(0,0,0,255 * zoom_blinder) )
			surface.DrawRect( 0, 0, X, Y )

			self.ZoomFov = self.OpticsFov
		else
			self.ZoomFov = nil
		end
	end

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )
ENT.IconFuel = Material( "lvs/fuel.png" )

local WaveScale = 0
local WaveMaterial = Material( "effects/select_ring" )
local oldThrottleActive = false
local oldReverse = false
local oldGear = -1

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	self:DrawDeveloperInfo()

	local EntTable = self:GetTable()

	local T = CurTime()

	if (EntTable._nextRefreshVel or 0) < T then
		EntTable._nextRefreshVel = T + 0.1
		EntTable._refreshVel = self:GetVelocity():Length()
	end

	local kmh = math.Round( (EntTable._refreshVel or 0) * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Throttle = self:GetThrottle()
	local Col = Throttle <= 1 and color_white or Color(0,0,0,255)
	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	local fueltank = self:GetFuelTank()

	if IsValid( fueltank ) and fueltank:GetFuel() <= 0 then
		surface.SetMaterial( EntTable.IconFuel )
	else
		surface.SetMaterial( EntTable.IconEngine )
	end

	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		oldThrottleActive = false
	
		local Reverse = self:GetReverse()

		if oldReverse ~= Reverse then
			oldReverse = Reverse

			WaveScale = 1
		end

		local IsManual = self:IsManualTransmission()
		local Gear = self:GetGear()

		if oldGear ~= Gear then
			oldGear = Gear

			WaveScale = 1
		end

		if WaveScale > 0 then
			WaveScale = math.max( WaveScale - RealFrameTime() * 2, 0 )

			local WaveRadius = (1 - WaveScale) * H * 1.5

			surface.SetDrawColor( 0, 127, 255, 255 * WaveScale ^ 2 )
			surface.SetMaterial( WaveMaterial )

			surface.DrawTexturedRectRotated( hX, hY, WaveRadius, WaveRadius, 0 )

			if not Reverse and not IsManual then
				draw.SimpleText( "D" , "LVS_FONT",  hX, hY, Color(0,0,0,math.min(800 * WaveScale ^ 2,255)), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end

		if IsManual then
			draw.SimpleText( (Reverse and -1 or 1) * Gear , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			if Reverse then
				draw.SimpleText( "R" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
	end

	self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )

	if Throttle > 1 then
		draw.SimpleText( "+"..math.Round((Throttle - 1) * 100,0).."%" , "LVS_FONT",  hX, hY, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
end

LVS:AddHudEditor( "CarMenu",  ScrW() - 690, ScrH() - 85,  220, 75, 220, 75, "CAR MENU",
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintCarMenu then return end
		vehicle:LVSHudPaintCarMenu( X, Y, W, H, ScrX, ScrY, ply )
	end
)
local function DrawTexturedRect( X, Y, size, selected )
	local oz = 2

	surface.SetDrawColor( 0, 0, 0, 150 )
	surface.DrawTexturedRectRotated( X + oz, Y + oz, size, size, 0 )

	if IsColor( selected ) then
		surface.SetDrawColor( selected.r, selected.g, selected.b, selected.a )
	else
		if selected then
			surface.SetDrawColor( 255, 255, 255, 255 )
		else
			surface.SetDrawColor( 150, 150, 150, 150 )
		end
	end

	surface.DrawTexturedRectRotated( X, Y, size, size, 0 )
end

ENT.CarMenuSiren = Material( "lvs/carmenu_siren.png" )
ENT.CarMenuHighbeam = Material( "lvs/carmenu_highbeam.png" )
ENT.CarMenuLowbeam = Material( "lvs/carmenu_lowbeam.png" )
ENT.CarMenuDisable = Material( "lvs/carmenu_cross.png" )
ENT.CarMenuFog = Material( "lvs/carmenu_fog.png" )
ENT.CarMenuHazard = Material( "lvs/carmenu_hazard.png" )
ENT.CarMenuLeft = Material( "lvs/carmenu_turnleft.png" )
ENT.CarMenuRight = Material( "lvs/carmenu_turnRight.png" )

function ENT:LVSHudPaintCarMenu( X, Y, w, h, ScrX, ScrY, ply )
	if self:GetDriver() ~= ply then return end

	local MenuOpen = ply:lvsKeyDown( "CAR_MENU" ) and self:HasTurnSignals()

	local EntTable = self:GetTable()

	if MenuOpen then
		if ply:lvsKeyDown( "CAR_BRAKE" ) then
			EntTable._SelectedMode = 3
		end
		if ply:lvsKeyDown( "CAR_THROTTLE" ) then
			EntTable._SelectedMode = 0
		end
		if ply:lvsKeyDown( "CAR_STEER_LEFT" ) then
			EntTable._SelectedMode = 1
		end
		if ply:lvsKeyDown( "CAR_STEER_RIGHT" ) then
			EntTable._SelectedMode = 2
		end

		if EntTable._oldSelectedMode ~= EntTable._SelectedMode then
			EntTable._oldSelectedMode = EntTable._SelectedMode

			self:EmitSound("buttons/lightswitch2.wav",75,120,0.25)
		end
	else
		if EntTable._oldSelectedMode and isnumber( EntTable._SelectedMode ) then
			self:EmitSound("buttons/lightswitch2.wav",75,100,0.25)

			net.Start( "lvs_car_turnsignal" )
				net.WriteInt( EntTable._SelectedMode, 4 )
			net.SendToServer()

			EntTable._SelectedMode = 0
			EntTable._oldSelectedMode = nil
		end

		local size = 32
		local dist = 5

		local cX = X + w * 0.5
		local cY = Y + h - size * 0.5 - dist

		local LightsHandler = self:GetLightsHandler()

		if IsValid( LightsHandler ) then
			if LightsHandler:GetActive() then
				if LightsHandler:GetHighActive() then
					surface.SetMaterial( self.CarMenuHighbeam )
					DrawTexturedRect( cX, cY, size, Color(0,255,255,255) )
				else
					surface.SetMaterial( self.CarMenuLowbeam )
					DrawTexturedRect( cX, cY, size, Color(0,255,0,255) )
				end
			end

			if LightsHandler:GetFogActive() then
				surface.SetMaterial( self.CarMenuFog )
				DrawTexturedRect( cX, cY - (size + dist), size, Color(255,100,0,255) )
			end
		end

		local TurnMode = self:GetTurnMode()

		if TurnMode == 0 then return end

		local Alpha = self:GetTurnFlasher() and 255 or 0

		if TurnMode == 1 or TurnMode == 3 then
			surface.SetMaterial( EntTable.CarMenuLeft )
			DrawTexturedRect( cX - (size + dist), cY, size, Color(0,255,157,Alpha) )
		end

		if TurnMode == 2 or TurnMode == 3 then
			surface.SetMaterial( EntTable.CarMenuRight )
			DrawTexturedRect( cX + (size + dist), cY, size, Color(0,255,157,Alpha) )
		end

		return
	end

	local SelectedThing = EntTable._SelectedMode or 0

	local size = 32
	local dist = 5

	local cX = X + w * 0.5
	local cY = Y + h - size * 0.5 - dist

	surface.SetMaterial( EntTable.CarMenuDisable )
	DrawTexturedRect( cX, cY - (size + dist), size, SelectedThing == 0 )

	surface.SetMaterial( EntTable.CarMenuLeft )
	DrawTexturedRect( cX - (size + dist), cY, size, SelectedThing == 1 )

	surface.SetMaterial( EntTable.CarMenuRight)
	DrawTexturedRect( cX + (size + dist), cY, size, SelectedThing == 2 )

	surface.SetMaterial( EntTable.CarMenuHazard )
	DrawTexturedRect( cX, cY, size, SelectedThing == 3 )
end

local smXX = 0
function ENT:DrawDeveloperInfo()
	if not LVS.DeveloperEnabled then return end
	local SizeX = 400
	local SizeY = 200
	local X = ScrW() - SizeX - 100
	local Y = 100

	surface.SetDrawColor(0,0,0,200)
	surface.DrawRect(X,Y,SizeX,SizeY)

	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawLine( X, Y, X, Y + SizeY )
	surface.DrawLine( X, Y + SizeY, X + SizeX, Y + SizeY )

	local EngineCurve = self.EngineCurve
	local EngineTorque = self.EngineTorque

	local Turbo = self:GetTurbo()
	if IsValid( Turbo ) then
		EngineCurve = EngineCurve + Turbo:GetEngineCurve()
		EngineTorque = EngineTorque + Turbo:GetEngineTorque()
	end

	local Compressor = self:GetCompressor()
	if IsValid( Compressor ) then
		EngineCurve = EngineCurve + Compressor:GetEngineCurve()
		EngineTorque = EngineTorque + Compressor:GetEngineTorque()
	end

	local torque = EngineTorque / 5
	local target = self.MaxVelocity
	local boost = (target / self.TransGears) * 0.5

	if self:GetReverse() then
		target = self.MaxVelocityReverse
		boost = (target / self.TransGearsReverse) * 0.5
	end

	local power = target * EngineCurve

	surface.SetDrawColor( 0, 255, 255, 255 )

	local steps = target / SizeX * 2

	local BoostMul = math.max( self.EngineCurveBoostLow, 0 )
	local BoostStart = 1 + BoostMul

	if self:GetEngineActive() then
		local throttle = self:GetThrottle()

		for a = 0, target, steps do
			local curRPM = a
			local nextRPM = a + steps

			local powerCurve1 = (power + math.max( target - power,0) - math.max(curRPM - power,0)) / target
			local powerCurve2 = (power + math.max( target - power,0) - math.max(nextRPM - power,0)) / target

			local TorqueBoost1 = BoostStart - (math.min( math.max( curRPM - boost, 0 ), boost) / boost) * BoostMul
			local TorqueBoost2 = BoostStart - (math.min( math.max( nextRPM - boost, 0 ), boost) / boost) * BoostMul

			local X1 = X + (curRPM / target) * SizeX
			local Y1 = Y + SizeY - powerCurve1 * TorqueBoost1 * torque * throttle

			local X2 = X + (nextRPM / target) * SizeX
			local Y2 = Y + SizeY - powerCurve2 * TorqueBoost2 * torque * throttle

			surface.DrawLine( X1, Y1, X2, Y2 )
		end

		smXX = smXX + ((self:GetVelocity():Length() / target) * SizeX - smXX) * RealFrameTime() * 5
		local XX = X + smXX
		surface.SetDrawColor( 255, 0, 0, 255 )
		surface.DrawLine( XX, Y - 10, XX, Y + SizeY + 10 )
	else
		for a = 0, target, steps do
			local curRPM = a
			local nextRPM = a + steps

			local powerCurve1 = (power + math.max( target - power,0) - math.max(curRPM - power,0)) / target
			local powerCurve2 = (power + math.max( target - power,0) - math.max(nextRPM - power,0)) / target

			local TorqueBoost1 = BoostStart - (math.min( math.max( curRPM - boost, 0 ), boost) / boost) * BoostMul
			local TorqueBoost2 = BoostStart - (math.min( math.max( nextRPM - boost, 0 ), boost) / boost) * BoostMul

			local X1 = X + (curRPM / target) * SizeX
			local Y1 = Y + SizeY - powerCurve1 * TorqueBoost1 * torque

			local X2 = X + (nextRPM / target) * SizeX
			local Y2 = Y + SizeY - powerCurve2 * TorqueBoost2 * torque

			surface.DrawLine( X1, Y1, X2, Y2 )
		end
	end

	draw.SimpleTextOutlined( "velocity u/s", "DermaDefault", X + SizeX + 15, Y + SizeY, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, color_black )
	draw.SimpleTextOutlined( self:GetReverse() and "torque@wheel [reverse]" or "torque@wheel", "DermaDefault", X, Y - 15, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, color_black )

	surface.SetDrawColor( 255, 255, 255, 255 )

	for a = 0, target, 250 do
		local X1 = X + (a / target) * SizeX
		local Y1 = Y + SizeY

		surface.DrawLine( X1, Y1 + 5, X1, Y1 - 5 )

		draw.SimpleTextOutlined( a, "DermaDefault", X1, Y1 + 10, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black )
	end

	for a = 0, SizeY, 20 do
		local X1 = X
		local Y1 = Y + SizeY - a

		surface.DrawLine( X1 - 5, Y1, X1 + 5, Y1 )

		draw.SimpleTextOutlined( a * 5, "DermaDefault", X1 - 10, Y1, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER, 1, color_black )
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_bike_wheeldrive/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "[LVS] Wheeldrive Bike"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MaxVelocity = 1250
ENT.MaxVelocityReverse = 100

ENT.EngineCurve = 0.4
ENT.EngineTorque = 250

ENT.TransGears = 4
ENT.TransGearsReverse = 1

ENT.PhysicsMass = 250
ENT.PhysicsWeightScale = 0.5
ENT.PhysicsInertia = Vector(400,400,200)

ENT.ForceAngleMultiplier = 0.5

ENT.PhysicsDampingSpeed = 500
ENT.PhysicsDampingForward = true
ENT.PhysicsDampingReverse = false

ENT.PhysicsRollMul = 1
ENT.PhysicsDampingRollMul = 1
ENT.PhysicsWheelGyroMul = 1
ENT.PhysicsWheelGyroSpeed = 400

ENT.WheelPhysicsMass = 250
ENT.WheelPhysicsInertia = Vector(5,4,5)

ENT.WheelSideForce = 800
ENT.WheelDownForce = 1000

ENT.KickStarter = true
ENT.KickStarterSound = "lvs/vehicles/bmw_r75/moped_crank.wav"
ENT.KickStarterMinAttempts = 2
ENT.KickStarterMaxAttempts = 4
ENT.KickStarterAttemptsInSeconds = 5
ENT.KickStarterMinDelay = 0.5

ENT.FastSteerAngleClamp = 15

function ENT:ShouldPutFootDown()
	return self:GetNWHandBrake() or self:GetVelocity():Length() < 20
end

function ENT:CalcMainActivity( ply )
	if ply ~= self:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
		
		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "drive_airboat" )

	return ply.CalcIdeal, ply.CalcSeqOverride
end

function ENT:GetWheelUp()
	return self:GetUp() * math.Clamp( 1 + math.abs( self:GetSteer() / 10 ), 1, 1.5 )
end

function ENT:GetVehicleType()
	return "bike"
end

function ENT:GravGunPickupAllowed( ply )
	return false
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_compressor.lua:
AddCSLuaFile()

ENT.Base = "lvs_wheeldrive_engine_mod"

ENT.PrintName = "Supercharger"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

if SERVER then
	function ENT:Initialize()	
		self:SetModel("models/diggercars/dodge_charger/blower_animated.mdl")
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysWake()
	end

	function ENT:CanLink( ent )
		if not ent.AllowSuperCharger or IsValid( ent:GetCompressor() ) then return false end

		return true
	end

	local function SaveCompressor( ply, ent, data )
		if not duplicator or not duplicator.StoreEntityModifier then return end

		timer.Simple( 0.2, function()
			if not IsValid( ent ) or not isfunction( ent.AddSuperCharger ) then return end

			local compressor = ent:AddSuperCharger()
			if IsValid( compressor ) then
				if data.Curve then compressor:SetEngineCurve( data.Curve ) end
				if data.Torque then compressor:SetEngineTorque( data.Torque ) end
			end
		end )

		duplicator.StoreEntityModifier( ent, "lvsCarCompressor", data )
	end

	if duplicator and duplicator.RegisterEntityModifier then
		duplicator.RegisterEntityModifier( "lvsCarCompressor", SaveCompressor )
	end

	function ENT:OnLinked( ent )
		ent:OnSuperCharged( true )
		ent:SetCompressor( self )

		if not self.PlaySound then return end

		ent:EmitSound("lvs/equip_blower.ogg")
	end

	function ENT:OnUnLinked( ent )
		ent:OnSuperCharged( false )

		if not duplicator or not duplicator.ClearEntityModifier then return end

		duplicator.ClearEntityModifier( ent, "lvsCarCompressor" )
	end

	function ENT:OnVehicleUpdated( ent )
		if not duplicator or not duplicator.ClearEntityModifier or not duplicator.StoreEntityModifier then return end

		duplicator.ClearEntityModifier( ent, "lvsCarCompressor" )
		local data = {
			Curve = self:GetEngineCurve(),
			Torque = self:GetEngineTorque(),
		}
		duplicator.StoreEntityModifier( ent, "lvsCarCompressor", data )
	end

	return
end

function ENT:OnEngineActiveChanged( Active, soundname )
	if Active then
		self:StartSounds( soundname )
	else
		self:StopSounds()
	end
end

function ENT:StartSounds( soundname )
	if self.snd then return end

	self.snd = CreateSound( self, soundname )
	self.snd:PlayEx(0,100)
end

function ENT:StopSounds()
	if not self.snd then return end

	self.snd:Stop()
	self.snd = nil
end

function ENT:HandleSounds( vehicle, engine )
	if not self.snd then return end

	local throttle = engine:GetClutch() and 0 or vehicle:GetThrottle()
	local volume = (0.2 + math.max( math.sin( math.rad( ((engine:GetRPM() - vehicle.EngineIdleRPM) / (vehicle.EngineMaxRPM - vehicle.EngineIdleRPM)) * 90 ) ), 0 ) * 0.8) * throttle * vehicle.SuperChargerVolume
	local pitch = engine:GetRPM() / vehicle.EngineMaxRPM

	local ply = LocalPlayer()
	local doppler = vehicle:CalcDoppler( ply )

	self._smBoost = self._smBoost and self._smBoost + (volume - self._smBoost) * FrameTime() * 5 or 0

	self.snd:ChangeVolume( volume * engine:GetEngineVolume() )
	self.snd:ChangePitch( (60 + pitch * 85) * doppler )
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	local EngineActive = vehicle:GetEngineActive()

	if self._oldEnActive ~= EngineActive then
		self._oldEnActive = EngineActive

		self:OnEngineActiveChanged( EngineActive, vehicle.SuperChargerSound )
	end

	if EngineActive then
		local engine = vehicle:GetEngine()

		if not IsValid( engine ) then return end

		self:SetPoseParameter( "throttle_pedal", math.max( vehicle:GetThrottle() - (engine:GetClutch() and 1 or 0), 0 ) )
		self:InvalidateBoneCache()

		self:HandleSounds( vehicle, engine )
	end
end

function ENT:OnRemove()
	self:StopSounds()
end

function ENT:Draw( flags )
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then
		self:DrawModel( flags )

		return
	end

	if not vehicle.SuperChargerVisible then return end

	self:DrawModel( flags )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_mine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName		= "Mine"
ENT.Author		= "Blu-x92"
ENT.Information		= "Immobilize Tanks"
ENT.Category = "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

if SERVER then
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 2000) end
	function ENT:GetForce() return (self._force or 8000) end
	function ENT:GetRadius() return (self._radius or 150) end

	function ENT:SpawnFunction( ply, tr, ClassName )

		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent.Attacker = ply
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent

	end

	function ENT:Initialize()	
		self:SetModel( "models/blu/lvsmine.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON  )
		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		self:DrawShadow( false )

		self.First = true
	end

	function ENT:Use( ply )
	end

	function ENT:Detonate( Pos )
		if self.IsExploded then return end

		self.IsExploded = true

		if not isvector( Pos ) then Pos = self:GetPos() end

		local effectdata = EffectData()
		effectdata:SetOrigin( Pos )
		effectdata:SetNormal( Vector(0,0,1) )
		effectdata:SetMagnitude( 1 )
		util.Effect( "lvs_bullet_impact_explosive", effectdata, true, true )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, Vector(0,0,1), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end

	function ENT:Think()
		local PhysObj = self:GetPhysicsObject()

		if IsValid( PhysObj ) and PhysObj:IsMotionEnabled() then
			if PhysObj:IsAsleep() then
				PhysObj:EnableMotion( false )
			end
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnRemove()
	end

	function ENT:PhysicsCollide( data, PhysObj )
		local HitEnt = data.HitEntity

		if self.First then
			self.First = nil
			self.IgnoreEnt = HitEnt
		end

		if HitEnt == self.IgnoreEnt then
			if data.Speed > 60 and data.DeltaTime > 0.1 then
				self:EmitSound( "weapon.ImpactHard" )
			end

			return
		end

		PhysObj:SetVelocity( data.OurOldVelocity * 0.5 )

		if not IsValid( HitEnt ) or HitEnt:IsWorld() then 
			if data.Speed > 60 and data.DeltaTime > 0.1 then
				self:EmitSound( "weapon.ImpactHard" )
			end
			
			return
		end

		if not HitEnt:IsPlayer() and HitEnt:GetClass() ~= self:GetClass() then
			self:Detonate( data.HitPos )
		else
			if data.Speed > 60 and data.DeltaTime > 0.1 then
				self:EmitSound( "weapon.ImpactHard" )
			end
		end
	end

	function ENT:OnTakeDamage( dmginfo )
		self:Detonate()
	end
else
	function ENT:Draw( flags )
		local ply = LocalPlayer()

		if IsValid( ply ) then
			if not ply:InVehicle() then
				self:DrawModel( flags )

				return
			end

			local ViewEnt = ply:GetViewEntity()

			if IsValid( ViewEnt ) then
				ply = ViewEnt
			end
		else
			return
		end

		local OldPos = self:GetPos()

		local Dist = math.min( (ply:GetPos() - self:GetPos()):LengthSqr() / 50000, 4.5 )

		self:SetPos( self:LocalToWorld( Vector(0,0,-Dist) ) )
		self:DrawModel( flags )
		self:SetPos( OldPos )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnRemove()
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_smoke.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Smoke"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= false
ENT.AdminOnly		= false

function ENT:SetupDataTables()
	self:NetworkVar( "Bool",0, "Active" )

	self:NetworkVar( "Float",0, "Radius" )

	self:NetworkVar( "Float",1, "LifeTime" )

	if SERVER then
		self:SetLifeTime( 30 )
		self:SetRadius( 1000 )
	end
end

function ENT:GetMins()
	local Radius = self:GetRadius()

	return Vector(-Radius,-Radius,-Radius)
end

function ENT:GetMaxs()
	local Radius = self:GetRadius()

	return Vector(Radius,Radius,Radius)
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/Items/grenadeAmmo.mdl" )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )

		self.TrailEntity = util.SpriteTrail( self, 0, Color(120,120,120,120), false, 5, 40, 0.2, 1 / ( 15 + 1 ) * 0.5, "trails/smoke" )
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.RemoveTime then return true end

		if self.RemoveTime < T then
			self:Remove()
		end

		return true
	end

	function ENT:Enable()
		if self:GetActive() then return end

		self.RemoveTime = CurTime() + self:GetLifeTime()

		self:SetActive( true )

		self:EmitSound("weapons/flaregun/fire.wav", 65, 100, 0.5)

		if IsValid( self.TrailEntity ) then
			self.TrailEntity:Remove()
		end
	end

	function ENT:PhysicsCollide( data, physobj )
		self:Enable()

		if data.Speed > 60 and data.DeltaTime > 0.2 then
			local VelDif = data.OurOldVelocity:Length() - data.OurNewVelocity:Length()

			if VelDif > 200 then
				self:EmitSound( "Grenade.ImpactHard" )
			else
				self:EmitSound( "Grenade.ImpactSoft" )
			end

			physobj:SetVelocity( data.OurOldVelocity * 0.5 )
		end
	end
else
	function ENT:Draw()
		self:DrawModel()
	end

	function ENT:StartSound()
		if self.snd then return self.snd end

		self.snd = CreateSound( self, "weapons/flaregun/burn.wav" )
		self.snd:PlayEx(1,100)

		return self.snd
	end

	function ENT:Think()
		local T = CurTime()

		if not self:GetActive() then self.DieTime = T + self:GetLifeTime() return end

		local volume = ((self.DieTime or 0) - T) / self:GetLifeTime()
		local snd = self:StartSound()
		snd:ChangeVolume( volume, 0.5 )

		self.RemovedEnts = self.RemovedEnts or {}

		local plyPos = LocalPlayer():GetPos()
		local pos = self:GetPos()

		if (plyPos - pos):Length() < self:GetRadius() then
			for id, ent in pairs( LVS:GetVehicles() ) do
				LVS:GetVehicles()[ id ] = nil
				table.insert( self.RemovedEnts, ent )
			end
		else
			local Mins = self:GetMins()
			local Maxs = self:GetMaxs()

			for id, ent in pairs( LVS:GetVehicles() ) do
				local pDelta = ent:GetPos() - plyPos
				local HitPos, HitNormal, Fraction = util.IntersectRayWithOBB( plyPos, pDelta, pos, angle_zero, Mins, Maxs )

				if HitPos then
					LVS:GetVehicles()[ id ] = nil

					table.insert( self.RemovedEnts, ent )
				end
			end

			for id, ent in pairs( self.RemovedEnts ) do
				if not IsValid( ent ) then 
					self.RemovedEnts[ id ] = nil

					continue
				end

				local pDelta = ent:GetPos() - plyPos
				local HitPos, HitNormal, Fraction = util.IntersectRayWithOBB( plyPos, pDelta, pos, angle_zero, Mins, Maxs )

				if not HitPos then
					self.RemovedEnts[ id ] = nil
					table.insert( LVS:GetVehicles(), ent )
				end
			end
		end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
		util.Effect( "lvs_defence_smoke", effectdata, true, true )

		self:SetNextClientThink( T + 0.2 )

		return true
	end

	function ENT:OnRemove()
		self.RemovedEnts = self.RemovedEnts or {}

		for id, ent in pairs( self.RemovedEnts ) do
			self.RemovedEnts[ id ] = nil

			if not IsValid( ent ) then 
				continue
			end

			table.insert( LVS:GetVehicles(), ent )
		end

		if not self.snd then return end

		self.snd:Stop()
		self.snd = nil
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flaktrailer/shared.lua:

ENT.Base = "lvs_base_wheeldrive_trailer"

ENT.PrintName = "FlaK Trailer"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.VehicleCategory = "Artillery"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/flakcarriage.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 200

ENT.DSArmorIgnoreForce = 1000

ENT.ForceAngleMultiplier = 2

ENT.lvsShowInSpawner = false

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Prong" )
end

ENT.GibModels = {
	"models/blu/carriage_wheel.mdl",
	"models/blu/carriage_wheel.mdl",
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
	"models/props_c17/canisterchunk01a.mdl",
	"models/props_c17/canisterchunk01d.mdl",
	"models/blu/carriage_d1.mdl",
	"models/blu/carriage_d2.mdl",
	"models/blu/carriage_d3.mdl",
	"models/blu/carriage_d4.mdl",
	"models/blu/carriage_d5.mdl",
	"models/blu/carriage_d6.mdl",
}
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_pak40/shared.lua:

ENT.Base = "lvs_base_wheeldrive_trailer"

ENT.PrintName = "PaK 40"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.VehicleCategory = "Artillery"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/pak40.mdl"

ENT.AITEAM = 1

ENT.WheelPhysicsMass = 350
ENT.WheelPhysicsInertia = Vector(10,8,10)
ENT.WheelPhysicsTireHeight = 0 -- tire height 0 = doesnt use tires

ENT.CannonArmorPenetration = 14500

-- ballistics
ENT.ProjectileVelocityHighExplosive = 13000
ENT.ProjectileVelocityArmorPiercing = 16000

ENT.lvsShowInSpawner = false

ENT.MaxHealth = 800

ENT.DSArmorIgnoreForce = 1000

ENT.GibModels = {
	"models/blu/pak_d1.mdl",
	"models/blu/pak_d2.mdl",
	"models/blu/pak_d3.mdl",
	"models/blu/pak_d4.mdl",
	"models/blu/pak_d5.mdl",
	"models/blu/pak_d6.mdl",
	"models/blu/pak40_wheel.mdl",
	"models/blu/pak40_wheel.mdl",
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
}

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Prongs" )
	self:AddDT( "Bool", "UseHighExplosive" )
end

function ENT:CalcMainActivity( ply )
	if ply ~= self:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
		
		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_CROUCHIDLE
	ply.CalcSeqOverride = ply:LookupSequence( "cidle_knife" )

	return ply.CalcIdeal, ply.CalcSeqOverride
end

function ENT:InitWeapons()
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = true
	weapon.Ammo = 100
	weapon.Delay = 3
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.OnThink = function( ent )
		local ply = ent:GetDriver()

		if not IsValid( ply ) then return end

		local SwitchType = ply:lvsKeyDown( "CAR_SWAP_AMMO" )

		if ent._oldSwitchType ~= SwitchType then
			ent._oldSwitchType = SwitchType

			if SwitchType then
				ent:SetUseHighExplosive( not ent:GetUseHighExplosive() )
				ent:DoReloadSequence( 0 )
				ent:SetHeat( 1 )
				ent:SetOverheated( true )

				if ent:GetUseHighExplosive() then
					ent:TurretUpdateBallistics( ent.ProjectileVelocityHighExplosive )
				else
					ent:TurretUpdateBallistics( ent.ProjectileVelocityArmorPiercing )
				end
			end
		end
	end
	weapon.Attack = function( ent )
		local ID = ent:LookupAttachment( "muzzle" )

		local Muzzle = ent:GetAttachment( ID )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= Muzzle.Ang:Forward()
		bullet.Spread = Vector(0,0,0)
		bullet.EnableBallistics = true

		if ent:GetUseHighExplosive() then
			bullet.Force	= 500
			bullet.HullSize 	= 15
			bullet.Damage	= 250
			bullet.SplashDamage = 750
			bullet.SplashDamageRadius = 200
			bullet.SplashDamageEffect = "lvs_bullet_impact_explosive"
			bullet.SplashDamageType = DMG_BLAST
			bullet.Velocity = ent.ProjectileVelocityHighExplosive
		else
			bullet.Force	= ent.CannonArmorPenetration
			bullet.HullSize 	= 0
			bullet.Damage	= 1000
			bullet.Velocity = ent.ProjectileVelocityArmorPiercing
		end

		bullet.TracerName = "lvs_tracer_cannon"
		bullet.Attacker 	= ent:GetDriver()
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle", effectdata )

		ent:TakeAmmo( 1 )

		ent:DoAttackSequence()
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local ID = ent:LookupAttachment(  "muzzle" )

		local Muzzle = ent:GetAttachment( ID )

		if Muzzle then
			local traceTurret = util.TraceLine( {
				start = Muzzle.Pos,
				endpos = Muzzle.Pos + Muzzle.Ang:Forward() * 50000,
				filter = ent:GetCrosshairFilterEnts()
			} )

			local MuzzlePos2D = traceTurret.HitPos:ToScreen() 

			if ent:GetUseHighExplosive() then
				ent:PaintCrosshairSquare( MuzzlePos2D, COLOR_WHITE )
			else
				ent:PaintCrosshairOuter( MuzzlePos2D, COLOR_WHITE )
			end

			ent:LVSPaintHitMarker( MuzzlePos2D )
		end
	end
	self:AddWeapon( weapon )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/sh_turret.lua:
ENT.TurretPodIndex = 1 -- 1 = driver

ENT.TurretAimRate = 25

ENT.TurretRotationSound = "vehicles/tank_turret_loop1.wav"
ENT.TurretRotationSoundDamaged = "lvs/turret_damaged_loop.wav"

ENT.TurretFakeBarrel = false
ENT.TurretFakeBarrelRotationCenter = vector_origin

ENT.TurretPitchPoseParameterName = "turret_pitch"
ENT.TurretPitchMin = -15
ENT.TurretPitchMax = 15
ENT.TurretPitchMul = 1
ENT.TurretPitchOffset = 0

ENT.TurretYawPoseParameterName = "turret_yaw"
ENT.TurretYawMul = 1
ENT.TurretYawOffset = 0

ENT.TurretRateDestroyedMul = 0.25

function ENT:TurretSystemDT()
	self:AddDT( "Bool", "NWTurretEnabled" )
	self:AddDT( "Bool", "NWTurretDestroyed" )
	self:AddDT( "Bool", "TurretDamaged" )
	self:AddDT( "Entity", "NWTurretArmor" )

	if SERVER then
		self:SetTurretEnabled( true )
		self:SetTurretPitch( self.TurretPitchOffset )
		self:SetTurretYaw( self.TurretYawOffset )
	end
end

function ENT:SetTurretDestroyed( new )
	self:SetNWTurretDestroyed( new )
	self:SetTurretDamaged( new )
end

function ENT:GetTurretDestroyed( new )
	return self:GetNWTurretDestroyed()
end

function ENT:SetTurretEnabled( new )
	self:SetNWTurretEnabled( new )
end

function ENT:SetTurretArmor( TurretArmor )
	self:SetNWTurretArmor( TurretArmor )

	if CLIENT then return end

	TurretArmor.OnDestroyed = function( ent, dmginfo )
		if not IsValid( self ) then return end

		self:SetTurretDestroyed( true )
	end

	TurretArmor.OnRepaired = function( ent )
		if not IsValid( self ) then return end

		self:SetTurretDestroyed( false )
	end

	TurretArmor.OnHealthChanged = function( ent, dmginfo, old, new )
		if new >= old then return end

		self:SetTurretDamaged( true )
	end
end

function ENT:GetTurretArmor()
	return self:GetNWTurretArmor()
end
function ENT:GetTurretEnabled()
	if self:GetTurretDestroyed() then return false end

	return self:GetNWTurretEnabled()
end

function ENT:SetTurretPitch( num )
	self._turretPitch = num
end

function ENT:SetTurretYaw( num )
	self._turretYaw = num
end

function ENT:GetTurretPitch()
	return (self._turretPitch or self.TurretPitchOffset)
end

function ENT:GetTurretYaw()
	return (self._turretYaw or self.TurretYawOffset)
end

if CLIENT then
	function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
		self:CalcTurret()
	end

	function ENT:CalcTurret()
		local pod = self:GetPassengerSeat( self.TurretPodIndex )

		if not IsValid( pod ) then return end

		local plyL = LocalPlayer()
		local ply = pod:GetDriver()

		if ply ~= plyL then return end

		self:AimTurret()
	end

	net.Receive( "lvs_turret_sync_other", function( len )
		local veh = net.ReadEntity()

		if not IsValid( veh ) then return end

		local Pitch = net.ReadFloat()
		local Yaw = net.ReadFloat()

		if isfunction( veh.SetTurretPitch ) then
			veh:SetTurretPitch( Pitch )
		end

		if isfunction( veh.SetTurretYaw ) then
			veh:SetTurretYaw( Yaw )
		end
	end )
else
	util.AddNetworkString( "lvs_turret_sync_other" )

	function ENT:OnPassengerChanged( Old, New, PodIndex )
		if PodIndex ~= self.TurretPodIndex then return end

		if IsValid( New ) then return end

		net.Start( "lvs_turret_sync_other" )
			net.WriteEntity( self )
			net.WriteFloat( self:GetTurretPitch() )
			net.WriteFloat( self:GetTurretYaw() )
		net.Broadcast()
	end

	function ENT:CalcTurretSound( Pitch, Yaw, AimRate )
		local DeltaPitch = Pitch - self:GetTurretPitch()
		local DeltaYaw = Yaw - self:GetTurretYaw()

		local PitchVolume = math.abs( DeltaPitch ) / AimRate
		local YawVolume = math.abs( DeltaYaw ) / AimRate

		local PlayPitch = PitchVolume > 0.95
		local PlayYaw = YawVolume > 0.95

		local TurretArmor = self:GetTurretArmor()
		local Destroyed = self:GetTurretDamaged()

		if Destroyed and (PlayPitch or PlayYaw) and IsValid( TurretArmor ) then
			local T = CurTime()

			if (self._NextTurDMGfx or 0) < T then
				self._NextTurDMGfx = T + 0.1

				local effectdata = EffectData()
				effectdata:SetOrigin( TurretArmor:LocalToWorld( Vector(0,0,TurretArmor:GetMins().z) ) )
				effectdata:SetNormal( self:GetUp() )
				util.Effect( "lvs_physics_turretscraping", effectdata, true, true )
			end
		end

		if PlayPitch or PlayYaw then
			self:DoTurretSound()
		end

		local T = self:GetTurretSoundTime()

		if T > 0 then
			local volume = math.max( PitchVolume, YawVolume )
			local pitch = 90 + 10 * (1 - volume)

			if Destroyed then
				local sound = self:StartTurretSoundDMG()

				pitch = pitch * self.TurretRateDestroyedMul

				sound:ChangeVolume( volume * 0.25, 0.25 )
			end
	
			local sound = self:StartTurretSound()

			sound:ChangeVolume( volume * 0.25, 0.25 )
			sound:ChangePitch( pitch, 0.25 )
		else
			self:StopTurretSound()
			self:StopTurretSoundDMG()
		end
	end

	function ENT:DoTurretSound()
		if not self._TurretSound then self._TurretSound = 0 end

		self._TurretSound = CurTime() + 1.1
	end

	function ENT:GetTurretSoundTime()
		if not self._TurretSound then return 0 end

		return math.max(self._TurretSound - CurTime(),0) / 1
	end

	function ENT:StopTurretSound()
		if not self._turretSND then return end

		self._turretSND:Stop()
		self._turretSND = nil
	end

	function ENT:StartTurretSoundDMG()
		if self._turretSNDdmg then return self._turretSNDdmg end

		self._turretSNDdmg = CreateSound( self, self.TurretRotationSoundDamaged  )
		self._turretSNDdmg:PlayEx(0.5, 100)

		return self._turretSNDdmg
	end

	function ENT:StopTurretSoundDMG()
		if not self._turretSNDdmg then return end

		self._turretSNDdmg:Stop()
		self._turretSNDdmg = nil
	end

	function ENT:StartTurretSound()
		if self._turretSND then return self._turretSND end

		self._turretSND = CreateSound( self, self.TurretRotationSound  )
		self._turretSND:PlayEx(0,100)

		return self._turretSND
	end

	function ENT:OnRemoved()
		self:StopTurretSound()
		self:StopTurretSoundDMG()
	end

	function ENT:OnTick()
		self:AimTurret()
	end

	function ENT:CreateTurretPhysics( data )
		if not isstring( data.follow ) or not isstring( data.mdl ) then return NULL end

		local idFollow = self:LookupAttachment( data.follow )

		local attFollow = self:GetAttachment( idFollow )

		if not attFollow then return NULL end

		local Follower = ents.Create( "lvs_wheeldrive_attachment_follower" )

		if not IsValid( Follower ) then return NULL end

		local Master = ents.Create( "lvs_wheeldrive_steerhandler" )

		if not IsValid( Master ) then Follower:Remove() return NULL end

		Master:SetPos( attFollow.Pos )
		Master:SetAngles( attFollow.Ang )
		Master:Spawn()
		Master:Activate()
		self:DeleteOnRemove( Master )
		self:TransferCPPI( Master )
	
		Follower:SetModel( data.mdl )
		Follower:SetPos( attFollow.Pos )
		Follower:SetAngles( self:GetAngles() )
		Follower:Spawn()
		Follower:Activate()
		Follower:SetBase( self )
		Follower:SetFollowAttachment( idFollow )
		Follower:SetMaster( Master )
		self:TransferCPPI( Follower )
		self:DeleteOnRemove( Follower )

		local B1 = constraint.Ballsocket( Follower, self, 0, 0, self:WorldToLocal( attFollow.Pos ), 0, 0, 1 )
		B1.DoNotDuplicate = true

		local Lock = 0.0001
		local B2 = constraint.AdvBallsocket( Follower,Master,0,0,vector_origin,vector_origin,0,0,-Lock,-Lock,-Lock,Lock,Lock,Lock,0,0,0,1,1)
		B2.DoNotDuplicate = true

		return Follower
	end
end

function ENT:IsTurretEnabled()
	if self:GetHP() <= 0 then return false end

	if not self:GetTurretEnabled() then return false end

	return IsValid( self:GetPassenger( self.TurretPodIndex ) ) or self:GetAI()
end

function ENT:AimTurret()
	if not self:IsTurretEnabled() then if SERVER then self:StopTurretSound() self:StopTurretSoundDMG() end return end

	local EntTable = self:GetTable()

	local weapon = self:GetWeaponHandler( EntTable.TurretPodIndex )

	if not IsValid( weapon ) then return end

	local AimAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )

	if EntTable.TurretFakeBarrel then
		AimAngles = self:WorldToLocalAngles( (self:LocalToWorld( EntTable.TurretFakeBarrelRotationCenter ) - weapon:GetEyeTrace().HitPos):Angle() )
	end

	local AimRate = EntTable.TurretAimRate * FrameTime() 

	if self:GetTurretDamaged() then
		AimRate = AimRate * EntTable.TurretRateDestroyedMul
	end

	local Pitch = math.Clamp( math.ApproachAngle( self:GetTurretPitch(), AimAngles.p, AimRate ), EntTable.TurretPitchMin, EntTable.TurretPitchMax )
	local Yaw = math.ApproachAngle( self:GetTurretYaw(), AimAngles.y, AimRate )

	if EntTable.TurretYawMin and EntTable.TurretYawMax then
		Yaw = math.Clamp( Yaw, EntTable.TurretYawMin, EntTable.TurretYawMax )
	end

	if SERVER then
		self:CalcTurretSound( Pitch, Yaw, AimRate )
	end

	self:SetTurretPitch( Pitch )
	self:SetTurretYaw( Yaw )

	self:SetPoseParameter(EntTable.TurretPitchPoseParameterName, EntTable.TurretPitchOffset + self:GetTurretPitch() * EntTable.TurretPitchMul )
	self:SetPoseParameter(EntTable.TurretYawPoseParameterName, EntTable.TurretYawOffset + self:GetTurretYaw() * EntTable.TurretYawMul )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_ammorack.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "HP" )
	self:NetworkVar( "Float",1, "MaxHP" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	self:NetworkVar( "Vector",0, "EffectPosition" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		self:NextThink( CurTime() + 1 )

		if self:GetDestroyed() then
			local Base = self:GetBase()

			if not IsValid( Base ) then return end

			local dmg = DamageInfo()
			dmg:SetDamage( 100 )
			dmg:SetAttacker( IsValid( Base.LastAttacker ) and Base.LastAttacker or game.GetWorld() )
			dmg:SetInflictor( IsValid(  Base.LastInflictor ) and Base.LastInflictor or game.GetWorld() )
			dmg:SetDamageType( DMG_BURN )
			Base:TakeDamageInfo( dmg )
		end

		return true
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )

			local Base = self:GetBase()

			if not IsValid( Base ) then return end

			Base:Lock()

			for _, ply in pairs( Base:GetEveryone() ) do
				Base:HurtPlayer( ply, ply:Health() + ply:Armor(), dmginfo:GetAttacker(), dmginfo:GetInflictor() )
			end
		end
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:RemoveFireSound()
	if self.FireBurnSND then
		self.FireBurnSND:Stop()
		self.FireBurnSND = nil
	end

	self.ShouldStopFire = nil
end

function ENT:StopFireSound()
	if self.ShouldStopFire or not self.FireBurnSND then return end

	self.ShouldStopFire = true

	self:EmitSound("ambient/fire/mtov_flame2.wav")

	self.FireBurnSND:ChangeVolume( 0, 0.5 )

	timer.Simple( 1, function()
		if not IsValid( self ) then return end

		self:RemoveFireSound()
	end )
end

function ENT:StartFireSound()
	if self.ShouldStopFire or self.FireBurnSND then return end

	self.FireBurnSND = CreateSound( self, "lvs/ammo_fire_loop.wav" )
	self.FireBurnSND:SetSoundLevel( 85 )

	self.FireBurnSND:PlayEx(0,100)

	self.FireBurnSND:ChangeVolume( 1, 1 )

	self:EmitSound("lvs/ammo_fire.wav")

	self.StartFireTime = CurTime()
end

function ENT:OnRemove()
	self:RemoveFireSound()
end

function ENT:Draw()
end

function ENT:Think()
	local T = CurTime()

	self:SetNextClientThink( T + 0.05 )
 
	if not self:GetDestroyed() then
		self:StopFireSound()

		return true
	end

	self:StartFireSound()

	local Scale = math.min( (T - (self.StartFireTime or T)) * 0.5, 1 )

	local Base = self:GetBase()

	local effectdata = EffectData()
		effectdata:SetOrigin( Base:LocalToWorld( self:GetEffectPosition() ) )
		effectdata:SetEntity( Base )
		effectdata:SetMagnitude( Scale )
	util.Effect( "lvs_ammorack_fire", effectdata )

	return true
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_city/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Honda City Turbo"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/honda_city_turbo/city.mdl"

ENT.MaxVelocity = 2200

ENT.EngineCurve = 0.15
ENT.EngineTorque = 62
ENT.EngineIdleRPM = 1000
ENT.EngineMaxRPM = 7000

ENT.TransGears = 5
ENT.TransGearsReverse = 1

ENT.RandomColor = {
	{
		Skin = 0,
		Color = Color(255,255,255),
	},
	{
		Skin = 0,
		Color = Color(131,131,131),
	},
	{
		Skin = 1,
		Color = Color(36,41,80),
	},
}

ENT.HornSound = "lvs/horn4.wav"
ENT.HornPos = Vector(40,0,35)

ENT.ExhaustPositions = {
	{
		pos = Vector(-62.14,-17.18,13.04),
		ang = Angle(0,180,0),
	}
}

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/miata/eng_idle_loop.wav",
		Volume = 1,
		Pitch = 85,
		PitchMul = 25,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/miata/eng_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 90,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/miata/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 90,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}


ENT.Lights = {
	{
		Trigger = "main",
		ProjectedTextures = {
			{ pos = Vector(60.8,23.19,26.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(60.8,-23.19,26.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "high",
		ProjectedTextures = {
			{ pos = Vector(60.8,23.19,26.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(60.8,-23.19,26.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
	Trigger = "main+high",
		SubMaterialID = 2,
		Sprites = {
			{ pos = Vector(60.8,23.19,26.28), colorB = 200, colorA = 150 },
			{ pos = Vector(60.8,-23.19,26.28), colorB = 200, colorA = 150 },
		},
	},
	{
		Trigger = "brake",
		SubMaterialID = 3,
	},
	{
		Trigger = "main+brake",
		SubMaterialID = 19,
		Sprites = {
			{ pos = Vector(-59.24,27.17,32.66), colorG = 0, colorB = 0, colorA = 150 },
			{ pos = Vector(-59.24,-27.17,32.66), colorG = 0, colorB = 0, colorA = 150 },
		}
	},
	{
		Trigger = "reverse",
		SubMaterialID = 16,
		Sprites = {
			{ pos = Vector(-60.44,26.66,27.06), height = 25, width = 25, colorA = 150 },
			{ pos = Vector(-60.44,-26.66,27.06), height = 25, width = 25, colorA = 150 },
		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 18,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(68.82,-23.21,19.41), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 35, height = 35, pos = Vector(59.1,-28.33,29.87), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 40, height = 40, pos = Vector(-58.23,-26.76,36.06), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 17,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(68.82,23.21,19.41), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 35, height = 35, pos = Vector(59.1,28.33,29.87), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 40, height = 40, pos = Vector(-58.23,26.76,36.06), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "fog",
		SubMaterialID = 29,
		Sprites = {
			{ pos = Vector(67.16,23.32,15.18), colorG = 200, colorB = 0, colorA = 100 },
			{ pos = Vector(67.16,-23.32,15.18), colorG = 200, colorB = 0, colorA = 100 },
		},
	},
}

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_template/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer ) -- keep default behavior

	--[[ add your gauges:

	self:SetPoseParameter( "tacho_gauge", engine_rpm / 8000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "alt_gauge", ammeter )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 240 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )
	]]
	-- no need to call invalidatebonecache. Its called automatically after this function.
end

--[[

function ENT:OnSpawn()
end

-- use this instead of ENT:OnRemove
function ENT:OnRemoved()
end

-- use this instead of ENT:Think()
function ENT:OnFrame()
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true -- return false to prevent original hud paint from running
end

-- called when the engine is turned on or off
function ENT:OnEngineActiveChanged( Active )
	if Active then
		self:EmitSound( "lvs/vehicles/generic/engine_start1.wav", 75, 100,  LVS.EngineVolume )
	else
		self:EmitSound( "vehicles/jetski/jetski_off.wav", 75, 100,  LVS.EngineVolume )
	end
end

-- called when either an ai is activated/deactivated or when a player is sitting/exiting the driver seat
function ENT:OnActiveChanged( Active )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles,  fov, pod )
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles,  fov, pod )
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end
]]
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_trackphysics.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:AddToGibList( ent )
		if not istable( self._GibList ) then self._GibList = {} end

		table.insert( self._GibList, ent )
	end

	function ENT:GetGibList()
		return self._GibList or {}
	end

	function ENT:SpawnGib( LeftOrRight )
		local base = self:GetBase()

		local options = {
			[LVS.WHEELTYPE_LEFT] = "left",
			[LVS.WHEELTYPE_RIGHT] = "right"
		}

		local side = options[ LeftOrRight ]

		if not side or not IsValid( base ) or not istable( base.TrackGibs ) or not base.TrackGibs[ side ] then return end

		local vel = self:GetVelocity()

		for _, data in pairs( base.TrackGibs[ side ] ) do
			local IsRagdoll = util.IsValidRagdoll( data.mdl ) 

			local class = IsRagdoll and "prop_ragdoll" or "prop_physics"

			local ent = ents.Create( class )

			if not IsValid( ent ) then continue end

			ent:SetModel( data.mdl )
			ent:SetPos( self:LocalToWorld( data.pos ) )
			ent:SetAngles( self:LocalToWorldAngles( data.ang ) )
			ent:Spawn()
			ent:Activate()
			ent:SetCollisionGroup( COLLISION_GROUP_DEBRIS )

			ent:EmitSound("lvs/tracks_break"..math.random(1,3)..".wav")

			if IsRagdoll then
				for i = 1, (ent:GetPhysicsObjectCount() - 1) do
					local bone = ent:GetPhysicsObjectNum( i )

					if not IsValid( bone ) then continue end

					bone:AddVelocity( vel )
				end
			else
				local PhysObj = ent:GetPhysicsObject()

				if IsValid( PhysObj ) then
					PhysObj:AddVelocity( vel )
				end
			end

			self:DeleteOnRemove( ent )

			self:AddToGibList( ent )

			timer.Simple( 59.5, function()
				if not IsValid( ent ) then return end

				ent:SetRenderMode( RENDERMODE_TRANSCOLOR )
				ent:SetRenderFX( kRenderFxFadeFast )
			end )

			timer.Simple( 60, function()
				if not IsValid( ent ) then return end

				ent:Remove()
			end )
		end
	end

	function ENT:ClearGib()
		local Gibs = self:GetGibList()

		for _, ent in pairs( Gibs ) do
			if not IsValid( ent ) then continue end

			ent:Remove()
		end

		table.Empty( Gibs )
	end

	function ENT:Initialize()	
		self:SetUseType( SIMPLE_USE )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )

		-- this is so vj npcs can still see us
		self:AddEFlags( EFL_DONTBLOCKLOS )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self:DrawShadow( false )

		self:SetMaterial( "models/wireframe" )

		local PhysObj = self:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		PhysObj:SetMass( 1 )
		PhysObj:EnableDrag( false )
		PhysObj:EnableGravity( false ) 
		PhysObj:EnableMotion( true )
		PhysObj:SetMaterial( "friction_00" )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		local Force = dmginfo:GetDamageForce()
		local fLength = Force:Length()

		-- translate force value to armor penetration value is Force * 0.1
		-- mm to inch is * 0.0393701
		-- so correct value is * 0.00393701
		local pLength = fLength * 0.00393701

		local startpos = dmginfo:GetDamagePosition()
		local endpos = startpos + Force:GetNormalized() * pLength

		local trace = util.TraceLine( {
			start = startpos,
			endpos = endpos,
			whitelist = true,
			ignoreworld = true,
			filter = base,
		} )

		if trace.Hit then
			dmginfo:SetDamagePosition( trace.HitPos )
		else
			dmginfo:SetDamageType( dmginfo:GetDamageType() + DMG_PREVENT_PHYSICS_FORCE )
		end

		base:OnTakeDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, phys )
		local HitEntity = data.HitEntity
		local HitObject = data.HitObject

		if not IsValid( HitEntity ) or not IsValid( HitObject ) then return end

		physobj:SetVelocityInstantaneous( data.OurOldVelocity )

		if HitObject:IsMotionEnabled() and (HitEntity:GetClass() == "prop_ragdoll" or HitEntity:GetCollisionGroup() == COLLISION_GROUP_WEAPON) then
			HitObject:SetVelocityInstantaneous( data.OurOldVelocity * 2 )
		end
	end

	function ENT:Use( ply )
		if (ply._lvsNextUse or 0) > CurTime() then return end

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:Use( ply )
	end

	function ENT:OnRemove()
		self:ClearGib()
	end

	return
end

function ENT:Draw()
	if not LVS.DeveloperEnabled then return end

	self:DrawModel()
end

function ENT:Think()
end

function ENT:OnRemove()
end
--PATH addons/__main/lua/entities/m9k_ammo_winchester/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Winchester Ammo"
ENT.Category		= "M9K Ammunition"

ENT.Spawnable		= true
ENT.AdminOnly = false
ENT.DoNotDuplicate = true

if SERVER then

AddCSLuaFile("shared.lua")

function ENT:SpawnFunction(ply, tr)

	if (!tr.Hit) then return end
	
	local SpawnPos = tr.HitPos + tr.HitNormal * 16
	
	local ent = ents.Create("m9k_ammo_winchester")
	
	ent:SetPos(SpawnPos)
	ent:Spawn()
	ent:Activate()
	ent.Planted = false
	
	return ent
end


/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	local model = ("models/Items/sniper_round_box.mdl")
	
	self.Entity:SetModel(model)
	
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:DrawShadow(false)
	
	self.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	local phys = self.Entity:GetPhysicsObject()
	
	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Entity:SetUseType(SIMPLE_USE)
end


/*---------------------------------------------------------
   Name: PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data, physobj)
	
	// Play sound on bounce
	if (data.Speed > 80 and data.DeltaTime > 0.2) then
		self.Entity:EmitSound("Default.ImpactSoft")
	end
end

/*---------------------------------------------------------
   Name: OnTakeDamage
---------------------------------------------------------*/
function ENT:OnTakeDamage(dmginfo)

	if dmginfo:GetAttacker():GetClass() == "m9k_ammo_explosion" then return end
	self.Entity:TakePhysicsDamage(dmginfo)
	if GetConVar("M9KAmmoDetonation") == nil then return end
	if not (GetConVar("M9KAmmoDetonation"):GetBool()) then return end
	blaster = dmginfo:GetAttacker()
	pos = self.Entity:GetPos()+Vector(0,0,10)
	
	dice = math.random(1,5)

	if dmginfo:GetDamage() >75 or dice == 1 then
		self.Entity:Remove()
	
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Entity:GetPos())
		util.Effect("ThumperDust", effectdata)
		util.Effect("Explosion", effectdata)
	
		timer.Simple(.01, function()
		
			for i=1, 100 do
			
			ouchies = {}
			ouchies.start = pos
			ouchies.endpos = pos + Vector(math.Rand(-1,1), math.Rand(-1,1), math.Rand(0,1)) * 64000
			ouchies = util.TraceLine(ouchies)
			
			if ouchies.Hit and not ouchies.HitSky then 
				util.Decal("Impact.Concrete", ouchies.HitPos + ouchies.HitNormal, ouchies.HitPos - ouchies.HitNormal )//and ouchies.Entity then
				ouchies.Entity:TakeDamage(30 * math.Rand(.85,1.15), blaster, self.Entity)
			end
			end
		end)
	end	
	

end


/*---------------------------------------------------------
   Name: Use
---------------------------------------------------------*/
function ENT:Use(activator, caller)

	
	if (activator:IsPlayer()) and not self.Planted then
		activator:GiveAmmo(100, "AirboatGun")
		self.Entity:Remove()
	end
end

end

if CLIENT then

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()
end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()
	
	self.Entity:DrawModel()
	
	local ledcolor = Color(230, 45, 45, 255)

  	local TargetPos = self.Entity:GetPos() + (self.Entity:GetUp() * 1.4) + (self.Entity:GetRight() * 1) + (self.Entity:GetForward() * -1.45)

	local FixAngles = self.Entity:GetAngles()
	local FixRotation = Vector(90, 0, 0)
	
	FixAngles:RotateAroundAxis(FixAngles:Right(), FixRotation.x)
	FixAngles:RotateAroundAxis(FixAngles:Up(), FixRotation.y)
	FixAngles:RotateAroundAxis(FixAngles:Forward(), FixRotation.z)

	self.Text = "Winchester"
	
	cam.Start3D2D(TargetPos, FixAngles, .07)
		draw.SimpleText(self.Text, "DermaDefaultBold", 31, -22, ledcolor, 1, 1)
	cam.End3D2D()
end

end
--PATH addons/_pcasino/lua/entities/pcasino_npc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	-- To prevent some weird issue where the animation was going crazy
	self:SetSequence(self:LookupSequence("idle_subtle"))

	self.hasInitialized = true
end


function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end

	surface.SetFont("pCasino.Entity.Arrows")
	self.textWidth = surface.GetTextSize(self.data.text.overhead)
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 200000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	if (not self.data.text.overhead) or (self.data.text.overhead == " ") then return end

	local ang = LocalPlayer():EyeAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(self:GetPos()+self:GetUp()*78, ang, 0.07)
		-- Previous bet step
		surface_setdrawcolor(black)
		surface_drawrect(-(self.textWidth + 10)*0.5, 5, self.textWidth + 10, 65)
		-- Border
		surface_setdrawcolor(white)
		surface_drawrect(-(self.textWidth + 20)*0.5, 0, self.textWidth + 20, 5)
		surface_drawrect(-(self.textWidth + 20)*0.5, 5, 5, 65)
		surface_drawrect((self.textWidth*0.5) + 5, 5, 5, 65)
		surface_drawrect(-(self.textWidth + 20)*0.5, 70, self.textWidth+20, 5)
		-- Text
		draw_simpletext(self.data.text.overhead, "pCasino.Entity.Arrows", 0, 35, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/__________skeypads/lua/entities/skeypad/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "sKeypad"
ENT.Category = "sKeypads"
ENT.Author = "Tom.bat & NoSharp"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.IsKeypad = true
ENT.noDrag = true
ENT.KeyRegions = {
    ["1"] = {
        displayText = "1",
        num = true,
        order = 1,
    },
    ["2"] = {
        displayText = "2",
        num = true,
        order = 2,
    },
    ["3"] = {
        displayText = "3",
        num = true,
        order = 3,
    },
    ["4"] = {
        displayText = "4",
        num = true,
        order = 4,
    },
    ["5"] = {
        displayText = "5",
        num = true,
        order = 5,
    },
    ["6"] = {
        displayText = "6",
        num = true,
        order = 6,
    },
    ["7"] = {
        displayText = "7",
        num = true,
        order = 7,
    },
    ["8"] = {
        displayText = "8",
        num = true,
        order = 8,
    },
    ["9"] = {
        displayText = "9",
        num = true,
        order = 9,
    },
    ["clear"] = {
        displayText = "CLR",
        num = true,
        order = 10,
    },
    ["0"] = {
        displayText = "0",
        num = true,
        order = 11,
    },
    ["enter"] = {
        displayText = "ENTER",
        num = true,
        order = 12,
    },
    ["fingerprint"] = {
        pos = { -28, 690 },
        size = { 536, 175 }
    }
}

function ENT:SetupDataTables()
    self:NetworkVar( "String", 0, "ScreenText" )
    self:NetworkVar( "Bool", 0, "InputBlocked" )
    self:NetworkVar( "Bool", 1, "IsOpen" )
    self:NetworkVar( "Entity", 0, "owning_ent" )
    if SERVER then
        self:SetScreenText( "" )
        self:SetInputBlocked( false )
        self:SetIsOpen( false )
    end
end

function ENT:SendCommand() --These two functions are here to prevent errors if the workshop keypads are installed alongside
end

function ENT:GetHoveredElement()
end
--PATH addons/____sprinter/lua/entities/sprinter_base/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.logs = {}
end

function ENT:Draw()
	self:DrawModel()
	
	if !sPrinter then return end

	if sPrinter.config["logo"][self.Base].enabled then
		sPrinter.drawLogo(self, sPrinter.config["logo"][self.Base].id)
	end
	
	local opacity = sPrinter.fadeByDistance(self)
	if opacity > 0 then
		sPrinter.drawSideScreen(self, opacity)
		sPrinter.drawTopScreen(self, opacity)
	end

	sPrinter.requestData(self)
end

function ENT:drawingOverlay(type)
	return self:GetLocked()
end

function ENT:GetLocked()
	local rack = self:GetRack()

	if IsValid(rack) and rack:GetLocked() then return true end
	
	return false
end

function ENT:OnRemove()
	if IsValid(self.topScreen) then
		self.topScreen:Remove()
	end

	if IsValid(self.sideScreen) then
		self.sideScreen:Remove()
	end
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_bag/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Weed Bag"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Int", 0, "BudCounter")
	
	self:NetworkVar("Bool", 0, "FirstSpawn")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_frontwoods/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 80
local ypos = -10
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 535, 150, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 150, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.Frontwoods.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	
		local amount = self:GetPaperCounter()
		for i=1, 3 do
			draw.RoundedBox(0, xpos+20, ypos+75+((i-1)*25), 505, 15, Color(35, 35, 35))
			if amount >= i then 
				draw.RoundedBox(0, xpos+20, ypos+75+((i-1)*25), 505, 15, Color(255, 255, 255))
			end

		end 
	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_light_big/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Big Light"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Bool", 0, "On")
	self:NetworkVar("Int", 0, "Battery")
	
	self:NetworkVar("Bool", 1, "FirstSpawn")
end
--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflash.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 255
		dlight.g = 50
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 4)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.05, 0.1))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)

	p:SetAirResistance(100)
	p:SetVelocity(self.Forward * 120 + VectorRand() * 20)
	p:SetGravity(Vector(0, 0, 10))
	p:SetDieTime(math.Rand(1, 2))
	p:SetStartAlpha(25)
	p:SetEndAlpha(0)
	p:SetStartSize(0)
	p:SetEndSize(45)
	p:SetRollDelta(math.Rand(-1, 1))
	p:SetColor(120, 120, 120)

	for i = 1, 5 do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1, 4), self.Start + i * 6 * self.Forward)

		p:SetVelocity(10 * VectorRand())

		p:SetDieTime(math.Rand(0.04, 0.1))

		p:SetStartAlpha(250)

		p:SetStartSize(30 - i * 3)
		p:SetEndSize(0)

		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))

		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end






--PATH addons/lvs_cars_3027255911/lua/effects/lvs_carfueltank_fire.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.FireMat = {
	[1] = Material( "effects/lvs_base/flamelet1" ),
	[2] = Material( "effects/lvs_base/flamelet2" ),
	[3] = Material( "effects/lvs_base/flamelet3" ),
	[4] = Material( "effects/lvs_base/flamelet4" ),
	[5] = Material( "effects/lvs_base/flamelet5" ),
	[6] = Material( "effects/lvs_base/fire" ),
}

EFFECT.SmokeMat = {
	[1] = Material( "particle/smokesprites_0001" ),
	[2] = Material( "particle/smokesprites_0002" ),
	[3] = Material( "particle/smokesprites_0003" ),
	[4] = Material( "particle/smokesprites_0004" ),
	[5] = Material( "particle/smokesprites_0005" ),
	[6] = Material( "particle/smokesprites_0006" ),
	[7] = Material( "particle/smokesprites_0007" ),
	[8] = Material( "particle/smokesprites_0008" ),
	[9] = Material( "particle/smokesprites_0009" ),
	[10] = Material( "particle/smokesprites_0010" ),
	[11] = Material( "particle/smokesprites_0011" ),
	[12] = Material( "particle/smokesprites_0012" ),
	[13] = Material( "particle/smokesprites_0013" ),
	[14] = Material( "particle/smokesprites_0014" ),
	[15] = Material( "particle/smokesprites_0015" ),
	[16] = Material( "particle/smokesprites_0016" ),
}

EFFECT.Smoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( Ent ) then return end

	self.Ent = Ent
	self.Pos = Ent:WorldToLocal( Pos + VectorRand() * 20 )
	self.RandomSize = math.Rand( 1, 2 )
	self.Vel = self.Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( self.Pos )

	if not IsValid( emitter ) then return end

	for i = 1, 8 do
		local particle = emitter:Add( self.Smoke[ math.random(1, #self.Smoke ) ], Pos )

		local Dir = Angle(0,math.Rand(-180,180),0):Forward()
		Dir.z = -0.5
		Dir:Normalize()

		if particle then
			particle:SetVelocity( Dir * 250 )
			particle:SetDieTime( 0.5 + i * 0.01 )
			particle:SetAirResistance( 125 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 40 )
			particle:SetRoll( math.Rand(-1,1) * math.pi )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( 0, 0, 0 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderSmoke()
	self:RenderFire()
end

function EFFECT:RenderSmoke()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	local Pos = self.Ent:LocalToWorld( self.Pos ) + Vector(0,0,25)

	local InvScale = 1 - Scale

	local Num = #self.SmokeMat - math.Clamp(math.ceil( Scale * #self.SmokeMat ) - 1,0, #self.SmokeMat - 1)

	local C = 10 + 10 * self.RandomSize
	local Size = (25 + 30 * InvScale) * self.RandomSize
	local Offset = (self.Vel * InvScale ^ 2) * 0.5

	render.SetMaterial( self.SmokeMat[ Num ] )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * 80 * self.RandomSize) - Offset, Size, Size, Color( C, C, C, 200 * Scale) )
end

function EFFECT:RenderFire()
	local Scale = (self.DieTime - 0.4 - CurTime()) / 0.6

	if Scale < 0 then return end

	local Pos = self.Ent:LocalToWorld( self.Pos )

	local InvScale = 1 - Scale

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * 10), 100 * InvScale, 100 * InvScale, Color( 255, 150, 75, 255) )

	local Num = #self.FireMat - math.Clamp(math.ceil( Scale * #self.FireMat ) - 1,0, #self.FireMat - 1)

	local Size = (10 + 20 * Scale) * self.RandomSize
	local Offset = (self.Vel * InvScale ^ 2) * 0.025

	render.SetMaterial( self.FireMat[ Num ] )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * 25) - Offset, Size, Size, Color( 255, 255, 255, 255) )
end
--PATH addons/lvs_cars_3027255911/lua/effects/lvs_defence_smoke.lua:

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()

	local emitter = ParticleEmitter( pos, false )

	if not emitter then return end

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

	for i = 0,2 do
		local particle = emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 200 )
		particle:SetDieTime( math.Rand(4,6) )
		particle:SetAirResistance( 250 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 0 )
		particle:SetEndSize( 650 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( VectorRand() * 600 )
		particle:SetCollide( true )
		particle:SetBounce( 1 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_shield_impact.lua:

local LastImpact = 0

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	local T = CurTime()

	self.LifeTime = 0.2
	self.DieTime = T + self.LifeTime

	local DontHurtEars = math.Clamp( T - LastImpact, 0.4, 1 ) ^ 2

	LastImpact = T

	sound.Play( "lvs/shield_deflect.ogg", self.Pos, 120, 100, DontHurtEars )

	self:Spark( self.Pos )

	if IsValid( self.Ent ) then
		self.Model = ClientsideModel( self.Ent:GetModel(), RENDERMODE_TRANSCOLOR )
		self.Model:SetMaterial("models/alyx/emptool_glow")
		self.Model:SetColor( Color(200,220,255,255) )
		self.Model:SetParent( self.Ent, 0 )
		self.Model:SetMoveType( MOVETYPE_NONE )
		self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
		self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
		self.Model:AddEffects( EF_BONEMERGE )
	end
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )

		local vel = VectorRand() * 500

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 0, 127, 255 )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then
		if IsValid( self.Model ) then
			self.Model:Remove()
		end
	end

	if self.DieTime < CurTime() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 200 * Scale, 200 * Scale, Color( 255, 255, 255, 255) )
end

--PATH addons/__main/lua/effects/muzzle_eff/init.lua:
function EFFECT:Init( data )
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos( data:GetOrigin(), self.WeaponEnt, self.Attachment )
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	local emitter = ParticleEmitter( self.Position )
	local particle = emitter:Add( "particle/particle_smokegrenade", self.Position - self.Forward * 4 )
	particle:SetAirResistance( 40 )
	particle:SetGravity( Vector( 0, 00, math.Rand( -10, 10 ) ) )
	particle:SetDieTime( math.Rand( 1, 0.5 ) )
	particle:SetStartAlpha( math.Rand( 80, 120 ) )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.Rand( 3, 7 ) )
	particle:SetEndSize( math.Rand( 20, 50 ) )
	particle:SetRoll( math.Rand( -25, 25 ) )
	particle:SetRollDelta( math.Rand( -0.05, 0.05 ) )
	particle:SetColor( 145, 145, 145 )
	for _ = 1, 4 do
		for _ = 1, 2 do
			particle = emitter:Add( "effects/muzzleflash" .. math.random( 1, 4 ), self.Position )
			particle:SetAirResistance( 900 )
			particle:SetGravity( Vector( 0, 0, math.Rand( 100, 200 ) ) )
			particle:SetDieTime( 0.05 )
			particle:SetStartAlpha( math.Rand( 255, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 1, 70 ) )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand( 180, 480 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor( 255, 255, 255, 255 )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/nrg_tracer_drr.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Think()

	util.ParticleTracerEx( 
		"nrg_tracer_drr", --particle system
		self.StartPos, --startpos
		self.EndPos, --endpos
		self.Parent:EntIndex(), --entity index
		1, --do whiz effect
		-1  --attachment
	)
	
end

function EFFECT:Render()

end

--PATH addons/____inventory/lua/itemstore/skins/flat.lua:
local SKIN = {}

SKIN.GradientUp = Material( "gui/gradient_up" )
SKIN.GradientDown = Material( "gui/gradient_down" )
SKIN.Blur = Material( "pp/blurscreen" )

function SKIN:PaintFrame( panel, w, h )
	self.Blur:SetFloat( "$blur", 8 )
	self.Blur:Recompute()
	render.UpdateScreenEffectTexture()

	local x, y = panel:LocalToScreen( 0, 0 )

	surface.SetDrawColor( 255, 255, 255 )
	surface.SetMaterial( self.Blur )
	surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )

	surface.SetDrawColor( Color( 30, 30, 30, 200 ) )
	surface.DrawRect( 0, 22, w, h - 22 )

	surface.SetDrawColor( Color( 44, 62, 80 ) )
	surface.DrawRect( 0, 0, w, 22 )
end

function SKIN:PaintButton( panel, w, h )
	surface.SetDrawColor( Color( 200, 200, 200 ) )
	surface.DrawRect( 0, 0, w, h )

	if not panel.Disabled then
		surface.SetMaterial( panel.Depressed and self.GradientUp or self.GradientDown )
		surface.SetDrawColor( panel.Hovered and Color( 240, 240, 240 ) or Color( 230, 230, 230 ) )
		surface.DrawTexturedRect( 0, 0, w, h )
	end

	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawOutlinedRect( 0, 0, w, h )
end

function SKIN:PaintTab( panel, w, h )
	if panel:IsActive() then
		draw.RoundedBoxEx( 2, 2, 0, w - 5, h - 8, Color( 0, 0, 0, 200 ),
			true, true, false, false )
	else
		draw.RoundedBoxEx( 2, 2, 0, w - 5, h, Color( 0, 0, 0, 150 ),
			true, true, false, false )
	end
end

function SKIN:PaintPropertySheet( panel, w, h )
	surface.SetDrawColor( Color( 0, 0, 0, 200 ) )
	surface.DrawRect( 0, 20, w, h )
end

function SKIN:PaintCategoryList( panel, w, h )
end

function SKIN:PaintCollapsibleCategory( panel, w, h )
	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawRect( 0, 0, w, 20 )

	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawRect( 0, 0, w, h )
end

function SKIN:PaintWindowCloseButton( panel, w, h )
	local col = Color( 0, 0, 0, 50 )

	if not panel:GetDisabled() and panel.Hovered then
		if panel:IsDown() then
			col = Color( 192, 57, 43 )
		else
			col = Color( 231, 76, 60 )
		end
	end

	draw.RoundedBoxEx( 4, 0, 2, w, 18, col, true, true, true, true )
	draw.SimpleText( "r", "Marlett", w * 0.5, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function SKIN:PaintWindowMaximizeButton( panel, w, h )
	if panel:GetDisabled() then return end

	local col = Color( 0, 0, 0, 50 )

	if panel.Hovered then
		if panel:IsDown() then
			col = Color( 41, 128, 185 )
		else
			col = Color( 52, 152, 219 )
		end
	end

	draw.RoundedBoxEx( 4, 0, 2, w, 18, col, false, false, false, false )
	draw.SimpleText( "1", "Marlett", w * 0.5, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function SKIN:PaintWindowMinimizeButton( panel, w, h )
	if true then return end

	local col = Color( 0, 0, 0, 50 )

	if panel.Hovered then
		if panel:IsDown() then
			col = Color( 41, 128, 185 )
		else
			col = Color( 52, 152, 219 )
		end
	end

	draw.RoundedBoxEx( 4, 0, 2, w, 18, col, true, false, true, false )
	draw.SimpleText( "0", "Marlett", w * 0.5, 11, color_white,
		TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

derma.DefineSkin( "itemstore", "Flat skin for ItemStore", SKIN )

--PATH addons/____inventory/lua/itemstore/vgui/trade.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSkin( "itemstore" )

	self.LeftContainer = vgui.Create( "ItemStoreContainer", self )
	self.RightContainer = vgui.Create( "ItemStoreContainer", self )

	self.LeftMoneyIcon = vgui.Create( "DImage", self )
	self.LeftMoneyIcon:SetImage( "icon16/money.png" )

	self.RightMoneyIcon = vgui.Create( "DImage", self )
	self.RightMoneyIcon:SetImage( "icon16/money.png" )

	self.LeftMoney = vgui.Create( "onyx.TextEntry", self )
	self.LeftMoney.OnLoseFocus = function( money )
		net.Start( "ItemStoreTradeMoney" )
			net.WriteUInt( tonumber( money:GetText() ) or 0, 32 )
		net.SendToServer()
	end

	self.RightMoney = vgui.Create( "onyx.Label", self )
	self.RightMoney:SetText( "0" )

	self.LeftReady = vgui.Create( "onyx.TogglerLabel", self )
	self.LeftReady:SetText( itemstore.Translate( "ready" ) )
	self.LeftReady:SetWide( 180 )
	self.LeftReady.OnChange = function( ready )
		net.Start( "ItemStoreReadyTrade" )
			net.WriteBit( ready:GetChecked() )
		net.SendToServer()
	end

	self.RightReady = vgui.Create( "onyx.Label", self )
	self.RightReady:SetText( itemstore.Translate( "not_ready" ) )

	self.Accept = vgui.Create( "onyx.Button", self )
	self.Accept:SetText( itemstore.Translate( "accept" ) )
	self.Accept:SetDisabled( true )
	self.Accept.DoClick = function()
		net.Start( "ItemStoreAcceptTrade" ) net.SendToServer()

		surface.PlaySound( "buttons/button9.wav" )
		self:Remove()
	end

	self.Chat = vgui.Create( "RichText", self )
	function self.Chat:Paint()
		draw.RoundedBox( 4, 0, 0, self:GetWide(), self:GetTall(), Color( 230, 230, 230 ) )
	end

	self.ChatEntry = vgui.Create( "onyx.TextEntry", self )
	function self.ChatEntry:OnEnter()
		LocalPlayer().Trade:SendMessage( self:GetText() )

		self:SetText( "" )
		self:RequestFocus()
	end

	self.Inventory = vgui.Create( "ItemStoreContainerWindow" )
	self.Inventory:SetContainerID( LocalPlayer().InventoryID )
	self.Inventory:SetTitle( itemstore.Translate( "inventory" ) )
	self.Inventory:ShowCloseButton( false )
	self.Inventory:InvalidateLayout( true )
end

function PANEL:Think()
	self.BaseClass.Think( self )

	local x, y = self:GetPos()
	self.Inventory:SetPos( x + self:GetWide() * 0.5 - self.Inventory:GetWide() * 0.5, y + self:GetTall() + 5 )
end

function PANEL:ChatMessage( pl, message )
	if pl == LocalPlayer() then
		self.Chat:InsertColorChange( 255, 0, 0, 255 )
	else
		self.Chat:InsertColorChange( 0, 0, 255, 255 )
	end

	self.Chat:AppendText( pl:Name() )
	self.Chat:InsertColorChange( 100, 100, 100, 255 )
	self.Chat:AppendText( ": " .. message .. "\n" )
end

function PANEL:Refresh()
	local trade = LocalPlayer().Trade

	if trade then
		local ourside = LocalPlayer() == trade.Left.Player and trade.Left or trade.Right
		local otherside = LocalPlayer() == trade.Right.Player and trade.Left or trade.Right

		self:SetTitle( itemstore.Translate( "trading_with", otherside.Player:Name() ) )

		self.LeftContainer:SetContainerID( ourside.Container:GetID() )
		self.RightContainer:SetContainerID( otherside.Container:GetID() )

		self.LeftMoney:SetText( ourside.Money )
		self.RightMoney:SetText( otherside.Money )

		self.LeftReady:SetChecked( ourside.Ready )
		self.RightReady:SetText( otherside.Ready and itemstore.Translate( "ready" )
			or itemstore.Translate( "not_ready" ) )

		self.Accept:SetDisabled( not ( ourside.Ready and otherside.Ready ) )
	end
end

-- it's me, i'm coding hitler. this is the grave of so many brave
-- functions that went to war and died on my behalf.
function PANEL:PerformLayout()
	self.BaseClass.PerformLayout( self )

	self.LeftContainer:SetPos( 5, 33 )
	self.LeftContainer:SizeToContents()
	local left_w, left_h = self.LeftContainer:GetSize()

	self.RightContainer:SetPos( 5 + left_w + 24, 33 )
	self.RightContainer:SizeToContents()
	local right_w, right_h = self.RightContainer:GetSize()

	self.LeftMoneyIcon:SetPos( 5, 33 + left_h + 5 )
	self.LeftMoneyIcon:SetSize( 16, 16 )

	self.LeftMoney:SetPos( 5 + 16 + 5, 33 + left_h + 5 )
	self.LeftMoney:SetSize( left_w - 5 - 16 - 5, 16 )

	self.RightMoneyIcon:SetPos( 5 + right_w + 24, 33 + right_h + 5 )
	self.RightMoneyIcon:SetSize( 16, 16 )

	self.RightMoney:SetPos( 5 + left_w + 24 + 5 + 16 + 5, 33 + right_h + 5 )
	self.RightMoney:SetSize( right_w - 5 - 16 - 5, 16 )

	self.LeftReady:SetPos( 5, 33 + left_h + 5 + 16 + 5 )
	self.LeftReady:SizeToContents()

	self.RightReady:SetPos( 5 + left_w + 24, 33 + right_h + 5 + 16 + 5 )

	self.RightReady:SizeToContents()

	self.Accept:SetPos( 5, 33 + left_h + 5 + ( 16 + 5 ) * 2 )
	self.Accept:SetSize( 390, 37 )

	self.Chat:SetPos( 400, 27 )
	self.Chat:SetSize( 195, 220 )

	self.ChatEntry:SetPos( 400, 250 )
	self.ChatEntry:SetSize( 195, 25 )

	self:SetSize( 600, 280 )
end

function PANEL:OnRemove()
	net.Start( "ItemStoreCloseTrade" ) net.SendToServer()
	self.Inventory:Close()
end

vgui.Register( "ItemStoreTrade", PANEL, "DFrame" )

--PATH RunString(Ex):
vapeHelium=0
--PATH addons/____esclib/lua/elib/essentials/esc_vgui.lua:
local PANEL_META = FindMetaTable("Panel")

local clamp = math.Clamp
local sin = math.sin
local TimeFraction = math.TimeFraction
local random = math.random

-- --example
-- local pnl = vgui.Create("DPanel")
-- pnl:eSetHoverPanel(function(prnt)
-- 	local pnl = vgui.Create("DPanel")
-- 	pnl:SetSize(200,200)
-- 	return pnl
-- end)
function PANEL_META:eSetHoverPanel(generate_panel)
    if not isfunction(generate_panel) then return end

    local pnl = self

    local oldOnCursorEntered = self.OnCursorEntered
    local oldOnCursorExited = self.OnCursorExited

	local generated_pnl = generate_panel(self)
	generated_pnl:SetVisible(false)

    function self:OnCursorEntered()
        if isfunction(oldOnCursorEntered) then oldOnCursorEntered(self) end
        
        if not IsValid(generated_pnl) then return end

		generated_pnl:SetVisible(true)
        generated_pnl:SetMouseInputEnabled(false)
        generated_pnl:SetAlpha(0)
        generated_pnl:AlphaTo(255, 0.1)

        self.eHoverPanel = generated_pnl
        self.eHasHoverPanel = true

        local oldGeneratedPnlThink = generated_pnl.Think

        function generated_pnl:Think()
            if isfunction(oldGeneratedPnlThink) then oldGeneratedPnlThink(self) end

            if not IsValid(pnl) then
                if IsValid(generated_pnl) then generated_pnl:Remove() end
                return
            end

            if not pnl:IsHovered() then
				self:SetVisible(false)
            else
                self:SetVisible(true)
            end
        end
    end

    function self:OnCursorExited()
        if isfunction(oldOnCursorExited) then oldOnCursorExited(self) end

        if IsValid(self.eHoverPanel) then
            self.eHoverPanel:SetVisible(false)
        end
    end

	return generated_pnl
end

--align uses TEXT_ALIGN ENUM but TEXT_ALIGN_CENTER uses mouse pos
function PANEL_META:eAddHint(text, font, align, parent_panel)
    return self:eSetHoverPanel(function(hovered_panel)
        local pnl = vgui.Create("esclib.hint_panel", parent_panel)
        pnl:Setup(text, font, align, parent_panel, hovered_panel)
        return pnl
    end, true)
end


---------------------
--# QUICK WINDOWS #--
---------------------
function esclib:GenerateBGClicker(key_input)
	local clr = esclib.addon:GetColors()

	local scrw,scrh = esclib.scrw,esclib.scrh
	local bg = vgui.Create("EditablePanel")
	bg:SetSize(scrw,scrh)
	bg:MakePopup()
	bg:SetKeyboardInputEnabled(key_input or false)
	bg:SetAlpha(0)
	bg:AlphaTo(255,0.1)
	bg:SetZPos(102)
	function bg:Paint(w,h)
		draw.RoundedBox(0, 0,0,w,h, clr.background.col)
	end

	function bg:Close()
		if self.OnClose then self:OnClose() end
		self:AlphaTo(0,esclib.addon:GetVar("animtime") or 0.01,0,function()
			self:Remove()
		end)
	end

	function bg:OnMousePressed(key)
		self:Close()
	end

	function bg:OnKeyCodePressed(key)
		if (key == KEY_F4) or (key == KEY_ESCAPE) then
			self:Close()
		end
	end

	return bg
end



function esclib:GeneratePopWindow(key_input)
	self.ready2close = false

	local clr = esclib.addon:GetColors()

	local scrw,scrh = esclib.scrw,esclib.scrh
	local bg = self:GenerateBGClicker(key_input)

	local pnl = vgui.Create("esclib.frame",bg)
	pnl.bg = bg
	pnl:SetSize(scrw*0.3, scrh*0.2)
	pnl:Center()
	function pnl:OnRemove()
		bg:Remove()
	end

	function pnl:Close()
		bg:Close()
	end
	
	return pnl
end


-- EXAMPLE
-- esclib:TextInputWindow("title", "text", false, false, function(result)
-- 	print(result)
-- end, function()
-- 	return true
-- end)
function esclib:TextInputWindow(title, text, is_multiline, is_numeric, callback, custom_check, try_language)
    local wide = esclib.scrw * 0.35
    local tall = 0
	if is_numeric then is_multiline = false end
    local font = esclib:AdaptiveFont("esclib", 20, 500)
    local multiline_data = esclib.text:Multiline(text, font, wide)
	local font_height = draw.GetFontHeight(font)
    local clr = esclib.addon:GetColors()

    local pnl = self:GeneratePopWindow()
    pnl:SetTitle(title)
    pnl:SetSize(wide, esclib.scrh * 0.3)
    pnl:Center()
    pnl:SetRoundSize(8)
	pnl:SetGradientColor(clr.frame.bg)
	pnl:SetColorThink(true)
	pnl:SetAutoRestoreColor(true)
    local content = pnl:GetContent()

    local lbl = content:Add("DPanel")
    lbl:SetSize(wide, multiline_data.height + 5)
    lbl:Dock(TOP)
    lbl:DockMargin(0, 10, 0, 0)
    function lbl:Paint(w, h)
        esclib.text:DrawMultiline(multiline_data, w * 0.5, 0, clr.frame.text, TEXT_ALIGN_CENTER)
    end
    tall = tall + lbl:GetTall() + 20

	local offset = 10
	local input_base = content:Add("DPanel")
	if not is_multiline then
		input_base:SetSize(wide - offset * 2, font_height+offset+4)
	else
		input_base:SetSize(wide - offset * 2, font_height*2+offset+4)
	end
    input_base:Dock(TOP)
    input_base:DockMargin(10, 5, 10, 5)
	function input_base:Paint(w,h)
		draw.RoundedBox(8, 0, 0, w, h, clr.frame.accent)
	end

    local textinput = input_base:Add("DTextEntry")
    textinput:Dock(FILL)
	textinput:DockMargin(5,5,5,5)
    textinput:SetFont(font)
    textinput:SetTextColor(clr.frame.text)
	if is_multiline then
		textinput:SetMultiline(true)
		textinput:SetVerticalScrollbarEnabled(true)
	end

    tall = tall + input_base:GetTall() + 10

    if is_numeric then
        textinput:SetPlaceholderText("500")
        textinput:SetNumeric(true)
        function textinput:AllowInput(str)
            local disallow = true
            local text = self:GetText()

            if string.find(str, "%d") or (str == ".") then
                if string.find(text, "%.") then
                    return str == "."
                end

                disallow = false
            end

            return disallow
        end
    end

    function textinput:Paint(w, h)
        -- draw.RoundedBox(0, 0, 0, w, h, clr.frame.accent)

        local textcol = self:GetTextColor()
        self:DrawTextEntryText(textcol, clr.frame.text_hover, textcol)
    end

    function textinput:OnGetFocus()
        pnl.bg:SetKeyboardInputEnabled(true)
    end

    function textinput:OnLoseFocus()
        pnl.bg:SetKeyboardInputEnabled(false)
    end

    function textinput:Shake()
        local x = input_base:GetX()
        local copy_clr = table.Copy(self:GetTextColor())
        local anim = self:NewAnimation(0.2, 0, -1, function(anim, pnl)
            input_base:SetX(x)
            self:SetTextColor(copy_clr)
            input_base:Dock(TOP)
        end)

        anim.Think = function(anim, pnl, fraction)
            local sin_v = math.sin(Lerp(fraction, -math.pi, math.pi))
            copy_clr.g = math.Clamp(copy_clr.g + sin_v * 50, 0, 255)
            copy_clr.b = math.Clamp(copy_clr.b + sin_v * 50, 0, 255)
            pnl:SetTextColor(copy_clr)
            input_base:SetPos(x + sin_v * 10, input_base:GetY())
        end
    end

    function textinput:OnEnter(text)
        if isfunction(custom_check) then
            local custom_check = custom_check(text)

            if custom_check then
                self:Shake()
                return
            end
        end
        if is_numeric then
            callback(self:GetFloat() or 0)
        else
            callback(text)
        end
        pnl:Close()
    end

    local buttonlist = content:Add("DPanel")
    buttonlist:SetSize(content:GetWide(), content:GetTall() * 0.15)
    buttonlist:Dock(BOTTOM)
    buttonlist:DockMargin(0, 10, 0, 10)
    buttonlist.Paint = nil

    tall = tall + content:GetTall() * 0.18 + 40

    local border = 25
    local revert = buttonlist:Add("esclib.button")
    revert:SetText(esclib.addon:Translate("button_Discard", try_language))
    revert:SetSize(buttonlist:GetWide() * 0.5 - border, buttonlist:GetTall())
    revert:SetX(border * 0.5)
    revert:SetIcon(esclib:GetMaterial("cross.png"))
    revert:SetIconColor(clr.button.discard)
    function revert:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.discard_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)

		if hovered then pnl:SetTargetGradientColor(clr.button.discard_hover) end
    end
    function revert:DoClick()
        pnl:Close()
    end

    local confirm = buttonlist:Add("esclib.button")
    confirm:SetSize(revert:GetWide(), revert:GetTall())
    confirm:SetX(revert:GetX() + revert:GetWide() + border)
    confirm:SetText(esclib.addon:Translate("button_Confirm", try_language))
    confirm:SetIcon(esclib:GetMaterial("true.png"))
    confirm:SetIconColor(clr.button.apply)
    function confirm:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.apply_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)

		if hovered then pnl:SetTargetGradientColor(clr.button.apply_hover) end
    end
    function confirm:DoClick()
        textinput:OnEnter(textinput:GetText())
    end

    pnl:SetTall(tall)

    return textinput
end


function esclib:ConfirmWindow(title, text, callback)
	local clr = esclib.addon:GetColors()
	local font = esclib:AdaptiveFont("esclib", 20, 500)
	
	local pnl = self:GeneratePopWindow(false)
	pnl:SetTitle(title)
	pnl:SetSize(esclib:AdaptiveSize(500),esclib:AdaptiveSize(150))
	pnl:Center()
	pnl:SetRoundSize(8)
	pnl:SetGradientColor(clr.frame.bg)
	pnl:SetColorThink(true)
	pnl:SetAutoRestoreColor(true)
	local content = pnl:GetContent()
	local tall = 0
	local border = 8
	local answered = false

	function pnl:OnRemove()
		if not answered then callback(false) end
	end

	if text ~= "" then
		local multiline_data = esclib.text:Multiline(text, font, content:GetWide())
		local lbl = content:Add("DPanel")
		lbl:SetSize(content:GetWide(), multiline_data.height+border)
		function lbl:Paint(w,h)
			esclib.text:DrawMultiline(multiline_data, w * 0.5, border, clr.frame.text, TEXT_ALIGN_CENTER)
		end
		tall = tall + lbl:GetTall()
	end
	
	tall = tall + pnl.titlepanel:GetTall() + border*2

	local buttonlist = content:Add("DPanel")
	buttonlist:SetSize(content:GetWide(), content:GetTall()*0.4)
	buttonlist:Dock(BOTTOM)
	buttonlist:DockMargin(border,0,border,border)
	buttonlist.Paint = nil

	tall = tall + buttonlist:GetTall()

	local revert = buttonlist:Add("esclib.button")
	revert:SetText(esclib.addon:Translate("button_Discard"))
	revert:SetSize( buttonlist:GetWide()*0.5-border,buttonlist:GetTall() )
	revert:SetIcon(esclib:GetMaterial("cross.png"))
    revert:SetIconColor(clr.button.discard)
	revert:Dock(LEFT)
	revert:DockMargin(0,0,border,0)
	function revert:DoClick()
		answered = true
		callback(false)
		pnl:Close()
	end
	function revert:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.discard_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)

		if hovered then pnl:SetTargetGradientColor(clr.button.discard_hover) end
    end

	local confirm = buttonlist:Add("esclib.button")
	confirm:SetSize(revert:GetWide()-border,revert:GetTall())
	confirm:SetX(revert:GetX() + revert:GetWide())
	confirm:SetText(esclib.addon:Translate("button_Confirm"))
	confirm:SetIcon(esclib:GetMaterial("true.png"))
    confirm:SetIconColor(clr.button.apply)
	confirm:Dock(LEFT)
	function confirm:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.apply_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)

		if hovered then pnl:SetTargetGradientColor(clr.button.apply_hover) end
    end
	
	function confirm:DoClick()
		answered = true
		callback(true)
		pnl:Close()
	end

	pnl:SetTall(tall)
end

--sel_count - bool or number | if false then only 1 can be selected
--selected - already selected values or value
function esclib:ChoiceMenu(title,items,max_selections,item_paint,callback,custom_filter,need_search,selected_values, wide)
	local items_list
	if not istable(items) then 
		if isfunction(items) then
			items_list = items()
		end
	else
		items_list = items
	end

	if items_list then
		if not istable(items_list) then return end
	else
		return
	end

	local items_list = table.Copy(items)
	if table.IsEmpty(items_list) then callback() return end
	
	local clr = esclib.addon:GetColors()
	local ply = LocalPlayer()

	local pnl = self:GeneratePopWindow()
	pnl:SetSize(wide or esclib.scrw*0.4,esclib.scrh*0.9)
	local base_tall = pnl:GetTall()
	pnl:Center()
	pnl:SetRoundSize(16)
	local content = pnl:GetContent()

	local top_bar = content:Add("DPanel")
	if need_search ~= false then
		top_bar:SetSize(content:GetWide(),content:GetTall()*0.05)
		top_bar:SetY(10)
	else
		top_bar:SetHeight(0)
		top_bar:Hide()
	end

	local font_door = esclib:AdaptiveFont("esclib", 20, 500)
	local textinput = top_bar:Add("DTextEntry")
	local offset = esclib.util.GetTextSize(esclib.addon:Translate("phrase_Search"),font_door).w + 25
	textinput:SetSize(top_bar:GetWide()-offset-10,top_bar:GetTall())
	textinput:SetX(offset)
	textinput:CenterVertical(0.45)
	textinput:SetFont(font_door)
	textinput:SetTextColor(clr.frame.text)

	function textinput:OnGetFocus()
		pnl.bg:SetKeyboardInputEnabled(true)
	end

	function textinput:OnLoseFocus()
		pnl.bg:SetKeyboardInputEnabled(false)
	end


	function top_bar:Paint(w,h)
		draw.SimpleText(esclib.addon:Translate("phrase_Search")..":",font_door, 10, h*0.5-2,clr.frame.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
	end

	function textinput:Paint(w,h)
		draw.RoundedBox(16,0,0,w,h,clr.frame.accent)

		local textcol = self:GetTextColor()
		self:DrawTextEntryText( textcol, clr.frame.text_hover, textcol )
	end

	local selected
	local max_values = 1

	if isnumber(max_selections) and max_selections ~= 1 then
		max_values = max_selections
		max_selections = true
	else
		max_selections = false
		max_values = 1
	end

	local border = 25
	local bot_bar = content:Add("DPanel")
	bot_bar:SetSize(content:GetWide(),content:GetTall()*0.07)
	bot_bar:Dock(BOTTOM)
	bot_bar:SetMouseInputEnabled(true)
	bot_bar:SetZPos(10)
	function bot_bar:Paint(w,h)
		draw.RoundedBoxEx(16,0,0,w,h,clr.frame.accent,false,false,true,true)
	end
	if not max_selections then
		bot_bar:Hide()
	end

	local scroll = content:Add("esclib.scrollpanel")
	if top_bar:IsVisible() then
		scroll:SetY(top_bar:GetY()+top_bar:GetTall()+5)
	end
	scroll:SetSize(content:GetWide(),content:GetTall()-top_bar:GetTall()-bot_bar:GetTall()-20)

	local list = scroll:Add("DIconLayout")
	list:SetBorder(5)
	list:SetWide(content:GetWide())
	list:SetStretchHeight(true)
	list:SetSpaceY(5)

	
	local cur_count = 0
	if max_selections then
		selected = istable(selected_values) and table.Copy(selected_values) or {}
		cur_count = table.Count(selected)
	else
		selected = selected_values and selected_values or nil
	end

	local function UpdateTitle()
		pnl:SetTitle(("(%d/%d) "):format(cur_count, max_values)..title)
	end
	UpdateTitle()


	function list:eClear()
		for k,v in ipairs(self:GetChildren()) do
			v:Remove()
		end
	end

    local revert = bot_bar:Add("esclib.button")
    revert:SetText(esclib.addon:Translate("button_Discard", try_language))
    revert:SetSize(bot_bar:GetWide() * 0.5 - border, bot_bar:GetTall()*0.6)
    revert:SetX(border * 0.5)
	revert:SetY(bot_bar:GetTall()*0.5 - revert:GetTall()*0.5)
    revert:SetIcon(esclib:GetMaterial("cross.png"))
    revert:SetIconColor(clr.button.discard)
    function revert:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.discard_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)
    end
    function revert:DoClick()
        callback()
		pnl:Close()
    end

    local confirm = bot_bar:Add("esclib.button")
    confirm:SetSize(revert:GetWide(), revert:GetTall())
    confirm:SetX(revert:GetX() + revert:GetWide() + border)
	confirm:SetY(bot_bar:GetTall()*0.5 - confirm:GetTall()*0.5)
    confirm:SetText(esclib.addon:Translate("button_Confirm", try_language))
    confirm:SetIcon(esclib:GetMaterial("true.png"))
    confirm:SetIconColor(clr.button.apply)
    function confirm:PaintBackground(w, h)
        local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, hovered and clr.button.apply_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)
    end
    function confirm:DoClick()
        if istable(selected) then
			if table.IsEmpty(selected) then
				selected = nil
			else
				selected = table.ClearKeys(selected)
			end
		end

		callback(selected)
		pnl:Close()
    end

	local function Update()
		local filter = string.lower(textinput:GetValue())


		local has_results = false
		for k,name in ipairs(items_list) do
			if custom_filter then
				if isfunction(custom_filter) then
					if not custom_filter(name,(filter or "")) then continue end
				end
			else
				if type(name) == "string" then
					if (not string.find(string.lower(name),filter)) then continue end
				end
			end

			local player_panel = list:Add("DButton")
			player_panel:SetSize(scroll:GetWide()-list:GetBorder()*2,scroll:GetTall()*0.07)
			player_panel:SetText("")

			local font = esclib:AdaptiveFont("esclib", 24, 500)
			function player_panel:Paint(w,h)
				local active
				if selected ~= nil and max_selections then 
					active = selected[name] 
				else
					active = (selected == name)
				end

				if item_paint then
					if isfunction(item_paint) then item_paint(self, w,h, name, active) end
				else
					local hovered = self:IsHovered()

					draw.RoundedBox(0,0,0,w,h,hovered and clr.button.hover or clr.button.main)
					if active then
						draw.RoundedBox(0,0,0,5,h,clr.button.apply)
					end

					draw.SimpleText(name,font,w*0.5,h*0.5,hovered and clr.button.text_hover or clr.button.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
			end
			function player_panel:DoClick()
				if max_selections then
					if selected[name] then 
						selected[name] = nil
						cur_count = cur_count - 1
						UpdateTitle()
						return 
					end
					
					if cur_count < max_values then
						selected[name] = name
						cur_count = cur_count + 1
					end
				else
					selected = name
					cur_count = 1
					confirm:DoClick()
				end

				UpdateTitle()
			end
			has_results = true
		end

		local font = esclib:AdaptiveFont("esclib", 24, 500)
		if not has_results then
			local player_panel = list:Add("DPanel")
			player_panel:SetSize(scroll:GetWide(),scroll:GetTall()*0.07)
			player_panel:SetText("")

			function player_panel:Paint(w,h)
				-- draw.RoundedBox(0,0,0,w,h,clr.button.main)

				draw.SimpleText(esclib.addon:Translate("phrase_NoResults"),font,w*0.5,h*0.5,hovered and clr.button.text_hover or clr.button.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end

			return
		end

		timer.Simple(0, function()
			local tall = list:GetTall() + pnl.titlepanel:GetTall() + list:GetBorder()

			if textinput:IsVisible() then
				tall = tall + textinput:GetTall()
			end

			if top_bar:IsVisible() then
				tall = tall + top_bar:GetTall()
			end

			if bot_bar:IsVisible() then
				tall = tall + bot_bar:GetTall()
			end

			pnl:SetTall( math.min(tall, base_tall) )
			pnl:Center()
		end)

	end

	Update()

	function textinput:OnChange()
		list:eClear()
		Update()
	end

	return pnl
end

function esclib:PlayerSelectWindow(title,multi,hide_self,callback,custom_filter)
	local player_list = player.GetAll()
	table.sort(player_list, function(a,b) return a:Nick() < b:Nick() end)

	local filter_func = function(ply,filter)
		if not IsValid(ply) then return false end
		if hide_self then 
			if ply:Name() == LocalPlayer():Name() then return false end
		end

		local res = false

		if ply.Name then
			res = string.find(string.lower(ply:Name()),filter)
		else
			res = (filter == "")
		end

		if custom_filter then
			if isfunction(custom_filter) then
				if not custom_filter(ply) then res = false end
			end
		end

		return res
	end

	local font = esclib:AdaptiveFont("esclib", 24, 500)
	local player_paint = function(self,w,h,ply,active)
		local hovered = self:IsHovered()
		local clr = esclib.addon:GetColors()

		local hovered = self:IsHovered()
        draw.RoundedBox(8, 0, 0, w, h, (hovered or active) and clr.button.apply_hover or clr.button.hover)
        draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.button.hover or clr.button.main)

		-- draw.RoundedBox(0,0,0,w,h,hovered and clr.button.hover or clr.button.main)
		-- if active then
		-- 	draw.RoundedBox(0,0,0,5,h,clr.button.apply)
		-- end

		draw.SimpleText(ply:Name(),font,15,h*0.5,hovered and clr.button.text_hover or clr.button.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		if DarkRP then
			local jobclr = team.GetColor(ply:Team()) or color_white
			draw.SimpleText(ply:getDarkRPVar("job"),font,w-15,h*0.5,jobclr, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
	end

	local return_result = function(result)
		callback(result)
	end

	-- function esclib:ChoiceMenu(title,items,max_selections,item_paint,callback,custom_filter,need_search, selected_values)
	esclib:ChoiceMenu(title, player_list, multi, player_paint, return_result, filter_func, true)
end

--https://github.com/Be1zebub/Small-GLua-Things/blob/54ce959d8375c1c94d077f7ed1a94095b7ed62d0/ui_animations.lua
function esclib:NewAnimation(length, delay, ease, onend, think_fn)
    ease = ease or -1
    delay = delay or 0

    local systime = SysTime()
    local starttime, endtime = systime + delay, systime + delay + length
    local h_name = "esclib.animation."..starttime.."." ..endtime.."."..random(-1000,1000)
    local fraction, frac

    hook.Add("Think", h_name, function()
        systime = SysTime()
        if starttime > systime then return end

        fraction = clamp(TimeFraction(starttime, endtime, systime), 0, 1)

        if ease < 0 then
            frac = fraction ^ (1 - fraction - 0.5)
        elseif ease > 0 and ease < 1 then
            frac = 1 - (1 - fraction) ^ (1 / ease)
        end

        if fraction == 1 or think_fn(frac) then
            if onend then onend() end
            hook.Remove("Think", h_name)
        end
    end)
    
    return function()
		if onend then onend() end
    	hook.Remove("Think", h_name)
    end
end
--PATH addons/____esclib/lua/elib/vgui/esc_dvscrollbar.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_HideButtons", "HideButtons" )
AccessorFunc( PANEL, "color", "Color", FORCE_COLOR )

function PANEL:Init()

	self.skin = esclib.addon:GetCurrentSkin()

	self.Offset = 0
	self.Scroll = 0
	self.CanvasSize = 1
	self.BarSize = 1

	self.scroll_speed = 0.5
	self.scrollspeed = 20
	self.scrollsoftness = 0.15 --the smaller the softer

	self.btnUp = vgui.Create( "DButton", self )
	self.btnUp:SetText( "" )
	self.btnUp.DoClick = function( self ) self:GetParent():AddScroll( -1 ) end
	self.btnUp.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ButtonUp", panel, w, h ) end

	self.btnDown = vgui.Create( "DButton", self )
	self.btnDown:SetText( "" )
	self.btnDown.DoClick = function( self ) self:GetParent():AddScroll( 1 ) end
	self.btnDown.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ButtonDown", panel, w, h ) end

	self.btnGrip = vgui.Create( "DScrollBarGrip", self )
	self:SetColor(self.skin.colors.button.hover)
    self.btnGrip.Paint = function( pnl, w, h ) 
    	draw.RoundedBox(0,0,0,w,h, self.color)
    end

	self:SetSize( 5, 15 )
	self:SetHideButtons( true )
end

function PANEL:SetSpeed(num)
	self.scrollspeed = num
end

function PANEL:GetSpeed()
	return self.scrollspeed
end

function PANEL:SetSoftness(num)
	self.scrollsoftness = num
end

function PANEL:GetSoftness()
	return self.scrollsoftness
end


function PANEL:SetEnabled( b )
	if not ( b ) then
		self.Offset = 0
		self:SetScroll( 0 )
		self.HasChanged = true
	end

	self:SetMouseInputEnabled( b )
	self:SetVisible( b )

	if ( self.Enabled ~= b ) then
		self:GetParent():InvalidateLayout()
		if ( self:GetParent().OnScrollbarAppear ) then
			self:GetParent():OnScrollbarAppear()
		end
	end

	self.Enabled = b
end

function PANEL:Value()
	return self.Pos
end

function PANEL:BarScale()
	if ( self.BarSize == 0 ) then return 1 end
	return self.BarSize / ( self.CanvasSize + self.BarSize )
end

function PANEL:SetUp( _barsize_, _canvassize_ )
	self.BarSize = _barsize_
	self.CanvasSize = math.max( _canvassize_ - _barsize_, 1 )
	self:SetEnabled( _canvassize_ > _barsize_ )
	self:InvalidateLayout()
end

function PANEL:SetScroll( scrll )
	-- if ( not self.Enabled ) then self.Scroll = 0 return end
	self.Scroll = math.Clamp( scrll, 0, self.CanvasSize )
	self:InvalidateLayout()

	local func = self:GetParent().OnVScroll
	if ( func ) then
		func( self:GetParent(), self:GetOffset() )
	else
		self:GetParent():InvalidateLayout()
	end
end

function PANEL:OnMouseWheeled( dlta )
	if ( not self:IsVisible() ) then return false end

	self.scroll_speed = self.scroll_speed + (6 * RealFrameTime()) --gain

	return self:AddScroll( dlta * -self.scroll_speed )
end

function PANEL:AddScroll( dlta )
	local OldScroll = self:GetScroll()
	dlta = dlta * (self.scrollspeed)
	self.Scroll2Add = dlta

	return OldScroll ~= self:GetScroll()
end

function PANEL:Think()

	if self.Scroll2Add then
		local oldscroll = self:GetScroll()
		local newscroll = self:GetScroll() + self.Scroll2Add

		-- print(newscroll)
		self:SetScroll( newscroll )
		self.Scroll2Add = self.Scroll2Add - self.Scroll2Add*self.scrollsoftness

		if math.floor(self:GetScroll()) == math.floor(oldscroll) then self.Scroll2Add = nil end
	end

	-- if (self.Scroll > self.CanvasSize) then
	-- 	self:SetScroll( self:GetScroll() - (self.Scroll-self.CanvasSize)*0.08)
	-- end

	if (self.Scroll < 0) then
		self:SetScroll( self:GetScroll() + 5 )
	end

	self.scroll_speed = Lerp(RealFrameTime(), self.scroll_speed, 0.2)
end

function PANEL:AnimateTo( scrll, length, delay, ease )

	local anim = self:NewAnimation( length, delay, ease )
	anim.StartPos = self.Scroll
	anim.TargetPos = scrll
	anim.Think = function( anim, pnl, fraction )
		pnl:SetScroll( Lerp( fraction, anim.StartPos, anim.TargetPos ) )
	end

end

function PANEL:GetScroll()
	if ( not self.Enabled ) then self.Scroll = 0 end
	return self.Scroll

end

function PANEL:GetOffset()

	if ( not self.Enabled ) then return 0 end
	return self.Scroll * -1

end

function PANEL:ScrollToBottom()
	self:InvalidateParent(true)
	self.Scroll = self.CanvasSize
end


function PANEL:Paint( w, h )
end

function PANEL:OnMousePressed()
	local x, y = self:CursorPos()
	local PageSize = self.BarSize
	if ( y > self.btnGrip.y ) then
		self:SetScroll( self:GetScroll() + PageSize )
	else
		self:SetScroll( self:GetScroll() - PageSize )
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = false
	self.DraggingCanvas = nil
	self:MouseCapture( false )

	self.btnGrip.Depressed = false
end

function PANEL:OnCursorMoved( x, y )
	if ( not self.Enabled ) then return end
	if ( not self.Dragging ) then return end

	local x, y = self:ScreenToLocal( 0, gui.MouseY() )

	-- Uck.
	y = y - self.btnUp:GetTall()
	y = y - self.HoldPos

	local BtnHeight = self:GetWide()
	if ( self:GetHideButtons() ) then BtnHeight = 0 end

	local TrackSize = self:GetTall() - BtnHeight * 2 - self.btnGrip:GetTall()

	y = y / TrackSize

	self:SetScroll( y * self.CanvasSize )
end

function PANEL:Grip()

	if ( not self.Enabled ) then return end
	if ( self.BarSize == 0 ) then return end

	self:MouseCapture( true )
	self.Dragging = true

	local x, y = self.btnGrip:ScreenToLocal( 0, gui.MouseY() )
	self.HoldPos = y

	self.btnGrip.Depressed = true

end

function PANEL:PerformLayout()

	local Wide = self:GetWide()
	local BtnHeight = Wide
	if ( self:GetHideButtons() ) then BtnHeight = 0 end
	local Scroll = self:GetScroll() / self.CanvasSize
	local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
	local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
	Track = Track + 1

	Scroll = Scroll * Track

	self.btnGrip:SetPos( 0, BtnHeight + Scroll )
	self.btnGrip:SetSize( Wide, BarSize )

	if ( BtnHeight > 0 ) then
		self.btnUp:SetPos( 0, 0, Wide, Wide )
		self.btnUp:SetSize( Wide, BtnHeight )

		self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
		self.btnDown:SetSize( Wide, BtnHeight )
		
		self.btnUp:SetVisible( true )
		self.btnDown:SetVisible( true )
	else
		self.btnUp:SetVisible( false )
		self.btnDown:SetVisible( false )
		self.btnDown:SetSize( Wide, BtnHeight )
		self.btnUp:SetSize( Wide, BtnHeight )
	end

end

derma.DefineControl( "esclib.scrollbar", "A Scrollbar for esclib", PANEL, "Panel" )
--PATH addons/____esclib/lua/elib/essentials/settings_menu/esc_settings_typemeta.lua:
local gsub = string.gsub

esclib.allowed_settings_types = esclib.allowed_settings_types or {}
esclib.settings_shared_funcs = esclib.settings_shared_funcs or {}

local function Capitalize(str)
	return (gsub(str, "^%l", string.upper))
end


local TYPE_META = {}
-- TYPE_META["__index"] = TYPE_META

function TYPE_META:Require(var, is_soft)

	if isfunction(is_soft) then
		self[var] = function(var_meta, ...)
			esclib:SafeMerge(self, var_meta, true)
			var_meta[var] = is_soft(self, ...)
			return var_meta
		end
	else
		local var_name = tostring(var)
		local func_name = string.format("Set%s",Capitalize(var_name))
		self[func_name] = function(var_meta, var)
			var_meta[var_name] = var
			return var_meta
		end

		if is_soft then
			table.insert(self["secondary_vars"], var_name)
		else
			table.insert(self["important_vars"], var_name)
		end
	end
end

function TYPE_META:SoftRequire(var)
	self:Require(var, true)
end

function esclib:RegisterSettingsType(name)
	local new_type = {}
	new_type["important_vars"] = {}
	new_type["secondary_vars"] = {}

	esclib:SafeMerge(new_type, TYPE_META, true)

	self.allowed_settings_types[name] = new_type
	return new_type
end

------------------------
--# SHARED FUNCTIONS #--
------------------------
local function tablesAreEqual(table1, table2)
	for k, v in pairs(table1) do
		if type(v) ~= type(table2[k]) then return false end
		if istable(v) and istable(table2[k]) then
			if not tablesAreEqual(v, table2[k]) then
				return false
			end
		elseif table2[k] ~= v then
			return false
		end
	end

	for k, _ in pairs(table2) do
		if table1[k] == nil then
			return false
		end
	end

	return true
end

function esclib.settings_shared_funcs.VarsIsEqual(var1, var2)
	if type(var1) ~= type(var2) then return false end
	if istable(var1) and istable(var2) then return tablesAreEqual(var1, var2) end
	return var1 == var2
end
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual

function esclib.settings_shared_funcs.SharedDoRightClick(self, settab, name, addon, varid, varc, def_val, callback)
	local clr = esclib.addon:GetColors()
	local context = settab:Add("esclib.contextmenu")
	local mx, my = input.GetCursorPos()
	context:SetPosClamped(mx+5,my+5)
	context:AddHeader(name)

	context:AddSeparator()

	local edit_text = esclib.addon:Translate("button_Edit", addon:GetLanguage())
	context:AddButton(edit_text, function()
		self:DoClick()
	end, esclib:GetMaterial("wrench.png"))

	if def_val ~= nil then
		local set_default = esclib.addon:Translate("phrase_ReturnDefault", addon:GetLanguage())
		local vars_equal = VarsIsEqual(def_val, varc.value)

		local btn = context:AddButton(set_default, function()
			if istable(def_val) then
				varc.value = table.Copy(def_val)
			else
				varc.value = def_val
			end
			callback(varid,varc.value)
		end, esclib:GetMaterial("revert.png"))

		if vars_equal then
			btn:SetMouseInputEnabled(false)
			btn:SetTextColor(clr.button.text_gray)
		end
	end

	context:SetZPos(10)
	return context
end

function esclib.settings_shared_funcs.draw_bg(w,h,hovered,clr, is_changed)
	if is_changed then
		draw.RoundedBox(8,0,0,w,h, clr.button.discard)
		draw.RoundedBox(6,2,2,w-4,h-4,hovered and clr.button.hover or clr.button.main)
	else
		draw.RoundedBox(8,0,0,w,h,clr.button.hover)
		draw.RoundedBox(6,2,2,w-4,h-4,hovered and clr.button.hover or clr.button.main)
	end
end
--PATH addons/____esclib/lua/elib/essentials/settings_menu/settings_types/esc_type_bool.lua:
local draw_bg = esclib.settings_shared_funcs.draw_bg
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual
local SharedDoRightClick = esclib.settings_shared_funcs.SharedDoRightClick

------------
--# BOOL #--
------------
local stype = esclib:RegisterSettingsType("bool")
stype:Require("value")
function stype:Build( parent ) --not used on serverside
	local addon     = parent.addon
	local varid     = parent.var_uid
	local varc      = parent.var
	local callback  = parent.ApplyValue
	local vars_copy = parent.initial_values
	local settab    = parent.bg
	local def_val   = parent.default_value

	--other: button_wide / button_tall / current_vars_copy
	local button_wide = parent:GetWide()
	local button_tall = parent:GetTall()

	local clr = esclib.addon:GetColors()

	local name_tr  = varc.name or addon:Translate(varc.name_tr)
	local desc = varc.desc or addon:Translate(varc.desc_tr)
	if (varc.change_type == "usergroup") or (varc.change_type == "steamid") then
		if varc.who_can_change and istable(varc.who_can_change) then
			if not desc then desc = "" end
			desc = desc.." "..esclib.addon:Translate("phrase_WhoCanChange")..": [ "
			for k,v in pairs(varc.who_can_change) do
				desc = desc..tostring(k).." "
			end
			desc = desc.." ]"
		end
	end

	if (varc.change_type == "boolean") then
		if not varc.who_can_change then
			if not desc then desc = "" end
			desc = desc.." "..esclib.addon:Translate("phrase_WhoCanChange")..": [ "..esclib.addon:Translate("phrase_NoOne").." ]"
		end
	end

	local offset_x = esclib:AdaptiveSize(10)
	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font2 = esclib:AdaptiveFont("esclib", 16, 500)
	local name = esclib.util:TextCutAccurate(name_tr, font, button_wide*0.8, "...")
	local desc_text = esclib.util:TextCutAccurate(desc or "", font2, button_wide*0.8, "...")

	local button = parent:Add("DButton")
	button:SetSize(button_wide, button_tall)
	button:SetText("")
	button.DoRightClick = function(self) SharedDoRightClick(self, settab, name_tr, addon, varid, varc, def_val, callback) end
	if desc then
		button:eAddHint(desc,esclib:AdaptiveFont("esclib", 20, 500),TEXT_ALIGN_TOP,settab)
	end

	function button:DoClick()
		varc.value = not varc.value
		callback(varid,varc.value)
	end

	local box_mat = esclib:GetMaterial("box.png")
	local true_mat = esclib:GetMaterial("true.png")
	function button:Paint(w,h)
		local hovered = self:IsHovered()
		local is_changed = varc.value ~= vars_copy[varid]

		draw_bg(w,h,hovered,clr,is_changed)

		if desc then
			draw.SimpleText(name,font,offset_x,h*0.2,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP)
			draw.SimpleText(desc_text,font2,offset_x,h*0.85,clr.button.text_gray,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM)
		else
			draw.SimpleText(name,font,offset_x,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
		end

		local checkbox_size = h*0.25
		esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size,  hovered and clr.button.main or clr.button.hover , box_mat)
		if varc.value then
			esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size*0.6, hovered and clr.button.accent_hover or clr.button.accent, true_mat)
		end
	end
end
--PATH addons/____esclib/lua/elib/config/esc_meta.lua:
esclib.addon = esclib:Addon("esclib")
esclib.addon:SetName("esclib")
esclib.addon:SetBranch("release")
esclib.addon:SetVersion("2.4.0")
esclib.addon:SetDescription("Brain for addons.")
esclib.addon:SetSortOrder(999) --go to the end)
esclib.addon:SetColor(Color(255,53,73))

if CLIENT then
	esclib.addon:SetThumbnail(esclib:GetMaterial("esclib_logo.png"))
end
--PATH addons/____esclib/lua/elib/config/esc_theme.lua:
local skin = {}
skin.roundsize = 8

skin.name = "Blackout"
skin.color = Color(13,13,13)
skin.colors = {}
skin.colors.background = {
	col = Color(23,23,24,200),
}
skin.colors.button = {
	main = Color(25, 25, 25),
	hover = Color(35, 35, 36),

	text = Color(160,160,160),
	text_hover = Color(225,225,255),
	text_gray = Color(100,100,100),

	discard = Color(252, 59, 80),
	discard_hover = Color(255, 80, 100),

	apply = Color(30, 215, 96),
	apply_hover = Color(70, 245, 136),

	accent = Color(36, 255, 164),
	accent_hover = Color(91, 255, 186),
}
skin.colors.frame = {
	bg = Color(21, 21, 21),
	accent = Color(41, 41, 41),
	accent2 = Color(30, 215, 96),

	text = Color(214, 214, 214),
	text_hover = Color(30, 215, 96),

	text_gray = Color(100,100,102),
}
skin.colors.hint = {
	bg = Color(25, 25, 25),
	bg2 = Color(49, 49, 51),
	text = Color(235,235,255)
}
esclib.addon:RegisterSkin("blackout", skin)


local skin = {}
skin.roundsize = 8

skin.name = "Whiteout"
skin.color = Color(255,255,255)
skin.colors = {}
skin.colors.background = {
	col = Color(150,150,170,70),
}
skin.colors.button = {
	main = Color(230, 230, 235, 250),
	hover = Color(255, 255, 255, 250),

	text = Color(13,13,13),
	text_hover = Color(30,30,35),
	text_gray = Color(0,0,0),

	discard = Color(252, 59, 80),
	discard_hover = Color(255, 80, 100),

	apply = Color(30, 215, 96),
	apply_hover = Color(50, 225, 116),

	accent = Color(24, 185, 118),
	accent_hover = Color(59, 173, 126),
}
skin.colors.frame = {
	bg = Color(170, 170, 195, 240),
	accent = Color(240, 240, 255),
	accent2 = Color(30, 215, 96),

	text = Color(13,13,13),
	text_hover = Color(35, 35, 35),

	text_gray = Color(50,50,55),
}
skin.colors.hint = {
	bg = Color(230, 230, 235),
	bg2 = Color(255, 255, 255),
	text = Color(13,13,13)
}
esclib.addon:RegisterSkin("whiteout", skin)

local skin = {}
skin.roundsize = 8

skin.name = "Monokai"
skin.color = Color(46, 46, 46)
skin.colors = {}
skin.colors.background = {
	col = Color(23,23,33,200),
}
skin.colors.button = {
	main = Color(60, 60, 57, 250),
	hover = Color(65, 65, 62, 250),

	text = Color(200,200,200),
	text_hover = Color(225,225,255),
	text_gray = Color(100,100,100),

	discard = Color(252, 59, 80),
	discard_hover = Color(255, 80, 100),

	apply = Color(30, 215, 96),
	apply_hover = Color(50, 225, 116),

	accent = Color(36, 255, 164),
	accent_hover = Color(91, 255, 186),
}
skin.colors.frame = {
	bg = Color(46, 46, 46, 250),
	accent = Color(67, 67, 66),
	accent2 = Color(30, 215, 96),

	text = Color(214, 214, 214),
	text_hover = Color(30, 215, 96),

	text_gray = Color(121, 121, 121),
}
skin.colors.hint = {
	bg = Color(23,23,30,250),
	bg2 = Color(45,45,48),
	text = Color(235,235,255)
}
esclib.addon:RegisterSkin("monokai", skin)


esclib.addon:SetDefaultSkin("blackout")

--PATH addons/____echat/lua/echat/config/ingame_config.lua:
local cfg = echat.config

--Init settings on client
local settings = esclib:InitSettings("echat", "client")

--Players can change this settings through menu!
--tab creating
local tab = settings:AddTab("general") --uid
tab:SetNameTranslateKey("s_tab_general") --key in language file
tab:SetPosition(1) --postion

tab:AddVar("chat_spacey", "numslider")
:SetNameTranslateKey("s_chat_spacey_name")
:SetDescTranslateKey("s_chat_spacey_desc")
:SetValue(cfg.chat_spacey)
:SetMin(0)
:SetMax(20)
:SetDecimals(0)
:SetStep(1)

tab:AddVar("msg_time", "numslider")
:SetNameTranslateKey("s_msg_time_name")
:SetDescTranslateKey("s_msg_time_desc")
:SetValue(cfg.message_time)
:SetMin(1)
:SetMax(30)
:SetDecimals(0)
:SetStep(1)

tab:AddVar("max_lines", "float")
:SetNameTranslateKey("s_max_lines_name")
:SetDescTranslateKey("s_max_lines_desc")
:SetValue(cfg.maximum_lines)
:SetMin(10)
:SetMax(2048)

tab:AddVar("autocomplete_count", "float")
:SetNameTranslateKey("s_autocomplete_count_name")
:SetDescTranslateKey("s_autocomplete_count_desc")
:SetValue(cfg.maximum_autocomplete_hints)
:SetMin(1)
:SetMax(512)

tab:AddVar("base_font_size", "numslider")
:SetNameTranslateKey("s_base_font_size_name")
:SetDescTranslateKey("s_base_font_size_desc")
:SetValue(cfg.base_font_size)
:SetMin(12)
:SetMax(48)
:SetDecimals(0)

tab:AddVar("clean_chat", "bool")
:SetNameTranslateKey("s_clean_chat_name")
:SetDescTranslateKey("s_clean_chat_desc")
:SetValue(cfg.clear_chat)

tab:AddVar("ambilight", "bool")
:SetNameTranslateKey("s_ambilight_name")
:SetValue(cfg.ambilight)

--new tab
local tab = settings:AddTab("location") --uid
tab:SetNameTranslateKey("s_tab_location") --key in language file
tab:SetPosition(2) --postion

tab:AddVar("pos_x", "numslider")
:SetNameTranslateKey("s_posx_name")
:SetDescTranslateKey("s_xywh_mod_name")
:SetValue(cfg.pos_x)
:SetMin(0)
:SetMax(1)
:SetDecimals(2)

tab:AddVar("pos_y", "numslider")
:SetNameTranslateKey("s_posy_name")
:SetDescTranslateKey("s_xywh_mod_name")
:SetValue(cfg.pos_y)
:SetMin(0)
:SetMax(1)
:SetDecimals(2)

tab:AddVar("size_w", "numslider")
:SetNameTranslateKey("s_sizew_name")
:SetDescTranslateKey("s_xywh_mod_name")
:SetValue(cfg.size_width)
:SetMin(0)
:SetMax(1)
:SetDecimals(2)

tab:AddVar("size_h", "numslider")
:SetNameTranslateKey("s_sizeh_name")
:SetDescTranslateKey("s_xywh_mod_name")
:SetValue(cfg.size_height)
:SetMin(0)
:SetMax(1)
:SetDecimals(2)

settings:End()


local settings = esclib:InitSettings("echat", "server")

local tab = settings:AddTab("general") --uid
tab:SetNameTranslateKey("s_tab_general") --key in language file
tab:SetPosition(1) --postion

tab:AddVar("ambilight_clr1", "clr")
:SetNameTranslateKey("s_ambilight_clr1_name")
:SetValue(cfg.ambilight_clr1)
:SetShared(true)

tab:AddVar("ambilight_clr2", "clr")
:SetNameTranslateKey("s_ambilight_clr2_name")
:SetValue(cfg.ambilight_clr2)
:SetShared(true)

tab:AddVar("chat_name", "str")
:SetNameTranslateKey("s_chat_name_name")
:SetValue(cfg.chat_name)
:SetMinimumCharCount(1)
:SetMaximumCharCount(128)
:SetPosition(1)
:SetShared(true) --make it accessible on client


settings:End()

--PATH addons/____echat/lua/echat/vgui/echat_choicelist.lua:
local PANEL = {}

function PANEL:Init()
    self.clr = echat.addon:GetColors()
    self.DropButton.Paint = self.PaintComboDownArrow

    self.TextColor = self.clr.main.text_gray
    self.TextColorHovered = self.clr.main.text
    self.BackgroundColor = self.clr.main.bg2
end

function PANEL:SetBackgroundColor(clr)
    self.BackgroundColor = clr
end

function PANEL:OpenMenu( pControlOpener )

    if ( pControlOpener && pControlOpener == self.TextEntry ) then
        return
    end

    -- Don't do anything if there aren't any options..
    if ( #self.Choices == 0 ) then return end

    -- If the menu still exists and hasn't been deleted
    -- then just close it and don't open a new one.
    if ( IsValid( self.Menu ) ) then
        self.Menu:Remove()
        self.Menu = nil
    end

    -- If we have a modal parent at some level, we gotta parent to that or our menu items are not gonna be selectable
    local parent = self
    while ( IsValid( parent ) && not parent:IsModal() ) do
        parent = parent:GetParent()
    end
    if ( not IsValid( parent ) ) then parent = self end

    self.Menu = vgui.Create("echat.menu", parent)
    self.Menu:SetWide(self:GetWide())

    if ( self:GetSortItems() ) then
        local sorted = {}
        for k, v in pairs( self.Choices ) do
            local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
            if ( string.len( val ) > 1 && not tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
            table.insert( sorted, { id = k, data = v, label = val } )
        end
        for k, v in SortedPairsByMemberValue( sorted, "label" ) do
            local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
            option:SetFont(self:GetFont())
            option:SetTextColor(self:GetTextColor())
            if ( self.ChoiceIcons[ v.id ] ) then
                option:SetIcon( self.ChoiceIcons[ v.id ] )
            end
            if ( self.Spacers[ v.id ] ) then
                self.Menu:AddSpacer()
            end
        end
    else
        for k, v in pairs( self.Choices ) do
            local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
            option:SetFont(self:GetFont())
            option:SetTextColor(self:GetTextColor())
            if ( self.ChoiceIcons[ k ] ) then
                option:SetIcon( self.ChoiceIcons[ k ] )
            end
            if ( self.Spacers[ k ] ) then
                self.Menu:AddSpacer()
            end
        end
    end

    local x, y = self:LocalToScreen( 0, 0 )

    self.Menu:InvalidateLayout(true)
    self.Menu:SetMinimumWidth( self:GetWide() )
    self.Menu:Open( x, y-self.Menu:GetTall(), false, self )

    self:OnMenuOpened( self.Menu )

end

function PANEL:Paint(w, h)
    draw.RoundedBox(0, 0, 0, w, h, self.BackgroundColor)
end

function PANEL.PaintComboDownArrow( panel, w, h )

    if IsValid(panel.ComboBox.Menu) then
        --font dont need to be adapted
        draw.SimpleText("▼","es_echat_12_500",w*0.5,h*0.5, panel.ComboBox.clr.main.accent, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    else
        draw.SimpleText("▲","es_echat_12_500",w*0.5,h*0.5, panel.ComboBox.clr.main.accent, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

end

vgui.Register("echat.choicelist", PANEL, "DComboBox")
