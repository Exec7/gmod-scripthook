--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 2/12 - 06/04/2025


--PATH lua/autorun/alarm.lua:
if !SERVER or game.GetMap() != "rp_kamino_extensive" then return end

sound.Add({
	name = "kamino_alarm",
	channel = CHAN_STATIC,
	volume = 0.7,
	level = 80,
	pitch = { 95 },
	sound = "mysounds/starwars/alarm3.wav"
})

sound.Add({
	name = "acclamator_alarm",
	channel = CHAN_STATIC,
	volume = 0.7,
	level = 80,
	pitch = { 95 },
	sound = "mysounds/starwars/alarm.wav"
})

local zones = {
    ["kamino"] = {
        {
            ["min"] = Vector(-8192,-8192,-13312),
            ["max"] = Vector( 8192, 8192,- 6656)
        }    
    },
    ["acclamator"] = {
        {  
            ["min"] = Vector(-5120,-8704,7168),
            ["max"] = Vector( 2048,-3584,9728)
        }
    }
}
 
local function InZone(ply)
    local pos = ply:GetPos()
 
    for zoneName, zones in pairs(zones) do
        for k, zone in pairs(zones) do
            if pos.x < zone.min.x then continue end
            if pos.y < zone.min.y then continue end
            if pos.z < zone.min.z then continue end
 
            if pos.x > zone.max.x then continue end
            if pos.y > zone.max.y then continue end
            if pos.z > zone.max.z then continue end
 
            return true, zoneName
        end
    end
 
    return false
end
 
local OldKaminoAlarm = false
local OldAcclamatorAlarm = false
local NextThink = 0
 
hook.Add("Think", "KaminoAlarm", function()
    if NextThink > CurTime() then return end
   
    if !isbool(KaminoAlarm) then
        KaminoAlarm = false
    end
    if !isbool(AcclamatorAlarm) then
        AcclamatorAlarm = false
    end
 
    for k, ply in pairs(player.GetAll()) do
        if !isbool(ply.InZone) then
            ply.InZone = false
        end
       
        local lastInZone = ply.InZone
        local inZone, zone = InZone(ply)
 
        --the kamino alarm was toggled
        if OldKaminoAlarm != KaminoAlarm then
            if KaminoAlarm and inZone and zone == "kamino" then
                ply:EmitSound("kamino_alarm")
            else
                ply:StopSound("kamino_alarm")
            end
           
            OldKaminoAlarm = KaminoAlarm
        end
 
        --the acclamator alarm was toggled
        if OldAcclamatorAlarm != AcclamatorAlarm then
            if AcclamatorAlarm and inZone and zone == "acclamator" then
                ply:EmitSound("acclamator_alarm")
            else
                ply:StopSound("acclamator_alarm")
            end
           
            OldAcclamatorAlarm = AcclamatorAlarm
        end
 
        --player entered or left a zone
        if lastInZone != inZone then
            if inZone then
                if zone == "kamino" and KaminoAlarm then
                    ply:EmitSound("kamino_alarm")
                elseif zone == "acclamator" and AcclamatorAlarm then
                    ply:EmitSound("acclamator_alarm")
                end
            else
                ply:StopSound("kamino_alarm")
                ply:StopSound("acclamator_alarm")
            end
        end
 
        ply.InZone = inZone
    end
 
    NextThink = CurTime() + 0.5
end)
--addons/arccw_weapons/lua/arccw/shared/explosives_sh_effects.lua:
game.AddParticles( "particles/apex_fx.pcf" )
game.AddParticles( "particles/melee_fx.pcf" )
game.AddParticles( "particles/cs_weapon_fx.pcf" )
game.AddParticles( "particles/inferno_fx.pcf" )
game.AddParticles( "particles/explosions_fx.pcf" )
--game.AddParticles( "particles/muzzleflashes_new.pcf" )

--NEW MUZZLES
PrecacheParticleSystem("wpn_muzzleflash_mgl_FULL")

--TRACERS
PrecacheParticleSystem("wpn_muzzleflash_dc17")


-- MISC
PrecacheParticleSystem("tfa_csgo_healnade")
PrecacheParticleSystem("tfa_apex_lstar_explode_core")
PrecacheParticleSystem("tfa_apex_arcstar_explode")
PrecacheParticleSystem("tfa_apex_frag_explode")
PrecacheParticleSystem("grenade_final")
PrecacheParticleSystem("tfa_apex_arcstar_impact")
PrecacheParticleSystem("tfa_apex_bocek_impact")
PrecacheParticleSystem("tfa_apex_bocek_trail")
PrecacheParticleSystem("tfa_apex_bullet_trail")
PrecacheParticleSystem("tfa_apex_bullet_energy_trail")
PrecacheParticleSystem("tfa_apex_bullet_sent_trail")
--addons/arccw_weapons/lua/arccw/shared/serv_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSERV = {}
GMSERV.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("serv_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SERVStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SERVStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SERVStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("SERV_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("SERV_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSERV:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSERV.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/15a_stock_short.lua:
att.PrintName = "15a Skeleton Stock"
att.PrintName = "Skeleton Stock for DC-15a. Improves speed with more recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15a_stock"}
att.ActivateElements = {"15a_stock_short"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.2
att.Mult_SpeedMult = 1.5
att.Mult_DrawTime = 0.65
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 1.30
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_masita_low.lua:
att.PrintName = "Low Compression"

att.SortOrder = 18
att.Icon = Material("interfaz/armas/sw_emitter2.png", "smooth mips")
att.Description = "Underpressured compression places less strain on the weapon, but lowers muzzle velocity and cyclic rate."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ammo_masita"

att.AutoStats = true

att.Mult_Recoil = 0.85
att.Mult_Range = 0.8

att.Mult_RPM = 0.95
att.Mult_ShootVol = 0.9
--att.Mult_ShootPitch = 1.05 please don't

att.Mult_MalfunctionMean = 1.15
att.Mult_PhysBulletMuzzleVelocity = 0.9
--lua/arccw/shared/attachments/arccw_titholo.lua:
att.PrintName = "Wonyeon Defense Holosight (2.1x)"
att.Icon = Material("entities/arccw_titholo.png", "mips smooth")
att.Description = "The preferred sight for many pilots due to its versatility, although it is slightly worst in close fights due to the higher zoom than the Lawai HCOG."

att.SortOrder = 4

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/optic_titholo.mdl"

att.AdditionalSights = {
    {
        Pos = Vector(0, 10, -1.35),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
        IgnoreExtra = true
    },
}

att.Holosight = true
att.HolosightReticle = Material("hud/holosight/tit_holo.png", "mips smooth")
att.HolosightNoFlare = true
att.HolosightSize = 2
att.HolosightBone = "holosight"
att.Colorable = true
att.ModelScale = Vector(1.4, 1.4, 1.4)

att.HolosightMagnification = 1

att.Mult_SightTime = 1.01

att.Colorable = false
--addons/arccw_weapons/lua/arccw/shared/attachments/cr2_barrel_extended.lua:
att.PrintName = "CR-2 Extended Barrel"
att.Description = ""
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_muzzle2.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"cr2_barrel"}
att.ActivateElements = {"cr2_barrel_extended"}

att.Mult_MoveSpeed = 0.9

att.Mult_Range = 1.25
att.Mult_Recoil = 0.95
att.Mult_SightTime = 1.35
att.Mult_AccuracyMOA = 0.75

att.Mult_ShootPitch = 0.9
att.Free = true
--addons/arccw_weapons/lua/arccw/shared/attachments/cr2_stock.lua:
att.PrintName = "CR-2 Stock"
att.PrintName = "Extended Stock for CR-2."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"cr2_stock"}
att.ActivateElements = {"cr2_stock"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.2
att.Mult_SpeedMult = 1.5
att.Mult_DrawTime = 0.65
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 1.30
att.Free = true
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_module_shotgun.lua:
att.PrintName = "Shotgun Module"
att.Icon = Material("entities/shotgun.png")
att.Description = "DC-17m Shotgun Module. Changes the main shoot to a shotgun round with multiple shoots. Close combat desired."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.NotForNPCs = true
att.AutoStats = true

att.Slot = "17m_module"
att.ActivateElements = {"17m_module_shotgun"}

att.Mult_ShootPitch = 0.9
att.Reload = 1.3
att.Mult_Penetration = 5
att.Override_Num = 4

att.Mult_DamageMin = 1.3
att.Mult_Damage = 1.3

att.Mult_Recoil = 1.2
att.Mult_SightTime = 1.2
att.Mult_RPM = 0.4
att.Mult_MuzzleVelocity = 2
att.Mult_SpeedMult = 1.15
att.Mult_AccuracyMOA = 10
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_dioxis.lua:
att.PrintName = "Grenade Launcher (Dioxis)"
att.Icon = Material("interfaz/armas/sw_stimpack.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Dioxis)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_poison", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_thermal.lua:
att.PrintName = "Grenade Launcher (Thermal)"
att.Icon = Material("interfaz/armas/sw_demolish.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Thermal)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_thermal", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_cr2_pistol_mod.lua:
att.PrintName = "CR-2 Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/cr2_pistol_barrel_default.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_dc15x_scope.lua:
att.PrintName = "DC-15X Scope"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/DLT19X_scope.mdl"
att.ModelOffset = Vector(0, 0, -0.1)
att.AdditionalSights = {
    {
        Pos = Vector(0, 12, -1.6),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 3,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true,
        ViewModelFOV = 40
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 11.92
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/DLT19X_scope_HSP.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 3
att.HolosightMagnificationMax = 7
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_sharpshooter.lua:
att.PrintName = "Sharpshooter"
att.Icon = Material("interfaz/iconos/kraken/sith snip marksmanship/233430474_1706893393.png")
att.Description = "You're a Sharpshooter, your shots will always be accurate alongside other benefits. Iron sights activate slowmo for better aim."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "Do not switch weapons when in slowmo!",
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true
att.Zedtime = 2

att.Mult_Damage = 1.05
att.Mult_DamageMin = 1.2

att.Mult_AccuracyMOA = 0.5
att.Mult_HipDispersion = 0.35
att.Mult_Range = 1
att.Mult_Penetration = 4

att.Hook_Compatible = function(wep)
    if (wep.Primary.Ammo ~= "SniperPenetratedRound" and wep.Primary.Ammo ~= "SniperRound" and wep.Primary.Ammo ~= "ar2") then return false end
end

--[[
att.Hook_Think = function(wep)
    if SERVER then
        if wep.Owner:KeyDown( IN_ATTACK2 ) then
            game.SetTimeScale(0.4)
        else
            game.SetTimeScale(1)
        end
    end
end]]
--addons/arccw_weapons/lua/arccw/shared/attachments/special_poison.lua:
att.PrintName = "Poison Rounds"
att.AbbrevName = "Poison Rounds"
att.Icon = Material("interfaz/iconos/jedi/1226256349_2572987182.png")
att.Description = "Experimental overcharged plasma that can poison targets."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"special_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 10
att.Override_Tracer = "tracer_yellow"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "heal", 10, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/deadeye/blasters_deadeye_laser_close_var_03.mp3", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_perk_standardtraining.lua:
att.PrintName = "Standard Training"

att.Icon = Material("", "smooth mips")
att.Description = [[The most basic training for weapon handling.
You perform at the core level now...]]
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
	"Maybe training will pay off..",
}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.1
att.Mult_JumpDispersion = 0.85

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.95
att.Mult_MoveDispersion = 0.95

att.Mult_DrawTime = 0.9
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.9

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_ReloadTime = 0.95

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.85
att.Mult_VisualRecoilMult = 0.8
att.Mult_Sway = 0.9

--lua/arccw/shared/attachments/uc_ammo_jhp.lua:
att.PrintName = "\"JHP\" Jacketed Hollow-point Rounds"
att.AbbrevName = "\"JHP\" Jacketed Hollow-point"

att.SortOrder = 4
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "A type of bullet with a hollow tip that expands on impact, causing a more lethal hit without penetrating further than necessary.\nFor use in environments where over-penetration could cause collateral damage."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_RangeMin = 0.5
att.Mult_Penetration = 0.25
att.Mult_Damage = 1.17

att.Mult_DamageMin = 0.85

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_lowtr.lua:
att.PrintName = "\"TR\" Intermittent Tracers"

att.SortOrder = 1
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "Every 5 rounds as well as the last few rounds of the magazine are tracer rounds, providing a visual indication of rounds remaining and make hip firing somewhat easier."
att.Desc_Pros = {
    "uc.lowind"
}
att.Desc_Cons = {
    "uc.tracer"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.InvAtt = "uc_ammo_tr"

att.AutoStats = true
att.Mult_HipDispersion = 0.9

att.Hook_AddShootSound = function(wep, data)
    local clip = wep:Clip1()
    if clip <= 5 and clip > 0 then
        wep:MyEmitSound("physics/metal/metal_computer_impact_bullet3.wav", data.volume, data.pitch + (5 - clip) * 7, 0.2, CHAN_AUTO)
    end
end

att.O_Hook_Override_TracerFinalMag = function(wep, data)
    return {current = math.Clamp(math.ceil(wep:GetCapacity() * 0.2), 5, 20)}
end
att.Override_TracerNum = 5
att.Override_Tracer = "arccw_uc_tracer"

att.ToggleStats = {
    {
        PrintName = "Green",
        Override_PhysTracerProfile = "uc_tracer_g"
    },
    {
        PrintName = "Red",
        Override_PhysTracerProfile = "uc_tracer_r"
    },
    {
        PrintName = "White",
        Override_PhysTracerProfile = "uc_tracer_w"
    },
}

--[[]
att.Override_TracerFinalMag = 5 -- this doesn't actually work like this, you know
att.ToggleStats = {
    {
        PrintName = "Red",
        Override_PhysTracerProfile = 1
    },
    {
        PrintName = "Green",
        Override_PhysTracerProfile = 2
    },
    {
        PrintName = "Violet",
        Override_PhysTracerProfile = 5
    },
    {
        PrintName = "Yellow",
        Override_PhysTracerProfile = 4
    },
}
]]

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_sg_baton.lua:
att.PrintName = "\"BATON\" Flexible Baton"

att.SortOrder = 0
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Less-lethal law enforcement round that fires a cushioned, low-velocity "bean bag" filled with lead pellets.
Designed to apprehend targets through pain instead of killing them, though the 40-gram projectile can still inflict deadly or permanent injuries.

Only compatible with manual action shotguns due to a weak pressure curve.]]
att.Desc_Pros = {
    "uc.baton",
}
att.Desc_Cons = {
    "uc.alwaysphys",
}
att.Desc_Neutrals = {
    "uc.oneprojectile",
    "uc.manualonly",
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}
att.ActivateElements = {"uc_manualonly"}

att.AutoStats = true

att.Override_Num = 1
att.Override_Num_Priority = 2
att.Mult_Recoil = .5

local path = ")^arccw_uc/common/"

att.Hook_PhysBulletHit = function(wep,data)
    if CLIENT then return end
    local tr = data.tr
    local bullet = data.bullet

    if tr.Entity and (tr.Entity:IsPlayer() or tr.Entity:IsNPC()) and tr.Entity:GetActiveWeapon() then
        local delta = bullet.Travelled / (bullet.Range / ArcCW.HUToM)
        delta = math.Clamp(delta, 0, 1)
        local dmg = Lerp(delta, bullet.DamageMax, bullet.DamageMin) -- one day I will understand this math
        local chance = math.random() * bullet.DamageMax
        -- if tr.HitGroup == HITGROUP_LEFTARM or tr.HitGroup == HITGROUP_RIGHTARM then
        --     chance = chance * 2
        -- end

        if chance <= dmg * .5 then -- Chance for a weapon drop increases the closer the shooter is to the target, but is never guaranteed
            tr.Entity:DropWeapon()
            if tr.Entity:IsPlayer() then
                tr.Entity:ScreenFade(1,Color(128,0,0,64),.5,0)
                tr.Entity:ViewPunch(Angle(3,0,0))
            end
        end
        if tr.Entity:IsNPC() then
            tr.Entity:SetSchedule(SCHED_FLINCH_PHYSICS)
        end
    end
end

att.Hook_GetShootSound = function(wep, fsound)
    if fsound == wep.ShootSound or fsound == wep.FirstShootSound then return {path .. "shotgun-lesslethal-01.ogg", path .. "shotgun-lesslethal-02.ogg"} end
    --if fsound == wep.ShootSoundSilenced then return path .. "shotgun-lesslethal_sup.ogg" end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if distancesound == wep.DistantShootSound then return false
    end
end
att.UC_NoInnyOuty = true

att.Mult_Damage = .2
att.Mult_DamageMin = .2
att.Mult_Penetration = 0
att.Mult_Range = .33
att.Mult_RangeMin = .33

att.Override_DamageType = DMG_CLUB

att.Override_AlwaysPhysBullet = true
att.Mult_PhysBulletMuzzleVelocity = 0.5
att.Mult_PhysBulletGravity = 2

att.Override_UC_ShellColor = Color(0.6 * 255, 0.2 * 255, 0.6 * 255)

att.GivesFlags = {"needsmanual"}
att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then return false end
end
--lua/arccw/shared/attachments/uc_ammo_sg_flech.lua:
att.PrintName = "\"FLECH\" Flechettes"

att.SortOrder = 3
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Payload consisting of heavy, aerodynamic metal darts, which have less clump spread and more penetration than buckshot.]]
att.Desc_Pros = {
    "uc.pellet.8",
    "uc.penetration.12"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}

att.AutoStats = true

att.Add_Num = 8
att.Mult_AccuracyMOA = .5
att.Add_Penetration = 12
att.Mult_Range = .75
att.Mult_Damage = .8

att.Mult_HullSize = 0.5

att.Override_UC_ShellColor = Color(0.2 * 255, 0.2 * 255, 0.5 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_fg_sg_rifled.lua:
att.PrintName = "Rifled Barrel"

att.Icon = Material("entities/att/arccw_uc_precisionrifling.png", "mips smooth")
att.Description = "Specially made lightweight barrel designed for slug rounds. Improves precision and time to aim noticably."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.reqslug"
}
att.Slot = {"uc_fg","uc_fg_singleshot"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then -- or wep:GetBuff("Num") > 1
        return false
    end
end

att.Mult_AccuracyMOA = 0.5
att.Mult_SightTime = 0.75
att.Mult_HipDispersion = 1.25

att.RequireFlags = {"uc_slug"}
att.GivesFlags = {"uc_fg_sg_rifled"}
att.ExcludeFlags = {"uc_choke_rifled"}

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_grip_kacvfg.lua:
att.PrintName = "Knight's Armament Company Vertical Foregrip"
att.AbbrevName = "KAC Vertical Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_kacvfg.png", "mips smooth")
att.Description = "Medium-length vertical foregrip that assists in control of the weapon, but detracts from its concealability."

att.SortOrder = 1400

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.25)
att.Model = "models/weapons/arccw/atts/uc_kacvfg1.mdl"

att.Mult_Recoil = 0.8
att.Mult_SightTime = 1.1
att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15

att.Override_HoldtypeActive = "smg"
att.Override_HoldtypeActive_Priority = 2
--lua/arccw/shared/attachments/uc_grip_mafg2_tan.lua:
att.PrintName = "MAGPUL AFG-2 Angled Fore Grip (Tan)"
att.AbbrevName = "Magpul Angled Foregrip (Tan)"
att.Icon = Material("entities/att/acwatt_uc_grip_magpul_afg2_tan.png", "mips smooth")
att.Description = "An ergonomically angled grip surface reduces wrist strain, increasing maneuverability.\nThis unit is cosmetically colored tan."

att.SortOrder = 1200

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.75)

att.Model = "models/weapons/arccw/atts/uc_magpul_afg2.mdl"
att.ModelSkin = 0

att.Mult_SightTime = 0.8
att.Mult_Sway = 1.15
att.Mult_Recoil = 1.20
--lua/arccw/shared/attachments/uc_muzzle_brake1.lua:
att.PrintName = "Hammerhead Muzzle Brake" -- fictional
att.AbbrevName = "Hammerhead Brake"
att.Icon = Material("entities/att/acwatt_uc_muzzle_brake1.png", "mips smooth")
att.Description = "Redirects propellant gases to reduce weapon recoil.\nReduces muzzle rise substantially."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 100

att.Model = "models/weapons/arccw/atts/uc_muzzle2.mdl"
att.ModelOffset = Vector(2.3, 0, 0)
att.ModelScale = Vector(1.0, 1.0, 1.0)
att.OffsetAng = Angle(0, 0, 0)

att.IsMuzzleDevice = true

att.Mult_Recoil = 0.8

att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

--lua/arccw/shared/attachments/uc_muzzle_fhider2.lua:
att.PrintName = "Cage Compensator" -- fictional
att.AbbrevName = "Cage Compensator"
att.Icon = Material("entities/att/acwatt_uc_muzzle_fhider2.png", "mips smooth")
att.Description = "Dual purpose compensator and flash hider, improving weapon stability while providing a clearer firing view from the hip."
att.Desc_Pros = {
    "uc.flashhider"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 50

att.Model = "models/weapons/arccw/atts/uc_muzzle4.mdl"
att.ModelOffset = Vector(2.2, 0, 0)
att.ModelScale = Vector(0.95, 0.95, 0.95)
att.OffsetAng = Angle(0, 0, 0)

-- att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_RecoilSide = 0.85
att.Mult_HipDispersion = 0.9

att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
--lua/arccw/shared/attachments/uc_optic_vortex_3x.lua:
att.PrintName = "Vortex SPITFIRE PRISM SCOPE (1.5x)"
att.AbbrevName = "Spitfire (1.5x)"
att.Icon = Material("entities/att/acwatt_uc_optic_vortex_3x.png", "mips smooth")
att.Description = "Short to medium range combat scope that allows a more versatile engagement range."

att.SortOrder = 1.5

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_vortex3x.mdl"
att.ModelOffset = Vector(0, 0, 0.18)

att.AdditionalSights = {
    {
        Pos = Vector(0, 8.5, -1.6),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ScopeMagnification = UC_HalfScope( 1.5 ),
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_vortex_reticle.png", "mips smooth"),
            HolosightNoFlare = true,
            HolosightSize = 8.5,
            HolosightPiece = "models/weapons/arccw/atts/uc_vortex3x_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 1.5 ),
            Colorable = true,
        },
    }
}

-- att.Holosight = true
-- att.HolosightReticle = Material("mifl_tarkov_reticle/dot.png", "mips smooth")

att.HolosightPiece = "models/weapons/arccw/atts/uc_vortex3x_hsp.mdl"
-- att.HolosightNoFlare = true
-- att.HolosightSize = 1
-- att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .8
--lua/arccw/shared/attachments/uc_tp_runandgun.lua:
att.PrintName = "On the Move"

att.Icon = Material("entities/att/arccw_uc_tp_run_and_gun.png", "smooth mips")
att.Description = "Expert training in high-verticality maneuvers and countless moving-while-shooting drills allow you to aim steadily even while moving between cover, across open ground, or while mid-air."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 4

att.Mult_JumpDispersion = 0
att.Mult_MoveDispersion = .5

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_asimov.lua:
att.PrintName = "Asiimov"
att.Icon = nil
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Slot = "mw2_wepcamo"
att.Free = true

att.ActivateElements = {"wepcamo-asimov"}

att.SortOrder = 7 *-1
--addons/arccw_base_modified/lua/arccw/client/cl_sway.lua:
local enabled = ArcCW.ConVars["enable_sway"]
local mult = ArcCW.ConVars["mult_sway"]

ArcCW.SwayDir = 0

function ArcCW.Sway(cmd)

    local ply = LocalPlayer()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    local ang = cmd:GetViewAngles()

    if wpn:GetState() == ArcCW.STATE_SIGHTS and !wpn.NoSway and enabled:GetBool() then
        local sway = mult:GetFloat() * wpn:GetBuff("Sway")
        --sway = sway * math.Clamp(1 / (wpn:GetActiveSights().ScopeMagnification or 1), 0.1, 1)
        if wpn:InBipod() then
            sway = sway * (wpn.BipodDispersion * wpn:GetBuff_Mult("Mult_BipodDispersion"))
        end
        if sway > 0.05 then
            ang.p = math.Clamp(ang.p + math.sin(CurTime() * 1.25) * FrameTime() * sway, -89, 89)

            ArcCW.SwayDir = ArcCW.SwayDir + math.Rand(-360, 360) * FrameTime() / math.min(sway, 1)

            ang.p = ang.p + math.sin(ArcCW.SwayDir) * FrameTime() * sway
            ang.y = ang.y + math.cos(ArcCW.SwayDir) * FrameTime() * sway

            -- ang.p = ang.p + math.Rand(-1, 1) * FrameTime() * sway
            -- ang.y = ang.y + math.Rand(-1, 1) * FrameTime() * sway

            cmd:SetViewAngles(ang)
        end
    end
end

hook.Add("CreateMove", "ArcCW_Sway", ArcCW.Sway)
--addons/weapons_other/lua/autorun/cdraw.lua:
if SERVER then return end

CDRAW = CDRAW or {}

local circle_cache = {}

function CDRAW.DrawCircle(x,y,radius,seg)
	local segstr = x..y..radius..seg
	if circle_cache[segstr] then
		surface.DrawPoly(circle_cache[segstr])
	else
		local cir = {}
		cir[#cir+1] = {x=x,y=y,u=0.5,v=0.5}
		for i = 0, seg do
			local a = math.rad((i/seg)*-360)
			cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		end
		local a = math.rad(0)
		cir[#cir+1] = {x=x+math.sin(a)*radius,y=y+math.cos(a)*radius,u=math.sin(a)/2+0.5,v=math.cos(a)/2+0.5}
		circle_cache[segstr] = cir
		surface.DrawPoly(cir)
	end
end

function CDRAW.DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

function CDRAW.GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

function CDRAW.DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	aye[2], aye[3] = math.Round(aye[2]), math.Round(aye[3])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i].r,aye[i].g,aye[i].b,aye[i].a)
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(aye[i])
			local _ox, _oy = surface.GetTextSize(aye[i])
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

function CDRAW.DrawNiceText(Col,Off,Font,Text)
	local sw, sh = CDRAW.GetTextSize(Font,Text)
	CDRAW.DrawText(Font..'_blur',-sw/2,-sh/2-Off,Col,Text)
	CDRAW.DrawText(Font,-sw/2,-sh/2-Off,Col,Text)
end

return CDRAW
--addons/aoc_fire_system/lua/ch_fire_system/shared/fire_config_lang.lua:
-- I DO NOT ADVISE YOU TRY TO EDIT BELOW THIS LINE UNLESS YOU UNDERSTAND HOW THIS WORKS!
-- IF YOU WANT TO ADD A LANAGUE PLEASE OPEN A SUPPORT TICKET ON GMODSTORE.
-- I WILL HELP YOU WITH ANYTHING YOU NEED AND ADD THE LANGUAGE TO THE OFFICIAL SCRIPT.
CH_FireSystem.Config.Lang = CH_FireSystem.Config.Lang or {}

-- Setting spawn points
CH_FireSystem.Config.Lang["Added a new spawn point for fire trucks. The new position is now in effect!"] = {
	["en"] = "Added a new spawn point for fire trucks. The new position is now in effect!",
	["fr"] = "Un nouveau point d'apparition pour les véhicules de pompier a été ajouté, et prend désormais effet!",
	["da"] = "Ny position for brændbiler er tilføjet. Denne position træder i kraft med det samme!",
	["de"] = "Ein neuer Erscheinungsort fьr die Feuerwehrwagen wurde hinzugefьgt. Er ist nun wirsam!",
	["pl"] = "Dodano nowy punkt spawnu dla wozów straży pożarnej. Nowa pozycja obowiązuje!",
	["ru"] = "Добавлена новая точка появления для пожарных машин. Новая позиция сейчас в силе!",
	["es"] = "Se ha agregado un nuevo punto de spawn para los camiones de bombero ¡La nueva posición está en funcionamiento!",
	["pt"] = "",
	["cn"] = "增加了一个新的消防车刷新点。新的位置已经生效了!",
	["tr"] = "Itfaiye araclari icin yeni bi olusma noktasi ayarlandi. Artik burasi kullanilacak.",
}

CH_FireSystem.Config.Lang["Only administrators can perform this action!"] = {
	["en"] = "Only administrators can perform this action!",
	["fr"] = "Seuls les administrateurs peuvent exécuter cette action!",
	["da"] = "Kun administratorer kan udføre denne handling!",
	["de"] = "Nur die Administratoren kцnnen diese Aktion ausfьhren!",
	["pl"] = "Tylko administratorzy mogą to zrobić!",
	["ru"] = "Только администраторы могут выполнить это действие!",
	["es"] = "¡Sólo los administradores pueden ejecutar esta acción!",
	["pt"] = "",
	["cn"] = "只有管理员才能执行这个操作!",
	["tr"] = "Sadece yetkililer bu eylemi gerceklestirebilir.",
}

CH_FireSystem.Config.Lang["All fire truck spawn positions have been cleared."] = {
	["en"] = "All fire truck spawn positions have been cleared.",
	["fr"] = "Tous les points d'apparition de véhicules de pompier ont été supprimés.",
	["da"] = "Alle pladser for brændbiler er blevet slettet.",
	["de"] = "Alle Erscheinungsorte fьr Feuerwehrwagen wurden entfernt.",
	["pl"] = "Wszystkie miejsca spawnu dla wozów strażackich zostały usunięte.",
	["ru"] = "Все позиции появления пожарных машин были очищены.",
	["es"] = "Todas los puntos de spawn han sido eliminados.",
	["pt"] = "",
	["cn"] = "所有的消防车刷新点都已清除完毕。",
	["tr"] = "Tum itfaiye araclarinin pozisyonlari temizlendi.",
}

CH_FireSystem.Config.Lang["Type firetruck_addspawnpos to start adding new ones!"] = {
	["en"] = "Type firetruck_addspawnpos to start adding new ones!",
	["fr"] = "Écrivez firetruck_addspawnpos pour commencer а ajouter des points d'apparition de véhicules de pompier!",
	["da"] = "Skriv firetruck_addspawnpos for at tilføje flere positioner!",
	["de"] = "Schreiben sie firetruck_addspawnpos um einen neuen Erscheinungsort fьr Feuerwehrwagen hinzuzufьgen!",
	["pl"] = "Wpisz firetruck_addspawnpos aby dodać nowe miejsca spawnu dla wozów strażackich!",
	["ru"] = "Введите firetruck_addspawnpos, чтобы добавить новые!",
	["es"] = "¡Escribe firetruck_addspawnpos para añadir un nuevo punto de spawn!",
	["pt"] = "",
	["cn"] = "输入 firetruck_addspawnpos 开始添加新的!",
	["tr"] = "firetruck_addspawnpos yazarak yenilerini eklemeye baslayabilirsin",
}

CH_FireSystem.Config.Lang["New position for the firetruck NPC has been succesfully set!"] = {
	["en"] = "New position for the firetruck NPC has been succesfully set!",
	["fr"] = "Une nouvelle position pour le PNJ des véhicules de pompier a été ajouté avec succès!",
	["da"] = "Ny position for brændbil NPC er blevet tilføjet!",
	["de"] = "Eine neue Position fьr den Feuerwehrwagen-NPC wurde erfolgreich hinzugefьgt!",
	["pl"] = "Nowe miejsce na NPC od wozów strażackich zostało pomyślnie ustawione!",
	["ru"] = "Новая позиция для NPC пожарной машины была успешно установлена!",
	["es"] = "¡Nueva posición para el NPC de camiones establecida correctamente!",
	["pt"] = "",
	["cn"] = "消防车NPC的新位置已经成功设置!",
	["tr"] = "Itfaiye araci NPC'si nin yeni pozisyonu ayarlandi!",
}

CH_FireSystem.Config.Lang["The NPC will respawn in 5 seconds. Move out the way."] = {
	["en"] = "The NPC will respawn in 5 seconds. Move out the way.",
	["fr"] = "Le PNJ va réapparaitre dans 5 secondes. Veuillez vous éloigner.",
	["da"] = "NPC'en spawner om 5 sekunder. Flyt dig til siden.",
	["de"] = "Der NPC wird in 5 Sekunden wieder erscheinen. Bitte gehen sie zur Seite.",
	["pl"] = "NPC zostanie zrespiony za 5 sekund, zejdź z miejsca respu.",
	["ru"] = "NPC возродится через 5 секунд. Освободите дорогу.",
	["es"] = "El NPC reaparecerá en 5 segundos. Muévete del lugar.",
	["pt"] = "",
	["cn"] = "NPC会在5秒后重现。",
	["tr"] = "NPC 5 saniye sonra canlanicak. Yoldan cekil.",
}

CH_FireSystem.Config.Lang["The NPC has been respawned."] = {
	["en"] = "The NPC has been respawned.",
	["fr"] = "Le PNJ est réapparu.",
	["da"] = "NPC'en er blevet respawnet.",
	["de"] = "Der NPC ist wieder erschienen.",
	["pl"] = "NPC został zespawnowany.",
	["ru"] = "NPC был возрожден.",
	["es"] = "El NPC ha reaparecido",
	["pt"] = "",
	["cn"] = "NPC已经重生了",
	["tr"] = "NPC yeniden canlandi.",
}

-- Spawn/remove fire truck
CH_FireSystem.Config.Lang["The server owner has not configured any fire truck spawn positions!"] = {
	["en"] = "The server owner has not configured any fire truck spawn positions!",
	["fr"] = "Le propriétaire du serveur n'a pas configuré les points d'apparition des véhicules de pompier!",
	["da"] = "Server ejeren har ikke konfigureret nogle positioner for brændbilerne!",
	["de"] = "Der Server Owner hat keine Erscheinungsorte fьr die Feuerwehrwahen konfiguriert!",
	["pl"] = "Właściciel serwera nie ustawił żadnych miejsc spawnu dla wozów strażackich!",
	["ru"] = "Владелец сервера не настроил ни одной позиции появления пожарных машин!",
	["es"] = "¡El dueño del servidor no ha configurado un punto de spawn para las camionetas!",
	["pt"] = "",
	["cn"] = "服主没有配置任何消防车刷新位置!",
	["tr"] = "Sunucu sahibi hic itfaiye araci canlanma pozisyonu ayarlamadi!",
}

CH_FireSystem.Config.Lang["You already own a fire truck. Please remove your current one to retrieve a new one!"] = {
	["en"] = "You already own a fire truck. Please remove your current one to retrieve a new one!",
	["fr"] = "Vous possédez déjà un véhicule de pompier. Veuillez supprimer celui-ci pour en prendre un autre!",
	["da"] = "Du ejer allerede en brændbil. Aflever venligst din nuværende brændbil for at få en ny!",
	["de"] = "Sie besitzen schon einen Feuerwehrwagen. Bitte entfernen sie diesen um einen neuen zu bekommen!",
	["pl"] = "Już posiadasz wóz strażacki, prosze usuń go aby dostać nowy!",
	["ru"] = "У вас уже есть пожарная машина. Пожалуйста, верните свою текущую машину, чтобы получить новую!",
	["es"] = "Ya tienes una camioneta ¡Por favor devuelve la antigua para retirar una nueva!",
	["pt"] = "",
	["cn"] = "你已经拥有一辆消防车。请先你现在的消防车收回，才能换一辆新的!",
	["tr"] = "Zaten bir itfaiye aracina sahipsin. Lutfen su an ki araci kaldirin ki yeniden cikartabilesiniz!",
}

CH_FireSystem.Config.Lang["The limitation of maximum fire trucks has been reached!"] = {
	["en"] = "The limitation of maximum fire trucks has been reached!",
	["fr"] = "La limite maximum des véhicules de pompier a été atteinte!",
	["da"] = "Det maksimale antal brændbiler er nået!",
	["de"] = "Die maximale Limit von Feuerwehrwagen wurden erreicht!",
	["pl"] = "Limit wozów strażackich osiągnął maximum!",
	["ru"] = "Максимальное количество пожарных машин достигнуто!",
	["es"] = "¡El límite de camionetas máximo ha sido alcanzado!",
	["pt"] = "",
	["cn"] = "已经达到消防车的上限限制了!",
	["tr"] = "Maksimum cikarilabilecek itfaiye araci sayisina ulasildi.",
}

CH_FireSystem.Config.Lang["You can not retrieve this fire truck as a"] = {
	["en"] = "You can not retrieve this fire truck as a",
	["fr"] = "Vous ne pouvez pas retirer de véhicule de pompier en tant que",
	["da"] = "Du kan ikke få denne brændbil som en",
	["de"] = "Sie kцnnen kein Feuerwehrwagen bekommen, da sie in dem folgendem Job sind :",
	["pl"] = "Nie możesz odzyskać tego wozu strażackiego jako",
	["ru"] = "Вы не можете пользоваться этой пожарной машиной за",
	["es"] = "No puedes retirar una camioneta como un",
	["pt"] = "",
	["cn"] = "你不能把这辆消防车当做一个",
	["tr"] = "Itfaiye aracini su meslekteyken cikartamazsiniz",
}

CH_FireSystem.Config.Lang["You are not the required ulx rank to retrieve the"] = {
	["en"] = "You are not the required ulx rank to retrieve the",
	["fr"] = "Vous n'avez pas le grade ulx requis pour récupérer le",
	["da"] = "Du er ikke tilstrækkeligt højt ULX rang for at hente brændbilen",
	["de"] = "Sie haben nicht den richtigen ulx Rank um Folgendes zu bekommen :",
	["pl"] = "Nie masz rangi ULX aby odzyskać",
	["ru"] = "Вы не имеете определённого ulx ранга чтобы получить",
	["es"] = "No tienes el rango ULX específico para retirar la",
	["pt"] = "",
	["cn"] = "你不在ULX权限组中，无法检索",
	["tr"] = "Sunu almak icin gerekli ulx rutbesine sahip degilsin",
}

CH_FireSystem.Config.Lang["You have successfully retrieved a"] = {
	["en"] = "You have successfully retrieved a",
	["fr"] = "Vous avez avec succès retiré un",
	["da"] = "Du har hentet brændbilen",
	["de"] = "Sie haben erfolgreich Folgendes bekommen :",
	["pl"] = "Pomyślnie odzyskałeś plik",
	["ru"] = "Вы успешно получили",
	["es"] = "Has retirado exitosamente una",
	["pt"] = "",
	["cn"] = "你已成功检索到一个",
	["tr"] = "Sundan basariyla geri aldiniz",
}

CH_FireSystem.Config.Lang["Your fire truck has been removed!"] = {
	["en"] = "Your fire truck has been removed!",
	["fr"] = "Votre véhicule de pompier a été supprimé!",
	["da"] = "Din brændbil er blevet afleveret tilbage!",
	["de"] = "Ihr Feuerwehrwagen wurde entfernt!",
	["pl"] = "Twój wóz strażacki został usunięty!",
	["ru"] = "Ваша пожарная машина была возвращена!",
	["es"] = "¡Tu camioneta ha sido removida!",
	["pt"] = "",
	["cn"] = "你的消防车已经被收回了！",
	["tr"] = "Itfaiye araciniz kaldirildi!",
}

CH_FireSystem.Config.Lang["You don't have a fire truck!"] = {
	["en"] = "You don't have a fire truck!",
	["fr"] = "Vous n'avez pas de véhicule de pompier!",
	["da"] = "Du har ingen brændbil!",
	["de"] = "Sie haben keinen Feuerwehrwagen!",
	["pl"] = "Nie masz wozu strażackiego!",
	["ru"] = "У вас нет пожарной машины!",
	["es"] = "¡No tienes una camioneta de bomberos!",
	["pt"] = "",
	["cn"] = "你没有消防车！",
	["tr"] = "Itfaiye aracina sahip degilsin.",
}

CH_FireSystem.Config.Lang["Only firefighters can access this NPC!"] = {
	["en"] = "Only firefighters can access this NPC!",
	["fr"] = "Seuls les pompiers peuvent accéder а ce PNJ!",
	["da"] = "Kun brandmænd har adgang til denne NPC!",
	["de"] = "Nur Feuerwehrwagen kцnnen diesen NPC benutzen:",
	["pl"] = "Tylko strażacy mogą wejść w interakcje z tym NPC!",
	["ru"] = "Только пожарные могут пользоваться этим NPC!",
	["es"] = "¡Sólo los bomberos pueden acceder a este NPC!",
	["pt"] = "",
	["cn"] = "只有消防员才能使用这个NPC!",
	["tr"] = "Sadece Itfaiye personelleri bu NPC'ye ulasabilir!",
}

-- Extinguisher bonuses
CH_FireSystem.Config.Lang["Extinguishing fire bonus"] = {
	["en"] = "Extinguishing fire bonus",
	["fr"] = "Bonus d'extinction de feu",
	["da"] = "Slukning af brand bonus",
	["de"] = "Bonus dafьr, dass sie einen Brand gelцscht haben",
	["pl"] = "Premia za gaszenie ognia",
	["ru"] = "Вы получили бонус за тушение пожара",
	["es"] = "Bonus de extinguidores",
	["pt"] = "",
	["cn"] = "灭火奖励",
	["tr"] = "Yangin sondurme bonusu",
}

CH_FireSystem.Config.Lang["Extinguishing fire bonus as non-firefighter"] = {
	["en"] = "Extinguishing fire bonus as non-firefighter",
	["fr"] = "Bonus d'extinction de feu en tant que non-pompier",
	["da"] = "Slukning af brand bonus som civil",
	["de"] = "Bonus dafьr, dass sie einen Brand gelцscht haben, als einen nicht-Feuerwehrmitglied",
	["pl"] = "Premia za gaszenie ognia jako strażak",
	["ru"] = "Бонус за тушение пожара в качестве не-пожарника",
	["es"] = "Extinguir fuego bonus como no-bombero",
	["pt"] = "",
	["cn"] = "作为非消防员的灭火奖励",
	["tr"] = "Itfaiye degilken yangin sondurme sonucu alinan bonus",
}

-- Fire extinguisher cabinet entity
CH_FireSystem.Config.Lang["Take Ext."] = {
	["en"] = "Take Ext.",
	["fr"] = "Prendre",
	["da"] = "Brandslukker",
	["de"] = "Nehmen",
	["pl"] = "Weź Ext",
	["ru"] = "Возьмите огнетушитель",
	["es"] = "Tomar Extinguidor",
	["pt"] = "",
	["cn"] = "拿上灭火器。",
	["tr"] = "Yangin Sondurucusu Al",
}

CH_FireSystem.Config.Lang["You cannot take an extinguisher at the moment."] = {
	["en"] = "You cannot take an extinguisher at the moment.",
	["fr"] = "Vous ne pouvez pas prendre d'extincteur pour le moment.",
	["da"] = "Du kan ikke tage en brandslukker på nuverænde tidspunkt og må vente.",
	["de"] = "Sie können im Moment keinen Feuerlöscher nehmen.",
	["pl"] = "W tej chwili nie możesz wziąć gaśnicy.",
	["ru"] = "Вы не можете взять огнетушитель в данный момент.",
	["es"] = "No puedes tomar un extinguidor ahora mismo.",
	["pt"] = "",
	["cn"] = "你现在不能拿灭火器。",
	["tr"] = "Yangin sondurucusunu su anda alamazsin.",
}

CH_FireSystem.Config.Lang["Succesfully took a citizen extinguisher from the cabinet."] = {
	["en"] = "Succesfully took a citizen extinguisher from the cabinet.",
	["fr"] = "A réussi à prendre un extincteur citoyen du cabinet.",
	["da"] = "Du har taget en brandslukker.",
	["de"] = "Erfolgreich einen Bürgerlöscher aus dem Kabinett genommen.",
	["pl"] = "Pomyślnie wyjąłeś z gabinetu gaśnicę obywatelską.",
	["ru"] = "Успешно взят гражданский огнетушитель из кабинета.",
	["es"] = "Has tomado exitosamente un extinguidor para ciudadanos del almacén.",
	["pt"] = "",
	["cn"] = "成功地从消防柜中取出一个公民灭火器。",
	["tr"] = "Dolaptan basariyla yangin sondurucu alindi.",
}

CH_FireSystem.Config.Lang["All fire extinguisher cabinets have been saved!"] = {
	["en"] = "All fire extinguisher cabinets have been saved!",
	["fr"] = "Toutes les armoires d'extincteurs ont été sauvées!",
	["da"] = "Alle brændslukker kabinetter er blevet gemt!",
	["de"] = "Alle Feuerlöscherschränke wurden gerettet!",
	["pl"] = "Wszystkie szafki gaśnicze zostały zapisane",
	["ru"] = "Все шкафы огнетушителей были сохранены!",
	["es"] = "¡Todos los gabinetes de extintores de incendios se han guardado!",
	["pt"] = "",
	["cn"] = "所有灭火器柜已保存!",
	["tr"] = "Yangin sondurme dolaplari kaydedildi!",
}

-- Admin fire commands
CH_FireSystem.Config.Lang["Please choose a unique name for the fire!"] = {
	["en"] = "Please choose a unique name for the fire!",
	["fr"] = "Choisissez s'il-vous-plait un nom unique pour le feu!",
	["da"] = "Vælg venligst et unikt navn for denne brand lokation.",
	["de"] = "Bitte, suchen sie einen einzigartigen Namen fьr den Brand!",
	["pl"] = "Wybierz unikalną nazwę dla ognia!",
	["ru"] = "Пожалуйста, выберите уникальное имя для огня!",
	["es"] = "¡Elige un nombre único para el fuego!",
	["pt"] = "",
	["cn"] = "为火灾起一个独特的名字!",
	["tr"] = "Lutfen yangin icin ozel bir isim seciniz!",
}

CH_FireSystem.Config.Lang["This file name is already in use. Please choose another name for this location of fire."] = {
	["en"] = "This file name is already in use. Please choose another name for this location of fire.",
	["fr"] = "Ce nom de fichier est déjà utilisé. S'il-vous-plait choisissez un autre nom pour cette localisation de feu.",
	["da"] = "Dette navn er allerede i brug. Vælg venligst et andet navn for denne brand lokation.",
	["de"] = "Dieser Name ist bereits benutzt. Bitte suchen sie einen anderen Namen aus, fьr diesen Ort wo ein Brand erscheinen wird.",
	["pl"] = "Ta nazwa pliku jest już w użyciu. Wybierz inną nazwę dla tej lokalizacji ognia.",
	["ru"] = "Это имя файла уже используется. Пожалуйста, выберите другое имя для расположения этого пожара.",
	["es"] = "El nombre del archivo ya está en uso. Elige otro nombre para esta zona de fuego.",
	["pt"] = "",
	["cn"] = "这个文件名已经在使用。请为这个位置的火灾选择其他名称。",
	["tr"] = "Bu isim zaten kullanimda. Baska bir isim koyunuz.",
}

CH_FireSystem.Config.Lang["New fire location created!"] = {
	["en"] = "New fire location created!",
	["fr"] = "Nouvelle localisation de feu créée!",
	["da"] = "Ny brand lokation oprettet!",
	["de"] = "Neuer Ort, wo Brand erscheinen wird hinzugefьgt!",
	["pl"] = "Stworzono nową lokacje ognia!",
	["ru"] = "Новая локация пожара создана!",
	["es"] = "¡Nueva zona de fuego creada!",
	["pt"] = "",
	["cn"] = "新的火灾点创建!",
	["tr"] = "Yeni ateş konumu yaratildi",
}

CH_FireSystem.Config.Lang["Please enter a filename!"] = {
	["en"] = "Please enter a filename!",
	["fr"] = "Entrez un nom de fichier s'il-vous-plait!",
	["da"] = "Indsæt venligst et filnavn!",
	["de"] = "Geben sie einen Namen ein!",
	["pl"] = "Prosze wprowadź nazwe pliku!",
	["ru"] = "Пожалуйста, введите имя файла!",
	["es"] = "¡Por favor ingresa un nombre de archivo!",
	["pt"] = "",
	["cn"] = "请输入一个文件名!",
	["tr"] = "Lutfen bir isim giriniz!",
}

CH_FireSystem.Config.Lang["The selected fire has been removed!"] = {
	["en"] = "The selected fire has been removed!",
	["fr"] = "Le feu selectionné a été supprimé!",
	["da"] = "Den valgte brand er blevet slettet!",
	["de"] = "Der ausgewдhlte Brand wurde entfernt!",
	["pl"] = "Wybrany ogień został usunięty!",
	["ru"] = "Выбранный огонь был удален!",
	["es"] = "¡La zona de fuego seleccionada ha sido removida!",
	["pt"] = "",
	["cn"] = "选定的火灾已被移除!",
	["tr"] = "Secilen yangin kaldirildi!",
}

CH_FireSystem.Config.Lang["The selected fire does not exist!"] = {
	["en"] = "The selected fire does not exist!",
	["fr"] = "Le feu selectionné n'existe pas!",
	["da"] = "Den valgte brand eksisterer ikke!",
	["de"] = "Der ausgewдhlte Brand existiert nicht!",
	["pl"] = "Wybrany ogień nie istnieje!",
	["ru"] = "Выбранный огонь не существует!",
	["es"] = "¡La zona de fuego seleccionada no existe!",
	["pt"] = "",
	["cn"] = "所选的火灾不存在!",
	["tr"] = "Secilen yangin bulunmuyor",
}

CH_FireSystem.Config.Lang["Successfully deleted all fire locations!"] = {
	["en"] = "Successfully deleted all fire locations!",
	["fr"] = "Suppression réussie de tous les emplacements d'incendie!",
	["da"] = "",
	["de"] = "Alle Feuerstellen erfolgreich gelöscht!",
	["pl"] = "Pomyślnie usunięto wszystkie lokalizacje pożarów!",
	["ru"] = "Удачно удалены все места возгорания!",
	["es"] = "¡Se eliminaron con éxito todas las ubicaciones de incendios!",
	["pt"] = "Excluídos com sucesso todos os locais de incêndio!",
	["cn"] = "成功删除了所有火灾地点！",
	["tr"] = "Tüm yangın yerleri başarıyla silindi!",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] All fires have been turned off."] = {
	["en"] = "[ADMIN FIRE] All fires have been turned off.",
	["fr"] = "[FEU ADMIN] Tous les feux ont été supprimйs.",
	["da"] = "[ADMIN BRAND] Alle brande er blevet slukket.",
	["de"] = "[ADMIN FEUER] Alle Brдnde wurden entfernt.",
	["pl"] = "[ADMIN FIRE] Wszystkie płomienie zostaały wyłączone",
	["ru"] = "[ADMIN FIRE] Все пожары были отключены.",
	["es"] = "[FUEGOS ADMIN] Todas las zonas de fuego han sido apagadas.",
	["pt"] = "",
	["cn"] = "[管理火灾]所有的火灾已被关闭。",
	["tr"] = "[ADMIN ATESI] Tum atesler kapatildi.",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] Fire created at your aim of sight."] = {
	["en"] = "[ADMIN FIRE] Fire created at your aim of sight.",
	["fr"] = "[FEU ADMIN] Feu créé au lieu oé vous regardiez.",
	["da"] = "[ADMIN BRAND] Brand startet ved dit sigte.",
	["de"] = "[ADMIN FEUER] Ein Brand wurde am Ort wo sie geschaut haben hinzugefьgt.",
	["pl"] = "[ADMIN FIRE] Ogień został rozpalony w miejscu na które patrzysz",
	["ru"] = "[ADMIN FIRE] Огонь создан в вашем поле зрения.",
	["es"] = "[FUEGOS ADMIN] Zona de fuego creada en tu mira.",
	["pt"] = "",
	["cn"] = "[管理火灾]在你的视线范围内产生的火灾。",
	["tr"] = "[ADMIN ATESI] Yangin baktigin yerde olusturuldu.",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] REMOVING FIRE: YOU ONLY USE THE LAST OF THE FILE NAME."] = {
	["en"] = "[ADMIN FIRE] REMOVING FIRE: YOU ONLY USE THE LAST OF THE FILE NAME.",
	["fr"] = "[FEU ADMIN] SUPPRESSION DU FEU: VOUS UTILISEZ UNIQUEMENT LA FIN DU NOM DE FICHIER.",
	["da"] = "[ADMIN BRAND] FJERNE BRAND: DU SKAL KUN BRUGE DEN SIDSTE DEL AF FIL NAVNET.",
	["de"] = "[ADMIN FEUER] ENTFERNUNG DES BRANDES: SIE NUTZEN NUR DAS ENDE DES NAMENS DES FEUERS.",
	["pl"] = "[ADMIN FIRE] USUWANIE POŻARU: WYKORZYSTUJESZ TYLKO OSTATNĄ NAZWĘ PLIKU.",
	["ru"] = "[ADMIN FIRE] УДАЛЕНИЕ ОГНЯ: ИСПОЛЬЗУЙТЕ ТОЛЬКО ПОСЛЕДНИЕ ИМЯ ФАЙЛА.",
	["es"] = "[FUEGOS ADMIN] REMOVIENDO ZONA: SÓLO USA LA ÚLTIMA PALABRA DEL ARCHIVO",
	["pt"] = "",
	["cn"] = "[管理火灾]删除火灾：只用文件名的最后一个。",
	["tr"] = "[ADMIN ATESI] ATESİ KALDIRMA: DOSYANIN SON ISMINI KULLANIN",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] SO IF A FILE NAME IS CALLED 'FIRE_LOCATION_TRAIN', THEN YOU WOULD USE 'CH_REMOVE_FIRE TRAIN' TO REMOVE IT!"] = {
	["en"] = "[ADMIN FIRE] SO IF A FILE NAME IS CALLED 'FIRE_LOCATION_TRAIN', THEN YOU WOULD USE 'CH_REMOVE_FIRE TRAIN' TO REMOVE IT!",
	["fr"] = "[FEU ADMIN] DONC SI UN NOM DE FICHIER ÉTAIT APPELÉ 'FIRE_LOCATION_TRAIN', VOUS UTILISERIEZ 'CH_REMOVE_FIRE TRAIN' POUR LE SUPPRIMER!",
	["da"] = "[ADMIN BRAND] SÅ HVIS DIN FIL ER KALDET 'FIRE_LOCATION_TRAIL', SÅ SKAL DU SKRIVE 'CH_REMOVE_FIRE TRAIN FOR AT SLETTE DEN!",
	["de"] = "[ADMIN FEUER] WENN DER NAME DES BRANDES 'FIRE_LOCATION_TRAIN' GEWESEN WДRE, WЬRDEN SIE 'CH_REMOVE_FIRE TRAIN' BENUTZEN, UM IN ZU ENTFERNEN!",
	["pl"] = "[ADMIN FIRE] KIEDY NAZWĄ PLIKU JEST 'FIRE_LOCATION_TRAIN', ABY GO USUNĄĆ MUSISZ WPISAĆ 'CH_REMOVE_FIRE TRAIN'",
	["ru"] = "[ADMIN FIRE] ТАК, ЕСЛИ ИМЯ ФАЙЛА НАЗЫВАЕТСЯ «FIRE_LOCATION_TRAIN», ТО ВАМ СЛЕДУЕТ ИСПОЛЬЗОВАТЬ «CH_REMOVE_FIRE TRAIN», ЧТОБЫ УДАЛИТЬ ЕГО!",
	["es"] = "[FUEGOS ADMIN] SI EL ARCHIVO SE LLAMA 'FIRE_LOCATION_TRAIN' ENTONCES DEBERÁS USAR 'CH_REMOVE_FIRE TRAIN' PARA REMOVERLO",
	["pt"] = "",
	["cn"] = "[管理火灾]所以如果一个文件名叫'fire_location_train'，那么你可以用'ch_remove_fire train'来删除它!",
	["tr"] = "[ADMIN ATESI] EGER DOSYA ADI 'FIRE_LOCATION_TRAIN', O ZAMAN 'CH_REMOVE_FIRE TRAIN' KULLANIP KALDIRABILIRSINIZ!",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] You have started all fires at all set spawn locations."] = {
	["en"] = "[ADMIN FIRE] You have started all fires at all set spawn locations.",
	["fr"] = "[FEU ADMIN] Vous avez démarré tous les feux а tous les lieux d'apparition de feu.",
	["da"] = "[ADMIN BRAND] Du har startet brande pе alle lokationer.",
	["de"] = "[ADMIN FEUER] Sie haben alle Brдnde an allen Erscheinungsorte fьr einen Brand gestartet.",
	["pl"] = "[ADMIN FIRE] Rozpaliłeś wszystkie pożary we wszystkich ustalonych miejscach odradzania",
	["ru"] = "[ADMIN FIRE] Вы начали все пожары во всех установленных местах спавна.",
	["es"] = "[FUEGOS ADMIN] Has activado todas las zonas de fuego en sus puntos de spawn.",
	["pt"] = "",
	["cn"] = "[管理火灾]你已经在所有设定的刷新点启动了所有的火灾。",
	["tr"] = "[ADMIN ATESI] Tum yangin noktalarinda ates spawnlandi.",
}

CH_FireSystem.Config.Lang["[ADMIN FIRE] Amount of active fires:"] = {
	["en"] = "[ADMIN FIRE] Amount of active fires:",
	["fr"] = "[FEU ADMIN] Montant de feux actifs:",
	["da"] = "[ADMIN BRAND] Antal aktive brande:",
	["de"] = "[ADMIN FEUER] Anzahl von aktiven Brдnde:",
	["pl"] = "[ADMIN FIRE] Ilość aktywnych pożarów:",
	["ru"] = "[ADMIN FIRE] Количество активных пожаров:",
	["es"] = "[FUEGOS ADMIN] Cantidad de zonas activas:",
	["pt"] = "",
	["cn"] = "[管理火灾] 现行火灾的数量：",
	["tr"] = "[ADMIN ATESI] Aktif ateslerin sayisi",
}

CH_FireSystem.Config.Lang["XP rewarded."] = {
    ["en"] = "XP rewarded.",
    ["fr"] = "XP récompensé",
    ["da"] = "XP givet.",
    ["de"] = "XP belohnt.",
    ["pl"] = "Nagrodzone XP.",
    ["ru"] = "Опыт получен.",
    ["es"] = "Recompensa de EXP",
    ["pt"] = "",
    ["cn"] = "XP奖励。",
    ["tr"] = "TP verildi.",
}

CH_FireSystem.Config.Lang["Your citizen fire extinguisher has expired."] = {
	["en"] = "Your citizen fire extinguisher has expired.",
	["fr"] = "L'extincteur public a été désactivé.",
	["da"] = "Din brandslukker er udløbet.",
	["de"] = "Ihr Feuerlöscher ist abgelaufen.",
	["pl"] = "Twoja gaśnica straciła ważność.",
	["ru"] = "Срок действия вашего огнетушителя истек.",
	["es"] = "Su extintor de incendios ha caducado.",
	["pt"] = "",
	["cn"] = "您的灭火器已过期。",
	["tr"] = "Yangın söndürücünüzün süresi doldu.",
}

CH_FireSystem.Config.Lang["Your citizen fire extinguisher has been activated. You can use it for"] = {
	["en"] = "Your citizen fire extinguisher has been activated. You can use it for",
	["fr"] = "L'extincteur public a été activé. Vous pouvez l'utiliser pendant",
	["da"] = "Din ildslukker er blevet aktiveret. Du kan bruge den i",
	["de"] = "Ihr Feuerlöscher wurde aktiviert. Sie können es für verwenden",
	["pl"] = "Twoja gaśnica została aktywowana. Możesz go użyć do",
	["ru"] = "Ваш огнетушитель активирован. Вы можете использовать его для",
	["es"] = "Su extintor de incendios ha sido activado. Puedes usarlo para",
	["pt"] = "",
	["cn"] = "您的灭火器已启动。您可以将其用于",
	["tr"] = "Yangın söndürücünüz devreye girdi. için kullanabilirsin",
}

CH_FireSystem.Config.Lang["seconds."] = {
	["en"] = "seconds.",
	["fr"] = "secondes.",
	["da"] = "sekunder.",
	["de"] = "Sekunden.",
	["pl"] = "sekundy.",
	["ru"] = "секунды.",
	["es"] = "segundos.",
	["pt"] = "",
	["cn"] = "秒。",
	["tr"] = "saniye.",
}

--[[
CH_FireSystem.Config.Lang[""] = {
	["en"] = "",
	["fr"] = "",
	["da"] = "",
	["de"] = "",
	["pl"] = "",
	["ru"] = "",
	["es"] = "",
	["pt"] = "",
	["cn"] = "",
	["tr"] = "",
}
--]]
--addons/gm_express_binding/lua/gm_express_bindings/adv2/cl_init.lua:
return function( Module )
    -- TODO: Both functions need env on / off - they should be done the same way

    -- https://github.com/wiremod/advdupe2/blob/master/lua/advdupe2/cl_file.lua#L1
    -- The current net reciever is a local function, so we use setfenv to hijack its environment
    -- replacing the net library with our own, which reads data differently
    local function envOn( data )
        local env = setmetatable( {
            -- We need to change the behavior of the net library to read data
            -- differently, so we store those special cases here
            net = {
                ReadUInt = function( v )
                    assert( v == 8, "Expected receiver to read 8 bits - is Express Bindings out of date?" )
                    return data.autoSave
                end,

                ReadStream = function( _, cb )
                    cb( data.data )
                end
            },
        }, {
            -- However, anything else the function needs should be fine, so we do a _G passthrough
            -- "if accessing the net table, use ours, otherwise use _G"
            __index = function( t, k )
                local stubbed = rawget( t, k )
                if stubbed ~= nil then return stubbed end

                return _G[k]
            end
        } )

        setfenv( Module.originalReceiver, env )
    end

    local function envOff()
        setfenv( Module.originalReceiver, getfenv( 0 ) )
    end

    function Module.Enable()
        Module.originalReceiver = Module.originalReceiver or net.Receivers["advdupe2_receivefile"]

        express.Receive( "advdupe2_receivefile", function( data )
            -- When we receive dupe data, we wrap the normal receiver in our special environment,
            -- run it, and then restore the environment
            envOn( data )

            local success, err = pcall( Module.originalReceiver )
            if not success then
                ErrorNoHalt( "Error processing received AdvDupe2 file: " .. err )
            end

            envOff()
        end )

        Module.originalUploadFile = Module.originalUploadFile or AdvDupe2.UploadFile
        AdvDupe2.UploadFile = function( ... )
            local name
            local stub = function() end

            -- We need to change the behavior of the net library to write data
            -- differently, so we store those special cases here
            local customNet = {
                -- Start and SendToServer will be called, so they need to exist
                Start = stub,
                SendToServer = stub,

                WriteString = function( str )
                    -- Currently, the only WriteString call is for the name of the file,
                    -- so we store it here
                    name = str
                end,

                WriteStream = function( fileData, cb )
                    assert( name ~= nil, "Expected WriteString to be called before WriteStream - Is Express Bindings out of date?" )

                    -- Hijacking call to WriteStream to send the file data to the server using Express instead
                    express.Send( "advdupe2_receivefile", {
                        name = name,
                        data = fileData
                    }, cb )

                    -- TODO: We should really return a proper NetStream mock here.
                    -- Doesn't appear to be matter in base adv2, but other addons might expect it
                    return { "ExpressBindings Mock NetStream object for dupe: " .. name }
                end
            }

            -- We override the environment of the function to use our custom net stub
            local env = setmetatable(
                { net = customNet },
                {
                    __index = function( t, k )
                        -- "if accessing the net table, use ours, otherwise use _G"
                        local stubbed = rawget( t, k )
                        if stubbed ~= nil then return stubbed end

                        return _G[k]
                    end
                }
            )

            setfenv( Module.originalUploadFile, env )

            local ok, err = pcall( Module.originalUploadFile, ... )
            if not ok then
                print( "Error uploading file: ", err )
            end

            -- Restore the environment
            setfenv( Module.originalUploadFile, getfenv( 0 ) )
        end
    end

    function Module.Disable()
        envOff()
        setfenv( Module.originalUploadFile, getfenv( 0 ) )

        AdvDupe2.UploadFile = Module.originalUploadFile
        express.ClearReceiver( "advdupe2_receivefile" )
    end
end

--addons/aocrp_map/lua/gmaps/cl_dgmapssettings.lua:

local PNL = {}
AccessorFunc(PNL,"m_PNL","Panel")

local function WhiteBox(panel)
	function panel:Paint(w,h)
		surface.SetDrawColor(color_black)
		surface.DrawOutlinedRect(0,0,w,h)
		surface.SetDrawColor(Color(210,210,210))
		surface.DrawRect(1,1,w-2,h-2)
	end
end

function PNL:Init()
	InstallBlur(self)
	
	self:DoModal(true)
	
	self:SetSize(500,300)
	self:DockPadding(5,32,5,5)
	self:MakePopup()
	self:Center()
	self:SetScreenLock(true)
	
	self.lblTitle:SetFont("gmaps_FrameTitle")
	-- self.lblTitle:SetTextColor(Color(255,255,255))
	self.lblTitle:SetTextColor(Color(255,255,255))
	self.lblTitle:SetExpensiveShadow(2,Color(0,0,0,200))
	self.lblTitle:SetTall(100)
	self:SetTitle("Karteneinstellungen")
	
	self.List = vgui.Create("DScrollPanel",self)
	self.List:Dock(FILL)
	
	self:PopulateList(self.List)
	
end

function PNL:PopulateList(list)
	local w,h = self:GetSize()
	
--[[ 	local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,5,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(60)
		WhiteBox(container)
	self.KeyL = vgui.Create("DLabel",container)
		self.KeyL:Dock(LEFT)
		self.KeyL:DockMargin(14,3,0,5)
		self.KeyL:SetFont("gmaps_Details")
		self.KeyL:SetText("Open Map Keybind:")
		self.KeyL:SetDark(true)
		self.KeyL:SetContentAlignment(4)
		self.KeyL:SizeToContents()
	self.Key = vgui.Create("DBinder",container)
		self.Key:SetFont("gmaps_Details")
		self.Key:SetDark(true)
		self.Key:Dock(FILL)
		self.Key:DockMargin(10,10,10,9)
		self.Key:SetValue(gmaps.KeyBind:GetInt())
		function self.Key.SetSelectedNumber( this, num )
			this.m_iSelectedNumber = num -- Preserve original functionality
			RunConsoleCommand("gmaps_key",num)
		end
	 ]]
	
	local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,5,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(60)
		WhiteBox(container)
	self.DefaultZoom = vgui.Create("DNumSlider",container)
		self.DefaultZoom:SetText("Standardzoom:")
		self.DefaultZoom.Label:SetFont("gmaps_Details")
		self.DefaultZoom:SetDark(true)
		self.DefaultZoom:Dock(FILL)
		self.DefaultZoom:DockMargin(15,0,0,0)
		self.DefaultZoom:SetMinMax(gmaps.Config.MinZoom,gmaps.Config.MaxZoom)
		self.DefaultZoom:SetDecimals(0)
		self.DefaultZoom:SetConVar("gmaps_default_zoom")
	
	
		local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,5,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(60)
		WhiteBox(container)
		self.MinimapSize = vgui.Create("DNumSlider",container)
		self.MinimapSize:SetText("Minimapgröße:")
		self.MinimapSize.Label:SetFont("gmaps_Details")
		self.MinimapSize:SetDark(true)
		self.MinimapSize:Dock(FILL)
		self.MinimapSize:DockMargin(15,0,0,0)
		self.MinimapSize:SetMinMax(1,3)
		
		self.MinimapSize:SetDecimals(0)
		self.MinimapSize:SetConVar("gmaps_mapsize")
	
	
		--[[ 	
	local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,5,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(60)
		WhiteBox(container)
	self.WorldPOI = vgui.Create("DCheckBoxLabel",container)
		self.WorldPOI:Dock(TOP)
		self.WorldPOI:DockMargin(15,7,0,0)
		self.WorldPOI:SetText("Show POI's in game world?")
		self.WorldPOI.Label:SetDark(true)
		self.WorldPOI.Label:SetContentAlignment(4)
		self.WorldPOI.Label:Dock(FILL)
		self.WorldPOI.Label:DockMargin(30,-1,0,0)
		self.WorldPOI.Label:SetFont("gmaps_Details")
		self.WorldPOI:SetConVar("gmaps_worldspace_poi")
	self.WorldNav = vgui.Create("DCheckBoxLabel",container)
		self.WorldNav:Dock(TOP)
		self.WorldNav:DockMargin(15,0,0,0)
		self.WorldNav:SetText("Show navigation path in game world?")
		self.WorldNav.Label:SetDark(true)
		self.WorldNav.Label:SetContentAlignment(4)
		self.WorldNav.Label:Dock(FILL)
		self.WorldNav.Label:DockMargin(30,-1,0,0)
		self.WorldNav.Label:SetFont("gmaps_Details")
		self.WorldNav:SetConVar("gmaps_worldspace_nav") ]]
	
	
	local bw,bm,ct = 100,5,135
	local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,5,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(ct)
		WhiteBox(container)
	self.TR = vgui.Create("DButton",container)
		self.TR:SetSize(bw,30)
		self.TR:SetPos(w-bw-bm-30,bm)
		self.TR:SetText("Oben Rechts")
		self.TR:SetFont("gmaps_Details")
		function self.TR.DoClick(this) 
			container.Active.Depressed = false
			container.Active:SetSelected(false)
			
			container.Active = this
			timer.Simple(0,function()
				this.Depressed = true
				this:SetSelected(true)
			end)
			
			RunConsoleCommand("gmaps_pin_corner",1)
		end
	self.TL = vgui.Create("DButton",container)
		self.TL:SetSize(bw,30)
		self.TL:SetPos(bm,bm)
		self.TL:SetText("Oben Links")
		self.TL:SetFont("gmaps_Details")
		function self.TL.DoClick(this) 
			container.Active.Depressed = false
			container.Active:SetSelected(false)
			
			container.Active = this
			timer.Simple(0,function()
				this.Depressed = true
				this:SetSelected(true)
			end)
			
			RunConsoleCommand("gmaps_pin_corner",2)
		end
	self.BL = vgui.Create("DButton",container)
		self.BL:SetSize(bw,30)
		self.BL:SetPos(bm,ct-bm-30)
		self.BL:SetText("Unten Links")
		self.BL:SetFont("gmaps_Details")
		function self.BL.DoClick(this) 
			container.Active.Depressed = false
			container.Active:SetSelected(false)
			
			container.Active = this
			timer.Simple(0,function()
				this.Depressed = true
				this:SetSelected(true)
			end)
			
			RunConsoleCommand("gmaps_pin_corner",3)
		end
	self.BR = vgui.Create("DButton",container)
		self.BR:SetSize(bw,30)
		self.BR:SetPos(w-bw-bm-30,ct-bm-30)
		self.BR:SetText("Unten Rechts")
		self.BR:SetFont("gmaps_Details")
		function self.BR.DoClick(this) 
			container.Active.Depressed = false
			container.Active:SetSelected(false)
			
			container.Active = this
			timer.Simple(0,function()
				this.Depressed = true
				this:SetSelected(true)
			end)
			
			RunConsoleCommand("gmaps_pin_corner",4)
		end
	self.Align = vgui.Create("DLabel",container)
		self.Align:SetText("Minimap Ecke")
		self.Align:SetFont("gmaps_FrameTitle")
		self.Align:SetDark(true)
		self.Align:SetContentAlignment(5)
		self.Align:Dock(FILL)
	
	local val = gmaps.PinCorner:GetInt()
	container.Active = val == 2 and self.TL or (val == 3 and self.BL or (val == 4 and self.BR or self.TR))
	container.Active.Depressed = true
	container.Active:SetSelected(true)
	
	
	
	--[[
	
	local container = vgui.Create("DPanel",list)
		container:Dock(TOP)
		container:DockMargin(0,0,0,5)
		container:DockPadding(5,5,5,5)
		container:SetTall(60)
		WhiteBox(container)
	self. = vgui.Create("DNumSlider",container)
		self.:Dock(FILL)
		self.:DockMargin(15,0,0,0)
		self.:SetText("")
		self..Label:SetFont("gmaps_Details")
		self.:SetConVar("gmaps_default_zoom")
	]]
	
	
end

function PNL:PerformLayout()

	local titlePush = 0

	if ( IsValid( self.imgIcon ) ) then

		self.imgIcon:SetPos( 5, 5 )
		self.imgIcon:SetSize( 16, 16 )
		titlePush = 16

	end

	self.btnClose:SetPos( self:GetWide() - 31 - 4, 0 )
	self.btnClose:SetSize( 31, 31 )

	self.btnMaxim:SetPos( self:GetWide() - 31 * 2 - 4, 0 )
	self.btnMaxim:SetSize( 31, 31 )

	self.btnMinim:SetPos( self:GetWide() - 31 * 3 - 4, 0 )
	self.btnMinim:SetSize( 31, 31 )

	self.lblTitle:SetPos( 8 + titlePush, 2 )
	self.lblTitle:SetSize( self:GetWide() - 25 - titlePush, 30 )

end

-- function PNL:OnFocusChanged(b)
	-- if !b and vgui.FocusedHasParent( self ) then
		-- self:Close()
	-- end
-- end


vgui.Register("DGMapsSettings",PNL,"DFrame")
--addons/billy_gas/lua/autorun/gmodadminsuite.lua:
if (CLIENT and not file.Exists("gmodadminsuite/sh_networking.lua", "LUA")) then
	-- serverside code failed for some reason, abort loading GAS
	return
end

if (CLIENT and GAS) then
	if (IsValid(GAS.Menu)) then
		GAS.Menu:Close()
	end
	if (IsValid(GAS.ModuleFrame)) then
		GAS.ModuleFrame:Close()
	end
end

if (not file.IsDir("gmodadminsuite", "DATA")) then
	file.CreateDir("gmodadminsuite", "DATA")
end

GAS = {}

--######## sv_hibernate_think ########--

if (SERVER) then
	RunConsoleCommand("sv_hibernate_think", "1")
end

--######## Clientside Lua Files ########--

AddCSLuaFile("gmodadminsuite_lua_functions.lua")
AddCSLuaFile("gmodadminsuite_config.lua")

AddCSLuaFile("gmodadminsuite/cl_contextmenu.lua")
AddCSLuaFile("gmodadminsuite/cl_menubar.lua")
AddCSLuaFile("gmodadminsuite/sh_teams.lua")
AddCSLuaFile("gmodadminsuite/sh_modules.lua")
AddCSLuaFile("gmodadminsuite/sh_language.lua")
AddCSLuaFile("gmodadminsuite/sh_afk.lua")
AddCSLuaFile("gmodadminsuite/cl_selection_prompts.lua")
AddCSLuaFile("gmodadminsuite/cl_menu.lua")
AddCSLuaFile("gmodadminsuite/cl_country_codes.lua")

AddCSLuaFile("gmodadminsuite/thirdparty/pon.lua")
AddCSLuaFile("gmodadminsuite/thirdparty/spon.lua")
AddCSLuaFile("gmodadminsuite/thirdparty/von.lua")

--######## PRINTING ########--

GAS_COLOR_WHITE = Color(255,255,255)

GAS_PRINT_COLOR_GOOD    = Color(0,255,0)
GAS_PRINT_COLOR_BAD     = Color(255,0,0)
GAS_PRINT_COLOR_NEUTRAL = Color(0,255,255)

GAS_PRINT_TYPE_INFO  = "[INFO]"
GAS_PRINT_TYPE_WARN  = "[WARN]"
GAS_PRINT_TYPE_FAIL  = "[FAIL]"
GAS_PRINT_TYPE_DEBUG = "[DEBUG]"
function GAS:print(print_text, print_status_or_type, print_type)
	local type_str = ""
	local print_status = GAS_PRINT_COLOR_NEUTRAL
	if (print_type) then
		print_status = print_status_or_type
		type_str = print_type .. " "
	else
		if (type(print_status_or_type) == "string") then
			type_str = print_status_or_type .. " "
		end
		if (type(print_status_or_type) == "table") then
			print_status = print_status_or_type
		end
	end
	MsgC(print_status, "[GmodAdminSuite] ", type_str, GAS_COLOR_WHITE, print_text .. "\n")
end
if (CLIENT) then
	function GAS:chatPrint(print_text, print_status_or_type, print_type)
		local type_str = ""
		local print_status = GAS_PRINT_COLOR_NEUTRAL
		if (print_type) then
			print_status = print_status_or_type
			type_str = print_type .. " "
		else
			if (type(print_status_or_type) == "string") then
				type_str = print_status_or_type .. " "
			end
			if (type(print_status_or_type) == "table") then
				print_status = print_status_or_type
			end
		end
		chat.AddText(print_status, "[GmodAdminSuite] ", type_str, GAS_COLOR_WHITE, print_text)
	end
end

local first_header = true
local header_space_len = 85
local header_padding = 3
function GAS:StartHeader(header)
	if (first_header) then
		first_header = false
	else
		GAS:print("")
	end
	local header_len = #header + (header_padding * 2)
	GAS:print("[" .. ("="):rep(math.floor(header_space_len / 2 - header_len / 2)) .. (" "):rep(header_padding) .. header .. (" "):rep(header_padding) .. ("="):rep(math.ceil(header_space_len / 2 - header_len / 2)) .. "]")
end
function GAS:HeaderPrint(str, print_status_or_type, print_type)
	local str_len = utf8.len(str)

	local type_str = ""
	local print_status = GAS_PRINT_COLOR_NEUTRAL
	if (print_type) then
		print_status = print_status_or_type
		type_str = print_type .. " "
	else
		if (type(print_status_or_type) == "string") then
			type_str = print_status_or_type .. " "
		end
		if (type(print_status_or_type) == "table") then
			print_status = print_status_or_type
		end
	end

	local header_space_len_padded = header_space_len - 2 - #type_str
	if (str_len > header_space_len_padded) then
		for i = 1, math.ceil(str_len / header_space_len_padded) do
			GAS:HeaderPrint(str:sub(((i - 1) * header_space_len_padded) + 1, i * header_space_len_padded), print_status_or_type, print_type)
		end
		return
	else
		MsgC(print_status, "[GmodAdminSuite] ", GAS_COLOR_WHITE, "[ ", print_status, type_str, GAS_COLOR_WHITE, str .. (" "):rep(header_space_len - str_len - #type_str - 2) .. " ]\n")
	end
end
function GAS:EndHeader()
	GAS:print("[" .. ("="):rep(header_space_len) .. "]")
end

--######## InitPostEntity ########--

GAS.InitPostEntity_hooks = {}
function GAS:InitPostEntity(func)
	if (GAS_InitPostEntity) then
		func()
	else
		table.insert(GAS.InitPostEntity_hooks, func)
	end
end
function GAS:InitPostEntity_Run()
	hook.Remove("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader")
	if GAS_InitPostEntity then return end

	GAS:print("InitPostEntity")
	GAS_InitPostEntity = true
	for _,v in ipairs(GAS.InitPostEntity_hooks) do v() end
end
if (SERVER) then
	util.AddNetworkString("GAS.InitPostEntityNetworking")

	net.Receive("GAS.InitPostEntityNetworking", function(_, ply)
		if (not ply.GAS_InitPostEntityNetworking) then
			ply.GAS_InitPostEntityNetworking = true
			net.Start("GAS.InitPostEntityNetworking")
			net.Send(ply)
		end
	end)
end

if (not GAS_InitPostEntity) then
	if (SERVER) then
		hook.Add("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader", GAS.InitPostEntity_Run)
		timer.Simple(0.1, GAS.InitPostEntity_Run)
	else
		hook.Add("InitPostEntity", "gmodadminsuite:InitPostEntity_Loader", function()
			net.Receive("GAS.InitPostEntityNetworking", function()
				timer.Remove("GAS.InitPostEntityNetworking")
				GAS:InitPostEntity_Run()
			end)
			local function DoPing()
				net.Start("GAS.InitPostEntityNetworking")
				net.SendToServer()
			end
			DoPing()
			timer.Create("GAS.InitPostEntityNetworking", 2, 0, DoPing)
		end)
	end
else
	GAS:InitPostEntity_Run()
end

--######## Initialize ########--

GAS_GMInitialize = GAS_GMInitialize == true or GM ~= nil or GAMEMODE ~= nil
GAS.GMInitialize_hooks = {}
function GAS:GMInitialize(func)
	if (GAS_GMInitialize) then
		func()
	else
		table.insert(GAS.GMInitialize_hooks, func)
	end
end
if (not GAS_GMInitialize) then
	local function GMInitialize()
		GAS_GMInitialize = true
		for _,v in ipairs(GAS.GMInitialize_hooks) do v() end
		GAS.GMInitialize_hooks = {}

		timer.Remove("gmodadminsuite:GMInitialize_Loader")
		hook.Remove("Initialize", "gmodadminsuite:GMInitialize_Loader")
	end
	hook.Add("Initialize", "gmodadminsuite:GMInitialize_Loader", function()
		timer.Remove("gmodadminsuite:GMInitialize_Loader")

		GAS:print("Gamemode initialized")

		GAS_GMInitialize = true
		for _,v in ipairs(GAS.GMInitialize_hooks) do v() end
		GAS.GMInitialize_hooks = {}
	end)
	timer.Simple(0, function()
		if (GM or GAMEMODE) then
			GMInitialize()
		else
			timer.Create("gmodadminsuite:GMInitialize_Loader", 1, 0, function()
				if (GM or GAMEMODE) then
					GAS:print("Gamemode initialized (late/did not fire)", GAS_PRINT_TYPE_WARN)
					GMInitialize()
				end
			end)
		end
	end)
end

--######## PRINT INFO ########--

GAS:StartHeader("GmodAdminSuite")

GAS.Version = "v1"
GAS:HeaderPrint("Version: " .. GAS.Version, GAS_PRINT_COLOR_GOOD)

--######## BillysErrors ########--

require("billyserrors")
if (SERVER) then
	GAS.BillysErrors = BillysErrors:AddAddon({
		Name  = "GmodAdminSuite",
		Color = Color(0,125,255),
		Icon  = "icon16/shield.png"
	})
end

--######## INITIALIZE ########--

include("gmodadminsuite/sh_core.lua")

--######## RELOADER ########--

concommand.Add("gas_reload", function(ply)
	if (SERVER and IsValid(ply)) then return end
	include("autorun/gmodadminsuite.lua")
end)
--addons/billy_gas/lua/gmodadminsuite_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	GmodAdminSuite has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which GmodAdminSuite can use.
	You'll find ways of integrating these Lua functions with GmodAdminSuite modules.

	More information on using GmodAdminSuite Lua functions can be found in module wikis.

]]

GAS.LuaFunctions = {
	["example_function"] = function(ply)
		if (ply:SteamID() == "STEAM_0:1:40314158" or ply:SteamID64() == "76561198112561190") then
			return true -- allow!
		elseif (ply:SteamID() == "STEAM_0:1:7099") then
			return false -- disallow!
		else
			return -- ignore!
		end
	end,
}

-- Do not delete the following line; your config will break.
return true
--addons/billy_gas/lua/gmodadminsuite/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = _G.pon or pon

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end
--addons/billy_gas/lua/gmodadminsuite/modules/commands/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "Désolé, mais vous n'avez pas la permission d'utiliser cette commande.",
		commands = "Commandes",
		command = "Commande",
		action = "Action",
		help = "Aide",
		new_command = "+ Nouvelle Commande",
		wiki = "Wiki",
		run_command = "Executer Commande",
		edit_command = "Modifier Commande",
		form_help = "Texte d'Assistance... (facultatif)",
		form_help_tip = "C'est le texte qui sera affiché dans le menu des commandes, dans le colonne \"Aide\".",
		select_action = "Selectionnez une Action...",
		hide_in_chat = "Masquer dans le chat ?",
		hide_in_chat_tip = "Si coché, le commande ne sera pas affiché dans le chat lorsque quelqu'un l'écrira.",
		finished = "Terminé",
		commands_case_insensitive = "Toutes les commandes ne sont pas sensibles aux majuscules.",
		ok = "OK",
		cannot_create_command = "Impossible de créer la commande !",
		cancel = "Annuler",
		delete_command = "Supprimer Commander",
		copy_command = "Copier Commande",
		permissions = "Permissions",
		permissions_editor = "Ouvrir l'Editeur de Permissions",
		permissions_tip = "Vous autorise à whitelister et blacklister les groupes d'utilisateurs et les équipes/métiers.",
		can_access_command = "Peu accéder à la commande",
		teams = "Equipes",
		usergroups = "Groupes d'Utilisateurs",
		anyone_can_access = "N'importe qui peut accéder à cette commande",
		whitelisted_only = "Seuls les membres whitelistés peuvent accéder à cette commande",
		non_blacklisted_only = "Seuls les membres non-blacklistés peuvent accéder à cette commande",
		whitelisted_and_blacklisted = "Seuls les membres whitelistés (excepté les blacklistés) peuvent accéder à cette commande",
		custom_usergroup = "+ Groupe d'Utilisateurs Custom",
		custom_usergroup_text = "Entrez groupe d'utilisateurs",
		custom_usergroup_placeholder = "Groupe d'Utilisateurs...",
		reason_usergroup_blacklisted = "Votre groupe d'utilisateurs est blacklisté sur cette commande.",
		reason_usergroup_not_whitelisted = "Votre group d'utilisateur n'est pas whitelisté sur cette commande.",
		reason_team_blacklisted = "Votre équipe est blacklistée sur cette commande.",
		reason_team_not_whitelisted = "Votre équipe n'est pas whitelistée sur cette commande.",
		saved_exclamation = "Sauvegardé !",
		set_position = "Définir Position",
		position_set = "Position Définie !",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Ouvrir le menu des commandes",
		action_command = "Executer commande console",
		action_chat = "Envoyer un message textuel",
		action_website = "Ouvrir Site Web",
		action_lua_function_sv = "Fonction Lua Client",
		action_lua_function_cl = "Fonction Lua Serveur",
		action_gas_module = "Ouvrir Module GAS",
		action_teleport = "Téléportation",

		form_action_command = "Commande console à éxécuter",
		form_action_chat = "Message textuel à envoyer",
		form_action_website = "Site Web à ouvrir",
		form_action_lua_function_sv = "Fonction Lua à éxécuter\nCôté Serveur",
		form_action_lua_function_cl = "Fonction Lua à éxécuter\nCôté Client",
		form_action_gas_module = "Module GAS à ouvrir",
		form_action_teleport = "Téléportation",

		error_command_exists = "Une commande avec ce nom existe déjà !",
		error_no_command = "Vous n'avez entré aucune commande.",
		error_no_command_execute = "Vous n'avez pas entré la commande à éxécuter.",
		error_no_action = "Vous n'avez pas séléctionné d'action pour cette commande.",
		error_invalid_website = "Le site web spécifié n'est pas une adresse valide.",
		error_no_lua_function = "Vous n'avez pas séléctionné de Fonction Lua à éxécuter.",
		error_no_gas_module = "Vous n'avez pas séléctionné de module GAS à ouvrir.",
		error_no_position_set = "Vous n'avez pas spécifié de position et d'angle pour cette téléportation.",

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "次要用户组",

            open_menu = "打开菜单",
            custom_ellipsis = "自定义...",
            usergroup_ellipsis = "用户组...",
            players = "玩家",
            settings = "设置",
            give_usergroup = "赋予用户组",
            usergroup_is_main = "这是用户的主用户组，不能被赋予或撤销。",
            help = "帮助",
            offline_btn = "新玩家...",
            loading_ellipsis = "加载中...",
            unknown = "未知",
        }
    end
}
--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Billy's Logs",
	Category = GAS.MODULE_CATEGORY_ADMINISTRATION,
	Wiki = "https://gmodsto.re/blogs-wiki",
	Icon = "icon16/database_lightning.png",
	GmodStore = "6016",
	License = '{"licensee":"76561199084268794","keys":{"xeon-de":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","xeon-us":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"}}'
}
--addons/billy_gas/lua/gmodadminsuite/cl_contextmenu.lua:
local function L(phrase, ...)
	if (#({...}) > 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.ContextProperties = {}
function GAS:ContextProperty(name, propertydata)
	GAS.ContextProperties[name] = propertydata
end

properties.Add("GmodAdminSuite", {
	MenuLabel = "GmodAdminSuite",
	MenuIcon = "icon16/shield.png",
	Filter = function(self, ent, ply)
		if (not IsValid(ent)) then return false end
		if (table.Count(GAS.ContextProperties) == 0) then return false end
		return true
	end,
	MenuOpen = function(self, option, ent, tr)
		local option_submenu = option:AddSubMenu()
		option_submenu:AddOption(L"open_menu", self.Action):SetIcon("icon16/application_form_magnify.png")
		local spacer = false
		for i,v in pairs(GAS.ContextProperties) do
			if (v.Filter and v.Filter(self, ent, LocalPlayer()) == false) then continue end
			if (not spacer) then spacer = true option_submenu:AddSpacer() end
			local submenu, submenu_pnl = option_submenu:AddSubMenu(v.MenuLabel, v.Action)
			if (v.MenuIcon) then
				submenu_pnl:SetIcon(v.MenuIcon)
			end
			if (v.MenuOpen) then
				v.MenuOpen(self, submenu, ent, tr, submenu_pnl)
			end
		end
	end,
	Action = function()
		RunConsoleCommand("gmodadminsuite")
	end
})

--lua/autorun/grady_aoc_event.lua:
--501st--

list.Set( "501st Trooper 1", "models/starwars/grady/501st/501st_trooper1.mdl" )   // "models/starwars/grady/501st/501st_trooper1.mdl" )
player_manager.AddValidModel( "501st Trooper 1", "models/starwars/grady/501st/501st_trooper1.mdl" )   // "models/starwars/grady/501st/501st_trooper1.mdl" )
player_manager.AddValidHands( "501st Trooper 1", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st Trooper 2", "models/starwars/grady/501st/501st_trooper2.mdl" )   // "models/starwars/grady/501st/501st_trooper2.mdl" )
player_manager.AddValidModel( "501st Trooper 2", "models/starwars/grady/501st/501st_trooper2.mdl" )   // "models/starwars/grady/501st/501st_trooper2.mdl" )
player_manager.AddValidHands( "501st Trooper 2", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

--501st ARF--

list.Set( "501st ARF 1", "models/starwars/grady/501st_arf/501st_arf1.mdl" )   // "models/starwars/grady/501st_arf/501st_arf1.mdl" )
player_manager.AddValidModel( "501st Trooper 1", "models/starwars/grady/501st_arf/501st_arf1.mdl" )   // "models/starwars/grady/501st_arf/501st_arf1.mdl" )
player_manager.AddValidHands( "501st Trooper 1", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st ARF 2", "models/starwars/grady/501st_arf/501st_arf2.mdl" )   // "models/starwars/grady/501st_arf/501st_arf2.mdl" )
player_manager.AddValidModel( "501st Trooper 2", "models/starwars/grady/501st_arf/501st_arf2.mdl" )   // "models/starwars/grady/501st_arf/501st_arf2.mdl" )
player_manager.AddValidHands( "501st Trooper 2", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

--501st AVP--

list.Set( "501st AVP 1", "models/starwars/grady/501st_avp/501st_avp1.mdl" )   // "models/starwars/grady/501st_avp/501st_avp1.mdl" )
player_manager.AddValidModel( "501st Trooper 1", "models/starwars/grady/501st_avp/501st_avp1.mdl" )   // "models/starwars/grady/501st_avp/501st_avp1.mdl" )
player_manager.AddValidHands( "501st Trooper 1", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st AVP 2", "models/starwars/grady/501st_avp/501st_avp2.mdl" )   // "models/starwars/grady/501st_avp/501st_avp2.mdl" )
player_manager.AddValidModel( "501st Trooper 2", "models/starwars/grady/501st_avp/501st_avp2.mdl" )   // "models/starwars/grady/501st_avp/501st_avp2.mdl" )
player_manager.AddValidHands( "501st Trooper 2", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st Pilot 1", "models/starwars/grady/501st_avp/501st_pilot1.mdl" )   // "models/starwars/grady/501st_avp/501st_pilot1.mdl" )
player_manager.AddValidModel( "501st Trooper 1", "models/starwars/grady/501st_avp/501st_pilot1.mdl" )   // "models/starwars/grady/501st_avp/501st_pilot1.mdl" )
player_manager.AddValidHands( "501st Trooper 1", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st Pilot 2", "models/starwars/grady/501st_avp/501st_pilot2.mdl" )   // "models/starwars/grady/501st_avp/501st_pilot2.mdl" )
player_manager.AddValidModel( "501st Trooper 2", "models/starwars/grady/501st_avp/501st_pilot2.mdl" )   // "models/starwars/grady/501st_avp/501st_pilot2.mdl" )
player_manager.AddValidHands( "501st Trooper 2", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

--501st Medic--

list.Set( "501st Medic 1", "models/starwars/grady/501st_medic/501st_medic1.mdl" )   // "models/starwars/grady/501st_medic/501st_medic1.mdl" )
player_manager.AddValidModel( "501st Trooper 1", "models/starwars/grady/501st_medic/501st_medic1.mdl" )   // "models/starwars/grady/501st_medic/501st_medic1.mdl" )
player_manager.AddValidHands( "501st Trooper 1", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

list.Set( "501st Medic 2", "models/starwars/grady/501st_medic/501st_medic2.mdl" )   // "models/starwars/grady/501st_medic/501st_medic2.mdl" )
player_manager.AddValidModel( "501st Trooper 2", "models/starwars/grady/501st_medic/501st_medic2.mdl" )   // "models/starwars/grady/501st_medic/501st_medic2.mdl" )
player_manager.AddValidHands( "501st Trooper 2", "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000" ) // "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 6, "00000000"

--Carlos Burak--

list.Set( "Carlos Burak", "models/starwars/grady/meme/burak_carlos.mdl" )   // "models/starwars/grady/models/starwars/grady/meme/burak_carlos.mdl.mdl" )
player_manager.AddValidModel( "Carlos Burak", "models/starwars/grady/meme/burak_carlos.mdl" )   // "models/starwars/grady/meme/burak_carlos.mdl.mdl" )
--addons/tools/lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--addons/joes_stuff/lua/bomb_system/sh_config.lua:
BombSystem.damage = 500 -- the damage of the bomb

BombSystem.radius = 1000 -- the radius of the bomb

BombSystem.colors = {
    Yellow = Color(100,100,0),
    Blue = Color(0,0,100),
    Green = Color(0,100,0),
    Red = Color(100,0,0),
    Orange = Color(100,50,0),
    Black = Color(0,0,0),
    White = Color(100,100,100),
}
--addons/weapon_jedi/lua/lscs/autorun/cl_hud.lua:

LSCS_HUD_POINTS_FORCE = 1
LSCS_HUD_POINTS_BLOCK = 2
LSCS_HUD_POINTS_ADVANTAGE = 3
LSCS_HUD_STANCE = 4

function LSCS:HUDShouldHide( LSCS_HUD )
	local ShouldDraw = hook.Run( "LSCS:HUDShouldDraw", LSCS_HUD )

	if ShouldDraw == false then return true end

	-- if ShouldDraw == true then return false end -- should the hook overpower client settings? i dont know.. If you have this edgecase please make a github issue and i will change this.

	return not LSCS.DrawHud
end

--addons/weapon_jedi/lua/lscs/combos/default.lua:
COMBO.id = "default"
COMBO.PrintName = "No-Stance"
COMBO.Author = "Luna"
COMBO.Description = "Everyone can swing a Lightsaber, but having a Lightsaber does not make you Jedi."

COMBO.DeflectBullets = false
COMBO.AutoBlock = false

COMBO.LeftSaberActive = false

COMBO.HoldType = "melee"

COMBO.Spawnable = false 

COMBO.Attacks = {}
COMBO.Attacks["____"] = {
	AttackAnim = "range_melee",
	AttackAnimMenu = "seq_baton_swing",

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
	end,
	FinishAttack = function( weapon, ply )  
	end,
	Delay = 0,
	Duration = 0.25,
}
--addons/lvs_base/lua/lvs_framework/autorun/lvs_soundscripts.lua:

sound.Add( {
	name = "LVS.Physics.Scrape",
	channel = CHAN_STATIC,
	level = 80,
	sound = "lvs/physics/scrape_loop.wav"
} )

sound.Add( {
	name = "LVS.Physics.Wind",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/wind_loop.wav",
} )

sound.Add( {
	name = "LVS.Physics.Water",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/water_loop.wav",
} )

sound.Add( {
	name = "LVS.DYNAMIC_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 110},
	sound = "^lvs/explosion_dist.wav"
} )

sound.Add( {
	name = "LVS.MISSILE_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 120},
	sound = {
		"ambient/levels/streetwar/city_battle17.wav",
		"ambient/levels/streetwar/city_battle18.wav",
		"ambient/levels/streetwar/city_battle19.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/dyn1.wav",
		"^lvs/explosions/dyn2.wav",
		"^lvs/explosions/dyn3.wav",
		"^lvs/explosions/dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/close1.wav",
		"lvs/explosions/close2.wav",
		"lvs/explosions/close3.wav",
		"lvs/explosions/close4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/med_dyn1.wav",
		"^lvs/explosions/med_dyn2.wav",
		"^lvs/explosions/med_dyn3.wav",
		"^lvs/explosions/med_dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/med_close1.wav",
		"lvs/explosions/med_close2.wav",
		"lvs/explosions/med_close3.wav",
		"lvs/explosions/med_close4.wav",
	}
} )


sound.Add( {
	name = "LVS.EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 115,
	pitch = {95, 115},
	sound = "lvs/explosion.wav"
} )

if CLIENT then
	local SoundList = {}

	hook.Add( "EntityEmitSound", "!!!lvs_fps_rape_fixer", function( t )
		if not t.Entity.LVS and not t.Entity._LVS then return end

		local SoundFile = t.SoundName

		if SoundList[ SoundFile ] == true then
			return true

		elseif SoundList[ SoundFile ] == false then
			return false

		else
			local File = string.Replace( SoundFile, "^", "" )

			local Exists = file.Exists( "sound/"..File , "GAME" )

			SoundList[ SoundFile ] = Exists

			if not Exists then
				print("[LVS] '"..SoundFile.."' not found. Soundfile will not be played and is filtered for this game session to avoid fps issues.")
			end
		end
	end )
end

--lua/autorun/mandalorian_npc.lua:
local Category = "StarWars"

local NPC =
{
	Name = "Mandalorian Bounty Hunter",
	Class = "npc_citizen",
	KeyValues =
	{
		citizentype = 4
	},
	Model = "models/Porky-da-Corgi/StarWars/Mandalorians/bountyhunter_npc.mdl",
	Health = "1000",
	Category = Category
}

list.Set( "NPC", "npc_mandalorian", NPC )

--lua/autorun/massif.lua:
player_manager.AddValidModel( "massif", 	"models/mrpounder1/player/massif.mdl" );

--addons/billy_gas/lua/openpermissions/lang/english.lua:
return {
	Name = "English",
	Icon = "flags16/gb.png",
	Phrases = {
		operator_only_menu = "Only OpenPermissions Operators can access this menu.",
		permissions = "Permissions",
		help = "Help",
		tester = "Tester",
		access_groups = "Access Groups",
		access_group = "Access Group",
		type = "Type",
		add_access_group = "Add Access Group",
		custom_ellipsis = "Custom...",
		enter_usergroup = "Enter the name of a usergroup",
		enter_steamid = "Enter a SteamID or SteamID64. Examples:\nSteamID: %s\nSteamID64: %s",
		invalid_steamid = "That was not a valid SteamID.",
		error = "Error",
		ok = "OK",
		none_info = "(none)",
		key = "Key",
		access_group_exists = "This access group already exists.",
		operations = "Operations",
		select_an_access_group = "Please select access group(s) on the left",
		back_btn = "Back",
		delete_access_group = "Delete Selected Access Group(s)",
		copy = "Copy",
		paste = "Paste",
		all_permissions = "All Permissions",
		all_addons = "All Addons",
		save = "Save",
		not_an_addon = "That's not a valid addon.",
		hold_ctrl_to_select_multiple = "Hold CTRL to multiselect groups",
		permission_clash_msg = "WARNING: You have selected multiple access groups to copy, only permissions where\nall access groups have the same permission will be copied",
		Players = "Players",

		ACCESS_GROUP_OTHER = "Other",
		ACCESS_GROUP_USERGROUP = "Usergroup",
		ACCESS_GROUP_STEAMID = "SteamID",
		ACCESS_GROUP_TEAM = "Team",
		ACCESS_GROUP_LUA_FUNCTION = "Lua Function",
		ACCESS_GROUP_DARKRP_CATEGORY = "DarkRP Job Category",
	}
}
--addons/admin_sam/lua/sam/sh_util.lua:
if SAM_LOADED then return end

local sam = sam

function sam.parse_args(str)
	local args = {}
	local tmp, in_quotes = "", false
	for i = 1, #str do
		local char = str:sub(i, i)
		if char == "\"" then
			-- i could use string.find to find the next double quotes but thats gonna be overkill
			in_quotes = not in_quotes
			if tmp ~= "" or not in_quotes then
				args[#args + 1], tmp = tmp, ""
			end
		elseif char ~= " " or in_quotes then
			tmp = tmp .. char
		elseif tmp ~= "" then
			args[#args + 1], tmp = tmp, ""
		end
	end
	if tmp ~= "" then
		args[#args + 1] = tmp
	end
	return args, #args
end

function sam.get_targets_list(targets)
	if sam.isstring(targets) then
		return {Color(244, 67, 54), targets}
	end

	local len = #targets

	if len == player.GetCount() and len > 1 then
		return {Color(244, 67, 54), sam.language.get("Everyone")}
	end

	local admin = targets.admin
	local result = {}
	local white = Color(236, 240, 241)
	for i = 1, len do
		local target = targets[i]

		if CLIENT and LocalPlayer() == target then
			table.insert(result, Color(255, 215, 0))
			if admin ~= LocalPlayer() then
				table.insert(result, sam.language.get("You"))
			else
				table.insert(result, sam.language.get("Yourself"))
			end
		elseif admin ~= target then
			local name
			if sam.isentity(target) and target.Name then
				name = target:Name()
			else
				name = "Unknown"
				table.insert(result, white)
				table.insert(result, "*")
			end

			table.insert(result, Color(244, 67, 54))
			table.insert(result, name)
		else
			table.insert(result, Color(255, 215, 0))
			table.insert(result, sam.language.get("Themself"))
		end

		if i ~= len then
			table.insert(result, white)
			table.insert(result, ",")
		end
	end

	return result
end

function sam.is_steamid(id, err) -- https://stackoverflow.com/questions/6724268/check-if-input-matches-steam-id-format
	if sam.isstring(id) and id:match("^STEAM_[0-5]:[0-1]:[0-9]+$") ~= nil then
		return true
	else
		return err and error("invalid steamid", 2) or false
	end
end

function sam.is_steamid64(id, err)
	if sam.isstring(id)
		and tonumber(id)
		and id:sub(1, 7) == "7656119"
		and (#id == 17 or #id == 18) then
		return true
	else
		return err and error("invalid steamid64", 2) or false
	end
end

do
	local console = {}

	do
		local return_console = function()
			return "Console"
		end
		for _, v in ipairs({"SteamID", "SteamID64", "Name", "Nick", "Name"}) do
			console[v] = return_console
		end
		setmetatable(console, {
			__tostring = return_console,
			MetaName = "console"
		})
	end

	function console.IsAdmin()
		return true
	end

	function console.IsSuperAdmin()
		return true
	end

	function console:IsUserGroup(name)
		return name == "superadmin"
	end

	function console.GetUserGroup()
		return "superadmin"
	end

	function console.HasPermission()
		return true
	end

	function console.CanTarget()
		return true
	end

	function console.CanTargetRank()
		return true
	end

	function console.GetBanLimit()
		return 0
	end

	function console.SetUserGroup()
	end

	function sam.isconsole(v)
		return v == console
	end

	sam.console = console
end

do
	local times = {
		"year"; 525600,
		"month"; 43800,
		"week"; 10080,
		"day"; 1440,
		"hour"; 60,
		"minute"; 1
	}

	for i = 1, #times, 2 do
		times[i] = " " .. times[i]
	end

	local floor = math.floor
	function sam.format_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "Indefinitely"
		elseif mins <= 1 then
			return "1 minute"
		end

		local str = ""
		for i = 1, #times, 2 do
			local n1, n2 = times[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					if mins == 0 then
						str = str .. " and "
					else
						str = str .. ", "
					end
				end
				str = str .. n2 .. times[i]
				if n2 > 1 then
					str = str .. "s"
				end
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	local times = {
		m = 1,
		h = 60,
		d = 1440,
		w = 10080,
		mo = 43800,
		y = 525600
	}

	function sam.parse_length(length)
		local time, found = tonumber(length), false
		if sam.isnumber(length) then
			time, found = length, true
		elseif time then
			found = true
		else
			time = 0
			for t, u in length:gmatch("(%d+)(%a+)") do
				u = times[u]
				if u then
					time = time + (u * t)
					found = true
				end
			end
		end
		if not found then return false end
		return math.Clamp(time, 0, 31536000)
	end

	local times2 = {}
	for k, v in SortedPairsByValue(times, true) do
		table.insert(times2, k)
		table.insert(times2, v)
	end

	local floor = math.floor
	function sam.reverse_parse_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2, 2 do
			local n1, n2 = times2[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	if SERVER then
		function sam.hook_call(event, ...)
			hook.Call(event, nil, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end

		function sam.client_hook_call(event, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end
	else
		local function hook_call(event, ...)
			hook.Call(event, nil, ...)
		end
		sam.netstream.Hook("HookCall", hook_call)
	end
end

if SERVER then
	local maps = {}

	for k, v in ipairs(file.Find("maps/*.bsp", "GAME")) do
		maps[k] = v:sub(1, -5):lower()
	end

	sam.set_global("Maps", maps)
end

function sam.is_valid_map(name)
	local maps = sam.get_global("Maps", {})
	if name:sub(-4) == ".bsp" then
		name = name:sub(1, -5)
	end
	name = name:lower()
	for i = 1, #maps do
		if maps[i] == name then
			return name
		end
	end
	return false
end

function sam.is_valid_gamemode(name)
	name = name:lower()
	local gamemodes = engine.GetGamemodes()
	for i = 1, #gamemodes do
		local gamemode = gamemodes[i]
		if sam.isstring(gamemode.name) and gamemode.name:lower() == name then
			return true
		end
	end
	return false
end

function sam.hook_first(event, name, func)
	if HOOK_HIGH then
		return hook.Add(event, name, func, HOOK_HIGH)
	end

	return hook.Add(event, name, func)
end

function sam.hook_last(event, name, func)
	if HOOK_LOW then
		return hook.Add(event, name, func, HOOK_LOW)
	end

	return hook.Add(event, name, func)
end

do
	local byte = string.byte
	local gsub = string.gsub
	local char = string.char
	local format = string.format
	local tonumber = tonumber

	local hex_encode = function(c)
		return format("%02X", byte(c))
	end

	function sam.to_hex(text)
		-- gsub returns more than one value, fucking glualint can't stop complaining about using ()
		local hex = gsub(text, ".", hex_encode)
		return hex
	end

	local hex_decode = function(d)
		return char(tonumber(d, 16))
	end

	function sam.from_hex(hex)
		local text = (gsub(hex, "%x%x", hex_decode))
		return text
	end
end

--addons/admin_sam/lua/sam_languages/english.lua:
return {
	You = "You",
	Yourself = "Yourself",
	Themself = "Themself",
	Everyone = "Everyone",

	cant_use_as_console = "You need to be a player to use {S Red} command!",
	no_permission = "You don't have permission to use '{S Red}'!",

	cant_target_multi_players = "You can't target multiple players using this command!",
	invalid_id = "Invalid id ({S Red})!",
	cant_target_player = "You can't target {S Red}!",
	cant_target_self = "You can't target your self using {S Red} command!",
	player_id_not_found = "Player with id {S Red} is not found!",
	found_multi_players = "Found multiple players: {T}!",
	cant_find_target = "Can't find a player to target ({S Red})!",

	invalid = "Invalid {S} ({S_2 Red})",
	default_reason = "none",

	menu_help = "Open admin mod menu.",

	-- Chat Commands
	pm_to = "PM to {T}: {V}",
	pm_from = "PM from {A}: {V}",
	pm_help = "Send a personal message (PM) to a player.",

	to_admins = "{A} to admins: {V}",
	asay_help = "Send a message to admins.",

	mute = "{A} muted {T} for {V}. ({V_2})",
	mute_help = "Stop player(s) from sending messages in chat.",

	unmute = "{A} unmuted {T}.",
	unmute_help = "Unmute player(s).",

	you_muted = "You are muted.",

	gag = "{A} gagged {T} for {V}. ({V_2})",
	gag_help = "Stop player(s) from speaking.",

	ungag = "{A} ungagged {T}.",
	ungag_help = "Ungag player(s).",

	-- Fun Commands
	slap = "{A} slapped {T}.",
	slap_damage = "{A} slapped {T} with {V} damage.",
	slap_help = "Slap asses.",

	slay = "{A} slayed {T}.",
	slay_help = "Slay player(s).",

	set_hp = "{A} set the hp for {T} to {V}.",
	hp_help = "Set health for player(s).",

	set_armor = "{A} set the armor for {T} to {V}.",
	armor_help = "Set armor for player(s).",

	ignite = "{A} ignited {T} for {V}.",
	ignite_help = "Ignite player(s).",

	unignite = "{A} extinguished {T}.",
	unignite_help = "Extinguish player(s).",

	god = "{A} enabled god mode for {T}.",
	god_help = "Enable god mode for player(s).",

	ungod = "{A} disabled god mode for {T}.",
	ungod_help = "Disable god mode for player(s).",

	freeze = "{A} froze {T}.",
	freeze_help = "Freeze player(s).",

	unfreeze = "{A} unfroze {T}.",
	unfreeze_help = "Unfreeze player(s).",

	cloak = "{A} cloaked {T}.",
	cloak_help = "Cloak player(s).",

	uncloak = "{A} uncloaked {T}.",
	uncloak_help = "Uncloak player(s).",

	jail = "{A} jailed {T} for {V}. ({V_2})",
	jail_help = "Jail player(s).",

	unjail = "{A} unjailed {T}.",
	unjail_help = "Unjail player(s).",

	strip = "{A} stripped weapons from {T}.",
	strip_help = "Strip weapons from player(s).",

	respawn = "{A} respawned {T}.",
	respawn_help = "Respawn player(s).",

	setmodel = "{A} set the model for {T} to {V}.",
	setmodel_help = "Change player(s)'s model.",

	giveammo = "{A} gave {T} {V} ammo.",
	giveammo_help = "Give player(s) ammo.",

	scale = "{A} set model scale for {T} to {V}.",
	scale_help = "Scale player(s).",

	freezeprops = "{A} froze all props.",
	freezeprops_help = "Freezes all props on the map.",

	-- Teleport Commands
	dead = "You are dead!",
	leave_car = "Leave the vehicle first!",

	bring = "{A} teleported {T}.",
	bring_help = "Bring a player.",

	goto = "{A} teleported to {T}.",
	goto_help = "Goto a player.",

	no_location = "No previous location to return {T} to.",
	returned = "{A} returned {T}.",
	return_help = "Return a player to where he was.",

	-- User Management Commands
	setrank = "{A} set the rank for {T} to {V} for {V_2}.",
	setrank_help = "Set a player's rank.",
	setrankid_help = "Set a player's rank by his steamid/steamid64.",

	addrank = "{A} created a new rank {V}.",
	addrank_help = "Create a new rank.",

	removerank = "{A} removed rank {V}.",
	removerank_help = "Remove a rank.",

	super_admin_access = "superadmin has access to everything!",

	giveaccess = "{A} granted access {V} to {T}.",
	givepermission_help = "Give permission to rank.",

	takeaccess = "{A} taken access {V} from {T}.",
	takepermission_help = "Take permission from rank.",

	renamerank = "{A} renamed rank {T} to {V}.",
	renamerank_help = "Rename rank.",

	changeinherit = "{A} changed the rank to inherit from for {T} to {V}.",
	changeinherit_help = "Change the rank to inherit from.",

	rank_immunity = "{A} changed rank {T}'s immunity to {V}.",
	changerankimmunity_help = "Change rank immunity.",

	rank_ban_limit = "{A} changed rank {T}'s ban limit to {V}.",
	changerankbanlimit_help = "Change rank ban limit.",

	changeranklimit = "{A} changed {V} limit for {T} to {V_2}.",
	changeranklimit_help = "Change rank limits.",

	-- Utility Commands
	map_change = "{A} changing the map to {V} in 10 seconds.",
	map_change2 = "{A} changing the map to {V} with gamemode {V_2} in 10 seconds.",
	map_help = "Change current map and gamemode.",

	map_restart = "{A} restarting the map in 10 seconds.",
	map_restart_help = "Restart current map.",

	mapreset = "{A} reset the map.",
	mapreset_help = "Reset the map.",

	kick = "{A} kicked {T} Reason: {V}.",
	kick_help = "Kick a player.",

	ban = "{A} banned {T} for {V} ({V_2}).",
	ban_help = "Ban a player.",

	banid = "{A} banned ${T} for {V} ({V_2}).",
	banid_help = "Ban a player using his steamid.",

	-- ban message when admin name doesn't exists
	ban_message = [[


		You are banned by: {S}

		Reason: {S_2}

		You will be unbanned in: {S_3}]],

	-- ban message when admin name exists
	ban_message_2 = [[


		You are banned by: {S} ({S_2})

		Reason: {S_3}

		You will be unbanned in: {S_4}]],

	unban = "{A} unbanned {T}.",
	unban_help = "Unban a player using his steamid.",

	noclip = "{A} has toggled noclip for {T}.",
	noclip_help = "Toggle noclip on player(s).",

	cleardecals = "{A} cleared ragdolls and decals for all players.",
	cleardecals_help = "Clear ragdolls and decals for all players.",

	stopsound = "{A} stopped all sounds.",
	stopsound_help = "Stop all sounds for all players.",

	not_in_vehicle = "You are not in a vehicle!",
	not_in_vehicle2 = "{S Blue} is not in a vehicle!",
	exit_vehicle = "{A} forced {T} to get out from a vehicle.",
	exit_vehicle_help = "Force a player out of a vehicle.",

	time_your = "Your total time is {V}.",
	time_player = "{T} total time is {V}.",
	time_help = "Check a player's time.",

	admin_help = "Activate admin mode.",
	unadmin_help = "Deactivate admin mode.",

	buddha = "{A} enabled buddha mode for {T}.",
	buddha_help = "Make player(s) godmoded when their health is 1.",

	unbuddha = "{A} disabled buddha mode for {T}.",
	unbuddha_help = "Disable buddha mode for player(s).",

	give = "{A} gave {T} {V}.",
	give_help = "Give player(s) weapon/entity",

	-- DarkRP Commands
	arrest = "{A} arrested {T} forever.",
	arrest2 = "{A} arrested {T} for {V} seconds.",
	arrest_help = "Arrest player(s).",

	unarrest = "{A} unarrested {T}.",
	unarrest_help = "Unarrest player(s).",

	setmoney = "{A} set money for {T} to {V}.",
	setmoney_help = "Set money for a player.",

	addmoney = "{A} added {V} for {T}.",
	addmoney_help = "Add money for a player.",

	door_invalid = "invalid door to sell.",
	door_no_owner = "no one owns this door.",

	selldoor = "{A} sold a door/vehicle for {T}.",
	selldoor_help = "Unown the door/vehicle you are looking at.",

	sellall = "{A} sold every door/vehicle for {T}.",
	sellall_help = "Sell every door/vehicle owned for a player.",

	s_jail_pos = "{A} set a new jail position.",
	setjailpos_help = "Resets all jail positions and sets a new one at your location.",

	a_jail_pos = "{A} added a new jail position.",
	addjailpos_help = "Adds a jail position at your current location.",

	setjob = "{A} set {T}'s job to {V}.",
	setjob_help = "Change a player's job.",

	shipment = "{A} spawned {V} shipment.",
	shipment_help = "Spawn a shipment.",

	forcename = "{A} set the name for {T} to {V}.",
	forcename_taken = "Name already taken. ({V})",
	forcename_help = "Force name for a player.",

	report_claimed = "{A} claimed a report submitted by {T}.",
	report_closed = "{A} closed a report submitted by {T}.",
	report_aclosed = "Your report is closed. (Time expired)",

	rank_expired = "{V} rank for {T} expired.",

	-- TTT Commands
	setslays = "{A} set amount of auto-slays for {T} to {V}.",
	setslays_help = "Set amount of rounds to auto-slay a player for.",

	setslays_slayed = "{T} got auto-slayed, slays left: {V}.",

	removeslays = "{A} removed auto-slays for {T}.",
	removeslays_help = "Remove auto-slays for a player."
}
--addons/admin_sam/lua/sam/player/cl_player.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream

netstream.Hook("PlaySound", function(sound)
	surface.PlaySound(sound)
end)
--addons/admin_sam/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--addons/admin_sam/lua/sam/menu/sh_init.lua:
if SAM_LOADED then return end

require("sui")

sam.command.new("menu")
	:Help("Open admin mod menu")
	:MenuHide()
	:DisableNotify()
	:OnExecute(function(ply)
		sam.netstream.Start(ply, "OpenMenu")
	end)
:End()

if CLIENT then
	sam.netstream.Hook("OpenMenu", function()
		sam.menu.open_menu()
	end)
end

if SERVER then
	for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
		sam.load_file("sam/menu/tabs/" .. f)
	end
end
--addons/admin_sam_sui/lua/sui/libs/types.lua:
-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sui.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sui["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sui.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sui.IsEntity = sui.isentity

local type = sui.type
function sui.istable(value)
	return type(value) == "table"
end
--addons/admin_sam_sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--addons/admin_sam_sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--addons/admin_sam_sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_imgur_button.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "ImageSize", "ImageSize", FORCE_NUMBER)
AccessorFunc(PANEL, "NormalColor", "NormalColor")
AccessorFunc(PANEL, "HoverColor", "HoverColor")
AccessorFunc(PANEL, "ClickColor", "ClickColor")
AccessorFunc(PANEL, "DisabledColor", "DisabledColor")

function PANEL:Init()
    self.ImageCol = PIXEL.CopyColor(color_white)
    self:SetImgurID("635PPvg")

    self:SetNormalColor(color_white)
    self:SetHoverColor(color_white)
    self:SetClickColor(color_white)
    self:SetDisabledColor(color_white)

    self:SetImageSize(1)
end

function PANEL:PaintBackground(w, h) end

function PANEL:Paint(w, h)
    self:PaintBackground(w, h)

    local imageSize = h * self:GetImageSize()
    local imageOffset = (h - imageSize) / 2

    if not self:IsEnabled() then
        PIXEL.DrawImgur(imageOffset, imageOffset, imageSize, imageSize, self:GetImgurID(), self:GetDisabledColor())
        return
    end

    local col = self:GetNormalColor()

    if self:IsHovered() then
        col = self:GetHoverColor()
    end

    if self:IsDown() or self:GetToggle() then
        col = self:GetClickColor()
    end

    self.ImageCol = PIXEL.LerpColor(FrameTime() * 12, self.ImageCol, col)

    PIXEL.DrawImgur(imageOffset, imageOffset, imageSize, imageSize, self:GetImgurID(), self.ImageCol)
end

vgui.Register("PIXEL.ImgurButton", PANEL, "PIXEL.Button")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_text_entry.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]


local PANEL = {}

function PANEL:Init()
    self.TextEntry = vgui.Create("PIXEL.TextEntryInternal", self)

    self.PlaceholderTextCol = PIXEL.OffsetColor(PIXEL.Colors.SecondaryText, -110)

    self.DisabledCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
    self.FocusedOutlineCol = PIXEL.Colors.PrimaryText

    self.OutlineCol = PIXEL.OffsetColor(PIXEL.Colors.Scroller, 10)
    self.InnerOutlineCol = PIXEL.CopyColor(PIXEL.Colors.Transparent)
end

function PANEL:PerformLayout(w, h)
    self.TextEntry:Dock(FILL)

    local xPad, yPad = PIXEL.Scale(4), PIXEL.Scale(8)
    self:DockPadding(xPad, yPad, xPad, yPad)
end

function PANEL:Paint(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.DisabledCol)
        PIXEL.DrawSimpleText("Disabled", "UI.TextEntry", PIXEL.Scale(4), h / 2, PIXEL.Colors.SecondaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        return
    end

    if self:GetValue() == "" then
        PIXEL.DrawSimpleText(self:GetPlaceholderText() or "", "UI.TextEntry", PIXEL.Scale(10), h / 2, self.PlaceholderTextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local outlineThickness = PIXEL.Scale(1)
    PIXEL.DrawOutlinedRoundedBox(PIXEL.Scale(2), 0, 0, w, h, self.OutlineCol, outlineThickness)

    local col = PIXEL.Colors.Transparent

    if self:IsEditing() then
        col = self.FocusedOutlineCol
    end

    if self.OverrideCol then
        col = self.OverrideCol
    end

    self.InnerOutlineCol = PIXEL.LerpColor(FrameTime() * 8, self.InnerOutlineCol, col)

    PIXEL.DrawOutlinedRoundedBox(PIXEL.Scale(2), outlineThickness, outlineThickness, w - outlineThickness * 2, h - outlineThickness * 2, self.InnerOutlineCol, PIXEL.Scale(1))
end

function PANEL:OnChange() end
function PANEL:OnValueChange(value) end

function PANEL:IsEnabled() return self.TextEntry:IsEnabled() end
function PANEL:SetEnabled(enabled) self.TextEntry:SetEnabled(enabled) end

function PANEL:GetValue() return self.TextEntry:GetValue() end
function PANEL:SetValue(value) self.TextEntry:SetValue(value) end

function PANEL:IsMultiline() return self.TextEntry:IsMultiline() end
function PANEL:SetMultiline(isMultiline) self.TextEntry:SetMultiline(isMultiline) end

function PANEL:IsEditing() return self.TextEntry:IsEditing() end

function PANEL:GetEnterAllowed() return self.TextEntry:GetEnterAllowed() end
function PANEL:SetEnterAllowed(allow) self.TextEntry:SetEnterAllowed(allow) end

function PANEL:GetUpdateOnType() return self.TextEntry:GetUpdateOnType() end
function PANEL:SetUpdateOnType(enabled) self.TextEntry:SetUpdateOnType(enabled) end

function PANEL:GetNumeric() return self.TextEntry:GetNumeric() end
function PANEL:SetNumeric(enabled) self.TextEntry:SetNumeric(enabled) end

function PANEL:GetHistoryEnabled() return self.TextEntry:GetHistoryEnabled() end
function PANEL:SetHistoryEnabled(enabled) self.TextEntry:SetHistoryEnabled(enabled) end

function PANEL:GetTabbingDisabled() return self.TextEntry:GetTabbingDisabled() end
function PANEL:SetTabbingDisabled(disabled) self.TextEntry:SetTabbingDisabled(disabled) end

function PANEL:GetPlaceholderText() return self.TextEntry:GetPlaceholderText() end
function PANEL:SetPlaceholderText(text) self.TextEntry:SetPlaceholderText(text) end

function PANEL:GetInt() return self.TextEntry:GetInt() end
function PANEL:GetFloat() return self.TextEntry:GetFloat() end

function PANEL:IsEditing() return self.TextEntry:IsEditing() end
function PANEL:SetEditable(enabled) self.TextEntry:SetEditable(enabled) end

function PANEL:AllowInput(value) end
function PANEL:GetAutoComplete(txt) end

function PANEL:OnKeyCode(code) end
function PANEL:OnEnter() end

function PANEL:OnGetFocus() end
function PANEL:OnLoseFocus() end

vgui.Register("PIXEL.TextEntry", PANEL, "Panel")
--addons/aocrp_emplacements/lua/autorun/turret_stopfire.lua:
if SERVER then
	AddCSLuaFile()
	util.AddNetworkString("TurretBlockAttackToggle")
	
elseif CLIENT then
	local shouldBlockAttack=false
	net.Receive("TurretBlockAttackToggle",function()
		local blockBit=net.ReadBit()
		if blockBit==1 then
			shouldBlockAttack=true
		elseif blockBit==0 then
			shouldBlockAttack=false
		end
	end)
	
	hook.Add("CreateMove","RedirectTurretAttack",function(cmd)
		local lp = LocalPlayer()
		if shouldBlockAttack and IsValid(lp) and bit.band(cmd:GetButtons(), IN_ATTACK) > 0 then
			cmd:SetButtons(bit.bor(cmd:GetButtons() - IN_ATTACK, IN_BULLRUSH))
		end
	end)

 
end
--lua/autorun/venator_lfs_fix.lua:
--[[
This is a workaround for LFS not being able to be teleported
It disables the ships engines and enables them again shortly after
dont know if this works well on low tick servers
Luna plz fix
]]



-- This has to match the map Name
if not (game.GetMap() == "rp_venator_extensive_v1_4") then return end

local function startEngine(ship)
	if ship:GetEngineActive() or ship:IsDestroyed() or ship:InWater() or ship:GetRotorDestroyed() then return end

	ship:SetEngineActive( true )
	ship:OnEngineStarted()

	ship:InertiaSetNow()
end

function LFSEnter()
	local ship = ACTIVATOR
	if IsValid(ship) and ship.LFS then
		if ship:GetEngineActive() then
			ship:StopEngine()
			timer.Simple(0.1, function() startEngine(ship) end)
		end
	end
end

--lua/autorun/venator_turbolasers.lua:
-- Based on code provided for gm_eperors_tower by P4sca1
-- Adapted by KingPommes for Venator and ISD
-- Oni was here too.


if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end
 
local masterCount = 2
local cannonCount = 8 + masterCount --plus two master seats
local cannonCache = {} --caching the cannons instead of finding them every tick safes much performance
local turretCache = {}
local exitOffset = Vector(-32, 32, 8)

local cannonX = "TLXAxis"
local cannonY = "TLYAxis"
local cannonTrack = "TLTrack"
local cannonSeat = "TLSeat"

local viewOffsetForward = 128
local viewOffsetUp = 0

local function IsValidCannon(cannon)
	local cannon = cannonCache[cannon]

	if cannon and IsValid(cannon.x) and IsValid(cannon.y) and IsValid(cannon.track) and IsValid(cannon.seat) then
		return true
    end

    return false
end

if CLIENT then
    local inCannon = false
	local turret
 
    net.Receive("DSEnterCannon", function(len, pl)
        inCannon = true
		turret = net.ReadEntity()
    end)
 
    net.Receive("DSLeaveCannon", function(len, pl)
        inCannon = false
		turret = nil
    end)
	

	hook.Add("CalcVehicleView", "UpdateCannonView", function(vehicle, ply, view)
		if inCannon then
			local newView = {}
			if (turret:GetModel() == "models/lordtrilobite/starwars/props/imp_chair01_cis.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -1000 + vehicle:GetUp() * -15000
				newView.angles = newView.angles
			elseif (turret:GetModel() == "models/kingpommes/starwars/venator/turbolaser_seat_venator.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -2500 + vehicle:GetUp() * -2600
				newView.angles = newView.angles
			else
				newView.origin = turret:GetPos() + turret:GetForward() * viewOffsetForward + turret:GetUp() * viewOffsetUp
				newView.angles = newView.angles
			end
			return newView
		end
	end)
end
 
if SERVER then
	hook.Add("Think", "UpdateCannonPos", function()
		for i = 1, cannonCount , 1 do
			
				-- create cache if it does not already exist or update it, if it is not valid anymore			
				if !IsValidCannon(i) then
				
					cannonCache[i] = {}
					if (i <= cannonCount - masterCount) then
						cannonCache[i]["x"] = ents.FindByName(cannonX .. i)[1]
						cannonCache[i]["y"] = ents.FindByName(cannonY .. i)[1]
						cannonCache[i]["track"] = ents.FindByName(cannonTrack .. i)[1]
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
					else
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
						cannonCache[i]["x"] = cannonCache[i]["seat"]
						cannonCache[i]["y"] = cannonCache[i]["seat"]
						cannonCache[i]["track"] = cannonCache[i]["seat"]
						continue
					end
					
					if IsValid(cannonCache[i]["seat"]) then
						cannonCache[i]["seat"]:SetVehicleClass("phx_seat2")
					end
				
					-- if the cannon is still not valid after searching it, then skip it, because it does not exist
					if !IsValidCannon(i) then
						continue
					end
				end
				cannonCache[i]["x"]:SetAngles(Angle(cannonCache[i]["x"]:GetAngles().pitch, cannonCache[i]["track"]:GetAngles().yaw, cannonCache[i]["x"]:GetAngles().roll))
				cannonCache[i]["y"]:SetAngles(Angle(cannonCache[i]["track"]:GetAngles().pitch, cannonCache[i]["y"]:GetAngles().yaw, cannonCache[i]["y"]:GetAngles().roll))
			
		end
	end)

    util.AddNetworkString("DSEnterCannon")
 
    hook.Add("PlayerEnteredVehicle", "EnterCannon", function(ply, veh, role)
        if string.StartWith(veh:GetName(), cannonSeat) then
            net.Start("DSEnterCannon")
			local turret
			for i = 1, cannonCount, 1 do
				if (cannonCache[i]["seat"] == veh) then
					turret = cannonCache[i]["y"]
					break
				end
			end
			net.WriteEntity(turret)
            net.Send(ply)
			ply:CrosshairEnable()
		end
		
		if (!IsValid(veh.applied)) then
			if (veh:GetKeyValues()["hammerid"] ~= 0) then
				if (veh:GetModel() == "models/kingpommes/starwars/misc/seats/turbolaser_seat.mdl") then
					veh:SetVehicleClass("phx_seat2")
					veh.applied = true
				end
			end
		end
    end)
 
    util.AddNetworkString("DSLeaveCannon")
 
    hook.Add("PlayerLeaveVehicle", "LeaveCannon", function(ply, veh)
		if (string.StartWith(veh:GetName(), cannonSeat)) then
			net.Start("DSLeaveCannon")
			net.Send(ply)
	
			ply:SetPos(veh:GetPos() + veh:GetForward() * exitOffset.x + veh:GetRight() * exitOffset.y + veh:GetUp() * exitOffset.z)
			return
		end
		if (veh:GetKeyValues()["hammerid"] ~= 0) then
			ply:SetPos(veh:GetPos() + veh:GetRight() * -32)
		end
    end)
end
--addons/vyhub-gmod/lua/vyhub/config/sh_config.lua:
-- Language used. Currently only languages in the "lang" directory are supported.
VyHub.Config.lang = "de"

-- Enable chat tags, not working together with DarkRP
VyHub.Config.chat_tags = false

-- Date format to use (for example in ban message)
-- See https://tieske.github.io/date/#dateObject.fmt
VyHub.Config.date_format = "%Y-%m-%d %H:%M:%S %z"
-- Time offset from UTC (+00:00)
-- Uses the timezone of the GMOD server when set to nil
-- Example: 2 for CEST, -5 for EST
VyHub.Config.time_offset = nil

-- Debug mode. Enable to see all API requests and responses
VyHub.Config.debug = false
--lua/wos/anim_extension/core/sh_holdtypes.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Register:
		The core files needed to make your own hold types
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}
wOS.AnimExtension.TranslateHoldType = wOS.AnimExtension.TranslateHoldType or {}

wOS.AnimExtension.ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

function wOS.AnimExtension:RegisterHoldtype( data )

	self.TranslateHoldType[ data.HoldType ] = data
    self.HoldTypeMeta:CreateMetaType( self.TranslateHoldType[ data.HoldType ] )
	
	if data.BaseHoldType then
		if prone then
			if prone.animations then
				if prone.animations.WeaponAnims then
					prone.animations.WeaponAnims.moving[ data.HoldType ] = prone.animations.WeaponAnims.moving[ data.BaseHoldType ]
					prone.animations.WeaponAnims.idle[ data.HoldType ] = prone.animations.WeaponAnims.idle[ data.BaseHoldType ]
				end
			end
		end
	end

	print( "[wOS] Registered new Hold Type: " .. data.Name )
	
end

local meta = FindMetaTable( "Player" )
local ENTITY = FindMetaTable( "Entity" )

local AttackTable = {
[ ACT_MP_ATTACK_STAND_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_STAND_SECONDARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_SECONDARYFIRE  ] = true,
}

local _TranslateWeaponActivity = meta.TranslateWeaponActivity
function meta:TranslateWeaponActivity( act )

	if AttackTable[ act ] then
		local wep = self:GetActiveWeapon()
		if IsValid( wep ) then  
			local holdtype = wep:GetHoldType()
			if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
				local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
				if ATTACK_DATA then
					local anim = self:LookupSequence( ATTACK_DATA.Sequence )
					self:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
					self:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )
				end
			end
		end
	end
	
	return _TranslateWeaponActivity( self, act )

end


-- local _DoAnimationEvent = meta.DoAnimationEvent
-- function meta:DoAnimationEvent( ply, event, data )

-- 	local act = _DoAnimationEvent( self, ply, event, data )
-- 	print( act )
-- 	local wep = self:GetActiveWeapon()
-- 	if IsValid( wep ) then  
-- 		local holdtype = wep:GetHoldType()
-- 		if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
-- 			local result = wOS.AnimExtension.TranslateHoldType[ holdtype ][ act ]
-- 			if result then
-- 				if istable( result ) then
-- 					result = table.Random( result )
-- 				end
-- 				if isstring( result ) then
-- 					local anim = ply:LookupSequence( result )	
-- 					ply.ActOverrider = act
-- 					ply.SequenceTime = CurTime() + ply:SequenceDuration( anim )
-- 				end
-- 			end
-- 		end
-- 	end
	
-- 	return act
-- end

hook.Add( "DoAnimationEvent", "wOS.AnimExtension.CustomTriggers", function( ply, event, data ) 

	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) then return end
	local holdtype = wep:GetHoldType()
	if !wOS.AnimExtension.TranslateHoldType[ holdtype ] then return end

	local act = 9999
	local crouch = ply:Crouching()
	if event == PLAYERANIMEVENT_RELOAD then
		act = ( crouch and ACT_MP_RELOAD_CROUCH ) or ACT_MP_RELOAD_STAND
	elseif event == PLAYERANIMEVENT_ATTACK_SECONDARY then
		act = ( crouch and ACT_MP_ATTACK_CROUCH_SECONDARYFIRE ) or ACT_MP_ATTACK_STAND_SECONDARYFIRE
	end

	local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
	if !ATTACK_DATA then return end

	local anim = ply:LookupSequence( ATTACK_DATA.Sequence )
	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
	ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )

	return ACT_INVALID
end )

hook.Add( "Initialize", "wOS.AnimExtension.CustomSequenceHoldtypes", function()

	local _CalcMainActivity = GAMEMODE.CalcMainActivity
	function GAMEMODE:CalcMainActivity( ply, vel )
		
		local act, seq = _CalcMainActivity( self, ply, vel )
		local pr = false
		if prone then
			if ply.IsProne then
				pr = ply:IsProne()
			end
		end

		if not pr then
			local wep = ply:GetActiveWeapon()
			if IsValid( wep ) then  
				local holdtype = wep:GetHoldType()
				if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
					local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
					if act == ACT_MP_RUN and ply:KeyDown( IN_SPEED ) then
						ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( ACT_MP_SPRINT ) or ATTACK_DATA
					end
					if ATTACK_DATA then
						seq = ply:LookupSequence( ATTACK_DATA.Sequence )
					end
				end
			end

			
			if act != ply.LastAct then
				ply:SetCycle( 0 )
			end
		end
		
		ply.LastAct = act
		
		return act, seq
		
	end
	
end )

if SERVER then return end

concommand.Add( "wos_base_help", function( ply, cmd, args )
	MsgC( Color( 255, 255, 255 ), "------------------ ", Color( 133, 173, 219 ), "wiltOS HELP PRINT", Color( 255, 255, 255 ), " ----------------------\n" )
	MsgC( Color( 255, 255, 255 ), "Addon Path Check: " )
	LocalPlayer():ConCommand( "whereis models/m_anm.mdl" )
	timer.Simple( 0.01, function()
	
		MsgC( color_white, "\nPlease ensure the addon path above points to ", Color( 0, 255, 0 ), "'[wOS] Animation Extension - Base'\n")
		MsgC( color_white, "If it does not, unsubscribe to the addon it does point to and get the Animation Base\n")
		print("\n")

		local seq = LocalPlayer():LookupSequence( "_base_wiltos_enabled_" )
		local resp = ( seq >= 0 and Color( 0, 255, 0 ) ) or Color( 255, 0, 0 )
		MsgC( color_white, "Sequence Check: ", resp, "\t", seq, "\n" )
		MsgC( color_white, "If the above sequence check is ", Color( 255, 0, 0 ), -1, color_white, " and the addon above points to the correct location,\nensure your model is a ", Color( 0, 255, 0 ), "PLAYER MODEL", color_white, " and not an ", Color( 255, 0, 0 ), "NPC MODEL\n" )
		MsgC( color_white, "Run this commmand again as a default GMod player model. If it still prints ", Color( 255, 0, 0 ), -1, color_white, " your Animation Base may be outdated\n" )

		print( "\n" )
		MsgC( color_white, "You can find the link here: https://steamcommunity.com/sharedfiles/filedetails/?id=757604550\n")
		MsgC( Color( 255, 255, 255 ), "-----------------------------------------------------------\n" )
	end )
end )
--lua/wos/anim_extension/holdtypes/a_combo1.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo1"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo1" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo1" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/leap.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "leap"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "leap" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "leap" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/slashup.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashup"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashup" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashup" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/slashuph.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashuph"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashuph" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashuph" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_netrate.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

/*
	Measures against net spamming
*/

if !SH_ANTICRASH.SETTINGS.EXPLOITS.NETRATELIMITER then return end

local enableNetLog = false
local netMsgNetCount = {}

timer.Create("z_anticrash_NetrateCleanTimer", 1, 0, function()
	table.Empty(netMsgNetCount)
end)

if CLIENT then

	local __oldStart = net.Start
	-- __oldStart = __oldStart or net.Start
	
	-- Client side netrate limiter	
	function net.Start(messageName, unreliable)
		
		if enableNetLog then
			print("Starting net msg: "..messageName)
		end
		
		netMsgNetCount[messageName] = (netMsgNetCount[messageName] or 0) + 1
		
		-- Discard message
		if netMsgNetCount[messageName] > 5 then return end
		
		__oldStart(messageName, unreliable)

	end

	/*
	timer.Create("Spammer",0.001,0,function()
		net.Start("SpamMe")
		net.SendToServer()
	end)
	*/

end

if SERVER then
	
	local function Incoming(len, client, nwName)
		
		if ( !nwName ) then return end
		
		local func = net.Receivers[ nwName:lower() ]
		if ( !func ) then return end

		--
		-- len includes the 16 bit int which told us the message name
		--
		len = len - 16
		
		func( len, client )

	end

	-- Sever side netrate limiter
	function net.Incoming( len, client )

		local nwName = util.NetworkIDToString(net.ReadHeader())

		if enableNetLog then
			print("net.Incoming",nwName, client, len)
		end
	
		netMsgNetCount[client] = netMsgNetCount[client] or {}
		netMsgNetCount[client][nwName] = (netMsgNetCount[client][nwName] or 0) + 1
		
		-- Discard message
		if netMsgNetCount[client][nwName] > 5 then return end
		
		Incoming(len, client, nwName)
		
	end
	
	/*
	util.AddNetworkString("SpamMe")
	local function SpamMe()
		print("Spammed!")
	end
	net.Receive("SpamMe", SpamMe)
	*/

end
--addons/tools_advdupe/lua/advdupe2/cl_file.lua:
local invalidCharacters = { "\"", ":"}
function AdvDupe2.SanitizeFilename(filename)
	for i=1, #invalidCharacters do
		filename = string.gsub(filename, invalidCharacters[i], "_")
	end
	filename = string.gsub(filename, "%s+", " ")

	return filename
end

function AdvDupe2.ReceiveFile(data, autoSave)
	AdvDupe2.RemoveProgressBar()
	if not data then
		AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
		return
	end
	local path
	if autoSave then
		if(LocalPlayer():GetInfo("advdupe2_auto_save_overwrite")~="0")then
			path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath, true)
		else
			path = AdvDupe2.GetFilename(AdvDupe2.AutoSavePath)
		end
	else
		path = AdvDupe2.GetFilename(AdvDupe2.SavePath)
	end

	path = AdvDupe2.SanitizeFilename(path)
	local dupefile = file.Open(path, "wb", "DATA")
	if not dupefile then
		AdvDupe2.Notify("File was not saved!",NOTIFY_ERROR,5)
		return
	end
	dupefile:Write(data)
	dupefile:Close()

	local errored = false
	if(LocalPlayer():GetInfo("advdupe2_debug_openfile")=="1")then
		if(not file.Exists(path, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end

		local readFile = file.Open(path, "rb", "DATA")
		if not readFile then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local success,dupe,info,moreinfo = AdvDupe2.Decode(readData)
		if(success)then
			AdvDupe2.Notify("DEBUG CHECK: File successfully opens. No EOF errors.")
		else
			AdvDupe2.Notify("DEBUG CHECK: " .. dupe, NOTIFY_ERROR)
			errored = true
		end
	end

	local filename = string.StripExtension(string.GetFileFromFilename( path ))
	if autoSave then
		if(IsValid(AdvDupe2.FileBrowser.AutoSaveNode))then
			local add = true
			for i=1, #AdvDupe2.FileBrowser.AutoSaveNode.Files do
				if(filename==AdvDupe2.FileBrowser.AutoSaveNode.Files[i].Label:GetText())then
					add=false
					break
				end
			end
			if(add)then
				AdvDupe2.FileBrowser.AutoSaveNode:AddFile(filename)
				AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.AutoSaveNode)
			end
		end
	else
		AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode:AddFile(filename)
		AdvDupe2.FileBrowser.Browser.pnlCanvas:Sort(AdvDupe2.FileBrowser.Browser.pnlCanvas.ActionNode)
	end
	if(!errored)then
		AdvDupe2.Notify("File successfully saved!",NOTIFY_GENERIC, 5)
	end
end

net.Receive("AdvDupe2_ReceiveFile", function()
	local autoSave = net.ReadUInt(8) == 1
	net.ReadStream(nil, function(data)
		AdvDupe2.ReceiveFile(data, autoSave)
	end)
end)

AdvDupe2.Uploading = false
function AdvDupe2.SendFile(name, data)
	net.Start("AdvDupe2_ReceiveFile")
	net.WriteString(name)
	AdvDupe2.Uploading = net.WriteStream(data, function()
		AdvDupe2.Uploading = nil
		AdvDupe2.File = nil
		AdvDupe2.RemoveProgressBar()
	end)
	net.SendToServer()
end

function AdvDupe2.UploadFile(ReadPath, ReadArea)
	if AdvDupe2.Uploading then AdvDupe2.Notify("Already opening file, please wait.", NOTIFY_ERROR) return end
	if(ReadArea==0)then
		ReadPath = AdvDupe2.DataFolder.."/"..ReadPath..".txt"
	elseif(ReadArea==1)then
		ReadPath = AdvDupe2.DataFolder.."/-Public-/"..ReadPath..".txt"
	else
		ReadPath = "adv_duplicator/"..ReadPath..".txt"
	end

	if(not file.Exists(ReadPath, "DATA"))then AdvDupe2.Notify("File does not exist", NOTIFY_ERROR) return end

	local read = file.Read(ReadPath)
	if not read then AdvDupe2.Notify("File could not be read", NOTIFY_ERROR) return end
	local name = string.Explode("/", ReadPath)
	name = name[#name]
	name = string.sub(name, 1, #name-4)

	local success, dupe, info, moreinfo = AdvDupe2.Decode(read)
	if(success)then
		AdvDupe2.SendFile(name, read)

		AdvDupe2.LoadGhosts(dupe, info, moreinfo, name)
	else
		AdvDupe2.Notify("File could not be decoded. ("..dupe..") Upload Canceled.", NOTIFY_ERROR)
	end
end

--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_mod_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Modules = wOS.PES.Modules or {}
wOS.PES.Modules.Data = wOS.PES.Modules.Data or {}

function wOS.PES.Modules:Autoloader()
	local _, folders = file.Find( "wos/pes/addons/*", "LUA")

    for _, folder in pairs( folders, true ) do

        local n_folder = "wos/pes/addons/" .. folder
        for __, source in pairs( file.Find( n_folder .. "/*", "LUA" ), true ) do   

            local realm = string.lower(string.Left(source, 3) )
            local ext = string.lower(string.Right(source, 3) )
            local lua =  n_folder .. "/" .. source

            if SERVER and realm == "sv_" then
                if ext == "wos" then
                    wOS.PES:ServerInclude( lua )
                else
                    include( lua )
                end
            elseif realm == "cl_" then
                if SERVER then
                    AddCSLuaFile( lua )
                else
                    include( lua )
                end
            elseif realm == "sh_" then
                if SERVER then
                    AddCSLuaFile( lua )
                end
                include( lua )
            end
            
        end

    end
end

function wOS.PES.Modules:RegisterAddon( name, varData )
    if not name then return end
    if not varData then return end
    self.Data[name] = varData
end

function wOS.PES.Modules:Get( mod )
    if not mod then return {} end
    if not wOS.PES.Modules.Data[mod] then return {} end

    return wOS.PES.Modules.Data[mod]
end

wOS.PES.Modules:Autoloader()

-- local function KevCISNPCFix( ent, entdata )
--     if not ent then return end
--     if not IsValid( ent.originalReference ) then return end
--     return ent.originalReference
-- end

-- hook.Add( "wOS.PES.PrePartialReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )
-- hook.Add( "wOS.PES.PreReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )

hook.Add( "wOS.PES.PostSpawnEntity", "wOS.PES.KevCISNPCDupeFixes", function( ent )
    if not ent then return end
    if not IsValid( ent.npc ) then return end
    return ent.npc
end )

if SERVER then
    hook.Add( "PreRegisterSENT", "wOS.PES.CISNPCSARETHEWORST", function( ent, class )
        if class != "seperatist_alliance_npc_base" and class != "seperatist_alliance_special_npc_base" then return end

        local init = ent.Initialize
        ent.Initialize = function( self )
            init( self )
            if not IsValid( self.npc ) then return end

            self.npc.OnEntityCopyTableFinish = function( npc, dat )
                if npc.WOS_StopCopy then return end
                dat.Class = npc.originalReference:GetClass()
                npc.WOS_StopCopy = true
                    dat.NPCSettings = duplicator.CopyEntTable( npc )
                    dat.NPCSettings.Angle = nil
                    dat.NPCSettings.Pos = nil
                npc.WOS_StopCopy = false
                dat.CurrentWeapon = npc:GetInternalVariable( "additionalequipment" )
            end
        end

        ent.PostEntityPaste = function( self, ply, ett, enttbl )
            if not IsValid( self.npc ) then return end
            
            if self.NPCSettings then
                duplicator.DoGeneric( self.npc, self.NPCSettings )
            end
            
            if not self.CurrentWeapon then return end
            self.npc:SetKeyValue( "additionalequipment", self.CurrentWeapon )
            self.npc:Give( self.CurrentWeapon )
        end
    end )
end
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/camera/cl_core.lua:

local pesCameraPathInfo = {}

local removeCamera = function( id )
	hook.Remove("CalcView", "!!wOS.PES.CameraPath" .. id)
	hook.Remove("Think", "!!wOS.PES.CameraPath" .. id)
	pesCameraPathInfo[id] = nil

	LocalPlayer().AOCRP_Kamerafahrt = false
end

local startCamera = function(id, path, speed)
	pesCameraPathInfo[id] = {}
	pesCameraPathInfo[id].path = path
	pesCameraPathInfo[id].speed = speed
	pesCameraPathInfo[id].current = 1

	hook.Add("CalcView", "!!wOS.PES.CameraPath" .. id, function(ply, pos, ang, fov, znear, zfar)
	
		LocalPlayer().AOCRP_Kamerafahrt = true

		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera()
			return
		end

		local currentVal = math.floor(pesCameraPathInfo[id].current)

		local current = pesCameraPathInfo[id].path[currentVal]
		local next = pesCameraPathInfo[id].path[currentVal + 1]

		if not current or not next then return end

		local lerpVal = pesCameraPathInfo[id].current - currentVal
		local pos = LerpVector(lerpVal, current.Vector, next.Vector)
		local ang = LerpAngle(lerpVal, current.Angle, next.Angle)

		return {
			origin = pos,
			angles = ang,
			fov = fov,
			znear = znear,
			zfar = zfar,
			drawviewer = true
		}
	end)

	hook.Add("Think", "!!wOS.PES.CameraPath" .. id, function()
		pesCameraPathInfo[id].current = pesCameraPathInfo[id].current + pesCameraPathInfo[id].speed * FrameTime()

		if pesCameraPathInfo[id].current > #pesCameraPathInfo[id].path then
			removeCamera( id )
			return
		end
	end)

end
net.Receive("wOS.PES.StartCamera", function(len)
	local id = net.ReadUInt( 32 )
	local path = net.ReadTable()
	local speed = net.ReadFloat()
	
	startCamera(id, path, speed)
end)

net.Receive("wOS.PES.EndCamera", function(len)
	local id = net.ReadUInt( 32 )
	removeCamera( id )
end)
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/color.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Color"
VAR.IsValid = function(varTable, value)
    if not IsColor(value) and not istable( value ) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local colorMixer = vgui.Create("DColorMixer")

    if not IsColor( value ) and istable( value ) then
        value = Color( value.r or value.x, value.g or value.y, value.b or value.z, value.a or 255 )
    end

    if IsColor(value) then
        colorMixer:SetColor(value)
    else
        colorMixer:SetColor(varTable.Default)
    end

    return colorMixer
end

VAR.GetValue = function(colorMixer)
    return colorMixer:GetColor()
end


return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/list_uneditable.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Read-Only List"

VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Variable View")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    return listView
end

VAR.GetValue = function(listView)
    local values = {}
    for k, line in ipairs( listView:GetLines() ) do
        table.insert( values, line:GetValue( 1 ) )
    end
    return values
end

return VAR
--addons/billy_gas/lua/vgui/bvgui_v2.lua:
bVGUI = {}

bVGUI.WORKSHOP_ID = "1261820532"

bVGUI.FONT_RUBIK     = 1
bVGUI.FONT_CONSOLAS  = 2
bVGUI.FONT_CIRCULAR  = 3
local fonts = {
	[bVGUI.FONT_RUBIK] = {
		NAME = "Rubik",
		STYLES = {
			REGULAR = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			UNDERLINE = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			ITALIC = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[12] = true,
				[14] = true,
				[16] = true,
			}
		}
	},
	[bVGUI.FONT_CONSOLAS] = {
		NAME = "Consolas",
		STYLES = {
			REGULAR = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[14] = true,
				[16] = true,
			},
		}
	},
	[bVGUI.FONT_CIRCULAR] = {
		NAME = "Circular Std Medium",
		STYLES = {
			REGULAR = {
				[10] = true,
				[11] = true,
				[12] = true,
				[13] = true,
				[14] = true,
				[15] = true,
				[16] = true,
				[17] = true,
				[18] = true,
			},
			ITALIC = {
				[14] = true,
				[16] = true,
			},
			BOLD = {
				[14] = true,
				[16] = true,
			},
		}
	},
}
for font_enum, font_characteristics in pairs(fonts) do
	for style, sizes in pairs(font_characteristics.STYLES) do
		for size in pairs(sizes) do
			local font_name = "bVGUI." .. font_characteristics.NAME .. size .. "_" .. style
			local font_data = {}
			font_data.size = size
			font_data.font = font_characteristics.NAME
			if (style == "ITALIC") then
				font_data.italic = true
			end
			if (style == "BOLD") then
				font_data.weight = 700
			end
			if (style == "UNDERLINE") then
				font_data.underline = true
			end

			surface.CreateFont(font_name, font_data)
			fonts[font_enum].STYLES[style][size] = font_name
		end
	end
end
bVGUI.FONT = function(font_enum, style, size)
	return fonts[font_enum].STYLES[style][size]
end

bVGUI.COLOR_WHITE       = Color(255,255,255) -- White
bVGUI.COLOR_BLACK       = Color(0,0,0)       -- Black
bVGUI.COLOR_LIGHT_GREY  = Color(236,236,236) -- Light grey
bVGUI.COLOR_DARK_GREY   = Color(26,26,26)    -- Dark grey
bVGUI.COLOR_DARKER_GREY = Color(19,19,19)    -- Darker grey
bVGUI.COLOR_SLATE       = Color(30,30,30)    -- Slate
bVGUI.COLOR_RED         = Color(255,0,0)     -- Red
bVGUI.COLOR_GMOD_BLUE   = Color(0,152,234)   -- GMod Blue
bVGUI.COLOR_PURPLE      = Color(144,0,255)   -- Purple

bVGUI.CEIL = function(n)
	if (n % 1 > .5) then
		return math.ceil(n)
	else
		return n
	end
end
bVGUI.FLOOR = function(n)
	if (n % 1 < .5) then
		return math.floor(n)
	else
		return n
	end
end
bVGUI.LerpColor = function(from, to, time)
	local interpolation_data = {
		current_color = table.Copy(from),
		from = table.Copy(from),
		to = table.Copy(to),

		ceil_r = to.r > from.r,
		ceil_g = to.g > from.g,
		ceil_b = to.b > from.b,

		curtime = SysTime()
	}
	function interpolation_data:DoLerp()
		if (
			self.current_color.r == self.to.r and
			self.current_color.g == self.to.g and
			self.current_color.b == self.to.b
		) then
			return
		end
		local time_fraction = math.min(math.TimeFraction(self.curtime, self.curtime + time, SysTime()), 1)
		time_fraction = time_fraction ^ (1.0 - ((time_fraction - 0.5)))
		self.current_color.r = Lerp(time_fraction, self.from.r, self.to.r)
		self.current_color.g = Lerp(time_fraction, self.from.g, self.to.g)
		self.current_color.b = Lerp(time_fraction, self.from.b, self.to.b)
		if (self.ceil_r) then
			self.current_color.r = bVGUI.CEIL(self.current_color.r)
		else
			self.current_color.r = bVGUI.FLOOR(self.current_color.r)
		end
		if (self.ceil_g) then
			self.current_color.g = bVGUI.CEIL(self.current_color.g)
		else
			self.current_color.g = bVGUI.FLOOR(self.current_color.g)
		end
		if (self.ceil_b) then
			self.current_color.b = bVGUI.CEIL(self.current_color.b)
		else
			self.current_color.b = bVGUI.FLOOR(self.current_color.b)
		end
	end
	function interpolation_data:GetColor()
		return self.current_color
	end
	function interpolation_data:SetColor(col)
		self.current_color = table.Copy(col)
		self.from = table.Copy(col)
		self.to = table.Copy(col)
		self.curtime = SysTime()
	end
	function interpolation_data:SetTo(to)
		self.curtime = SysTime()
		
		self.from = table.Copy(self.current_color)
		self.to = table.Copy(to)

		self.ceil_r = self.to.r > self.from.r
		self.ceil_g = self.to.g > self.from.g
		self.ceil_b = self.to.b > self.from.b
	end
	return interpolation_data
end
bVGUI.Lerp = function(from, to, time)
	local interpolation_data = {
		current_val = from,
		from = from,
		to = to,

		ceil = to > from,

		curtime = SysTime(),
	}
	function interpolation_data:DoLerp()
		if (self.current_val == self.to) then return end
		local time_fraction = math.min(math.TimeFraction(self.curtime, self.curtime + time, SysTime()), 1)
		time_fraction = time_fraction ^ (1.0 - ((time_fraction - 0.5)))
		self.current_val = Lerp(time_fraction, self.from, self.to)
		if (self.ceil) then
			self.current_val = bVGUI.CEIL(self.current_val)
		else
			self.current_val = bVGUI.FLOOR(self.current_val)
		end
	end
	function interpolation_data:GetValue()
		return self.current_val
	end
	function interpolation_data:SetValue(val)
		self.current_val = val
		self.to = val
		self.from = val
		self.curtime = SysTime()
	end
	function interpolation_data:SetTo(to)
		self.curtime = SysTime()
		
		self.from = self.current_val
		self.to = to

		self.ceil = self.to > self.from
	end
	return interpolation_data
end
bVGUI.DarkenColor = function(color, fraction)
	return Color(math.min(color.r - color.r * fraction, 255), math.min(color.g - color.g * fraction, 255), math.min(color.b - color.b * fraction, 255), color.a)
end
bVGUI.LightenColor = function(color, fraction)
	return Color(math.min(color.r + color.r * fraction, 255), math.min(color.g + color.g * fraction, 255), math.min(color.b + color.b * fraction, 255), color.a)
end
bVGUI.ColorShouldUseBlackText = function(color)
	return (color.r * 0.299 + color.g * 0.587 + color.b * 0.114) > 186
end
bVGUI.TextColorContrast = function(bg_color)
	if (bVGUI.ColorShouldUseBlackText(bg_color)) then
		return bVGUI.COLOR_BLACK
	else
		return bVGUI.COLOR_WHITE
	end
end
bVGUI.EllipsesText = function(text, font, width, controlchar)
	surface.SetFont(font)
	local TextWidth = surface.GetTextSize(text)
	local WWidth = surface.GetTextSize(controlchar or "W")

	if TextWidth <= width then
		return text		
	end

	for i=1, #text do
		if select(1, surface.GetTextSize(text:sub(1, i))) >= width then 
			return text:sub(1, i - 3) .. "..."
		end
	end

	return "..." -- kek
end

bVGUI.ICON_CLOSE               = Material("materials/vgui/bvgui/icon_close.png")
bVGUI.ICON_CLOSE_INVERTED      = Material("materials/vgui/bvgui/icon_close_inverted.png")
bVGUI.ICON_FULLSCREEN          = Material("materials/vgui/bvgui/icon_fullscreen.png")
bVGUI.ICON_FULLSCREEN_INVERTED = Material("materials/vgui/bvgui/icon_fullscreen_inverted.png")
bVGUI.ICON_MENU                = Material("materials/vgui/bvgui/icon_menu.png")
bVGUI.ICON_MENU_INVERTED       = Material("materials/vgui/bvgui/icon_menu_inverted.png")
bVGUI.ICON_PIN                 = Material("materials/vgui/bvgui/icon_pin.png")
bVGUI.ICON_PIN_INVERTED        = Material("materials/vgui/bvgui/icon_pin_inverted.png")
bVGUI.MATERIAL_LOADING_ICON    = Material("materials/vgui/bvgui/loading.png", "smooth")

bVGUI.MATERIAL_GRADIENT             = Material("materials/vgui/bvgui/darken_gradient.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LARGE       = Material("materials/vgui/bvgui/darken_gradient_large.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LIGHT       = Material("materials/vgui/bvgui/darken_gradient_light.png", "smooth")
bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE = Material("materials/vgui/bvgui/darken_gradient_light_large.png", "smooth")
bVGUI.MATERIAL_SHADOW               = Material("materials/vgui/bvgui/shadow.png", "smooth")
bVGUI.MATERIAL_SHADOW_FLIP          = Material("materials/vgui/bvgui/shadow_flip.png", "smooth")

bVGUI.DEBUG_PAINTOVER = function(self,w,h)
	surface.SetDrawColor(255,0,0,50)
	surface.DrawRect(0,0,w,h)
end

bVGUI_DermaMenuOption_GreenToRed = function(i, max, option)
	bVGUI_DermaMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end
bVGUI_DermaMenuOption_ColorIcon = function(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
bVGUI_DermaMenuOption_PlayerTooltip = function(option, options)
	if (IsValid(options.ply)) then
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(options.ply:Team()))
	elseif (options.account_id) then
		local ply = player.GetByAccountID(options.account_id)
		if (IsValid(ply)) then
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply:Team()))
		else
			option:SetIcon("icon16/server_delete.png")
		end
	elseif (options.steamid64) then
		local ply = player.GetBySteamID64(options.steamid64)
		if (IsValid(ply)) then
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply:Team()))
		else
			option:SetIcon("icon16/server_delete.png")
		end
	end
	bVGUI.PlayerTooltip.Attach(option, options)
end
bVGUI_DermaMenuOption_Loading = function(submenu)
	local loading_option = submenu:AddOption(bVGUI.L("loading_ellipsis"))
	loading_option:SetIcon("icon16/transmit_blue.png")
	function loading_option:OnMouseReleased(m)
		DButton.OnMouseReleased(self, m)
		if (m ~= MOUSE_LEFT or not self.m_MenuClicking) then return end
		self.m_MenuClicking = false
	end
	return loading_option
end

bVGUI_Message = function(title, text, btn_text)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:SetSize(400,150)
	bVGUI.ACTIVE_POPUP:Center()
	bVGUI.ACTIVE_POPUP:MakePopup()

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
	bVGUI.ACTIVE_POPUP.Text:Dock(FILL)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,10)
	bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(5)
	bVGUI.ACTIVE_POPUP.Text:SetText(text)

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	bVGUI.ACTIVE_POPUP.ButtonContainer.Button = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:Dock(FILL)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetText(btn_text or bVGUI.L("done"))
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetSound("btn_heavy")
	function bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
		if (callback) then
			callback(bVGUI.ACTIVE_POPUP.TextEntry:GetValue())
		end
		bVGUI.ACTIVE_POPUP:Close()
	end
end

bVGUI.StringQuery = function(title, text, placeholder, callback, verification, btn_text)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:MakePopup()
	bVGUI.ACTIVE_POPUP:SetWide(300)

	if (text) then
		bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
		bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
		bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
		bVGUI.ACTIVE_POPUP.Text:Dock(TOP)
		bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,0)
		bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(8)
		bVGUI.ACTIVE_POPUP.Text:SetText(text)
		bVGUI.ACTIVE_POPUP.Text:SetTall(0)
		bVGUI.ACTIVE_POPUP.Text:SetWrap(true)
		bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(true)
	else
		bVGUI.ACTIVE_POPUP:SetTall(95)
		bVGUI.ACTIVE_POPUP:Center()
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	bVGUI.ACTIVE_POPUP.ButtonContainer.Button = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:Dock(FILL)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetText(btn_text or bVGUI.L("done"))
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetDisabled(true)
	bVGUI.ACTIVE_POPUP.ButtonContainer.Button:SetSound("btn_heavy")
	function bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
		local val = bVGUI.ACTIVE_POPUP.TextEntry:GetValue()
		bVGUI.ACTIVE_POPUP:Close()
		if (callback) then
			callback(val)
		end
	end

	bVGUI.ACTIVE_POPUP.TextEntry = vgui.Create("bVGUI.TextEntry", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.TextEntry:Dock(TOP)
	bVGUI.ACTIVE_POPUP.TextEntry:SetTall(25)
	bVGUI.ACTIVE_POPUP.TextEntry:SetPlaceholderText(placeholder or bVGUI.L("enter_text_ellipsis"))
	bVGUI.ACTIVE_POPUP.TextEntry:DockMargin(10,10,10,10)
	bVGUI.ACTIVE_POPUP.TextEntry:SetUpdateOnType(true)
	bVGUI.ACTIVE_POPUP.TextEntry:RequestFocus()
	function bVGUI.ACTIVE_POPUP.TextEntry:OnValueChange(text)
		if (verification) then
			self:GetParent().ButtonContainer.Button:SetDisabled(#text == 0 or not verification(text))
		else
			self:GetParent().ButtonContainer.Button:SetDisabled(#text == 0)
		end
	end
	function bVGUI.ACTIVE_POPUP.TextEntry:OnEnter(text)
		bVGUI.ACTIVE_POPUP.ButtonContainer.Button:DoClick()
	end

	if (text) then
		bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer.Button:GetTall() + bVGUI.ACTIVE_POPUP.TextEntry:GetTall() + 60)
		bVGUI.ACTIVE_POPUP:Center()
		function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
			if (bVGUI.ACTIVE_POPUP.Text:GetTall() > 0 and bVGUI.ACTIVE_POPUP.Text:GetTall() ~= self.StoreY) then
				self.StoreY = bVGUI.ACTIVE_POPUP.Text:GetTall()
				bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer.Button:GetTall() + bVGUI.ACTIVE_POPUP.TextEntry:GetTall() + 60)
				bVGUI.ACTIVE_POPUP:Center()
			end
		end
	end

	return bVGUI.ACTIVE_POPUP
end

bVGUI.Query = function(...)
	local vararg = {...}
	local text, title = vararg[1], vararg[2]

	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(title)
	bVGUI.ACTIVE_POPUP:MakePopup()
	bVGUI.ACTIVE_POPUP:SetWide(300)

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("DLabel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	bVGUI.ACTIVE_POPUP.Text:SetTextColor(bVGUI_COLOR_WHITE)
	bVGUI.ACTIVE_POPUP.Text:Dock(TOP)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(10,10,10,0)
	bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(8)
	bVGUI.ACTIVE_POPUP.Text:SetText(text)
	bVGUI.ACTIVE_POPUP.Text:SetTall(0)
	bVGUI.ACTIVE_POPUP.Text:SetWrap(true)
	bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(true)

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)
	bVGUI.ACTIVE_POPUP.ButtonContainer:DockMargin(0,0,0,15)
	bVGUI.ACTIVE_POPUP.ButtonContainer:SetTall(25)

	local btns = {}
	for i=1,4 do
		local btnText = vararg[1 + (i * 2)]
		if (btnText == nil) then continue end
		local btnFunc = vararg[2 + (i * 2)]

		local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
		table.insert(btns, btn)
		btn:SetSize(90,25)
		if (i == 1) then
			btn:SetColor(bVGUI.BUTTON_COLOR_GREEN)
		elseif (i == 2) then
			btn:SetColor(bVGUI.BUTTON_COLOR_RED)
		elseif (i == 3) then
			btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
		elseif (i == 4) then
			btn:SetColor(bVGUI.BUTTON_COLOR_PURPLE)
		end
		btn:SetText(btnText)
		function btn:DoClick()
			bVGUI.ACTIVE_POPUP:Close()
			if (btnFunc) then btnFunc() end
		end
	end

	function bVGUI.ACTIVE_POPUP.ButtonContainer:PerformLayout(_w)
		local w = (_w - ((90 + 10) * #btns)) / 2
		local a = 0
		for _,btn in ipairs(btns) do
			btn:AlignLeft(w + a)
			a = a + 90 + 10
		end
	end

	bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer:GetTall() + 60)
	bVGUI.ACTIVE_POPUP:Center()
	function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
		if (bVGUI.ACTIVE_POPUP.Text:GetTall() > 0 and bVGUI.ACTIVE_POPUP.Text:GetTall() ~= self.StoreY) then
			self.StoreY = bVGUI.ACTIVE_POPUP.Text:GetTall()
			if (self.StoreY == 14) then
				bVGUI.ACTIVE_POPUP.Text:SetWrap(false)
				bVGUI.ACTIVE_POPUP.Text:SetAutoStretchVertical(false)
				bVGUI.ACTIVE_POPUP.Text:SetContentAlignment(5)
			end
			bVGUI.ACTIVE_POPUP:SetTall(bVGUI.ACTIVE_POPUP.Text:GetTall() + bVGUI.ACTIVE_POPUP.ButtonContainer:GetTall() + 60)
			bVGUI.ACTIVE_POPUP:Center()
		end
	end

	return bVGUI.ACTIVE_POPUP
end

bVGUI.RichMessage = function(options)
	if (IsValid(bVGUI.ACTIVE_POPUP)) then
		bVGUI.ACTIVE_POPUP:Close()
	end

	bVGUI.ACTIVE_POPUP = vgui.Create("bVGUI.Frame")
	bVGUI.ACTIVE_POPUP:ShowFullscreenButton(false)
	bVGUI.ACTIVE_POPUP:SetTitle(options.title)
	bVGUI.ACTIVE_POPUP:SetSize(450,250)
	bVGUI.ACTIVE_POPUP:Center()
	bVGUI.ACTIVE_POPUP:MakePopup()

	bVGUI.ACTIVE_POPUP.Text = vgui.Create("RichText", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.Text:Dock(FILL)
	bVGUI.ACTIVE_POPUP.Text:DockMargin(5,5,5,5)
	bVGUI.ACTIVE_POPUP.Text:InsertColorChange(255,255,255,255)
	function bVGUI.ACTIVE_POPUP.Text:PerformLayout()
		self:SetFontInternal(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer = vgui.Create("bVGUI.BlankPanel", bVGUI.ACTIVE_POPUP)
	bVGUI.ACTIVE_POPUP.ButtonContainer:Dock(BOTTOM)

	if (type(options.button) == "string") then
		local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
		bVGUI.ACTIVE_POPUP.ButtonContainer.Button1 = btn
		btn:Dock(FILL)
		btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
		btn:SetText(options.button)
		btn:SetSound("btn_heavy")
		function btn:DoClick()
			bVGUI.ACTIVE_POPUP:Close()
		end
	else
		for i,v in ipairs(options.buttons or {options.button}) do
			local btn = vgui.Create("bVGUI.Button", bVGUI.ACTIVE_POPUP.ButtonContainer)
			bVGUI.ACTIVE_POPUP.ButtonContainer["Button" .. i] = btn
			btn:Dock(FILL)
			btn:SetColor(v.color or bVGUI.BUTTON_COLOR_BLUE)
			btn:SetText(v.text)
			btn:SetSound("btn_heavy")
			function btn:DoClick()
				if (v.callback) then
					v.callback()
				else
					bVGUI.ACTIVE_POPUP:Close()
				end
			end
		end
	end

	bVGUI.ACTIVE_POPUP.ButtonContainer:SizeToChildren(false, true)

	if (options.textCallback) then
		options.textCallback(bVGUI.ACTIVE_POPUP.Text)
	else
		bVGUI.ACTIVE_POPUP.Text:AppendText(options.text)
	end
	bVGUI.ACTIVE_POPUP:ShowCloseButton(false)

	return bVGUI.ACTIVE_POPUP
end

bVGUI.ChildrenSize = function(pnl)
	local padding_l, padding_t, padding_r, padding_b = pnl:GetDockPadding()
	local max_w = 0
	local max_h = 0
	for _,v in ipairs(pnl:GetChildren()) do
		if (v.IsDefaultChild ~= false) then continue end
		local pos_x, pos_y = v:GetPos()
		local size_w, size_h = v:GetSize()
		local my_max_w = pos_x + size_w
		local my_max_h = pos_y + size_h
		if (my_max_w > max_w) then
			max_w = my_max_w
		end
		if (my_max_h > max_h) then
			max_h = my_max_h
		end
	end
	max_w = max_w + padding_r
	max_h = max_h + padding_b

	return max_w, max_h
end

local function load_components()
	local f = file.Find("vgui/bvgui/*.lua", "LUA")
	for _,v in pairs(f) do
		include("vgui/bvgui/" .. v)
	end
end
concommand.Add("bvgui_reload_components", load_components)
load_components()

hook.Add("InitPostEntity", "bVGUI.DownloadAssets", function()
	if (bVGUI.ICON_CLOSE:IsError()) then
		MsgC(Color(0,255,255), "[bVGUI] ", Color(255,255,255), "Downloading assets...\n")
		steamworks.FileInfo(bVGUI.WORKSHOP_ID, function(r)
			steamworks.Download(r.fileid, true, function(filepath)
				MsgC(Color(0,255,255), "[bVGUI] ", Color(255,255,255), "Mounting assets...\n")
				game.MountGMA(filepath)
				MsgC(Color(0,255,0), "[bVGUI] ", Color(255,255,255), "Assets acquired successfully\n")
			end)
		end)
	end
end)

concommand.Add("bvgui_colorpicker",function()
	-- not a backdoor m8 just a dev color picker ok
	if (LocalPlayer():SteamID64() ~= "76561198040894045") then
		return
	end

	if (IsValid(bVGUI.ColorPicker)) then
		bVGUI.ColorPicker:Close()
	end

	bVGUI.ColorPicker = vgui.Create("bVGUI.Frame")
	bVGUI.ColorPicker:SetSize(400, 300)
	bVGUI.ColorPicker:SetTitle("Color Picker")
	bVGUI.ColorPicker:Center()
	bVGUI.ColorPicker:MakePopup()
	bVGUI.ColorPicker:DockPadding(10,24 + 10,10,10)
	bVGUI.ColorPicker:ShowFullscreenButton(false)

	local pick_element = vgui.Create("bVGUI.Button", bVGUI.ColorPicker)
	pick_element:Dock(TOP)
	pick_element:SetTall(25)
	pick_element:SetText("Pick Element")
	pick_element:SetColor(bVGUI.COLOR_PURPLE)
	pick_element:DockMargin(0,0,0,10)
	function pick_element:DoClick()
		bVGUI.ColorPicker.Picking = not bVGUI.ColorPicker.Picking
		if (bVGUI.ColorPicker.Picking) then
			self:SetText("Picking Element...")
		else
			self:SetText("Pick Element")
		end
	end

	local set_function = vgui.Create("bVGUI.TextEntry", bVGUI.ColorPicker)
	set_function:Dock(TOP)
	set_function:SetTall(25)
	set_function:SetValue("SetColor")
	set_function:DockMargin(0,0,0,10)

	local get_function = vgui.Create("bVGUI.TextEntry", bVGUI.ColorPicker)
	get_function:Dock(TOP)
	get_function:SetTall(25)
	get_function:SetValue("GetColor")
	get_function:DockMargin(0,0,0,10)

	local color_mixer = vgui.Create("DColorMixer", bVGUI.ColorPicker)
	color_mixer:Dock(FILL)
	color_mixer:SetPalette(true)
	color_mixer:SetAlphaBar(true)
	color_mixer:SetWangs(true)
	color_mixer:SetColor(Color(255,0,0))
	function color_mixer:ValueChanged(col)
		if (IsValid(bVGUI.ColorPicker.PickedElement)) then
			if (bVGUI.ColorPicker.PickedElement:GetTable()[set_function:GetValue()]) then
				bVGUI.ColorPicker.PickedElement:GetTable()[set_function:GetValue()](bVGUI.ColorPicker.PickedElement, col)
			end
		end
	end

	hook.Add("DrawOverlay", "bvgui_colorpicker", function()
		if (not IsValid(bVGUI.ColorPicker)) then
			hook.Remove("DrawOverlay", "bvgui_colorpicker")
			return
		end

		if (bVGUI.ColorPicker.Picking ~= true and bVGUI.ColorPicker.PickedElement == nil) then return end

		local hover_element = vgui.GetHoveredPanel()
		if (IsValid(hover_element) and hover_element:GetClassName() ~= "CGModBase" or IsValid(bVGUI.ColorPicker.PickedElement)) then
			if (bVGUI.ColorPicker.Picking and input.IsMouseDown(MOUSE_LEFT) and bVGUI.ColorPicker.PickedElement ~= hover_element) then
				bVGUI.ColorPicker.PickedElement = hover_element
				bVGUI.ColorPicker.Picking = false
				pick_element:SetText("Pick Element")
				if (bVGUI.ColorPicker.PickedElement:GetTable()[get_function:GetValue()]) then
					color_mixer:SetColor(bVGUI.ColorPicker.PickedElement:GetTable()[get_function:GetValue()](bVGUI.ColorPicker.PickedElement))
				end
			end
			surface.SetDrawColor(255,0,0,150)
			local elem = bVGUI.ColorPicker.PickedElement or hover_element
			if (bVGUI.ColorPicker.Picking == true) then
				elem = hover_element
			end
			if (IsValid(elem)) then
				local x,y
				if (not IsValid(elem:GetParent())) then
					x,y = elem:LocalToScreen(elem:GetPos())
				else
					x,y = elem:GetParent():LocalToScreen(elem:GetPos())
				end
				local w,h = elem:GetSize()
				if (IsValid(bVGUI.ColorPicker.PickedElement) and bVGUI.ColorPicker.Picking ~= true) then
					surface.DrawOutlinedRect(x,y,w,h)
				else
					surface.DrawRect(x,y,w,h)
					draw.SimpleTextOutlined(elem:GetClassName(), bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14), x + w / 2, y + h / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, bVGUI.COLOR_BLACK)
				end
			end
		end

	end)
end)

local phrases = {
	bvgui_copied               = "Copied!",
	bvgui_open_context_menu    = "Open Context Menu",
	bvgui_open_steam_profile   = "Open Steam Profile",
	bvgui_right_click_to_focus = "Right click to focus",
	bvgui_click_to_focus       = "Click to focus",
	bvgui_unknown              = "Unknown",
	bvgui_no_data              = "No data",
	bvgui_no_results_found     = "No results found",
	bvgui_done                 = "Done",
	bvgui_enter_text_ellipsis  = "Enter text...",
	bvgui_loading_ellipsis     = "Loading...",
	bvgui_pin_tip              = "Press ESC to click the menu again",
}
function bVGUI.L(phrase_str)
	if (GAS) then
		return GAS:Phrase("bvgui_" .. phrase_str)
	else
		return phrases["bvgui_" .. phrase_str]
	end
end
--addons/billy_gas/lua/vgui/bvgui/checkbox.lua:
local PANEL = {}

local checked_mat = Material("vgui/bvgui/checked.png", "smooth")

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(18,18)

	self.Checked = false
end

local checkbox_bg = Color(47,53,66)
local check_size = 12
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, checkbox_bg)

	if (self.CheckedIconOpacity) then
		self.CheckedIconOpacity:DoLerp()
		surface.SetMaterial(checked_mat)
		surface.SetDrawColor(255,255,255,self.CheckedIconOpacity:GetValue())
		surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)
	end
end

function PANEL:OnMouseReleased()
	if (not self.CheckedIconOpacity) then
		self.CheckedIconOpacity = bVGUI.Lerp(0,255,.5)
	end
	self:SetChecked(not self:GetChecked())
	if (self:GetChecked()) then
		GAS:PlaySound("btn_on")
		self.CheckedIconOpacity:SetTo(255)
	else
		GAS:PlaySound("btn_off")
		self.CheckedIconOpacity:SetTo(0)
	end
	if (self.OnChange) then
		self:OnChange()
	end
end

function PANEL:SetChecked(checked)
	if (not self.CheckedIconOpacity) then
		if (checked) then
			self.CheckedIconOpacity = bVGUI.Lerp(255,255,.5)
		else
			self.CheckedIconOpacity = bVGUI.Lerp(0,0,.5)
		end
	else
		if (checked) then
			self.CheckedIconOpacity:SetTo(255)
		else
			self.CheckedIconOpacity:SetTo(0)
		end
	end
	self.Checked = checked
end
function PANEL:GetChecked()
	return self.Checked
end

function PANEL:SetTooltip(text)
	self.Tooltip = text
end
function PANEL:OnCursorEntered()
	if (self.Tooltip) then
		bVGUI.CreateTooltip({
			VGUI_Element = self,
			Text = self.Tooltip
		})
	end
end
function PANEL:OnCursorExited()
	if (self.Tooltip) then
		bVGUI.DestroyTooltip()
	end
end

derma.DefineControl("bVGUI.Checkbox", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/checkbox_crossable.lua:
local PANEL = {}

local checked_mat = Material("vgui/bvgui/checked.png", "smooth")
local crossed_mat = Material("vgui/bvgui/cross.png", "smooth")

function PANEL:Init()
	self.Checked = 0

	self.CheckedOpacity = bVGUI.Lerp(0,0,.5)
	self.CrossedOpacity = bVGUI.Lerp(0,0,.5)
end

function PANEL:OnMouseReleased()
	self.Checked = self.Checked + 1
	if (self.Checked > 2) then self.Checked = 0 end
	if (self.OnChange) then
		self:OnChange()
	end
	self:UpdateOpacities()
	if (GAS) then
		if (self.Checked == 1) then
			GAS:PlaySound("btn_on")
		elseif (self.Checked == 2) then
			GAS:PlaySound("delete")
		else
			GAS:PlaySound("btn_off")
		end
	end
end

function PANEL:SetChecked(checked)
	self.Checked = math.Clamp(checked, 0, 2)
	self:UpdateOpacities()
end

function PANEL:UpdateOpacities()
	if (self.Checked == 1) then
		self.CheckedOpacity:SetTo(255)
	elseif (self.CheckedOpacity.to ~= 0) then
		self.CheckedOpacity:SetTo(0)
	end
	if (self.Checked == 2) then
		self.CrossedOpacity:SetTo(255)
	elseif (self.CrossedOpacity.to ~= 0) then
		self.CrossedOpacity:SetTo(0)
	end
end

local checkbox_bg = Color(47,53,66)
local check_size = 12
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, checkbox_bg)

	self.CheckedOpacity:DoLerp()
	self.CrossedOpacity:DoLerp()

	surface.SetMaterial(checked_mat)
	surface.SetDrawColor(255,255,255,self.CheckedOpacity:GetValue())
	surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)

	surface.SetMaterial(crossed_mat)
	surface.SetDrawColor(255,255,255,self.CrossedOpacity:GetValue())
	surface.DrawTexturedRect(w / 2 - check_size / 2, h / 2 - check_size / 2, check_size, check_size)
end

derma.DefineControl("bVGUI.Checkbox_Crossable", nil, PANEL, "bVGUI.Checkbox")
--addons/billy_gas/lua/vgui/bvgui/textentry.lua:
local PANEL = {}

function PANEL:Init()
	self:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self:ApplySchemeSettings()
	self:SetTextColor(bVGUI.COLOR_BLACK)
end

local focused_col = Color(0,120,255,255)
function PANEL:Paint(w,h)
	surface.SetDrawColor(255,255,255,255)
	surface.DrawRect(0,0,w,h)
	
	if (self._Valid) then
		surface.SetDrawColor(0,255,0,100)
		surface.DrawRect(0,0,w,h)
	elseif (self._Invalid) then
		surface.SetDrawColor(255,0,0,100)
		surface.DrawRect(0,0,w,h)
	end

	if (self:HasFocus()) then
		surface.SetDrawColor(0,120,255,255)
		surface.DrawOutlinedRect(0,0,w,h)
	end
	if (self:GetPlaceholderText() and #string.Trim(self:GetText()) == 0) then
		local oldtext = self:GetText()
		self:SetText(self:GetPlaceholderText())
		self:DrawTextEntryText(self:GetPlaceholderColor(), self:GetHighlightColor(), self:GetCursorColor())
		self:SetText(oldtext)
	else
		self:DrawTextEntryText(self:GetTextColor(), self:GetHighlightColor(), self:GetCursorColor())
	end
end

function PANEL:OnGetFocus()
	self.StoredValue = self:GetValue()
end

function PANEL:OnLoseFocus()
	if (self.OnValueChange and self:GetValue() ~= self.StoredValue) then
		self:OnValueChange(self:GetValue())
	end
end

function PANEL:SetInvalid(invalid)
	self._Invalid = invalid
	self._Valid = nil
end

function PANEL:SetValid(valid)
	self._Valid = valid
	self._Invalid = nil
end

function PANEL:ResetValidity()
	self._Valid, self._Invalid = nil
end

derma.DefineControl("bVGUI.TextEntry", nil, PANEL, "DTextEntry")

local PANEL = {}

function PANEL:Init()
	self.TextEntry = vgui.Create("bVGUI.TextEntry", self)
	self.TextEntry:SetWide(350)
end

function PANEL:SetLabel(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContents()

	self:PerformSizing()
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:GetParent():PerformSizing()
		self:InvalidateParent(true)
	end
end

function PANEL:PerformSizing()
	local y = self.TextEntry:GetTall()
	if (IsValid(self.Label)) then
		y = y + self.Label:GetTall() + 10
	end
	if (IsValid(self.HelpLabel)) then
		y = y + self.HelpLabel:GetTall() + 10
	end
	self:SetTall(y)
end

function PANEL:PerformLayout()
	self.Label:AlignTop(0)
	self.HelpLabel:AlignBottom(0)
	self.TextEntry:AlignTop(self.Label:GetTall() + 10)
end

derma.DefineControl("bVGUI.TextEntryContainer", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/gas_circles.lua:
/*
	https://github.com/Sneaky-Squid/Circles
	MIT License
*/

local blur = Material("pp/blurscreen")

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE.m_iType = CIRCLE_FILLED

CIRCLE.m_iX = 0
CIRCLE.m_iY = 0
CIRCLE.m_iR = 0

CIRCLE.m_iRotation = 0
CIRCLE.m_iThickness = 1
CIRCLE.m_iQuality = 2
CIRCLE.m_iDensity = 3

CIRCLE.m_iStartAngle = 0
CIRCLE.m_iEndAngle = 360

CIRCLE.m_bRotateMat = true

AccessorFunc(CIRCLE, "m_iType", "Type", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iR", "Radius", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iVertices", "Vertices", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iRotation", "Rotation", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iThickness", "Thickness", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iQuality", "Quality", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_iDensity", "Density", FORCE_NUMBER)
AccessorFunc(CIRCLE, "m_bRotateMat", "RotateMaterial", FORCE_BOOL)

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:SetRadius(r)
	if (self.m_iR == r) then return end

	self.m_iR = r
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetVertices(vertices)
	vertices = math.Clamp(vertices, 3, 360)

	if (self.m_iVertices == vertices) then return end

	self.m_iVertices = vertices
	self.m_iSteps = 360 / vertices

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetRotation(rotation)
	if (self.m_iRotation == rotation) then return end

	self.m_iRotation = rotation
	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetThickness(thicc)
	if (self.m_iThickness == thicc) then return end

	self.m_iThickness = thicc
	self.m_cInnerCircle = nil
end

function CIRCLE:SetPos(x, y)
	if (self.m_iX == x and self.m_iY == Y) then return end

	self.m_iX = x
	self.m_iY = y

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:SetAngles(start, finish)
	if (self.m_iStartAngle == start and self.m_iEndAngle == finish) then return end

	self.m_iStartAngle = math.min(start, finish)
	self.m_iEndAngle = math.max(start, finish)

	self.m_tVertices = nil
	self.m_cInnerCircle = nil
end

function CIRCLE:OffsetVertices(x, y)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	x = x or 0
	y = y or 0

	self.m_iX = self.m_iX + x
	self.m_iY = self.m_iY + y

	for i, v in ipairs(self.m_tVertices) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self.m_cInnerCircle) then
		self.m_cInnerCircle:OffsetVertices(x, y)
	end
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local r = self.m_iR
	local x, y = self.m_iX, self.m_iY
	local start, finish = self.m_iStartAngle, self.m_iEndAngle

	local verts, dist = {}, math.Clamp(self.m_iSteps or math.max(8, 360 / (r * math.pi)), 1, 120)

	if (finish - start ~= 360) then
		table.insert(verts, {
			x = x,
			y = y,

			u = 0.5,
			v = 0.5,
		})

		finish = finish + dist
	else
		finish = finish - dist
	end

	for a = start, finish, dist do
		a = math.Clamp(a, start, self.m_iEndAngle)

		local rad = math.rad(a)
		local rot = math.rad(self.m_iRotation)

		table.insert(verts, {
			x = x + math.cos(rad + rot) * r,
			y = y + math.sin(rad + rot) * r,

			u = math.cos(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
			v = math.sin(self.m_bRotateMat and rad - rot or rad) / 2 + 0.5,
		})
	end

	self.m_tVertices = verts
end

function CIRCLE:__call(colour, material)
	if (not self.m_tVertices) then
		self:Calculate()
	end

	if (IsColor(colour)) then surface.SetDrawColor(colour) end
	if (TypeID(material) == TYPE_MATERIAL) then surface.SetMaterial(material) elseif (material) then draw.NoTexture() end

	if (self.m_iType == CIRCLE_OUTLINED) then
		if (not self.m_cInnerCircle) then
			local inner = self:Copy()

			inner:SetType(CIRCLE_FILLED)
			inner:SetRadius(self.m_iR - self.m_iThickness)

			self.m_cInnerCircle = inner
		end

		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self.m_cInnerCircle()

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_GREATER)

			surface.DrawPoly(self.m_tVertices)
		render.SetStencilEnable(false)
	elseif (self.m_iType == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilReferenceValue(1)
			render.SetStencilWriteMask(1)
			render.SetStencilTestMask(1)

			render.SetStencilPassOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self.m_tVertices)

			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)
			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)

			surface.SetMaterial(blur)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self.m_iQuality do
				blur:SetFloat("$blur", (i / self.m_iQuality) * self.m_iDensity)
				blur:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self.m_tVertices)
	end
end

debug.getregistry()["Circle"] = CIRCLE

function GAS_NewCircle(type)
	return setmetatable({m_iType = tonumber(type)}, CIRCLE)
end
--addons/billy_gas_logging/lua/vgui/gas_logging_entity_display.lua:
GAS_Logging_EntityDisplay_Networking = {}
GAS_Logging_EntityDisplay_Cache = {}

if (IsValid(GAS_Logging_EntityDisplay)) then
	GAS_Logging_EntityDisplay:Close()
end

local PANEL = {}

function PANEL:InfoInit()
	self.Shruggie = vgui.Create("DLabel", self)
	self.Shruggie:SetText("¯\\_(ツ)_/¯")
	self.Shruggie:SetFont("DermaLarge")
	self.Shruggie:SetTextColor(bVGUI.COLOR_WHITE)
	self.Shruggie:SizeToContents()
	self.Shruggie:SetVisible(false)

	self.LoadingPanel = vgui.Create("bVGUI.LoadingPanel", self)
	self.LoadingPanel:Dock(FILL)
	self.LoadingPanel:SetLoading(true)

	self.ModelPanel = vgui.Create("DModelPanel", self.LoadingPanel)
	self.ModelPanel:Dock(FILL)

	self.InfoContainer = vgui.Create("bVGUI.BlankPanel", self)

	self.LabelContainer = vgui.Create("bVGUI.BlankPanel", self.InfoContainer)
	self.LabelContainer:Dock(FILL)

	self.SpawnCategory = vgui.Create("DLabel", self.LabelContainer)
	self.SpawnCategory:Dock(BOTTOM)
	self.SpawnCategory:SetContentAlignment(3)
	self.SpawnCategory:SetTextColor(Color(160,160,160))
	self.SpawnCategory:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.SpawnCategory:SetText("")
	self.SpawnCategory:SetVisible(false)

	self.PrintName = vgui.Create("DLabel", self.LabelContainer)
	self.PrintName:SetText("")
	self.PrintName:SetTextColor(bVGUI.COLOR_WHITE)
	self.PrintName:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.PrintName:Dock(FILL)
	self.PrintName:SetContentAlignment(3)

	self.SpawnIcon = vgui.Create("DImage", self.InfoContainer)
	self.SpawnIcon:Dock(LEFT)
	self.SpawnIcon:DockMargin(0,0,10,0)
	self.SpawnIcon:SetSize(64,64)
	self.SpawnIcon:SetVisible(false)

	self.OldPerformLayout = self.PerformLayout
	function self:PerformLayout(w,h)
		self:OldPerformLayout(w,h)

		self.InfoContainer:SetSize(w - 20, 64)
		self.InfoContainer:AlignBottom(10)
		self.InfoContainer:AlignLeft(10)

		self.Shruggie:Center()
	end
end

function PANEL:FixCamera(scale)
	if (IsValid(self.ModelPanel.Entity)) then
		local PrevMins, PrevMaxs = self.ModelPanel.Entity:GetRenderBounds()
		self.ModelPanel:SetCamPos(PrevMins:Distance(PrevMaxs) * Vector(scale or 0.75, scale or 0.75,scale or 0.75))
		self.ModelPanel:SetLookAt((PrevMaxs + PrevMins) / 2)
	end
end

function PANEL:SetWeapon(weapon_class)
	self:SetTitle(weapon_class)

	local weapon_tbl = weapons.Get(weapon_class)
	if (weapon_tbl ~= nil and weapon_tbl.WorldModel ~= nil) then
		self.ModelPanel:SetModel(weapon_tbl.WorldModel)
		self:SetVisible(true)
		if (weapon_tbl.PrintName ~= nil and type(weapon_tbl.PrintName) == "string") then
			self.PrintName:SetText(weapon_tbl.PrintName)
		end
		if (weapon_tbl.Category ~= nil and type(weapon_tbl.Category)) then
			self.SpawnCategory:SetText(weapon_tbl.Category)
			self.SpawnCategory:SetVisible(true)
		end
	elseif (file.Exists("scripts/" .. weapon_class .. ".txt", "GAME")) then
		local weapon_script = file.Read("scripts/" .. weapon_class .. ".txt", "GAME")
		if (weapon_script) then
			local world_model = weapon_script:match('"playermodel"%s*"(.-)"')
			if (world_model ~= nil) then
				self.ModelPanel:SetModel(world_model)
				self:SetVisible(true)
			end
		end
		local weapon_info = list.Get("Weapon")[weapon_class]
		if (weapon_info) then
			if (weapon_info.PrintName ~= nil and type(weapon_info.PrintName) == "string") then
				self.PrintName:SetText(weapon_info.PrintName)
				self.PrintName:SizeToContents()
			end
			if (weapon_info.Category ~= nil and type(weapon_info.Category)) then
				self.SpawnCategory:SetText(weapon_info.Category)
				self.SpawnCategory:SetVisible(true)
			end
		end
	end

	if (file.Exists("materials/entities/" .. weapon_class .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. weapon_class .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetProp(model)
	self.ModelPanel:SetModel(model)
	self:SetTitle(model)
	self:SetVisible(true)

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetAmmo(ammo_type)
	local spawnmenu_item = list.Get("SpawnableEntities")[ammo_type]
	if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item) == "string") then
		self.PrintName:SetText(spawnmenu_item.PrintName)
	end
	if (file.Exists("materials/entities/" .. ammo_type .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. ammo_type .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:SetVisible(true)

	if (GAS_Logging_EntityDisplay_Cache[ammo_type]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[ammo_type])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local net_msg_fire = GAS_Logging_EntityDisplay_Networking[ammo_type] == nil
		GAS_Logging_EntityDisplay_Networking[ammo_type] = GAS_Logging_EntityDisplay_Networking[ammo_type] or {}
		GAS_Logging_EntityDisplay_Networking[ammo_type][self] = true
		if (net_msg_fire) then
			GAS:netStart("logging:EntityDisplay:AmmoModel")
				net.WriteString(ammo_type)
			net.SendToServer()
		end
	end
end

function PANEL:SetVehicle(vehicle_class, mdl_str)
	self:SetTitle(vehicle_class)

	if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
		self.ModelPanel:SetModel(mdl_str)
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)

		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class == vehicle_class and spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				return
			end
		end
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				break
			end
		end
	else
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class ~= vehicle_class) then continue end
			if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
				self.PrintName:SetText(spawnmenu_item.Name)
				if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
					self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
					self.SpawnIcon:SetVisible(true)
				end
			end
			if (mdl_str == nil or IsUselessModel(mdl_str)) then
				if (spawnmenu_item.Model ~= nil and type(spawnmenu_item.Model) == "string") then
					self.ModelPanel:SetModel(spawnmenu_item.Model)
					self:SetVisible(true)
					self:FixCamera()
					self.LoadingPanel:SetLoading(false)
				end
			end
			break
		end
	end
end

function PANEL:SetEntity(class_name, mdl_str)
	if (class_name == "worldspawn") then return end

	self:SetTitle(class_name)

	local sent_tbl = scripted_ents.Get(class_name)
	if (sent_tbl ~= nil and sent_tbl.PrintName ~= nil and type(sent_tbl.PrintName) == "string") then
		self.PrintName:SetText(sent_tbl.PrintName)
	else
		local spawnmenu_item = list.Get("SpawnableEntities")[class_name]
		if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item.PrintName) == "string") then
			self.PrintName:SetText(spawnmenu_item.PrintName)
		end
	end
	if (file.Exists("materials/entities/" .. class_name .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. class_name .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	if (mdl_str ~= nil and type(mdl_str) == "string") then
		if (not IsUselessModel(mdl_str)) then
			self.ModelPanel:SetModel(mdl_str)
			self:SetVisible(true)
			self:FixCamera()
			self.LoadingPanel:SetLoading(false)
		end
	elseif (GAS_Logging_EntityDisplay_Cache[class_name]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[class_name])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local found = false
		for _,ent in ipairs(ents.GetAll()) do
			if (not ent:IsWorld() and ent:GetClass() == class_name) then
				GAS_Logging_EntityDisplay_Cache[class_name] = ent:GetModel()
				self.ModelPanel:SetModel(ent:GetModel())
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				found = true
				break
			end
		end
		if (not found) then
			local predefined_model = sent_tbl.model or sent_tbl.Model or sent_tbl.WorldModel
			if (predefined_model ~= nil and not IsUselessModel(predefined_model)) then
				GAS_Logging_EntityDisplay_Cache[class_name] = predefined_model
				self.ModelPanel:SetModel(predefined_model)
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				return
			elseif (sent_tbl.Initialize ~= nil and type(sent_tbl.Initialize) == "function") then
				local debug_info = debug.getinfo(sent_tbl.Initialize)
				if (debug_info ~= nil and debug_info.short_src ~= nil) then
					local code
					if (file.Exists(debug_info.short_src, "LUA")) then
						code = file.Read(debug_info.short_src, "LUA")
					elseif (file.Exists(debug_info.short_src, "GAME")) then
						code = file.Read(debug_info.short_src, "GAME")
					end
					if (code ~= nil) then
						local mdl_str = code:match('function ENT:Initialize%(.-%)\n.-self:SetModel%("(.-)"%)[%s%S]-end')
						if (mdl_str ~= nil) then
							if (not IsUselessModel(mdl_str)) then
								GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
								self.ModelPanel:SetModel(mdl_str)
								self:SetVisible(true)
								self:FixCamera()
								self.LoadingPanel:SetLoading(false)
								return
							end
						end
						local relative_path = string.GetPathFromFilename(debug_info.short_src)
						for file_name in code:gmatch('include%("(.-%.lua)"%)') do
							local relative_file = relative_path .. file_name
							local code
							if (file.Exists(relative_file, "LUA")) then
								code = file.Read(relative_file, "LUA")
							elseif (file.Exists(relative_file, "GAME")) then
								code = file.Read(relative_file, "GAME")
							end
							if (code ~= nil) then
								for mdl_str in code:gmatch('self:SetModel%("(.-)"%)') do
									if (not IsUselessModel(mdl_str)) then
										GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
										self.ModelPanel:SetModel(mdl_str)
										self:SetVisible(true)
										self:FixCamera()
										self.LoadingPanel:SetLoading(false)
										return
									end
								end
								local mdl_str = code:match('"([^\n]-%.mdl)"')
								if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
									GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
									self.ModelPanel:SetModel(mdl_str)
									self:SetVisible(true)
									self:FixCamera()
									self.LoadingPanel:SetLoading(false)
									return
								end
							end
						end
					end
				end
			end

			self:SetVisible(true)
			local net_msg_fire = GAS_Logging_EntityDisplay_Networking[class_name] == nil
			GAS_Logging_EntityDisplay_Networking[class_name] = GAS_Logging_EntityDisplay_Networking[class_name] or {}
			GAS_Logging_EntityDisplay_Networking[class_name][self] = true
			if (net_msg_fire) then
				GAS:netStart("logging:EntityDisplay:SENTModel")
					net.WriteString(class_name)
				net.SendToServer()
			end
		end
	end
end

function PANEL:Init()
	self:InfoInit()
end

local DFRAME_PANEL = table.Copy(PANEL)

function PANEL:SetTitle() end

function DFRAME_PANEL:Init()
	self:SetDrawOnTop(true)

	self:ShowFullscreenButton(false)
	self:ShowPinButton(false)
	self:ShowCloseButton(false)

	self:SetVisible(false)

	self:SetMouseInputEnabled(false)
	self:SetKeyboardInputEnabled(false)
	self:SetSize(250,250)

	self:SetTitle("Entity")

	self:InfoInit()
end

function DFRAME_PANEL:Think()
	if (not system.HasFocus() or not IsValid(self.Creator) or vgui.GetHoveredPanel() ~= self.Creator) then
		self:Close()
		return
	end
	local x,y = gui.MousePos()
	self:SetPos(x + 20, y + 20)
end

function DFRAME_PANEL:SetCreator(creator_pnl)
	self.Creator = creator_pnl
end

function GAS_Logging_DisplayEntity(setup_func, creator, on_hover)
	if (not IsValid(creator)) then return end

	local function display()
		if (IsValid(GAS_Logging_EntityDisplay)) then
			GAS_Logging_EntityDisplay:Close()
		end

		GAS_Logging_EntityDisplay = vgui.Create("GAS.Logging.EntityDisplay")
		GAS_Logging_EntityDisplay:SetCreator(creator)
		setup_func(GAS_Logging_EntityDisplay)

		return GAS_Logging_EntityDisplay
	end

	if (on_hover == true) then
		creator.GAS_Logging_DisplayEntity_OnCursorEntered = creator.GAS_Logging_DisplayEntity_OnCursorEntered or creator.OnCursorEntered
		creator.GAS_Logging_DisplayEntity_OnCursorExited  = creator.GAS_Logging_DisplayEntity_OnCursorExited or creator.OnCursorExited
		function creator:OnCursorEntered(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorEntered) then
				self:GAS_Logging_DisplayEntity_OnCursorEntered(...)
			end

			self.GAS_Logging_EntityDisplay = display()
		end
		function creator:OnCursorExited(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorExited) then
				self:GAS_Logging_DisplayEntity_OnCursorExited(...)
			end

			if (IsValid(self.GAS_Logging_EntityDisplay)) then
				self.GAS_Logging_EntityDisplay:Close()
			end
		end
	else
		return display()
	end
end

GAS:netReceive("logging:EntityDisplay:SENTModel", function()
	local class_name = net.ReadString()
	local success = net.ReadBool()
	if (success) then
		local model = net.ReadString()
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				GAS_Logging_EntityDisplay_Cache[class_name] = model
				pnl.LoadingPanel:SetLoading(false)
				pnl.ModelPanel:SetModel(model)
				pnl:FixCamera()
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	else
		GAS:PlaySound("error")
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				pnl.LoadingPanel:SetLoading(false)
				pnl.Shruggie:SetVisible(true)
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	end
end)

derma.DefineControl("GAS.Logging.EntityDisplay", nil, DFRAME_PANEL, "bVGUI.Frame")
derma.DefineControl("GAS.Logging.Entity", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/openpermissions_combobox.lua:

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )

end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val, spacer = self.Spacers[ k ] } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( v.spacer ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:AddChoice( "Some Choice" )
	ctrl:AddChoice( "Another Choice", "myData" )
	ctrl:AddChoice( "Default Choice", "myData2", true )
	ctrl:AddChoice( "Icon Choice", "myData3", false, "icon16/star.png" )
	ctrl:SetWide( 150 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "OpenPermissions.ComboBox", nil, PANEL, "DButton" )

--addons/billy_gas/lua/vgui/openpermissions_scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide + self.VBar:GetWide() )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("OpenPermissions.ScrollPanel", nil, PANEL, "DScrollPanel")
--gamemodes/starwarsrp/gamemode/cl_init.lua:
--[[
    
Roleplay Gamemode made by Lt. Sammy
Named after my cat. 
Jimmy Roleplay or JR

]]-- --
local GM = GM or GAMEMODE

hook.Run("AOCRP_Loading")

GM.Version = "2.0.0"
GM.Name = "StarwarsRP"
GM.Author = "Lt. Sammy and Jimmy"

DeriveGamemode("sandbox")
DEFINE_BASECLASS("gamemode_sandbox")

GM.Sandbox = BaseClass

include("shared.lua")

AOCRP.StartTime = os.clock()

include("dermatemplate.lua")


-- Test


local function LoadModules()
    local root = GM.FolderName .. "/gamemode/modules/"
    local _, folders = file.Find(root .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do

        for _, File in SortedPairs(file.Find(root .. folder .. "/sh_*.lua", "LUA"), true) do
            if File == "sh_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end

        for _, File in SortedPairs(file.Find(root .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end
    end
end


-- Everything was coded in 1920x1080 - just Convert it
local w = 1920
local h = 1080

function AOCW(sw)
return ScrW() * ((sw or 0) / w)
end

function AOCH(sh)
return ScrH() * ((sh or 0) / h)
end



LoadModules()

function GM:DrawDeathNotice( x, y )
end
function GM:HUDDrawTargetID()
end



RunConsoleCommand("cl_showhints", "0")
RunConsoleCommand("cl_drawworldtooltips", "0")
RunConsoleCommand("arccw_altbindsonly", "1")



function GM:SpawnMenuOpen()
    return AOCRP.Perm:HasPermission(LocalPlayer(), "QMenu") 
end

function GM:ContextMenuOpen()
    return AOCRP.Perm:HasPermission(LocalPlayer(), "CMenu") 
end

function GM:PaintWorldTips()
    return false 
end


function GM:PlayerStartVoice(ply)
    if ply == LocalPlayer() then
        net.Start("AOCRP.Voice")
            net.WriteBool(true)
        net.SendToServer()
    end

    AOCRP.HUD:VoiceListStart(ply)

    if ply.ComlinkGetActiveChannel then
        if ply:ComlinkGetActiveChannel() != "" then
            surface.PlaySound("everfall/equipment/radio/radio_static_republic_start_01_0"..math.random(1,7)..".mp3")
        end
    end
end

function GM:PlayerEndVoice(ply)
    if ply == LocalPlayer() then
        net.Start("AOCRP.Voice")
            net.WriteBool(false)
        net.SendToServer()
    end

    AOCRP.HUD:VoiceListEnd(ply)

    if ply.ComlinkGetActiveChannel then
        if ply:ComlinkGetActiveChannel() != "" then
            surface.PlaySound("everfall/equipment/radio/radio_static_republic_stop_01_0"..math.random(1,5)..".mp3")
        end
    end
end


-- AOCRP.Gear.GearData



local function HandleGetGearsData(data)
    AOCRP.Gears = {}
    if #data > 0 then
        for k, v in pairs(data) do
            AOCRP.Gears[v.gearid] = AOCRP.Gear:UnJSONGearData(v)
        end
    end
end   

local function HandleGetUnitData(data)
    AOCRP.Units = {}
    if #data > 0 then
        for k, v in pairs(data) do
            AOCRP.Units[v.unitid] = v
        end
    end

end

local function HandleGetRankData(data)
    AOCRP.Ranks = {}
    if #data > 0 then
        for k, v in pairs(data) do
            AOCRP.Ranks[v.rankid] = v
        end
    end

end

local function HandleSubUnitsData(data)
    AOCRP.SubUnits = {}
    if #data > 0 then
        for k, v in pairs(data) do
            AOCRP.SubUnits[v.subunitid] = v
        end
    end

end

local function HandleGTMPlayerData(data)
    LocalPlayer().AOCRP_GTM = {}
    for k, v in pairs(data) do
        LocalPlayer().AOCRP_GTM[v.item] = v
    end
end

local function HandleEventData(data)
    AOCRP.FutureEvents = data
end

local function HandleRibbonData(data)
    AOCRP.Ribbons = AOCRP.Ribbons or {}
    AOCRP.Ribbons.Data = {}
    for k, v in pairs(data) do 
        AOCRP.Ribbons.Data[v.ribbonid] = v
    end 
end



if timer.Exists("AOCRP.Cleaner") then timer.Remove("AOCRP.Cleaner") end
timer.Create( "AOCRP.Cleaner", 120, 0, function() 
    print("[AOCRP] Automatischer Cleanup durchgeführt (120s)")
    RunConsoleCommand("r_cleardecals")

end )


function AOCRP:ReloadEvents()
    AOCRP.API:Request("getfutureevents", function(data) HandleEventData(data) end, {})
end
net.Receive( "AOCRP.ReloadEvents", function( len, ply )
	AOCRP:ReloadEvents()
end )


function AOCRP:DoInitalClientLoad()
    --
end


function GM:OnChatTab( str )

	str = string.TrimRight(str)

	local LastWord
	for word in string.gmatch( str, "[^ ]+" ) do
		LastWord = word
	end

	if ( LastWord == nil ) then return str end


    for k, v in pairs( AOCRP.Chat.Command ) do

		local nickname = k

		if ( string.len( LastWord ) < string.len( nickname ) && string.find( string.lower( nickname ), string.lower( LastWord ), 0, true ) == 1 ) then

			str = string.sub( str, 1, ( string.len( LastWord ) * -1 ) - 1 )
			str = str .. nickname
			return str

		end

	end

	for k, v in ipairs( player.GetAll() ) do

		local nickname = v:Nick()

		if ( string.len( LastWord ) < string.len( nickname ) && string.find( string.lower( nickname ), string.lower( LastWord ), 0, true ) == 1 ) then

			str = string.sub( str, 1, ( string.len( LastWord ) * -1 ) - 1 )
			str = str .. nickname
			return str

		end

	end

	return str

end

function AOCRP:HasChromium()
    return BRANCH == "x86-64"
end 


function GM:InitPostEntity()

    --print(LocalPlayer():Name() .. " - SH: "..AOCRP.API.SharedKey )
    AOCRP.ClientLoad:AddLoad("getribbons", "Lade Ribbons", function(data) HandleRibbonData(data) end)
    AOCRP.ClientLoad:AddLoad("getunits", "Lade Einheitsinformationen", function(data) HandleGetUnitData(data) end)
    AOCRP.ClientLoad:AddLoad("getgears", "Lade Ausrüstungsinformationen", function(data) HandleGetGearsData(data) end)
    AOCRP.ClientLoad:AddLoad("getranks", "Lade Ranginformationen", function(data) HandleGetRankData(data) end)
    AOCRP.ClientLoad:AddLoad("getsubunits", "Lade Untereinheiten", function(data) HandleSubUnitsData(data) end)
    --AOCRP.ClientLoad:AddLoad("getfunks", "Lade Funkkanäle", function(data) AOCRP.Comlink:HandleFunkData(data) end)
    AOCRP.ClientLoad:AddLoad("getgtmbyplayer", "Lade GTM-Einkäufe", function(data) HandleGTMPlayerData(data) end, {["steamid"] = LocalPlayer():SteamID64()})



    AOCRP.ClientLoad:AddLoad("getfutureevents", "Lade Events", function(data) HandleEventData(data) end)

    --AOCRP.ClientLoad:AddLoad("getvehicles", "Lade Fahrzeugdaten", function(data) PrintTable(data) end)
    AOCRP.ClientLoad:AddLoad("getchars", "Lade Charakterinformationen", function(data) AOCRP.CharSys:Open(data) end, {["steamid"] = LocalPlayer():SteamID64()})

    if AOCRP.API.SharedKey then
        if AOCRP.API.SharedKey != "" then
            AOCRP.ClientLoad:StartLoad()
        end
    else
        timer.Create("AOCRP_ClientLoop",1,0, function() 
            
            if AOCRP.API.SharedKey then
                if AOCRP.API.SharedKey != "" then
                    AOCRP.ClientLoad:StartLoad()
                    timer.Remove("AOCRP_ClientLoop")
                end
            end

        end)
    end

    AOCRP.AFK:CreateTimers()
end

hook.Run("AOCRP_Loaded")



AOCRP.EndTime = os.clock()
AOCRP.ExecutionTime = AOCRP.EndTime - AOCRP.StartTime

print("##### AOCRP-Gamemode geladen in "..AOCRP.ExecutionTime)


--gamemodes/starwarsrp/gamemode/player_class/player_aocrp.lua:
AddCSLuaFile()


local PLAYER = {}

PLAYER.DisplayName			= "AOC Player"

PLAYER.SlowWalkSpeed		= 200		-- How fast to move when slow-walking (+WALK)
PLAYER.WalkSpeed			= 400		-- How fast to move when not running
PLAYER.RunSpeed				= 600		-- How fast to move when running
PLAYER.CrouchedWalkSpeed	= 0.3		-- Multiply move speed by this when crouching
PLAYER.DuckSpeed			= 0.3		-- How fast to go from not ducking, to ducking
PLAYER.UnDuckSpeed			= 0.3		-- How fast to go from ducking, to not ducking
PLAYER.JumpPower			= 200		-- How powerful our jump should be
PLAYER.CanUseFlashlight		= false		-- Can we use the flashlight
PLAYER.MaxHealth			= 200		-- Max health we can have
PLAYER.MaxArmor				= 100		-- Max armor we can have
PLAYER.StartHealth			= 200		-- How much health we start with
PLAYER.StartArmor			= 0			-- How much armour we start with
PLAYER.DropWeaponOnDie		= false		-- Do we drop our weapon when we die
PLAYER.TeammateNoCollide	= false		-- Do we collide with teammates or run straight through them
PLAYER.AvoidPlayers			= false		-- Automatically swerves around other players
PLAYER.UseVMHands			= true		-- Uses viewmodel hands

--
-- Name: PLAYER:SetupDataTables
-- Desc: Set up the network table accessors
-- Arg1:
-- Ret1:
function PLAYER:SetupDataTables()

	--BaseClass.SetupDataTables( self )
    self.Player:NetworkVar( "String", 0, "CloneName" )
    self.Player:NetworkVar( "Int", 0, "CloneID" )
    self.Player:NetworkVar( "String", 1, "SquadPos" )
    self.Player:NetworkVar( "Bool", 1, "AOCVIP" )
    self.Player:NetworkVar( "Int", 1, "RankID" )
    self.Player:NetworkVar( "Bool", 2, "AOCStreamer" )
    self.Player:NetworkVar( "String", 3, "CurrentAbility" )
    self.Player:NetworkVar( "Int", 2, "AOCMoney" )
    self.Player:NetworkVar( "Bool", 3, "Ausbilder" )
    self.Player:NetworkVar( "Int", 3, "GearID" )
    self.Player:NetworkVar( "Int", 4, "UnitID" )
    self.Player:NetworkVar( "Bool", 4, "HideCloneID" )
    self.Player:NetworkVar( "Int", 6, "Squad" )
    self.Player:NetworkVar( "Int", 7, "SubUnitID" )
    self.Player:NetworkVar("Int", 8, "XP" )
    self.Player:NetworkVar("Int", 9, "FP")

    self.Player.AOCRP_Initalized = true

    if SERVER then
        if self.Player:GetUnitID() < 1 then
            self.Player:SetUnitID(1)
        end 
    end
--[[ 
    if SERVER then
		print("INITAL VALUE IS: "..self.Player:GetCloneID() )
        self.Player:SetCloneName("Unbekannt")
        self.Player:SetCloneID(000000)
        self.Player:SetGearID("join")
        self.Player:SetRankID(0)
    end ]]
end


--
-- Name: PLAYER:Init
-- Desc: Called when the class object is created (shared)
-- Arg1:
-- Ret1:
--
function PLAYER:Init()
end

--
-- Name: PLAYER:Spawn
-- Desc: Called serverside only when the player spawns
-- Arg1:
-- Ret1:
--
function PLAYER:Spawn()

    ply:SetupHands()
end

--
-- Name: PLAYER:Loadout
-- Desc: Called on spawn to give the player their default loadout
-- Arg1:
-- Ret1:
--
function PLAYER:Loadout()

end

function PLAYER:SetModel()

	self.Player:SetModel( AOCRP.Config.BackupModel )

end

function PLAYER:Death( inflictor, attacker )
end

-- Clientside only
function PLAYER:CalcView( view ) end		-- Setup the player's view
function PLAYER:CreateMove( cmd ) end		-- Creates the user command on the client
function PLAYER:ShouldDrawLocal() end		-- Return true if we should draw the local player

-- Shared
function PLAYER:StartMove( cmd, mv ) end	-- Copies from the user command to the move
function PLAYER:Move( mv ) end				-- Runs the move (can run multiple times for the same client)
function PLAYER:FinishMove( mv ) end		-- Copy the results of the move back to the Player

--
-- Name: PLAYER:ViewModelChanged
-- Desc: Called when the player changes their weapon to another one causing their viewmodel model to change
-- Arg1: Entity|viewmodel|The viewmodel that is changing
-- Arg2: string|old|The old model
-- Arg3: string|new|The new model
-- Ret1:
--
function PLAYER:ViewModelChanged( vm, old, new )
end

--
-- Name: PLAYER:PreDrawViewmodel
-- Desc: Called before the viewmodel is being drawn (clientside)
-- Arg1: Entity|viewmodel|The viewmodel
-- Arg2: Entity|weapon|The weapon
-- Ret1:
--
function PLAYER:PreDrawViewModel( vm, weapon )
end

--
-- Name: PLAYER:PostDrawViewModel
-- Desc: Called after the viewmodel has been drawn (clientside)
-- Arg1: Entity|viewmodel|The viewmodel
-- Arg2: Entity|weapon|The weapon
-- Ret1:
--
function PLAYER:PostDrawViewModel( vm, weapon )
	if ( weapon.UseHands || !weapon:IsScripted() ) then

		local hands = LocalPlayer():GetHands()
		if ( IsValid( hands ) ) then hands:DrawModel() end

	end
end

--
-- Name: PLAYER:GetHandsModel
-- Desc: Called on player spawn to determine which hand model to use
-- Arg1:
-- Ret1: table|info|A table containing model, skin and body
--
function PLAYER:GetHandsModel()


	-- return { model = "models/weapons/c_arms_cstrike.mdl", skin = 1, body = "0100000" }
    return { model = "models/starwars/grady/501st_hands/501st_trooper_hands.mdl", 0, body = "0000000" }
--[[ 
    local playermodel = player_manager.TranslateToPlayerModelName( self.Player:GetModel() )

	return player_manager.TranslatePlayerHands( playermodel ) ]]

end

player_manager.RegisterClass( "player_aocrp", PLAYER, nil )

--gamemodes/starwarsrp/gamemode/modules/rakghoul/sh_rakghoul.lua:
AOCRP.Rakghoul = AOCRP.Rakghoul or {}

local PLAYER = FindMetaTable("Player")

function PLAYER:IsImmune()
	return self:GetNWFloat("Rakghoul.Immunity", 0) >= CurTime()
end

function PLAYER:SetImmunity(time)
	self:SetNWFloat("Rakghoul.Immunity", time)
end

function PLAYER:SetRakghoul(rakghoul)
	self:SetNWBool("IsRakghoul", rakghoul)
end

function PLAYER:IsRakghoul()
	return self:GetNWBool("IsRakghoul", false)
end

function PLAYER:IsTransforming()
	return timer.Exists("Rakghoul.Transforming_" .. self:SteamID64())
end

-- Replaces the rakghoul footstep
--
-- @param? Player ply
hook.Add("PlayerFootstep", "AOCRP.Rakghoul:Footstep", function(ply)
	if ply:IsRakghoul() then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/rakghoul/cl_rakghoul.lua:
AOCRP.Rakghoul = AOCRP.Rakghoul or {}

-- Makes the Screenspace effect
--
hook.Add( "RenderScreenspaceEffects", "AOCRP.Rakghoul:ScreenEffect", function()
	if LocalPlayer():IsRakghoul() then
		DrawSobel(0.08)
		DrawColorModify({
			["$pp_colour_addr"] = 0.02,
			["$pp_colour_addg"] = 0.02,
			["$pp_colour_addb"] = 0,
			["$pp_colour_brightness"] = 0.15,
			["$pp_colour_contrast"] = 1,
			["$pp_colour_colour"] = 3,
			["$pp_colour_mulr"] = 0,
			["$pp_colour_mulg"] = 0.02,
			["$pp_colour_mulb"] = 0})
		DrawMaterialOverlay("models/props_lab/xencrystal_sheet", 0.0001)
		DrawMotionBlur(0.1, 0.39, 0.05)
	end
end)

-- Creates a halo around all rakghouls
--
hook.Add("PreDrawHalos", "AOCRP.Rakghoul:ShowRakghouls", function()
	if not LocalPlayer():IsRakghoul() then return end

	local rakghouls = {}
	local rakghoulColor = Color(170, 15, 15)

	for _, ply in pairs(player.GetHumans()) do
		if ply == LocalPlayer() then continue end
		if ply:GetNW2Bool("CamoEnabled") then continue end

		if ply:IsRakghoul() or ply:IsTransforming() then
			table.insert(rakghouls, ply)
			continue
		end
	end

	halo.Add(rakghouls, rakghoulColor, 5, 5, 1, true, false)
end)
--gamemodes/starwarsrp/gamemode/modules/qim/cl_qim.lua:


AOCDerma:RegisterFont("QIM_Title", "Agency FB", 50, 1000)



-- Test Interaction
AOCRP.QIM = AOCRP.QIM or {}


AOCRP.QIM.BTNS = {}

AOCRP.QIM.BTNS["self"] = {
    
    { 
        title = "Squadmarker",
        runFunc = function() AOCRP.QIM:OpenBTNS("squadmarker") end,
        limitFunc = function() return AOCRP.Squad:InValidSquad(LocalPlayer()) end,
    },
    { 
        title = "Squadbefehle",
        runFunc = function() AOCRP.QIM:OpenBTNS("squadbefehle") end,
        limitFunc = function() return AOCRP.Squad:InValidSquad(LocalPlayer()) end,
    },
    { 
        title = "Squadfarbe",
        runFunc = function() AOCRP.QIM:OpenBTNS("squadteam") end,
        limitFunc = function() return AOCRP.Squad:InValidSquad(LocalPlayer()) end,
    },
    { 
        title = "Squadposition",
        runFunc = function() AOCRP.QIM:OpenBTNS("squadpos") end,
        limitFunc = function() return AOCRP.Squad:InValidSquad(LocalPlayer()) end,
    },
    { 
        title = "Gesten",
        runFunc = function() AOCRP.QIM:OpenBTNS("gestures") end,
        limitFunc = function() return true end,
    },

}




AOCRP.QIM.BTNS["otherplayer"] = {


{ 
    title = "Person befreien",
    runFunc = function(ent)

        net.Start( "Cuffs_FreePlayer" )
        net.WriteEntity( ent )
        net.SendToServer()
        AOCRP.QIM:FuckOff()
    end,
    limitFunc = function(ent) 
                    
        return ent:IsHandcuffed()
        
    end,
},

{ 
    title = "Ausrüstung abnehmen",
    runFunc = function(ent)

        net.Start( "AOCRP.QIM.CuffWeps" )
        net.WriteEntity( ent )
        net.SendToServer()
        AOCRP.QIM:FuckOff()
    end,
    limitFunc = function(ent) 
                    
        return ent:IsHandcuffed() and ent:GetNetVar("AOCRP_HasHisWeapons", nil) == nil
        
    end,
},

{ 
    title = "Ausrüstung zurückgeben",
    runFunc = function(ent)

        net.Start( "AOCRP.QIM.CuffWeps" )
        net.WriteEntity( ent )
        net.SendToServer()
        AOCRP.QIM:FuckOff()
    end,
    limitFunc = function(ent) 
                    
        return ent:GetNetVar("AOCRP_HasHisWeapons", nil) == LocalPlayer()
        
    end,
},

    { 
        title = "Person ziehen",
        runFunc = function(ent)
            local cuffed,cuff = ent:IsHandcuffed()
            net.Start( "Cuffs_DragPlayer" )
                net.WriteEntity( ent )
                net.WriteBit( LocalPlayer()~=cuff:GetKidnapper() )
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent) 

            
            if LocalPlayer():IsHandcuffed() then return false end
            if ! ent:IsHandcuffed() then return false end

            local cuffed,cuff = ent:IsHandcuffed()

            if !IsValid(cuff) then return false end


                        
            return cuff:GetRopeLength()>0 and !IsValid(cuff:GetKidnapper())
            
        end,
    },

    { 
        title = "Person nicht mehr ziehen",
        runFunc = function(ent)
            local cuffed,cuff = ent:IsHandcuffed()
            net.Start( "Cuffs_DragPlayer" )
                net.WriteEntity( ent )
                net.WriteBit( LocalPlayer()~=cuff:GetKidnapper() )
            net.SendToServer()

            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent) 

            
            if LocalPlayer():IsHandcuffed() then return false end
            if ! ent:IsHandcuffed() then return false end

            local cuffed,cuff = ent:IsHandcuffed()

            if !IsValid(cuff) then return false end


                        
            return cuff:GetRopeLength()>0 and IsValid(cuff:GetKidnapper()) and cuff:GetKidnapper() == LocalPlayer()
            
        end,
    },
    { 
        title = "In deine Einheit einladen",
        runFunc = function(ent) 
            net.Start("AOCRP.UnitMgmt.Invite")
            net.WriteEntity(ent)
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent)  
            local unit = AOCRP.Unit:GetData(LocalPlayer():GetUnitID())
            return LocalPlayer():GetRankID() >= unit.mininviterank
        end,
    },
    { 
        title = "Knebeln",
        runFunc = function(ent) LocalPlayer():ConCommand("say /gag "..ent:GetCloneID()) end,
        limitFunc = function(ent) return LocalPlayer():GetUnitID() == 8 and ent:GetGearID() == 328 end,
    },
    { 
        title = "Nerven",
        runFunc = function(ent) LocalPlayer():ConCommand("say /fickprisoner "..ent:GetCloneID()) end,
        limitFunc = function(ent) return LocalPlayer():GetUnitID() == 8 and ent:GetGearID() == 328 end,
    },
}

AOCRP.QIM.BTNS["squadpos"] = {}

for k, v in pairs(AOCRP.Config.SquadPos) do
    AOCRP.QIM.BTNS["squadpos"][#AOCRP.QIM.BTNS["squadpos"]+1] = { 
        title = v,
        runFunc = function()         
            net.Start("AOCRP.Squad.SetSquadPos")
            net.WriteString(k)
            net.SendToServer()
        end,
        limitFunc = function() return true end,
    }
end


AOCRP.QIM.BTNS["squadteam"] = {}

for k, v in pairs(AOCRP.Config.SquadTeams) do
    AOCRP.QIM.BTNS["squadteam"][#AOCRP.QIM.BTNS["squadteam"]+1] = { 
        title = v.name,
        runFunc = function()         
            net.Start("AOCRP.Squad.SetSquadTeam")
            net.WriteInt(k,5)
            net.SendToServer()
        end,
        limitFunc = function() return true end,
    }
end



AOCRP.QIM.BTNS["squadmarker"] = {}

for k, v in pairs(AOCRP.Config.SquadMarker) do
    AOCRP.QIM.BTNS["squadmarker"][#AOCRP.QIM.BTNS["squadmarker"]+1] = { 
        title = v.title,
        runFunc = function()         
            LocalPlayer():ConCommand("aocrp_squadmarker "..k)
        end,
        limitFunc = function() return true end,
    }
end


AOCRP.QIM.BTNS["squadbefehle"] = {}

for k, v in pairs(AOCRP.Config.SquadBefehleRadial) do
    AOCRP.QIM.BTNS["squadbefehle"][#AOCRP.QIM.BTNS["squadbefehle"]+1] = { 
        title = v.name,
        runFunc = v.func,
        limitFunc = function() return true end,
    }
end


AOCRP.QIM.BTNS["inLVS"] = {
    {
        title = "Starterlaubnis",
        runFunc = function(ent)

            AOCDerma:SmallStringRequest( "Grund für Starterlaubnis:", function(grund)
            
            
                net.Start("AOCRP_QIM_Vehicle_SetAnfrage")
                net.WriteEntity(ent)
                net.WriteString("Starterlaubnis, "..grund)
                net.SendToServer()
                AOCRP.QIM:FuckOff()

            end, "KAMPFEINSATZ" )

        end,
        limitFunc = function(ent)
            return true
        end,
    },
    {
        title = "Landerlaubnis",
        runFunc = function(ent)

            AOCDerma:SmallStringRequest( "Grund für Landerlaubnis:", function(grund)
            
            
                net.Start("AOCRP_QIM_Vehicle_SetAnfrage")
                net.WriteEntity(ent)
                net.WriteString("Landerlaubnis, "..grund)
                net.SendToServer()
                AOCRP.QIM:FuckOff()

            end, "Haupthangar" )

        end,
        limitFunc = function(ent)
            return true
        end,
    },
    {
        title = "Toröffnung",
        runFunc = function(ent)

            AOCDerma:SmallStringRequest( "Welches Tor:", function(grund)
            
            
                net.Start("AOCRP_QIM_Vehicle_SetAnfrage")
                net.WriteEntity(ent)
                net.WriteString("Toröffnung, "..grund)
                net.SendToServer()
                AOCRP.QIM:FuckOff()

            end, "Mainhangar" )

        end,
        limitFunc = function(ent)
            return true
        end,
    },
    {
        title = "Eigene Anfrage",
        runFunc = function(ent)

            AOCDerma:SmallStringRequest( "Anfrage:", function(grund)
            
            
                net.Start("AOCRP_QIM_Vehicle_SetAnfrage")
                net.WriteEntity(ent)
                net.WriteString(grund)
                net.SendToServer()
                AOCRP.QIM:FuckOff()

            end, "" )

        end,
        limitFunc = function(ent)
            return true
        end,
    },
    {
        title = "Aufschließen",
        runFunc = function(ent)
            net.Start("AOCRP_QIM_Vehicle_SetLock")
            net.WriteEntity(ent)
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent)
            return ent:GetlvsLockedStatus() and ent:GetNetVar("AOCRP_Owner") == LocalPlayer()
        end,
    },
    {
        title = "Abschließen",
        runFunc = function(ent)
            net.Start("AOCRP_QIM_Vehicle_SetLock")
            net.WriteEntity(ent)
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent)
            return not ent:GetlvsLockedStatus() and ent:GetNetVar("AOCRP_Owner") == LocalPlayer()
        end,
    },
}


AOCRP.QIM.BTNS["lvs_generic"] = {
    {
        title = "Aufschließen",
        runFunc = function(ent)
            net.Start("AOCRP_QIM_Vehicle_SetLock")
            net.WriteEntity(ent)
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent)
            return ent:GetlvsLockedStatus() and ent:GetNetVar("AOCRP_Owner") == LocalPlayer()
        end,
    },
    {
        title = "Abschließen",
        runFunc = function(ent)
            net.Start("AOCRP_QIM_Vehicle_SetLock")
            net.WriteEntity(ent)
            net.SendToServer()
            AOCRP.QIM:FuckOff()
        end,
        limitFunc = function(ent)
            return not ent:GetlvsLockedStatus() and ent:GetNetVar("AOCRP_Owner") == LocalPlayer()
        end,
    },
    {
        title = "Skinmenü",
        runFunc = function(ent)

            local skinOptions = {}

            for i = 0, ent:SkinCount()  do
                skinOptions[i] = {
                    title = "Skin "..i,
                    runFunc = function(ent)
                        net.Start("AOCRP_QIM_Vehicle_SetSkin")
                        net.WriteEntity(ent)
                        net.WriteInt(i-1,5)
                        net.SendToServer()
                        AOCRP.QIM:FuckOff()
                    end,
                    limitFunc = function(ent)
                        return ent:GetNetVar("AOCRP_Owner") == LocalPlayer()
                    end,
                }
            end

            AOCRP.QIM:OpenSubBTNS(skinOptions,ent)
        end,
        limitFunc = function(ent)
            return ent:GetNetVar("AOCRP_Owner") == LocalPlayer() and ent:SkinCount() > 1
        end,
    },



    
}





AOCRP.QIM.BTNS["gestures"] = {

    {
        title = "Winken",
        runFunc = function()
            RunConsoleCommand("act", "wave")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_wave")
        end,
    },
    {
        title = "Auslachen",
        runFunc = function()
            RunConsoleCommand("act", "laugh")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_laugh")
        end,
    },
    {
        title = "Zustimmen",
        runFunc = function()
            RunConsoleCommand("act", "agree")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_agree")
        end,
    },
    {
        title = "Salutieren",
        runFunc = function()
            RunConsoleCommand("act", "salute")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_salute")
        end,
    },
    {
        title = "Herbeirufen",
        runFunc = function()
            RunConsoleCommand("act", "becon")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_becon")
        end,
    },
    {
        title = "Verbeugen",
        runFunc = function()
            RunConsoleCommand("act", "bow")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_bow")
        end,
    },
    {
        title = "Gruppieren",
        runFunc = function()
            RunConsoleCommand("act", "group")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_group")
        end,
    },
    {
        title = "Tanzen",
        runFunc = function()
            RunConsoleCommand("act", "dance")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_dance")
        end,
    },
    {
        title = "Jubeln",
        runFunc = function()
            RunConsoleCommand("act", "cheer")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_cheer")
        end,
    },
    {
        title = "Robo-Tanz",
        runFunc = function()
            RunConsoleCommand("act", "robot")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_robot")
        end,
    },
    {
        title = "Vorwärts",
        runFunc = function()
            RunConsoleCommand("act", "forward")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_forward")
        end,
    },
    {
        title = "Zombie",
        runFunc = function()
            RunConsoleCommand("act", "zombie")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_zombie")
        end,
    },
    {
        title = "Nein",
        runFunc = function()
            RunConsoleCommand("act", "disagree")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_disagree")
        end,
    },
    {
        title = "Pers",
        runFunc = function()
            RunConsoleCommand("act", "pers")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_pers")
        end,
    },
    {
        title = "Halt",
        runFunc = function()
            RunConsoleCommand("act", "halt")
        end,
        limitFunc = function()
            return AOCRP.GTM:HasItem(LocalPlayer(), "act_halt")
        end,
    },



} 











function AOCRP.QIM:OpenBTNS(btns,traceEnt,first)
    if !ValidPanel(self.ButtonPanel) then return end
    if !AOCRP.QIM.BTNS[btns] then return end

    self.ButtonPanel:Clear()


--[[     if btns != "self" and first then
        local button = AOCDerma:Button(self.ButtonPanel, "Ich", function() AOCRP.QIM:OpenBTNS("self") end, "cb")
        button:Dock(TOP)
        button:DockMargin(0,0,0,AOCH(20))
    end ]]

    for k, v in ipairs(AOCRP.QIM.BTNS[btns]) do
        if v.limitFunc(traceEnt) then
            local button = AOCDerma:Button(self.ButtonPanel, v.title, function() v.runFunc(traceEnt) end, "cb")
            button:Dock(TOP)
            button:DockMargin(0,0,0,AOCH(20))
        end
    end
end

function AOCRP.QIM:OpenSubBTNS(btns,traceEnt)
    if !ValidPanel(self.ButtonPanel) then return end
    if !istable(btns) then return end

    self.ButtonPanel:Clear()


    for k, v in ipairs(btns) do
        if v.limitFunc(traceEnt) then
            local button = AOCDerma:Button(self.ButtonPanel, v.title, function() v.runFunc(traceEnt) end, "cb")
            button:Dock(TOP)
            button:DockMargin(0,0,0,AOCH(20))
        end
    end
end

function AOCRP.QIM:FuckOff()
    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
end

function AOCRP.QIM:OpenMenu()
    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    gui.EnableScreenClicker(true)

    input.SetCursorPos( AOCW(960), AOCH(250) )

    self.FRAME = vgui.Create("DPanel")
    self.FRAME:SetSize(ScrW(),ScrH())
    self.FRAME:Center()
    --self.FRAME:SetSizable(false)
    --self.FRAME:SetDraggable(false)

    function self.FRAME:OnRemove()
        gui.EnableScreenClicker(false)
    end
    function self.FRAME:Paint(w,h)

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,50))
        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)

        AOCDerma:DrawTextShadow("SCHNELLINTERAKTION", AOCDerma:Font("QIM_Title"), ScrW() / 2, AOCH(150), Color(255,255,255), TEXT_ALIGN_CENTER)
    end


    self.ButtonPanel = AOCDerma:ScrollBar(self.FRAME) 
    self.ButtonPanel:Dock(FILL)
    self.ButtonPanel:DockMargin(AOCW(700),AOCH(230),AOCW(700),AOCH(50))
    self.ButtonPanel:SetPaintBackground(false)


    local eyeTrace = LocalPlayer():GetEyeTraceNoCursor()

    if LocalPlayer():InVehicle() then 
        local veh = LocalPlayer():GetVehicle()
        if IsValid(veh:GetParent()) then
            AOCRP.QIM:OpenBTNS("inLVS", veh:GetParent())
            return
        end
    end 

    if IsValid(eyeTrace.Entity) then
        if AOCRP.QIM.BTNS[eyeTrace.Entity:GetClass()] then
            AOCRP.QIM:OpenBTNS(eyeTrace.Entity:GetClass(), eyeTrace.Entity,true)
            return
        end
        if eyeTrace.Entity:GetNetVar("AOCRP.QIM.Menu", "" ) != "" then
            AOCRP.QIM:OpenBTNS(eyeTrace.Entity:GetNetVar("AOCRP.QIM.Menu", "" ), eyeTrace.Entity,true)
            return
        end
        if eyeTrace.Entity:IsPlayer() then
            AOCRP.QIM:OpenBTNS("otherplayer", eyeTrace.Entity,true)
            return
        end
    end


    AOCRP.QIM:OpenBTNS("self")

end

--gamemodes/starwarsrp/gamemode/modules/main/cl_loading.lua:
AOCRP.ClientLoad = AOCRP.ClientLoad or {}

AOCRP.ClientLoad.Queue = {}



function AOCRP.ClientLoad:AddLoad(id, txt, datafunc, data)
    local len = #self.Queue 
    self.Queue[len+1] = {}
    self.Queue[len+1].id = id 
    self.Queue[len+1].text = txt
    self.Queue[len+1].func = datafunc
    self.Queue[len+1].data = data or {}
end



function AOCRP.ClientLoad:DoNextLoad()
    if #self.Queue > 0 then

        local loadData = self.Queue[1]
        if ValidPanel(self.LoadingScreen) then 
            self.LoadingScreen.text = loadData.text 
        end

        local time = CurTime()
        print("[AOCRP] "..loadData.text )

        AOCRP.API:Request(loadData.id, function(data) 

            loadData.func(data)

            print("[AOCRP] Fertig! Dauer: "..CurTime()-time.."s")
            table.remove(AOCRP.ClientLoad.Queue, 1)

 
            AOCRP.ClientLoad:DoNextLoad()


        end, loadData.data, 
        function(err) 
            print(err) 
        end)


    else 
        if ValidPanel(self.LoadingScreen) then self.LoadingScreen:Remove() end
    end 
end


function AOCRP.ClientLoad:StartLoad()
    if #self.Queue > 0 then
        if ValidPanel(self.LoadingScreen) then self.LoadingScreen:Remove() end
        self.LoadingScreen = AOCDerma:CreateLoadingScreen("Spielinhalte werden vorbereitet")

        self:DoNextLoad()
    end
end

--gamemodes/starwarsrp/gamemode/modules/jail/sh_jail.lua:
--


if SERVER then 

    AOCRP.Jail = {}

    AOCRP.Jail.Inmates = {}




    function AOCRP.Jail:NearJailMarker(ply)

        for k, v in ipairs( ents.FindByClass( "aoc_jailmarker" ) ) do
            if ply:GetPos():DistToSqr(v:GetPos()) < 500*500 then 
                return true
            end 
         end
         return false
    end

    function AOCRP.Jail:UnJail(target, jailer)

        
        local targetEnt = AOCRP.Chat:FindPlayer(target)

        if !IsValid(targetEnt) then 
            jailer:ChatPrint(Color(255,0,0),"*** Es wurde kein gültiges Ziel gefunden.")
            return
        end

        if !targetEnt.AOCRP_InJail then
            jailer:ChatPrint(Color(255,0,0),"*** Diese Person ist nicht inhaftiert.")
            return
        end

        AOCRP.CharSys:UpdateCharacter(targetEnt:GetCloneID(), "jailtime", 0)
        AOCRP.CharSys:UpdateCharacter(targetEnt:GetCloneID(), "jailreason", "")

        targetEnt.AOCRP_JailTime = 0
        targetEnt.AOCRP_JailReason = ""

        targetEnt:KillSilent()
        targetEnt:Spawn()
    end 

    function AOCRP.Jail:SendToJail(target, time, reason, jailer)

        local targetEnt = AOCRP.Chat:FindPlayer(target)

        if !IsValid(targetEnt) then 
            jailer:ChatPrint(Color(255,0,0),"*** Es wurde kein gültiges Ziel gefunden.")
            return
        end

        if !AOCRP.Jail:NearJailMarker(targetEnt) then jailer:ChatPrint("Dein Ziel ist nicht in der Nähe eines Gefängnisses") return end

        AOCRP.CharSys:CharLogEntry(targetEnt:GetCloneID(), "Soldat wurde für "..time.." Minuten von "..jailer:Name().." inhaftiert. Grund:"..reason)

        AOCRP.CharSys:UpdateCharacter(targetEnt:GetCloneID(), "jailtime", time)
        AOCRP.CharSys:UpdateCharacter(targetEnt:GetCloneID(), "jailreason", reason .. " - Durch: "..jailer:Name())

        targetEnt.AOCRP_JailTime = time
        targetEnt.AOCRP_JailReason = reason .. " - Durch: "..jailer:Name()

        jailer:ConCommand("say /funk ST Ich habe "..targetEnt:Name().." für "..time.." Minuten inhaftiert - Grund: "..reason)

        targetEnt:KillSilent()
        targetEnt:Spawn()

    
    end


    function AOCRP.Jail:JailBan(target, time, reason, jailer)

        local targetEnt = target


        AOCRP.Player:UpdatePlayerVar(targetEnt:SteamID64(), "jailtime", time)
        AOCRP.Player:UpdatePlayerVar(targetEnt:SteamID64(), "jailreason", "JailBan | " .. reason .. " - Durch: "..jailer:Name())
        targetEnt.AOCRP_JailBanTime = time
        targetEnt.AOCRP_JailBanReason = "JailBan | " .. reason .. " - Durch: "..jailer:Name()


        targetEnt:KillSilent()
        targetEnt:Spawn()

    
    end

    function AOCRP.Jail:OnPlayerSpawn(ply)

        if ply.AOCRP_JailTime then 
            if ply.AOCRP_JailTime > 0 then
                ply.AOCRP_InJail = true
                ply:SetNetVar("AOCRP_InJail", true)

                ply:SetGearID(328)
                ply:ApplyGear()


                ply:ChatPrint("*** Du bist im Gefägnis inhaftiert für "..ply.AOCRP_JailTime.. " Minuten. Grund: "..ply.AOCRP_JailReason)
                ply:ChatPrint("*** Alle deine Ausrüstungegenstände wurden dir abgenommen und du kannst dein Comlink nicht nutzen.")

                local jails = ents.FindByClass( "aoc_jailmarker" ) 

                if #jails > 0 then

                    local randomJail = jails[math.random(#jails)]

                    ply:SetPos(randomJail:GetPos())
                else 
                    ply:Kick("Du kannst auf dieser Map leider nicht deine Haftstrafe absitzen!")
                end
            end
        end 

        if ply.AOCRP_JailBanTime then 
            if ply.AOCRP_JailBanTime > 0 then
                ply.AOCRP_InJailBan = true
                ply:SetNetVar("AOCRP_InJail", true)

                ply:SetGearID(328)
                ply:ApplyGear()

                ply:sam_set_pdata("unmute_time", 0)

                ply:ChatPrint("*** Du bist im Gefägnis inhaftiert für "..ply.AOCRP_JailBanTime.. " Minuten. Grund: "..ply.AOCRP_JailBanReason)
                ply:ChatPrint("*** Alle deine Ausrüstungegenstände wurden dir abgenommen und du kannst dein Comlink nicht nutzen.")

                local jails = ents.FindByClass( "aoc_jailmarker" ) 

                if #jails > 0 then

                    local randomJail = jails[math.random(#jails)]

                    ply:SetPos(randomJail:GetPos())
                else 
                    ply:Kick("Du kannst auf dieser Map leider nicht deine Haftstrafe absitzen!")
                end
            end
        end 
    end


    if !timer.Exists("AOCRP.JailTimer") then
        timer.Remove("AOCRP.JailTimer") 

    end 
	    timer.Create( "AOCRP.JailTimer", 60, 0, function() 

            for k, v in pairs(player.GetHumans()) do
                if v.AOCRP_InJail then
                    
                    if v.AOCRP_JailTime > 0 then 
                        AOCRP.CharSys:UpdateCharacter(v:GetCloneID(), "jailtime", v.AOCRP_JailTime - 1, function(id,var,val) 
                            v.AOCRP_JailTime = val 
                            v:ChatPrint("*** Du hast eine weitere Minute deiner Haftzeit abgesessen! Verbliebend: "..val.." Minuten.")
                        end)

                        if PRS.OnlinePlayerNum >= 85 then 
                            v:Kick("Der Server wird voll, Häftlinge müssen erstmal draußen bleiben.")
                        end
                        
                    else 
                        v:ChatPrint("*** Du bist nun ein freier Mann.")
                        v.AOCRP_InJail = false
                        v:SetNetVar("AOCRP_InJail", false)

                        if !AOCRP.Jail:NearJailMarker(v) then return end
                        v:SetCloneID(0)
                        v:KillSilent()
                        v:Spawn()
                    end 

                end


                if v.AOCRP_InJailBan then
                    
                    if v.AOCRP_JailBanTime > 0 then 

                        AOCRP.Player:UpdatePlayerVar(v:SteamID64(), "jailtime", v.AOCRP_JailBanTime - 1, function(id,var,val)
                            v.AOCRP_JailBanTime = val 
                            v:ChatPrint("*** Du hast eine weitere Minute deiner Haftzeit abgesessen! Verbliebend: "..val.." Minuten.")
                        end)

     --[[                    AOCRP.CharSys:UpdateCharacter(v:GetCloneID(), "jailtime", v.AOCRP_JailBanTime - 1, function(id,var,val) 
                            v.AOCRP_JailBanTime = val 
                            v:ChatPrint("*** Du hast eine weitere Minute deiner Haftzeit abgesessen! Verbliebend: "..val.." Minuten.")
                        end)
 ]]
                        if PRS.OnlinePlayerNum >= 85 then 
                            v:Kick("Der Server wird voll, Häftlinge müssen erstmal draußen bleiben.")
                        end
                        
                    else 
                        v:ChatPrint("*** Du bist nun ein freier Mann.")
                        v.AOCRP_InJailBan = false
                        v:SetNetVar("AOCRP_InJail", false)

                        if !AOCRP.Jail:NearJailMarker(v) then return end
                        v:sam_set_pdata("unmute_time", nil)
                        v:SetCloneID(0)
                        v:KillSilent()
                        v:Spawn()
                    end 

                end
            end
        end )
 

end
--gamemodes/starwarsrp/gamemode/modules/gui/cl_weaponselector.lua:
--[[ Config ]]--

local MAX_SLOTS = 9	 -- Max number of weapon slots. Expects Integer [0, inf)
local CACHE_TIME = 1 -- Time in seconds between updating the weapon cache. RealTime is used for comparisons. Expects Decimal [0, inf]. 0 = update every frame, inf = never update
local MOVE_SOUND = "everfall/miscellaneous/ux/navigation/navigation_tab_01.mp3" -- Sound to play when the player moves between weapon slots. Expects String soundscape or sound file path. "" = no sound
local SELECT_SOUND = "everfall/miscellaneous/ux/navigation/navigation_weaponmodify_01_01.mp3" -- Sound to play when the player selects a weapon. Expects String soundscape or sound file path. "" = no sound
local CANCEL_SOUND = "everfall/miscellaneous/ux/navigation/navigation_error_01.mp3" -- Sound to play when the player cancels the weapon selection. Expects String soundscape or sound file path. "" = no sound

--[[ Instance variables - do not edit ]]--

local iCurSlot = 0 -- Currently selected slot. Will be an Integer [0, MAX_SLOTS]. 0 = no selection
local iCurPos = 1 -- Current position in that slot. Will be an Integer [0, inf)
local flNextPrecache = 0 -- Time until next precache. Will be a Decimal [0, inf) representing a RealTime
local flSelectTime = 0 -- Time the weapon selection changed slot/visibility states. Can be used to close the weapon selector after a certain amount of idle time. Will be a Decimal [0, inf) representing a RealTime
local iWeaponCount = 0 -- Total number of weapons on the player. Will be an Integer [0, inf)
    
-- Weapon cache; table of tables. tCache[Weapon:GetSlot() + 1] or tCacheLength[iCurSlot] contains a table containing that slot's weapons. The table's length is tCacheLength[Slot + 1]
local tCache = {}

-- Weapon cache length. tCacheLength[Weapon:GetSlot() + 1] or tCacheLength[iCurSlot] will contain the number of weapons that slot has
local tCacheLength = {}

--[[ Weapon switcher ]]--

--[[ Guarentees when this function is called:
	- cl_drawhud != 0
	- iCurSlot >= 1
	- 1 <= iCurPos <= tCacheLength[iCurSlot]
	- iWeaponCount >= 1
	- LocalPlayer():IsValid()
	- LocalPlayer():Alive()
	- not LocalPlayer():InVehicle() or LocalPlayer():GetAllowWeaponsInVehicle()
]]

local startpos = AOCW(650)

AOCDerma:RegisterFont("WeaponSelect_AOCRP", "Aurebesh", 40, 10)
AOCDerma:RegisterFont("WeaponSelect_AOCRP_Weapon", "Agency FB", 50, 5000)

local downPos = 10

local function DrawWeaponHUD()
    LastWeaponHUD = CurTime() + 0.01

	for i = 1, MAX_SLOTS do
        if i == iCurSlot then
		    AOCDerma:DrawTextShadow(i, AOCDerma:Font("WeaponSelect_AOCRP"), startpos + AOCW(60) * i, AOCH(5), color_white, TEXT_ALIGN_LEFT)
        else
            AOCDerma:DrawTextShadow(i, AOCDerma:Font("WeaponSelect_AOCRP"), startpos + AOCW(60) * i, AOCH(5), Color(255,255,255,100), TEXT_ALIGN_LEFT)
        end
	end

	local tWeapons = tCache[iCurSlot]

    draw.RoundedBox(0, startpos+AOCW(40), AOCH(45), AOCW(60) * MAX_SLOTS, AOCH(2), Color(255,255,255,100))

	for i = 1, tCacheLength[iCurSlot] do
		if !IsValid(tWeapons[i]) then return end 
        if i == iCurPos then
		    AOCDerma:DrawTextShadow(tWeapons[i]:GetPrintName(), AOCDerma:Font("WeaponSelect_AOCRP_Weapon"), ScrW()/2, AOCH(50) * i, color_white, TEXT_ALIGN_CENTER)
        else
            AOCDerma:DrawTextShadow(tWeapons[i]:GetPrintName(), AOCDerma:Font("WeaponSelect_AOCRP_Weapon"), ScrW()/2, AOCH(50) * i, Color(78,78,78), TEXT_ALIGN_CENTER)
        end
	end

	--draw.SimpleText("> ", "DermaDefault", startpos + 50 * iCurSlot, downPos + 12 * iCurPos, color_white, TEXT_ALIGN1_RIGHT, TEXT_ALIGN_CENTER)
end

--[[ Implementation - do not edit ]]--

-- Initialize tables with slot number
for i = 1, MAX_SLOTS do
	tCache[i] = {}
	tCacheLength[i] = 0
end

local tonumber = tonumber
local RealTime = RealTime
local hook_Add = hook.Add
local math_floor = math.floor
local string_sub = string.sub
local LocalPlayer = LocalPlayer
local string_lower = string.lower
local input_SelectWeapon = input.SelectWeapon

local function PrecacheWeps()
	-- Reset all table values
	for i = 1, MAX_SLOTS do
		for j = 1, tCacheLength[i] do
			tCache[i][j] = nil
		end

		tCacheLength[i] = 0
	end

	-- Update the cache time
	flNextPrecache = RealTime() + CACHE_TIME

	local tWeapons = LocalPlayer():GetWeapons()
	iWeaponCount = #tWeapons

	if (iWeaponCount == 0) then
		iCurSlot = 0
		iCurPos = 1
	else
		for i = 1, iWeaponCount do
			local pWeapon = tWeapons[i]

			-- Weapon slots start internally at 0
			-- Here, we will start at 1 to match the slot binds
			local iSlot = pWeapon:GetSlot() + 1

			if (iSlot <= MAX_SLOTS) then
				-- Cache number of weapons in each slot
				local iLen = tCacheLength[iSlot] + 1
				tCacheLength[iSlot] = iLen
				tCache[iSlot][iLen] = pWeapon
			end
		end
	end

	-- Make sure we're not pointing out of bounds
	if (iCurSlot ~= 0) then
		local iLen = tCacheLength[iCurSlot]

		if (iLen == 0) then
			iCurSlot = 0
			iCurPos = 1
		elseif (iCurPos > iLen) then
			iCurPos = iLen
		end
	end
end

local function CheckBounds()
	if (iCurSlot < 0 or iCurSlot > MAX_SLOTS) then
		iCurSlot = 0
	else
		iCurSlot = math_floor(iCurSlot)
	end

	if (iCurPos < 1) then
		iCurPos = 1
	else
		iCurPos = math_floor(iCurPos)
	end

	if (iWeaponCount < 0) then
		iWeaponCount = 0
	else
		iWeaponCount = math_floor(iWeaponCount)
	end
end

local cl_drawhud = GetConVar("cl_drawhud")

hook_Add("HUDPaint", "GS_WeaponSelector", function()
	if (not cl_drawhud:GetBool()) then
		return
	end

	CheckBounds()

	if (iCurSlot == 0) then
		return
	end

	local pPlayer = LocalPlayer()

	if WeaponSelect_LastBindPressed then
		if WeaponSelect_LastBindPressed < CurTime() then
			iCurSlot = 0
			iCurPos = 1
		end
	end

	-- Don't draw in vehicles unless weapons are allowed to be used
	-- Or while dead!
	if (pPlayer:IsValid() and pPlayer:Alive() and (not pPlayer:InVehicle() or pPlayer:GetAllowWeaponsInVehicle())) then
		if (flNextPrecache <= RealTime()) then
			PrecacheWeps()
		end

		if (iCurSlot ~= 0) then
			DrawWeaponHUD()
		end
	else
		iCurSlot = 0
		iCurPos = 1
	end
end)

hook_Add("PlayerBindPress", "GS_WeaponSelector", function(pPlayer, sBind, bPressed)
	if (not pPlayer:Alive() or pPlayer:InVehicle() and not pPlayer:GetAllowWeaponsInVehicle()) then
		return
	end

	WeaponSelect_LastBindPressed = CurTime() + 2

	sBind = string_lower(sBind)

	-- Last weapon switch
	if (sBind == "lastinv") then
		if (bPressed) then
			local pLastWeapon = pPlayer:GetPreviousWeapon()

			if (pLastWeapon:IsWeapon()) then
				input_SelectWeapon(pLastWeapon)
			end
		end

		return true
	end

	-- Close the menu
	if (sBind == "cancelselect") then
		if (bPressed and iCurSlot ~= 0) then
			iCurSlot = 0
			iCurPos = 1

			flSelectTime = RealTime()
			pPlayer:EmitSound(CANCEL_SOUND)
		end

		return true
	end

	-- Move to the weapon before the current
	if (sBind == "invprev") then
		if (not bPressed) then
			return true
		end
		

		CheckBounds()
		PrecacheWeps()

		if (iWeaponCount == 0) then
			return true
		end

		local bLoop = iCurSlot == 0

		if (bLoop) then
			local pActiveWeapon = pPlayer:GetActiveWeapon()



			if (pActiveWeapon:IsValid()) then

				if pActiveWeapon:GetClass() == "weapon_physgun" then
					return true
				end
				
				local iSlot = pActiveWeapon:GetSlot() + 1
				local tSlotCache = tCache[iSlot]

				if (tSlotCache[1] ~= pActiveWeapon) then
					iCurSlot = iSlot
					iCurPos = 1

					for i = 2, tCacheLength[iSlot] do
						if (tSlotCache[i] == pActiveWeapon) then
							iCurPos = i - 1

							break
						end
					end

					flSelectTime = RealTime()
					pPlayer:EmitSound(MOVE_SOUND)

					return true
				end

				iCurSlot = iSlot
			end
		end

		if (bLoop or iCurPos == 1) then
			repeat
				if (iCurSlot <= 1) then
					iCurSlot = MAX_SLOTS
				else
					iCurSlot = iCurSlot - 1
				end
			until(tCacheLength[iCurSlot] ~= 0)

			iCurPos = tCacheLength[iCurSlot]
		else
			iCurPos = iCurPos - 1
		end

		flSelectTime = RealTime()
		pPlayer:EmitSound(MOVE_SOUND)

		return true
	end

	-- Move to the weapon after the current
	if (sBind == "invnext") then
		if (not bPressed) then
			return true
		end

		CheckBounds()
		PrecacheWeps()

		-- Block the action if there aren't any weapons available
		if (iWeaponCount == 0) then
			return true
		end

		-- Lua's goto can't jump between child scopes
		local bLoop = iCurSlot == 0

		-- Weapon selection isn't currently open, move based on the active weapon's position
		if (bLoop) then
			local pActiveWeapon = pPlayer:GetActiveWeapon()


			if (pActiveWeapon:IsValid()) then

				if pActiveWeapon:GetClass() == "weapon_physgun" then
					return true
				end

				local iSlot = pActiveWeapon:GetSlot() + 1
				local iLen = tCacheLength[iSlot]
				local tSlotCache = tCache[iSlot]

				if (tSlotCache[iLen] ~= pActiveWeapon) then
					iCurSlot = iSlot
					iCurPos = 1

					for i = 1, iLen - 1 do
						if (tSlotCache[i] == pActiveWeapon) then
							iCurPos = i + 1

							break
						end
					end

					flSelectTime = RealTime()
					pPlayer:EmitSound(MOVE_SOUND)

					return true
				end

				-- At the end of a slot, move to the next one
				iCurSlot = iSlot
			end
		end

		if (bLoop or iCurPos == tCacheLength[iCurSlot]) then
			-- Loop through the slots until one has weapons
			repeat
				if (iCurSlot == MAX_SLOTS) then
					iCurSlot = 1
				else
					iCurSlot = iCurSlot + 1
				end
			until(tCacheLength[iCurSlot] ~= 0)

			-- Start at the beginning of the new slot
			iCurPos = 1
		else
			-- Bump up the position
			iCurPos = iCurPos + 1
		end

		flSelectTime = RealTime()
		pPlayer:EmitSound(MOVE_SOUND)

		return true
	end

	-- Keys 1-6
	if (string_sub(sBind, 1, 4) == "slot") then
		local iSlot = tonumber(string_sub(sBind, 5))

		-- If the command is slot#, use it for the weapon HUD
		-- Otherwise, let it pass through to prevent false positives
		if (iSlot == nil) then
			return
		end

		if (not bPressed) then
			return true
		end

		CheckBounds()
		PrecacheWeps()

		-- Play a sound even if there aren't any weapons in that slot for "haptic" (really auditory) feedback
		if (iWeaponCount == 0) then
			pPlayer:EmitSound(MOVE_SOUND)

			return true
		end

		-- If the slot number is in the bounds
		if (iSlot <= MAX_SLOTS) then
			-- If the slot is already open
			if (iSlot == iCurSlot) then
				-- Start back at the beginning
				if (iCurPos == tCacheLength[iCurSlot]) then
					iCurPos = 1
				-- Move one up
				else
					iCurPos = iCurPos + 1
				end
			-- If there are weapons in this slot, display them
			elseif (tCacheLength[iSlot] ~= 0) then
				iCurSlot = iSlot
				iCurPos = 1
			end

			flSelectTime = RealTime()
			pPlayer:EmitSound(MOVE_SOUND)
		end

		--return true
	end

	-- If the weapon selection is currently open
	if (iCurSlot ~= 0) then
		if (sBind == "+attack") then
			-- Hide the selection
			local pWeapon = tCache[iCurSlot][iCurPos]
			iCurSlot = 0
			iCurPos = 1

			-- If the weapon still exists and isn't the player's active weapon
			if (pWeapon:IsValid() and pWeapon ~= pPlayer:GetActiveWeapon()) then
				input_SelectWeapon(pWeapon)
			end

			flSelectTime = RealTime()
			pPlayer:EmitSound("everfall/miscellaneous/ux/navigation/navigation_carousel_01.mp3")

			return true
		end

		-- Another shortcut for closing the selection
		if (sBind == "+attack2") then
			flSelectTime = RealTime()
			pPlayer:EmitSound(CANCEL_SOUND)

			iCurSlot = 0
			iCurPos = 1

			return true
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/gui/cl_derma_radial.lua:
AOCDerma = AOCDerma or {}

AOCDermaRMenu_MouseAng = 0
AOCDermaRMenu_MouseRad = 0

local fontf = "Bahnschrift"

surface.CreateFont( "arc_radial_binds_16", {
    font = fontf,
    size = ScreenScale(16),
    weight = 0,
    antialias = true,
    extended = true, -- Required for non-latin fonts
} )

surface.CreateFont( "arc_radial_binds_16_shadow", {
    font = fontf,
    size = ScreenScale(16),
    blursize = 5,
    weight = 0,
    antialias = true,
    extended = true, -- Required for non-latin fonts
} )

local function RadiusSpoke(x, y, angle, rad)
    x = x + (math.cos(angle) * rad)
    y = y + (math.sin(angle) * rad)

    return x, y
end



hook.Add("InputMouseApply", "ArcticRadialBinds_Mouse", function(cmd, x, y, ang)
    if !ValidPanel(AOCDerma.RMenu) then return end

    if math.abs(x) + math.abs(y) <= 0 then return end

    cmd:SetMouseX( 0 )
    cmd:SetMouseY( 0 )

    local mousex = math.cos(math.rad(AOCDermaRMenu_MouseAng)) * AOCDermaRMenu_MouseRad
    local mousey = math.sin(math.rad(AOCDermaRMenu_MouseAng)) * AOCDermaRMenu_MouseRad

    mousex = mousex + x
    mousey = mousey + y

    local newang = math.deg(math.atan2(mousey, mousex))
    local newrad = math.sqrt(math.pow(mousex, 2) + math.pow(mousey, 2))


    newrad = math.min(newrad, ScreenScale(100))

    AOCDermaRMenu_MouseRad = newrad
    AOCDermaRMenu_MouseAng = newang


    return true
end)





local TestMenu = {}

TestMenu[1] = {
    name = "Sammeln",
    func = function() LocalPlayer():ChatPrint("penis") end,
}
TestMenu[2] = {
    name = "Test12",
    func = function() end,
}
TestMenu[3] = {
    name = "T21312",
    func = function() end,
}

function AOCDerma:RadialMenu(data)
    if ValidPanel(self.RMenu) then self.RMenu:Remove() end

    self.RMenu = vgui.Create("DPanel")
    self.RMenu:SetSize(ScrW(),ScrH())
    self.RMenu:Center()
    --self.RMenu:SetTitle("")

    local mat_ring = Material("sgm/playercircle")
    local segmentfadetime = 0.25
    local fadetime = 0.1

    function self.RMenu:OnRemove()
        if data[self.SELECTION] then
            data[self.SELECTION].func()
        end
    end

    function self.RMenu:Paint(w,h)
        local ss = ScreenScale(1)

        local col_fg = Color(255, 255, 255, 255)
        local col_fg_h = Color(25, 25, 25, 255)
    
        local segments = table.Count(data)
    
        local x = ScrW() / 2
        local y = ScrH() / 2
    
        local rad = ss * 100
    
        if segments > 0 then
            -- draw each segment
            local arc = 360 / segments
    
            for i = 1, segments do
                local angle = (i * arc) - 90
    
                local d = (AOCDermaRMenu_MouseAng - angle + 180 + 360) % 360 - 180
                d = math.abs(d)
    
                local selected = d <= arc / 2
    
                if AOCDermaRMenu_MouseRad == 0 then
                    selected = false
                end
    
                if !data[i] then continue end
    
                data[i].SegmentFade = data[i].SegmentFade or 0
    
                local size = rad * (1 + (data[i].SegmentFade * 0.1))
    
                local inf_x, inf_y = RadiusSpoke(x, y, math.rad(angle), size)
    
                if selected then
                    self.SELECTION = i
                    data[i].SegmentFade = math.Approach(data[i].SegmentFade, 1, FrameTime() / segmentfadetime)
                else
                    data[i].SegmentFade = math.Approach(data[i].SegmentFade, 0, FrameTime() / segmentfadetime)
                end
    
                surface.SetFont("arc_radial_binds_16")
                local inf_w, inf_h = surface.GetTextSize(data[i].name)
    
                local tb_w = inf_w + (ss * 4)
    
                if selected then
                    surface.SetDrawColor(255, 255, 255, 255 * 0.5)
                else
                    surface.SetDrawColor(0, 0, 0, 255 * 0.8)
                end
                surface.DrawRect(inf_x - (tb_w / 2), inf_y - (ss * 0.5), tb_w, inf_h + (ss * 1))
    
                surface.SetTextColor(0, 0, 0, a)
                surface.SetFont("arc_radial_binds_16_shadow")
                surface.SetTextPos(inf_x - (inf_w / 2), inf_y)
                surface.DrawText(data[i].name)
    
                if selected then
                    surface.SetTextColor(col_fg_h)
                else
                    surface.SetTextColor(col_fg)
                end
                surface.SetFont("arc_radial_binds_16")
                surface.SetTextPos(inf_x - (inf_w / 2), inf_y)
                surface.DrawText(data[i].name)
            end
        end
    
        local pick_x, pick_y = RadiusSpoke(x, y, math.rad(AOCDermaRMenu_MouseAng), AOCDermaRMenu_MouseRad)
        local pick_s = ss * 8
        surface.SetMaterial(mat_ring)
        surface.SetDrawColor(255, 255, 255, a)
        surface.DrawTexturedRect(pick_x - (pick_s / 2), pick_y - (pick_s / 2), pick_s, pick_s)
    end
end

--gamemodes/starwarsrp/gamemode/modules/gamemec/sh_weaponbox.lua:
AOCRP.Waffenkiste = AOCRP.Waffenkiste or {}


if SERVER then
    
    util.AddNetworkString("AOCRP.Waffenkiste.Action")
    net.Receive( "AOCRP.Waffenkiste.Action", function( len, ply )
        local take = net.ReadBool()
        local weapon = net.ReadString()

        local wepTbl = ply:GetGearTable().weaponbox

        if table.HasValue(wepTbl, weapon) then
            if take then
                ply:StripWeapon(weapon)
            else
                ply:Give(weapon)
            end
        end
    end)

end

if CLIENT then
    function AOCRP.Waffenkiste:Open()

        if ValidPanel(AOCWaffenKisteFrame) then AOCWaffenKisteFrame:Remove() end
        AOCWaffenKisteFrame = AOCDerma:DefaultFrame()
        AOCWaffenKisteFrame:SetSize(AOCW(800),AOCH(1000))
        AOCWaffenKisteFrame:Center()
        AOCWaffenKisteFrame:SetNewTitle("Waffenkiste")
        AOCWaffenKisteFrame:SetSizable(false)
        AOCWaffenKisteFrame:SetDraggable(false)

        local content = AOCDerma:ScrollBar(AOCWaffenKisteFrame) 
        content:Dock(FILL)


        for k, v in pairs(LocalPlayer():GetGearTable().weaponbox) do

            local text = v
            
            local wepTbl = weapons.Get( v )

            if istable(wepTbl) then
                text = wepTbl.PrintName
            end

                
                
                local btn = AOCDerma:Button(content, text, function() 

                    if LocalPlayer():HasWeapon(v) then
                        net.Start( "AOCRP.Waffenkiste.Action" )
                        net.WriteBool(true)
                        net.WriteString(v)
                        net.SendToServer()
                    else
                        net.Start( "AOCRP.Waffenkiste.Action" )
                        net.WriteBool(false)
                        net.WriteString(v)
                        net.SendToServer()      
                    end
                end, "bl")

                btn:Dock(TOP)
                btn:DockMargin(5,10,5,0)

                function btn:Think() 
                     if LocalPlayer():HasWeapon(v) then
                        self.akzent = Color(0,200,0)
                        self.akzenthover = Color(0,255,0,255)
                     else
                        self.akzent = Color(200,0,0)
                        self.akzenthover = Color(255,0,0,255)
                     end
                end
                



        end  
    end
end
--gamemodes/starwarsrp/gamemode/modules/chat/sh_chat.lua:
AOCRP.Chat = AOCRP.Chat or {}


if ( CLIENT ) then
    function AOCRP.Chat:AddText(...)
        chat.AddText( ... )
    end 
end   

if ( SERVER ) then
	util.AddNetworkString( "AOCRP.Chat.ChatPrint" )
end

if ( CLIENT ) then
	net.Receive( "AOCRP.Chat.ChatPrint", function()
		local parts = {}

		for _ = 1, net.ReadUInt( 16 ) do
			parts[ #parts + 1 ] = net.ReadType()
		end

		AOCRP.Chat:AddText(unpack(parts))
	end )
end

function WriteChatParts( ... )
	local parts = { ... }

	net.WriteUInt( #parts, 16 )

	for i = 1, #parts do
		net.WriteType( parts[i] )
	end
end


	function ChatPrint( ... )
        if SERVER then
            net.Start( "AOCRP.Chat.ChatPrint" )
                WriteChatParts( ... )
            net.Broadcast()
        else 
            AOCRP.Chat:AddText( ... )
        end
	end


local PLAYER = FindMetaTable( "Player" )

-- Prints a colored message to the chat box of the given player
-- from the client or server.
function PLAYER:ChatPrint( ... )
	if ( CLIENT ) then
		if ( self == LocalPlayer() ) then
			AOCRP.Chat:AddText( ... )
		end
	else
		net.Start( "AOCRP.Chat.ChatPrint" )
			WriteChatParts( ... )
		net.Send( self )
	end
end


--addons/wos-passiveevent-ageo/lua/wos/pes/loader/loader.lua:
wOS = wOS || {}
wOS.PES = wOS.PES || {}

if SERVER then
    //TEMPP RRESOURCE ADD TTILL ALL OTHHER ICONSS ARRE REAADY
    resource.AddSingleFile( "materials/wos/pes/bg.png" )
end

local base_dir = "wos/pes"

if SERVER then
    AddCSLuaFile( base_dir .. "/config/general/sh_config.lua")
	AddCSLuaFile( base_dir .. "/config/general/sh_permissions.lua")
    include( base_dir .. "/config/general/sv_config.lua" )
end

include( base_dir .. "/config/general/sh_config.lua")
include( base_dir .. "/config/general/sh_permissions.lua")

if SERVER then

	AddCSLuaFile( base_dir .. "/core/sh_sfs_extern.lua")

    AddCSLuaFile( base_dir .. "/vgui/wos_nodebackground.lua" )
    AddCSLuaFile( base_dir .. "/vgui/wos_node.lua" )
	AddCSLuaFile( base_dir .. "/vgui/wos_viewnodes.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_calendar.lua")
	AddCSLuaFile( base_dir .. "/vgui/wos_datacopy_editor.lua")

    AddCSLuaFile( base_dir .. "/core/sh_mod_mount.lua")
    AddCSLuaFile( base_dir .. "/core/sh_var_mount.lua")

    AddCSLuaFile( base_dir .. "/core/cl_core.lua")
	AddCSLuaFile( base_dir .. "/core/cl_admin_menu.lua")
    AddCSLuaFile( base_dir .. "/core/cl_net.lua")
	AddCSLuaFile( base_dir .. "/core/sh_net.lua")
    AddCSLuaFile( base_dir .. "/core/cl_accessors.lua")
	AddCSLuaFile( base_dir .. "/core/sh_settings.lua")

    include( base_dir .. "/core/sh_var_mount.lua" )
    include( base_dir .. "/core/sh_mod_mount.lua" )
	
    wOS.PES:ServerInclude( base_dir .. "/core/sv_node_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_trigger_mount.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_trigger.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_node.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_obj_event.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_net.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_core.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_permission.lua")
    wOS.PES:ServerInclude( base_dir .. "/core/sv_url_importer.lua")
else

    include( base_dir .. "/vgui/wos_nodebackground.lua" )
    include( base_dir .. "/vgui/wos_node.lua" )

	include( base_dir .. "/vgui/wos_viewnodes.lua")
	include( base_dir .. "/vgui/wos_calendar.lua")

    include( base_dir .. "/vgui/wos_datacopy_editor.lua")

    include( base_dir .. "/core/sh_mod_mount.lua")
    include( base_dir .. "/core/sh_var_mount.lua")
	
	include( base_dir .. "/core/cl_core.lua")
	include( base_dir .. "/core/cl_admin_menu.lua")
    include( base_dir .. "/core/cl_net.lua")
    include( base_dir .. "/core/cl_accessors.lua")

end

include( base_dir .. "/core/sh_sfs_extern.lua")
include( base_dir .. "/core/sh_settings.lua")
include( base_dir .. "/core/sh_net.lua")

hook.Call( "wOS.PES.OnLoaded" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_node.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

function PANEL:DrawTriangleUp( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy + h/2 },
        { x = cx, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleDown( cx, cy, w, h, color )

    local triangle = {
        { x = cx, y = cy + h/2 },
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy - h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleRight( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy },
        { x = cx - w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleLeft( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy },
        { x = cx + w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawRotatedBox( x, y, w, h, ang, color )
	draw.NoTexture()
	surface.SetDrawColor( color or color_white )
	surface.DrawTexturedRectRotated( x, y, w, h, ang )
end

PANEL.TriggerColorHierarchy = {
    Color( 0, 205, 0 ),
    Color( 50, 83, 205 ),   
    Color( 205, 0, 0 ),
    Color( 205, 205, 0 ),
    Color( 205, 0, 205 ),
    Color( 50, 205, 205 ),
}

// Applies to everything, including the current panel after INIT
local function ChildRecursive( self, child )
    child:NoClipping( false )
    child:SetPaintedManually( true )
    child.TestHover = self.TestHover
    child.GetBackground = function() return self:GetBackground() end
    child.GetCursorPos = self.GetCursorPos

    // If we start seeing issues with sub menus, fix this.
    if not child.DropButton then
        child.OnChildAdded = function( s, kid )
            ChildRecursive( s, kid )
        end
    end

    child.RecursiveManualPaint = function( pan )
        if not pan:IsVisible() then return end
        pan:PaintManual( true )
        for _, child in ipairs( pan:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            if not child:IsVisible() then continue end
            child:RecursiveManualPaint()
        end        
    end

    for _, cpan in ipairs( child:GetChildren() ) do
        ChildRecursive( child, cpan )
    end

end

function PANEL:RecursiveManualPaint()
    if not self:IsVisible() then return end
    if not IsValid( self.vars ) then 
        self:PaintManual( true ) 
        for _, child in ipairs( self:GetChildren() ) do
            child:PaintManual( true )
        end
        return 
    end

    local dx, dy = self:GetPos()
    local px, py = self:GetParent():LocalToScreen( dx, dy )
    self.Matrix:SetTranslation( Vector( dx, dy, 0 ) )
    cam.PushModelMatrix(self.Matrix, true)
    self:Paint( self:GetWide(), self:GetTall() )
    cam.PopModelMatrix()

    for _, child in ipairs( self:GetChildren() ) do
        if child == self.vars then continue end
        if not child.Paint then continue end
        self.Matrix:SetTranslation( Vector( dx + child:GetX(), dy + child:GetY(), 0 ) )
        cam.PushModelMatrix(self.Matrix, true)
        child:Paint( child:GetWide(), child:GetTall() )
        cam.PopModelMatrix()
    end

    render.ClearStencil()
    render.SetStencilTestMask( 255 )
    render.SetStencilWriteMask( 255 )
    render.SetStencilPassOperation( STENCILOPERATION_KEEP )
    render.SetStencilZFailOperation( STENCILOPERATION_KEEP )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )

    // Now we render self.vars

    render.SetStencilEnable( true )
        render.SetStencilReferenceValue( 9 )
        render.SetStencilFailOperation( STENCILOPERATION_REPLACE )

        // Masked Draw
        dx, dy = self:LocalToScreen( self.vars:GetPos() )
        px, py = self:GetParent():ScreenToLocal( dx, dy )
        draw.RoundedBox(0, px, py, self.vars:GetWide(), self.vars:GetTall(), Color( 255, 0, 0 ) )
        /////////////////////////////////
        render.SetStencilFailOperation( STENCILOPERATION_KEEP )
        render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )

        // Main draw
        self.vars:RecursiveManualPaint( true )
        /////////////////////////////////
    render.SetStencilEnable( false )

end

function PANEL:OnChildAdded( child )
    ChildRecursive( self, child )
end

function PANEL:TestHover( mx, my )
    local bg = self:GetBackground()
    if IsValid( bg ) and bg:GetZoomScale() < 1 then
        mx, my = self:GetBackground():GetZoomedCursorPos(mx, my)
    end
    
    mx, my = self:ScreenToLocal( mx, my )
    local bx, by = self:GetSize()
    return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
end

function PANEL:Init()
    self.NextClick = 0
    self.MainLink = true
    self._vars = {}
    self._disablevars = {}
    self._checkboxes = {}
    self.Matrix = Matrix()


    self.wOSNode = true
    self:NodeClose(true)
    self:SetZPos( -5 )
    self:SetPaintedManually(true)

    self.DeleteButton = vgui.Create("DButton", self)
    self.DeleteButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.DeleteButton:SetPos( self:GetWide()*0.9 - self:GetTall()*0.0, self:GetTall()*0.925 )
    self.DeleteButton:SetText("")
    self.DeleteButton.DoClick = function(pan)
        self:GetBackground():NodeRemove(self)
        hook.Call( "wOS.PES.OnNodeDelete", nil, self )
    end
    self.DeleteButton.Paint = function(pan, ww, hh)
        //draw.RoundedBox(hh*0.3, 0, 0, ww, hh, Color( 200, 200, 200 ) )
        //draw.SimpleText("X", "DermaDefaultBold", ww/2, hh/2, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, -45, color_white )
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, 45, color_white )
    end

    self.ExpandButton = vgui.Create("DButton", self)
    self.ExpandButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.ExpandButton:SetPos( self:GetWide()*0.8 - self:GetTall()*0.075, self:GetTall()*0.925 )
    self.ExpandButton:SetText("")
    self.ExpandButton.DoClick = function(pan)
        if self.IsOpen then
            self:NodeClose()
        else
            self:Open()
        end
        self.NodeDirty = false
    end
    self.ExpandButton.Paint = function(pan, ww, hh)
        if self.IsOpen then
            self:DrawTriangleUp( ww*0.5, hh*0.3875, ww*0.75, hh*0.75, color_white )
            draw.RoundedBox(0, 0, hh*0.88, ww, hh*0.12, color_white )
        else
            draw.RoundedBox(0, 0, 0, ww, hh*0.12, color_white )
            self:DrawTriangleDown( ww*0.5, hh*0.6, ww*0.8, hh*0.8, color_white )
        end
    end
    self:SetText("")
    self:CreateLinks()

    // Legacy
    self:OnChildAdded( self.ExpandButton )
    self:OnChildAdded( self.DeleteButton )
end

function PANEL:OnSizeChanged( newWidth, newHeight )
	self:CreateLinks( true )
end

function PANEL:CreateLinks( recalc )
    if self.Links then
        for index, link in ipairs(self.Links) do
            if IsValid(link) then link:Remove() end
        end
    end

    self.Links = {}
    self.OtherLinks = {}

    local function makeOtherLink(name, oNode)
        if self.OtherLinks[oNode] and IsValid(self.OtherLinks[oNode][name]) then return end
        local link = vgui.Create("DButton", oNode)
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( link:GetWide()*-0.5, self:GetTall()*0.5 - link:GetTall()*0.5 )
        link:SetText( "" )
        link.Name = name or "Output"
        link.TriggerColor = Color( 255, 255, 255 )
        
        link.OldThink = link.Think
        link.Think = function( s )
            s:OldThink()
            s:SetPos( s:GetPos(), s:GetParent():GetTall()*0.5 - s:GetTall()*0.5 )
        end

        link.DoClick = function()
            self:GetBackground():RemoveLink(self, name, oNode)
            surface.PlaySound( "buttons/button15.wav" )
            link:Remove()
        end

        link.Paint = function(s, w, h)
            local wasEnabled = DisableClipping( true )            
            local col = s.TriggerColor
            if s.Hovered then col = Color(150,150,150) end
            draw.RoundedBox( h*0.3, 0, 0, w, h, col )
            DisableClipping( wasEnabled )
        end

        if IsValid(oNode) then
            self.OtherLinks[oNode] = self.OtherLinks[oNode] || {}
            self.OtherLinks[oNode][name] = link
        else
            self:GetBackground():RemoveLink(self, name, oNode)
        end
    end

    local function makeLink( name, label, desc )
        local link = vgui.Create("DButton", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]

        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )
        link.NLabel = label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip( link.NDescription )

        link.OnDepressed = function( s )
            surface.PlaySound( "weapons/airboat/airboat_gun_lastshot2.wav" )
            s.Linking = true
        end

        link.OnReleased = function( s )
            s.Linking = false
            local x, y = self:GetCursorPos()

            timer.Simple(0, function()
                local a = vgui.GetHoveredPanel()

                local hoveredPanel = vgui.GetHoveredPanel()
                if not hoveredPanel then return end
                if not IsValid(hoveredPanel) then return end
                if not hoveredPanel.wOSNode then return end
                if hoveredPanel:IsStart() then return end
                self:GetBackground():MakeLink(self, hoveredPanel, link.Name)
                makeOtherLink(link.Name, hoveredPanel)
                surface.PlaySound( "weapons/airboat/airboat_gun_lastshot1.wav" )
            end)

            s.mousepos = {x = x, y= y}
            self.Links[#self.Links + 1] = link
        end

        link.Paint = function(s, w, h)

            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            if s.Hovered then col = Color(150,150,150) end

            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )

            if not s.Linking then return end
            DisableClipping( true )

            local x,y = s:ScreenToLocal( self:GetCursorPos() )

            surface.DrawLine( w, h/2, x, y )

            DisableClipping( wasEnabled )
        end
        self.Links[#self.Links + 1] = link
    end

    local nodeLinks = self:GetBackground():GetLinks(self)

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end

                makeLink(name, trigger_label, trigger_description )
                if recalc then return end
                if not nodeLinks[name] then continue end
                for index, node in pairs(nodeLinks[name]) do
                    makeOtherLink(name, node)
                end
            end
            return
        end
    end

    makeLink("Instant")
    if not nodeLinks["Instant"] then return end
    for index, node in pairs(nodeLinks["Instant"]) do
        makeOtherLink("Instant", node)
    end
end

function PANEL:ApproveVar( name, data, dirty )
    if not name then return true end
    if not data then return true end
    if data.Internal then return true end

    if ( self:GetVarDisabled( name ) ) then return true end

    //Dirty validation
    if dirty then
        local varType = wOS.PES.Vars:Get(data.Type)
        if varType then
            if varType.DirtyValidate then
                self._vars[name] = data.Default or nil
                return false 
            end
        end
    end

    if !data.Required then return true end
    if ( self._vars[name] != nil ) then return true end
    return false
end

function PANEL:GetCursorPos()
    local bg = self:GetBackground()
    if not IsValid( bg ) then return input.GetCursorPos() end
    return bg:GetZoomedCursorPos( input.GetCursorPos() )
end

function PANEL:RecalculateDirty( dirty )
    local final = false
    
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData then
            if nodeData.Vars then
                for _, name in pairs(nodeData.SortedVars) do
                    local data = nodeData.Vars[ name ]
                    if not data then continue end
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end

            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                if istable( tdata ) then
                    name = tdata.Type or name
                end
                
                local triggerTable = wOS.PES.Triggers:Get(name)
                if not triggerTable then continue end
                if not triggerTable.Vars then continue end
                for name, data in pairs(triggerTable.Vars) do
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end
        end
    end

    self.NodeDirty = final
end

function PANEL:SetVars(tbl, dirty)
    tbl = tbl or {}
    self._vars = tbl
    self:RecalculateName()
    self:RecalculateDirty( dirty )
end

-- function PANEL:UpdateCheckbox( name )
--     if not self._checkboxes[ name ] then return end
--     self._checkboxes[ name ]( !self:GetVarDisabled( name ) )
-- end

function PANEL:SetDisableVars( tbl, dirty )
    tbl = tbl or {}
    self._disablevars = tbl
    self:RecalculateDirty( dirty )
    //self:RefreshCheckBoxes()
end

function PANEL:GetVars()
    return self._vars
end

function PANEL:GetCopy()
    local data = {}
    data.Vars = table.Copy( self._vars )
    data.Toggles = table.Copy( self._disablevars )
    data.Type = self.Type
    return data
end

function PANEL:GetVar(name)
    return self._vars[name]
end

function PANEL:GetVarDisabled(name)
    if self._disablevars[name] != nil then
        return self._disablevars[name]
    end
    return false
end

function PANEL:SetVarDisabled(name, bool)
    self._disablevars[name] = bool
end

function PANEL:SetVar(name, value)
    self._vars[name] = value
    self:RecalculateName()
end

function PANEL:SetMainLink(bool)
    self.MainLink = bool
end

function PANEL:GetMainLink()
    return self.MainLink
end

function PANEL:GetBackground()
    if self.TempBack then return self.TempBack:GetParent() end
    return self:GetParent():GetParent()
end

function PANEL:GetMaster()
    local pan = self:GetBackground()
    if not pan then return end
    return pan:GetParent()
end

function PANEL:OnDepressed()
    local x, y = self:GetCursorPos()
    self.mousepos = {x = x, y= y}

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    self.Dragging = true
    local back = self:GetBackground()
    if back.SelectedPanel == self then return end
    back:SelectNode( self )
end

function PANEL:OnReleased()
    self.Dragging = false
end

function PANEL:GetTriggerPos(triggerName)
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        -- if check
		if nodeData then
			local maxTriggers = #nodeData.Triggers
            for index, tdata in ipairs(nodeData.Triggers) do
                local trigger = tdata
                if istable( tdata ) then
                    trigger = tdata.Type or trigger
                end

				if trigger == triggerName then
					return self:GetTall()*0.5 + self:GetTall()*0.13 * ( index - ( maxTriggers + 1 )*0.5 ), index, self.TriggerColorHierarchy[index]
				end
			end
		end
	end

    return self:GetTall() * 0.5, 1, self.TriggerColorHierarchy[1]
end

function PANEL:Think()

    if not self.Dragging then return end
    if not input.IsMouseDown(MOUSE_LEFT) then self.Dragging = false return end

    local cX, cY = self:ScreenToLocal( self.mousepos.x, self.mousepos.y )
    local mX, mY = self:GetCursorPos()
    self.mousepos = {x = mX, y = mY}
    mX, mY = self:ScreenToLocal( mX, mY )

    local x, y = self:GetPos()
    local dX, dY = mX - cX, mY - cY
    self:SetPos(x + dX, y + dY)

end

function PANEL:DoClick()
    if self.NextClick >= CurTime() then
        self.NextClick = CurTime() + 1
        return
    end

    local back = self:GetBackground()
    back:SelectNode( self )
end

function PANEL:SaveVars()
    if not self.Type then return end

    local nodeData = wOS.PES.Nodes:Get(self.Type)
    -- if no data then return
    local maxTriggers = #nodeData.Triggers

    if !self.varDerma then return end

    if nodeData.Vars then
        for name, varTable in pairs(nodeData.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[name]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar(name, value)
        end
    end

    for index, tdata in ipairs(nodeData.Triggers) do
        local name = tdata
        if istable( tdata ) then
            name = tdata.Type or name
        end
        local triggerTable = wOS.PES.Triggers:Get(name)
        if not triggerTable then continue end
        if not triggerTable.Vars then continue end
        for name, varTable in pairs(triggerTable.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[ name ]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar( name, value)
        end
    end
end

function PANEL:NodeClose(bool)
    -- remove extra elements
    self:SetZPos(20)
    self.IsOpen = false
    if !bool then
        self:SaveVars()
    end

    self:SetSize(self:GetWide(), self:GetWide()*0.8 )

    if IsValid(self.TypeComboBox) then
        self.TypeComboBox:Remove()
    end

    if IsValid(self.vars) then
        self.vars:Remove()
    end
end

function PANEL:Open()
    self:SetSize( self:GetWide(), self:GetWide() )
    self.IsOpen = true
    self:Populate()
    self:SetZPos(9999)
end

function PANEL:Populate()

    // Replace this with a label that makes sense
    local a = vgui.Create("DLabel", self)
    a:SetSize(190, 15)
    a:SetTextColor( Color( 0, 0, 0 ) )
    a:SetText( self:GetText() )
    a:SetPos(10, 10)
    self.TypeComboBox = a

    if self.Type then
        local scroll = vgui.Create("DCategoryList", self)
        scroll:SetPos( self:GetWide()*0.025, self.BoxTopSize + self:GetTall()*0.05 )
        scroll:SetSize( self:GetWide()*0.95, self:GetTall()*0.9 - self.BoxTopSize - self.BoxBottomSize )

        self.vars = scroll
        self.varDerma = {}
    end

    local makeVars = function(varTable, varData)
        local varType = wOS.PES.Vars:Get(varTable.Type)
        if varTable.Internal then return end

        local cat = self.vars:Add( varTable.Name )

        if !varType then
            cat:Add("This variable errored!")
            self.vars:InvalidateLayout( true )
            return
        end

        -- send in varData or the Default value
        local element = varType.DermaElement(varTable, varData)

        local back = vgui.Create("DPanel")

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        if element:GetClassName() == "TextEntry" then
            local old_func = element.OnGetFocus
            element.OnGetFocus = function( pan )
                self:GetBackground().SelectedPanel = nil
                old_func( pan )
            end
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

        self.varDerma[varTable.Name] = element

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Use Tool")
            useTool.DoClick = function( pan )
                wOS.PES:SetEditingVar(self, varTable)
                local bg = self:GetBackground()
                if not bg then return end
                bg:SetupTool()
            end
        end

        cat:SetContents(back)
        self.vars:InvalidateLayout( true )

        if varTable.ToggleVar then
            local header = cat.Header

            local checkbox = vgui.Create( "DCheckBox", header )
            local hew, heh = header:GetSize()
            local cw, ch = self.vars:GetSize()

            checkbox:DockMargin(heh*0.1, heh*0.10, heh*0.1, heh*0.1)
            checkbox:Dock( RIGHT )
            checkbox:SetSize( heh*0.7, heh*0.7 )
            checkbox.Variable = varTable.Name

            //checkbox:SetPos( cw - 40, heh*0.15 )

            //self:SetVarDisabled( varTable.Name, false )
            
            header.OriginalColor = header:GetTextColor()
            checkbox.OnChange = function( pan, chk )
                local color = Color( 0, 0, 0, 155 )
                if chk then
                    color = pan:GetParent().OriginalColor
                end
                header:SetTextColor( color )
                if pan.RecursivePrevention then return end
                self:SetVarDisabled( pan.Variable, !chk )
            end

            local state = !self:GetVarDisabled( checkbox.Variable )
            checkbox.RecursivePrevention = true
            checkbox:SetChecked( state )
            checkbox:OnChange( state )
            checkbox.RecursivePrevention = false
            
            -- self._checkboxes[ checkbox.Variable ]  = function( bool )
            --     checkbox.RecursivePrevention = true
            --     checkbox:SetChecked( bool )
            --     checkbox.RecursivePrevention = false
            -- end
        end


    end

    if self.vars then
        self:OnChildAdded( self.vars )
    end

    local nodeData = wOS.PES.Nodes:Get(self.Type)

    if nodeData then
        if nodeData.Vars then
            for _, name in pairs(nodeData.SortedVars) do
                local data = nodeData.Vars[ name ]
                if not data then continue end
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end

        for index, tdata in ipairs(nodeData.Triggers) do
            local name = tdata
            if istable( tdata ) then
                name = tdata.Type or name
            end
            local triggerTable = wOS.PES.Triggers:Get(name)
            if not triggerTable then continue end
            if not triggerTable.Vars then continue end
            for name, data in pairs(triggerTable.Vars) do
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end
    end
    
end

function PANEL:RecalculateName()
    if self:IsStart() then return end

    if self:GetVar("Event Label") and self:GetVar("Event Label") != "" then
        self.TextName = self:GetVar("Event Label")
        return
    end

    if self.Type then
        self.TextName = self.Type .. " " .. tostring(self.ID-1) 
    else
        self.TextName = "Node " .. tostring(self.ID-1) 
    end
end

function PANEL:Paint(w, h)


    local color = Color(0, 0, 0, 255)

    if self.EventViewerNode then
    
        if self.Active then
            color = Color(0, 255, 0, 255)
        end

    else

        // Regular usage ( CSS / PES CREATION )
        local back = self:GetBackground()
        if self.NodeDirty then 
            color = Color( 176, 66, 33 )
        elseif back.SelectedPanel == self then
            color = Color( 66, 117, 176 ) 
        end

    end
    draw.RoundedBox(w*0.1, 0, 0, w, h, color)
    draw.RoundedBox(w*0.1, w*0.015, w*0.015, w*0.97, h - w*0.03, Color(155, 155, 155, 88))

    if not self.TextName then return end
    local txt = wOS.PES.WrapText( self.TextName, "wOS.PES.NodeText", w*0.95 )
    surface.SetFont( "wOS.PES.NodeText" )
    local _, dH = surface.GetTextSize( txt )


    self.BoxTopSize = h*0.18
    self.BoxBottomSize = h*0.18
    self.BoxBottomPos = h - self.BoxBottomSize
    
    if dH > self.BoxTopSize*0.95 then
        self.BoxTopSize = self.BoxTopSize + dH*0.5
    end

	if IsValid(self.ExpandButton) then
        self.ExpandButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.ExpandButton:SetPos( self:GetWide()*0.75 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

	if IsValid(self.DeleteButton) then
        self.DeleteButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.DeleteButton:SetPos( self:GetWide()*0.9 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

    // Bottom Bar
    draw.RoundedBoxEx( w*0.1, 0, self.BoxBottomPos, w, self.BoxBottomSize, Color( 66, 0, 0 ), false, false, true, true )
    draw.RoundedBoxEx( w*0.1, w*0.015, self.BoxBottomPos + w*0.015, w*0.97, self.BoxBottomSize - w*0.03, Color( 125, 0, 0 ), false, false, true, true )

    // Top Bar
    draw.RoundedBoxEx( w*0.1, 0, 0, w, self.BoxTopSize, Color( 66, 0, 0 ), true, true, false, false )
    draw.RoundedBoxEx( w*0.1, w*0.015, w*0.015, w*0.97, self.BoxTopSize - w*0.03, Color( 125, 0, 0 ), true, true, false, false )

    draw.DrawText(txt, "wOS.PES.NodeText", w/2, self.BoxTopSize/2 - dH/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function PANEL:SetAsStart( isstarter )
    self.IsStartNode = isstarter
end

function PANEL:IsStart()
    return self.IsStartNode
end

vgui.Register( "WOS_PES_NODE", PANEL, "DButton" )

--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_datacopy_editor.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2023
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


























































































































































local PANEL = {}

function PANEL:Init()

end

function PANEL:SetVariableData( data )
    self.VariableData = table.Copy( data )
    self:RebuildData()
end

function PANEL:SetBasePanel( pan )
    self.DataPanel = pan
end

function PANEL:GetVariableData()
    return self.VariableData
end
--
-- Clears and rebuilds the controls. Should only really be called internally.
--
function PANEL:RebuildData()

	--
	-- we're rebuilding - so clear all the old controls
	--
	self:Clear()

    if not self.VariableData then return end

    -- Enforces that it is at the top of the list
    self:GetCategory( "Base Entity Data", true )

	for name, data in pairs( self.VariableData ) do
		self:EditVariable( name, data )
	end

end

local function VarToPropertyType( var )
    if isbool( var ) then
        return "Bool"
    elseif IsColor( var ) then
        return "VectorColor"
    elseif isvector( var ) then
        return "Vector"
    elseif isangle( var ) then
        return "Angle"
    end

    return "String"
end

function PANEL:CreateNestedEditor( varname, editdata )
    local category = self:GetCategory( varname, true )
    local count = 0
    for val_name, val in pairs( editdata ) do
        if istable( val ) then continue end
        count = count + 1
        local row = self:CreateRow( varname, val_name )
        row:Setup( VarToPropertyType( val ) )
        row:SetValue( val )
        row:SetEnabled( true )

        row.DataUpdate = function( _ ) end
        row.DataChanged = function( _, vald )
            if not IsValid( self.DataPanel ) then return end
            self.VariableData[ varname ][ val_name ] = vald
        end
    end
    if count < 1 then category:Remove() end
end

--
-- Called internally. Adds an entity variable to watch.
--
function PANEL:EditVariable( varname, editdata )

	if ( istable( editdata ) ) then 
        /*
            Uncomment this function if you DARE. It will add some nested tables (only one layer of nest)
            Need to make a TABLE row type for PES, so we can ADD to tables. Only then will this official get added back
        */

        // self:CreateNestedEditor( varname, editdata ) 
        return 
    end

	local row = self:CreateRow( "Base Entity Data", varname )
	row:Setup( VarToPropertyType( editdata ) )
    row:SetValue( editdata )
    row:SetEnabled( true )

	row.DataUpdate = function( _ ) end
	row.DataChanged = function( _, val )
        if not IsValid( self.DataPanel ) then return end
        self.VariableData[ varname ] = val
	end

end

vgui.Register( "WOS_PES_DATACOPY_EDITOR", PANEL, "DProperties" )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/sound/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local addon = {}



local function IsUrl(str)
    local pattern = "https?://%S+"
    return string.match(str, pattern) ~= nil
end

net.Receive("wOS.PES.Music", function()
    local path = net.ReadString()
    local vol = net.ReadFloat()
    local dur = net.ReadUInt(12)

    AOCRP:PlayMusic(path)
end)

net.Receive("wOS.PES.Sound", function()
    local path = net.ReadString()
    local vol = net.ReadFloat()
    local dur = net.ReadUInt(12)

    local soundStation = nil

    if IsUrl(path) then
        local soundObject = sound.PlayURL(path, "noblock", function(station) 
            if (IsValid(station)) then
                station:SetVolume(1)
                station:Play()

                if dur < 1 then
                    dur = station:GetLength()
                end

                soundStation = station
            end
        end)
    else
        local soundObj = sound.PlayFile("sound/" .. path, "3d", function(station)
            if (IsValid(station)) then
                station:Play()
                station:SetVolume(vol)
                station:SetPos(LocalPlayer():GetPos())
            end

            if dur > 0 then
                timer.Simple(dur, function()
                    if IsValid(station) then
                        station:Remove()
                    end
                end)
            end
        end)
    end
end)

wOS.PES.Modules:RegisterAddon("sound", addon)
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local SWEP = {}

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0
SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )

SWEP.PrintName = "Combat Simulation Tool"
SWEP.Slot = 5
SWEP.SlotPos = 6
SWEP.HoldType = "pistol"
--SWEP.Author	        = "Jan (wiltOS)"

SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel	= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.Category = "[wOS] Passive Event"
SWEP.UseHands = true

SWEP.Primary = {}
SWEP.Primary.Swap           = Sound( "weapons/clipempty_rifle.wav" )
SWEP.Primary.Sound			= Sound( "NPC_CombineCamera.Click" )
SWEP.Primary.Delete1		= Sound( "Weapon_StunStick.Melee_Hit" )
SWEP.Primary.Delete			= Sound( "Weapon_StunStick.Melee_HitWorld" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.Secondary = {}
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

-- TODO: Add "Modify Border Points"

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "ToolMode" )
	self:NetworkVar( "Int", 1, "ToolStep" )

	self:NetworkVar( "Entity", 0, "SelectedSimulator")
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	local trace = self:GetOwner():GetEyeTrace()

	if mode == WOS_CSS.MODE.INITIAL then
		local ent = trace.Entity
		if !IsValid(ent) then return end
		if ent:GetClass() == "prop_physics" then
			self:CreateSimulator(ent)
		end
	elseif mode == WOS_CSS.MODE.AREASELECT then
		local ent = trace.Entity

		if step == WOS_CSS.AREASELECT.BORDER then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				return
			end
			self:SelectBorderPoint(trace)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			if IsValid(ent) and ent:GetClass() == "wos_simulation_system" then
				-- TODO: Validation
				self:FinishAreaSelectMode()
				return
			end
			self:SelectHeightPoint(trace)
		end
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarPrimary()
	end
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end

	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode == WOS_CSS.MODE.AREASELECT then
		if step != WOS_CSS.AREASELECT.BORDER then return end
		self:RemoveBorderPoint()
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		self:DoVarSecondary()
	end

end

function SWEP:Reload()
    if not IsFirstTimePredicted() then return end

	timer.Create("wOS.CombatSim.ReloadTime", 1, 1, function()
		self.LastReloadPressed = false
	end)

	if self.LastReloadPressed then return end
	self.LastReloadPressed = true

	local mode = self:GetToolMode()
	local step = self:GetToolStep()

	if mode == WOS_CSS.MODE.POINTSELECT then
		wOS.CombatSim:OpenSimulationCreator(simulator)
		return
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
        wOS.CombatSim:OpenSimulationCreator(simulator)
	end

end

function SWEP:Think()
end

function SWEP:Deploy()
    local cur_pan = wOS.PES:GetActiveMenu()
    if !IsValid(cur_pan) then return end
    if !cur_pan.menu then return end
    if not cur_pan.menu.CreationType then return end 
    if cur_pan.menu.CreationType == WOS_PES.CREATOR.SIMULATION then return end
    cur_pan:Remove()
end

function SWEP:Holster()
	return true
end

function SWEP:CreateSimulator(ent)
	self.SelectedBorderPoints = {}
	self.SelectedHeight = 0
end

function SWEP:SelectBorderPoint(trace)
	table.insert(self.SelectedBorderPoints, trace.HitPos)
end

function SWEP:RemoveBorderPoint()
	self.SelectedBorderPoints[#self.SelectedBorderPoints] = nil
end

function SWEP:SelectHeightPoint(trace)
	local firstPoint = self.SelectedBorderPoints[1]
	
	if isvector(firstPoint) then
		self.SelectedHeight = trace.HitPos.z - firstPoint.z
	end
end

function SWEP:FinishAreaSelectMode()
	wOS.CombatSim:OpenSimulatorNameMenu(self.SelectedBorderPoints, self.SelectedHeight)
end

function SWEP:DoVarPrimary(trace)
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarPrimaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.PrimaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

function SWEP:DoVarSecondary()
	local simulator = self:GetSelectedSimulator()
	if simulator == self then return end
	if not IsValid(simulator) then return end
	if simulator:GetClass() != "wos_simulation_system" then return end
  
	local wtbl = weapons.Get( "wos_pes_tool" )
	if not wtbl then return end

	local hookname = "wOS.CombatSim.EnforceVarSecondaryPlacement." .. self:EntIndex()
	hook.Add( "wOS.CombatSim.CanPlaceEntity", hookname, function( wep, ply, pos ) 
		if wep != self then return end
		if ply != LocalPlayer() then return end
		local inside = simulator:CheckInBorders(pos + Vector(0, 0, 1)) -- Offset because the floor isn't 100% inside.
		if inside then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		notification.AddLegacy( "[wOS-PES] You can't operate vars outside the simulation area.", NOTIFY_ERROR, 3 )
		return false
	end )

	local success = wtbl.SecondaryAttack( self )
	hook.Remove( "wOS.CombatSim.CanPlaceEntity", hookname )
end

local w,h = ScrW(), ScrH()
function SWEP:DrawHUD()
	local mode = self:GetToolMode()
	local step = self:GetToolStep()
	
	if mode != WOS_CSS.MODE.POINTSELECT then
		draw.SimpleText("Simulation System Tool", "wOS.CombatSim.MainFont", w * 0.02, h * 0.02, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Create new or configure existing Combat Simulators.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	end

	if mode == WOS_CSS.MODE.INITIAL then
		draw.SimpleText("Simulator Selection / Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		draw.SimpleText("Create a new simulator by left-clicking a prop.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		draw.SimpleText("Select an existing simulator by left-clicking its console.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.AREASELECT then
		draw.SimpleText("Simulator Area Creation", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

		if step == WOS_CSS.AREASELECT.BORDER then
			draw.SimpleText("Left-click to add a border point to the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Right-click to remove the last border point from the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.14, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm border.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.16, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		elseif step == WOS_CSS.AREASELECT.HEIGHT then
			draw.SimpleText("Left-click to set the border height of the simulator area.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("Left-click the simulator console to confirm height.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.15, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
		
		draw.SimpleText("Press R to abort creation.", "wOS.CombatSim.SmallFont", w * 0.02, h * 0.18, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.SIMSELECTED then
		draw.SimpleText("Simulator | Challenges Creation/Editing", "wOS.CombatSim.LeaderFont", w * 0.02, h * 0.09, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	elseif mode == WOS_CSS.MODE.POINTSELECT then
		local wtbl = weapons.Get( "wos_pes_tool" )
		if not wtbl then return end
		local success = wtbl.DrawHUD( self )
		self.RenderScreen = wtbl.RenderScreen
	end
end

weapons.Register(SWEP, "wos_simulation_tool")
--addons/arccw_weapons/lua/weapons/aocrp_cr2c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "CR-2"
SWEP.Trivia_Class = "Heavy-Blaster Rifle"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/cr2.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_cr2.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_cr2.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-11.4, 5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 26
SWEP.RangeMin = 450
SWEP.DamageMin = 13
SWEP.Range = 1344
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 65
SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13
SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.FirstShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_07.mp3"
SWEP.ShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_08.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.152, -5.928, 2.367),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods
-- Attachments
SWEP.AttachmentElements = {
    ["cr2_barrel_extended"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.45, 0.7, 13.4),
            },
        }
    },
    ["cr2_stock"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, -1.7, -1),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },     
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, 0.7, 11.4),
            vang = Angle(90, 0, -90),

        },
    },       
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = "cr2_stock",
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        VMScale = Vector(0.7, 0.7, 0.7),
        Slot = {"charm"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0, -1.4, 3.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0.7, -0.7, -1),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["fire_iron"] = {
        Source = "Neutral"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 23
SWEP.DamageMin = 13
SWEP.RangeMin = 450
SWEP.Range = 1344
SWEP.Delay = 60 / 550
SWEP.Primary.ClipSize = 40
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dc15x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


-- Trivia
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DC-15x sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic through extensive modifications of the standard-issue DC-15A blaster rifle."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15x.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/ser/starwars/c_dc15x.mdl"
SWEP.WorldModel = "models/ser/starwars/w_dc15x.mdl"

SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(8, 1., -3.5),
    ang = Angle(-5, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.2
}

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 200
SWEP.RangeMin = 600
SWEP.DamageMin = 100
SWEP.Range = 1544
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1.78
SWEP.RecoilSide = 0.36
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 2000
SWEP.MoveDispersion = 1000

--SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.35

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15x.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.941, -6.442, 1.307),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(1, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

--[[ SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1) ]]

--[[ SWEP.Bipod_Integral = f -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.1 -- Bipod recoil for Integral bipods ]]

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
	{
		PrintName = "Sight", 
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "optic",
		Offset = {
            vpos = Vector(0.02, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.8, -4.6),
            wang = Angle(-7, 0, 180),
        },
	}, 
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "optic",
        Offset = {
            vpos = Vector(0.8, 1, 15),
            vang = Angle(90, 0, -0),
            wpos = Vector(24, 1.4, -5),
            wang = Angle(-5, 0, -90),
        },
    },
    {
        PrintName = "Bipod",
        DefaultAttName = "None",
        Slot = {"btrs_41_bipod"},
        --WMScale = Vector(111, 111, 111),
        Bone = "optic",
        Offset = {
            vpos = Vector(15, 0.6, -2.3),
            vang = Vector(15, 0.6, -2.3),    
            wpos = Vector(0, 0, 0),
            wang = Angle(-3, 0, 180)     
        },
    },   
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "optic",
        Offset = {
            vpos = Vector(0, 2, 15),
            vang = Angle(90, 0, -90),    
            wang = Angle(-3, 0, 180)     
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2.6, 6),
        vmax = Vector(-0.2, 2.6, 12),
        wmin = Vector(15, 0.6, -2.3), 
        wmax = Vector(15, 0.6, -2.3)
        },         
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "optic", 
        Offset = {
            vpos = Vector(0, 1, 20),
            vang = Angle(90, 0, -90),
            wpos = Vector(26, 0.75, -5.25),
            wang = Angle(-5, 0.5, 180)
        },
    },  
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "optic",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, 1.6, -3.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(2.3, 1.8, -2.3),
            wang = Angle(0, 0, 180)
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "optic",
        Offset = {
            vpos = Vector(1, 1.350, -6),
            vang = Angle(90, 0, -90),
            wpos = Vector(-2, 1.8, -2.3),
            wang = Angle(-5, 0, 180)
        },
    },      
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15x-1", t = 0.1 }, --s sound file
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 },
            {s = "everfall/weapons/handling/reload_heavy/mag_load/023d-000000ae.mp3", t = 0.9 }, --s sound file
        },
    },

sound.Add({
    name =          "dc15x-1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "everfall/weapons/handling/reload_heavy/mag_eject/023d-00000628.mp3"
    }),
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 200
SWEP.DamageMin = 100
SWEP.RangeMin = 600
SWEP.Range = 1544
SWEP.Delay = 60 / 120
SWEP.Primary.ClipSize = 15
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dual_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact DC15S Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 21
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 520
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"


SWEP.MuzzleFlashColor = Color(0, 0, 255, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, 0, -1.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17", "dc17+"}

SWEP.AttachmentElements = {
    ["dc17"] = {
        VMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(-10, -8, 90)
                }
            }
        },
    },
    ["dc17+"] = {
         VMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(-190, 8, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-8, -4, 2),
            vang = Angle(170, 0, 0),
        },
    },   
}   


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 90
SWEP.Range = 350
SWEP.Delay = 60 / 520
SWEP.Primary.ClipSize = 40
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_rps6.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Eingestellte Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "RPS-6"
SWEP.TrueName = "RPS-6 Launcher"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "A rocket launcher with 4 different payload options; HE, HEAT, Tandem, and Smoke. HE rockets have high splash but low immediate damage. HEAT rounds have good damage and splash. Tandem rounds have very little splash, but massive damage. Smoke rounds do no damage, but create an obscuring smokescreen."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Mechanism = "Single-Action"
SWEP.Trivia_Country = "Russia"
SWEP.Trivia_Year = 1961

SWEP.Slot = 4
SWEP.UseHands = true

SWEP.ViewModel = "models/holdtypes/c_rpg7.mdl"
SWEP.WorldModel = "models/holdtypes/w_rpg7.mdl"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true

SWEP.IconOverride = "materials/entities/rps6_meeks.png"

SWEP.ShootEntity = "arccw_rocket_heat" -- entity to fire, if any
SWEP.MuzzleVelocity = 100000 -- projectile or phys bullet muzzle velocity
-- IN M/S

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 1 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 2
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 2

SWEP.Delay = 60 / 600 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = "weapon_rpg"
SWEP.NPCWeight = 150

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 500

SWEP.Primary.Ammo = "RPG_Round" -- what ammo type the gun uses
SWEP.MagID = "rpg7" -- the magazine pool this gun draws from

SWEP.ShootVol = 130 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound = "everfall/weapons/rocket_launcher/explosive_rocketlauncher_corebass_close_var_01.mp3"
SWEP.DistantShootSound = "weapons/arccw/rpg7/rpg7_dist.wav"

SWEP.MuzzleEffect = "muzzleflash_m79"

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on

SWEP.SightTime = 0.35

SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75

SWEP.BarrelLength = 24

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.CaseBones = {}

SWEP.IronSightStruct = {
    Pos = Vector(-2, -12, 2),
    Ang = Angle(1.5, 0, 0),
    Magnification = 1.5,
    SwitchToSound = "", -- sound that plays when switching to this sight
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 5)
SWEP.SprintAng = Angle(-30, 0, 0)

SWEP.HolsterPos = Vector(1, 4, -14)
SWEP.HolsterAng = Angle(40, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(13.824, 2, 0.897)
SWEP.CustomizeAng = Angle(12.149, 40.547, 45)

SWEP.ExtraSightDist = 15

SWEP.DefaultElements = {"rocketlauncher"}

SWEP.AttachmentElements = {
    ["rocketlauncher"] = {
        VMElements = {
            {
                Model = "models/weapons/rocket3/rocket_launcher3.mdl",
                Bone = "Weapon_Main",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(0.2, -2, -6),
                    ang = Angle(0, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/weapons/rocket3/rocket_launcher3.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-50, 10, -55),
                    ang = Angle(0, -90, 180)
                }
            }
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights",
        WMScale = Vector(11, 11, 11),
        Slot = {"optic", "optic_lp"}, -- what kind of attachments can fit here, can be string or table
        Bone = "Weapon_Main", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, -5.9, 4), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(90.36, 10, -110.301),
            wang = Angle(0, 0, 180)
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod"},
        WMScale = Vector(11, 11, 11),
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(0, -2, 6),
            vang = Angle(90, 0, -90),
            wpos = Vector(140, 10, -55.453),
            wang = Angle(-180.216, 0, 0)
        },
        InstalledEles = {"nogrip"},
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "Default",
        Slot = "ammo_rocket"
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        NoWM = true,
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(1.7, -3, 1), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(11, 1.25, -4.5),
            wang = Angle(0, -4.211, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1,
    },
    ["idle_empty"] = {
        Source = "idle_empty",
        Time = 1,
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 1.5,
    },
    ["draw"] = {
        Source = "draw",
        Time = 1.5,
    },
    ["fire"] = {
        Source = "fire",
        Time = 0.5,
    },
    ["reload"] = {
        Source = "reload",
        Time = 4,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {20, 26, 40},
        FrameRate = 30,
        LHIK = false,
        SoundTable = {
            {
                s = "insertrocket", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 74 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "insertrocket2", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 115 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "rocketclick", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 174 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}

local path = "weapons/rocket launcher/"

sound.Add({
	name = "insertrocket",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert.wav"
	})

sound.Add({
	name = "insertrocket2",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert2.wav"
	})


sound.Add({
	name = 			"rocketclick",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = path ..	"click.wav"
})



SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_ubgl.lua:
att.PrintName = "Granatwerfer"
att.AbbrevName = "Granatwerfer"
att.Icon = Material("interfaz/iconos/jedi/453218427_4064545516.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher designed to Special Infantry."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "aocrp_ubgl"
att.ExcludeFlags = {"uc_noubgl"}
att.LHIK = true
att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/weapons/arccw/atts/uc_ubgl_m203.mdl"
att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""
att.UBGL = true
att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1
att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local function Ammo(wep)
    return (wep:GetOwner():GetAmmoCount("Grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/raise.ogg", t = 0.2},
            {s = "arccw_uc/common/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw_uc/common/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw_uc/common/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "tfa_battlefront_ent_nade_impact"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw_uc/common/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw_uc/common/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw_uc/common/40mm/casing-40mm-01.ogg", "arccw_uc/common/40mm/casing-40mm-02.ogg", "arccw_uc/common/40mm/casing-40mm-03.ogg", "arccw_uc/common/40mm/casing-40mm-04.ogg", "arccw_uc/common/40mm/casing-40mm-05.ogg", "arccw_uc/common/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw_uc/common/rattle1.ogg", "arccw_uc/common/rattle2.ogg", "arccw_uc/common/rattle3.ogg" }, t = 0},
            {s = "arccw_uc/common/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw_uc/common/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw_uc/common/40mm/203insert.ogg", t = 1.2},
            {s = "arccw_uc/common/shoulder.ogg", t = 1.5},
            {s = "arccw_uc/common/40mm/203close.ogg", t = 1.7},
            {s = "arccw_uc/common/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)

 
    wep:GetOwner():RemoveAmmo( 1, "Grenade" )
    wep:SetClip2(1)

end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85
att.ToggleLockDefault = false
att.ToggleStats = {
    {
        PrintName = "Impact Grenade",
        UBGL_Entity = "arccw_thr_impact"
    },
}
--addons/aocrp_emplacements/lua/weapons/aocrp_waffengeschuetz.lua:
AddCSLuaFile()

SWEP.PrintName				= "Waffengeschütz"
SWEP.Author					= "Mekphen"
SWEP.Purpose				= ""
SWEP.Category				= "AOCRP - Eingestellte Waffen"

SWEP.Slot					= 7
SWEP.SlotPos				= 1

SWEP.ViewModel				= Model( "" )
SWEP.WorldModel				= Model( "" )
SWEP.ViewModelFOV			= 70
SWEP.UseHands				= false
SWEP.HoldType				= "normal"


SWEP.Emplacement 			= "turret_bullets"
SWEP.PreviewModel 			= "models/reach/weapons/turret/tripod.mdl"

SWEP.Spawnable = true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "emplacement_762"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.DrawAmmo				= true
SWEP.Empty 					= false


function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )

	if CLIENT then
		self:GhostProp()

		if self:GetOwner():GetAmmoCount(self.Primary.Ammo) > 0 then
			self.ghostProp:SetNoDraw( false )
		else
			self.ghostProp:SetNoDraw( true )
		end
	end
end

function SWEP:Deploy()
	if CLIENT then
		self:GhostProp()
	end
end

function SWEP:GhostProp()
	if (IsValid(self.ghostProp)) then self.ghostProp:Remove() end
	self.ghostProp = ents.CreateClientProp()
	self.ghostProp:SetModel( self.PreviewModel )
	self.ghostProp:SetMaterial("models/wireframe")
	self.ghostProp:Spawn()
	self.ghostProp:Activate()
	self.ghostProp:SetRenderMode(RENDERMODE_TRANSALPHA)
	self.ghostProp:SetModelScale(1)
end


function SWEP:CalcViewModelView( vm, oldPos, oldAng, pos, ang )
	local oldPos = vm:GetPos()
	local oldAng = vm:GetAngles()

	local newPos = pos + ang:Up() * 5 + ang:Forward() * -12
	return newPos, ang
end

function SWEP:IsTurret(ent)
	if not IsValid(ent) then return false end

	local isTurret = false

	if ent:GetModel() == "models/reach/weapons/turret/tripod.mdl" and (table.Count(ent:GetTable().Constraints) >= 1) then
		isTurret = true
	end

	return isTurret
end

function SWEP:PrimaryAttack( right )

	local tr = self:GetOwner():GetEyeTrace()
	local normal = tr.HitNormal:Angle().p

	if (SERVER) then
		self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

		if self:GetOwner():GetAmmoCount(self.Primary.Ammo) < 1 then
			local targetEnt = self:GetOwner():GetEyeTrace().Entity
			if IsValid(targetEnt) and self:IsTurret(targetEnt) then

				targetEnt:GetTable().Constraints[1]:GetTable().Ent2:Remove()
				targetEnt:Remove()
				
				self:GetOwner():EmitSound( "weapons/iceaxe/iceaxe_swing1.wav")
				self:GetOwner():SetAmmo(1, self.Primary.Ammo)
			else
				self:GetOwner():ChatPrint("Du hast kein weiteres Geschütz dabei.")
				self:GetOwner():EmitSound( "common/wpn_denyselect.wav")
			end
		else
			if (tr.HitWorld and normal > 90 and self:GetOwner():GetPos():DistToSqr(tr.HitPos) < 150*150) then
				local emplacement = ents.Create(self.Emplacement)
				emplacement:SetPos(tr.HitPos + Vector(0, 0, 2))
				emplacement:SetAngles(Angle(0,self:GetOwner():GetAngles().y + 180,0))
				emplacement:Activate()
				emplacement:Spawn()

				self:GetOwner():EmitSound( "weapons/iceaxe/iceaxe_swing1.wav")
				self:GetOwner():SetAmmo(0, self.Primary.Ammo)
			else
				self:GetOwner():ChatPrint("Du kannst das Geschütz nur auf flachen Boden und in deiner Nähe platzieren.")
				self:GetOwner():EmitSound( "common/wpn_denyselect.wav")
			end
		end
	end

	self:SendWeaponAnim( ACT_VM_HITCENTER )

	self:SetNextPrimaryFire( CurTime() + 0.4 )
	self:SetNextSecondaryFire( CurTime() + 0.4 )
end

function SWEP:Think()
	if CLIENT then
		//get trace of weapon
		local tr = self:GetOwner():GetEyeTrace()

		if IsValid(self.ghostProp) then
			self.ghostProp:SetPos(tr.HitPos)
			self.ghostProp:SetAngles(Angle(0, self:GetOwner():GetAngles().y - 90, 0))
			if self:GetOwner():GetAmmoCount(self.Primary.Ammo) > 0 then
				self.ghostProp:SetNoDraw( false )
			else
				self.ghostProp:SetNoDraw( true )
			end
		end
	end
end

function SWEP:PreDrawViewModel()
	if CLIENT then
		if not IsValid(self.ghostProp) then
			self:GhostProp()
		end
	end
end

function SWEP:Holster()
	if CLIENT then
		if IsValid(self.ghostProp) then
			self.ghostProp:Remove()
		end
	end
	return true
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:OnRemove()
	if CLIENT then
		if IsValid(self.ghostProp) then
			self.ghostProp:Remove()
		end
	end
end
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_crosshair.lua:
local size = 0
local clump_inner = Material("arccw/hud/clump_inner.png", "mips smooth")
local clump_outer = Material("arccw/hud/clump_outer.png", "mips smooth")
local aimtr_result = {}
local aimtr = {}
local square_mat = Material("color")

function SWEP:ShouldDrawCrosshair()
    if ArcCW.ConVars["override_crosshair_off"]:GetBool() then return false end
    if !ArcCW.ConVars["crosshair"]:GetBool() then return false end
    if self:GetReloading() then return false end
    if self:BarrelHitWall() > 0 then return false end
    local asight = self:GetActiveSights()

    if !self:GetOwner():ShouldDrawLocalPlayer()
            and self:GetState() == ArcCW.STATE_SIGHTS and !asight.CrosshairInSights then
        return false
    end

    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return false end
    if self:GetCurrentFiremode().Mode == 0 then return false end
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return false end
    if self:GetNWState() == ArcCW.STATE_CUSTOMIZE then return false end
    if self:GetNWState() == ArcCW.STATE_DISABLE then return false end
    return true
end

local cr_main = Color( 0, 255, 0 )
local cr_shad = Color( 0, 0, 0, 127 )

local gaA = 0
local gaD = 0

function SWEP:GetFOVAcc( acc, disp )
    cam.Start3D()
        local lool = ( EyePos() + ( EyeAngles():Forward() ) + ( ( ArcCW.MOAToAcc * (acc or self:GetBuff("AccuracyMOA")) ) * EyeAngles():Up() ) ):ToScreen()
        local lool2 = ( EyePos() + ( EyeAngles():Forward() ) + ( ( (disp or self:GetDispersion()) * ArcCW.MOAToAcc / 10 ) * EyeAngles():Up() ) ):ToScreen()
    cam.End3D()

    local gau = 0
    gau = ( (ScrH() / 2) - lool.y )
    gaA = math.Approach(gaA, gau, (ScrH() / 2) * FrameTime())
    gau = 0
    gau = ( (ScrH() / 2) - lool2.y )
    gaD = math.Approach(gaD, gau, (ScrH() / 2) * FrameTime())

    return gaA, gaD
end

function SWEP:DrawDevCrosshair(x, y)
    surface.SetDrawColor(255, 50, 50, 255)

    surface.DrawLine(x, y - 256, x, y + 256)
    surface.DrawLine(x - 256, y, x + 256, y)


    local gA, gD = self:GetFOVAcc( self:GetBuff("AccuracyMOA"), self:GetDispersion() )
    surface.DrawCircle(x, y, gA + gD, 255, 255, 255, 155)
    surface.DrawCircle(x, y, gA, 255, 255, 0, 55)

    draw.SimpleTextOutlined(math.Round(self:GetDispersion(), 1) .. " MOA", "ArcCW_24_Unscaled", x - gA - gD - 16, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(self:GetBuff("AccuracyMOA"), 1) .. " MOA", "ArcCW_24_Unscaled", x - gA - gD - 16, y, Color(255, 255, 0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))


    local dist = self:GetOwner():GetEyeTrace().HitPos:Distance(self:GetOwner():GetShootPos()) * ArcCW.HUToM
    local rf = self:GetRangeFraction(dist)

    local dmg = math.floor(self:GetDamage(dist))
    draw.SimpleTextOutlined(dmg .. " damage", "ArcCW_24_Unscaled", x + 256, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(dist, 1) .. "m", "ArcCW_24_Unscaled", x + 256 - 64, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(rf * 100) .. "%", "ArcCW_24_Unscaled", x + 256, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))

end

function SWEP:DoDrawCrosshair(x, y)
    local ply = LocalPlayer()
    local pos = ply:EyePos()
    local ang = ply:EyeAngles() - self:GetOurViewPunchAngles() + self:GetFreeAimOffset()

    if self:GetBuff_Hook("Hook_PreDrawCrosshair") then return end

    local static = ArcCW.ConVars["crosshair_static"]:GetBool()

    local prong_dot = ArcCW.ConVars["crosshair_dot"]:GetBool()
    local prong_top = ArcCW.ConVars["crosshair_prong_top"]:GetBool()
    local prong_left = ArcCW.ConVars["crosshair_prong_left"]:GetBool()
    local prong_right = ArcCW.ConVars["crosshair_prong_right"]:GetBool()
    local prong_down = ArcCW.ConVars["crosshair_prong_bottom"]:GetBool()

    local prong_len = ArcCW.ConVars["crosshair_length"]:GetFloat()
    local prong_wid = ArcCW.ConVars["crosshair_thickness"]:GetFloat()
    local prong_out = ArcCW.ConVars["crosshair_outline"]:GetInt()
    local prong_tilt = ArcCW.ConVars["crosshair_tilt"]:GetBool()

    local clr = Color(ArcCW.ConVars["crosshair_clr_r"]:GetInt(),
            ArcCW.ConVars["crosshair_clr_g"]:GetInt(),
            ArcCW.ConVars["crosshair_clr_b"]:GetInt())
    if ArcCW.ConVars["ttt_rolecrosshair"] and ArcCW.ConVars["ttt_rolecrosshair"]:GetBool() then
        if GetRoundState() == ROUND_PREP or GetRoundState() == ROUND_POST then
            clr = Color(255, 255, 255)
        elseif ply.GetRoleColor and ply:GetRoleColor() then
            clr = ply:GetRoleColor() -- TTT2 feature
        elseif ply:IsActiveTraitor() then
            clr = Color(255, 50, 50)
        elseif ply:IsActiveDetective() then
            clr = Color(50, 50, 255)
        else
            clr = Color(50, 255, 50)
        end
    end
    if ArcCW.ConVars["crosshair_aa"]:GetBool() and ply.ArcCW_AATarget != nil and ArcCW.ConVars["aimassist"]:GetBool() and ArcCW.ConVars["aimassist_cl"]:GetBool() then
            -- whooie
        clr = Color(255, 0, 0)
    end
    clr.a = ArcCW.ConVars["crosshair_clr_a"]:GetInt()

    local outlineClr = Color(ArcCW.ConVars["crosshair_outline_r"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_g"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_b"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_a"]:GetInt())

    local gA, gD = self:GetFOVAcc( self:GetBuff("AccuracyMOA"), self:GetDispersion() )
    local gap = (static and 8 or gA + gD) * ArcCW.ConVars["crosshair_gap"]:GetFloat()

    gap = gap + ( ScreenScale(8) * math.Clamp(self.RecoilAmount, 0, 1) )

    local prong = ScreenScale(prong_len)
    local p_w = ScreenScale(prong_wid)
    local p_w2 = p_w + prong_out

    local sp
    if self:GetOwner():ShouldDrawLocalPlayer() then
        local tr = util.GetPlayerTrace(self:GetOwner())
        local trace = util.TraceLine( tr )

        cam.Start3D()
        local coords = trace.HitPos:ToScreen()
        coords.x = math.Round(coords.x)
        coords.y = math.Round(coords.y)
        cam.End3D()
        sp = { visible = true, x = coords.x, y = coords.y }
    end

    cam.Start3D()
    sp = (pos + (ang:Forward() * 3200)):ToScreen()
    cam.End3D()

    if ArcCW.ConVars["crosshair_trueaim"]:GetBool() then
        aimtr.start = self:GetShootSrc()
    else
        aimtr.start = pos
    end

    aimtr.endpos = aimtr.start + ((ply:EyeAngles() + self:GetFreeAimOffset()):Forward() * 100000)
    aimtr.filter = {ply}
    aimtr.output = aimtr_result

    table.Add(aimtr.filter, ArcCW:GetVehicleFilter(ply) or {})

    util.TraceLine(aimtr)

    cam.Start3D()
    local w2s = aimtr_result.HitPos:ToScreen()
    w2s.x = math.Round(w2s.x)
    w2s.y = math.Round(w2s.y)
    cam.End3D()

    sp.x = w2s.x sp.y = w2s.y
    x, y = sp.x, sp.y

    if ArcCW.ConVars["dev_crosshair"]:GetBool() and LocalPlayer():IsAdmin() then
        self:DrawDevCrosshair(x, y)
    end

    local st = self:GetSightTime() / 2

    if self:ShouldDrawCrosshair() then
        self.CrosshairDelta = math.Approach(self.CrosshairDelta or 0, 1, FrameTime() * 1 / st)
    else
        self.CrosshairDelta = math.Approach(self.CrosshairDelta or 0, 0, FrameTime() * 1 / st)
    end

    if ArcCW.ConVars["crosshair_equip"]:GetBool() and (self:GetBuff("ShootEntity", true) or self.PrimaryBash) then
        prong = ScreenScale(prong_wid)
        p_w = ScreenScale(prong_wid)
        p_w2 = p_w + prong_out
    end

    if prong_dot then
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        surface.DrawRect(x - p_w2 / 2, y - p_w2 / 2, p_w2, p_w2)

        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        surface.DrawRect(x - p_w / 2, y - p_w / 2, p_w, p_w)
    end


    size = math.Approach(size, gap, FrameTime() * 32 * gap)
    gap = size
    if !static then gap = gap * self.CrosshairDelta end
    gap = math.max(4, gap)

    local num = self:GetBuff("Num")
    if ArcCW.ConVars["crosshair_shotgun"]:GetBool() and num > 1 then
        prong = ScreenScale(prong_wid)
        p_w = ScreenScale(prong_len)
        p_w2 = p_w + prong_out
    end

    local prong2 = prong + prong_out
    if prong_tilt then
        local angle = (prong_left and prong_top and prong_right and prong_down) and 45 or 30
        local rad = math.rad(angle)
        local dx = gap * math.cos(rad) + prong * math.cos(rad) / 2
        local dy = gap * math.sin(rad) + prong * math.sin(rad) / 2
        surface.SetMaterial(square_mat)
        -- Shade
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        if prong_left and prong_top then
            surface.DrawTexturedRectRotated(x - dx, y - dy, prong2, p_w2, -angle)
            surface.DrawTexturedRectRotated(x + dx, y - dy, prong2, p_w2, angle)
        elseif prong_left or prong_top then
            surface.DrawRect(x - p_w2 / 2, y - gap - prong2 + prong_out / 2, p_w2, prong2)
        end
        if prong_right and prong_down then
            surface.DrawTexturedRectRotated(x + dx, y + dy, prong2, p_w2, -angle)
            surface.DrawTexturedRectRotated(x - dx, y + dy, prong2, p_w2, angle)
        elseif prong_right or prong_down then
            surface.DrawRect(x - p_w2 / 2, y + gap - prong_out / 2, p_w2, prong2)
        end
        -- Fill
        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        if prong_left and prong_top then
            surface.DrawTexturedRectRotated(x - dx, y - dy, prong, p_w, -angle)
            surface.DrawTexturedRectRotated(x + dx, y - dy, prong, p_w, angle)
        elseif prong_left or prong_top then
            surface.DrawRect(x - p_w / 2, y - gap - prong, p_w, prong)
        end
        if prong_right and prong_down then
            surface.DrawTexturedRectRotated(x + dx, y + dy, prong, p_w, -angle)
            surface.DrawTexturedRectRotated(x - dx, y + dy, prong, p_w, angle)
        elseif prong_right or prong_down then
            surface.DrawRect(x - p_w / 2, y + gap, p_w, prong)
        end
    else
        -- Shade
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        if prong_left then
            surface.DrawRect(x - gap - prong2 + prong_out / 2, y - p_w2 / 2, prong2, p_w2)
        end
        if prong_right then
            surface.DrawRect(x + gap - prong_out / 2, y - p_w2 / 2, prong2, p_w2)
        end
        if prong_top then
            surface.DrawRect(x - p_w2 / 2, y - gap - prong2 + prong_out / 2, p_w2, prong2)
        end
        if prong_down then
            surface.DrawRect(x - p_w2 / 2, y + gap - prong_out / 2, p_w2, prong2)
        end
        -- Fill
        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        if prong_left then
            surface.DrawRect(x - gap - prong, y - p_w / 2, prong, p_w)
        end
        if prong_right then
            surface.DrawRect(x + gap, y - p_w / 2, prong, p_w)
        end
        if prong_top then
            surface.DrawRect(x - p_w / 2, y - gap - prong, p_w, prong)
        end
        if prong_down then
            surface.DrawRect(x - p_w / 2, y + gap, p_w, prong)
        end
    end

    if ArcCW.ConVars["crosshair_clump"]:GetBool() and (ArcCW.ConVars["crosshair_clump_always"]:GetBool() or num > 1) then
        local acc = math.max(1, gA)
        if ArcCW.ConVars["crosshair_clump_outline"]:GetBool() then
            surface.SetMaterial(clump_outer)

            for i=1, prong_out do
                surface.DrawCircle(x-1, y-0, acc + math.ceil(i*0.5) * (i % 2 == 1 and 1 or -1), outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
            end
            surface.DrawCircle(x-1, y-0, acc, outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        end

        surface.DrawCircle(x-1, y-0, acc, clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
    end

    self:GetBuff_Hook("Hook_PostDrawCrosshair", w2s)

    return true
end
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_hud.lua:
local translate = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local cvar_deadzonex, cvar_deadzoney
local function CopeX()
    if !cvar_deadzonex then cvar_deadzonex = ArcCW.ConVars["hud_deadzone_x"] end
    return cvar_deadzonex:GetFloat() * ScrW() / 2
end

local function CopeY()
    if !cvar_deadzoney then cvar_deadzoney = ArcCW.ConVars["hud_deadzone_y"] end
    return cvar_deadzoney:GetFloat() * ScrH() / 2
end

local function MyDrawText(tbl)
    local x = tbl.x
    local y = tbl.y
    local dontbust = Color(tbl.col.r, tbl.col.g, tbl.col.b, tbl.col.a)
    surface.SetFont(tbl.font)

    if tbl.alpha then
        dontbust.a = tbl.alpha
    else
        dontbust.a = 255
    end

    if tbl.align or tbl.yalign then
        local w, h = surface.GetTextSize(tbl.text)
        if tbl.align == 1 then
            x = x - w
        elseif tbl.align == 2 then
            x = x - (w / 2)
        end
        if tbl.yalign == 1 then
            y = y - h
        elseif tbl.yalign == 2 then
            y = y - h / 2
        end
    end

    if tbl.shadow then
        surface.SetTextColor(Color(0, 0, 0, tbl.alpha or 255))
        surface.SetTextPos(x, y)
        surface.SetFont(tbl.font .. "_Glow")
        surface.DrawText(tbl.text)
    end

    surface.SetTextColor(dontbust)
    surface.SetTextPos(x, y)
    surface.SetFont(tbl.font)
    surface.DrawText(tbl.text)
end

local vhp = 0
local varmor = 0
local vclip = 0
local vreserve = 0
local vclip2 = 0
local vreserve2 = 0
local vubgl = 0
local lastwpn = ""
local lastinfo = {ammo = 0, clip = 0, firemode = "", plus = 0}
local lastinfotime = 0

function SWEP:GetHUDData()
    local data = {
        clip = math.Round(vclip or self:Clip1()),
        ammo = math.Round(vreserve or self:Ammo1()),
        bars = self:GetFiremodeBars(),
        mode = self:GetFiremodeName(),
        ammotype = self.Primary.Ammo,
        ammotype2 = self.Secondary.Ammo,
        heat_enabled        = self:HeatEnabled(),
        heat_name           = translate("ui.heat"),
        heat_level          = self:GetHeat(),
        heat_maxlevel       = self:GetMaxHeat(),
        heat_locked         = self:GetHeatLocked(),
    }

    if data.clip > self:GetCapacity() then
        data.plus = data.clip - self:GetCapacity()
        data.clip = self:GetCapacity()
    end

    local infammo, btmless = self:HasInfiniteAmmo(), self:HasBottomlessClip()
    data.infammo = infammo
    data.btmless = btmless

    if self.PrimaryBash or self:Clip1() == -1 or self:GetCapacity() == 0 or self.Primary.ClipSize == -1 then
        data.clip = "-"
    end
    if self.PrimaryBash then
        data.ammo = "-"
    end

    if self:GetBuff_Override("UBGL") then
        data.clip2 = math.Round(vclip2 or self:Clip2())

        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            data.ammo2 = tostring(math.Round(vreserve2 or self:GetOwner():GetAmmoCount(ubglammo)))
        end

        if data.clip2 > self:GetBuff_Override("UBGL_Capacity") then
            data.plus2 = (data.clip2 - self:GetBuff_Override("UBGL_Capacity"))
            data.clip2 = self:GetBuff_Override("UBGL_Capacity")
        end
    end

    do
        if infammo then
            data.ammo = btmless and data.ammo or "-"
            data.clip = self.Throwing and "∞" or data.clip
        end
        if btmless then
            data.clip = infammo and "∞" or data.ammo
            data.ammo = "-"
        end

        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            data.ubgl = self:Clip2() + self:GetOwner():GetAmmoCount(ubglammo)
        end
    end

    data = self:GetBuff_Hook("Hook_GetHUDData", data) or data

    return data
end

local t_states = {
    [0] = "STATE_IDLE",
    [1] = "STATE_SIGHTS",
    [2] = "STATE_SPRINT",
    [3] = "STATE_DISABLE",
    [4] = "STATE_CUSTOMIZE",
    [5] = "STATE_BIPOD"
}

local mr = math.Round
local bird = Material("arccw/hud/really cool bird.png", "mips smooth")
local statlocked = Material("arccw/hud/locked_32.png", "mips smooth")

local bar_fill = Material("arccw/hud/fmbar_filled.png",           "mips smooth")
local bar_outl = Material("arccw/hud/fmbar_outlined.png",         "mips smooth")
local bar_shad = Material("arccw/hud/fmbar_shadow.png",           "mips smooth")
local bar_shou = Material("arccw/hud/fmbar_outlined_shadow.png",  "mips smooth")

local hp = Material("arccw/hud/hp.png", "smooth")
local hp_shad = Material("arccw/hud/hp_shadow.png", "mips smooth")

local armor = Material("arccw/hud/armor.png", "mips smooth")
local armor_shad = Material("arccw/hud/armor_shadow.png", "mips smooth")
local ubgl_mat = Material("arccw/hud/ubgl.png", "smooth")
local bipod_mat = Material("arccw/hud/bipod.png", "smooth")

local function debug_panel(self)
    local reloadtime = self:GetReloadTime()
    local s = ScreenScaleMulti(1)
    local thestate = self:GetState()
    local ecksy = s * 64

    if thestate == ArcCW.STATE_CUSTOMIZE then
        ecksy = s * 256
    elseif thestate == ArcCW.STATE_SIGHTS then
        surface.SetDrawColor(255, 50, 50, 150)
        surface.DrawLine(ScrW() / 2, ScrH() * 0.5 - 256, ScrW() / 2, ScrH() * 0.5 + 256)
        surface.DrawLine(ScrW() * 0.5 - 256, ScrH() / 2, ScrW() * 0.5 + 256, ScrH() / 2)
    end

    surface.SetFont("ArcCW_26")
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetDrawColor(0, 0, 0, 63)

    -- it's for contrast, i promise
    surface.SetMaterial(bird)
    surface.DrawTexturedRect(ecksy - s-400, s-320, s * 512, s * 512)

    surface.SetDrawColor(255, 255, 255, 255)
    if reloadtime then
        surface.SetTextPos(ecksy, 26 * s * 1)
        surface.DrawText(math.Round(reloadtime[1], 2))

        surface.SetTextPos(ecksy, 26 * s * 2)
        surface.DrawText(math.Round(reloadtime[2], 2))

        surface.SetTextPos(ecksy, 26 * s * 3)
        if self:GetMagUpIn() - CurTime() > 0 then
            surface.SetTextColor(255, 127, 127, 255)
        end
        surface.DrawText( mr( math.max( self:GetMagUpIn() - CurTime(), 0 ), 2) )
    else
        surface.SetFont("ArcCW_20")
        surface.SetTextPos(ecksy, 26 * s * 2)
        surface.DrawText("NO RELOAD ANIMATION")

        surface.SetFont("ArcCW_12")
        surface.SetTextPos(ecksy, 26 * s * 2.66)
        surface.DrawText("not a mag fed one, at least...")
    end
    surface.SetTextPos(ecksy + (s*36*3), 26 * s * 3)
    if self:GetReloadingREAL() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.DrawText( mr( math.max( self:GetReloadingREAL() - CurTime(), 0 ), 2) )
    surface.SetFont("ArcCW_26")
    surface.SetTextColor(255, 255, 255, 255)

    local delay = math.max(self:GetReloadingREAL(), self:GetNWPriorityAnim())
    if delay - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 4)
    surface.DrawText( mr( math.max( delay - CurTime(), 0 ), 2 ) )
    surface.SetTextColor(255, 255, 255, 255)

    if self:GetWeaponOpDelay() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 5)
    surface.DrawText( mr( math.max( self:GetWeaponOpDelay() - CurTime(), 0 ), 2 ) )
    surface.SetTextColor(255, 255, 255, 255)

    if self:GetNextPrimaryFire() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 6)
    surface.DrawText( mr( math.max( self:GetNextPrimaryFire() * 1000 - CurTime() * 1000, 0 ), 0 ) .. "ms" )
    surface.SetTextColor(255, 255, 255, 255)

    local seq = self:GetSequenceInfo( self:GetOwner():GetViewModel():GetSequence() )
    local seq2 = self:GetOwner():GetViewModel():GetSequence()
    local seq3 = self:GetOwner():GetViewModel()
    surface.SetFont("ArcCW_20")
    surface.SetTextPos(ecksy, 26 * s * 7)
    surface.DrawText( seq2 .. ", " .. seq.label )

    local proggers = 1 - ( self.LastAnimFinishTime - CurTime() ) / seq3:SequenceDuration()

    surface.SetTextPos(ecksy, 26 * s * 8)
    surface.SetFont("ArcCW_12")
    surface.DrawText( mr( seq3:SequenceDuration() * proggers, 2 ) )

    surface.SetTextPos(ecksy + s * 30, 26 * s * 8)
    surface.DrawText( "-" )

    surface.SetTextPos(ecksy + s * 48, 26 * s * 8)
    surface.DrawText( mr( self:SequenceDuration( seq2 ), 2 ) )

    surface.SetTextPos(ecksy + s * 132, 26 * s * 7.6)
    surface.DrawText( mr(proggers * 100) .. "%" )

    -- welcome to the bar
    surface.DrawOutlinedRect(ecksy, 26 * s * 7.7, s * 128, s * 8, s)
    surface.DrawRect(ecksy, 26 * s * 7.7 + s * 2, s * 128 * math.Clamp(proggers, 0, 1), s * 8-s * 4, s)

    surface.SetFont("ArcCW_20")
    surface.SetTextPos(ecksy, 26 * s * 8.5)
    surface.DrawText( t_states[thestate] )

    surface.SetTextPos(ecksy, 26 * s * 9.25)
    surface.DrawText( mr(self:GetSightDelta() * 100) .. "%" )

    surface.DrawOutlinedRect(ecksy, 26 * s * 10, s * 64, s * 4, s / 2)
    surface.DrawRect(ecksy, 26 * s * 10 + s * 1, s * 64 * self:GetSightDelta(), s * 4-s * 2)

    surface.DrawOutlinedRect(ecksy, 26 * s * 10.25, s * 64, s * 4, s / 2)
    surface.DrawRect(ecksy, 26 * s * 10.25 + s * 1, s * 64 * self:GetSprintDelta(), s * 4-s * 2)


    surface.SetTextPos(ecksy, 26 * s * 11)
    surface.DrawText( mr(self:GetHolster_Time(), 1) )

    surface.SetTextPos(ecksy, 26 * s * 12)
    surface.DrawText( tostring(self:GetHolster_Entity()) )

    -- Labels
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("ArcCW_8")

    if reloadtime then
        surface.SetTextPos(ecksy, 26 * s * 1)
        surface.DrawText("RELOAD")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 1.33)
        surface.DrawText("FULL")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 2.33)
        surface.DrawText("MAGIN")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 3.33)
        surface.DrawText("MAG LOAD")
    end

    surface.SetTextPos(ecksy- s * (36 * -2), s * 26 * 3.33)
    surface.DrawText("RELOAD TIME")

    surface.SetTextPos(ecksy, 26 * s * 4)
    surface.DrawText("PRIORITY DELAY")

    surface.SetTextPos(ecksy, 26 * s * 5)
    surface.DrawText("WEAPON OPERATION DELAY")

    surface.SetTextPos(ecksy, 26 * s * 6)
    surface.DrawText("NEXT PRIMARY FIRE")

    surface.SetTextPos(ecksy, 26 * s * 7)
    surface.DrawText("CURRENT ANIMATION")

    surface.SetTextPos(ecksy, 26 * s * 8.5)
    surface.DrawText("WEAPON STATE")

    surface.SetTextPos(ecksy, 26 * s * 9.25)
    surface.DrawText("SIGHT DELTA")

    surface.SetTextPos(ecksy, 26 * s * 11)
    surface.DrawText("HOLSTER TIME")

    surface.SetTextPos(ecksy, 26 * s * 12)
    surface.DrawText("HOLSTER ENT")

    -- lhik timeline
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("ArcCW_8")
    surface.SetDrawColor(255, 255, 255, 11)
    surface.DrawRect(s * 8, s * 8, ScrW() - (s * 16), s * 2)

    local texy = math.Round(CurTime(),1)
    local a, b = surface.GetTextSize(texy)
    surface.SetTextPos((ScrW() / 2) - (a / 2), (s * 16) - (b / 2))
    surface.DrawText(texy)

    surface.SetDrawColor(255, 255, 255, 127)
    if self.LHIKTimeline then for i, v in pairs(self.LHIKTimeline) do

        local pox = ScrW() / 2
        local poy = (s * 7)

        local zo = s * 0.01

        local dist = self.LHIKStartTime + v.t

        surface.DrawRect(pox + (dist * zo), poy, s * 8, s * 4)

        texy = math.Round(dist,1)
        a, b = surface.GetTextSize(texy)
        surface.SetTextPos(pox + (dist * zo) - (a / 2), (s * 16) - (b / 2) )
        surface.DrawText(texy)
    end end
end

function SWEP:DrawHUD()
    if ArcCW.ConVars["dev_debug"]:GetBool() then
        debug_panel(self)
    end

    if ArcCW.ConVars["dev_benchgun"]:GetBool() then
        draw.SimpleTextOutlined("BENCHGUN ENABLED", "ArcCW_26", ScrW() / 2, ScreenScaleMulti(4), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 2, Color(0, 0, 0))
        draw.SimpleTextOutlined("VIEWMODEL POSITION MOVED", "ArcCW_16", ScrW() / 2, ScreenScaleMulti(30), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 2, Color(0, 0, 0))
    end

    if !GetConVar("cl_drawhud"):GetBool() then return false end

    if self:GetState() != ArcCW.STATE_CUSTOMIZE then
        self:GetBuff_Hook("Hook_DrawHUD")
    end

    local col2 = Color(255, 255, 255, 255)
    local col3 = Color(255, 0, 0, 255)

    local airgap = ScreenScaleMulti(8)

    local apan_bg = {
        w = ScreenScaleMulti(128),
        h = ScreenScaleMulti(48),
    }

    local data = self:GetHUDData()

    if data.heat_locked then
        col2 = col3
    end

    local curTime = CurTime()
    --local mode = self:GetFiremodeName()

    local muzz = self:GetBuff_Override("Override_MuzzleEffectAttachment") or self.MuzzleEffectAttachment or 1

    local fmbars = ArcCW.ConVars["hud_fcgbars"]:GetBool() and string.len( self:GetFiremodeBars() or "-----" ) != 0

    if ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        local decaytime = GetConVar("arccw_hud_3dfun_decaytime"):GetFloat()
        if decaytime == 0 then decaytime = math.huge end
        local visible = (lastinfotime + decaytime + 1 > curTime or lastinfotime - 0.5 > curTime)

        -- Detect changes to stuff drawn in HUD
        local curInfo = {
            ammo = data.ammo,
            clip = data.clip,
            plus = data.plus or "0", -- data.plus is nil when it doesnt exist
            ammo2 = data.ammo2,
            clip2 = data.clip2,
            plus2 = data.plus2 or "0", -- data.plus is nil when it doesnt exist
            ammotype = data.ammotype,
            firemode = data.mode,
            heat = data.heat_level,
            self:GetInUBGL(),
            self:GetInBipod(),
            self:CanBipod(),
        }
        if GetConVar("arccw_hud_3dfun_lite"):GetBool() then
            curInfo.clip = nil
            curInfo.plus = nil
            curInfo.clip2 = nil
            curInfo.plus2 = nil
            curInfo.heat = nil
        end
        for i, v in pairs(curInfo) do
            if v != lastinfo[i] then
                lastinfotime = visible and (curTime - 0.5) or curTime
                lastinfo = curInfo
                break
            end
        end
        local qss = ScreenScaleMulti(24)
        local correct_y = 28
        local correct_x = 0
        if !GetConVar("arccw_hud_3dfun"):GetBool() then
            qss = ScreenScaleMulti(-24)
            correct_y = -36
            correct_x = 52
        end

        -- TODO: There's an issue where this won't ping the HUD when switching in from non-ArcCW weapons
        if LocalPlayer():KeyDown(IN_RELOAD) or lastwpn != self then lastinfotime = visible and (curTime - 0.5) or curTime end

        local alpha
        if lastinfotime + decaytime < curTime then
            alpha = 255 - (curTime - lastinfotime - decaytime) * 255
        elseif lastinfotime + 0.5 > curTime then
            alpha = 255 - (lastinfotime + 0.5 - curTime) * 255
        else
            alpha = 255
        end

        if alpha > 0 then

            local EyeAng = EyeAngles()

            local angpos
            if GetConVar("arccw_hud_3dfun"):GetBool() and self:GetOwner():ShouldDrawLocalPlayer() then
                local bone = "ValveBiped.Bip01_R_Hand"
                local ind = self:GetOwner():LookupBone(bone)

                if ind and ind > -1 then
                    local p, a = self:GetOwner():GetBonePosition(ind)
                    angpos = {Ang = a, Pos = p}
                end
            elseif GetConVar("arccw_hud_3dfun"):GetBool() then
                local vm = self:GetOwner():GetViewModel()

                if vm and vm:IsValid() then
                    angpos = vm:GetAttachment(muzz)
                end
            end

            if GetConVar("arccw_hud_3dfun"):GetBool() and angpos then

                angpos.Pos = angpos.Pos - EyeAng:Up() * GetConVar("arccw_hud_3dfun_up"):GetFloat() - EyeAng:Right() * GetConVar("arccw_hud_3dfun_right"):GetFloat() - EyeAng:Forward() * GetConVar("arccw_hud_3dfun_forward"):GetFloat()
                cam.Start3D()
                    local toscreen = angpos.Pos:ToScreen()
                cam.End3D()

                apan_bg.x = toscreen.x - apan_bg.w - ScreenScaleMulti(8)
                apan_bg.y = toscreen.y - apan_bg.h * 0.5
            else
                apan_bg.x = ScrW() - CopeX() - ScreenScaleMulti(128 + 8)
                apan_bg.y = ScrH() - CopeY() - ScreenScaleMulti(48)
            end

            apan_bg.x = math.Clamp(apan_bg.x, ScreenScaleMulti(8), ScrW() - CopeX() - ScreenScaleMulti(128 + 8))
            apan_bg.y = math.Clamp(apan_bg.y, ScreenScaleMulti(8), ScrH() - CopeY() - ScreenScaleMulti(48))

            if !fmbars then
                apan_bg.y = apan_bg.y + ScreenScaleMulti(6)
            end

            local corny = 22 * math.ease.OutSine(math.sin(vubgl * math.pi)) * (self:GetInUBGL() and -1 or 1)
            local ngap = 22 * vubgl
            local wammo = {
                x = apan_bg.x + apan_bg.w - airgap + ScreenScaleMulti(corny),
                y = apan_bg.y - ScreenScaleMulti(4) - ScreenScaleMulti(ngap),
                text = tostring(data.clip),
                font = "ArcCW_26",
                col = col2,
                align = 1,
                shadow = true,
                alpha = alpha,
            }

            wammo.col = col2

            if data.clip == 0 then
                wammo.col = col3
            end

            if tostring(data.clip) == "-" then
                wammo.text = ""
            end
                MyDrawText(wammo)
                wammo.w, wammo.h = surface.GetTextSize(wammo.text)
            surface.SetFont("ArcCW_26")

            if data.plus and !self:HasBottomlessClip() then
                local wplus = {
                    x = wammo.x,
                    y = wammo.y,
                    text = "+" .. tostring(data.plus),
                    font = "ArcCW_16",
                    col = col2,
                    shadow = true,
                    alpha = alpha,
                }

                MyDrawText(wplus)
            end

            local wreserve = {
                x = wammo.x - wammo.w - ScreenScaleMulti(4),
                y = apan_bg.y + ScreenScaleMulti(10) - ScreenScaleMulti(ngap),
                text = tostring(data.ammo) .. " /",
                font = "ArcCW_12",
                col = col2,
                align = 1,
                yalign = 2,
                shadow = true,
                alpha = alpha,
            }

            if tonumber(data.ammo) and tonumber(data.clip) and tonumber(data.clip) >= self:GetCapacity() then
                wreserve.text = tostring(data.ammo) .. " |"
            end

            if self:GetPrimaryAmmoType() <= 0 then
                wreserve.text = "!"
            end

            if self.PrimaryBash then
                wreserve.text = ""
            end

            local drew = false
            local ungl = false
            if tostring(data.ammo) != "-" then
                drew = true
                MyDrawText(wreserve)
                surface.SetFont("ArcCW_12")
                wreserve.w, wreserve.h = surface.GetTextSize(wreserve.text)
            end

            if GetConVar("arccw_hud_3dfun_ammotype"):GetBool() and isstring(data.ammotype) then
                local wammotype = {
                    x = wammo.x - wammo.w - ScreenScaleMulti(3),
                    y = wammo.y + (wammo.h/2),
                    text = language.GetPhrase(data.ammotype .. "_ammo"),
                    font = "ArcCW_8",
                    col = col2,
                    align = 1,
                    yalign = 2,
                    shadow = true,
                    alpha = alpha,
                }

                if drew then
                    wammotype.x = wreserve.x - wreserve.w - ScreenScaleMulti(3)
                    wammotype.y = wreserve.y-- + (wreserve.h/2)
                end

                MyDrawText(wammotype)
            end

            --ubgl
            if self:GetBuff_Override("UBGL") then
                ungl = true
                local ugap = 22 * (1-vubgl)

                local wammo = {
                    x = apan_bg.x + apan_bg.w - airgap + ScreenScaleMulti(corny*-1),
                    y = apan_bg.y - ScreenScaleMulti(4) - ScreenScaleMulti(ugap),
                    text = tostring(data.clip2),
                    font = "ArcCW_26",
                    col = col2,
                    align = 1,
                    shadow = true,
                    alpha = alpha,
                }

                wammo.col = col2

                if data.clip2 == 0 then
                    wammo.col = col3
                end

                if tostring(data.clip2) != "-" then
                    MyDrawText(wammo)
                end
                surface.SetFont("ArcCW_26")
                wammo.w, wammo.h = surface.GetTextSize(wammo.text)

                if data.plus2 and !self:HasBottomlessClip() then
                    local wplus = {
                        x = wammo.x,
                        y = wammo.y,
                        text = "+" .. tostring(data.plus2),
                        font = "ArcCW_16",
                        col = col2,
                        shadow = true,
                        alpha = alpha,
                    }

                    MyDrawText(wplus)
                end

                local wreserve = {
                    x = wammo.x - wammo.w - ScreenScaleMulti(4),
                    y = apan_bg.y + ScreenScaleMulti(10) - ScreenScaleMulti(ugap),
                    text = tostring(data.ammo2) .. " /",
                    font = "ArcCW_12",
                    col = col2,
                    align = 1,
                    yalign = 2,
                    shadow = true,
                    alpha = alpha,
                }

                if tonumber(data.ammo2) and tonumber(data.clip2) and tonumber(data.clip2) >= self:GetBuff_Override("UBGL_Capacity") then
                    wreserve.text = tostring(data.ammo2) .. " |"
                end

                if self:GetSecondaryAmmoType() <= 0 then
                    wreserve.text = "!"
                end

                local drew = false
                if tostring(data.ammo2) != "-" then
                    drew = true
                    MyDrawText(wreserve)
                    surface.SetFont("ArcCW_12")
                    wreserve.w, wreserve.h = surface.GetTextSize(wreserve.text)
                end

                if GetConVar("arccw_hud_3dfun_ammotype"):GetBool() and isstring(data.ammotype) then
                    local wammotype = {
                        x = wammo.x - wammo.w - ScreenScaleMulti(3),
                        y = wammo.y + (wammo.h/2),
                        text = language.GetPhrase(data.ammotype2 .. "_ammo"),
                        font = "ArcCW_8",
                        col = col2,
                        align = 1,
                        yalign = 2,
                        shadow = true,
                        alpha = alpha,
                    }

                    if drew then
                        wammotype.x = wreserve.x - wreserve.w - ScreenScaleMulti(3)
                        wammotype.y = wreserve.y
                    end

                    MyDrawText(wammotype)
                end
            end

            local wmode = {
                x = apan_bg.x + apan_bg.w - airgap,
                y = apan_bg.y + ScreenScaleMulti(28),
                font = "ArcCW_12",
                text = data.mode,
                col = col2,
                align = 1,
                shadow = true,
                alpha = alpha,
            }
            if !fmbars then
                wmode.y = wmode.y - ScreenScaleMulti(6)
            end
            MyDrawText(wmode)

            -- overheat bar 3d
            if self:GetMalfunctionJam() then
                local col = Color(255, 0, 32)

                local wheat = { --cheeeeerios
                    x = apan_bg.x + apan_bg.w - airgap,
                    y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 1 ),
                    font = "ArcCW_12",
                    text = translate("ui.jammed"),
                    col = col,
                    align = 1,
                    shadow = true,
                    alpha = alpha,
                }
                if fmbars then
                    wheat.y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 0.8 )
                end
                if ungl then
                    wheat.y = wheat.y - ScreenScaleMulti(24)
                end

                local wheat_shad = {
                    x = wheat.x,
                    y = wheat.y,
                    font = "ArcCW_12_Glow",
                    text = wheat.text,
                    col = col,
                    align = 1,
                    shadow = false,
                    alpha = alpha,
                }
                MyDrawText(wheat_shad)

                MyDrawText(wheat)
            elseif data.heat_enabled then
                local pers = math.Clamp(1 - (data.heat_level / data.heat_maxlevel), 0, 1)
                local pers2 = math.Clamp(data.heat_level / data.heat_maxlevel, 0, 1)
                local colheat1 = data.heat_locked and Color(255, 0, 0) or Color(255, 128 + 127 * pers, 128 + 127 * pers)
                local colheat2 = data.heat_locked and Color(255, 0, 0) or Color(255 * pers2, 0, 0)

                local wheat = {
                    x = apan_bg.x + apan_bg.w - airgap,
                    y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 1 ),
                    font = "ArcCW_12",
                    text = data.heat_name .. " " .. tostring(math.floor(100 * data.heat_level / data.heat_maxlevel)) .. "%",
                    col = colheat1,
                    align = 1,
                    shadow = false,
                    alpha = alpha,
                }
                if fmbars then
                    wheat.y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 0.8 )
                end
                if ungl then
                    wheat.y = wheat.y - ScreenScaleMulti(24)
                end

                local wheat_shad = {
                    x = wheat.x,
                    y = wheat.y,
                    font = "ArcCW_12_Glow",
                    text = wheat.text,
                    col = colheat2,
                    align = 1,
                    shadow = false,
                    alpha = alpha * pers,
                }
                MyDrawText(wheat_shad)

                MyDrawText(wheat)
            end
            if self:CanBipod() or self:GetInBipod() then
                local size = ScreenScaleMulti(32)
                local awesomematerial = self:GetBuff_Override("Bipod_Icon", bipod_mat)
                local whatsthecolor =   self:GetInBipod() and     Color(255, 255, 255, alpha) or
                                        self:CanBipod() and   Color(255, 255, 255, alpha / 4) or Color(0, 0, 0, 0)
                local bar = {
                    w = size,
                    h = size,
                    x = (ScrW()/2) - (size/2),
                    y = ScrH() - CopeY() - ScreenScaleMulti(40),
                }
                surface.SetDrawColor( whatsthecolor )
                surface.SetMaterial( awesomematerial )
                surface.DrawTexturedRect( bar.x, bar.y, bar.w, bar.h )

                local txt = string.upper(ArcCW:GetBind("+use"))

                local bip = {
                    shadow = true,
                    x = bar.x + (bar.w/2),
                    y = bar.y - ScreenScaleMulti(12),
                    align = 2,
                    font = "ArcCW_12",
                    text = txt,
                    col = whatsthecolor,
                    alpha = alpha,
                }

                MyDrawText(bip)
            end

            if ArcCW.ConVars["hud_togglestats"] and ArcCW.ConVars["hud_togglestats"]:GetBool() then
            local items = {
            }
            --[[
            {
                Icon = "",
                Locked = false,
                Selected = 1,
                Toggles = {
                    [1] = "",
                    [2] = "",
                    [3] = "",
                }
            }
            ]]

            for k, v in pairs(self.Attachments) do
                local atttbl = v.Installed and ArcCW.AttachmentTable[v.Installed]
                if atttbl and atttbl.ToggleStats then-- and !v.ToggleLock then
                    --print(atttbl.PrintName)
                    local item = {
                        Icon = atttbl.Icon,
                        Locked = v.ToggleLock,
                        Selected = v.ToggleNum,
                        Toggles = {}
                    }
                    for i, h in ipairs(atttbl.ToggleStats) do
                        table.insert(item.Toggles, h.PrintName)
                        --print("\t" .. (v.ToggleNum == i and "> " or "") .. atttbl.ToggleStats[i].PrintName .. (v.ToggleNum == i and " <" or ""))
                    end
                    table.insert(items, item)
                end
            end

            for i=1, 0 do
                table.insert(items, {
                    Icon = Material("Test"),
                    Locked = false,
                    Selected = i,
                    Toggles = {
                        "Test",
                        "Test",
                        "Test",
                        "Test",
                        "Test",
                    }
                })
            end

            do
                local size = ScreenScaleMulti(28)
                local lock = ScreenScaleMulti(7)
                local shiit = 1.5
                local gaap = ScreenScaleMulti(7) -- 32 / 8
                if #items == 1 then
                    gaap = 0
                    shiit = 1
                end
                for index, item in ipairs(items) do
                    surface.SetMaterial(item.Icon or bird)
                    surface.SetDrawColor(color_white)

                    local px, py = (ScrW()/2) - ((size*shiit)*(index-(#items*0.5))) + gaap, (ScrH()-CopeY()-(size*1.25))
                    surface.DrawTexturedRect(px, py, size, size)

                    if item.Locked then
                        surface.SetMaterial(statlocked)
                        surface.DrawTexturedRect(px + (size/2) - (lock/2), py + size - (lock/2), lock, lock)
                    end

                    for tdex, tinfo in ipairs(item.Toggles) do
                        local infor = {
                            x = px + (size*0.5),
                            y = py - (#item.Toggles * ScreenScaleMulti(8)) + (tdex * ScreenScaleMulti(8)),
                            font = "ArcCW_8",
                            text = tinfo,
                            col = col2,
                            align = 2,
                            yalign = 1,
                            shadow = true,
                            alpha = alpha * (tdex == item.Selected and 1 or 0.25),
                        }
                        MyDrawText(infor)
                    end
                end
            end
            end

            if fmbars then
                local segcount = string.len( self:GetFiremodeBars() or "-----" )
                local bargap = ScreenScaleMulti(2)
                local bart = {
                    w = (ScreenScaleMulti(100) + ((segcount + 1) * bargap)) / segcount,
                    h = ScreenScaleMulti(8),
                    x = apan_bg.x + apan_bg.w,
                    y = apan_bg.y + apan_bg.h
                }

                bart.x = bart.x - ((bart.w / 2 + bargap) * segcount) - ScreenScaleMulti(4) - (bart.w / 4)
                bart.y = bart.y - ScreenScaleMulti(28)

                for i = 1, segcount do
                    local c = data.bars[i]

                    if c == "#" then continue end

                    if c != "!" and c != "-" then
                        surface.SetMaterial(bar_shou)
                    else
                        surface.SetMaterial(bar_shad)
                    end
                    surface.SetDrawColor(255, 255, 255, 255 / 5 * 3)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)

                    if c == "-" then
                        -- good ol filled
                        surface.SetMaterial(bar_fill)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    elseif c == "!" then
                        surface.SetMaterial(bar_fill)
                        surface.SetDrawColor(col3)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                        surface.SetMaterial(bar_outl)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    else
                        -- good ol outline
                        surface.SetMaterial(bar_outl)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    end

                    bart.x = bart.x + (bart.w / 2 + bargap)
                end
            end
        end
    elseif !ArcCW.ConVars["override_hud_off"]:GetBool() and ArcCW.ConVars["hud_minimal"]:GetBool() then
        if fmbars then
            local segcount = string.len( self:GetFiremodeBars() or "-----" )
            local bargap = ScreenScaleMulti(2)
            local bart = {
                w = (ScreenScaleMulti(256) - ((segcount + 1) * bargap)) / segcount,
                h = ScreenScaleMulti(8),
                x = ScrW() / 2,
                y = ScrH() - ScreenScaleMulti(24)
            }

            bart.x = bart.x - ((bart.w / 4) * segcount) - bart.w / 3.5 - bargap

            for i = 1, segcount do
                local c = data.bars[i]

                if c == "#" then continue end

                if c != "!" and c != "-" then
                    surface.SetMaterial(bar_shou)
                else
                    surface.SetMaterial(bar_shad)
                end
                surface.SetDrawColor(255, 255, 255, 255 / 5 * 3)
                surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)

                if c == "-" then
                    -- good ol filled
                    surface.SetMaterial(bar_fill)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                elseif c == "!" then
                    surface.SetMaterial(bar_fill)
                    surface.SetDrawColor(col3)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    surface.SetMaterial(bar_outl)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                else
                    -- good ol outline
                    surface.SetMaterial(bar_outl)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                end

                bart.x = bart.x + (bart.w / 2) + bargap
            end
        end
        local wmode = {
            x = ScrW() / 2,
            y = ScrH() - ScreenScaleMulti(34),
            font = "ArcCW_12",
            text = data.mode,
            col = col2,
            align = 2,
            shadow = true,
            alpha = alpha,
        }
        MyDrawText(wmode)

        if self:GetBuff_Override("UBGL") then
            local size = ScreenScaleMulti(32)
            local awesomematerial = self:GetBuff_Override("UBGL_Icon", ubgl_mat)
            local whatsthecolor = self:GetInUBGL() and  Color(255, 255, 255, 255) or
                                                    Color(255, 255, 255, 0)
            local bar2 = {
                w = size,
                h = size,
                x = ScrW() / 2 + ScreenScaleMulti(32),
                y = ScrH() - ScreenScaleMulti(52),
            }
            surface.SetDrawColor( whatsthecolor )
            surface.SetMaterial( awesomematerial )
            surface.DrawTexturedRect( bar2.x, bar2.y, bar2.w, bar2.h )
        end

        if self:CanBipod() or self:GetInBipod() then
            local size = ScreenScaleMulti(32)
            local awesomematerial = self:GetBuff_Override("Bipod_Icon", bipod_mat)
            local whatsthecolor =   self:GetInBipod() and   Color(255, 255, 255, 255) or
                                    self:CanBipod() and     Color(255, 255, 255, 127) or
                                                            Color(255, 255, 255, 0)
            local bar2 = {
                w = size,
                h = size,
                x = ScrW() / 2 - ScreenScaleMulti(64),
                y = ScrH() - ScreenScaleMulti(52),
            }
            surface.SetDrawColor( whatsthecolor )
            surface.SetMaterial( awesomematerial )
            surface.DrawTexturedRect( bar2.x, bar2.y, bar2.w, bar2.h )

            local txt = string.upper(ArcCW:GetBind("+use"))

            local bip = {
                shadow = true,
                x = ScrW() / 2 - ScreenScaleMulti(64),
                y = ScrH() - ScreenScaleMulti(52),
                font = "ArcCW_12",
                text = txt,
                col = whatsthecolor,
            }

            MyDrawText(bip)
        end

        if data.heat_enabled then
            surface.SetDrawColor(col2)
            local perc = data.heat_level / data.heat_maxlevel

            local bar = {
                x = 0,
                y = ScrH() - ScreenScaleMulti(22)
            }

            surface.DrawOutlinedRect(ScrW() / 2 - ScreenScaleMulti(62), bar.y + ScreenScaleMulti(4.5), ScreenScaleMulti(124), ScreenScaleMulti(3))
            surface.DrawRect(ScrW() / 2 - ScreenScaleMulti(62), bar.y + ScreenScaleMulti(4.5), ScreenScaleMulti(124) * perc, ScreenScaleMulti(3))

            surface.SetFont("ArcCW_8")
            local bip = {
                shadow = false,
                x = (ScrW() / 2) - (surface.GetTextSize(data.heat_name) / 2),
                y = bar.y + ScreenScaleMulti(8),
                font = "ArcCW_8",
                text = data.heat_name,
                col = col2,
            }

            MyDrawText(bip)
        end
    end

    -- health + armor

    if ArcCW:ShouldDrawHUDElement("CHudHealth") then

        local colhp = Color(255, 255, 255, 255)
        local gotarmor = false

        if LocalPlayer():Armor() > 0 then
            gotarmor = true
            local armor_s = ScreenScaleMulti(10)
            local war = {
                x = airgap + CopeX() + armor_s + ScreenScaleMulti(6),
                y = ScrH() - ScreenScaleMulti(16) - airgap - CopeY(),
                font = "ArcCW_16",
                text = tostring(math.Round(varmor)),
                col = Color(255, 255, 255, 255),
                shadow = true,
                alpha = alpha
            }

            local armor_x = war.x - armor_s - ScreenScaleMulti(4)
            local armor_y = war.y + ScreenScaleMulti(4)

            surface.SetMaterial(armor_shad)
            surface.SetDrawColor(0, 0, 0, 255)
            surface.DrawTexturedRect(armor_x, armor_y, armor_s, armor_s)

            surface.SetMaterial(armor)
            surface.SetDrawColor(colhp)
            surface.DrawTexturedRect(armor_x, armor_y, armor_s, armor_s)

            MyDrawText(war)
        end

        local hpicon_s = ScreenScaleMulti(16)
        local hpicon_x = airgap + CopeX()

        if LocalPlayer():Health() <= 30 then
            colhp = col3
        end

        local whp = {
            x = airgap + hpicon_s + CopeX(),
            y = ScrH() - ScreenScaleMulti(26 + (gotarmor and 16 or 0)) - airgap - CopeY(),
            font = "ArcCW_26",
            text = tostring(math.Round(vhp)),
            col = colhp,
            shadow = true,
            alpha = alpha
        }

        local hpicon_y = whp.y + ScreenScaleMulti(8)

        MyDrawText(whp)

        surface.SetMaterial(hp_shad)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawTexturedRect(hpicon_x, hpicon_y, hpicon_s, hpicon_s)

        surface.SetMaterial(hp)
        surface.SetDrawColor(colhp)
        surface.DrawTexturedRect(hpicon_x, hpicon_y, hpicon_s, hpicon_s)

    end

    vhp = self:GetOwner():Health()
    varmor = self:GetOwner():Armor()

    local clipdiff = math.abs(vclip - self:Clip1())
    local reservediff = math.abs(vreserve - self:Ammo1())

    if clipdiff == 1 then
        vclip = self:Clip1()
    elseif self:Clip1() == ArcCW.BottomlessMagicNumber then
        clipdiff = 0
    end

    vclip = math.Approach(vclip, self:Clip1(), FrameTime() * 30 * clipdiff)
    vreserve = math.Approach(vreserve, self:Ammo1(), FrameTime() * 30 * reservediff)

    do
        local clipdiff = math.abs(vclip2 - self:Clip2())
        local reservediff = math.abs(vreserve2 - self:Ammo2())

        if clipdiff == 1 then
            vclip2 = self:Clip2()
        elseif self:Clip2() == ArcCW.BottomlessMagicNumber then
            clipdiff = 0
        end

        vclip2 = math.Approach(vclip2, self:Clip2(), FrameTime() * 30 * clipdiff)
        vreserve2 = math.Approach(vreserve2, self:Ammo2(), FrameTime() * 30 * reservediff)
    end

    vubgl = math.Approach(vubgl, (self:GetInUBGL() and 1 or 0), (FrameTime() / 0.3) )

    if lastwpn != self then
        vclip = self:Clip1()
        vreserve = self:Ammo1()
        vclip2 = self:Clip2()
        vreserve2 = self:Ammo2()
        vubgl = 0
        vhp = self:GetOwner():Health()
        varmor = self:GetOwner():Armor()
    end

    lastwpn = self
end

function SWEP:CustomAmmoDisplay()
    local data = self:GetHUDData()
    self.AmmoDisplay = self.AmmoDisplay or {}

    self.AmmoDisplay.Draw = true -- draw the display?

    if self.Primary.ClipSize > 0 and tonumber(data.clip) then
        local plus = tonumber(data.plus) or 0
        self.AmmoDisplay.PrimaryClip = tonumber(data.clip) + plus -- amount in clip
    end

    if self.Primary.ClipSize > 0 and tonumber(data.ammo) then
        self.AmmoDisplay.PrimaryAmmo = tonumber(data.ammo) -- amount in reserve
    end

    if true then
        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            self.AmmoDisplay.SecondaryAmmo = self:Clip2() + self:GetOwner():GetAmmoCount(ubglammo) -- amount of secondary ammo
        end
    end

    return self.AmmoDisplay -- return the table
end
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_laser.lua:
local mth        = math
local m_log10    = mth.log10
local m_rand     = mth.Rand
local rnd        = render
local SetMat     = rnd.SetMaterial
local DrawBeam   = rnd.DrawBeam
local DrawSprite = rnd.DrawSprite
local cam        = cam

local lasermat = Material("arccw/laser")
local flaremat = Material("effects/whiteflare")
local delta    = 1

function SWEP:DoLaser(world, nocontext)
    world = world or false

    if !nocontext then
        if world then
            cam.Start3D()
        else
            cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(self.CurrentViewModelFOV))
        end
    end

    for slot, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local attach = ArcCW.AttachmentTable[k.Installed]

        if self:GetBuff_Stat("Laser", slot) then
            local color = self:GetBuff_Stat("LaserColor", slot) or attach.ColorOptionsTable[k.ColorOptionIndex or 1]

            if world then
                if !k.WElement then continue end
                self:DrawLaser(attach, k.WElement.Model, color, true)
            else
                if !k.VElement then continue end
                self:DrawLaser(attach, k.VElement.Model, color)
            end
        end
    end

    if self.Lasers then
        if world then
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self.WMModel or self, k.LaserColor, true)
            end
        else
            -- cam.Start3D(nil, nil, self.ViewmodelFOV)
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self:GetOwner():GetViewModel(), k.LaserColor)
            end
            -- cam.End3D()
        end
    end

    if !nocontext then
        cam.End3D()
    end
end

function SWEP:DrawLaser(laser, model, color, world)
    local owner = self:GetOwner()
    local behav = ArcCW.LaserBehavior

    if !owner then return end

    if !IsValid(owner) then return end

    if !model then return end

    if !IsValid(model) then return end

    local att = model:LookupAttachment(laser.LaserBone or "laser")

    att = att == 0 and model:LookupAttachment("muzzle") or att

    local pos, ang, dir

    if att == 0 then
        pos = model:GetPos()
        ang = owner:EyeAngles() + self:GetFreeAimOffset()
        dir = ang:Forward()
    else
        local attdata  = model:GetAttachment(att)
        pos, ang = attdata.Pos, attdata.Ang
        dir      = -ang:Right()
    end

    if world then
        dir = owner:IsNPC() and (-ang:Right()) or dir
    else
        ang:RotateAroundAxis(ang:Up(), 90)

        if self.LaserOffsetAngle then
            ang:RotateAroundAxis(ang:Right(), self.LaserOffsetAngle[1])
            ang:RotateAroundAxis(ang:Up(), self.LaserOffsetAngle[2])
            ang:RotateAroundAxis(ang:Forward(), self.LaserOffsetAngle[3])
        end
        if self.LaserIronsAngle and self:GetActiveSights().IronSight then
            local d = 1 - self:GetSightDelta()
            ang:RotateAroundAxis(ang:Right(), d * self.LaserIronsAngle[1])
            ang:RotateAroundAxis(ang:Up(), d * self.LaserIronsAngle[2])
            ang:RotateAroundAxis(ang:Forward(), d * self.LaserIronsAngle[3])
        end

        dir = ang:Forward()

        local eyeang   = EyeAngles() - self:GetOurViewPunchAngles() + self:GetFreeAimOffset()
        local canlaser = self:GetCurrentFiremode().Mode != 0 and !self:GetReloading() and self:BarrelHitWall() <= 0

        delta = Lerp(0, delta, canlaser and self:GetSightDelta() or 1)

        if self.GuaranteeLaser then
            delta = 1
        else
            delta = self:GetSightDelta()
        end

        dir = Lerp(delta, eyeang:Forward(), dir)
    end

    local beamdir, tracepos = dir, pos

    beamdir = world and (-ang:Right()) or beamdir

    if behav and !world then
        -- local cheap = ArcCW.ConVars["cheapscopes"]:GetBool()
        local punch = self:GetOurViewPunchAngles()

        ang = EyeAngles() - punch + self:GetFreeAimOffset()

        tracepos = EyePos() - Vector(0, 0, 1)
        pos, dir = tracepos, ang:Forward()
        beamdir  = dir
    end

    local dist = 128

    local tl = {}
    tl.start  = tracepos
    tl.endpos = tracepos + (dir * 33000)
    tl.filter = owner

    local tr = util.TraceLine(tl)

    tl.endpos = tracepos + (beamdir * dist)

    local btr = util.TraceLine(tl)

    local hit    = tr.Hit
    local hitpos = tr.HitPos
    local solid  = tr.StartSolid

    local strength = laser.LaserStrength or 1
    local laserpos = solid and tr.StartPos or hitpos

    laserpos = laserpos - ((EyeAngles() + self:GetFreeAimOffset()):Forward())

    if solid then return end

    local width = m_rand(0.05, 0.1) * strength * 1

    if (!behav or world) and hit then
        SetMat(lasermat)
        local a = 200
        DrawBeam(pos, btr.HitPos, width * 0.3, 1, 0, Color(a, a, a, a))
        DrawBeam(pos, btr.HitPos, width, 1, 0, color)
    end

    if hit and !tr.HitSky then
        local mul = 1 * strength
        mul = m_log10((hitpos - EyePos()):Length()) * strength
        local rad = m_rand(4, 6) * mul
        local glr = rad * m_rand(0.2, 0.3)

        SetMat(flaremat)

        -- if !world then
        --     cam.IgnoreZ(true)
        -- end
        DrawSprite(laserpos, rad, rad, color)
        DrawSprite(laserpos, glr, glr, color_white)

        -- if !world then
        --     cam.IgnoreZ(false)
        -- end
    end
end

--addons/arccw_base_modified/lua/weapons/arccw_base/cl_scope.lua:
function SWEP:AdjustMouseSensitivity()
    if self:GetState() != ArcCW.STATE_SIGHTS then return end

    local threshold = ArcCW.ConVars["adjustsensthreshold"]:GetFloat()

    local irons = self:GetActiveSights() or {}

    local tmag = ((irons.Magnification or 1) + (irons.ScopeMagnification or 0))

    if tmag < threshold then return end

    return 1 / tmag
end

function SWEP:Scroll(var)
    local irons = self:GetActiveSights()

    if irons.ScrollFunc == ArcCW.SCROLL_ZOOM then
        if !irons.ScopeMagnificationMin then return end
        if !irons.ScopeMagnificationMax then return end

        local old = irons.ScopeMagnification

        local minus = var < 0

        var = math.abs(irons.ScopeMagnificationMax - irons.ScopeMagnificationMin)

        var = var / (irons.ZoomLevels or 5)

        if minus then
            var = var * -1
        end

        irons.ScopeMagnification = irons.ScopeMagnification - var

        irons.ScopeMagnification = math.Clamp(irons.ScopeMagnification, irons.ScopeMagnificationMin, irons.ScopeMagnificationMax)

        self.SightMagnifications[irons.Slot or 0] = irons.ScopeMagnification

        if old != irons.ScopeMagnification then
            self:MyEmitSound(irons.ZoomSound or "", 75, math.Rand(95, 105), 1, CHAN_ITEM)
        end

        -- if !irons.MinZoom then return end
        -- if !irons.MaxZoom then return end

        -- local old = irons.Magnification

        -- irons.Magnification = irons.Magnification - var

        -- irons.Magnification = math.Clamp(irons.Magnification, irons.MinZoom, irons.MaxZoom)

        -- if old != irons.Magnification then
        --     self:MyEmitSound(irons.ZoomSound or "", 75, 100, 1, CHAN_ITEM)
        -- end
    end

end

local ang0 = Angle(0, 0, 0)

SWEP.ViewPunchAngle = Angle(ang0)
SWEP.ViewPunchVelocity = Angle(ang0)

function SWEP:OurViewPunch(angle)
    self.ViewPunchVelocity:Add(angle)
    for i = 1, 3 do self.ViewPunchVelocity[i] = math.Clamp(self.ViewPunchVelocity[i], -180, 180) end
end

function SWEP:GetOurViewPunchAngles()
    local a = self:GetOwner():GetViewPunchAngles()
    for i = 1, 3 do a[i] = a[i] + self.ViewPunchAngle[i] * 10 end
    return a
end

local function lensqr(ang)
    return (ang[1] ^ 2) + (ang[2] ^ 2) + (ang[3] ^ 2)
end

-- scraped from source SDK 2013, just like this viewpunch damping code
local PUNCH_DAMPING = 9
local PUNCH_SPRING_CONSTANT = 120

function SWEP:DoOurViewPunch()
    -- if ( player->m_Local.m_vecPunchAngle->LengthSqr() > 0.001 || player->m_Local.m_vecPunchAngleVel->LengthSqr() > 0.001 )

    local vpa = self.ViewPunchAngle
    local vpv = self.ViewPunchVelocity

    if lensqr(vpa) + lensqr(vpv) > 0.000001 then
        -- {
        --     player->m_Local.m_vecPunchAngle += player->m_Local.m_vecPunchAngleVel * gpGlobals->frametime;
        --     float damping = 1 - (PUNCH_DAMPING * gpGlobals->frametime);

        local ft = FrameTime()

        vpa = vpa + (vpv * ft)
        local damping = 1 - (PUNCH_DAMPING * ft)

        --     if ( damping < 0 )
        --     {
        --         damping = 0;
        --     }

        if damping < 0 then damping = 0 end

        --     player->m_Local.m_vecPunchAngleVel *= damping;

        vpv = vpv * damping

        --     // torsional spring
        --     // UNDONE: Per-axis spring constant?
        --     float springForceMagnitude = PUNCH_SPRING_CONSTANT * gpGlobals->frametime;
        local springforcemagnitude = PUNCH_SPRING_CONSTANT * ft
        --     springForceMagnitude = clamp(springForceMagnitude, 0.f, 2.f );
        springforcemagnitude = math.Clamp(springforcemagnitude, 0, 2)
        --     player->m_Local.m_vecPunchAngleVel -= player->m_Local.m_vecPunchAngle * springForceMagnitude;
        vpv = vpv - (vpa * springforcemagnitude)

        --     // don't wrap around
        --     player->m_Local.m_vecPunchAngle.Init(
        --         clamp(player->m_Local.m_vecPunchAngle->x, -89.f, 89.f ),
        --         clamp(player->m_Local.m_vecPunchAngle->y, -179.f, 179.f ),
        --         clamp(player->m_Local.m_vecPunchAngle->z, -89.f, 89.f ) );
        -- }

        vpa[1] = math.Clamp(vpa[1], -89.9, 89.9)
        vpa[2] = math.Clamp(vpa[2], -179.9, 179.9)
        vpa[3] = math.Clamp(vpa[3], -89.9, 89.9)

        self.ViewPunchAngle = vpa
        self.ViewPunchVelocity = vpv
    else
        self.ViewPunchAngle = Angle(ang0)
        self.ViewPunchVelocity = Angle(ang0)
    end
end

-- viewbob during reload and firing shake
SWEP.ProceduralViewOffset = Angle(ang0)
local procedural_spdlimit = 5
local oldangtmp
local mzang_fixed,mzang_fixed_last
local mzang_velocity = Angle(ang0)
local progress = 0
local targint,targbool

function SWEP:CoolView(ply, pos, ang, fov)
    if !ang then return end
    if ply != LocalPlayer() then return end
    if ply:ShouldDrawLocalPlayer() then return end
    local vm = ply:GetViewModel()
    if !IsValid(vm) then return end
    local ftv = FrameTime()

    local gunbone, gbslot = self:GetBuff_Override("LHIK_CamDriver")
    local lhik_anim_model = gbslot and self.Attachments[gbslot].GodDriver and self.Attachments[gbslot].GodDriver.Model
    if IsValid(lhik_anim_model) and lhik_anim_model:GetAttachment(gunbone) then
        local catang = lhik_anim_model:GetAttachment(gunbone).Ang

        catang:Sub( Angle( 0, 90, 90 ) )
        catang.y = -catang.y
        local r = catang.r
        catang.r = -catang.p
        catang.p = -r

        ang:RotateAroundAxis( ang:Right(),		catang.x )
        ang:RotateAroundAxis( ang:Up(),			catang.y )
        ang:RotateAroundAxis( ang:Forward(),	catang.z )

    end

    -- Cam_Offset_Ang might not always be assigned properly. Try not to use it if it's nil, or it'll tilt the player's view.
    local att = self:GetBuff_Override("Override_CamAttachment", self.CamAttachment) or -1
    if vm:GetAttachment(att) and self.Cam_Offset_Ang then
        local attang = vm:WorldToLocalAngles(vm:GetAttachment(att).Ang)
        attang:Sub(self.Cam_Offset_Ang)
        ang:Add(attang)
        return
    end

    local viewbobintensity = self.ProceduralViewBobIntensity or 0.3

    if viewbobintensity == 0 then return end

    oldpostmp = pos * 1
    oldangtmp = ang * 1

    targbool = self:GetNextPrimaryFire() - .1 > CurTime()
    targint = targbool and 1 or 0
    targint = math.min(targint, 1-math.pow( vm:GetCycle(), 2 ) )
    progress = Lerp(ftv * 15, progress, targint)

    local angpos = vm:GetAttachment(self.ProceduralViewBobAttachment or self.MuzzleEffectAttachment or 1)

    if angpos and self:GetReloading() then
        mzang_fixed = vm:WorldToLocalAngles(angpos.Ang)
        mzang_fixed:Normalize()
    else return
    end

    self.ProceduralViewOffset:Normalize()

    if mzang_fixed_last then
        local delta = mzang_fixed - mzang_fixed_last
        delta:Normalize()
        mzang_velocity = mzang_velocity + delta * 2
        mzang_velocity.p = math.Approach(mzang_velocity.p, -self.ProceduralViewOffset.p * 2, ftv * 20)
        mzang_velocity.p = math.Clamp(mzang_velocity.p, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.p = self.ProceduralViewOffset.p + mzang_velocity.p * ftv
        self.ProceduralViewOffset.p = math.Clamp(self.ProceduralViewOffset.p, -90, 90)
        mzang_velocity.y = math.Approach(mzang_velocity.y, -self.ProceduralViewOffset.y * 2, ftv * 20)
        mzang_velocity.y = math.Clamp(mzang_velocity.y, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.y = self.ProceduralViewOffset.y + mzang_velocity.y * ftv
        self.ProceduralViewOffset.y = math.Clamp(self.ProceduralViewOffset.y, -90, 90)
        mzang_velocity.r = math.Approach(mzang_velocity.r, -self.ProceduralViewOffset.r * 2, ftv * 20)
        mzang_velocity.r = math.Clamp(mzang_velocity.r, -procedural_spdlimit, procedural_spdlimit)
        self.ProceduralViewOffset.r = self.ProceduralViewOffset.r + mzang_velocity.r * ftv
        self.ProceduralViewOffset.r = math.Clamp(self.ProceduralViewOffset.r, -90, 90)
    end

    self.ProceduralViewOffset.p = math.Approach(self.ProceduralViewOffset.p, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.p)
    self.ProceduralViewOffset.y = math.Approach(self.ProceduralViewOffset.y, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.y)
    self.ProceduralViewOffset.r = math.Approach(self.ProceduralViewOffset.r, 0, (1 - progress) * ftv * -self.ProceduralViewOffset.r)
    mzang_fixed_last = mzang_fixed
    local ints = 3 * ArcCW.ConVars["vm_coolview_mult"]:GetFloat() * -viewbobintensity
    ang:RotateAroundAxis(ang:Right(), Lerp(progress, 0, -self.ProceduralViewOffset.p) * ints)
    ang:RotateAroundAxis(ang:Up(), Lerp(progress, 0, self.ProceduralViewOffset.y / 2) * ints)
    ang:RotateAroundAxis(ang:Forward(), Lerp(progress, 0, self.ProceduralViewOffset.r / 3) * ints)

    ang = LerpAngle(0, ang, oldangtmp)
end

function SWEP:CalcView(ply, pos, ang, fov)
    if !CLIENT then return end

    if ArcCW.ConVars["vm_coolview"]:GetBool() then
        self:CoolView(ply, pos, ang, fov)
    end

    if ArcCW.ConVars["shake"]:GetBool() and !engine.IsRecordingDemo() then
        local de = (0.2 + (self:GetSightDelta()*0.8))
        ang = ang + (AngleRand() * self.RecoilAmount * 0.006 * de)
    end

    ang = ang + (self.ViewPunchAngle * 10)

    return pos, ang, fov
end

function SWEP:ShouldGlint()
    return self:GetBuff_Override("ScopeGlint") and self:GetState() == ArcCW.STATE_SIGHTS
end

function SWEP:DoScopeGlint()
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_util.lua:
function SWEP:TableRandom(table)
    return table[math.random(#table)]
end

function SWEP:MyEmitSound(fsound, level, pitch, vol, chan, useWorld)
    if !fsound then return end

    fsound = self:GetBuff_Hook("Hook_TranslateSound", fsound) or fsound

    if istable(fsound) then fsound = self:TableRandom(fsound) end

    if fsound and fsound != "" then
        if useWorld then
            sound.Play(fsound, self:GetOwner():GetShootPos(), level, pitch, vol)
        else
            self:EmitSound(fsound, level, pitch, vol, chan or CHAN_AUTO)
        end
    end
end
--addons/arccw_weapons/lua/weapons/arccw_dc17_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc17_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(11, 0, -4.4),
    ang = Angle(175, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.4, -0, 0.4),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(2, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {""}

-- SWEP.AttachmentElements = {
--     ["dc17"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "v_scoutblaster_reference001",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(0, 0, 0),
--                     ang = Angle(0, 90, 0)
--                 }
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1, 1, 1),
--                 Offset = {
--                     pos = Vector(300, 100, -90),
--                     ang = Angle(-15, 0, 180)
--                 }
--             }
--         },
--     },
-- }
-- WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic_lp",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(5, 1.13, -5.3),
            wang = Angle(-6, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, 1.12, -2.8),
            wang = Angle(-5, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(10.2, 1.12, -4.2),
            wang = Angle(-6, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(8, 1.7, -4.6),
            wang = Angle(-10, 0, 180)
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15, 0, 180)
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["fire_sights"] = {
        Source = "shoot",
        Time = -1,
    },
    ["idle_sights"] = {
        Source = "",
        Time = -1,
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2.5,
        SoundTable = {
            {s = "reloads/pistols.wav", t = 1 / 30}, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dl18.lua:
AddCSLuaFile()

SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] DL-18"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dl18.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 80
SWEP.DamageMin = 14
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1050


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 2

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dl18.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-4.125, -8, 1.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"dl18"}

SWEP.AttachmentElements = {
    ["dl18"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/dl18.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(0.2, -3.5, -3.75),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/dl18.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, 20),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/dl18.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -5, 1.3),
            vang = Angle(0, 90, 0),
        },
    }  
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dt12.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] DT-12"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dt12.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 80
SWEP.DamageMin = 14
SWEP.Range = 290
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 16

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },       
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dpst.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.925, -8, 2.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)


SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"dt12"}

SWEP.AttachmentElements = {
    ["dt12"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(-0.25, -2.0, -4.5),
                    ang = Angle(0, 90, 1.5)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(60, 20, 20),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.02, -0.3, 2),
            vang = Angle(0, 180, 0),
            wpos = Vector(40, 20, -45),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        WMScale = Vector(9, 9, 9),
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -5, 1.3),
            vang = Angle(0, 90, 0),
            wpos = Vector(80, 20, -50),
            wang = Angle(-15, 0, 180)
        },
    }, 
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(9, 9, 9),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
            wpos = Vector(91, 20, -59),
            wang = Angle(-15, 0, 180)
        },
    },       
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.9, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(35, 25, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_bx_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual E-5 BX"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual E-5 BX Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_e5bx.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true

SWEP.Damage = 38
SWEP.RangeMin = 150
SWEP.DamageMin = 22
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(0, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"e5", "e5+"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, -1.5, -1),
                    ang = Angle(-4, -2, 90)
                }
            }
        },
    },
    ["e5+"] = {
         VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, 1.5, 1),
                    ang = Angle(-4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}



-- AOCRP WAFFENSTATS arccw_dual_bx_e5 - 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 20
SWEP.RangeMin = 150
SWEP.Range = 350
SWEP.Delay = 60 / 380
SWEP.Primary.ClipSize = 40
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_dual_ll30.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual LL-94"
SWEP.Trivia_Class = " Dual Blaster Pistol"
SWEP.Trivia_Desc = " Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_ll30.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 315
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 44

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 290
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/ll30.wav"

SWEP.MuzzleFlashColor = Color(250, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"ll30", "ll30+"}

SWEP.AttachmentElements = {
    ["ll30"] = {
        VMElements = {
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, -1, -0.5),
                    ang = Angle(80, -2, 90)
                }
            }
        },
    },
    ["ll30+"] = {
         VMElements = {
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, 1, 0.5),
                    ang = Angle(-95, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/weapons/ll30.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/weapons/ll30.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_ee3.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[SMG] EE-3"
SWEP.Trivia_Class = "Galactic Blaster Rifle "
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_ee3a.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 20
SWEP.RangeMin = 135
SWEP.DamageMin = 16
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 38

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},  
    {
        Mode = 1
    },
    {
        Mode = 0
    },      
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/ee3.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3.6, -3, 2.1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"ee3", "muzzle"}

SWEP.AttachmentElements = {
    ["ee3"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/ee3_noscope.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, -0.5, -0.5),
                    ang = Angle(0,-90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt19_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 5 ),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/ee3_noscope.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.3, 1.3, 1.3),
                Offset = {
                    pos = Vector(200, 100, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2500, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/sw_battlefront/weapons/ee3_noscope.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.45, 0.8, -1),
            vang = Angle(90, 0, -90),
            wpos = Vector(850, 100, -740),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 3.28, 7),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 3.5, 3),
        vmax = Vector(-0.1, 3.5, 7),
        wmin = Vector(2100, 100, -720), 
        wmax = Vector(2100, 100, -720)  -- how far this attachment can slide in both directions.
        },         
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3.3, 10.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(2300, 90, -800),
            wang = Angle(-15, 0, -180)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment",
        WMScale = Vector(111, 111, 111), -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(2600, 100, -1020),
            wang = Angle(-15, 0, -90)
        },
    },             
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 1.5, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_hunter_shotgun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[SH] Hunter Shotgun"
SWEP.Trivia_Class = "Blaster Shotgun"
SWEP.Trivia_Desc = "High tech Blaster shotgun, built for piercing the enemy defenses."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = false
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_huntershotgun.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 10
SWEP.RangeMin = 15
SWEP.DamageMin = 4
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 4.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 90 / 120
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 1050 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/hunter.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-2.92, -12, 0.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 70,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, .8, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"huntershotgun"}

SWEP.AttachmentElements = {
    ["huntershotgun"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, 4, -2.5),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(800, 100, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
        WMOverride = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl", -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}

--SWEP.Attachments
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.49, 1.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 90, -590),
            wang = Angle(-15, 0, 180)
        },
    }, 
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(1800, 100, -690),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.1, 3.4, 3.4),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 2),
            vmax = Vector(-0.2, 2.5, 9),
            wmin = Vector(1200, 100, -580), 
            wmax = Vector(1200, 100, -580) -- how far this attachment can slide in both directions.
        },   
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(2300, 20, -760),
            wang = Angle(-15, 0, 180)
        },
    },             
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 2.1, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 100, -500),
            wang = Angle(0 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1, 
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_deadmanstale.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'Dead Man's Tale'"
SWEP.Trivia_Class = "Blaster Lever-Action Rifle"
SWEP.Trivia_Desc = "Galactic Lever-Action rifle. Unkown origin. 'Long, short, they all end the same way.'"
SWEP.IconOverride = "entities/sopsmisc/lever2.png"

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_dead_mans_tale.mdl"
SWEP.WorldModel = "models/tor/weapons/w_quadblaster.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 6, -5),
    ang = Angle(-10, 0, 180)
}

-- Special properties
SWEP.ShotgunReload = true
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 2

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 34
SWEP.DamageMin = 27
SWEP.RangeMin = 179
SWEP.Range = 390
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 10
SWEP.AmmoPerShot = 1

SWEP.Recoil = 1.23
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.76
SWEP.RecoilPunch = 1.28

SWEP.Delay = 60 / 128
SWEP.Num = 1 
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150

SWEP.Primary.Ammo = "ar2" 
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/rifles/deadmansfire1.wav"
SWEP.ShootSound = "sops-v2/weapons/rifles/deadmansfire3.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.CaseEffectAttachment = 2
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-5.237, -10.469, 0.91),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, -5, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {       
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },         
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle_retracted",
    },
	["fire"] = {
        Source = "shoot",
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
    },
    ["sgreload_start"] = {
        Source = "start reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadstart.wav", t = 0.1},
                    },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "insert",
        RestoreAmmo = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadinsert.wav", t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "finish reload",
        SoundTable = {
                        {s = "sops-v2/weapons/rifles/deadmansreloadend.wav", t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },  
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/weapons/rifles/deadmansdraw.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/weapons/rifles/deadmansdraw.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_ex11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "EX-11"
SWEP.Trivia_Class = "Experimental Blaster SMG"
SWEP.Trivia_Desc = "Experimental SMG Blaster, short-range desired."
SWEP.IconOverride = "entities/sopsmisc/ex-11.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 33
SWEP.RangeMin = 98
SWEP.DamageMin = 24
SWEP.Range = 187
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 457

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/rx21.wav"
SWEP.ShootSound = "sops-v2/weapons/rx21.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.35, 0, 1),
    Ang = Angle(1.5, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 5, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/prototype_blaster.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-2, -5.5, -8.4),
                    ang = Angle(0, 0,    0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 10, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/prototype_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(50, -5, 60),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(150, 15, -70),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/prototype_blaster.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, -3, 1.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(30, 15.5, -47),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.5, 7, 0.2),
            vang = Angle(0, -90, 90),
            wpos = Vector(140, 21, -64),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 1, -0.9),
            vang = Angle(0, -90, 0),
            wpos = Vector(100, 15.5, -40),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 10, 0.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(193, 15.5, -78),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(0.7, -10, 0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(-30, 24, -20),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.7, -5, 0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(30, 28, -34),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_z2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Z-2"
SWEP.Trivia_Class = "Galactic Rotary Canon Blaster"
SWEP.Trivia_Desc = "A powerful chain gun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Heavy Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_t21.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_z2.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 95
SWEP.DamageMin = 16
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 2
SWEP.RecoilRise = 0.34

SWEP.Delay = 245 / 2400
SWEP.Num = 1

SWEP.BobMult = 1

SWEP.Firemodes = {
	{
		Mode = 2,
	},
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)

SWEP.SpeedMult = 0.5
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 1

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.02

SWEP.ShootSound = "w/z6.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -12, -4),
    Ang = Angle(0, 0, 0),
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
    CrosshairInSights = true
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(4, -10, -8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -30, -20)
SWEP.SprintAng = Angle(40, 0, -10)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(0, 0, 0)

SWEP.CustomizePos = Vector(20.824, -4, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.DefaultElements = {"z6"}

SWEP.AttachmentElements = {
    ["z6"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/Z6_Rotary_Cannon_Skin.mdl",
                Bone = "v_t21_reference001",
                Scale = Vector(1.2, 1.1, 1.2),
                Offset = {
                    pos = Vector(.1, -0.3, 1),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/Z6_Rotary_Cannon_Skin.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3.75, 2.5, -1.5),
                    ang = Angle(-10, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}

WMOverride = "models/arccw/sw_battlefront/weapons/Z6_Rotary_Cannon_Skin.mdl"

SWEP.Jamming = true
SWEP.HeatGain = 0.8 -- heat gained per shot
SWEP.HeatCapacity = 75 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = true -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5

--SWEP.Attachments 
SWEP.Attachments = {       
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 0.6, 35),
            vang = Angle(90, 0, 0),
            wpos = Vector(4000, 50, -1000),
            wang = Angle(-10, 0, -90)
        },
    },            
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [4] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 1, 29),
            vang = Angle(90, 0, -90),
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 2,
        SoundTable = {
            {
                s = "draw/blasters_deathray_foley_undeploy_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 200, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/blasters_deathray_foley_undeploy_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_z6.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--lua/weapons/blood_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Blood katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Blood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to hard attack, Special +vampirism"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(170, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 6), angle = Angle(0, 180, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, -45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 70, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1, 0, 9), angle = Angle(0, 90, -12.858), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+++"] = { type = "Model", model = "models/gibs/agibs.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 6), angle = Angle(0, 180, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(170, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 0, 0, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(170, 180, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 70, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/gibs/hgibs_spine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1, 0, 9), angle = Angle(0, 90, -12.858), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}




SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 31
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Blood"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 62
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Blood"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		self.Owner:SetHealth(math.Clamp(self.Owner:Health()+3,0,100))
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/joes_stuff/lua/weapons/defuser_bomb/shared.lua:
SWEP.PrintName = "Zange"
SWEP.Author =	"Joe"

SWEP.Spawnable =	true
SWEP.Adminspawnable =	false
SWEP.Category = "AOCRP - Tools"
SWEP.ShowWorldModel = false


SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/v_pliers.mdl"
SWEP.WorldModel = ""
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.DrawCrosshair = true

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true




function SWEP:PrimaryAttack()
	if not SERVER then return end
	local ply = self.Owner
	local tr = ply:GetEyeTrace()

	local ent = tr.Entity
	if not IsValid(ent) or ent:GetClass() != "joe_cable" then return end
	if ent.iscut then return end
	if not IsValid(ent.bomb) then return end
	--if ent.bomb:GetBodygroup(1) == 0 then return end
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

	self:SetNextPrimaryFire(CurTime() + 2)

	ent.bomb:CableCut(ent)
	ent.iscut = true
	ent:SetModel("models/starwars_bomb/starwars_bomb_cable_cut.mdl")
	self.Owner:EmitSound("bomb/cut.mp3")
end

function SWEP:SecondaryAttack()

end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )

	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() )

end

function SWEP:Holster()
	
	return true
end

function SWEP:OnRemove()

end

--lua/weapons/demonic_battle_axe/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Demonic Battle axe"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Demonic"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType 		= "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.093, 0.093, 0.093), pos = Vector(0, 0, 0), angle = Angle(-7.778, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -12.778), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-0.556, 0, 2.407), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-2.3, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-56.667, 0, 0) }
}
SWEP.VElements = {
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 33), angle = Angle(90, 0, 90), size = Vector(0.107, 0.301, 0.009), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.699), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(1.5, 0, 33), angle = Angle(0, 180, 90), size = Vector(0.107, 0.107, 0.107), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 31.399), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.05, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.5, 0, 33), angle = Angle(0, 0.8, 90), size = Vector(0.107, 0.107, 0.107), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.5, 0, 33), angle = Angle(0, 0.8, 90), size = Vector(0.107, 0.107, 0.107), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.699), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(1.5, 0, 33), angle = Angle(0, 180, 90), size = Vector(0.107, 0.107, 0.107), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 31.399), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.05, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -24.546, 8), size = Vector(0.05, 0.039, 0.108), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 33), angle = Angle(90, 0, 90), size = Vector(0.107, 0.301, 0.009), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} }
}




SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 60
SWEP.Primary.DelayMiss	 = 2
SWEP.Primary.DelayHit 	 = 1.2
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 22

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/ghost_baton/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Ghost baton"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+1"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils1", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils1"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -29.222, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+++1"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils1", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++1"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils1", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 15
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Sand"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetRunSpeed=505

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetRunSpeed(self.SetRunSpeed)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/ghost_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Ghost dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 183), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 10
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 30
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetRunSpeed=505

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetRunSpeed(self.SetRunSpeed)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/ghost_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Ghost katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, -45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 255, 150), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 30
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 60
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/tools/lua/weapons/gmod_tool/stools/precision.lua:

TOOL.Category		= "Constraints"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "freeze" ]	 		= "1"
TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "0"

//adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

//Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()//delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()
	
	//local col = CurrentEnt:GetCollisionGroup()
	//col = 19
	//CurrentEnt:SetCollisionGroup(col)
	//self:SendMessage("New group: "..col)
	
	//if ( CurrentPhys:IsDragEnabled() ) then
	//end
	//CurrentPhys:SetAngleDragCoefficient(1.05)
	//CurrentPhys:SetDragCoefficient(1.05)
	
	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then//Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45//Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	// Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false//Something happened to original target, don't continue
	end
	// Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
	local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)
	
	local NumApp = 0
	

	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then // not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then //Apply
							self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then //Rotate
							//self:SendMessage("Sorry, No entire contraption rotating... yet")
							//return false//TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then //move
							//self:SendMessage("Sorry, No entire contraption moving... yet")
							//return false//todo: entire contraption move/snap
						elseif ( mode == 4 ) then //weld
							local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
							self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then //doaxis
							local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
							self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then //ballsocket
							local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
							self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then //adv ballsocket
							local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
							self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then //slider
							local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							if (constraint0) then
								undo.Create("Precision_Slider")
								if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
									local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
									if (constraint2) then
										undo.AddEntity( constraint2 )
									end
									local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
									if (constraint3) then
										undo.AddEntity( constraint3 )
									end
									local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
									if (constraint4) then
										undo.AddEntity( constraint4 )
									end
								end
								undo.AddEntity( constraint0 )
								undo.SetPlayer( self:GetOwner() )
								undo.Finish()
								self:GetOwner():AddCleanup( "constraints", constraint0 )
							end
						elseif ( mode == 9 ) then //Parent
							self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then//Repair spaz
							if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
							elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
							end
								//CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )//Can't disable gravity - sliders would go nuts and disappear.	
							local speeddamp,angledamp = CurrentPhys:GetDamping()
							if ( speeddamp == 0 && angledamp == 0 ) then
								CurrentPhys:SetDamping( 5, 5 )
							elseif ( speeddamp == 5 && angledamp == 5 ) then
								CurrentPhys:SetDamping( 0, 0 )
							end
							CurrentEnt:SetPos(CurrentEnt:GetPos())
							CurrentPhys:Wake()
						elseif ( mode == 11 ) then //Removal
							if ( CLIENT ) then return true end//? should probably be in more places
							if ( removal_nocollide ) then
								constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
								CurrentPhys:EnableCollisions(true)
							end
							if ( removal_weld ) then
								constraint.RemoveConstraints( CurrentEnt, "Weld" )
							end
							if ( removal_axis ) then
								constraint.RemoveConstraints( CurrentEnt, "Axis" )
							end
							if ( removal_ballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "Ballsocket" )
							end
							if ( removal_advballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "AdvBallsocket" )
							end
							if ( removal_slider ) then
								constraint.RemoveConstraints( CurrentEnt, "Slider" )
							end
							if ( removal_parent) then
								if ( CurrentEnt:GetParent():IsValid() ) then
									self:UndoParent( CurrentEnt )
								end
							end
							if ( removal_other ) then
								constraint.RemoveConstraints( CurrentEnt, "Elastic" )
								constraint.RemoveConstraints( CurrentEnt, "Hydraulic" )
								constraint.RemoveConstraints( CurrentEnt, "Keepupright" )
								constraint.RemoveConstraints( CurrentEnt, "Motor" )
								constraint.RemoveConstraints( CurrentEnt, "Muscle" )
								constraint.RemoveConstraints( CurrentEnt, "Pulley" )
								constraint.RemoveConstraints( CurrentEnt, "Rope" )
								constraint.RemoveConstraints( CurrentEnt, "Winch" )
							end
						end
						if ( mode <= 8 ) then
							CurrentPhys:EnableMotion( !freeze )
							CurrentPhys:Wake()
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end//Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end
	
	
	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	// Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) //TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2//Valid parent, but itself isn't
		else
			return 0//No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0// Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1// Only allow second click to be here...
	else
		return 3//Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	
	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end
	
	if IsValid( Phys ) then
		Phys:EnableMotion( false ) //else it drifts
	end
	
	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation/2) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation/2) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation/2) % rotation)
	self.OldPos = self:GetPos(1)//trace.HitPos
end

function TOOL:DoMove()
	// Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)
	
	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then//Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation/2) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation/2) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation/2) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )//Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	//self:SetPos(2)

	// Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	// Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
	
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()//0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	
	if ( stage == 0 ) then//first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false//No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then //Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then//Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then//Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then//Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					//return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then//Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then
	
	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end
	
	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )
	
	// Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )
	
	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end


function TOOL:Think()
	//if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end
		
	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then//no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation/2)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				// Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	//////////////////////////////////////////
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				// Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	//if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)//No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					/*if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end*/// todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then //phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then

	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Accurately moves/constrains objects" )
	language.Add( "Tool.precision.0", "Primary: Move/Apply | Secondary: Push | Reload: Pull" )
	language.Add( "Tool.precision.1", "Target the second item. If enabled, this will move the first item.  (Swap weps to cancel)" )
	language.Add( "Tool.precision.2", "Rotate enabled: Turn left and right to rotate the object (Hold Reload or Secondary for other rotation directions!)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0//Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = "precision_freeze",
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		//Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Push/Pull Amount",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Push/Pull as Percent (%) of target's depth", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		//Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		local list = vgui.Create("DListView")

		//17 per item + 16 for title
		local height = 203 //All 11 shown
		if ( user < 2 ) then
			height = 135 //7 shown
		elseif ( user < 3 ) then
			height = 170 //9 shown
		end
		

		list:SetSize(30,height)
		//list:SizeToContents()
		list:AddColumn("Tool Mode")
		list:SetMultiSelect(false)
		function list:OnRowSelected(LineID, line)
			if not (mode == LineID) then
				RunConsoleCommand("precision_setmode", LineID)
			end
		end

		if ( mode == 1 ) then
			list:AddLine(" 1 ->Apply<- (Directly apply settings to target)")
		else
			list:AddLine(" 1   Apply   (Directly apply settings to target)")
		end
		if ( mode == 2 ) then
			list:AddLine(" 2 ->Rotate<- (Turn an object without moving it)")
		else
			list:AddLine(" 2   Rotate   (Turn an object without moving it)")
		end
		if ( mode == 3 ) then
			list:AddLine(" 3 ->Move<- (Snap objects together - Great for building!)")
		else
			list:AddLine(" 3   Move   (Snap objects together - Great for building!)")
		end
		if ( mode == 4 ) then
			list:AddLine(" 4 ->Weld<-")
		else
			list:AddLine(" 4   Weld")
		end
		if ( mode == 5 ) then
			list:AddLine(" 5 ->Axis<-")
		else
			list:AddLine(" 5   Axis")
		end
		if ( mode == 6 ) then
			list:AddLine(" 6 ->Ballsocket<-")
		else
			list:AddLine(" 6   Ballsocket")
		end
		if ( user >= 2 ) then
			if ( mode == 7 ) then
				list:AddLine(" 7 ->Adv Ballsocket<-")
			else
				list:AddLine(" 7   Adv Ballsocket")
			end
			if ( mode == 8 ) then
				list:AddLine(" 8 ->Slider<-")
			else
				list:AddLine(" 8   Slider")
			end
		end
		if ( user >= 3 ) then
			if ( mode == 9 ) then
				list:AddLine(" 9 ->Parent<- (Like a solid weld, but without object collision)")
			else
				list:AddLine(" 9   Parent   (Like a solid weld, but without object collision)")
			end
			if ( mode == 10 ) then
				list:AddLine("10 ->Repair<- (Attempts to fix a flailing contraption)")
			else
				list:AddLine("10   Repair   (Attempts to fix a flailing contraption)")
			end
		end
		if ( mode == 11 ) then
			list:AddLine("11 ->Removal<- (Undoes constraints from target)")
		else
			list:AddLine("11   Removal   (Undoes constraints from target)")
		end
		list:SortByColumn(1)
		Panel:AddItem(list)

		if ( mode >= 4 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Move Target? ('Easy' constraint mode)", Command = "precision_move", Description = "Uncheck this to apply the constraint without altering positions." } )
		end
		if (  mode >= 3 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Rotate Target? (Rotation after moving)", Command = "precision_rotate", Description = "Uncheck this to remove the extra click for rotation. Handy for speed building." } )
			//Panel:AddControl( "Label", { Text = "This is the distance from touching of the targeted props after moving:", Description	= "Use 0 mostly, % takes the second prop's width." }  )
			Panel:AddControl( "Slider",  { Label	= "Snap Distance",
					Type	= "Float",
					Min		= 0,
					Max		= 10,
					Command = "precision_offset",
					Description = "Distance offset between joined props.  Type in negative to inset when moving."}	 )
			Panel:AddControl( "Checkbox", { Label = "Snap distance as Percent (%) of target's depth", Command = "precision_offsetpercent", Description = "Unchecked = Exact units, Checked = takes % of width from second prop" } )
		end
		if ( mode >= 2 && mode <= 8 ) then
			Panel:AddControl( "Slider",  { Label	= "Rotation Snap (Degrees)",
					Type	= "Float",
					Min		= 0.02,
					Max		= 90,
					Command = "precision_rotation",
					Description = "Rotation rotates by this amount at a time. No more guesswork. Min: 0.02 degrees "}	 ):SetDecimals( 4 )
		end
		if ( mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Freeze Target", Command = "precision_freeze", Description = "Freeze props when this tool is used" } )

			if ( mode >= 3 && mode <= 8 ) then
				Panel:AddControl( "Checkbox", { Label = "No Collide Targets", Command = "precision_nocollide", Description = "Nocollide pairs of props when this tool is used. Note: No current way to remove this constraint when used alone."  } )
			end
		end

		if ( user >= 2 || mode == 1 ) then
			if ( (mode >= 3 && mode <= 8) || mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Auto-align to world (nearest 45 degrees)", Command = "precision_autorotate", Description = "Rotates to the nearest world axis (similar to holding sprint and use with physgun)"  } )
			end

			if ( mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Disable target shadow", Command = "precision_ShadowDisable", Description = "Disables shadows cast from the prop"  } )
			end
		end

		if ( user >= 3 ) then
			if ( mode == 1 ) then //apply
				Panel:AddControl( "Checkbox", { Label = "Only Collide with Player", Command = "precision_nocollideall", Description = "Nocollides the first prop to everything and the world (except players collide with it). Warning: don't let it fall away through the world."  } )
				Panel:AddControl( "Checkbox", { Label = "Disable Physics on object", Command = "precision_physdisable", Description = "Disables physics on the first prop (gravity, being shot etc won't effect it)"  } )
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on PhysDisable objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use if you want to be able to manually move props after phyics disabling them (may break clipboxes)."  } )
				
				//Panel:AddControl( "Checkbox", { Label = "Drag", Command = "precision_drag", Description = ""  } )
			end
			if ( mode == 9 ) then //parent
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on Parented objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use this if you want to play with the parenting hierarchy etc."  } )
			end
		end
		if ( user >= 2 ) then
			if ( mode != 2 && mode != 3 && mode != 10 ) then //todo: entire contrap move/rotate support
				Panel:AddControl( "Checkbox", { Label = "Entire Contraption! (Everything connected to target)", Command = "precision_entirecontrap", Description = "For mass constraining or removal or nudging or applying of things. Yay generic."  } )
			end
		end

		if ( user >= 2 ) then
			if ( (mode >= 4 && mode <= 7) ) then //breakable constraint
				Panel:AddControl( "Slider",  { Label	= "Force Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_forcelimit",
						Description = "Applies to most constraint modes" }	 )
			end


			if ( mode == 5 || mode == 6 || mode == 7 ) then //axis or ballsocket
				Panel:AddControl( "Slider",  { Label	= "Torque Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_torquelimit",
						Description = "Breakpoint of turning/rotational force"}	 )
			end
		end

		if ( mode == 5 ) then //axis
			Panel:AddControl( "Slider",  { Label	= "Axis Friction",
					Type	= "Float",
					Min		= 0.0,
					Max		= 100,
					Command = "precision_friction",
					Description = "Turning resistance, this is best at 0 in most cases to conserve energy"}	 )
		end

		if ( mode ==7 ) then //adv ballsocket
			Panel:AddControl( "Slider",  { Label	= "X Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMin",
					Description = "Rotation minimum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMax",
					Description = "Rotation maximum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMin",
					Description = "Rotation minimum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMax",
					Description = "Rotation maximum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMin",
					Description = "Rotation minimum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMax",
					Description = "Rotation maximum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_XRotFric",
					Description = "Rotation friction of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_YRotFric",
					Description = "Rotation friction of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_ZRotFric",
					Description = "Rotation friction of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Checkbox", { Label = "Free Movement", Command = "precision_FreeMov", Description = "Only lock relative rotation, not position?"  } )
		end

		if ( mode == 8 ) then //slider
			Panel:AddControl( "Slider",  { Label	= "Slider Width",
					Type	= "Float",
					Min		= 0.0,
					Max		= 10,
					Command = "precision_width",
					Description = "Width of the slider black line (0 = invisible)"}	 )

			Panel:AddControl( "Checkbox", { Label = "Turn Off Minor Slider Stabilisation", Command = "precision_disablesliderfix", Description = "Fix being separate X/Y/Z advanced ballsocket locks between the props.  This stops most spaz caused by rotation, but not spaz caused by displacement." } )
			Panel:AddControl( "Label", { Text = "Stabilisation is separate X/Y/Z adv. ballsockets; it makes it far less prone to rotation triggered spaz, but the difference is only noticeable sometimes as it's still just as prone to spaz caused by drifting.", Description	= "Due to lack of working descriptions at time of coding" }  )
		end

		if ( mode == 9 ) then //parent
			Panel:AddControl( "Label", { Text = "Parenting Notes:", Description	= "Due to lack of working descriptions at time of coding" }  )
			Panel:AddControl( "Label", { Text = "Parenting objects is most similar to a very strong weld, but it stops most interaction on the first object when you attach it to the second.  Players can walk on it, but it will fall through players.  It will not collide with objects or the world.  It will also not cause any extra physics lag/spaz.  Try it out on a test object, and decide if it's useful to you!", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Parented objects are most useful for: Adding detail to moving objects without creating extra physics lag.  Things like houses that you want to move (though you can only safely walk on parented objects when they are still.)", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Possible issues:  Remove constraints first to avoid spaz. Duplicating or such may cause the collision model to become separated.  Best to test it if in doubt.", Description	= "Why must labels cause menu flicker? D:" }  )
		end
		
		if ( mode == 10 ) then //repair
			Panel:AddControl( "Label", { Text = "Repair mode", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Usage: When a contraption is going crazy, colliding, making rubbing noises.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "What it does: Temporarily toggles collisions, allowing things that are bent out of shape to pop back.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Warning: No guarantees.  This may turn things inside-out or make things worse depending on the situation.", Description	= "" }  )
		end
		if ( mode == 11 ) then //removal
			Panel:AddControl( "Label", { Text = "This mode will remove:", Description	= "" }  )
			Panel:AddControl( "Checkbox", { Label = "Nocollide", Command = "precision_removal_nocollide", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Weld", Command = "precision_removal_weld", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Axis", Command = "precision_removal_axis", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Ballsocket", Command = "precision_removal_ballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Adv. Ballsocket", Command = "precision_removal_advballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Slider", Command = "precision_removal_slider", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Parent", Command = "precision_removal_parent", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Other", Command = "precision_removal_other", Description = "" } )
			Panel:AddControl( "Label", { Text = "(Other = Rope/slider variants like winch/hydraulic, also motor/keepupright)", Description	= "" }  )
			Panel:AddControl( "Button", { Label = "Select All", Command = "precision_removal_all", Description = ""  } )
			Panel:AddControl( "Button", { Label = "Select None", Command = "precision_removal_none", Description = ""  } )

		end
		if ( showgenmenu == 1 ) then
			Panel:AddControl( "Button", { Label = "\\/ General Tool Options \\/", Command = "precision_generalmenu", Description = "Collapse menu"  } )




		local params = {Label = "User Level",Description = "Shows options appropriate to user experience level", MenuButton = "0", Height = 67, Options = {}}
		if ( user == 1 ) then
			params.Options[" 1 ->Normal<-"] = { precision_setuser = "1" }
		else
			params.Options[" 1   Normal"] = { precision_setuser = "1" }
		end
		if ( user == 2 ) then
			params.Options[" 2 ->Advanced<-"] = { precision_setuser = "2" }
		else
			params.Options[" 2   Advanced"] = { precision_setuser = "2" }
		end
		if ( user == 3 ) then
			params.Options[" 3 ->Experimental<-"] = { precision_setuser = "3" }
		else
			params.Options[" 3   Experimental"] = { precision_setuser = "3" }
		end

		Panel:AddControl( "ListBox", params )

			//Panel:AddControl( "Label", { Text = "General Tool Options:", Description	= "Note: These don't save with presets." }  )
			Panel:AddControl( "Checkbox", { Label = "Enable tool feedback messages?", Command = "precision_enablefeedback", Description = "Toggle for feedback messages incase they get annoying"  } )
			Panel:AddControl( "Checkbox", { Label = "On = Feedback in Chat, Off = Centr Scrn", Command = "precision_chatfeedback", Description = "Chat too cluttered? Can have messages centre screen instead"  } )
			//Panel:AddControl( "Checkbox", { Label = "Hide Menu Tips?", Command = "precision_hidehints", Description = "Streamline the menu once you're happy with using the tool."  } )
			Panel:AddControl( "Checkbox", { Label = "Add Push/Pull to Undo List", Command = "precision_nudgeundo", Description = "For if you're in danger of nudging somthing to where you can't reach it"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Movement to Undo List", Command = "precision_moveundo", Description = "So you don't have to secondary fire with nocollide to undo mistakes"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Rotation to Undo List", Command = "precision_rotateundo", Description = "So you can find the exact rotation value easier"  } )
			Panel:AddControl( "Button", { Label = "Restore Current Mode Default", Command = "precision_defaultrestore", Description = "Collapse menu"  } )
		else
			Panel:AddControl( "Button", { Label = "-- General Tool Options --", Command = "precision_generalmenu", Description = "Expand menu"  } )
			if ( user == 1 ) then
				Panel:AddControl( "Label", { Text = "(Note: For more modes and options like slider, use this options button and change the user level)", Description = "" }  )
			end
		end
	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			RunConsoleCommand("precision_move", "0")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_XRotMin", "0")
			RunConsoleCommand("precision_XRotMax", "0")
			RunConsoleCommand("precision_YRotMin", "0")
			RunConsoleCommand("precision_YRotMax", "0")
			RunConsoleCommand("precision_ZRotMin", "0")
			RunConsoleCommand("precision_ZRotMax", "0")
			RunConsoleCommand("precision_XRotFric", "0")
			RunConsoleCommand("precision_YRotFric", "0")
			RunConsoleCommand("precision_ZRotFric", "0")
			RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "0")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_width", "1")
			RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )
	

	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		//custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		//elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		//	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end
--addons/tools/lua/weapons/gmod_tool/stools/what_addon.lua:

TOOL.Category = "Stoneman"
TOOL.Name = "Addon Finder"


if CLIENT then
	language.Add( "tool.what_addon.name", "Addon Finder" )
	language.Add( "tool.what_addon.desc", "What addon is this model from?" )
	language.Add( "tool.what_addon.0", "Left click to find what addon something is from." )
else
    AddCSLuaFile("includes/modules/af_derma_extension.lua")
end

TOOL.ClientConVar[ "item_name" ] = "100"

// It seems like we have to do it for each fucking category for fuck sake
if CLIENT then
    local function DownloadPreviewImage(wsid, AddonIcon)
        steamworks.FileInfo( wsid, function( result )
            steamworks.Download( result.previewid, true, function( name )
                if not name then return end
                if not AddonIcon then return end
                AddonIcon:SetMaterial( AddonMaterial( name ) )
            end) 
        end)
    end

    local function SearchAddonsFrom(target, wildcard)
        // Open a new vgui for addon info!!!
        local AddonFrame = vgui.Create( "DFrame" )
        AddonFrame:SetSize( 750, 500 )
        AddonFrame:Center()
        AddonFrame:MakePopup()
        AddonFrame:SetTitle( "Addon Finder" )
        AddonFrame:SetVisible( true )
        AddonFrame:SetDraggable( true )
        AddonFrame:ShowCloseButton( true )
        // Make it blur background
        AddonFrame:SetBackgroundBlur( true )
        AddonFrame.Paint = function( self, w, h )
            draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
        end

        // Addon's icon!
        local AddonIcon = vgui.Create( "DImage", AddonFrame )
        AddonIcon:SetSize( 128, 128 )
        AddonIcon:Center()
        AddonIcon:SetPos( AddonIcon:GetX(), 32)
        AddonIcon:SetImage( "icon16/box.png" )

        // A bunch of data for the prop, and addon..
        local AddonName = vgui.Create( "DLabel", AddonFrame )
        AddonName:SetSize( 750, 32 )
        AddonName:SetPos( 32, AddonIcon:GetY() + 128 + 32 )
        AddonName:SetFont( "Trebuchet24" )
        AddonName:SetText( "Addon Name: Not Found!" )
        
        local FilePath = vgui.Create( "DLabel", AddonFrame )
        FilePath:SetSize( 750, 32 )
        FilePath:SetPos( 32, AddonName:GetY() + 32 )
        FilePath:SetFont( "Trebuchet24" )
        FilePath:SetText( "File Path: Not Found!" )

        local FileSize = vgui.Create( "DLabel", AddonFrame )
        FileSize:SetSize( 750, 32 )
        FileSize:SetPos( 32, FilePath:GetY() + 32 )
        FileSize:SetFont( "Trebuchet24" )
        FileSize:SetText( "File Size: Not Found!" )

        local GMAFile = vgui.Create( "DLabel", AddonFrame )
        GMAFile:SetSize( 750, 32 )
        GMAFile:SetPos( 32, FileSize:GetY() + 32 )
        GMAFile:SetFont( "Trebuchet24" )
        GMAFile:SetText( "GMA File: Not Found!" )

        // If it's not found, then it must be mounted from the addon folder.
        if FileSize:GetText() == "File Size: Not Found!" then
            AddonName:SetText( "Addon Name: Unknown" )
            FilePath:SetText( "File Path: " .. target )
            FileSize:SetText( "File Size: " .. file.Size( target, "GAME" ) / 1000000 .. " MB" )
        end

        // Button to visit the addon's page
        local VisitAddon = vgui.Create( "DButton", AddonFrame )
        VisitAddon:SetSize( 128, 32 )
        VisitAddon:Center()
        VisitAddon:SetY( AddonFrame:GetTall() - 64 )
        VisitAddon:SetText( "Open Workshop Page" )

        local result = StonemanAddonSearcherCache[target]

        // If you can't find it, but it's an entity, search for model instead!
        if result == nil and wildcard == "entity" then
            local npc = list.Get( "NPC" )[target]
            if npc then
                local model = npc.Model
                if model then model = string.lower( model ) end
                
                result = StonemanAddonSearcherCache[model]
            end

            if result == nil then
                local vehicle = list.Get( "Vehicles" )[target]
                if not vehicle then return end
                local model = vehicle.Model
                if model then model = string.lower( model ) end

                result = StonemanAddonSearcherCache[model]
            end
        end

        for _, addon in pairs( engine.GetAddons() ) do
            if result == addon.title then
                DownloadPreviewImage(addon.wsid, AddonIcon)
                AddonName:SetText( "Addon Name: " .. addon.title )
                FilePath:SetText( "File Path:" )
                // Make another label for file path
                local FilePathName = vgui.Create( "DLabel", AddonFrame )
                FilePathName:SetSize( 750, 32 )
                FilePathName:SetPos( FilePath:GetX() + 128, FilePath:GetY() )
                FilePathName:SetFont( "Trebuchet18" )
                FilePathName:SetText( target )

                if wildcard == "entity" then
                    FilePath:SetText( "Entity Name: " )
                elseif wildcard == "model" then
                    FilePath:SetText( "Model Path: " )
                elseif wildcard == "weapon" then
                    FilePath:SetText( "Weapon: " )
                elseif wildcard == "map" then
                    FilePath:SetText( "Map: " )
                end

                // Directly under the filepathname is a secret invisible button that copies the file path to clipboard
                local CopyFilePath = vgui.Create( "DButton", AddonFrame )
                CopyFilePath:SetSize( 750, 32 )
                CopyFilePath:SetPos( FilePathName:GetX(), FilePathName:GetY() )
                CopyFilePath:SetText( "" )
                CopyFilePath:SetToolTip( "Copy file path to clipboard")
                CopyFilePath.DoClick = function()
                    SetClipboardText( target )
                end
                CopyFilePath.Paint = function( self, w, h )
                    draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 0 ) )
                end

                // File size, we translate to megabytes! (10^6)
                FileSize:SetText( "File Size: " .. addon.size / 1000000 .. " MB" )
                GMAFile:SetText( "GMA File: ")
                // Make another label for GMA File Name
                local GMAFileName = vgui.Create( "DLabel", AddonFrame )
                GMAFileName:SetSize( 750, 32 )
                GMAFileName:SetPos( GMAFile:GetX() + 128, GMAFile:GetY() )
                GMAFileName:SetFont( "Trebuchet18" )
                GMAFileName:SetText( addon.file )

                // Directly under the GMAFileName is a secret invisible button that copies the file path to clipboard
                local CopyGMAFile = vgui.Create( "DButton", AddonFrame )
                CopyGMAFile:SetSize( 750, 32 )
                CopyGMAFile:SetPos( GMAFileName:GetX(), GMAFileName:GetY() )
                CopyGMAFile:SetText( "" )
                CopyGMAFile:SetToolTip( "Copy GMA file name to clipboard")
                CopyGMAFile.DoClick = function()
                    SetClipboardText( addon.file )
                end
                CopyGMAFile.Paint = function( self, w, h )
                    draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 0 ) )
                end
                
                VisitAddon.DoClick = function()
                    gui.OpenURL( "http://steamcommunity.com/sharedfiles/filedetails/?id=" .. addon.wsid )
                end
                return
            end
        end
    end

    concommand.Add("stoneman_search_addons", function(ply, cmd, args)
        local target = args[1]
        local wildcard = args[2]
        SearchAddonsFrom(target, wildcard)
    end)

    -- SilkIcons
    local egs_icon = "icon16/egs.png"
    local creator_icon = "icon16/wand.png"
    local delete_icon = "icon16/cross.png"
    local copy_icon = "icon16/page_copy.png"
    local search_icon = "icon16/magnifier.png"
    -- Prop Launcher compatability
    local pl_icon = "icon16/prop_launcher.png"

    local function CheckInstalledEGS()
        if file.Exists( "addons/entity_group_spawner_951638840.gma", "GAME" ) == true then
            return true
        elseif file.Exists( "weapons/gmod_tool/stools/egs.lua", "LUA") == true then
            return true
        else
            return false
        end
    end

    local function AddRecursive(addon, folder, wildcard)
        local files, folders = file.Find( folder .. "*", addon )
        if ( !files ) then MsgN( "Warning! Not opening '" .. folder .. "' because we cannot search in it!"  ) return false end
    
        for k, v in pairs( files ) do
            if wildcard == "weapon" or wildcard == "entity" then
                if ( !string.EndsWith( v, ".lua" ) ) then continue end
                local found = v
                
                // Remove the .lua extension
                found = string.gsub(found, ".lua", "")
                found = string.lower(found)
                StonemanAddonSearcherCache[found] = addon

                continue
            else
                if ( !string.EndsWith( v, ".mdl" ) ) then continue end
                local found = folder..v
                found = string.lower(found)
                StonemanAddonSearcherCache[found] = addon

                continue
            end
        end
    
        for k, v in pairs( folders ) do 
            if wildcard == "weapon" or wildcard == "entity" then
                local found = v
                found = string.lower(found)
                StonemanAddonSearcherCache[found] = addon

                continue
            else
                AddRecursive( addon, folder .. v .. "/", wildcard )
            end
        end
    end

    local function SearchForMaps(addon)
        local files, folders = file.Find(  "maps/".. "*", addon )
        for k, v in pairs( files ) do
            if ( !string.EndsWith( v, ".bsp" ) ) then continue end
            local found = v
            found = string.gsub(found, ".bsp", "")
            StonemanAddonSearcherCache[found] = addon
        end
    end
    
    local function BeginSearching()
        // Put all models into a table. Every last one.
        for _, addon in SortedPairsByMemberValue( engine.GetAddons(), "title" ) do
            if addon.mounted and addon.downloaded then
                AddRecursive(addon.title, "models/", "model")
                AddRecursive(addon.title, "lua/weapons/", "weapon")
                AddRecursive(addon.title, "lua/entities/", "entity")
                SearchForMaps(addon.title)
            end
        end
    end
    
    hook.Add("InitPostEntity", "StonemanAddonSearcher:Cache", function()
        StonemanAddonSearcherCache = {}
        BeginSearching()
    end)
    
    concommand.Add("stoneman_search_addons_reload", function()
        StonemanAddonSearcherCache = {}
        BeginSearching()
    end)

    require('af_derma_extension')

    local validContentTypes = {
        ['weapon'] = true,
        ['entity'] = true,
        ['npc'] = true,
        ['vehicle'] = true
    }

    hook.Add('AF.ContentIconMenuExtraOpened', 'addon_finder_option', function(contentIcon, dmenu)
        if not isfunction(contentIcon.GetContentType) then
            dmenu:AddOption('Find Addon', function()
                RunConsoleCommand("stoneman_search_addons", contentIcon:GetModelName(), "model")
            end):SetImage('icon16/magnifier.png')
        else
            local ContentType = contentIcon:GetContentType()

            if ContentType and validContentTypes[ContentType] then
                dmenu:AddOption('Find Addon', function()
                    if ContentType == "weapon" then
                        RunConsoleCommand("stoneman_search_addons", contentIcon:GetSpawnName(), "weapon")
                    else
                        RunConsoleCommand("stoneman_search_addons", contentIcon:GetSpawnName(), "entity")
                    end
                end):SetImage('icon16/magnifier.png')
            end
        end
    end)
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl("Header", { Text = "#tool.what_addon.name", Description = "#tool.what_addon.desc" })
	// a text fill that accepts stuff
	local TextEntrys = vgui.Create("DTextEntry")
	TextEntrys:SetSize(200, 30)
	TextEntrys:SetText("")
	TextEntrys.OnEnter = function(self)
		// If it doesn't end with .mdl, nothing happens
		local text = self:GetValue()
		if not string.EndsWith(text, ".mdl") then return end
		RunConsoleCommand("stoneman_search_addons", self:GetValue(), ".mdl")
	end

	CPanel:AddItem(TextEntrys)

	// Reset / Refresh button!
	local button = vgui.Create("DButton")
	button:SetText("Search!")
	button:SetSize(200, 30)
	button.DoClick = function()
		RunConsoleCommand("stoneman_search_addons", TextEntrys:GetValue(), ".mdl")
	end

    CPanel:AddItem(button)
    // Get current map button!
    local button2 = vgui.Create("DButton")
    button2:SetText("Search for current map!")
    button2:SetSize(200, 30)
    button2.DoClick = function()
        RunConsoleCommand("stoneman_search_addons", game.GetMap(), "map")
    end

    CPanel:AddItem(button2)
end

local DisallowedEntities = {
    "prop_physics",
    "prop_physics_multiplayer",
    "prop_physics_respawnable",
    "prop_ragdoll",
    "prop_dynamic",
    "prop_dynamic_ornament",
    "prop_dynamic_override",
    "func_brush",
}

local function CheckForValidTrace(tr)
	// See what entity something is from
	if not tr.Entity then return end
	if not tr.Entity:IsValid() then return end
	if tr.Entity:IsWorld() then return end
    if tr.Entity:IsWeapon() then
	    RunConsoleCommand("stoneman_search_addons", tr.Entity:GetClass(), "weapons")
    elseif tr.Entity:IsNPC() or tr.Entity:IsNextBot() or tr.Entity:IsScripted() then
        RunConsoleCommand("stoneman_search_addons", tr.Entity:GetClass(), "entity")
    else
        RunConsoleCommand("stoneman_search_addons", tr.Entity:GetModel(), "models")
    end
end

function TOOL:LeftClick(tr)
    if not IsFirstTimePredicted() then return end
    if game.SinglePlayer() then
        CheckForValidTrace(tr)
    end
    
    if SERVER then return end

    CheckForValidTrace(tr)
	return false
end
--lua/weapons/gold_spanish_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Gold Spanish sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Gold"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(15, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -1), angle = Angle(0, 90, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 216, 0, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 28
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.28
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/weapons/jet_mk1.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jetpack mit Model"
SWEP.Category	= "Star Wars Jetpacks"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= false
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		--if (ply.LastJetExecuted or 0)+0 >= CurTime() then return end
		local jp = ents.Create('mk1')
		jp:SetSlotName('mk1')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--addons/arccw_weapons/lua/weapons/masita_dc15a_modular.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Modular DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_modular.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.DefaultBodygroups = "00000000"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 32
SWEP.RangeMin = 207
SWEP.DamageMin = 24
SWEP.Range = 301
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -14, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -6)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.AttachmentElements = {
    ["15a_rangefinder"] = {
        VMBodygroups = {{ind = 6, bg = 2}},
    },
    ["15a_barrel_up"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["15a_barrel_short"] = {
        NameChange = "Short DC-15a",
        VMBodygroups = {{ind = 3, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 25.7),
            },
        }
    },
    ["15a_barrel_extended"] = {
        NameChange = "Extended DC-15a",
        VMBodygroups = {{ind = 3, bg = 3}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["15a_barrel_longrange"] = {
        NameChange = "DC-15x",
        VMBodygroups = {{ind = 3, bg = 4}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["15a_foregrip"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 6, bg = 2}
        },
    },
    ["15a_top_short"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["15a_top_closecombat"] = {
        NameChange = "Close-quarter DC-15a",
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["15a_top_stabilizer"] = {
        NameChange = "DC-15le",
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["15a_stock_short"] = {
        NameChange = "Skeleton DC-15a",
        VMBodygroups = {{ind = 10, bg = 1}},
    },
}

SWEP.Attachments = {
    [1] = {
        PrintName = "Long-Range Scope",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -2.2, 2.2),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },     
    [2] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(00, -1.3, 30.5),
            vang = Angle(90, 0, -90),

        },
    },       
    [3] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "15a_barrel",
    },   
    [4] = {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"15a_foregrip", "foregrip"},
        Bone = "dc-15a",
        InstalledEles = {"15a_rangefinder"},
        Offset = {
            vpos = Vector(0.1, 0, 11),
            vang = Angle(90, 0, -90),

        },
    },  
    [5] = {
        PrintName = "Top",
        DefaultAttName = "None",
        Slot = "15a_top",
    },  
    [6] = {
        PrintName = "Mag",
        DefaultAttName = "None",
        Slot = {"dc15a_magazine_75"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(-0.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },  
    [7] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = "15a_stock",
    },  
    [8] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    [9] = {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    [10] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [11] = {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },    
    [12] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.1, -1),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dc15le.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15le"
SWEP.Trivia_Class = "Heavy Long Range Battle-Rifle"
SWEP.Trivia_Desc = "The DC-15le blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15le.png"


-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "000000011"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 221
SWEP.DamageMin = 27
SWEP.Range = 573
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 427
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 327
SWEP.Num = 1

SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1 
SWEP.BipodRecoil = 1

-- Attachments
SWEP.Attachments = {  
    {
        PrintName = "Optic", 
        DefaultAttName = "Iron Sights", 
        Slot = "optic",
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(-0.5,-1.9,10),
            vang = Angle(90,0,-40),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },         
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },     
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-0.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = {"rep_ubgl"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 30.675),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 35
SWEP.DamageMin = 15
SWEP.RangeMin = 530
SWEP.Range = 1200
SWEP.Delay = 60 / 327
SWEP.Primary.ClipSize = 55
SWEP.Category = 'REP'


--addons/arccw_weapons/lua/weapons/masita_repshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Republic Blast Shield"
SWEP.Trivia_Class = "Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Manufacturer = "Grand Army of the Republic"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/republic_shield.png"

SWEP.Slot = 0

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw_go/v_shield.mdl"
SWEP.WorldModel = "models/weapons/arccw_go/v_shield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/weapons/arccw_go/v_shield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 35
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "arccw_go/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "physics/metal/metal_barrel_impact_hard7.wav",
}
SWEP.MeleeHitNPCSound = {
    "physics/body/body_medium_break3.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 3)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_05.wav"
})
--addons/joes_stuff/lua/weapons/personal_shield/shared.lua:
AddCSLuaFile()

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.UseHands = true
SWEP.Category = "AOCRP - Schilde"

SWEP.PrintName = "Personal Shield Base"
SWEP.Author = "Joe"
SWEP.Purpose = ""

SWEP.ViewModelFOV	= 80
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= ""
SWEP.WorldModel		= ""
SWEP.Primary.Ammo = "none"
SWEP.Secondary.Ammo = "none"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1

SWEP.health = SWRPShield.personalshieldhp

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

function SWEP:PrimaryAttack()
    if not SERVER then return end
    local ply = self.Owner
    if not IsValid(ply) then return end
    if ply.per_shieldcooldown and ply.per_shieldcooldown >= CurTime() then return end
    if IsValid(ply.per_shield) then
        self:CloseShield()
    else
        self:OpenShield()
        ply.per_shieldcooldown = CurTime() + 1
    end
end

function SWEP:OpenShield()
    local ply = self.Owner
    local ent = ents.Create("shield_bubble_personal")
    ent:SetModel("models/jackjack/props/fullsphere.mdl")
    ent:SetRadius(45)
    ent:SetShieldOwner(ply)
  	ent:SetPos(ply:GetPos() + ply:OBBCenter() + Vector(0,0,10)) 
    ent:SetHealth(self.health)
    ent:Spawn()
    ply:EmitSound("hl1/fvox/activated.wav")
    ply.per_shield = ent
end

function SWEP:CloseShield()
    local ply = self.Owner
    ply.per_shield:Remove()
    ply.per_shield = nil 
    ply:EmitSound("hl1/fvox/deactivated.wav")
    ply.per_shieldcooldown = CurTime() + SWRPShield.personalshieldcooldown
end

function SWEP:SecondaryAttack()
    if IsValid(self.Owner.per_shield) then
        self:CloseShield()
    end
end

function SWEP:Reload()

end

function SWEP:Initialize()
    self:SetHoldType("normal")
end
--addons/joes_stuff/lua/weapons/shield_deployer_1/shared.lua:
AddCSLuaFile()

SWEP.Base = "shield_deployer_base"
SWEP.PrintName = "Shield Level 1 Deployer"
SWEP.Category = "AOCRP - Schilde"

SWEP.Author = "Joe"
SWEP.Purpose = "Deploy Shields"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true


SWEP.ENT_CLASS = "shield_1"
--lua/weapons/weapon_base/sh_anim.lua:
local ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

--[[---------------------------------------------------------
   Name: SetWeaponHoldType
   Desc: Sets up the translation table, to translate from normal 
			standing idle pose, to holding weapon pose.
-----------------------------------------------------------]]
function SWEP:SetWeaponHoldType( t )

	t = string.lower( t )
	local index = ActIndex[ t ]
	
	if ( index == nil ) and !wOS.AnimExtension.TranslateHoldType[ t ] then
		Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal)\n" )
		t = "normal"
		index = ActIndex[ t ]		
	end
	
	if wOS.AnimExtension.TranslateHoldType[ t ] then 
		self.ActivityTranslate = table.Copy( wOS.AnimExtension.TranslateHoldType[ t ]:GetActivityList() )
	else
		self.ActivityTranslate = {}
		self.ActivityTranslate [ ACT_MP_STAND_IDLE ] 				= index
		self.ActivityTranslate [ ACT_MP_WALK ] 						= index+1
		self.ActivityTranslate [ ACT_MP_RUN ] 						= index+2
		self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ] 				= index+3
		self.ActivityTranslate [ ACT_MP_CROUCHWALK ] 				= index+4
		self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ] 	= index+5
		self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5
		self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]		 		= index+6
		self.ActivityTranslate [ ACT_MP_JUMP ] 						= index+7
		self.ActivityTranslate [ ACT_RANGE_ATTACK1 ] 				= index+8
		self.ActivityTranslate [ ACT_MP_SWIM ] 						= index+9	
	end
	
	-- "normal" jump animation doesn't exist
	if t == "normal" then
		self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM
	end

	self:SetupWeaponHoldTypeForAI( t )

end

-- Default hold pos is the pistol
SWEP:SetWeaponHoldType( "pistol" )

--[[---------------------------------------------------------
   Name: weapon:TranslateActivity( )
   Desc: Translate a player's Activity into a weapon's activity
		 So for example, ACT_HL2MP_RUN becomes ACT_HL2MP_RUN_PISTOL
		 Depending on how you want the player to be holding the weapon
-----------------------------------------------------------]]
function SWEP:TranslateActivity( act )

	if ( self.Owner:IsNPC() ) then
		if ( self.ActivityTranslateAI[ act ] ) then
			return self.ActivityTranslateAI[ act ]
		end
		return -1
	end

	if ( self.ActivityTranslate[ act ] != nil ) then
		return self.ActivityTranslate[ act ]
	end

	return -1

end
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_nuru.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Nuru Kungurama"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("zatt")
		self:SetBladeR("blue")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
    ply:lscsAddInventory("item_force_throw", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)

	ply:lscsAddInventory("item_stance_djemso", true)
	ply:lscsAddInventory("item_stance_ataru", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapons_other/lua/weapons/weapon_standardswordart/shared.lua:
if (SERVER) then
	AddCSLuaFile()
end

if (CLIENT) then
	SWEP.Slot = 0
	SWEP.SlotPos = 5
	SWEP.DrawAmmo = false
	SWEP.PrintName = "Standard Sword Art"
	SWEP.DrawCrosshair = true
end


SWEP.ViewModelFOV = 77
SWEP.UseHands = false
SWEP.Category = "Custom Character"
SWEP.Instructions = "do your combo "
SWEP.Purpose = ""
SWEP.Contact = ""
SWEP.Author = "YongLi"
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/weapons/charactersword.mdl"
SWEP.AdminOnly = true
SWEP.Spawnable = false

SWEP.Primary.NeverRaised = true
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.Damage = 90
SWEP.Primary.Delay = 3
SWEP.Primary.Ammo = ""
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.Delay = 0
SWEP.Secondary.Ammo = ""


--gamemodes/starwarsrp/entities/entities/aoc_hackterminal_training.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Terminal (Training)"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true
ENT.Editable = true

function ENT:SetupDataTables()


	self:NetworkVar( "String", 0, "AnzeigeName", { KeyName = "AnzeigeName",	Edit = { type = "Text"  } } ) 
	self:NetworkVar( "Int", 0, "WaitTime", { KeyName = "WaitTime",	Edit = { type = "Int", mix = 1, max = 500  } } ) 

	if SERVER then
		self:SetAnzeigeName("Trainingsterminal")
        self:SetWaitTime(1)
	end

end


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/starwars/syphadias/props/hoth_barrack/console_1.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


        self.CableTable = {
            [1] = {
                pos = Vector(2.032251, 6.022954, 26.184006),
                ang = Angle(58.160, 22.754, 72.184),
            },
            [2] = {
                pos = Vector(-2.647063, 7.137735, 12.956272),
                ang = Angle(24.138, 85.227, -90.413),
            },
            [3] = {
                pos = Vector(-8.424945, -3.761531, 29.757538),
                ang = Angle(75.625, 89.618, 88.550),
            },
            [4] = {
                pos = Vector(1.253638, -9.945827, 29.554203),
                ang = Angle(79.388, -84.360, -87.514),
            },
            [5] = {
                pos = Vector(10.601143, -0.763375, 31.281775),
                ang = Angle(87.242, -2.380, 101.274),
            },
        }


        local combination = AOCRP.Config.TerminalCombinations[math.random(#AOCRP.Config.TerminalCombinations)]
        for k, v in pairs(self.CableTable) do
            self.CableTable[k].col = combination[k][1]
            self.CableTable[k].cut = combination[k][2]
        end
    
        self.cables = {}

        self.CurrentDelay = 0


    end
    


 
 
    function ENT:Use( activator, caller )


        if self.Hacked then 
            AOCRP.HUD:Notify(activator, "Dieses Terminal wurde erfolgreich gehackt, generiere neue Kombination!", 1)

            
            local combination = AOCRP.Config.TerminalCombinations[math.random(#AOCRP.Config.TerminalCombinations)]
            for k, v in pairs(self.CableTable) do
                self.CableTable[k].col = combination[k][1]
                self.CableTable[k].cut = combination[k][2]
            end
            
            self.Hacked = false
        end 

        if self.CurrentDelay > CurTime() then
            local waitTime = math.Round(self.CurrentDelay - CurTime())
            AOCRP.HUD:Notify(activator, "Du musst noch " .. waitTime .. "s warten bevor du dieses Terminal erneut hacken kannst!", 2)
            return
        end

        if !self.HackingActive then

            self.HackingActive = true 

            --activator:ConCommand("say /me öffnet die Panele des Terminals und zieht die Kabel hervor.")

            self.Hacker = activator

            for number,data in pairs(self.CableTable) do
                local ent = ents.Create("joe_cable")
                ent:SetPos(self:LocalToWorld(data.pos))
                ent:SetAngles(self:GetAngles() - data.ang)
                ent:SetColor(BombSystem.colors[data.col])
                ent.data = {pos = data.pos, ang = data.ang}
                ent.cut = data.cut
                ent.bomb = self
                ent:Spawn()
                ent:Activate()
                ent:SetUnPresetColor(data.col)
                self.cables[ent] = true
                constraint.NoCollide(self, ent, 0, 0)
            end
            
        else

            self:RemoveCables()
            --activator:ConCommand("say /me packt die Kabel wieder rein und schließt die Panele.")
        end


    end

    function ENT:RemoveCables()
        for v,_ in pairs(self.cables) do
            if not IsValid(v) then continue end
            v:Remove()
        end
        self.cables = {}

        self.HackingActive = false 

        self.curexpected = nil
    end


    function ENT:OnRemove()
        self:RemoveCables()
    end

    function ENT:Think()
        if self.HackingActive then
            for v,_ in pairs(self.cables) do
                if not IsValid(v) then continue end
                v:SetPos(self:LocalToWorld(v.data.pos))
                v:SetAngles(self:GetAngles() - v.data.ang)
            end
        end
    end



    function ENT:NotCorrect()
        self:RemoveCables()
        self:EmitSound("everfall/equipment/squad_shield/break/gadgets_burstshieldundeploysparks_var_01_0"..math.random(9)..".mp3")

        self.CurrentDelay = CurTime() + self:GetWaitTime()
    end

    function ENT:Correct()
        self.Hacked = true
        self:EmitSound("ambient/alarms/warningbell1.wav")

        if IsValid(self.Hacker) then
            --self.Hacker:addMoney(5, "Hacken eines Trainingsterminals")
        end
        --AOCRP.Chat:TeamPrint( self:GetAnzeigeName() .. " wurde erfolgreich gehackt. ")
        --AOCRP.Chat:GlobalPrint("*** " .. self:GetAnzeigeName() .. " wurde erfolgreich gehackt.")
    end

    function ENT:CableCut(cable)
		if cable.cut == false then
			self:NotCorrect()
		else
			if isnumber(cable.cut) then
				self.curexpected = self.curexpected or 1
				if cable.cut == self.curexpected then
					for v,_ in pairs(self.cables) do
						if not v.cut or not isnumber(v.cut) then continue end
						if v.cut > self.curexpected then
							self.curexpected = self.curexpected + 1
							return
						end
					end
					self:Correct()
				else
					self:NotCorrect()
				end
			else
				self:Correct()
			end
		end
    end

end


--gamemodes/starwarsrp/entities/entities/aoc_medicbox.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Sanitätsausrüstung"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/crate_03/crate_03.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
        wep = activator:GetActiveWeapon()
        if wep then
            if wep:GetClass() == "aocrp_medicscanner" then
                wep:SetClip1(AOCRP.Config.DefaultMedicSupply)
                --self:EmitSound("everfall/miscellaneous/ux/navigation/navigation_weaponequip_01.mp3")
                --AOCRP.HUD:Notify(activator, "Medizinische Vorräte wieder aufgefüllt.", 1) 
                AOCRP.HUD:Notification(activator, {text="Medizinische Vorräte wieder aufgefüllt",barcolor=Color(0,255,0),sound="everfall/miscellaneous/ux/navigation/navigation_weaponequip_01.mp3"}) 
            end  
        end
    end


end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.
                                    -- Use this when you need to add to the rendering.
        --self:DrawEntityOutline( 1.0 ) -- Draw an outline of 1 world unit.
        --self:DrawModel()       -- Draw the model.


    end

end
--gamemodes/starwarsrp/entities/entities/aoc_terminal.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Modulares Terminal"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.Editable = true
ENT.BlockDrag = true

function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "TerminalID", { KeyName = "TerminalID",	Edit = { type = "Text"  } } ) 
    self:NetworkVar( "String", 1, "CurrentMenu" ) 


    if SERVER then
        self:SetTerminalID("none")
        self:NetworkVarNotify( "TerminalID", self.UpdateTerminalData )
    end

end

if SERVER then
        
    function ENT:UpdateTerminalData( name, old, new )
        
        
        if !AOCRP.Terminal:Exists(new) then return end
        --print("Changing model to "..new)
        self:SetModel( AOCRP.Terminal[new].model  )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,

    end


    function ENT:Initialize()

        self:SetModel( "models/reizer_props/alysseum_project/console/holo_screen_01/holo_screen_01.mdl" )
        self:DrawShadow( false )
        --self:SetColor(Color(225,0,255))
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )
        --self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end


        



end


if CLIENT then

    ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

    function ENT:DrawTranslucent()

        if !AOCRP.Terminal:Exists(self:GetTerminalID()) then return end

        if !AOCRP.Terminal[self:GetTerminalID()].noDraw then
        self:DrawModel()

        end


    -- While you can of course use the imgui.Start3D2D function for entities, IMGUI has some special syntax
    -- This function automatically calls LocalToWorld and LocalToWorldAngles respectively on position and angles 

        AOCRP.Terminal[self:GetTerminalID()].drawTranslucent(self)
 
    end
--[[ 
    function ENT:Draw()
        self:DrawModel() 
    end ]]
end















AOCRP.Terminal = {}



function AOCRP.Terminal:Exists(id) 
    return AOCRP.Terminal[id]
end


if CLIENT then
    AOCDerma:RegisterFont("AOCRP.TERMINAL.TITLE", "Agency FB", 50, 1)


end

AOCRP.Terminal["none"] = {

    model = "models/reizer_props/alysseum_project/console/holo_screen_01/holo_screen_01.mdl",

    drawTranslucent = function(self)
        if AOCRP.IMGUI.Entity3D2D(self, Vector(0, 0, 86), Angle(0, 90, 90), 0.1) then
            -- render things
            surface.SetDrawColor(0, 52, 82)
            surface.DrawRect(-660, 0, 660*2, 511)

            draw.DrawText("! TERMINAL NICHT EINGERICHTET !", "DermaLarge", 0,50, Color(255,0,0), TEXT_ALIGN_CENTER)

            AOCRP.IMGUI.End3D2D()
        end
    end,

}


AOCRP.Terminal["nonedisplay"] = {

    model = "models/reizer_props/alysseum_project/console/holo_screen_03/holo_screen_03.mdl",

    drawTranslucent = function(self)
        if AOCRP.IMGUI.Entity3D2D(self, Vector(0, 0, 55), Angle(0, 90, 90), 0.1) then
            -- render things
            surface.SetDrawColor(0, 52, 82)
            surface.DrawRect(-660, 0, 660*2, 511)

            draw.DrawText("! TERMINAL NICHT EINGERICHTET !", "DermaLarge", 0,50, Color(255,0,0), TEXT_ALIGN_CENTER)

            AOCRP.IMGUI.End3D2D()
        end
    end,

}



AOCRP.Terminal["galaxymap"] = {

    model = "models/hunter/plates/plate2x2.mdl",

    drawTranslucent = function(self)
        local imgui = AOCRP.IMGUI

        
        if imgui.Entity3D2D(self, Vector(0, 0, 0), Angle(0, 0, 0), 0.05, 500, 200) then
            -- Get your ship's position dynamically (replace this with your actual code to get ship's position)

            local width = 3500
            local height = 2000

            local maxDrawwidth = width - 200
            local maxDrawheight = height - 200

            surface.SetDrawColor(0, 52, 82,255)
            surface.DrawRect(-width/2, -height/2, width, height)

            if self:GetCurrentMenu() == "" then
                draw.DrawText("Nautische Konsole", imgui.xFont("!Agency FB@200"), 0, -height/2+100, Color(255, 255, 255), TEXT_ALIGN_CENTER)
        
                if imgui.xTextButton("Sektorkarte", "!Agency FB@150", -500, -300, 1000, 200, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("karte")
                        net.WriteEntity(self)
                    net.SendToServer()
                end  
                if imgui.xTextButton("Zielkoordinaten setzen", "!Agency FB@150", -500, 0, 1000, 200, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("hyperspace")
                        net.WriteEntity(self)
                    net.SendToServer()
                end  

            elseif self:GetCurrentMenu() == "karte" then
                local shipPosition = Vector(12545, -170, 0)  -- Example ship's position
            
                -- Calculate the offset to center the ship
                local offsetX = -shipPosition.x
                local offsetY = -shipPosition.y
            

                surface.SetDrawColor(0, 52, 82,255)
                surface.DrawRect(-width/2, -height/2, width, height)

                if #AOCRP.Terminal.PlanetData <= 0 then 
                
                    if imgui.xTextButton("Galaxiskarte laden", "!Agency FB@150", -500, 300, 1000, 200, 1, Color(255,255,255)) then
                        AOCRP.Terminal:LoadPlanetData()
                    end  
                end
            
                for k, v in pairs(AOCRP.Terminal.PlanetData) do
                    -- Adjust the planet coordinates based on the ship's position
                    local adjustedX = v["x"] + offsetX
                    local adjustedY = v["y"] + offsetY
            

                    if adjustedX >= -maxDrawwidth/2 and adjustedX <= maxDrawwidth/2 and adjustedY >= -maxDrawheight/2 and adjustedY <= maxDrawheight/2 then

                            surface.SetDrawColor(255, 255, 255,200)
                            if v["control"] == -1 then
                                surface.SetDrawColor(255, 0, 0)
                            end 
                            if v["control"] == 1 then
                                surface.SetDrawColor(0, 255, 0)
                            end 
                            surface.DrawRect(adjustedX-19/2, adjustedY-19/2, 19, 19)
                    
                            draw.DrawText(v["name"] or "NULL", imgui.xFont("!TargetID@35"), adjustedX , adjustedY + 10, Color(196, 196, 196), TEXT_ALIGN_CENTER)


                            if imgui.xButton(adjustedX-10, adjustedY-10, 20, 20, 4, Color(0,0,0)) then
                                net.Start("AOCRP.Terminal.SetCurrentMenu")
                                    net.WriteString(v["id"])
                                    net.WriteEntity(self)
                                net.SendToServer()
                            end
        
                        --end
                    end
                end
            
                surface.SetDrawColor(255, 0, 0, 100)
                surface.DrawRect(-25,-25,50,50)

                draw.DrawText("X:"..shipPosition.x .. " Y:"..shipPosition.y, imgui.xFont("!TargetID@30"), 0, 25, Color(0, 0, 0), TEXT_ALIGN_CENTER)


                if imgui.xTextButton("Daten neuladen", "!Agency FB@40", width/2-225, height/2-75, 200, 50, 1, Color(255,255,255)) then
                    AOCRP.Terminal:LoadPlanetData()
                end 


                
                if imgui.xTextButton("<<", "!Agency FB@150", -width/2+50, height/2-250, 200, 200, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("")
                        net.WriteEntity(self)
                    net.SendToServer()
                    
                end  

            elseif self:GetCurrentMenu() == "hyperspace" then 


                
                if imgui.xTextButton("<<", "!Agency FB@150", -width/2+50, height/2-250, 200, 200, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("")
                        net.WriteEntity(self)
                    net.SendToServer()
                    
                end  

                draw.DrawText("Zielkoordinaten setzen", imgui.xFont("!Agency FB@200"), 0, -height/2+100, Color(255, 255, 255), TEXT_ALIGN_CENTER)
        
                Xpos = Xpos or ""
    
                -- Define the position and size of the NumPad
                local numPadX = -900
                local numPadY = -height/2+800
                local numPadWidth = 500
    
                draw.DrawText("X: "..Xpos, imgui.xFont("!Agency FB@200"), numPadX+400, -height/2+500, Color(255, 255, 255), TEXT_ALIGN_CENTER)
            
                -- Draw the NumPad
                local buttonSize = numPadWidth / 4
                local buttonSpacing = buttonSize / 4
                for i = 0, 9 do
                    local row = math.floor(i / 3)
                    local col = i % 3
                    local buttonX = numPadX + col * (buttonSize + buttonSpacing)
                    local buttonY = numPadY + row * (buttonSize + buttonSpacing)
                    if i == 9 then
                        buttonX = numPadX + (buttonSize + buttonSpacing) * 2
                        buttonY = numPadY + 3 * (buttonSize + buttonSpacing)
                    else
                        buttonX = numPadX + (col + 1) * (buttonSize + buttonSpacing)
                        buttonY = numPadY + row * (buttonSize + buttonSpacing)
                    end
                    if imgui.xTextButton(tostring(i), "!Agency FB@80", buttonX, buttonY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                        Xpos = Xpos .. tostring(i)
                    end
                end
            
                local commaX = numPadX + (buttonSize + buttonSpacing)
                local commaY = numPadY + 3 * (buttonSize + buttonSpacing)
                if imgui.xTextButton(",", "!Agency FB@80", commaX, commaY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                    Xpos = Xpos .. ","
                end
            
                local okX = numPadX + 3 * (buttonSize + buttonSpacing)
                local okY = numPadY + 3 * (buttonSize + buttonSpacing)
                if imgui.xTextButton("C", "!Agency FB@80", okX, okY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                    Xpos = ""
                end
    
    
    
                        
                Ypos = Ypos or ""
    
                -- Define the position and size of the NumPad
                local numPadX = 200
                local numPadY = -height/2+800
                local numPadWidth = 500
    
                draw.DrawText("Y: "..Ypos, imgui.xFont("!Agency FB@150"), numPadX+400, -height/2+500, Color(255, 255, 255), TEXT_ALIGN_CENTER)
            
                -- Draw the NumPad
                local buttonSize = numPadWidth / 4
                local buttonSpacing = buttonSize / 4
                for i = 0, 9 do
                    local row = math.floor(i / 3)
                    local col = i % 3
                    local buttonX = numPadX + col * (buttonSize + buttonSpacing)
                    local buttonY = numPadY + row * (buttonSize + buttonSpacing)
                    if i == 9 then
                        buttonX = numPadX + (buttonSize + buttonSpacing) * 2
                        buttonY = numPadY + 3 * (buttonSize + buttonSpacing)
                    else
                        buttonX = numPadX + (col + 1) * (buttonSize + buttonSpacing)
                        buttonY = numPadY + row * (buttonSize + buttonSpacing)
                    end
                    if imgui.xTextButton(tostring(i), "!Agency FB@80", buttonX, buttonY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                        
                        Ypos = Ypos .. tostring(i)
                    end
                end
            
                local commaX = numPadX + (buttonSize + buttonSpacing)
                local commaY = numPadY + 3 * (buttonSize + buttonSpacing)
                if imgui.xTextButton(",", "!Agency FB@80", commaX, commaY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                    -- Handle button click event for comma
                    -- You can add your logic here
                    Ypos = Ypos .. ","
                end
            
                local okX = numPadX + 3 * (buttonSize + buttonSpacing)
                local okY = numPadY + 3 * (buttonSize + buttonSpacing)
                if imgui.xTextButton("C", "!Agency FB@80", okX, okY, buttonSize, buttonSize, 1, Color(255,255,255)) then
                    -- Handle button click event for OK
                    -- You can add your logic here
                    Ypos = ""
                end
            
    
                if imgui.xTextButton("ZIEL BESTÄTIGEN", "!Agency FB@150", -500, height/2-250, 1000, 200, 1, Color(0,255,0)) then
                    
                end  

                
            else

                if imgui.xTextButton("<<", "!Agency FB@150", -width/2+50, height/2-250, 200, 200, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("karte")
                        net.WriteEntity(self)
                    net.SendToServer()
                    
                end  

                if AOCRP.Terminal.PlanetData[tonumber(self:GetCurrentMenu())] then

                    local PlanetData = AOCRP.Terminal.PlanetData[tonumber(self:GetCurrentMenu())]
                    
                    draw.DrawText(PlanetData["name"], imgui.xFont("!Agency FB@200"), 0, -height/2+50, Color(255, 255, 255), TEXT_ALIGN_CENTER)

                    draw.DrawText("X: ".. PlanetData["x"] .. " / Y: ".. PlanetData["y"], imgui.xFont("!Agency FB@125"), 0, -height/2+250, Color(255, 255, 255), TEXT_ALIGN_CENTER)

                    draw.DrawText("Region: \n"..PlanetData["region"] or "n/a", imgui.xFont("!Agency FB@125"), 0, -height/2+400, Color(255, 255, 255), TEXT_ALIGN_CENTER)

 
                    draw.DrawText("Kontrolle:", imgui.xFont("!Agency FB@125"), 0, height/2-400, Color(255, 255, 255), TEXT_ALIGN_CENTER)

 

                    local color = Color(61,61,61)

                    if PlanetData["control"] == -1 then 
                        color = Color(255,0,0)
                    end 
                    if imgui.xTextButton("FEIND", "!Agency FB@150", -450-450/2-50, height/2-250, 450, 200, 1, color) then
                        net.Start("AOCRP.Terminal.PlanetAssocChange")
                            net.WriteInt(PlanetData["id"],13)
                            net.WriteInt(-1,3)
                        net.SendToServer()
                    end  
                    local color = Color(61,61,61)

                    if PlanetData["control"] == 0 then 
                        color = Color(255,255,0)
                    end 
                    if imgui.xTextButton("NEUTRAL", "!Agency FB@150", -450/2, height/2-250, 450, 200, 1, color) then
                        net.Start("AOCRP.Terminal.PlanetAssocChange")
                            net.WriteInt(PlanetData["id"],13)
                            net.WriteInt(0,3)
                        net.SendToServer()
                    end 
                    local color = Color(61,61,61)

                    if PlanetData["control"] == 1 then 
                        color = Color(0,255,0)
                    end 
                    if imgui.xTextButton("REPUBLIK", "!Agency FB@150", 450/2+50, height/2-250, 450, 200, 1, color) then
                        net.Start("AOCRP.Terminal.PlanetAssocChange")
                            net.WriteInt(PlanetData["id"],13)
                            net.WriteInt(1,3)
                        net.SendToServer()
                    end 

                    if imgui.xTextButton("Daten neuladen", "!Agency FB@40", width/2-225, height/2-75, 200, 50, 1, Color(255,255,255)) then
                        AOCRP.Terminal:LoadPlanetData()
                    end 
    
                end
            end

            imgui.xCursor(-width/2, -height/2, width, height)

        
            imgui.End3D2D()
        end
    end,

}



if CLIENT then 


    AOCRP.Terminal.PlanetData = AOCRP.Terminal.PlanetData or {}


    function AOCRP.Terminal:LoadPlanetData()
        AOCRP.Terminal.PlanetData = {}
        AOCRP.API:Request("getplanets", function(data) 

            AOCRP.Terminal.PlanetData = data

        end, {}, function(err) print(err) end)  
    end

end



if SERVER then 


    util.AddNetworkString("AOCRP.Terminal.PlanetAssocChange")


    net.Receive("AOCRP.Terminal.PlanetAssocChange", function(len,ply) 

        local planetid = net.ReadInt(13)
        local assoc = net.ReadInt(3)

        local updateObj = mysql:Update("planeten");
        updateObj:Update("control", assoc);
        updateObj:Where("id", planetid);
        updateObj:Callback(function(result, status, lastID)
        end);
        updateObj:Execute(); 

    end)





    util.AddNetworkString("AOCRP.Terminal.ATCGlobal")
    util.AddNetworkString("AOCRP.Terminal.SetCurrentMenu")
    util.AddNetworkString("AOCRP.Terminal.ATCEntNotify")

    util.AddNetworkString("AOCRP.Terminal.ATCResetAnfrage")
    util.AddNetworkString("AOCRP.Terminal.ATCEntStatus")
    util.AddNetworkString("AOCRP.Terminal.SetTarget")

    util.AddNetworkString("AOCRP.Terminal.FireAtTarget")


    net.Receive("AOCRP.Terminal.FireAtTarget", function(len,ply) 

        if ply:GetUnitID() != 9 then return end

        local entity = net.ReadEntity()
        for k, v in pairs(ents.FindByClass("aoc_rocketmarker")) do

            local ent = ents.Create( "lvs_protontorpedo" )
            ent:SetPos( v:GetPos() )
            ent:SetAngles( v:GetAngles())
            ent:Spawn()
            ent:Activate()
            ent:SetAttacker( ply )
            ent:SetTarget(entity)
            ent:Enable()

        end

    end)
    
    net.Receive("AOCRP.Terminal.SetTarget", function(len,ply) 
        if ply:GetUnitID() != 9 then return end

        local ent = net.ReadEntity()

        ent:SetNetVar("AOC_ATC_TARGET",  !ent:GetNetVar("AOC_ATC_TARGET", false))

        if !ent:GetNetVar("AOC_ATC_TARGET", false) then 
            ply:ConCommand("say /funk ATC OID-"..ent:EntIndex().. " - MARKIERT, ELIMINIEREN!")
        else 
            ply:ConCommand("say /funk ATC OID-"..ent:EntIndex().. " - MARKIERUNG AUFGEHOBEN, FEUER EINSTELLEN!")
        end
    end)

    net.Receive("AOCRP.Terminal.ATCEntStatus", function(len, ply)
        if ply:GetUnitID() != 9 then return end

        local ent = net.ReadEntity()
        local status = net.ReadInt(5)

        ent:SetNetVar("AOCRP_ATC_Status", status)

    end)

    net.Receive("AOCRP.Terminal.ATCResetAnfrage", function(len, ply)
        if ply:GetUnitID() != 9 then return end

        local ent = net.ReadEntity()

        ent:SetNetVar("AOCRP_ATC_LastAnfrage", ent:GetNetVar("AOCRP_ATC_Anfrage", ""))
        ent:SetNetVar("AOCRP_ATC_Anfrage", "")

    end)


    net.Receive("AOCRP.Terminal.SetCurrentMenu", function(len, ply)
        local menustr = net.ReadString()
        local ent = net.ReadEntity()

        ent:SetCurrentMenu(menustr)

    end)

    net.Receive("AOCRP.Terminal.ATCGlobal", function(len, ply)
        if ply:GetUnitID() != 9 then return end

        local alert = net.ReadInt(5)


        local alerts = {}
        alerts[1] = {
            title = "ACHTUNG",
            text = "Alarmrotte auf Bereitschaftsposition!",
            soundurl = "https://github.com/ltsammy/randomfiles/raw/master/ATC/rottebereit.wav",
            delay = 20
        }
        alerts[2] = {
            title = "ACHTUNG",
            text = "Einsatz für die Alarmrotte! Zielbennenung folgt.",
            soundurl = "https://github.com/ltsammy/randomfiles/raw/master/ATC/rotteinsatz.wav",
            delay = 20
        }
        alerts[3] = {
            title = "ACHTUNG",
            text = "Alle Kampfjäger zur Luftraumverteidigung sofort starten!",
            soundurl = "https://github.com/ltsammy/randomfiles/raw/master/ATC/allejaeger.wav",
            delay = 30
        }
        if !alerts[alert] then return end 


        AOCRP.HUD:Notification(player.GetHumans(), {title=alerts[alert].title, text=alerts[alert].text, titlecolor=Color(255, 0, 0), soundurl = alerts[alert].soundurl, delay = alerts[alert].delay})

    end)   

    net.Receive("AOCRP.Terminal.ATCEntNotify", function(len, ply)
        if ply:GetUnitID() != 9 then return end

        local ent = net.ReadEntity()
        local alert = net.ReadInt(5)


        local alerts = {}
        alerts[1] = {
            title = "ACHTUNG",
            text = "Melden sie sich umgehend im ATC-Kanal!",
            soundurl = "https://github.com/ltsammy/randomfiles/raw/master/ATC/lilli.wav",
            delay = 30
        }
        alerts[2] = {
            title = "ACHTUNG",
            text = "Melden Sie sich im ATC! Wir nutzen Waffengewalt.",
            soundurl = "https://github.com/ltsammy/randomfiles/raw/master/ATC/garlos.wav",
            delay = 30
        }
        if !alerts[alert] then return end 
 
        if IsValid(ent:GetDriver()) then
            AOCRP.HUD:Notification(ent:GetDriver(), {title=alerts[alert].title, text=alerts[alert].text, titlecolor=Color(255, 0, 0), soundurl = alerts[alert].soundurl, delay = alerts[alert].delay})
        end
    end)  
end 


AOCRP.Terminal["atc"] = {

    model = "models/reizer_props/alysseum_project/console/holo_screen_01/holo_screen_01.mdl",
 

    atcCategorys = {
        ["Freund"] = {
            color = Color(0,255,0),
            show = true,
            icon = "F",
            text = "Freund",
        },
        ["Feind"] = {
            color = Color(255,0,0),
            show = true,
            icon = "T",
            text = "Feind",
        },
        ["Unbekannt"] = {
            color = Color(255,255,0),
            show = true,
            icon = "U",
            text = "Unbekannt",
        },
        ["Fahrzeug"] = {
            color = Color(0,0,0),
            show = false,
            icon = "#",
            text = "Fahrzeug",
        },
    },

    lvsToATC = function(lvsCat)

        if lvsCat == "AOCRP - KUS - Flugobjekte" then 
            return AOCRP.Terminal["atc"].atcCategorys["Feind"]
        end 

        if lvsCat == "[LVS] - Republik" then 
            return AOCRP.Terminal["atc"].atcCategorys["Freund"]
        end 

        return AOCRP.Terminal["atc"].atcCategorys["Unbekannt"]
    end,

    lvsPercent = function(lvs)

            -- Ensure the player is valid
            if IsValid(lvs) then
                -- Get player's health and maximum health
                local health = lvs:GetHP()
                local maxHealth = lvs.MaxHealth
                
                -- Calculate health percentage
                local healthPercentage = (health / maxHealth) * 100
                
                -- Clamp the percentage between 0 and 100
                healthPercentage = math.Clamp(healthPercentage, 0, 100)
                
                return healthPercentage
            else
                return 0 -- Return 0 if player is invalid
            end
    
    end,

    drawTranslucent = function(self)
        
        local imgui = AOCRP.IMGUI
        if imgui.Entity3D2D(self, Vector(0, 0, 86), Angle(0, 90, 90),0.05, 500, 200) then

            local screenX = 1320
            local screenH = 1030
            -- render things
            surface.SetDrawColor(0, 52, 82)
            surface.DrawRect(-screenX, 0, screenX*2, screenH)

--[[             AOCRP.Config.Defcon
            GetGlobalNetVar("AOCRP.DEFCON",0) ]]

            

--[[             local defcon = GetGlobalNetVar("AOCRP.DEFCON",0)
 

            if defcon == 0 then 
                defcon = 5 
            else
                defcon = defcon - 1
            end 

            if AOCRP.Config.Defcon[defcon] then
                if imgui.xTextButton("DEFCON "..defcon, "!Agency FB@50", -100, screenH - 130, 200, 80, 1, AOCRP.Config.Defcon[defcon].color) then
                    LocalPlayer():ConCommand("say /defcon "..defcon)
                end     
            end ]]

            if self:GetCurrentMenu() != "" then 
                if IsValid(Entity(tonumber(self:GetCurrentMenu()))) then
                    local targetEnt = Entity(tonumber(self:GetCurrentMenu()))

                    if IsValid(targetEnt) and targetEnt.GetDriver and targetEnt.LVS then 

                        local category = AOCRP.Terminal["atc"].lvsToATC(targetEnt.Category)


                        local textW, textH = AOCDerma:GetTextSize(targetEnt:EntIndex().. " - "..targetEnt.PrintName, imgui.xFont("!Agency FB@70"))
                
                        draw.SimpleText(category.icon, imgui.xFont("!Aurebesh@70"), -screenX+200, 45, category.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)

                        surface.SetDrawColor(Color(200,200,200))
                        surface.DrawOutlinedRect( -screenX + 170, 50, textW + 170, 80, 1 )

                        draw.SimpleText(targetEnt:EntIndex().. " - "..targetEnt.PrintName, imgui.xFont("!Agency FB@70"), -screenX + 300 , 55, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)



                        local DriverName = "n/a"

                        

                        if IsValid(targetEnt:GetDriver()) then
                            if category.text == "Freund" then
                                DriverName = targetEnt:GetDriver():Nick()
                            else 
                                DriverName = "Verschlüsselt"
                            end
                        else 
                            if targetEnt:GetAI() then 
                                DriverName = "Droide"
                            end
                        end

                        local Vel = targetEnt:GetVelocity():Length()
                        local kmh = math.Round(Vel * 0.09144,0)
                        
                        local pSeats = targetEnt:GetPassengerSeats()
                        local pCount = 0
                        for k, v in pairs(pSeats) do
                            if v:GetDriver() != NULL then
                                pCount = pCount + 1
                            end 
                        end

                        local secondText = ""..kmh.." km/h | P: "..DriverName.. " | B: "..pCount

            

                        local text2W, text2H = AOCDerma:GetTextSize(secondText, imgui.xFont("!Agency FB@70"))
                
                        surface.SetDrawColor(Color(200,200,200))
                        surface.DrawOutlinedRect( -screenX + 170 + textW + 170 + 20, 50, text2W + 40, 80, 1 )
                        draw.SimpleText(secondText, imgui.xFont("!Agency FB@70"), -screenX + 170 + textW + 170 + 20 + 20, 55, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    

                        draw.SimpleText("Objektoptionen", imgui.xFont("!Agency FB@70"), -screenX + 600/2, 160, Color(255,255,255,255), TEXT_ALIGN_CENTER)
    

                        if targetEnt:GetNetVar("AOC_ATC_TARGET", false) then 
                            if imgui.xTextButton("ABSCHUSSMAKIERUNG AUFHEBEN", "!Agency FB@50", -screenX+50, 250, 500, 80, 1, Color(0,255,0)) then
                                net.Start("AOCRP.Terminal.SetTarget")
                                    net.WriteEntity(targetEnt)
                                net.SendToServer()
                            end   
                        else 
                            if imgui.xTextButton("ZUM ABSCHUSS FREIGEBEN", "!Agency FB@50", -screenX+50, 250, 500, 80, 1, Color(255,0,0)) then
                                net.Start("AOCRP.Terminal.SetTarget")
                                    net.WriteEntity(targetEnt)
                                net.SendToServer()
                            end 
                        end
                        if imgui.xTextButton("MIT ABWEHRKANONE FEUERN", "!Agency FB@50", -screenX+50, 350, 500, 80, 1, Color(255,0,0)) then
                          net.Start("AOCRP.Terminal.FireAtTarget")
                                net.WriteEntity(targetEnt)
                            net.SendToServer() 
                        end   


                        local statusStart = -screenX+50
                        local statusW = 213
                        for i=0, 10 do

                            local statusclr = color_white
                            if targetEnt:GetNetVar("AOCRP_ATC_Status", 0) == i then 
                                statusclr = Color(0,255,0)
                            end
                            if imgui.xTextButton(i, "!Aurebesh@40", statusStart, screenH-280, statusW, 80, 1, statusclr) then
                                net.Start("AOCRP.Terminal.ATCEntStatus")
                                net.WriteEntity(targetEnt)
                                net.WriteInt(i,5)
                                net.SendToServer()
                            end 
                            statusStart = statusStart + statusW + 20
                        end

                        if IsValid(targetEnt:GetDriver()) then

                            if targetEnt:GetNetVar("AOCRP_ATC_Anfrage","") != "" then
                                draw.SimpleText("AKTUELLE ANFRAGE", imgui.xFont("!Agency FB@70"), 0, 160, Color(255,255,255,255), TEXT_ALIGN_CENTER)
        
                                draw.SimpleText(targetEnt:GetNetVar("AOCRP_ATC_Anfrage",""), imgui.xFont("!Agency FB@70"), 0, 250, Color(199,199,199), TEXT_ALIGN_CENTER)
            
            
                                if imgui.xTextButton("ANFRAGE GENEHMIGEN", "!Agency FB@50", -550, 550, 500, 80, 1, Color(0,255,0)) then
                                    LocalPlayer():ConCommand("say /funk "..targetEnt:GetDriver():GetCloneID().. " Anfrage von OID-"..targetEnt:EntIndex().." # "..targetEnt:GetNetVar("AOCRP_ATC_Anfrage","").. " # GENEHMIGT!")
                                    net.Start("AOCRP.Terminal.ATCResetAnfrage")
                                    net.WriteEntity(targetEnt)
                                    net.SendToServer()

                                end   
            
                                if imgui.xTextButton("ANFRAGE VERWEIGERN", "!Agency FB@50", 50, 550, 500, 80, 1, Color(255,0,0)) then
                                    LocalPlayer():ConCommand("say /funk "..targetEnt:GetDriver():GetCloneID().. " Anfrage von OID-"..targetEnt:EntIndex().." # "..targetEnt:GetNetVar("AOCRP_ATC_Anfrage","").. " # ABGELEHNT!")
                                    net.Start("AOCRP.Terminal.ATCResetAnfrage")
                                    net.WriteEntity(targetEnt)
                                    net.SendToServer()
                                end   
                            else 
                                if targetEnt:GetNetVar("AOCRP_ATC_LastAnfrage","") != "" then
                                    draw.SimpleText("LETZTE GENEHMIGTE ANFRAGE", imgui.xFont("!Agency FB@70"), 0, 160, Color(255,255,255,255), TEXT_ALIGN_CENTER)
        
                                    draw.SimpleText(targetEnt:GetNetVar("AOCRP_ATC_LastAnfrage",""), imgui.xFont("!Agency FB@70"), 0, 250, Color(199,199,199), TEXT_ALIGN_CENTER)
                
                                end
                            end

                            

                            draw.SimpleText("Pilotenoptionen", imgui.xFont("!Agency FB@70"), screenX-600/2, 160, Color(255,255,255,255), TEXT_ALIGN_CENTER)
    
                            if imgui.xTextButton("FUNK: ATC MELDEN", "!Agency FB@50", screenX-550, 250, 500, 80, 1, Color(255,255,0)) then
                                net.Start("AOCRP.Terminal.ATCEntNotify")
                                    net.WriteEntity(targetEnt)
                                    net.WriteInt(1,5)
                                net.SendToServer()

                                LocalPlayer():ConCommand("say /funk "..targetEnt:GetDriver():GetCloneID().. " MELDEN SIE SICH UMGEHEND IM ATC-KANAL!")

                            end 
                            
                            if imgui.xTextButton("FUNK: W-WARNUNG", "!Agency FB@50", screenX-550, 350, 500, 80, 1, Color(255,0,0)) then
                            net.Start("AOCRP.Terminal.ATCEntNotify")
                                    net.WriteEntity(targetEnt)
                                    net.WriteInt(2,5)
                                net.SendToServer() 

                                LocalPlayer():ConCommand("say /funk "..targetEnt:GetDriver():GetCloneID().. " Wir fordern sie auf umgehend den ATC-Kanal zu schalten und sich bei uns zu Identifizieren!")

                            
                            end   
                        end
                    else 

                        draw.SimpleText("Objekt: "..self:GetCurrentMenu(), imgui.xFont("!Agency FB@120"), 0, 30, Color(255,255,255,100), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                        draw.SimpleText("UNGÜLTIGES ATC-OBJEKT", imgui.xFont("!Agency FB@120"), 0, 300, Color(255,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

        
                    end

                else 
                    draw.SimpleText("Objekt: "..self:GetCurrentMenu(), imgui.xFont("!Agency FB@120"), 0, 30, Color(255,255,255,100), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                    draw.SimpleText("UNGÜLTIGES ZIEL", imgui.xFont("!Agency FB@120"), 0, 300, Color(255,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

                end

                
                if imgui.xTextButton("<<", "!Agency FB@50", -screenX+50, 50, 100, 80, 1, Color(255,255,255)) then
                    net.Start("AOCRP.Terminal.SetCurrentMenu")
                        net.WriteString("")
                        net.WriteEntity(self)
                    net.SendToServer()
                    
                end  
            else 

            

             

                local startY = 50
                local count = 0
                local startX = -screenX + 50
                local maxPerRow = 7
                for k, v in ipairs(ents.GetAll()) do
                    if !v.LVS then continue end
                    if !table.HasValue(AOCRP.Config.LVSATCAllowed, v:GetClass()) then continue end

                    if count >= maxPerRow*7 then continue end
                    count = count + 1

                    local category = AOCRP.Terminal["atc"].lvsToATC(v.Category)

    

                    if imgui.xButton(startX, startY, 630, 100, 1, Color(136,136,136)) then
                        net.Start("AOCRP.Terminal.SetCurrentMenu")
                            net.WriteString(v:EntIndex())
                            net.WriteEntity(self)
                        net.SendToServer()
                    end

                    local btnColor = Color(182,182,182)

                    if v:GetNetVar("AOCRP_ATC_Anfrage","") != "" and IsValid(v:GetDriver()) then
                        btnColor = Color(255,145,0)
                    end


                    draw.SimpleText(v:EntIndex(), imgui.xFont("!Aurebesh@70"), startX+630/2, startY+2, btnColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                    draw.SimpleText(category.icon, imgui.xFont("!Aurebesh@70"), startX+15, startY+2, category.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)


                    if IsValid(v:GetDriver()) or v:GetAI() then
                        draw.SimpleText(v:GetNetVar("AOCRP_ATC_Status", 0), imgui.xFont("!Aurebesh@70"), startX+610, startY+2, Color(0,255,0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
                    else 
                        draw.SimpleText(v:GetNetVar("AOCRP_ATC_Status", 0), imgui.xFont("!Aurebesh@70"), startX+610, startY+2, Color(255,0,0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
                    end

                    --startX = startX + 640
                    startY = startY + 110
                    
                    if count == maxPerRow or count == maxPerRow*2 or count == maxPerRow*3 or count == maxPerRow*4 or count == maxPerRow*5 or count == maxPerRow*6 then 
                        startY = 50
                        startX = startX + 640
                    end
                end
                --imgui.xButton(10, 50, screenX - 60, 100, 1, Color(255,255,255))

            --[[     draw.SimpleText(count, imgui.xFont("!Aurebesh@100"), screenX-50, screenH-170, Color(211,211,211), TEXT_ALIGN_RIGHT)
 ]]
            end


            surface.SetDrawColor(color_white)
            surface.DrawLine( -screenX + 50, screenH-180, screenX - 50, screenH-180 )


            local btnsStX = -screenX+50
            local btnDis = 320
            local btnwdith = 300
            if imgui.xTextButton("ALARMROTTE BEREIT", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(255,255,0)) then
                net.Start("AOCRP.Terminal.ATCGlobal")
                    net.WriteInt(1,5)
                net.SendToServer()
                
                LocalPlayer():ConCommand("say /funk ANK Alarmrotte der AVP auf Bereitschaftsposition!")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("ALARMROTTE ALARM", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(255,0,0)) then
                net.Start("AOCRP.Terminal.ATCGlobal")
                    net.WriteInt(2,5)
                net.SendToServer()

                LocalPlayer():ConCommand("say /funk ANK Einsatz für die Alarmrotte, Starterlaubnis für Jäger der Alarmrotte erteilt!")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("ALARMROTTE LANDEN", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(0,255,0)) then

                LocalPlayer():ConCommand("say /funk ATC Einsatz der Alarmrotte beendet. Landeerlaubnis bei Startpunkt genehmigt.")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("ALLE JÄGER BEREIT", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(255,255,0)) then
--[[                 net.Start("AOCRP.Terminal.ATCGlobal")
                    net.WriteInt(2,5)
                net.SendToServer() ]]

                LocalPlayer():ConCommand("say /funk ANK Alle Kampfpiloten sofort zu ihren Jägern und Bereithalten!")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("ALLE JÄGER STARTEN", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(255,0,0)) then
                net.Start("AOCRP.Terminal.ATCGlobal")
                    net.WriteInt(3,5)
                net.SendToServer()

                LocalPlayer():ConCommand("say /funk ANK Alle Kampfjäger zur Luftraumverteidigung sofort starten!")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("ALLE JÄGER LANDEN", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(0,255,0)) then
                
                LocalPlayer():ConCommand("say /funk ANK Alle unverzüglich Landen!")
            end  
            btnsStX = btnsStX + btnDis

            if imgui.xTextButton("HANGAR DURCHSAGE", "!Agency FB@50", btnsStX, screenH - 150, btnwdith, 80, 1, Color(255,255,255)) then
                LocalPlayer():ConCommand("say /funk ANK ACHTUNG, Massive Flugbewegungen in den Hangaren. Jäger haben Vorrang!")
            end  
            btnsStX = btnsStX + btnDis

--[[             if imgui.xTextButton("ALLE JÄGER STARTEN", "!Agency FB@50", screenX-450-430, screenH - 150, 400, 80, 1, Color(255,0,0)) then
                net.Start("AOCRP.Terminal.ATCGlobal")
                    net.WriteInt(3,5)
                net.SendToServer()

                LocalPlayer():ConCommand("say /funk ANK Alle Kampfjäger zur Luftraumverteidigung sofort starten!")
            end  

             if imgui.xTextButton("ALLE LANDEN", "!Agency FB@50", screenX-450, screenH - 150, 400, 80, 1, Color(0,255,0)) then
                
                LocalPlayer():ConCommand("say /funk ANK Alle unverzüglich Landen!")
            end   
 ]]
    

            imgui.xCursor(-screenX, 0, screenX*2, screenH)

            imgui.End3D2D()
        end
    end,

}
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_b1.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "B1 Kampfdroide"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/cis_npc/b1_battledroids/assault/b1_battledroid_assault.mdl"
ENT.Weapon = "weapon_npc_e5"
ENT.HP = 300
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = 0.3
ENT.Speed = 100

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = true
ENT.Grenades = {"summe_gr_grenade"}

ENT.Sounds = {
    ["killed"] = {
        "aoc/nextbot/b1/killed/scream1.wav",
        "aoc/nextbot/b1/killed/scream2.wav",
        "aoc/nextbot/b1/killed/scream3.wav",
        "aoc/nextbot/b1/killed/scream4.wav",
        "aoc/nextbot/b1/killed/scream5.wav"
    },

    ["attacking"] = {
        "aoc/nextbot/b1/attack/ausloeschen.wav",
        "aoc/nextbot/b1/attack/roger-roger.wav",
        "aoc/nextbot/b1/attack/scanne-das-ziel.wav",
        "aoc/nextbot/b1/attack/scanne-feindeinheit.wav",
        "aoc/nextbot/b1/attack/siegt.wav",
        "aoc/nextbot/b1/attack/ziel-erfasst.wav",
    },

    ["kill"] = {
        "aoc/nextbot/b1/kill/knapp.wav",
        "aoc/nextbot/b1/kill/nimm-das.wav",
        "aoc/nextbot/b1/kill/yeah.wav"
    }
}

ENT.Anims = {
    ["idle"] = {0},
    ["shoot"] = {"Smg1angryidle1"},
    ["reload"] = {"reload_smg1"},
    ["walk_slow"] = {"walk_all"},
    ["walk_fast"] = {"run_all"},
    ["melee"] = {"swing"},
}
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_b2.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "B2 Superkampfdroide"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/player/hydro/b2_battledroid/b2_battledroid.mdl"
ENT.Weapon = "weapon_npc_b2"
ENT.HP = 800
ENT.ShootingRange = 1500
ENT.LooseRadius = 4000
ENT.Proficiency = 0.2
ENT.Speed = 60

ENT.Scale = 1.15

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_impact"}

ENT.Sounds = {
    ["killed"] = {
        "aoc/nextbot/b2/killed/death1.wav",
        "aoc/nextbot/b2/killed/death2.wav"
    },

    ["attacking"] = {
        "aoc/nextbot/b2/attack/nimm-das.wav",
        "aoc/nextbot/b2/attack/problem-geloest.wav"
    },
}

ENT.Anims = {
    ["shoot"] = {"idle_pistol"},
    ["reload"] = {"reload_smg1_original"},
    ["walk_slow"] = {"menu_walk"},
    ["walk_fast"] = {"menu_walk"},
    ["melee"] = {"swing"},
}

function ENT:ShootEnemy()
    local weapon = self:GetWeapon()
    local enemy = self:GetEnemy()

    if not IsValid(weapon) then return end
    if AOCRPNextbots:CannotTarget(enemy) then self:SetEnemy(false) return end

    weapon.LastEnemy = enemy

    if weapon:Clip1() > 0 then
        if self.IsReloading then return end
        self:PlayAnimation("shoot")
        self:MakeSound(table.Random(self.Sounds["attacking"]), 80)

        if math.random(0, 100) > 98 then
            self:ShootMissle()
            return
        end

        weapon:PrimaryAttack()


    else
        if self.IsReloading then return end
        self.IsReloading = true
        self:MakeSound("weapons/bf3/standard_reload2.ogg", 0)
        self:PlayAnimation("reload")
        timer.Simple(3, function()
            if not IsValid(weapon) then return end
            weapon:SetClip1(self.NormalWeaponClip)
            self.IsReloading = false
        end)
    end
end

function ENT:ShootMissle()
    if IsValid(self.Missle) then return end
    local enemy = self:GetEnemy()
    if not enemy then return end

    self:EmitSound("weapons/rocket launcher/explosive_rocketlauncher_corebass_close_var_03.mp3", 100, 100, 1, CHAN_WEAPON)

    self.Missle = ents.Create("summe_b2missle")
    self.Missle:SetPos(self:EyePos())
    self.Missle:SetAngles(self:EyeAngles())
    self.Missle:SetOwner(self)
    self.Missle:Spawn()
end
--addons/arccw_base_modified/lua/entities/arccw_ammo_pistol.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Pistol Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/pistol_ammo.mdl"

ENT.AmmoType = "pistol"
ENT.AmmoCount = 40

ENT.DetonationDamage = 10
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/pistol/pistol_fire3.wav"
--addons/arccw_base_modified/lua/entities/arccw_att_base/shared.lua:
ENT.Type                  = "anim"
ENT.Base                  = "base_entity"
ENT.PrintName             = "Base Dropped Attachment"
ENT.Author                = ""
ENT.Information           = ""

ENT.Spawnable             = false

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.Category              = "ArcCW - Attachments"

AddCSLuaFile()

ENT.GiveAttachments = nil -- table of all the attachments to give, and in what quantity. {{["id"] = int quantity}}

ENT.SoundImpact = "weapon.ImpactSoft"
ENT.Model = ""

if SERVER then

function ENT:Initialize()
    if !self.Model then
        self:Remove()
        return
    end

    self:SetModel(self.Model)
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    self:SetTrigger( true )
    self:SetPos(self:GetPos() + Vector(0, 0, 4))
    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:SetBuoyancyRatio(0)
    end
end

function ENT:PhysicsCollide(colData, collider)
    if colData.DeltaTime < 0.25 then return end

    self:EmitSound(self.SoundImpact)
end

function ENT:Use(activator, caller)
    if !caller:IsPlayer() then return end

    if ArcCW.ConVars["attinv_free"]:GetBool() then return end

    local take = false

    for i, k in pairs(self.GiveAttachments) do
        if i == "BaseClass" then continue end

        if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
            if ArcCW:PlayerGetAtts(caller, i) > 0 then
                continue
            end
        end

        if hook.Run("ArcCW_PickupAttEnt", caller, i, k) then continue end

        ArcCW:PlayerGiveAtt(caller, i, k)

        take = true
    end

    if take then
        ArcCW:PlayerSendAttInv(caller)

        self:EmitSound("weapons/arccw/useatt.wav")
        self:Remove()
    end
end

else

local defaulticon = Material("arccw/hud/atts/default.png")
local iw = 64

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()

    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

    if self.PrintName == "Base Dropped Attachment" and self:GetNWInt("attid", -1) != -1 then
        local att = ArcCW.AttachmentIDTable[self:GetNWInt("attid", -1)]

        if !att then return end

        local atttbl = ArcCW.AttachmentTable[att]

        if !atttbl then return end

        self.PrintName = atttbl.PrintName or att
        self.Icon = atttbl.Icon or defaulticon
    end

    if (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()

        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)

        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 16), ang, 0.1)
            surface.SetFont("ArcCW_32_Unscaled")

            local w = surface.GetTextSize(self.PrintName)
            surface.SetTextPos(-w / 2 + 2, 2)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(self.PrintName)
            surface.SetTextPos(-w / 2, 0)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(self.PrintName)

            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(self.Icon or defaulticon)
            surface.DrawTexturedRect(-iw / 2, iw / 2, iw, iw)
        cam.End3D2D()
    end
end

end
--addons/arccw_weapons/lua/entities/arccw_rocket_gravity.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "arccw_new_projectile"
ENT.PrintName 			= "Gravity Rocket"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/w_missile_launch.mdl"
ENT.BoxSize = Vector(8, 4, 1)

ENT.FuseTime = 0.077
ENT.Boost = 1200
ENT.Lift = 80
ENT.DragCoefficient = 0.1
--addons/arccw_weapons/lua/entities/arccw_rocket_smoke/shared.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 Smoke Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    self:EmitSound("weapons/arccw/smokegrenade/smoke_emit.wav", 90, 100, 1, CHAN_AUTO)

    local cloud = ents.Create( "arccw_smoke" )

    if !IsValid(cloud) then return end

    cloud:SetPos(self:GetPos())
    cloud:Spawn()

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 300, 10)

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 175, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--addons/arccw_weapons/lua/entities/arccw_thr_frag.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Fragnade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/thermal_detonator.mdl"
ENT.FuseTime = 3.5
ENT.TrailColor = Color(255, 0, 0, 255)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("w/thermaldet.wav")

        -- Play the sound when the entity is spawned
        self:EmitSound("w/thermaldet.wav")
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/grenade_bounce_2ch_v2_0" .. math.random(1,3) .. ".wav"))
        end

    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("weapons/grenades/explode" .. math.random(1,3) .. ".wav", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 350)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(190 * f)
            --dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/cis_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "PLX-1 Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 12
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
			ParticleEffectAttach( "astw2_swbf_muzzle_cis_bulldog", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_rocket", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 115 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end
        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(255, 100, 195) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/arccw_weapons/lua/entities/ion_nade/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "Ion Nade"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--local rSound = Sound("Missile.Accelerate")

if SERVER then
	AddCSLuaFile( "shared.lua" )

	function ENT:Initialize()   
		self.flightvector = self.Entity:GetForward() * ((30*15.5)/2)
		self.timeleft = CurTime() + 2
		self.Owner = self:GetOwner()
		self.Entity:SetModel( "models/sw_battlefront/weapons/rocketprojectile.mdl" )
		self.Entity:PhysicsInit( SOLID_VPHYSICS )	
		self.Entity:SetMoveType( MOVETYPE_NONE )
		self.Entity:SetSolid( SOLID_VPHYSICS )
		--self.Entity:EmitSound(rSound, 75, 100)
		self.Entity:SetNWBool("smoke", 10, true)
	end   

	function ENT:Think()

			if self.timeleft < CurTime() then
				self:Explosion()
				self.Entity:Remove()
			end

		Table	={} 			//Table name is table name
		Table[1]	=self.Owner 		//The person holding the gat
		Table[2]	=self.Entity 		//The cap

		local trace = {}
			trace.start = self.Entity:GetPos()
			trace.endpos = self.Entity:GetPos() + self.flightvector
			trace.filter = Table
		local tr = util.TraceLine( trace )
		

			if tr.HitSky then
				self:Explosion()
				self.Entity:Remove()
				return true
			end

			local dmg = math.Rand( 250, 275 )
			util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 15, dmg)
		
			if tr.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin(tr.HitPos)
						effectdata:SetNormal(tr.HitNormal)
						--effectdata:SetEntity(self.Entity)
						effectdata:SetScale(3)
						effectdata:SetRadius(tr.MatType)
						effectdata:SetMagnitude(18)
						util.Effect( "ion_exp_effect", effectdata )
						--util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 500, dmg)
						util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
						self.Entity:SetNWBool("smoke", false)
				self:Explosion()
				self.Entity:Remove()	
			end
		
		self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
		self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
		self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
		self.Entity:NextThink( CurTime() )
		return true
	end
	
	function ENT:Explosion()
		self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_medium_bigion_discharge_close_var_01.mp3", 500, 100)	
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 130 ) ) do
			if IsValid( v ) then
				if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v:IsPlayer() or v:IsNPC() then
					damage = DamageInfo()
					damage:SetDamage( 5000000 )
					damage:SetAttacker( self:GetOwner() )
					damage:SetDamageType( DMG_DISSOLVE )
					v:TakeDamageInfo( damage )
				end
			end 
	end
end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then

    function ENT:Draw()
     pos = self:GetPos()
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 30, 30, Color(255, 255, 0))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 15, 15, Color(255, 255, 0))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 5, 5, Color(255, 255, 0))
    end
 
    function ENT:Initialize()
        pos = self:GetPos()
        self.emitter = ParticleEmitter( pos )
    end
 
    function ENT:Think()
    end

end
--addons/joes_stuff/lua/entities/joe_bomb/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName= "Defusable Bomb"
ENT.Author= "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Joe"

--addons/joes_stuff/lua/entities/joe_cable/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName= "cable"
ENT.Author= "Joe"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Joe"

function ENT:SetupDataTables()
    self:NetworkVar( "String", 0, "UnPresetColor" )

end
--addons/weapon_joe_fort/lua/entities/joefort_buildent/cl_init.lua:
include('shared.lua')

local mat = Material("ace/sw/hologram")

function ENT:Draw()
	if not self.buildtime then return end
	self.height = self.height or 0
	self.StartTime = self.StartTime or CurTime()
	self.scannerheight = self.scannerheight or 0

	self.height = ( self:OBBMaxs().z / self.buildtime ) * ( CurTime() - self.StartTime ) - 1.5
	self.scannerheight = ( self:OBBMaxs().z / self.buildtime ) * ( CurTime() - self.StartTime )

	local normal = -self:GetUp() 
    local pos = self:LocalToWorld(Vector(0, 0, self.scannerheight))
	local distance = normal:Dot(pos)
	
	render.MaterialOverride(mat)

	render.EnableClipping(true)
	render.PushCustomClipPlane(normal, distance)
	self:DrawModel()
	render.PopCustomClipPlane()


	render.MaterialOverride()

    local pos = self:LocalToWorld(Vector(0, 0, self.height))
	local distance = normal:Dot(pos)
	
	render.EnableClipping(true)
	render.PushCustomClipPlane(normal, distance)
	self:DrawModel()
	render.PopCustomClipPlane()
end

function ENT:Think()
	local mins = self:OBBMins()
	local maxs = self:OBBMaxs()
	for i = 1,3 do
		local pos = Vector(0,0,0)
		pos.x = mins.x + math.random(0, maxs.x - mins.x )
		pos.y = mins.y + math.random(0, maxs.y - mins.y )
		pos.z = mins.z + math.random(0, self.height or 0 )
		pos = self:LocalToWorld(pos)
		local effectData = EffectData()
		effectData:SetOrigin(pos)
		effectData:SetMagnitude(2)
		effectData:SetScale(1)
		effectData:SetRadius(1)
		util.Effect("Sparks", effectData)
	end

	self:SetNextClientThink(CurTime() + 1)
	return true
end
--addons/weapon_joe_fort/lua/entities/joefort_buildent/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName= "JoeFort_Buildent"
ENT.Author= "Joe"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "JoeFort"

--addons/lvs_addons/lua/entities/loader_new/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Loader"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable = true

ENT.MDL = "models/loader/ships/loader.mdl"

ENT.AITEAM = 2


ENT.MaxHealth = 1000

ENT.MaxVelocityX = 400
ENT.BoostAddVelocitX = 500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 2

ENT.ForceLinearMultiplier = 2
ENT.ForceLinearRate = 2

ENT.MaxVelocityY = 150
ENT.BoostAddVelocitY = 150



ENT.IgnoreWater = false

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "LightsOn" )
end

function ENT:CalcMainActivityPassenger( ply )
end

function ENT:CalcMainActivity( ply )
    if ply ~= self:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

    if ply.m_bWasNoclipping then 
        ply.m_bWasNoclipping = nil 
        ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
        
        if CLIENT then 
            ply:SetIK( true )
        end 
    end 

    ply.CalcIdeal = ACT_STAND
    ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

    return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:InitWeapons()

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.lighton == true then
			self:SetLightsOn(false)
			self.lighton = false
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self.lighton = true
			self:SetLightsOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.loaded then
			self.loaded = false
			print("removed")
			constraint.RemoveConstraints( self, "Weld" )
		else
			self.posibleentities = ents.FindInBox( self:LocalToWorld(Vector(136,65,32)), self:LocalToWorld(Vector(-134,-66,105)) ) 
			for _, entity in ipairs(self.posibleentities) do
				if entity:GetClass() == "player" then
				elseif entity:GetClass() == "prop_physics" or "anim" then
					self.loaded = true
					constraint.Weld(self, entity, 0, 0, 0, true, false)
				end
			end
		end
	end
	self:AddWeapon( weapon )

    local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0.5
	weapon.HeatRateUp = 5
	weapon.HeatRateDown = 5
	weapon.Attack = function( ent )

		if self.FiredRope then
			if self.HookedEnt != nil && IsValid(self.HookedEnt) then
				self:UnRagdoll(self.HookedEnt)
				self.HookedEnt = nil
			end

			constraint.RemoveConstraints( self, "Rope" )
			self.FiredRope = false
			
			return
		end

		local trace = self:GetEyeTrace()


		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(440.93,-256.45,105.48) )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_nil"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 0
		bullet.SplashDamage = 0
		bullet.SplashDamageRadius = 0
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			if !tr.Hit or (self:LocalToWorld(Vector(136,0,16)) - tr.HitPos):Length() > 1000 then return false end

			if tr.Entity:IsPlayer() then
				self.HookedEnt = tr.Entity
				self:Ragdoll(tr.Entity)
				tr.Entity = tr.Entity.tw_Ragdoll
            end

            self.CurRope = constraint.Rope(self, tr.Entity, 0, 0, Vector(136,0,16), tr.Entity:WorldToLocal(tr.HitPos), (self:LocalToWorld(Vector(136,0,16)) - tr.HitPos):Length() + 100, 0, 0, 5, 'cable/cable2', false)
			
            if IsValid(self.CurRope) then
                self.FiredRope = true
                if tr.Entity == lvs then 
                    self:StartEngine(true)
                end
            end
            
		end
        local effectdata = EffectData()
        effectdata:SetStart( Vector(0,0,0) )
        effectdata:SetOrigin( bullet.Src )
        effectdata:SetNormal( ent:GetForward() )
        effectdata:SetEntity( ent )
        util.Effect( "lvs_muzzle_colorable", effectdata )

        ent:LVSFireBullet( bullet )

		ent:TakeAmmo()
	end
    weapon.HudPaint = function( ent, X, Y, ply )
        local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

        local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

        local base = ent:GetVehicle()
        base:PaintCrosshairCenter( Pos2D, Col )
        base:PaintCrosshairOuter( Pos2D, Col )
        base:LVSPaintHitMarker( Pos2D )
    end
    self:AddWeapon( weapon )
end


function ENT:MakeInvisible(player, invisible)
	player:SetNoDraw(invisible)
	player:SetNotSolid(invisible)

	player:DrawViewModel(!invisible)
	player:DrawWorldModel(!invisible)

	if (invisible) then
		player:GodEnable()
	else
		player:GodDisable()
	end
end

function ENT:UnRagdoll(target)
    if IsValid(target) then 
	    self:MakeInvisible(target, false)

	    local position = target.tw_Ragdoll:GetPos()

	    target:UnSpectate()
        target.tw_Ragdoll:Remove()

        target:SetParent(NULL)
        target:Spawn()
        timer.Simple(0.1, function()
            target:SetPos(position +Vector(0, 0, 5))
        end)

        for k, weapon in pairs(target.tw_Weapons) do
            target:Give(weapon)
        end

        target.tw_Weapons = nil
    else
        self.CurRag:Remove()
        self.CurRag = nil
    end
end

function ENT:Ragdoll(target)

	target.tw_Weapons = {}

	for k, weapon in pairs(target:GetWeapons()) do
		if IsValid(weapon) then
			table.insert(target.tw_Weapons, weapon:GetClass())
		end
	end

	target.tw_Ragdoll = ents.Create("prop_ragdoll")
	target.tw_Ragdoll:SetPos(target:GetPos())
	target.tw_Ragdoll:SetModel(target:GetModel())
	target.tw_Ragdoll:SetAngles(target:GetAngles())
	target.tw_Ragdoll:SetSkin(target:GetSkin())
	target.tw_Ragdoll:SetMaterial(target:GetMaterial())
	target.tw_Ragdoll:Spawn()

    self.CurRag = target.tw_Ragdoll


	target.tw_Ragdoll:CallOnRemove("UnragdollPlayer", function(ragdoll)
		if IsValid(target) then
			self:MakeInvisible(target, false)

			local position = ragdoll:GetPos()

			target:SetParent(NULL)
			target:Spawn()
			timer.Simple(0.1, function()
				target:SetPos(position + Vector(0, 0, 5))
			end)

			if (target.tw_Weapons) then
				for k, weapon in pairs(target.tw_Weapons) do
					target:Give(weapon)
				end
			end

			target.tw_Weapons = nil
		end
	end)

	target.tw_Ragdoll:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	local velocity = target:GetVelocity()
	local physObjects = target.tw_Ragdoll:GetPhysicsObjectCount() - 1

	for i = 0, physObjects do
		local bone = target.tw_Ragdoll:GetPhysicsObjectNum(i)

		if IsValid(bone) then
			local position, angle = target:GetBonePosition(target.tw_Ragdoll:TranslatePhysBoneToBone(i))

			if (position and angle) then
				bone:SetPos(position)
				bone:SetAngles(angle)
			end

			bone:AddVelocity(velocity)
		end
	end

	target:StripWeapons()
	target:SetMoveType(MOVETYPE_OBSERVER)
	target:Spectate(OBS_MODE_CHASE)
	target:SpectateEntity(target.tw_Ragdoll)
	target:SetParent(target.tw_Ragdoll)

	self:MakeInvisible(target, true)
end
--addons/lvs_base/lua/entities/lvs_base/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseEntity"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.Editable = true

ENT.LVS = true

ENT.MDL = "models/props_c17/trappropeller_engine.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 100
ENT.MaxShield = 0

ENT.SpawnNormalOffset = 15
ENT.HitGroundLength = 10

ENT.lvsDisableZoom = true

function ENT:AddDT( type, name, data )
	if not self.DTlist then self.DTlist = {} end

	if self.DTlist[ type ] then
		self.DTlist[ type ] = self.DTlist[ type ] + 1
	else
		self.DTlist[ type ] = 0
	end

	self:NetworkVar( type, self.DTlist[ type ], name, data )
end

function ENT:CreateBaseDT()
	local InitWeaponsSuccess, ErrorMsg = pcall( function() self:InitWeapons() end )

	if not InitWeaponsSuccess then
		ErrorNoHalt( "\n[ERROR] "..ErrorMsg.."\n\n" )
	end

	self:AddDT( "Entity", "Driver" )
	self:AddDT( "Entity", "DriverSeat" )

	self:AddDT( "Bool", "Active" )
	self:AddDT( "Bool", "EngineActive" )
	self:AddDT( "Bool", "AI",	{ KeyName = "aicontrolled",	Edit = { type = "Boolean",	order = 1,	category = "AI"} } )

	local ShowAIGunnerInMenu = false

	if istable( self.WEAPONS ) then
		for id, _ in pairs( self.WEAPONS ) do
			if id == 1 then continue end

			ShowAIGunnerInMenu = true

			break
		end
	end

	if ShowAIGunnerInMenu then
		self:AddDT( "Bool", "AIGunners",	{ KeyName = "aigunners",	Edit = { type = "Boolean",	order = 2,	category = "AI"} } )
	else
		self:AddDT( "Bool", "AIGunners" )
	end

	self:AddDT( "Bool", "lvsLockedStatus" )
	self:AddDT( "Bool", "lvsReady" )
	self:AddDT( "Bool", "NWOverheated" )

	self:AddDT( "Int", "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 3, category = "AI"} } )
	self:AddDT( "Int", "SelectedWeapon" )
	self:AddDT( "Int", "NWAmmo" )

	self:AddDT( "Float", "HP", { KeyName = "health", Edit = { type = "Float", order = 2,min = 0, max = self.MaxHealth, category = "Misc"} } )
	self:AddDT( "Float", "Shield" )
	self:AddDT( "Float", "NWHeat" )

	if SERVER then
		self:NetworkVarNotify( "AI", self.OnToggleAI )
		self:NetworkVarNotify( "HP", self.PDSHealthValueChanged )
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )

		self:SetAITEAM( self.AITEAM )
		self:SetHP( self.MaxHealth )
		self:SetShield( self.MaxShield )
		self:SetSelectedWeapon( 1 )
	end

	self:OnSetupDataTables()
end

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:OnSetupDataTables()
end

function ENT:CalcMainActivity( ply )
end

function ENT:GetPlayerBoneManipulation( ply, PodID )
	return self.PlayerBoneManipulate[ PodID ] or {}
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end

function ENT:StartCommand( ply, cmd )
end

function ENT:HitGround()
	local trace = util.TraceLine( {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.HitGroundLength) ),
		filter = self:GetCrosshairFilterEnts()
	} )
	
	return trace.Hit 
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetMaxShield()
	return self.MaxShield
end

function ENT:GetShieldPercent()
	return self:GetShield() / self:GetMaxShield()
end

function ENT:GetMaxHP()
	return self.MaxHealth
end

function ENT:IsInitialized()
	if not self.GetlvsReady then return false end -- in case this is called BEFORE setupdatatables

	return self:GetlvsReady()
end

function ENT:GetWeaponHandler( num )
	if num == 1 then return self end

	local pod = self:GetPassengerSeat( num )

	if not IsValid( pod ) then return NULL end

	return pod:lvsGetWeapon()
end

function ENT:GetPassengerSeat( num )
	if num == 1 then
		return self:GetDriverSeat()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then continue end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod
			end
		end

		return NULL
	end
end

function ENT:GetPassengerSeats()
	if not self:IsInitialized() then return {} end

	if not istable( self.pSeats ) then
		self.pSeats = {}

		local DriverSeat = self:GetDriverSeat()

		for _, v in pairs( self:GetChildren() ) do
			if v ~= DriverSeat and v:GetClass():lower() == "prop_vehicle_prisoner_pod" then
				table.insert( self.pSeats, v )
			end
		end
	end

	return self.pSeats
end

function ENT:HasActiveSoundEmitters()
	local active = false

	for _, emitter in ipairs( self:GetChildren() ) do
		if emitter:GetClass() ~= "lvs_soundemitter" then continue end

		if not IsValid( emitter ) or not emitter.GetActive or not emitter.GetActiveVisible then continue end

		if emitter:GetActive() and emitter:GetActiveVisible() then
			active = true

			break
		end
	end

	return active
end

function ENT:GetPassenger( num )
	if num == 1 then
		return self:GetDriver()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then
				return NULL
			end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod:GetDriver()
			end
		end

		return NULL
	end
end

function ENT:GetEveryone()
	local plys = {}

	local Pilot = self:GetDriver()
	if IsValid( Pilot ) then
		table.insert( plys, Pilot )
	end

	for _, Pod in pairs( self:GetPassengerSeats() ) do
		if not IsValid( Pod ) then continue end

		local ply = Pod:GetDriver()

		if not IsValid( ply ) then continue end

		table.insert( plys, ply )
	end

	return plys
end

function ENT:GetPodIndex()
	return 1
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

function ENT:GetVehicle()
	return self
end

function ENT:GetVehicleType()
	return "LBaseEntity"
end

function ENT:GetBoneInfo( BoneName )
	local BoneID = self:LookupBone( BoneName )
	local numHitBoxSets = self:GetHitboxSetCount()

	if not BoneID then
		goto SkipLoop
	end

	for hboxset = 0, numHitBoxSets - 1 do
		local numHitBoxes = self:GetHitBoxCount( hboxset )

		for hitbox=0, numHitBoxes - 1 do
			local bone = self:GetHitBoxBone( hitbox, hboxset )
			local name = self:GetBoneName( bone )

			if BoneName ~= name then continue end

			local mins, maxs = self:GetHitBoxBounds( hitbox, hboxset )
			local pos, ang = self:GetBonePosition( BoneID )

			return self:WorldToLocal( pos ), self:WorldToLocalAngles( ang ), mins, maxs
		end
	end

	:: SkipLoop ::

	return vector_origin, angle_zero, vector_origin, vector_origin
end
--addons/lvs_addons/lua/entities/lvs_base_starfighter/cl_flyby.lua:

ENT.FlyByAdvance = 0

function ENT:FlyByThink()
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local EntTable = self:GetTable()

	if ply:lvsGetVehicle() == self then self.OldApproaching = false return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Time = CurTime()

	if (EntTable._nextflyby or 0) > Time then return end

	EntTable._nextflyby = Time + 0.1

	local Vel = self:GetVelocity()

	if self:GetThrottle() <= 0.75 or Vel:Length() <= EntTable.MaxVelocity * 0.75 then return end

	local Sub = ViewEnt:GetPos() - self:GetPos() - Vel * EntTable.FlyByAdvance
	local ToPlayer = Sub:GetNormalized()
	local VelDir = Vel:GetNormalized()

	local ApproachAngle = math.deg( math.acos( math.Clamp( ToPlayer:Dot( VelDir ) ,-1,1) ) )

	local Approaching = ApproachAngle < 80

	if Approaching ~= EntTable.OldApproaching then
		EntTable.OldApproaching = Approaching

		if Approaching then
			self:StopFlyBy()
		else
			self:OnFlyBy( 60 + 80 * math.min(ApproachAngle / 140,1) )
		end
	end
end

function ENT:OnFlyBy( Pitch )
	if not self.FlyBySound then return end

	local EntTable = self:GetTable()

	EntTable.flybysnd = CreateSound( self, EntTable.FlyBySound )
	EntTable.flybysnd:SetSoundLevel( 95 )
	EntTable.flybysnd:PlayEx( 1, Pitch )
end

function ENT:StopFlyBy()
	local EntTable = self:GetTable()

	if not EntTable.flybysnd then return end

	EntTable.flybysnd:Stop()
	EntTable.flybysnd = nil
end
--addons/lvs_base/lua/entities/lvs_bomb.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.ExplosionEffect = "lvs_explosion_bomb"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Bool", 1, "MaskSolid" )

	self:NetworkVar( "Vector", 0, "Speed" )
end

if SERVER then
	util.AddNetworkString( "lvs_bomb_hud" )

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:GetEntityFilter()
		return self._FilterEnts or {}
	end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent )
		self._attacker = ent

		if not IsValid( ent ) or not ent:IsPlayer() then return end

		net.Start( "lvs_bomb_hud", true )
			net.WriteEntity( self )
		net.Send( ent )
	end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 2000) end
	function ENT:GetForce() return (self._force or 8000) end
	function ENT:GetRadius() return (self._radius or 400) end

	function ENT:Initialize()
		self:SetModel( "models/props_phx/ww2bomb.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self:PhysWake()

		timer.Simple(1, function()
			if not IsValid( self ) then return end

			self:SetCollisionGroup( COLLISION_GROUP_NONE )
		end )

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 500 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )
		pObj:SetVelocityInstantaneous( self:GetSpeed() )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local ForceLinear = physenv.GetGravity()

		local Pos = self:GetPos()
		local TargetPos = Pos + self:GetVelocity()

		local AngForce = -self:WorldToLocalAngles( (TargetPos - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * 10 - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T )

		self:UpdateTrajectory()

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	function ENT:UpdateTrajectory()
		local base = self:GetParent()

		if not IsValid( base ) then return end

		self:SetSpeed( base:GetVelocity() )
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_IN_VEHICLE] = true
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end

	return
end

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "lvs/weapons/bomb_whistle_loop.wav")
	self.snd:SetSoundLevel( 110 )
	self.snd:PlayEx(0,150)
end

function ENT:CalcDoppler()
	local Ent = LocalPlayer()

	local ViewEnt = Ent:GetViewEntity()

	if Ent:lvsGetVehicle() == self then
		if ViewEnt == Ent then
			Ent = self
		else
			Ent = ViewEnt
		end
	else
		Ent = ViewEnt
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:Think()
	if self.snd then
		self.snd:ChangePitch( 100 * self:CalcDoppler(), 1 )
		self.snd:ChangeVolume(math.Clamp(-(self:GetVelocity().z + 1000) / 3000,0,1), 2)
	end

	if self.IsEnabled then return end

	if self:GetActive() then
		self:Enable()
	end
end

function ENT:Draw()
	local T = CurTime()

	if not self:GetActive() then
		self._PreventDrawTime = T + 0.1
		return
	end

	if (self._PreventDrawTime or 0) > T then return end

	self:DrawModel()
end

function ENT:SoundStop()
	if self.snd then
		self.snd:Stop()
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

local color_red = Color(255,0,0,255)
local color_red_blocked = Color(100,0,0,255)
local HudTargets = {}
hook.Add( "HUDPaint", "!!!!lvs_bomb_hud", function()
	for ID, _ in pairs( HudTargets ) do
		local Missile = Entity( ID )

		if not IsValid( Missile ) or Missile:GetActive() then
			HudTargets[ ID ] = nil

			continue
		end

		local Grav = physenv.GetGravity()
		local FT = 0.05
		local MissilePos = Missile:GetPos()
		local Pos = MissilePos
		local Vel = Missile:GetSpeed()

		local LastColor = color_red
		local Mask = Missile.GetMaskSolid and (Missile:GetMaskSolid() and MASK_SOLID or MASK_SOLID_BRUSHONLY) or MASK_SOLID_BRUSHONLY

		cam.Start3D()
		local Iteration = 0
		while Iteration < 1000 do
			Iteration = Iteration + 1

			Vel = Vel + Grav * FT

			local StartPos = Pos
			local EndPos = Pos + Vel * FT

			local trace = util.TraceLine( {
				start = StartPos,
				endpos = EndPos,
				mask = Mask,
			} )

			local traceVisible = util.TraceLine( {
				start = MissilePos,
				endpos = StartPos,
				mask = Mask,
			} )

			LastColor = traceVisible.Hit and color_red_blocked or color_red

			render.DrawLine( StartPos, EndPos, LastColor )

			Pos = EndPos

			if trace.Hit then
				break
			end
		end
		cam.End3D()

		local TargetPos = Pos:ToScreen()

		if not TargetPos.visible then continue end

		surface.DrawCircle( TargetPos.x, TargetPos.y, 20, LastColor )
	end
end )

net.Receive( "lvs_bomb_hud", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) then return end

	HudTargets[ ent:EntIndex() ] = true
end )

--addons/lvs_addons/lua/entities/lvs_fakehover_barc_medic/shared.lua:
ENT.Type = "anim"
DEFINE_BASECLASS( "lunasflightschool_basescript_gunship" )
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Medic Barc-speeder"
ENT.Author = "Codexx"
ENT.Information = "Biker Advanced Recon Commando "
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/barc/barc.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 1400

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 600

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 480
ENT.BoostAddVelocityY = 480

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(120.24,18.04 * i,26.96) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

end

ENT.EngineSounds = {
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 205,
	},
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "heracles421/galactica_vehicles/barc_engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.IFTX.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/iftx/fire_missile.mp3"
} )

--addons/lvs_addons/lua/entities/lvs_repdestroyer_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Republic Destroyer"
ENT.Author = "Ophra"
ENT.Information = "Destroyer of the Republic"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_rep_destroyer.mdl"


ENT.AITEAM = 1

ENT.MaxVelocity = 2000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.5
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.5

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 2000
ENT.MaxShield = 300



function ENT:InitWeapons()
	self.FirePositions = {
		Vector(300,150.6,-55),
		Vector(300,-150.6,-55),
		Vector(300, 150.6,-55),
		Vector(300,-150.6,-55),
	}

	


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 1016.45, (ent._swapMissile and -147.22 or 147.22 ), 10.39 )




		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green"
 		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(1016.45,147.22,10.39)
		)
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(1016.45,-147.22,10.39)
		)

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_addons/lua/entities/lvs_repulsorlift_dropship/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/c"
ENT.Author = "Luna"
ENT.Information = "Tank Carrier of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Gunships"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laat_c.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 40

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "HeldEntity" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src 	= att.Pos
			bullet.Dir 	= att.Ang:Up()
			bullet.Spread 	= Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1
	weapon.HeatRateUp = 10
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		ent:ToggleGrabber()
	end
	self:AddWeapon( weapon )



	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.RearGunAngleRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then return true end

		local trace = ent:GetEyeTrace()

		local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		local ID = self:LookupAttachment( "muzzle_reargun" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return true end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 65
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		if not IsValid( self.SNDTail ) then return end

		self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then base:SetPoseParameter("reargun_yaw", 0 ) return end

		local trace = ent:GetEyeTrace()

		local _,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		base:SetPoseParameter("reargun_pitch", -Ang.p )
		base:SetPoseParameter("reargun_yaw", -Ang.y )

	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local StartPos = pod:LocalToWorld( pod:OBBCenter() ) + angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local RearGunInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange

		local Col = RearGunInRange and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

sound.Add( {
	name = "LVS.LAAT.GRABBER",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "lvs/vehicles/laat/door_large_open.wav"
} )

sound.Add( {
	name = "LVS.LAAT.GRABBER_CANTDROP",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "buttons/button8.wav"
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:ResetFilters()
	-- clear the filters, so they can be rebuild
	self.CrosshairFilterEnts = nil
end

function ENT:BuildFilter()
	if not istable( self.CrosshairFilterEnts ) then
		self:GetCrosshairFilterEnts()
	end

	local HeldEnt = self:GetHeldEntity()

	if not IsValid( HeldEnt ) then return end

	if HeldEnt.GetCrosshairFilterEnts then
		for _, ent in pairs( HeldEnt:GetCrosshairFilterEnts() ) do
			table.insert( self.CrosshairFilterEnts, ent )
		end
	else
		table.insert( self.CrosshairFilterEnts , HeldEnt )
	end
end

--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/sh_ballturret_left.lua:
function ENT:SetPosBTL()
	local BTL = self:GetBTPodL()

	if not IsValid( BTL ) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local PosL = self:WorldToLocal( Muzzle.Pos + Muzzle.Ang:Right() * 28 - Muzzle.Ang:Up() * 65 )
		BTL:SetLocalPos( PosL )
	end
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTL( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("ballturret_left_pitch", AimAng.p )
	self:SetPoseParameter("ballturret_left_yaw", AimAng.y )
end

function ENT:InitWeaponBTL()
	local COLOR_RED = Color(255,0,0,255)
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.05
	weapon.HeatRateUp = 0.545
	weapon.HeatRateDown = 0.5
	weapon.OnOverheat = function( ent )
		if ent:GetAI() then return end
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()
		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )
		local bullet = {}
			bullet.Src 	= Muzzle.Pos
			bullet.Dir 	= Muzzle.Ang:Up()
			bullet.Spread 	= Vector( 0.0125,  0.0125, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 100
			bullet.HullSize 	= 10
			bullet.Damage	= 10
			bullet.SplashDamage = 50
			bullet.SplashDamageRadius = 200
			bullet.Velocity = 15000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Muzzle.Pos ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_explosion", effectdata )
			end
			ent:LVSFireBullet( bullet )
			-- ent:EmitSound("lvs/vehicles/laat/fire.mp3", 50 )
			self.sndBTL:EmitSound( "lvs/vehicles/laat/fire.mp3", 65 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
		base:SetPosBTL()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end


	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()
		base.ZoomFov = 20

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, COLOR_RED )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )





	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.345
	weapon.HeatRateDown = 0.1
	weapon.OnOverheat = function( ent )
		if ent:GetAI() then return end
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		local trace = base:TraceBTL()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		base:SetBTLFire( true )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Play()
		self.sndBTL:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTLFire( false )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
		base:SetPosBTL()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end

		if ent:AngleBetweenNormal(Muzzle.Ang:Up(),ent:GetAimVector()) > 5 then
			ent:SetHeat( 1 )
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()
		base.ZoomFov = 20

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, COLOR_RED )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship_space/cl_spotlights.lua:
function ENT:DrawSpotlights()
	if not self:IsSpotlightMounted() or not self:GetLightsActive() then
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:RemoveLight()
	if IsValid(self.projector_L) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid(self.projector_R) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end


function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	local spotlight = Material("effects/lfs_base/spotlight_projectorbeam")
	local glow_color = Color(255, 255, 255, 10)

	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, color_white)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color)

	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
	spotlight:SetBrightness(10)
	spotlight:SetTexture("effects/flashlight/soft")
	spotlight:SetColor(color_white)
	spotlight:SetEnableShadows(false)
	spotlight:SetFarZ(5000)
	spotlight:SetNearZ(75)
	spotlight:SetFOV(40)

	return spotlight
end

function ENT:OnRemove()
	self:RemoveLight()
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship_space/sh_driverweapons.lua:
function ENT:InitDriverWeapons()
	self.FirePositions = {
		Vector(432, 34, 36),
		Vector(432, -34, 36)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 255, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 255, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 24
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.75
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		self.RocketsModel:ResetSequence("Load_Missile")

		local Pos = Vector(150, ent._swapMissile and -70 or 70, 275)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos) )
		projectile:SetAngles(ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Opens / Close the door
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 1

		-- Sets the door mode
		local DoorMode = self:GetDoorMode() + 1
		DoorMode = DoorMode >= 2 and 0 or DoorMode
		self:SetDoorMode(DoorMode)

		if DoorMode == 0 then
			self:ResetSequence(self.closeSequence)
			self:SetPlaybackRate(1.5)

			local bonePos, _ = self:GetBonePosition(self:LookupBone("LAAT"))

			for doorID, _ in pairs(self.DoorsToClose) do
				local doorData = self.Doors[doorID]
				local offset = self:GetRight() * doorData.closeoffset.x + self:GetForward() * doorData.closeoffset.y + self:GetUp() * doorData.closeoffset.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)
			end

			timer.Simple(0.75, function()
				if not IsValid(self) then return end
				self:EmitSound("laat_bf2/door_close.mp3")

				if not self.IsHatchOpen then
					self:TurnLightRed()
				end
			end)
		end

		if DoorMode == 1 then
			if self:IsSpotlightMounted() then
				self:ResetSequence("Door_Open_Half")
				self.closeSequence = "Door_Closed_Half"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))
				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["R_Door2"] = true,
				}
			else
				self:ResetSequence("Door_Open_Both")
				self.closeSequence = "Door_Closed_Both"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))

				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["L_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["L_Door1"] = true,
					["R_Door2"] = true,
					["R_Door1"] = true,
				}
			end

			self:EmitSound("laat_bf2/door_open.mp3")

			self:TurnLightGreen()
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 2

		self:ToggleHatch()
	end

	self:AddWeapon(weapon, 3)

    local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grab.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function(ent)
        if not self.IsHatchOpen then return end

        self:GrabEntity()
	end
	self:AddWeapon(weapon, 3)

    local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_drop.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function(ent)
        if not self.IsHatchOpen then return end

        self:DropHeldEntity()
	end
	self:AddWeapon(weapon, 3)
end
--lua/entities/lvs_space_laat_arc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.nextEFX = 0
	self.nextDFX = 0
	self.nextBeepSound = 0
	self.nextLFX = 0
	self.NextAlertSound = 0
	--self.ActiveTime = CurTime()
	self.bommed = false
	self.onact = false
end


local spotlight = Material("effects/lvs/laat_spotlight")
local glow_spotlight = Material("sprites/light_glow02_add")
local spotlight_color = Color(255, 255, 255)
local glow_color = Color(255, 255, 255, 10)
local glow_reactor = Material("sprites/light_glow02_add")
local lamp_pos = Vector(3, 0, 135)
local lamp_color_black = Color(0, 0, 0)
local lamp_color_red = Color(255, 0, 0)
local lamp_color_green = Color(0, 255, 0)
local reactor_color = Color(0, 127, 255)
local reactor_pos = {
	Vector(-270, -20, 265),
	Vector(-270, 20, 265),
}

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lfs_fb_wingturret_projector", effectdata )
	end
end



function ENT:OnFrame()
	self:Boom()

	self:WingTurretProjector()

	self:ENGCheck()

	self:DamageFX()

	self:ExhaustFX()

end

function ENT:Boom()
	if self:GetHP() > 2200 then
		self.bommed = false
		self:StopParticles()
	end
	if self.bommed == false then
		if self:GetHP() < 2200 then
			ParticleEffectAttach("env_fire_large_smoke", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("R_Heat_Hatch"))
			self.bommed = true
			local effectdata = EffectData()
				effectdata:SetOrigin(self:LocalToWorld(Vector(-300, 0, 180)))
			util.Effect("lvs_explosion_small", effectdata)
		end
	end
end

function ENT:ENGCheck()
	if self.onact == false then
		if self:GetEngineActive() == true then
			self.ActiveTime = CurTime()
			self.onact = true
			self.nextEFX = CurTime() + 1
		end
	end
	if self.onact == true then
		if self:GetEngineActive() == false then
			self.onact = false
			self.StopTime = CurTime()
		end
	end
	if self:GetEngineActive() == false then
		self.onact = false
	end
end

function ENT:ExhaustFX()
	local FullThrottle = self:GetThrottle() >= 35

	if self.OldFullThrottle ~= FullThrottle then
		self.OldFullThrottle = FullThrottle
		if FullThrottle then 
			self:EmitSound("laat_bf2/boost_"..math.random(1, 2)..".wav")
		end
	end

	if self:GetEngineActive() then
		if self.nextEFX < CurTime() then
			self.nextEFX = CurTime() + 0.01
			
			local emitter = ParticleEmitter(self:GetPos(), false)
			local Pos = {
				Vector(-270, -20, 265),
				Vector(-270, 20, 265),
			}

			if emitter then
				for _, v in pairs(Pos) do
					local vOffset = self:LocalToWorld( v )
					local vNormal = -self:GetForward()
					local vOffset2 = vOffset + vNormal * 5

					local particle = emitter:Add("sprites/heatwave", vOffset2)
					if not particle then return end
						particle:SetVelocity(vNormal * math.Rand(1500, 1000) + self:GetVelocity())
						particle:SetLifeTime(0)
						particle:SetDieTime(0.1)
						particle:SetStartAlpha(255)
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(35, 50))
						particle:SetEndSize(math.Rand(0, 5))
						particle:SetRoll(math.Rand(-1, 1) * 100)
						particle:SetColor(255, 255, 255)
				end
				
				emitter:Finish()
			end
		end
	end
end

function ENT:CanSound()
	self.NextSound = self.NextSound or 0
	return self.NextSound < CurTime()
end

function ENT:CanSound2()
	self.NextSound2 = self.NextSound2 or 0
	return self.NextSound2 < CurTime()
end

function ENT:DelayNextSound( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound = CurTime() + fDelay
end

function ENT:DelayNextSound2( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound2 = CurTime() + fDelay
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(math.Clamp(math.Clamp(80 + Pitch * 25, 50, 255) + Doppler, 0, 255))
		self.ENG:ChangeVolume(math.Clamp(-1 + Pitch * 6, 0.5, 1))
	end
	
	if self.DIST then
		local ply = LocalPlayer()
		local DistMul = math.min((self:GetPos() - ply:GetPos()):Length() / 8000, 1) ^ 2
		self.DIST:ChangePitch(math.Clamp(100 + Doppler * 0.2, 0, 255))
		self.DIST:ChangeVolume(math.Clamp(-1.5 + Pitch * 6, 0.5, 1) * DistMul)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP <= 0 or HP > self:GetMaxHP() * 0.5 then return end

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)

		if HP <= 2200 then
			if math.random(0, 45) < 3 then
				if math.random(1, 3) == 1 then
					local Pos = self:LocalToWorld(Vector(0, 0, 140) + VectorRand() * 20)
						effectdata:SetOrigin(Pos)
					util.Effect("cball_explode", effectdata, true, true)
					sound.Play("laat_bf2/spark"..math.random(1, 4)..".ogg", Pos, 75)
				end
			end

			local ply = LocalPlayer()
			if self.NextAlertSound < CurTime() then
				self.NextAlertSound = CurTime() + 0.27
				self:EmitSound( "laat_bf2/crash.mp3", 85 )

				--sound.Play("laat_bf2/crash.mp3", self:GetPos() + self:GetForward() * 190 + self:GetUp() * 160, 75)
			end
		end
	end
end



function ENT:Draw()
	self:DrawModel()

	if self:GetEngineActive() then
		render.SetMaterial(glow_reactor)
		local delta = CurTime() - self.ActiveTime
		local max = math.min(15 * ( delta / 1 ), 15)

		local t = 0
		for _, v in pairs(reactor_pos) do
			if self:GetHP() < 2200 then
				if self.nextLFX > CurTime() && t == 1 then continue end
				self.nextLFX = CurTime() + math.random(0, 2)
			end

			local vOffset = self:LocalToWorld(v)
			local vNormal = -self:GetForward()
			
			for i = 0, max do 
				local vUp = -self:GetUp()
				local ind = i * 2
				local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

				render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
			end

			t = t + 1
		end
	else
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 1)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[2])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
			
		end
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 2)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[1])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
		end
	end
	local StartPos = self:LocalToWorld(lamp_pos)
	render.SetMaterial(glow_spotlight)
	local lamp_mode = self:GetLampMode()
	render.DrawSprite(StartPos, 80, 80, lamp_mode == 0 && lamp_color_black || lamp_mode == 1 && lamp_color_red || lamp_color_green)

	if not self:IsSpotlightMounted() or not self:GetSpotlightOn() or not self:GetEngineActive() then 
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:OnRemove()
	self:RemoveLight()
	self:RemoveLight2()
end

function ENT:RemoveLight2()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	render.SetMaterial(glow_spotlight)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, spotlight_color)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color) 
	
	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
		spotlight:SetBrightness(10) 
		spotlight:SetTexture("effects/flashlight/soft")
		spotlight:SetColor(spotlight_color) 
		spotlight:SetEnableShadows(false) 
		spotlight:SetFarZ(5000) 
		spotlight:SetNearZ(75) 
		spotlight:SetFOV(40)
	
	return spotlight
end

function ENT:OnSpawn()

end

--[[


function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end
end
]]--
function ENT:OnStartBoost()
	self:EmitSound( "laat_bf2/boost_"..math.random(1, 2)..".wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod == self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

--[[
function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() or self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end]]

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight2()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 4000 ) 
		thelamp:SetNearZ( 1 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(332.26,-2.1,5.41),
		Ang = Angle(135.25,-0.01,0.71)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 0, 20, 20, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 0,  StartPos + Dir * 100, 90, 0, 1, Color( 255, 255, 255, 12) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end
--addons/lvs_addons/lua/entities/lvs_starfighter_peltaclass/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Republic Pelta Class Frigate"
ENT.Author = "Salty"
ENT.Information = "Republic Pelta Class Frigate"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/peltaclassfrigate.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
	"models/salty/PeltaGib1.mdl",
	"models/salty/PeltaGib2.mdl",
	"models/salty/PeltaGib3.mdl",
	"models/salty/PeltaGib4.mdl",
	"models/salty/PeltaGib5.mdl",

}

ENT.AITEAM = 2

ENT.MaxVelocity = 1700
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3
ENT.TurnRatePitch = 0.1
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.07

ENT.ForceLinearMultiplier = 0.5

ENT.ForceAngleMultiplier = 0.9
ENT.ForceAngleDampingMultiplier = 0.5

ENT.MaxHealth = 12000
ENT.MaxShield = 2500

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )
	self:AddDT( "Entity", "FourthGunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(100,300,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 50 or AimAngles.p <= -50)
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(2063.79,491.55,425.06),
		Vector(2071.39,-472.58,425.02),
	}
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.40
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 130
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0, 255, 0) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0, 255, 0) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 80 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.95
	weapon.HeatRateUp = 0.40
	weapon.HeatRateDown = 0.8
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 5 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 70 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld(Vector(484.69,2.98,675.79) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 35
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 5) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 30 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-694.04,-552.87,682.9) or Vector(-694.02,-510.2,682.44) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
	
local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 30 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-702.96,506.41,682.09) or Vector(-705.49,549.28,681.37) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 500
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 4 )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 45 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-1215.85,-25.02,662.31) or Vector(-1216.4,18.25,662.18) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 45) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 5 )

end

ENT.FlyByAdvance = 0.90
ENT.FlyBySound = "lvs/vehicles/frigates/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/crash/crashingdown.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/frigates/loop3.wav",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighterinterceptor_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Sith Interceptor"
ENT.Author = "Ophra"
ENT.Information = "Interceptor of the Sith Empire"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_imp_starfighter_interceptor.mdl"


ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 2
ENT.TurnRateYaw = 2
ENT.TurnRateRoll = 0.6

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(55.87,18.66,-24.15),
		Vector(55.87,-18.66,-24.15),
		Vector(55.87,18.66,-24.15),
		Vector(55.87,-18.66,-24.15),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )





	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(55.87,-18.66*i,-24.15)
		)

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/lvs_addons/lua/entities/lvs_walker_hsd/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("cl_prediction.lua")
include("sh_weapons.lua")

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:ProjectorBeam()
	self:DamageFX()
end

function ENT:ProjectorBeam()
	local ProjectorBeam = self:GetProjectorBeam()

	if ProjectorBeam == self.OldProjectorBeam then return end

	self.OldProjectorBeam = ProjectorBeam

	if not ProjectorBeam then return end

	local effectdata = EffectData()
	effectdata:SetEntity( self )
	util.Effect( "lvs_hsd_dish_projector", effectdata )
end
	
function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,250) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,260) + VectorRand() * 80 ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

ENT.GlowPos1 = Vector(46,-2.89,294.88)
ENT.GlowPos2 = Vector(41.15,5.82,295.63)
ENT.GlowColor = Color( 255, 0, 0, 255)
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()

	if self:GetIsRagdoll() then return false end

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( self:LocalToWorld( self.GlowPos1 ), 32, 32, self.GlowColor )
	render.DrawSprite( self:LocalToWorld( self.GlowPos2 ), 16, 16, self.GlowColor )

	return false
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSHudPaint( X, Y, ply )
	if ply ~= self:GetDriver() then
		return
	end

	local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end

--addons/lvs_addons/lua/entities/lvs_zakfighter_swtor/cl_init.lua:
include("shared.lua")

-- Engine Particles start

ENT.EngineColor = Color( 0, 195, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,57,8.36),
	Vector(-163.81,-57,8.36),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 195, 255)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end

--addons/weapons_other/lua/entities/mk1.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jetpack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 4 , -6 , -0.2 ),
	OffsetAng = Angle( -90 , 90 , 90 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(12)	--drain in seconds
		self:SetFuelRecharge( 17 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2500 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--addons/arccw_weapons/lua/entities/mortal_grenade/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Mortal Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.ImpactFuse = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end

        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()

    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_imp_launcher", self:GetPos(), self:GetAngles() )
sound.Play( "weapons/star_wars_battlefront/common/exp_ord_thermalDetonator0" .. math.random(1,2) .. ".wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 200, 75)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),4096,100,0.6,1024)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(155, 50, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--lua/entities/plo_koon_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Plo Koon Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/plo_koon_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("plo_koon_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--addons/weapons_other/lua/entities/recondroid/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Category = "Evan's Remote Recon"
ENT.PrintName = "Recon Droid Camera"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.AutomaticFrameAdvance = true


if SERVER then
	//AddCSLuaFile("autorun/swep_net.lua")
end

function ENT:Initialize()
 timer.Simple(.5,function() self:ResetSequence(1) end)

end

function ENT:Think()

	self:SetCycle(CurTime() % 1)

end

function ENT:SetupDataTables()
		
		
	if ( SERVER ) then
		
	end

end
--addons/arccw_weapons/lua/entities/rep_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "PLX-1 Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 14
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
			phys:SetMass(2)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(100, 100, 225) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/arccw_weapons/lua/entities/rocket_rep/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "PLX-1 Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 14
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
			phys:SetMass(2)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(100, 100, 225) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/aoc_nextbots/lua/entities/summe_b2missle.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.PrintName = "AOCRPNextbots B2 Missle"
ENT.Category = "Other"

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/cs574/ammo/reworked_rocket.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)

        self.flightvector = self:GetForward() * ((110 * 52.5) / 66)

        self.Glow = ents.Create("env_sprite")
        self.Glow:SetKeyValue("model","orangecore2.vmt")
        self.Glow:SetKeyValue("rendercolor","235 52 222")
        self.Glow:SetKeyValue("scale","0.3")
        self.Glow:SetPos(self:GetPos())
        self.Glow:SetParent(self)
        self.Glow:Spawn()
        self.Glow:Activate()

        self:DrawShadow( true )
    else
        self.Emitter = ParticleEmitter(self:GetPos())
    end
    self.Delay = CurTime() + 8
    self.Damage = 150
end

function ENT:SetDamage(number)
    self.Damage = number
end

if SERVER then
    function ENT:Think()
        if self.Delay < CurTime() then
            SafeRemoveEntity(self)
        end

        local Table = {}
        Table[1] = self:GetOwner()
        Table[2] = self
        local trace = {}
        trace.start = self:GetPos()
        trace.endpos = self:GetPos() + self.flightvector
        trace.filter = Table
        local tr = util.TraceLine(trace)

        if tr.HitSky then
            SafeRemoveEntity(self)

            return true
        end

        if tr.Hit then
            self:Explode()
        end

        local speed = self.Speed or 33
        self:SetPos(self:GetPos() + self.flightvector)
        self.flightvector = self.flightvector - self.flightvector / ((10 * 39.37) / speed) + self:GetForward() * 2 + Vector(math.Rand(-0.3, 0.3), math.Rand(-0.3, 0.3), math.Rand(-0.1, 0.1)) + Vector(0, 0, -0.111)
        self:SetAngles(self.flightvector:Angle() + Angle(0, 0, 0))
        self:NextThink(CurTime())

        return true
    end
end

if CLIENT then
    function ENT:Think()
        local pos = self:GetPos()

        for i = 1, 5 do
            local part = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), pos + (self:GetForward() * 0 * i))

            if part then
                part:SetVelocity((self:GetForward() * -45) + (VectorRand() * 45))
                part:SetDieTime(math.Rand(1.1, 1.9))
                part:SetStartAlpha(math.Rand(15, 30))
                part:SetEndAlpha(0)
                part:SetStartSize(math.Rand(15, 15))
                part:SetEndSize(math.Rand(0.01, 0.02))
                part:SetRoll(math.Rand(0, 360))
                part:SetRollDelta(math.Rand(-1, 1))
                part:SetColor(85, 85, 85)
                part:SetAirResistance(200)
                part:SetGravity(Vector(0, 0, 0))
            end
        end
    end
end

function ENT:Explode()
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    util.Effect("HelicopterMegaBomb", effectdata)

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    effectdata:SetEntity(self)
    effectdata:SetScale(10)
    effectdata:SetRadius(100)
    effectdata:SetMagnitude(6)
    util.Effect("HelicopterMegaBomb", effectdata)
    util.ScreenShake(self:GetPos(), 10, 5, 1, 3000)

    sound.Play("Explosion.Boom", self:GetPos())
    sound.Play("ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self:GetPos(), 100, 80)

    util.BlastDamage(self, self, self:GetPos(), 350, self.Damage)
    local spos = self:GetPos()

    local trs = util.TraceLine({
        start = spos + Vector(0, 0, 64),
        endpos = spos + Vector(0, 0, -32),
        filter = self
    })

    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
    self.Explo = ents.Create("env_explosion")
    self.Explo:SetKeyValue("spawnflags", 144)
    self.Explo:SetKeyValue("iMagnitude", 15)
    self.Explo:SetKeyValue("iRadiusOverride", 256)
    self.Explo:SetPos(self:GetPos())
    self.Explo:Spawn()
    self.Explo:Fire("explode", "", 0)
    self:Remove()
end

function ENT:OnRemove()
end
--addons/aoc_nextbots/lua/entities/summe_nextbot/shared.lua:
AddCSLuaFile()

ENT.Base 			= "base_nextbot"
ENT.Spawnable		= false

ENT.Model = "models/npc/b1battledroids/b1_base.mdl"
ENT.Weapon = "weapon_npc_e5"
ENT.HP = 300
ENT.ShootingRange = 860
ENT.LooseRadius = 1500
ENT.Proficiency = 0
ENT.Speed = 100

ENT.Melee = false
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = false
--ENT.Grenades = {"rw_sw_ent_nade_impact", "rw_sw_ent_nade_stun", "rw_sw_ent_nade_thermal", "rw_sw_ent_nade_smoke"}

ENT.Duty = "Passive"
ENT.Duties = {
    "Passive",
    "Normal",
    "Patrol",
    "Attack"
}
--addons/arccw_weapons/lua/entities/tfbow_arrow_stuck_clientside/cl_init.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

include("shared.lua")

function ENT:Draw()
	if IsValid( self:GetParent() ) then
		self:GetParent():SetupBones()
	end
	self:SetupBones()
	self:DrawModel()
end
--addons/aocrp_emplacements/lua/entities/turret_bullets/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "Emplacements"
ENT.PrintName 		= "7.62x39mm Turret"
ENT.Author			= "Wolly/BOT_09"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.TurretFloatHeight=3
ENT.TurretModelOffset=Vector(0,0,40)
ENT.TurretTurnMax=0.7

ENT.LastShot=0
ENT.ShotInterval=0.07


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:NetworkVar("Float",1,"Heat")
	--self:DTVar("Entity",1,"ShootPos")

	if SERVER then 
		self:SetHeat(0)
	end 
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		plr.AOCRP_Emplacement = self 
		
		plr:SetNetVar("AOCRP_Emplacement", self)

		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			plr:SetNetVar("AOCRP_Emplacement", nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=60)
end



function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
--[[ 			local effectPosAng=self:GetAttachment(self.MuzzleAttachment)
			local vPoint = effectPosAng.Pos
			local effectdata = EffectData()
			effectdata:SetStart( vPoint )
			effectdata:SetOrigin( vPoint )
			effectdata:SetAngles(effectPosAng.Ang)
			effectdata:SetEntity(self)
			effectdata:SetScale( 1 )
			util.Effect( "MuzzleEffect", effectdata )
			 ]]
		--elseif SERVER then
			self:EmitSound(self.ShotSound,50,100)
			
			
		end
		
		if IsValid(self.shootPos) and SERVER then
			
			self:FireBullets({
				Num=1,
				Src=self.shootPos:GetPos()+self.shootPos:GetAngles():Forward()*10,
				Dir=self.shootPos:GetAngles():Forward()*1,
				Spread=Vector(0.02,0.02,0),
				Tracer=0,
				Force=2,
				Damage=18,
				Attacker=self.Shooter,
				Callback=function(attacker,trace,dmginfo) 
					--if CLIENT then
						
						local tracerEffect=EffectData()
						tracerEffect:SetStart(self.shootPos:GetPos())
						tracerEffect:SetOrigin(trace.HitPos)
						tracerEffect:SetScale(6000)
						util.Effect("tracer_blue",tracerEffect)


						self:SetHeat(self:GetHeat()+0.5)
					--end
					
			

				end
			})
			self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*50000 )
			
			
		end
		
		self.LastShot=CurTime()
	end
	
end

function ENT:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

    end

    return true;
end

ENT.HeatDelay = 0
function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=self.turretBase:GetAngles():Right():DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				if SERVER then 
					if self:GetHeat() < 100 then
						self:DoShot()
					end
				end
			else
				if SERVER then 
					if self:GetHeat() >= 1 then 
						if self.HeatDelay < CurTime() then
							self:SetHeat(self:GetHeat()-1)
							self.HeatDelay = CurTime() + 1
						end
					end 
				end
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--addons/lvs_addons/lua/entities/tx-ex/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-130 / TX-130-T"
ENT.Author = "Dec"
ENT.Information = "Republic Fighter Tank"
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/tkaro/starwars/vehicle/tx130/tx130.mdl"
ENT.GibModels = {
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_charge_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_flap_gib.mdl",
    "models/tkaro/starwars/vehicle/tx130/gibs/tx130_hatch_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_main_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_sidegun_gib_2.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_model_turret_gib.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_1.mdl",
	"models/tkaro/starwars/vehicle/tx130/gibs/tx130_wing_gib_2.mdl",
}

ENT.AITEAM = 2

ENT.ForceAngleMultiplier = 3
ENT.ForceAngleDampingMultiplier = 3

ENT.ForceLinearMultiplier = 3
ENT.ForceLinearRate = 3

ENT.SpawnNormalOffset = 50

ENT.MaxHealth = 3000
ENT.MaxShield = 250
ENT.MaxVelocityX = 400
ENT.BoostAddVelocitX = 500
ENT.IgnoreWater = false

ENT.MaxTurnRate = 1
ENT.RotorPos = Vector(-68,0,18)

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100


function ENT:OnSetupDataTables()

	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )

	self:NetworkVar( "Int",18, "DoorMode" )
	self:NetworkVar( "Bool",19, "BTLFire" )
	self:NetworkVar( "Bool",21, "RearHatch" )
	self:NetworkVar( "Bool",22, "WeaponOutOfRange" )
	self:NetworkVar( "Bool",23, "FrontInRange" )

end

function ENT:CalcMainActivityPassenger( ply )
end

function ENT:CalcMainActivity( ply )
	local guner = self:GetGunnerSeat()

    if ply ~= guner:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

    if ply.m_bWasNoclipping then 
        ply.m_bWasNoclipping = nil 
        ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
        
        if CLIENT then 
            ply:SetIK( true )
        end 
    end 

    ply.CalcIdeal = ACT_STAND
    ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

    return ply.CalcIdeal, ply.CalcSeqOverride
end


ENT.EngineSounds = {
	{
		channel = CHAN_STATIC,
		volume = 1.1,
		level = 100,
		sound = "lfs/tx130/engine.wav"
	},
	{
		channel = CHAN_STATIC,
		volume = 1,
		level = 90,
		sound = "lfs/tx130/interior.wav"
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,30)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)


function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.curfire = false

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.40
	weapon.HeatRateDown = 0.8
	weapon.Attack = function( ent )

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleL = self:GetAttachment( ID_L )
		local MuzzleR = self:GetAttachment( ID_R )
		
		if not MuzzleL or not MuzzleR then return end
			
		
		self:EmitSound( "lfs/tx130/twincannonlaser.wav" )
	
		self.MirrorPrimary = not self.MirrorPrimary
	
		local Pos = self.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir = (self.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		print(Dir)
		--if Dir < 150 then
			--local Pos = self:WorldToLocal(Pos) + Vector(0,0,10)
		--end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 150
		bullet.SplashDamage	= 100
		bullet.SplashDamageRadius	= 200
		bullet.Velocity = 	9000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:LVSFireBullet( bullet )
		util.ScreenShake(self:GetPos(), 35, 10, 0.5, 550, true )
	end
	weapon.OnThink = function( ent, active )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 20
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.9
	weapon.Attack = function( ent )
		timer.Simple( 0, function()
			if self:GetDoorMode() == 0 then return end
		
			local ID1 = self:LookupAttachment( "left_launch_tube_1" )
			local ID2 = self:LookupAttachment( "right_launch_tube_1" )
			local ID3 = self:LookupAttachment( "left_launch_tube_2" )
			local ID4 = self:LookupAttachment( "right_launch_tube_2" )
			local ID5 = self:LookupAttachment( "left_launch_tube_3" )
			local ID6 = self:LookupAttachment( "right_launch_tube_3" )
			local ID7 = self:LookupAttachment( "left_launch_tube_4" )
			local ID8 = self:LookupAttachment( "right_launch_tube_4" )
			local ID9 = self:LookupAttachment( "left_launch_tube_5" )
			local ID10 = self:LookupAttachment( "right_launch_tube_5" )
		
			local Muzzle1 = self:GetAttachment( ID1 )
			local Muzzle2 = self:GetAttachment( ID2 )
			local Muzzle3 = self:GetAttachment( ID3 )
			local Muzzle4 = self:GetAttachment( ID4 )
			local Muzzle5 = self:GetAttachment( ID5 )
			local Muzzle6 = self:GetAttachment( ID6 )
			local Muzzle7 = self:GetAttachment( ID7 )
			local Muzzle8 = self:GetAttachment( ID8 )
			local Muzzle9 = self:GetAttachment( ID9 )
			local Muzzle10 = self:GetAttachment( ID10 )
			
			local FirePos = {
				[1] = Muzzle1,
				[2] = Muzzle2,
				[3] = Muzzle3,
				[4] = Muzzle4,
				[5] = Muzzle5,
				[6] = Muzzle6,
				[7] = Muzzle7,
				[8] = Muzzle8,
				[9] = Muzzle9,
				[10] = Muzzle10,
			}
			
			if not FirePos then return end
			self.FireIndex2 = self.FireIndex2 and self.FireIndex2 + 1 or 1
			if self.FireIndex2 > 10 then
				self.FireIndex2 = 1
			end
			self:EmitSound( "lfs/tx130/rocket.wav" )

		
			local Pos = FirePos[self.FireIndex2].Pos
			if not IsValid( ent ) then return end

			if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
			ent:TakeAmmo()
			local Dir =  FirePos[self.FireIndex2].Angle

			local trace = ent:GetEyeTrace()

			local Driver = self:GetDriver()

			local Pos = self:WorldToLocal( Pos ) + Vector(25,0,10)	
			local projectile = ents.Create( "lvs_protontorpedo" )
			projectile:SetPos( self:LocalToWorld(Pos) )
			projectile:SetAngles( self:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile.GetTargetPos = function( projectile )
				return projectile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
			end
			projectile:SetAttacker(Driver)
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetDamage( 1500 )
			projectile:SetRadius( 300 )
			projectile:Enable()

			ent:SetHeat( 1 )
			ent:SetOverheated( true )

			for i=1,2 do
				local effectdata = EffectData()
				effectdata:SetOrigin(  self:LocalToWorld(Pos - Vector(0,0,30)) )
				effectdata:SetRadius(80 * 80)
				effectdata:SetScale(10 * 10)
				util.Effect( "ThumperDust", effectdata, true, true )
			end

		end)
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = 20
	weapon.Delay = 0
	weapon.HeatRateUp = 0.8
	weapon.HeatRateDown = 0.4
	weapon.Attack = function( ent )
		local Pod = self:GetGunnerSeat()
		local Driver = Pod:GetDriver()
		if self:GetBodygroup(1) == 1 then
			if IsValid( Driver ) and IsValid( Pod ) then
				local veh = ent:GetVehicle()
				self:SetBTLFire( true )
				if self.curfire == false then
					veh.SecSND:PlayOnce()
					self.curfire = true
				end
				
				local ID = self:LookupAttachment( "lazer_cannon_muzzle" )
				local Muzzle = self:GetAttachment( ID )
							
				local Dir = Muzzle.Ang:Up()
				local startpos = Muzzle.Pos
						
				local Trace = util.TraceLine( {
					start = startpos,
					endpos = (startpos + Dir * 50000),
				} )
					
				self:BallturretDamage( Trace.Entity, Driver, Trace.HitPos, Dir )
			end
		end
	end
	weapon.FinishAttack = function( ent )
		self:SetBTLFire( false )
		self.curfire = false
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if self:GetBodygroup(1) == 1 then

			local Pos2D = base:TraceBTL().HitPos:ToScreen()

			base:PaintCrosshairCenter( Pos2D, color_white )
			base:PaintCrosshairOuter( Pos2D, color_white )
			base:LVSPaintHitMarker( Pos2D )
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.4
	weapon.StartAttack = function( ent )
		if (self.turmount) then
			self.turmount = false
			self:SetBodygroup(1, 0)
		else
			self:SetBodygroup(1, 1)
			self.turmount = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self.lighton == true then
			self:SetBodygroup(9, 0)
			self.lighton = false
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self.lighton = true
			self:SetBodygroup(9, 1)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	self:AddWeapon( weapon, 3 )
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "lazer_cannon_muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end
--addons/tools/lua/entities/vanilla_highwake2/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace_HighWake"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--addons/arccw_weapons/lua/effects/astw2_haloreach_explosion_concussion/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 155
            light.b = 185
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/explosive_burst", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 195, 215 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/smoke_directional_large", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(0.3,0.6) )
    particle:SetStartAlpha( 155 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(75,125) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 255, 125, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo3/8pt_ringed_star_flare", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(125,200) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,125,210 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.3, 0.4) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(150,185) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,185,205 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_haloreach_explosion_grenade/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 135
            light.b = 100
            light.Brightness = 3
            light.Decay = 10
            light.Size = 724
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/8pt_ringed_star_flare", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(125,150) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	

    for i= 0,2 do
   local particle = emitter:Add("effects/halo3/smoke_dark", self.Origin)

    particle:SetVelocity( Vector(math.Rand(-100, 100),math.Rand(-100, 100),math.Rand(250, 400)) )
    particle:SetDieTime( math.Rand(2,3) )
    particle:SetStartAlpha( 25 )
    particle:SetEndAlpha( 100 )
    particle:SetStartSize( math.Rand(45,50) )
    particle:SetEndSize( math.Rand(85,90) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 155 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-325,-425) ) )
    particle:SetLighting( true )
    particle:SetCollide( false )
	end

		for i= 0,5 do
        particle = emitter:Add( "effects/halo3/explosion" .. math.random(2,4) , self.Origin )
        particle:SetVelocity( 7 * Vector(math.Rand(-25, 25),math.Rand(-25, 25),math.Rand(10, 25)) )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(30,50) )
        particle:SetEndSize( math.Rand(85,100) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,math.Rand( 200, 225 ),math.Rand( 175, 200 ) )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,25) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	end

    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/explosion1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.2, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(75,125) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/explosive_burst", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(175,300) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,155,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_laser/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.5 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 10, 15 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );
			particle:SetColor(255, 100, 100, 100);
		end
		emitter:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 100, 100, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_needler/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 16;

local MaterialGlow		= Material( "effects/halo3/flare1" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) );
			particle:SetStartAlpha( 155 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 200, 225, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_plasmarifle_brute/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 100, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 100, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_shotgun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_green_main" );
local MaterialFront			= Material( "effects/sw_laser_green_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_plasma_blue_burn/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_plasma_purple/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_haloreach_tracer_focusrifle/init.lua:

local Tracer = Material( "effects/halo2/c_gun_turret_contrail" )
local Tracer2  = Material( "effects/halo3/spartanlaser" )
local Width = 10
local Width2 = 5

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.1
	self.LifeTime2 = 0.15
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 205, 255, v * 200 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 220, 255, 185, (v2 * 155)*1 ) )

end

--addons/arccw_weapons/lua/effects/effect_t_laser_l_redplasma/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 20000;
EFFECT.Length				= 2000;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 3, 3, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_t_laser_long/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 40000;
EFFECT.Length				= 4000;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 3, 3, color_white );
	
end

--addons/aoc_fire_system/lua/effects/extinguish/init.lua:
--[[
THIS SCRIPT IS CREATED BY CRAP-HEAD
GMODSTORE PROFILE: https://www.gmodstore.com/users/crap-head
CRAP-HEAD STEAM ID || CRAP-HEAD ID 64
STEAM_0:0:14587461 || 76561198055197932
--]]

function EFFECT:Init( data )
	local target = data:GetEntity()
    local pos = Vector( 0, 0, 0 )
	
	if IsValid( self ) and IsValid( data:GetEntity() ) then
        pos = self:GetTracerShootPos( data:GetOrigin(), data:GetEntity():GetActiveWeapon(), data:GetAttachment())
    end
	local emitter = ParticleEmitter( pos )
	
	for i = 1, 10 do
		if target and IsValid( target ) and target:IsPlayer() and target:Alive() then
			local effect = emitter:Add( "effects/extinguisher", pos )
			effect:SetVelocity( target:GetAimVector() * 500 )
			effect:SetDieTime( 1 )
			effect:SetStartAlpha( 0 )
			effect:SetEndAlpha( 100 )
			effect:SetStartSize( 5 )
			effect:SetEndSize( 40 )
			effect:SetRoll( math.Rand( 0, 10  ) )
			effect:SetRollDelta( math.Rand( -0.2, 0.2 ) )
		end
	end
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/weapon_jedi/lua/effects/force_block_active.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()
	
	self.mat = Material( "effects/select_ring" )
	
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )
	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,70,150,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * (1 + math.abs( math.cos( CurTime() * 5 ) ) * 0.2 ) )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or not self.Ent:Alive() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	if IsValid( self.Ent ) then
		local Pos = self.Ent:GetPos() + Vector(0,0,40)

		local Scale = (self.DieTime - CurTime()) / self.LifeTime

		if IsValid( self.Model ) then
			local A = math.abs( math.cos( CurTime() * 5 ) )
			local InvA = 1 - A

			local r = 0
			local g = 127 * A + 50 * InvA
			local b = 255 * A + 255 * InvA
			local a = 255 * A + 255 * InvA

			self.Model:SetColor( Color(r,g,b,a) )
		end
	end
end

--addons/lvs_addons/lua/effects/lfs_fb_detonator_explosion.lua:
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Fire
	for _ = 1, 3 do
		local EffectCode = Emitter:Add("particles/flamelet1",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(30,40)))
            EffectCode:SetDieTime(math.Rand(0.4,0.6)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
            EffectCode:SetStartSize(math.Rand(60,80)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(100,100)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(0,0)) -- How fast it rolls
            EffectCode:SetColor(255,255,255) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end

	-- Smoke screen
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
            EffectCode:SetDieTime(math.Rand(7,9)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(200,230)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
            EffectCode:SetAirResistance(15)
	end

	-- Cloud of smoke that goes up
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-60,70),math.random(-60,70),math.random(70,100)))
            EffectCode:SetDieTime(math.Rand(3,4)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(150,190)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end
    
	Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/lvs_base/lua/effects/lvs_bullet_impact.lua:

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local scale = data:GetMagnitude()

	sound.Play( "physics/flesh/flesh_strider_impact_bullet"..math.random(1,3)..".wav", pos, 85, math.random(180,200) + 55 * math.max(1 - scale,0), 0.75 )
	sound.Play( "ambient/materials/rock"..math.random(1,5)..".wav", pos, 75, 180, 1 )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.2,0.18,0.15)) * 255

	local DieTime = math.Rand(0.8,1.6)

	if dir.z > 0.85 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

				if not particle then continue end

				particle:SetVelocity( (dir * 50 * i + VectorRand() * 25) * scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( 20 * i * scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 40) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,12 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )
		
		if particle then
			local ang = i * 30
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(200,1600) + Vector(0,0,50)
			Vel:Rotate( dir:Angle() + Angle(90,0,0) )

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( DieTime )
			particle:SetAirResistance( 500 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_explosion_bomb.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = Vector(0,0,1)
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = 3

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 3 do
				local StartPos = trace.HitPos + Vector(math.random(-200,200),math.random(-200,200),0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(3,6), math.Rand(3,6) )
			end
		end
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BOMB_EXPLOSION", Pos )
			sound.Play( "LVS.BOMB_EXPLOSION_DYNAMIC", Pos )
		end )
	end

	for i = 1, 10 do
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1, 10 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

		if not particle then continue end

		particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * scale )
		particle:SetDieTime( (i / 8) * DieTime )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( 20 * i * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
		particle:SetGravity( Vector(0,0,-600) * scale )
		particle:SetCollide( false )
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if particle then
			local ang = i * 15
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(1500,2000)

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( math.Rand(1,3) )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 )
			particle:SetEndSize( 600 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		local vel = VectorRand() * math.Rand(800,1600)
		vel.z = math.Rand(1000,4000)

		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.random(5,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -2000 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -450 * InvScale, 30,30, Color( 255, 200, 150, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -500 * InvScale, 30,30, Color( 255, 200, 150, 100 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -550 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 600 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
	end
end

--addons/lvs_addons/lua/effects/lvs_laser_blue.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_addons/lua/effects/lvs_laser_charge.lua:

EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.ID = data:GetAttachment()

	if not IsValid( self.Ent ) then return end

	
	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	self.Emitter = ParticleEmitter( Pos, false )
	self.Particles = {}
end

function EFFECT:Think()
	if (self.DieTime or 0) < CurTime() or not IsValid( self.Ent ) then 
		if IsValid( self.Emitter ) then
			self.Emitter:Finish()
		end

		return false
	end

	self:DoSpark()

	return true
end

function EFFECT:DoSpark()
	local T = CurTime()

	if (self._Next or 0) > T then return end

	self._Next = T + 0.01

	if not IsValid( self.Emitter ) then return end

	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos
	local Dir = VectorRand() * 25

	for id, particle in pairs( self.Particles ) do
		if not particle then
			self.Particles[ id ] = nil

			continue
		end

		particle:SetGravity( (Pos - particle:GetPos()) * 50 )
	end

	local particle = self.Emitter:Add( "sprites/rico1", Pos + Dir )

	if not particle then return end

	particle:SetDieTime( 0.25 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.Rand( 1, 5 ) )
	particle:SetEndSize( 0 )
	particle:SetColor( 255, 0, 0 )
	particle:SetAirResistance( 0 )
	particle:SetRoll( math.Rand(-10,10) )
	particle:SetRollDelta( math.Rand(-10,10) )

	table.insert( self.Particles, particle )
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	if Scale <= 0 then return end

	local rnd = VectorRand() * math.Rand(0,0.5)

	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( att.Pos, 30 *(1 - Scale), 30 * (1 - Scale), Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat ) 
	render.DrawSprite( att.Pos + rnd, 120 *  (1 - Scale), 120 * (1 - Scale), Color(255,0,0,255) ) 
end
	

--addons/lvs_addons/lua/effects/lvs_laser_explosion_aat.lua:


EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	self.Pos = Pos

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	sound.Play( "LVS.AAT.LASER_EXPLOSION", Pos )
	self:Explosion( Pos )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	if not emitter then return end

	for i = 0, 15 do
		local particle = emitter:Add( "sprites/light_glow02_add", pos )
		
		local vel = VectorRand() * 450
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(1,1.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,15) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255,0,0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )
		
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 1000
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.5,0.8) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( -vel:GetNormalized() * math.random(1250,1750) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )

		particle:SetAirResistance( 200 )
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		
		if not particle then continue end

		particle:SetVelocity( VectorRand(-1,1) * 500 )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 )
		particle:SetEndSize( math.Rand(30,60) )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = math.max((self.DieTime - self.LifeTime + 0.3 - CurTime()) / 0.3,0)
	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( self.Pos, 300 * Scale, 300 * Scale, Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 1000 * Scale, 1000 * Scale, Color( 255, 100, 50, 255) )

	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 250, 0, 0, 255) )
		render.DrawSprite( self.Pos, 25 * Scale, 25 * Scale, Color( 255, 255, 255, 255) )
	end

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -180 * InvScale, 30,30, Color( 255, 0, 0, 255 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -190 * InvScale, 30,30, Color( 255, 0, 0, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -200 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 210 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
	end
end

--addons/lvs_addons/lua/effects/lvs_laser_yellow.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 200, 150, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 200, 150, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/arccw_weapons/lua/effects/tfa_csgo_poisonade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 25 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 35 )
			else
				particle:SetDieTime( math.Rand( 30,35 ) )
			end
			particle:SetStartAlpha( math.Rand( 116, 216 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 116 )
			particle:SetEndSize( 216 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 95, 125, 60 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/arccw_weapons/lua/effects/thetalaser/init.lua:

EFFECT.Mat = Material( "effects/blueblacklargebeam" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
	self.WeaponEnt 		= data:GetEntity()
	self.Attachment 		= data:GetAttachment()
	
	self.Position 		= self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward 		= data:GetNormal()
	self.Angle 			= self.Forward:Angle()
	self.Right 			= self.Angle:Right()
	self.Up 			= self.Angle:Up()
	

	
	local emitter 		= ParticleEmitter(self.Position)
					local particle = emitter:Add("effects/yellowflare", self.Position)
			particle:SetVelocity(500 * self.Forward + 15 * VectorRand()) -- + AddVel)
			particle:SetAirResistance(0)
			particle:SetGravity(Vector(0, 0, math.Rand(25, 100)))
			particle:SetDieTime(math.Rand(1, 2))
			particle:SetStartAlpha(0)
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(8, 12))
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(-5, 45))
			particle:SetRollDelta(math.Rand(-0.05, 0.05))
			particle:SetColor(0, 0, 0)
			
								
			

	emitter:Finish()
	
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 7,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 222, 25, 11, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/arccw_weapons/lua/effects/tracer_blue/init.lua:
-- Credits: Meeks, Xan, Matsil, Masita
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 0, 255)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 0, 250)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 102
        dlight.b = 255
        dlight.brightness = 7
        dlight.Decay = 760
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tracer_green/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 255, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 255, 40)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 255
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 760
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/train_light.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)

	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)

	for i = 1, math.random(25, 35) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.2, 0.35))
		p:SetStartAlpha(255)
		p:SetEndAlpha(40)
		p:SetStartSize(math.random(35, 55) * self.size)
		p:SetEndSize(45 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 90, 0)
	end
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--addons/tools/lua/effects/vanilla_ship_explosion/init.lua:


local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Scale = data:GetScale()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i

				self:Explosion( p, Scale )
			end
		end)
	end

	self:Debris( Pos )
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if emitter then
		for i = 0,10 do
			local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], pos )

			if particle then
				particle:SetVelocity( VectorRand() * 1000 * scale )
				particle:SetDieTime( math.Rand(0.75,1.5) * 4)
				particle:SetAirResistance( math.Rand(200,600) )
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( math.Rand(60,120) * scale )
				particle:SetEndSize( math.Rand(160,280) * scale )
				particle:SetRoll( math.Rand(-1,1) )
				particle:SetColor( 40,40,40 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end

		for i = 0, 40 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

			if particle then
				particle:SetVelocity( VectorRand() * 1000 * scale )
				particle:SetDieTime( 0.14 )
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( math.Rand(60,120) * scale )
				particle:SetEndAlpha( 100 )
				particle:SetRoll( math.Rand( -1, 1 ) )
				particle:SetColor( 200,150,150 )
				particle:SetCollide( false )
			end
		end

		emitter:Finish()
	end

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/cl_menu.lua:
local function L(phrase, discriminator)
	return GAS:Phrase(phrase, "logging", discriminator)
end

if (IsValid(GAS.Logging.Menu)) then
	GAS.Logging.Menu:Close()
end
if (GAS.Logging.EvidenceBox and IsValid(GAS.Logging.EvidenceBox.Menu)) then
	GAS.Logging.EvidenceBox.Menu:Close()
end

local deep_storage_category_item
local advanced_search_category_item
local all_logs_category_item
local damage_logs_category_item

local user_icons   = {"user.png", "user_green.png", "user_orange.png", "user_red.png", "user_suit.png", "user_gray.png"}
local string_icons = {"tag_blue.png", "tag_green.png", "tag_orange.png", "tag_pink.png", "tag_purple.png", "tag_red.png", "tag_yellow.png"}
function GAS.Logging:OpenLogsContextMenu(row)
	local format_submenus = {
		[GAS.Logging.FORMAT_PLAYER]    = {L"players","icon16/user.png",},
		[GAS.Logging.FORMAT_WEAPON]    = {L"weapons","icon16/bomb.png"},
		[GAS.Logging.FORMAT_ENTITY]    = {L"entities","icon16/bricks.png"},
		[GAS.Logging.FORMAT_PROP]      = {L"props","icon16/box.png"},
		[GAS.Logging.FORMAT_RAGDOLL]   = {L"ragdolls","icon16/status_online.png"},
		[GAS.Logging.FORMAT_CURRENCY]  = {L"money","icon16/money.png"},
		[GAS.Logging.FORMAT_DAMAGE]    = {L"damage","icon16/emoticon_unhappy.png"},
		[GAS.Logging.FORMAT_COUNTRY]   = {L"countries","icon16/world.png"},
		[GAS.Logging.FORMAT_AMMO]      = {L"ammo","icon16/coins.png"},
		[GAS.Logging.FORMAT_TEAM]      = {L"teams","icon16/flag_red.png"},
		[GAS.Logging.FORMAT_USERGROUP] = {L"usergroups","icon16/group.png"},
		[GAS.Logging.FORMAT_ROLE]      = {L"roles","icon16/tag_red.png"},
		[GAS.Logging.FORMAT_VEHICLE]   = {L"vehicles","icon16/car.png"}
	}

	GAS:PlaySound("btn_heavy")

	local menu = DermaMenu()

	menu:AddOption(L"copy_log", function()
		if (row.IsColored) then
			GAS:SetClipboardText(GAS:MarkupToPlaintext(row.LabelsData[3]))
		else
			GAS:SetClipboardText(row.LabelsData[3])
		end
	end):SetIcon("icon16/page_copy.png")

	menu:AddOption(L"add_to_evidence_box", function()
		GAS.Logging.EvidenceBox:Add(row)
	end):SetIcon("icon16/box.png")

	if (row.Data[6]) then
		menu:AddOption(L"open_pvp_event_report", function()
			GAS:PlaySound("jump")
			if (IsValid(damage_logs_category_item)) then
				GAS:netStart("logging:PvPEventReport")
					net.WriteUInt(row.Data[6], 16)
				net.SendToServer()
			end
		end):SetIcon("icon16/bomb.png")
	end

	local user_icon_i = 1
	local string_icon_i = 1
	local data_submenu, category_submenus
	local duplicate_prevention = {}
	for _,replacement in ipairs(row.Data[1]) do
		if (replacement[1] == nil or (replacement[1] ~= GAS.Logging.FORMAT_STRING and replacement[1] ~= GAS.Logging.FORMAT_HIGHLIGHT and format_submenus[replacement[1]] == nil)) then continue end
		if (not data_submenu) then
			local _data_submenu, __ = menu:AddSubMenu(L"data")
			__:SetIcon("icon16/database_gear.png")
			data_submenu = _data_submenu
			category_submenus = {}
		end
		if (not category_submenus[replacement[1]]) then
			if (replacement[1] == GAS.Logging.FORMAT_STRING or replacement[1] == GAS.Logging.FORMAT_HIGHLIGHT) then
				local newsub,_ = data_submenu:AddSubMenu(L"strings")
				_:SetIcon("icon16/style.png")
				category_submenus[GAS.Logging.FORMAT_STRING] = newsub
				category_submenus[GAS.Logging.FORMAT_HIGHLIGHT] = newsub
			else
				local newsub,_ = data_submenu:AddSubMenu(format_submenus[replacement[1]][1])
				_:SetIcon(format_submenus[replacement[1]][2])
				category_submenus[replacement[1]] = newsub
			end
		end

		if (replacement[1] == GAS.Logging.FORMAT_TEAM) then
			if (duplicate_prevention[GAS.Logging.FORMAT_TEAM] and duplicate_prevention[GAS.Logging.FORMAT_TEAM][replacement[3]]) then
				continue
			else
				duplicate_prevention[GAS.Logging.FORMAT_TEAM] = duplicate_prevention[GAS.Logging.FORMAT_TEAM] or {}
				duplicate_prevention[GAS.Logging.FORMAT_TEAM][replacement[3]] = true
			end
		else
			if (duplicate_prevention[replacement[1]] and duplicate_prevention[replacement[1]][replacement[2]]) then
				continue
			else
				duplicate_prevention[replacement[1]] = duplicate_prevention[replacement[1]] or {}
				duplicate_prevention[replacement[1]][replacement[2]] = true
			end
		end

		if (replacement[1] == GAS.Logging.FORMAT_PLAYER) then

			local icon
			if (replacement[2] == "CONSOLE") then
				icon = "icon16/application_osx_terminal.png"
			elseif (replacement[2] == "BOT") then
				icon = "icon16/server.png"
			else
				icon = "icon16/" .. user_icons[user_icon_i]
			end

			local nick_label
			if (replacement[3] ~= nil and replacement[3][1] ~= nil) then
				nick_label = replacement[3][1]
			elseif (replacement[2] == "CONSOLE" or replacement[2] == "BOT") then
				nick_label = replacement[2]
			elseif (replacement[2] == nil) then
				nick_label = "UNKNOWN"
			else
				nick_label = GAS:AccountIDToSteamID(replacement[2])
			end

			if (replacement[2] == "CONSOLE" or replacement[2] == "BOT" or replacement[2] == nil) then
				category_submenus[replacement[1]]:AddOption(nick_label):SetIcon(icon)
			else
				local option = category_submenus[replacement[1]]:AddOption(nick_label, function()
					bVGUI.PlayerTooltip.Focus()
				end)
				option:SetIcon(icon)
				
				bVGUI.PlayerTooltip.Attach(option, {
					account_id = tonumber(replacement[2]),
					creator = option,
					focustip = L"click_to_focus"
				})
			end

			user_icon_i = user_icon_i + 1
			if (user_icon_i > #user_icons) then user_icon_i = 1 end

		elseif (replacement[1] == GAS.Logging.FORMAT_WEAPON) then

			local option = category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end)
			option:SetIcon(format_submenus[replacement[1]][2])

			GAS_Logging_DisplayEntity(function(pnl)
				pnl:SetWeapon(replacement[2])
			end, option, true)

		elseif (replacement[1] == GAS.Logging.FORMAT_PROP) then

			local option = category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end)
			option:SetIcon(format_submenus[replacement[1]][2])

			GAS_Logging_DisplayEntity(function(pnl)
				pnl:SetProp(replacement[2])
			end, option, true)

		elseif (replacement[1] == GAS.Logging.FORMAT_AMMO) then

			local option = category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end)
			option:SetIcon(format_submenus[replacement[1]][2])

			GAS_Logging_DisplayEntity(function(pnl)
				pnl:SetAmmo(replacement[2])
			end, option, true)

		elseif (replacement[1] == GAS.Logging.FORMAT_VEHICLE) then
			
			local option = category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end)
			option:SetIcon(format_submenus[replacement[1]][2])

			GAS_Logging_DisplayEntity(function(pnl)
				pnl:SetVehicle(replacement[2], replacement[3])
			end, option, true)

		elseif (replacement[1] == GAS.Logging.FORMAT_ENTITY) then

			local option = category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2] == "WORLD" and "worldspawn" or replacement[2])
			end)
			option:SetIcon(format_submenus[replacement[1]][2])

			if (replacement[2] ~= "WORLD") then
				GAS_Logging_DisplayEntity(function(pnl)
					pnl:SetEntity(replacement[2], replacement[3])
				end, option, true)
			end
			
		elseif (replacement[1] == GAS.Logging.FORMAT_TEAM) then

			bVGUI_DermaMenuOption_ColorIcon(category_submenus[replacement[1]]:AddOption(replacement[3], function()
				GAS:SetClipboardText(replacement[3])
			end), replacement[4])
			
		elseif (replacement[1] == GAS.Logging.FORMAT_COUNTRY) then

			local icon = "icon16/world.png"
			if (GAS.CountryCodesReverse[replacement[2]] ~= nil) then
				local country_code = GAS.CountryCodesReverse[replacement[2]]:lower()
				if (file.Exists("materials/flags16/" .. country_code .. ".png", "GAME")) then
					icon = "flags16/" .. country_code .. ".png"
				end
			end

			category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end):SetIcon(icon)
			
		elseif (replacement[1] == GAS.Logging.FORMAT_CURRENCY) then

			category_submenus[replacement[1]]:AddOption(GAS.Logging:FormatCurrencyStr(replacement[2]), function()
				GAS:SetClipboardText(replacement[2])
			end):SetIcon("icon16/money.png")

		elseif (replacement[1] == GAS.Logging.FORMAT_STRING or replacement[1] == GAS.Logging.FORMAT_HIGHLIGHT) then

			category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end):SetIcon("icon16/" .. string_icons[string_icon_i])

			string_icon_i = string_icon_i + 1
			if (string_icon_i > #string_icons) then string_icon_i = 1 end

		else

			category_submenus[replacement[1]]:AddOption(replacement[2], function()
				GAS:SetClipboardText(replacement[2])
			end):SetIcon(format_submenus[replacement[1]][2])

		end
	end

	menu:Open()
end

GAS.Logging.EvidenceBox = {}
function GAS.Logging.EvidenceBox:Open()
	if (IsValid(GAS.Logging.EvidenceBox.Menu)) then return true end

	GAS:PlaySound("popup")

	GAS.Logging.EvidenceBox.Menu = vgui.Create("bVGUI.Frame")
	GAS.Logging.EvidenceBox.Menu:SetSize(500,350)
	GAS.Logging.EvidenceBox.Menu:SetMinimumSize(500,350)
	GAS.Logging.EvidenceBox.Menu:SetTitle(L"evidence_box")
	GAS.Logging.EvidenceBox.Menu:Center()
	GAS.Logging.EvidenceBox.Menu:MakePopup()

	GAS.Logging.EvidenceBox.Rows = vgui.Create("bVGUI.Table", GAS.Logging.EvidenceBox.Menu)
	GAS.Logging.EvidenceBox.Rows.AddedLogs = {}
	GAS.Logging.EvidenceBox.Rows:Dock(FILL)
	GAS.Logging.EvidenceBox.Rows:AddColumn(L"log")
	GAS.Logging.EvidenceBox.Rows:SetRowCursor("hand")

	function GAS.Logging.EvidenceBox.Rows:OnRowClicked(row)
		GAS:PlaySound("btn_heavy")
		local menu = DermaMenu()
		menu:AddOption(L"remove", function()
			GAS:PlaySound("delete")
			GAS.Logging.EvidenceBox.Rows:RemoveRow(row.RowIndex)
		end):SetIcon("icon16/delete.png")
		menu:Open()
	end

	GAS.Logging.EvidenceBox.ExportContainer = vgui.Create("bVGUI.BlankPanel", GAS.Logging.EvidenceBox.Menu)
	GAS.Logging.EvidenceBox.ExportContainer:Dock(BOTTOM)
	GAS.Logging.EvidenceBox.ExportContainer:SetTall(40)
	function GAS.Logging.EvidenceBox.ExportContainer:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0,0,w,h)
	end

	GAS.Logging.EvidenceBox.ExportBtn = vgui.Create("bVGUI.Button", GAS.Logging.EvidenceBox.ExportContainer)
	GAS.Logging.EvidenceBox.ExportBtn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	GAS.Logging.EvidenceBox.ExportBtn:SetText(L"export_to_clipboard")
	GAS.Logging.EvidenceBox.ExportBtn:SetSize(150,25)
	function GAS.Logging.EvidenceBox.ExportBtn:DoClick()
		GAS:SetClipboardText(GAS.Logging.EvidenceBox:Export(GAS.Logging.EvidenceBox.Rows.Rows))
	end

	function GAS.Logging.EvidenceBox.ExportContainer:PerformLayout()
		GAS.Logging.EvidenceBox.ExportBtn:Center()
	end

	GAS.Logging.EvidenceBox.Menu:EnableUserResize()

	return false
end
function GAS.Logging.EvidenceBox:Add(row)
	if (GAS.Logging.EvidenceBox:Open()) then
		GAS:PlaySound("flash")
	end
	if (not GAS.Logging.EvidenceBox.Rows.AddedLogs[row.Data[7]]) then
		GAS.Logging.EvidenceBox.Rows:AddRow(row.LabelsData[3]).Data = row.Data
		GAS.Logging.EvidenceBox.Rows.AddedLogs[row.Data[7]] = true
	end
end
local EvidenceBox_Logo = string.Explode("\n",[[   ___ _ _ _       _        __                 
  / __(_) | |_   _( )__    / /  ___   __ _ ___ 
 /__\// | | | | | |/ __|  / /  / _ \ / _` / __|
/ \/  \ | | | |_| |\__ \ / /__| (_) | (_| \__ \
\_____/_|_|_|\__, ||___/ \____/\___/ \__, |___/
             |___/                   |___/     ]])
function GAS.Logging.EvidenceBox:Export(logs)
	local all_involved_steamids = {}

	local columns = {{},{},{},{},{}}

	local sorted_rows = {}
	for _,row in ipairs(logs) do
		table.insert(sorted_rows, {timestamp = row.Data[3], row = row})
	end
	table.SortByMember(sorted_rows, "timestamp", true)

	for _,sorted_row in pairs(sorted_rows) do
		local row = sorted_row.row
		local module_tbl = GAS.Logging.IndexedModules[row.Data[2]]
		table.insert(columns[1], "[" .. module_tbl.Category .. "]")
		table.insert(columns[2], "[" .. module_tbl.Name .. "]")
		table.insert(columns[3], "[" .. row.Data[7] .. "]")
		table.insert(columns[4], "[" .. GAS:FormatFullTimestamp(row.Data[3]) .. "]")
		local formatted_log = GAS.Logging:FormatMarkupLog(row.Data, false)
		local log_str
		if (row.Data[5]) then
			log_str = L(row.Data[5], "Logs")
		elseif (row.Data[4]) then
			log_str = row.Data[4]
		end
		for _,replacement in ipairs(row.Data[1]) do
			if (replacement[1] == GAS.Logging.FORMAT_PLAYER) then
				local nick = "UNKNOWN"
				if (replacement[2] == "CONSOLE" or replacement[2] == "BOT") then
					nick = replacement[2]
				elseif (replacement[3] ~= nil) then
					nick = GAS:utf8_force_strip(replacement[3][1])
				end
				all_involved_steamids[GAS:AccountIDToSteamID(replacement[2])] = nick
			end
		end
		table.insert(columns[5], formatted_log)
	end
	local column_lengths = {}
	for i,rows in ipairs(columns) do
		column_lengths[i] = 0
		for _,row in ipairs(rows) do
			if (#row > column_lengths[i]) then
				column_lengths[i] = #row
			end
		end
	end

	local exported = ""

	local longest_row

	local date = GAS:FormatFullTimestamp(os.time())
	local exported_by = GAS:utf8_force_strip(LocalPlayer():Nick()) .. " (" .. LocalPlayer():SteamID() .. ")"

	local longest_nick
	local longest_steamid
	if (not GAS:table_IsEmpty(all_involved_steamids)) then
		for steamid, nick in pairs(all_involved_steamids) do
			if (not longest_nick or utf8.len(nick) > longest_nick) then
				longest_nick = utf8.len(nick)
			end
			if (not longest_steamid or #steamid > longest_steamid) then
				longest_steamid = #steamid
			end
		end
	end
	local longest_involved_player
	if (longest_nick and longest_steamid) then
		longest_involved_player = longest_nick + longest_steamid + 1
	end

	if (longest_involved_player) then
		longest_row = math.max(utf8.len(exported_by) + 13, #date + 6, longest_involved_player)
	else
		longest_row = math.max(utf8.len(exported_by) + 13, #date + 6)
	end

	local logo_padding = math.max(math.ceil((longest_row + 2) / 2 - 47 / 2), 0)
	for _,line in ipairs(EvidenceBox_Logo) do
		exported = exported .. (" "):rep(logo_padding) .. line .. "\r\n"
	end

	exported = exported .. "\r\n" .. ("\\"):rep(longest_row + 4) .. "\r\n"
	exported = exported .. "[" .. (" "):rep(longest_row + 2) .. "]\r\n"

	local header_margin = math.max(math.ceil((longest_row - 19) / 2), 0)
	local header_margin_right = math.max(math.floor((longest_row - 19) / 2), 0)
	exported = exported .. "[ " .. (" "):rep(header_margin) .. "Evidence Box Export" .. (" "):rep(header_margin_right) .. " ]\r\n"

	exported = exported .. "[" .. (" "):rep(longest_row + 2) .. "]\r\n"
	exported = exported .. "[ Date: " .. (" "):rep(longest_row - 6 - #date) .. date .. " ]\r\n"
	exported = exported .. "[ Exported by: " .. (" "):rep(longest_row - 13 - utf8.len(exported_by)) .. exported_by .. " ]\r\n"
	exported = exported .. "[" .. (" "):rep(longest_row + 2) .. "]\r\n"

	if (longest_involved_player) then
		local header_margin = math.max(math.ceil((longest_row - 16) / 2), 0)
		local header_margin_right = math.max(math.floor((longest_row - 16) / 2), 0)
		exported = exported .. "[ " .. (" "):rep(header_margin) .. "Involved Players" .. (" "):rep(header_margin_right) .. " ]\r\n"
		exported = exported .. "[" .. (" "):rep(longest_row + 2) .. "]\r\n"

		for steamid, nick in pairs(all_involved_steamids) do
			exported = exported .. "[ " .. nick .. (" "):rep(longest_row - #steamid - utf8.len(nick)) .. steamid .. " ]\r\n"
		end

		exported = exported .. "[" .. (" "):rep(longest_row + 2) .. "]\r\n"
	end

	exported = exported .. ("/"):rep(longest_row + 4) .. "\r\n\r\n"
	exported = exported .. "[ Category / Module / ID / Timestamp / Log ]\r\n"

	local row_count = #columns[1]
	local row_index = 1
	while (row_index <= row_count) do
		exported = exported .. "\r\n"
		for i,rows in ipairs(columns) do
			local row = rows[row_index]
			local spaces = 0
			if (i ~= #columns) then
				spaces = math.max(column_lengths[i] - #row + 1, 1)
			end
			exported = exported .. row .. (" "):rep(spaces)
		end
		row_index = row_index + 1
	end

	return exported
end

function GAS.Logging:ShowClassSelector(content)
	GAS.Logging.ClassSelector = vgui.Create("bVGUI.Frame")
	GAS.Logging.ClassSelector:SetTitle(L"class_selector")
	GAS.Logging.ClassSelector:SetSize(560,500)
	GAS.Logging.ClassSelector:SetMinimumSize(560,500)
	GAS.Logging.ClassSelector:Center()
	GAS.Logging.ClassSelector:MakePopup()

	GAS.Logging.ClassSelector.Categories = vgui.Create("DPanel", GAS.Logging.ClassSelector)
	GAS.Logging.ClassSelector.Categories:Dock(LEFT)
	GAS.Logging.ClassSelector.Categories:SetWide(130)
	GAS.Logging.ClassSelector.Categories:DockPadding(10,10,10,10)
	function GAS.Logging.ClassSelector.Categories:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)

		if (not IsValid(GAS.Logging.Menu) or not GAS.Logging.Menu.AdvancedSearch:IsVisible()) then
			GAS.Logging.ClassSelector:Close()
		end
	end

	GAS.Logging.ClassSelector.Search = vgui.Create("bVGUI.Button", GAS.Logging.ClassSelector.Categories)
	GAS.Logging.ClassSelector.Search:Dock(BOTTOM)
	GAS.Logging.ClassSelector.Search:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	GAS.Logging.ClassSelector.Search:SetText(L"search")
	GAS.Logging.ClassSelector.Search:SetTall(25)
	function GAS.Logging.ClassSelector.Search:DoClick()
		if (GAS.Logging.ClassSelector.SearchQuery ~= nil) then
			GAS:PlaySound("delete")

			GAS.Logging.ClassSelector.SearchQuery = nil
			
			GAS.Logging.ClassSelector.Search:SetColor(bVGUI.BUTTON_COLOR_BLUE)
			GAS.Logging.ClassSelector.Search:SetText(L"search")

			GAS.Logging.ClassSelector.Pagination:SetPage(1)
			GAS.Logging.ClassSelector.Pagination:OnPageSelected(1)
		else
			GAS:PlaySound("flash")

			GAS.Logging.ClassSelector.CloseFrames = GAS.Logging.ClassSelector.CloseFrames or {}
			GAS.Logging.ClassSelector.CloseFrames[
				bVGUI.StringQuery(L"class_search_title", L"class_search_text", L"class_name_ellipsis", function(query)
					GAS.Logging.ClassSelector.SearchQuery = query

					GAS.Logging.ClassSelector.Search:SetColor(bVGUI.BUTTON_COLOR_RED)
					GAS.Logging.ClassSelector.Search:SetText(L"cancel")

					GAS.Logging.ClassSelector.Pagination:SetPage(1)
					GAS.Logging.ClassSelector.Pagination:OnPageSelected(1)
				end)
			] = true
		end
	end

	local class_type_names = GAS.Logging:ClassTypeNames(L)
	local allowed_types = {}
	for i,v in pairs(class_type_names) do
		local container = vgui.Create("bVGUI.BlankPanel", GAS.Logging.ClassSelector.Categories)
		container:Dock(TOP)
		container:SetTall(18)
		container:DockMargin(0,0,0,10)
		container:SetCursor("hand")
		container:SetMouseInputEnabled(true)

		local checkbox = vgui.Create("bVGUI.Checkbox", container)
		checkbox:Dock(LEFT)
		checkbox:SetChecked(true)
		checkbox:SetText(v)
		checkbox:DockMargin(0,0,10,0)
		function container:OnMouseReleased(m)
			checkbox:OnMouseReleased(m)
		end

		allowed_types[i] = true
		function checkbox:OnChange()
			if (self:GetChecked()) then
				allowed_types[i] = true
			else
				allowed_types[i] = nil
			end
			GAS.Logging.ClassSelector.Pagination:SetPage(1)
			GAS.Logging.ClassSelector.Pagination:OnPageSelected(1)
		end

		local label = vgui.Create("DLabel", container)
		label:SetText(v)
		label:SetTextColor(bVGUI.COLOR_WHITE)
		label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
		label:Dock(FILL)
		label:SetContentAlignment(4)
	end

	GAS.Logging.ClassSelector.ContentTable = vgui.Create("bVGUI.Table", GAS.Logging.ClassSelector)
	GAS.Logging.ClassSelector.ContentTable:Dock(FILL)
	GAS.Logging.ClassSelector.ContentTable:AddColumn(L"class_type", bVGUI.TABLE_COLUMN_SHRINK)
	GAS.Logging.ClassSelector.ContentTable:AddColumn(L"value")
	GAS.Logging.ClassSelector.ContentTable:SetRowCursor("hand")
	GAS.Logging.ClassSelector.ContentTable:SetLoading(true)

	function GAS.Logging.ClassSelector.ContentTable:OnRowRightClicked(row, column_index)
		if (column_index == 2 and row.Data[2] == GAS.Logging.ClassType_PLAYER) then
			bVGUI.PlayerTooltip.Focus()
		end
	end
	function GAS.Logging.ClassSelector.ContentTable:OnRowClicked(row)
		GAS:PlaySound("btn_heavy")

		local item = vgui.Create("GAS.Logging.AdvancedSearchItem", content)
		item:SetValue(tostring(row.Data[3]))
		item:SetText("(" .. row.LabelsData[1] .. ") " .. row.LabelsData[2])
		item:SetColor(Color(255,120,0))
		if (row.AccountID) then
			item:SetAccountID(row.AccountID)
			GAS.Logging.Menu.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(2, item)
		else
			GAS.Logging.Menu.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(3, item)
		end
	end
	function GAS.Logging.ClassSelector.ContentTable:OnColumnHovered(row, column_index)
		if (row.AccountID) then
			if (column_index == 2) then
				bVGUI.PlayerTooltip.Create({
					account_id = tonumber(row.AccountID),
					creator = row,
					focustip = L"right_click_to_focus"
				})
			else
				bVGUI.PlayerTooltip.Close()
			end
		end
	end

	GAS.Logging.ClassSelector.PaginationContainer = vgui.Create("bVGUI.BlankPanel", GAS.Logging.ClassSelector)
	GAS.Logging.ClassSelector.PaginationContainer:Dock(BOTTOM)
	GAS.Logging.ClassSelector.PaginationContainer:SetTall(30)
	function GAS.Logging.ClassSelector.PaginationContainer:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0,0,w,h)
	end

	GAS.Logging.ClassSelector.Pagination = vgui.Create("bVGUI.Pagination", GAS.Logging.ClassSelector.PaginationContainer)
	GAS.Logging.ClassSelector.Pagination:Dock(FILL)
	GAS.Logging.ClassSelector.Pagination:SetPages(1)
	function GAS.Logging.ClassSelector.Pagination:OnPageSelected(page)
		GAS.Logging.ClassSelector.ContentTable:Clear()
		GAS.Logging.ClassSelector.ContentTable:SetLoading(true)
		GAS:netStart("logging:ClassSelector:GetPage")
			net.WriteUInt(page, 10)
			local allowed_types_count = table.Count(allowed_types)
			if (allowed_types_count ~= table.Count(class_type_names)) then
				net.WriteBool(true)
				net.WriteUInt(allowed_types_count, 6)
				for allowed_type in pairs(allowed_types) do
					net.WriteUInt(allowed_type, 6)
				end
			else
				net.WriteBool(false)
			end
			if (GAS.Logging.ClassSelector.SearchQuery ~= nil) then
				net.WriteBool(true)
				net.WriteString(GAS.Logging.ClassSelector.SearchQuery)
			else
				net.WriteBool(false)
			end
		net.SendToServer()
	end

	function GAS.Logging.ClassSelector.ContentTable:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,150)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(0,0,10,h)
	end

	GAS.Logging.ClassSelector:EnableUserResize()
	GAS.Logging.ClassSelector.Pagination:OnPageSelected(1)
end

GAS:netReceive("logging:ClassSelector:GetPage", function()
	local pages = net.ReadUInt(10)
	local data_len = net.ReadUInt(16)
	local data = GAS:DeserializeTable(util.Decompress(net.ReadData(data_len)))
	if (not IsValid(GAS.Logging.ClassSelector)) then return end
	GAS.Logging.ClassSelector.Pagination:SetPages(pages)
	GAS.Logging.ClassSelector.ContentTable:Clear()
	GAS.Logging.ClassSelector.ContentTable:SetLoading(false)
	
	local class_type_names = GAS.Logging:ClassTypeNames(L)
	for _,row in ipairs(data) do
		local class_type = class_type_names[tonumber(row.class_type)] or L"unknown"
		local row_pnl
		if (tonumber(row.class_type) == GAS.Logging.ClassType_PLAYER) then
			if (row.class_name == "BOT") then
				row_pnl = GAS.Logging.ClassSelector.ContentTable:AddRow(class_type, "BOT")
			else
				row_pnl = GAS.Logging.ClassSelector.ContentTable:AddRow(class_type, GAS:AccountIDToSteamID(row.class_name))
			end
			row_pnl.AccountID = tonumber(row.class_name)
		else
			row_pnl = GAS.Logging.ClassSelector.ContentTable:AddRow(class_type, row.class_name)
		end
		row_pnl.Data = {tonumber(row.id), tonumber(row.class_type), row.class_name}
	end
end)

GAS:hook("gmodadminsuite:ModuleSize:logging", "logging:framesize", function()
	return 1000,600
end)

local search_tab_mat = Material("gmodadminsuite/search_tab.vtf")
local database_mat = Material("gmodadminsuite/database.vtf")
local search_mat = Material("gmodadminsuite/search.vtf")
local logo_mat = Material("gmodadminsuite/blogs.vtf")
local advancedsearch_dropshadow = Material("gmodadminsuite/advancedsearch_dropshadow.vtf")
GAS:hook("gmodadminsuite:ModuleFrame:logging", "logging:menu", function(ModuleFrame)
	GAS.Logging.Menu = ModuleFrame

	local is_operator = OpenPermissions:IsOperator(LocalPlayer())

	ModuleFrame.Tabs = vgui.Create("bVGUI.Tabs", ModuleFrame)
	ModuleFrame.Tabs:Dock(TOP)
	ModuleFrame.Tabs:SetTall(40)

	ModuleFrame.logs_content = ModuleFrame.Tabs:AddTab(L"logs", bVGUI.COLOR_GMOD_BLUE)

	ModuleFrame.logs_content.Categories = vgui.Create("bVGUI.Categories", ModuleFrame.logs_content)
	ModuleFrame.logs_content.Categories:Dock(LEFT)
	ModuleFrame.logs_content.Categories:SetWide(175)
	ModuleFrame.logs_content.Categories:EnableSearchBar()
	ModuleFrame.logs_content.Categories:SetLoading(true)

	function ModuleFrame.logs_content:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(self.Categories:GetWide(),0,10,h)
	end

	GAS.Logging.Menu.LogsTable = vgui.Create("bVGUI.Table", ModuleFrame.logs_content)
	GAS.Logging.Menu.LogsTable:Dock(FILL)
	GAS.Logging.Menu.LogsTable:AddColumn(L"module", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
	GAS.Logging.Menu.LogsTable:AddColumn(L"when", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
	GAS.Logging.Menu.LogsTable:AddColumn(L"log", bVGUI.TABLE_COLUMN_GROW)
	GAS.Logging.Menu.LogsTable:SetRowCursor("hand")

	function GAS.Logging.Menu.LogsTable:OnRowRightClicked(row)
		self:OnRowClicked(row)
	end
	function GAS.Logging.Menu.LogsTable:OnRowClicked(row)
		GAS.Logging:OpenLogsContextMenu(row)
	end

	function GAS.Logging.Menu.LogsTable:OnColumnHovered(row, column_index)
		if (column_index == 1) then
			bVGUI.CreateTooltip({
				Text = GAS.Logging.IndexedModules[row.Data[2]].Category,
				TextColor = GAS.Logging.IndexedModules[row.Data[2]].Colour,
				VGUI_Element = row
			})
		elseif (column_index == 2) then
			bVGUI.CreateTooltip({
				Text = GAS:FormatFullTimestamp(row.Data[3]),
				VGUI_Element = row
			})
		else
			bVGUI.DestroyTooltip()
		end
	end

	GAS.Logging.Menu.LogsTable.CurrentPage = 1
	GAS.Logging.Menu.LogsTable.ModuleID = false
	GAS.Logging.Menu.LogsTable.DeepStorage = false

	local pagination_container
	local pagination

	local damage_logs_mode = false

	local time_taken
	local function LoadLogs()
		if (IsValid(all_logs_category_item)) then
			if (GAS.Logging.Menu.LogsTable.ModuleID == false) then
				all_logs_category_item:SetActive(true)
			end
		end

		ModuleFrame.AdvancedSearch:SetVisible(false)
		ModuleFrame.DeepStorage:SetVisible(false)
		pagination_container:SetVisible(true)
		GAS.Logging.Menu.SearchTab:SetVisible(true)
		GAS.Logging.Menu.QuickSearch:SetVisible(true)

		time_taken:SetVisible(true)
		time_taken:SetText(L"loading_ellipsis")
		time_taken:SizeToContents()
		local time_taken_SysTime = SysTime()

		GAS.Logging.Menu.LogsTable:Clear()
		GAS.Logging.Menu.LogsTable:SetLoading(true)
		GAS.Logging.Menu.LogsTable:SetVisible(true)
		GAS.Logging.Menu.LogsTable:MoveToAfter(GAS.Logging.Menu.DamageLogs)
		time_taken:MoveToAfter(GAS.Logging.Menu.LogsTable)

		GAS.Logging.Menu.DamageLogs:SetVisible(false)
		GAS.Logging.Menu.DamageLogs.Padding:SetVisible(false)
		GAS.Logging.Menu.DamageLogs.NoData:SetVisible(false)

		local function LogsLoaded(data_present, len, filtered)
			if (not IsValid(GAS.Logging.Menu.LogsTable)) then return end
			GAS.Logging.Menu.LogsTable:SetLoading(false)

			pagination:SetPage(GAS.Logging.Menu.LogsTable.CurrentPage)

			if (data_present) then
				local benchmark = net.ReadFloat()

				if (filtered ~= true) then
					local pages = net.ReadUInt(16)
					pagination:SetPages(math.max(pages, 1))
				end
				pagination:SetInfinite(filtered == true)

				local cl_time = math.Round(SysTime() - time_taken_SysTime, 2)
				if (cl_time >= 1) then
					cl_time = cl_time .. "s"
				else
					cl_time = cl_time * 1000 .. "ms"
				end

				local sv_time = math.Round(benchmark, 2)
				if (sv_time >= 1) then
					sv_time = sv_time .. "s"
				else
					sv_time = sv_time * 1000 .. "ms"
				end

				time_taken:SetText("cl " .. cl_time .. " / sv " .. sv_time)
				time_taken:SizeToContents()
			else
				pagination:SetInfinite(false)
				if (filtered == true) then
					pagination:SetPages(pagination:GetPage())
				end

				local cl_time = math.Round(SysTime() - time_taken_SysTime, 2)
				if (cl_time >= 1) then
					cl_time = cl_time .. "s"
				else
					cl_time = cl_time * 1000 .. "ms"
				end

				time_taken:SetText("cl " .. cl_time)
				time_taken:SizeToContents()
			end
		end

		if (GAS.Logging.Menu.LogsTable.Filters) then
			GAS.Logging.Menu.SendLogs_TransactionID = GAS:StartNetworkTransaction("logging:GetFilteredPage", function()
				net.WriteUInt(GAS.Logging.Menu.LogsTable.CurrentPage, 16)
				local data = util.Compress(GAS:SerializeTable(GAS.Logging.Menu.LogsTable.Filters))
				net.WriteUInt(#data, 32)
				net.WriteData(data, #data)
				net.WriteBool(GAS.Logging.Menu.LogsTable.DeepStorage)
				net.WriteBool(ModuleFrame.AdvancedSearch.Greedy:GetChecked())
				net.WriteString(GAS.Languages:GetSelectedLanguage("logging"))
				if (GAS.Logging.Menu.LogsTable.ModuleID ~= false) then
					net.WriteBool(true)
					net.WriteUInt(GAS.Logging.Menu.LogsTable.ModuleID, 12)
				else
					net.WriteBool(false)
				end
			end, function(data_present, len)
				LogsLoaded(data_present, len, true)
			end)
		else
			GAS.Logging.Menu.SendLogs_TransactionID = GAS:StartNetworkTransaction("logging:GetPage", function()
				net.WriteUInt(GAS.Logging.Menu.LogsTable.CurrentPage, 16)
				net.WriteBool(GAS.Logging.Menu.LogsTable.ModuleID ~= false)
				net.WriteUInt(GAS.Logging.Menu.LogsTable.ModuleID or 0, 12)
				net.WriteBool(GAS.Logging.Menu.LogsTable.DeepStorage)
			end, LogsLoaded)
		end
	end

	local function LoadDamageLogs()
		if (IsValid(damage_logs_category_item)) then damage_logs_category_item:SetActive(true) end

		ModuleFrame.AdvancedSearch:SetVisible(false)
		ModuleFrame.DeepStorage:SetVisible(false)
		pagination_container:SetVisible(true)
		GAS.Logging.Menu.SearchTab:SetVisible(true)
		GAS.Logging.Menu.QuickSearch:SetVisible(true)

		time_taken:SetVisible(true)
		time_taken:SetText(L"loading_ellipsis")
		time_taken:SizeToContents()
		local time_taken_SysTime = SysTime()

		GAS.Logging.Menu.LogsTable:Clear()
		GAS.Logging.Menu.LogsTable:SetVisible(false)

		GAS.Logging.Menu.DamageLogs:Clear()
		GAS.Logging.Menu.DamageLogs:SetVisible(true)
		GAS.Logging.Menu.DamageLogs.Padding:SetVisible(true)
		GAS.Logging.Menu.DamageLogs:SetLoading(true)
		GAS.Logging.Menu.DamageLogs:MoveToAfter(GAS.Logging.Menu.LogsTable)
		GAS.Logging.Menu.DamageLogs.NoData:SetVisible(false)

		GAS.Logging.Menu.SendLogs_TransactionID = GAS:StartNetworkTransaction("logging:GetDamageLogsPage", function()
			net.WriteUInt(GAS.Logging.Menu.DamageLogs.CurrentPage, 16)
			net.WriteUInt(GAS.Logging.Menu.DamageLogs.FilterLen, 7)
			for v in pairs(GAS.Logging.Menu.DamageLogs.Filter) do
				net.WriteUInt(v, 31)
			end
		end, function(data_present, len)
			if (not IsValid(GAS.Logging.Menu.DamageLogs)) then return end
			if (not IsValid(pagination)) then return end
			GAS.Logging.Menu.DamageLogs:SetLoading(false)

			if (data_present) then
				local benchmark = net.ReadFloat()

				local is_not_filtered = net.ReadBool()
				if (is_not_filtered) then
					local pages = net.ReadUInt(16)
					pagination:SetInfinite(false)
					pagination:SetPages(math.max(pages, 1))
				else
					pagination:SetInfinite(true)
				end

				local cl_time = math.Round(SysTime() - time_taken_SysTime, 2)
				if (cl_time >= 1) then
					cl_time = cl_time .. "s"
				else
					cl_time = cl_time * 1000 .. "ms"
				end

				local sv_time = math.Round(benchmark, 2)
				if (sv_time >= 1) then
					sv_time = sv_time .. "s"
				else
					sv_time = sv_time * 1000 .. "ms"
				end

				time_taken:SetText("cl " .. cl_time .. " / sv " .. sv_time)
				time_taken:SizeToContents()
				time_taken:MoveToAfter(GAS.Logging.Menu.DamageLogs.Padding)
			else
				pagination:SetInfinite(false)
				if (GAS.Logging.Menu.DamageLogs.FilterLen > 0) then
					pagination:SetPages(pagination:GetPage())
				end

				GAS.Logging.Menu.DamageLogs.NoData:SetVisible(true)

				local cl_time = math.Round(SysTime() - time_taken_SysTime, 2)
				if (cl_time >= 1) then
					cl_time = cl_time .. "s"
				else
					cl_time = cl_time * 1000 .. "ms"
				end

				time_taken:SetText("cl " .. cl_time)
				time_taken:SizeToContents()
			end
		end)
	end

	time_taken = vgui.Create("DLabel", ModuleFrame.logs_content)
	time_taken:SetText("")
	time_taken:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	bVGUI.AttachTooltip(time_taken, {Text = L"cl_sv_tooltip"})

	function ModuleFrame.logs_content:PerformLayout()
		time_taken:AlignRight(7)
		time_taken:AlignTop(4)
		if (not self.StoreX or not self.StoreY or self.StoreX ~= self:GetWide() or self.StoreY ~= self:GetTall()) then
			self.StoreX = self:GetWide()
			self.StoreY = self:GetTall()

			GAS.Logging.Menu.SearchTab:AlignRight(10)
			if (GAS.Logging.Menu.QuickSearch.Open) then
				GAS.Logging.Menu.SearchTab:AlignBottom(pagination_container:GetTall() + GAS.Logging.Menu.QuickSearch:GetTall())
				GAS.Logging.Menu.QuickSearch:AlignBottom(pagination_container:GetTall())
			else
				GAS.Logging.Menu.SearchTab:AlignBottom(pagination_container:GetTall())
				GAS.Logging.Menu.QuickSearch:AlignBottom(pagination_container:GetTall() - GAS.Logging.Menu.QuickSearch:GetTall())
			end
		end
	end

	--############# DAMAGE LOGS #############--

	GAS.Logging.Menu.DamageLogs = vgui.Create("bVGUI.LoadingScrollPanel", ModuleFrame.logs_content)
	GAS.Logging.Menu.DamageLogs:Dock(FILL)
	GAS.Logging.Menu.DamageLogs:SetMouseInputEnabled(true)
	GAS.Logging.Menu.DamageLogs.Filter = {}
	GAS.Logging.Menu.DamageLogs.FilterLen = 0

	GAS.Logging.Menu.DamageLogs.Padding = vgui.Create("bVGUI.BlankPanel", ModuleFrame.logs_content)
	GAS.Logging.Menu.DamageLogs.Padding:Dock(TOP)
	GAS.Logging.Menu.DamageLogs.Padding:SetTall(24)
	GAS.Logging.Menu.DamageLogs.Padding:SetVisible(false)
	function GAS.Logging.Menu.DamageLogs.Padding:Paint(w,h)
		surface.SetDrawColor(51,80,114)
		surface.DrawRect(0,0,w,h - 1)

		surface.SetDrawColor(31,48,68)
		surface.DrawLine(0,h - 1,w,h - 1)
	end

	GAS.Logging.Menu.DamageLogs.NoData = vgui.Create("DLabel", ModuleFrame.logs_content)
	GAS.Logging.Menu.DamageLogs.NoData:Dock(FILL)
	GAS.Logging.Menu.DamageLogs.NoData:SetMouseInputEnabled(false)
	GAS.Logging.Menu.DamageLogs.NoData:SetText(L"no_data")
	GAS.Logging.Menu.DamageLogs.NoData:SetTextColor(bVGUI.COLOR_WHITE)
	GAS.Logging.Menu.DamageLogs.NoData:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	GAS.Logging.Menu.DamageLogs.NoData:SetContentAlignment(5)
	GAS.Logging.Menu.DamageLogs.NoData:SetVisible(false)

	GAS.Logging.Menu.DamageLogs.SearchPanel = vgui.Create("bVGUI.BlankPanel", ModuleFrame.logs_content)
	GAS.Logging.Menu.DamageLogs.SearchPanel:SetWide(0)
	GAS.Logging.Menu.DamageLogs.SearchPanel:DockPadding(10,10,10,10)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Open = false
	function GAS.Logging.Menu.DamageLogs.SearchPanel:Paint(w,h)
		self:SetSize(175, ModuleFrame.logs_content:GetTall() - 30 - 24)
		self:SetPos(ModuleFrame:GetWide() - w, 24)
		surface.SetDrawColor(19,19,19,255)
		surface.DrawRect(0,0,w,h)
	end
	function GAS.Logging.Menu.DamageLogs.SearchPanel:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,150)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(0,0,10,h)
	end

	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter = vgui.Create("bVGUI.Button", GAS.Logging.Menu.DamageLogs.SearchPanel)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:SetText(L"clear_filter")
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:SetColor(bVGUI.BUTTON_COLOR_RED)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:SetDisabled(true)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:SetTall(30)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:Dock(TOP)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:DockMargin(0,0,0,10)
	function GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:DoClick()
		GAS.Logging.Menu.DamageLogs.Filter = {}
		GAS.Logging.Menu.DamageLogs.FilterLen = 0
		self:SetDisabled(true)
		GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetDisabled(true)
		LoadDamageLogs()
		for _,v in ipairs(GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer.CheckboxItems) do
			if (v.checkbox:GetChecked()) then
				GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetDisabled(false)
				break
			end
		end
	end

	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply = vgui.Create("bVGUI.Button", GAS.Logging.Menu.DamageLogs.SearchPanel)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetText(L"apply_filter")
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetDisabled(true)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetTall(30)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:Dock(TOP)
	GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:DockMargin(0,0,0,10)
	function GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:DoClick()
		GAS.Logging.Menu.DamageLogs.Filter = {}
		GAS.Logging.Menu.DamageLogs.FilterLen = 0
		for _,v in ipairs(GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer.CheckboxItems) do
			if (v.checkbox:GetChecked()) then
				GAS.Logging.Menu.DamageLogs.Filter[v.AccountID] = true
				GAS.Logging.Menu.DamageLogs.FilterLen = GAS.Logging.Menu.DamageLogs.FilterLen + 1
			end
		end
		GAS.Logging.Menu.DamageLogs.SearchPanel.ClearFilter:SetDisabled(false)
		self:SetDisabled(true)
		LoadDamageLogs()
	end

	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID = vgui.Create("bVGUI.Button", GAS.Logging.Menu.DamageLogs.SearchPanel)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:SetText(L"manual_steamid_ellipsis")
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:SetTall(30)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:Dock(TOP)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:DockMargin(0,0,0,10)
	GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID.AccountIDs = {}
	function GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID:DoClick()
		GAS.SelectionPrompts:PromptAccountID(function(accountid)
			if (table.HasValue(GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID.AccountIDs, accountid)) then return end
			GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID.AccountIDs[#GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID.AccountIDs + 1] = accountid
			GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer:Refresh()
		end)
	end

	GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer = vgui.Create("bVGUI.ScrollPanel", GAS.Logging.Menu.DamageLogs.SearchPanel)
	GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer:Dock(FILL)
	GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer.CheckboxItems = {}
	function GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer:Refresh()
		local this = self
		local plys = {}
		for _,ply in ipairs(player.GetHumans()) do
			plys[#plys + 1] = {accountid = ply:AccountID(), name = ply:Nick()}
		end
		for _,accountid in ipairs(GAS.Logging.Menu.DamageLogs.SearchPanel.ManualSteamID.AccountIDs) do
			plys[#plys + 1] = {accountid = accountid, name = GAS:AccountIDToSteamID(accountid)}
		end
		table.SortByMember(plys, "name", true)
		for i,v in ipairs(plys) do
			if (self.CheckboxItems[i] == nil or self.CheckboxItems[i].AccountID ~= v.accountid) then
				local checkbox_item = vgui.Create("bVGUI.BlankPanel", self)
				checkbox_item:Dock(TOP)
				checkbox_item:DockPadding(0,0,0,10)
				checkbox_item:SetTall(28)
				checkbox_item.AccountID = v.accountid
				checkbox_item:SetCursor("hand")
				checkbox_item:SetMouseInputEnabled(true)
				function checkbox_item:OnMouseReleased(m)
					if (m == MOUSE_RIGHT) then
						bVGUI.PlayerTooltip.Focus()
					else
						checkbox_item.checkbox:OnMouseReleased(MOUSE_LEFT)
					end
				end

				bVGUI.PlayerTooltip.Attach(checkbox_item, {
					account_id = checkbox_item.AccountID,
					creator = checkbox_item,
					focustip = L"right_click_to_focus"
				})

				checkbox_item.checkbox = vgui.Create("bVGUI.Checkbox", checkbox_item)
				checkbox_item.checkbox:Dock(LEFT)
				checkbox_item.checkbox:DockMargin(0,0,10,0)
				function checkbox_item.checkbox:OnChange()
					local checked = false
					for _,v in ipairs(this.CheckboxItems) do
						if (v.checkbox:GetChecked()) then
							checked = true
						end
						if (GAS.Logging.Menu.DamageLogs.Filter[v.AccountID] ~= (self:GetChecked() or nil)) then
							GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetDisabled(false)
							if (checked) then break end
						end
					end
					if (not checked) then
						GAS.Logging.Menu.DamageLogs.SearchPanel.Apply:SetDisabled(true)
					end
				end

				checkbox_item.label = vgui.Create("DLabel", checkbox_item)
				checkbox_item.label:Dock(FILL)
				checkbox_item.label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
				checkbox_item.label:SetTextColor(bVGUI.COLOR_WHITE)
				checkbox_item.label:SetContentAlignment(4)
				checkbox_item.label:SetText(v.name)

				checkbox_item.avatar = vgui.Create("AvatarImage", checkbox_item)
				checkbox_item.avatar:Dock(RIGHT)
				checkbox_item.avatar:DockMargin(10,0,10,0)
				checkbox_item.avatar:SetSize(18,18)
				checkbox_item.avatar:SetSteamID(GAS:AccountIDToSteamID64(checkbox_item.AccountID), 16)
				checkbox_item.avatar:SetMouseInputEnabled(false)
				
				table.insert(self.CheckboxItems, i, checkbox_item)
			else
				self.CheckboxItems[i].label:SetText(v.name)
			end
			if (IsValid(self.CheckboxItems[i + 1])) then self.CheckboxItems[i]:MoveToBefore(self.CheckboxItems[i + 1]) end
		end
		self.pnlCanvas:InvalidateLayout()
		self:InvalidateLayout()
	end

	GAS.Logging.Menu.DamageLogs.CurrentPage = 1

	--############# ADVANCED SEARCH #############--

	ModuleFrame.AdvancedSearch = vgui.Create("bVGUI.BlankPanel", ModuleFrame.logs_content)
	ModuleFrame.AdvancedSearch:Dock(FILL)
	ModuleFrame.AdvancedSearch:SetVisible(false)

	ModuleFrame.AdvancedSearch.Image = vgui.Create("DImage", ModuleFrame.AdvancedSearch)
	ModuleFrame.AdvancedSearch.Image:SetSize(64,64)
	ModuleFrame.AdvancedSearch.Image:SetMaterial(search_mat)

	ModuleFrame.AdvancedSearch.Button = vgui.Create("bVGUI.Button", ModuleFrame.AdvancedSearch)
	ModuleFrame.AdvancedSearch.Button:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	ModuleFrame.AdvancedSearch.Button:SetText(L"tutorial")
	ModuleFrame.AdvancedSearch.Button:SetSize(125,30)
	function ModuleFrame.AdvancedSearch.Button:DoClick()
		GAS:OpenURL("https://gmodsto.re/blogs-advancedsearch-help")
	end

	ModuleFrame.AdvancedSearch.Greedy = vgui.Create("bVGUI.Switch", ModuleFrame.AdvancedSearch)
	ModuleFrame.AdvancedSearch.Greedy:SetChecked(true)
	ModuleFrame.AdvancedSearch.Greedy:SetText(L"greedy")
	bVGUI.AttachTooltip(ModuleFrame.AdvancedSearch.Greedy.ClickableArea, {Text = L"greedy_tip"})

	ModuleFrame.AdvancedSearch.Filters = vgui.Create("DPanel", ModuleFrame.AdvancedSearch)
	ModuleFrame.AdvancedSearch.Filters:SetSize(600,275)
	function ModuleFrame.AdvancedSearch.Filters:Paint(w,h)
		surface.SetDrawColor(39,43,53,255)
		surface.DrawRect(0,0,w,h)

		surface.SetDrawColor(255,255,255,200)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)

		surface.SetDrawColor(0,0,0,150)
		local children_num = #self.Headers:GetChildren()
		local h_w = w / children_num
		for i=1,#self.Headers:GetChildren() do
			surface.DrawLine((i * h_w) - 1, 0, (i * h_w) - 1, h)
		end
	end

	function ModuleFrame.AdvancedSearch:Paint(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(advancedsearch_dropshadow)
		local x,y = self.Filters:GetPos()
		surface.DrawTexturedRect(x - 10, y - 10, 1024, 1024)
	end

	ModuleFrame.AdvancedSearch.Filters.Headers = vgui.Create("bVGUI.BlankPanel", ModuleFrame.AdvancedSearch.Filters)
	ModuleFrame.AdvancedSearch.Filters.Headers:Dock(TOP)
	ModuleFrame.AdvancedSearch.Filters.Headers:SetTall(24)
	function ModuleFrame.AdvancedSearch.Filters.Headers:PerformLayout()
		local w = self:GetWide() / #self:GetChildren()
		local accumulative_w = 0
		for _,child in ipairs(self:GetChildren()) do
			child:SetWide(w)
			child:AlignLeft(accumulative_w)
			accumulative_w = accumulative_w + w
		end
	end

	ModuleFrame.AdvancedSearch.Filters.Buttons = vgui.Create("bVGUI.BlankPanel", ModuleFrame.AdvancedSearch.Filters)
	ModuleFrame.AdvancedSearch.Filters.Buttons:Dock(BOTTOM)
	ModuleFrame.AdvancedSearch.Filters.Buttons:SetTall(25)
	ModuleFrame.AdvancedSearch.Filters.Buttons:DockMargin(0,0,0,10)
	function ModuleFrame.AdvancedSearch.Filters.Buttons:PerformLayout()
		local w = self:GetWide() / #self:GetChildren()
		local accumulative_w = 0
		for _,child in ipairs(self:GetChildren()) do
			child:SetWide(w - 20)
			child:AlignLeft(accumulative_w + 10)
			accumulative_w = accumulative_w + w
		end
	end

	ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems = vgui.Create("bVGUI.BlankPanel", ModuleFrame.AdvancedSearch.Filters)
	ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:Dock(FILL)
	ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.Items = {{},{},{},{}}
	ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.Contents = {}
	function ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(index, item)
		item.SearchIndex = index
		if (self.Items[index][item:GetValue()]) then
			item:Remove()
		else
			self.Items[index][item:GetValue()] = item
			self:Update()
		end
	end
	function ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:RemoveItem(item)
		self.Items[item.SearchIndex][item:GetValue()] = nil
		item:Remove()
		self:Update()
	end
	function ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:Update()
		for _,items in ipairs(self.Items) do
			for i in pairs(items) do
				ModuleFrame.AdvancedSearch.Filters.ClearButton:SetDisabled(false)
				ModuleFrame.AdvancedSearch.Filters.DoSearch:SetDisabled(false)
				advanced_search_category_item:SetForcedActive(GAS.Logging.Menu.LogsTable.Filters ~= nil)
				return
			end
		end
		GAS.Logging.Menu.LogsTable.Filters = nil
		ModuleFrame.AdvancedSearch.Filters.ClearButton:SetDisabled(true)
		ModuleFrame.AdvancedSearch.Filters.DoSearch:SetDisabled(true)
		advanced_search_category_item:SetForcedActive(false)
	end
	function ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:GetFilters()
		local all_filters = {}
		for filter_i,filters in ipairs(self.Items) do
			all_filters[filter_i] = {}
			for i,item in pairs(filters) do
				all_filters[filter_i][i] = true
			end
		end
		return all_filters
	end

	function ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:PerformLayout()
		local w = self:GetWide() / #self:GetChildren()
		local accumulative_w = 0
		for _,child in ipairs(self:GetChildren()) do
			child:SetSize(w, self:GetTall())
			child:AlignLeft(accumulative_w)
			accumulative_w = accumulative_w + w
		end
	end

	ModuleFrame.AdvancedSearch.Filters.Categories = {}
	for i,v in ipairs({
		{
			label = L"modules",
			btn = L"add_module",
			color = Color(135,0,135),
			tooltip = L"modules_search_tooltip",
			func = function(content, col)
				GAS:PlaySound("btn_light")
				local is_operator = OpenPermissions:IsOperator(LocalPlayer())
				local menu = DermaMenu()
				for category_name, modules in pairs(GAS.Logging.Modules) do
					if (GAS:table_IsEmpty(modules)) then continue end
					local category_submenu, category_option
					local colored_the_icon = false
					for module_name, module_data in pairs(modules) do
						if (not is_operator and OpenPermissions:GetPermission(LocalPlayer(), "gmodadminsuite_logging/" .. category_name .. "/" .. module_name) == OpenPermissions.CHECKBOX.CROSSED) then continue end
						if (not category_submenu) then
							category_submenu, category_option = menu:AddSubMenu(category_name)
						end
						if (not colored_the_icon) then
							colored_the_icon = true
							bVGUI_DermaMenuOption_ColorIcon(category_option, module_data.Colour)
						end
						bVGUI_DermaMenuOption_ColorIcon(category_submenu:AddOption(module_name, function()
							GAS:PlaySound("btn_heavy")
							local item = vgui.Create("GAS.Logging.AdvancedSearchItem", content)
							item:SetValue(module_data.ModuleID)
							item:SetText(category_name .. " ➞ " .. module_name)
							item:SetColor(module_data.Colour)
							ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(1, item)
						end), module_data.Colour)
					end
				end
				menu:Open()
			end,
		},
		{
			label = L"players",
			btn = L"add_player",
			color = bVGUI.COLOR_GMOD_BLUE,
			tooltip = L"players_search_tooltip",
			func = function(content)
				GAS.SelectionPrompts:PromptAccountID(function(account_id, ply)
					local item = vgui.Create("GAS.Logging.AdvancedSearchItem", content)
					item:SetAccountID(account_id)
					item:SetValue(tostring(account_id))
					if (IsValid(ply)) then
						item:SetText(ply:Nick())
						item:SetColor(team.GetColor(ply:Team()))
					else
						item:SetText(GAS:AccountIDToSteamID(account_id))
					end
					ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(2, item)
				end)
			end,
		},
		{
			label = L"entities",
			btn = L"add_entity",
			color = Color(255,120,0),
			tooltip = L"entities_search_tooltip",
			func = function(content, col)
				GAS:PlaySound("popup")
				GAS.Logging:ShowClassSelector(content)
	
				ModuleFrame.CloseFrames = ModuleFrame.CloseFrames or {}
				ModuleFrame.CloseFrames[GAS.Logging.ClassSelector] = true
			end,
		},
		{
			label = L"strings",
			btn = L"add_string",
			color = Color(76,216,76),
			tooltip = L"strings_search_tooltip",
			func = function(content, col)
				GAS:PlaySound("popup")
				
				ModuleFrame.CloseFrames = ModuleFrame.CloseFrames or {}
				ModuleFrame.CloseFrames[
					bVGUI.StringQuery(L"add_string_popup_title", L"add_string_popup_text", L"text_ellipsis", function(str)
						local item = vgui.Create("GAS.Logging.AdvancedSearchItem", content)
						item:SetValue(str)
						item:SetColor(col)
						ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(4, item)
					end)
				] = true
			end,
		},
	}) do
		local header = vgui.Create("bVGUI.Header", ModuleFrame.AdvancedSearch.Filters.Headers)
		header:SetText(v.label)
		header:SetColor(v.color)

		local content = vgui.Create("bVGUI.ScrollPanel", ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems)
		ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.Contents[i] = content
		content.pnlCanvas:DockPadding(5,5,10,5)

		if (i == 2) then
			ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.PlayerPnl = content
		end

		function content.pnlCanvas:RemoveItem(item)
			ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:RemoveItem(item)
		end

		local button = vgui.Create("bVGUI.Button", ModuleFrame.AdvancedSearch.Filters.Buttons)
		button:SetTall(25)
		button:SetText(v.btn)
		button:SetColor(v.color)
		if (v.func) then
			function button:DoClick()
				v.func(content, v.color)
			end
		end

		if (v.tooltip) then
			button:SetTooltip({
				Text = v.tooltip,
				VGUI_Element = button
			})
			function header:OnCursorEntered()
				bVGUI.CreateTooltip({
					Text = v.tooltip,
					VGUI_Element = self
				})
			end
			function header:OnCursorExit()
				bVGUI.DestroyTooltip()
			end
		end
	end

	ModuleFrame.AdvancedSearch.Actions = vgui.Create("bVGUI.BlankPanel", ModuleFrame.AdvancedSearch)
	ModuleFrame.AdvancedSearch.Actions:SetSize(125 + 15 + 125, 30)

	ModuleFrame.AdvancedSearch.Filters.ClearButton = vgui.Create("bVGUI.Button", ModuleFrame.AdvancedSearch.Actions)
	ModuleFrame.AdvancedSearch.Filters.ClearButton:SetSize(125,30)
	ModuleFrame.AdvancedSearch.Filters.ClearButton:SetColor(bVGUI.BUTTON_COLOR_RED)
	ModuleFrame.AdvancedSearch.Filters.ClearButton:SetText(L"clear_filters")
	ModuleFrame.AdvancedSearch.Filters.ClearButton:SetDisabled(true)
	function ModuleFrame.AdvancedSearch.Filters.ClearButton:DoClick()
		GAS:PlaySound("flash")
		GAS.Logging.Menu.LogsTable.Filters = nil
		self:SetDisabled(true)
		for _,filters in ipairs(ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.Items) do
			for _,filter in pairs(filters) do
				filter:Remove()
			end
		end
		ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.Items = {{},{},{},{}}
		ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:Update()
	end

	ModuleFrame.AdvancedSearch.Filters.DoSearch = vgui.Create("bVGUI.Button", ModuleFrame.AdvancedSearch.Actions)
	ModuleFrame.AdvancedSearch.Filters.DoSearch:SetSize(125,30)
	ModuleFrame.AdvancedSearch.Filters.DoSearch:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	ModuleFrame.AdvancedSearch.Filters.DoSearch:SetText(L"advanced_search")
	ModuleFrame.AdvancedSearch.Filters.DoSearch:SetDisabled(true)
	bVGUI.AttachTooltip(ModuleFrame.AdvancedSearch.Filters.DoSearch, {Text = L"deep_storage_advanced_search_warning"})
	function ModuleFrame.AdvancedSearch.Filters.DoSearch:DoClick()
		GAS:PlaySound("success")

		damage_logs_mode = false
		GAS.Logging.Menu.LogsTable.CurrentPage = 1
		GAS.Logging.Menu.LogsTable.ModuleID = false
		GAS.Logging.Menu.LogsTable.Filters = GAS.Logging.Menu.AdvancedSearch.Filters.AdvancedSearchItems:GetFilters() or nil

		advanced_search_category_item:SetForcedActive(true)
		LoadLogs()
	end

	function ModuleFrame.AdvancedSearch.Actions:PerformLayout()
		local w = ModuleFrame.AdvancedSearch.Filters.ClearButton:GetWide() + ModuleFrame.AdvancedSearch.Filters.DoSearch:GetWide() + 15
		ModuleFrame.AdvancedSearch.Filters.ClearButton:AlignLeft(self:GetWide() / 2 - w / 2)
		ModuleFrame.AdvancedSearch.Filters.DoSearch:AlignLeft(self:GetWide() / 2 - w / 2 + ModuleFrame.AdvancedSearch.Filters.ClearButton:GetWide() + 15)
	end

	function ModuleFrame.AdvancedSearch:PerformLayout()
		local x,y = self:GetSize()
		x = x / 2
		y = y / 2
		local h = self.Image:GetTall() + 20 + self.Button:GetTall() + 20 + self.Greedy:GetTall() + 20 + self.Filters:GetTall() + 20 + self.Actions:GetTall()

		self.Image:SetPos(x - self.Image:GetWide() / 2, y - h / 2)
		self.Button:SetPos(x - self.Button:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20)
		self.Greedy:SetPos(x - self.Greedy:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20 + self.Button:GetTall() + 20)
		self.Filters:SetPos(x - self.Filters:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20 + self.Button:GetTall() + 20 + self.Greedy:GetTall() + 20)
		self.Actions:SetPos(x - self.Actions:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20 + self.Button:GetTall() + 20 + self.Greedy:GetTall() + 20 + self.Filters:GetTall() + 20)
	end

	--############# DEEP STORAGE #############--

	ModuleFrame.DeepStorage = vgui.Create("bVGUI.BlankPanel", ModuleFrame.logs_content)
	ModuleFrame.DeepStorage:Dock(FILL)
	ModuleFrame.DeepStorage:SetVisible(false)

	ModuleFrame.DeepStorage.Image = vgui.Create("DImage", ModuleFrame.DeepStorage)
	ModuleFrame.DeepStorage.Image:SetSize(64,64)
	ModuleFrame.DeepStorage.Image:SetMaterial(database_mat)

	ModuleFrame.DeepStorage.Text = vgui.Create("DLabel", ModuleFrame.DeepStorage)
	ModuleFrame.DeepStorage.Text:SetText(L"deep_storage_help")
	ModuleFrame.DeepStorage.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	ModuleFrame.DeepStorage.Text:SetContentAlignment(8)
	ModuleFrame.DeepStorage.Text:SetSize(400,0)
	ModuleFrame.DeepStorage.Text:SetWrap(true)
	ModuleFrame.DeepStorage.Text:SetAutoStretchVertical(true)

	ModuleFrame.DeepStorage.ButtonContainer = vgui.Create("bVGUI.BlankPanel", ModuleFrame.DeepStorage)
	ModuleFrame.DeepStorage.ButtonContainer:SetSize(125 + 125 + 10, 30)

	ModuleFrame.DeepStorage.Button = vgui.Create("bVGUI.Button", ModuleFrame.DeepStorage.ButtonContainer)
	ModuleFrame.DeepStorage.Button:SetText(L"view_deep_storage")
	ModuleFrame.DeepStorage.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	ModuleFrame.DeepStorage.Button:SetSize(125,30)
	function ModuleFrame.DeepStorage.Button:DoClick()
		if (GAS.Logging.Menu.LogsTable.DeepStorage == false) then
			GAS.Logging.Menu.LogsTable.DeepStorage = true
			ModuleFrame.DeepStorage.Button:SetColor(bVGUI.BUTTON_COLOR_RED)
			ModuleFrame.DeepStorage.Button:SetText(L"exit_deep_storage")
			bVGUI.UnattachTooltip(ModuleFrame.AdvancedSearch.Filters.DoSearch)
			GAS:PlaySound("btn_on")
		else
			GAS.Logging.Menu.LogsTable.DeepStorage = false
			ModuleFrame.DeepStorage.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
			ModuleFrame.DeepStorage.Button:SetText(L"view_deep_storage")
			bVGUI.AttachTooltip(ModuleFrame.AdvancedSearch.Filters.DoSearch, {Text = L"deep_storage_advanced_search_warning"})
			GAS:PlaySound("btn_off")
		end
		deep_storage_category_item:SetForcedActive(GAS.Logging.Menu.LogsTable.DeepStorage)
	end

	ModuleFrame.DeepStorage.LearnMore = vgui.Create("bVGUI.Button", ModuleFrame.DeepStorage.ButtonContainer)
	ModuleFrame.DeepStorage.LearnMore:SetText(L"learn_more")
	ModuleFrame.DeepStorage.LearnMore:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	ModuleFrame.DeepStorage.LearnMore:SetSize(125,30)
	function ModuleFrame.DeepStorage.LearnMore:DoClick()
		GAS:OpenURL("https://gmodsto.re/blogs-deepstorage-help")
	end

	function ModuleFrame.DeepStorage.ButtonContainer:PerformLayout()
		ModuleFrame.DeepStorage.Button:SetPos(self:GetWide() / 2 - ModuleFrame.DeepStorage.Button:GetWide() - 5, 0)
		ModuleFrame.DeepStorage.LearnMore:SetPos(self:GetWide() / 2 + 5, 0)
	end

	function ModuleFrame.DeepStorage:PerformLayout()
		local x,y = self:GetSize()
		x = x / 2
		y = y / 2
		local h = self.Image:GetTall() + 20 + self.Text:GetTall() + 20 + self.Button:GetTall()

		self.Image:SetPos(x - self.Image:GetWide() / 2, y - h / 2)
		self.Text:SetPos(x - self.Text:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20)
		self.ButtonContainer:SetPos(x - self.ButtonContainer:GetWide() / 2, y - h / 2 + self.Image:GetTall() + 20 + self.Text:GetTall() + 20)
	end

	--############# SETTINGS TAB #############--

	local settings_content = ModuleFrame.Tabs:AddTab(L"settings", Color(75,75,216))
	local settings_tabs = vgui.Create("bVGUI.Tabs", settings_content)
	settings_tabs:Dock(TOP)
	settings_tabs:SetTall(40)

	local info_content = settings_tabs:AddTab(L"module_name", Color(216,75,75))
	info_content.Logo = vgui.Create("DImage", info_content)
	info_content.Logo:SetMaterial(logo_mat)
	info_content.Logo:SetSize(256,256)

	info_content.ScriptPage = vgui.Create("bVGUI.Button", info_content)
	info_content.ScriptPage:SetText(L"script_page")
	info_content.ScriptPage:SetColor(bVGUI.BUTTON_COLOR_RED)
	info_content.ScriptPage:SetSize(150,30)
	function info_content.ScriptPage:DoClick()
		GAS:OpenURL("https://gmodsto.re/blogs")
	end

	info_content.Wiki = vgui.Create("bVGUI.Button", info_content)
	info_content.Wiki:SetText(L"wiki")
	info_content.Wiki:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	info_content.Wiki:SetSize(150,30)
	function info_content.Wiki:DoClick()
		GAS:OpenURL("https://gmodsto.re/blogs-wiki")
	end

	info_content.Discord = vgui.Create("bVGUI.Button", info_content)
	info_content.Discord:SetText("Discord")
	info_content.Discord:SetColor(Color(114, 137, 218))
	info_content.Discord:SetSize(150,30)
	function info_content.Discord:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
	end

	function info_content:PerformLayout()
		local h = (self:GetTall() - 110 - 256 - 20) / 2
		self.Logo:SetPos((self:GetWide() - self.Logo:GetWide()) / 2, h)
		self.ScriptPage:SetPos((self:GetWide() - self.ScriptPage:GetWide()) / 2, h + ((256 + 145) / 2) + 20)
		self.Wiki:SetPos((self:GetWide() - self.Wiki:GetWide()) / 2, h + ((256 + 145) / 2) + 20 + 30 + 10)
		self.Discord:SetPos((self:GetWide() - self.Discord:GetWide()) / 2, h + ((256 + 145) / 2) + 20 + 30 + 10 + 30 + 10)
	end

	local livelogs_tab_content, livelogs_tab = settings_tabs:AddTab(L"livelogs", Color(75,216,75), OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite_logging/see_live_logs"))
	local livelogs_content

	local function LiveLogsSettings()
		if (IsValid(livelogs_content)) then
			if (IsValid(livelogs_content.btncontainer)) then
				livelogs_content.btncontainer:Remove()
			end
			livelogs_content:Remove()
		end

		livelogs_content = vgui.Create("bVGUI.ScrollPanel", livelogs_tab_content)
		livelogs_content:Dock(FILL)

		livelogs_content.btncontainer = vgui.Create("bVGUI.BlankPanel", livelogs_tab_content)
		livelogs_content.btncontainer:Dock(BOTTOM)
		livelogs_content.btncontainer:SetTall(50)
		function livelogs_content.btncontainer:Paint(w,h)
			surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
			surface.DrawRect(0,0,w,h)
			surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
			surface.DrawTexturedRect(0,0,w,h)
		end
		
		local livelogs_help = vgui.Create("bVGUI.Button", livelogs_content.btncontainer)
		livelogs_help:SetColor(bVGUI.BUTTON_COLOR_GREEN)
		livelogs_help:SetText(L"help")
		livelogs_help:SetSize(150,30)
		livelogs_help.DoClick = function()
			GAS:OpenURL("https://gmodsto.re/blogs-livelogs-help")
		end
		
		local livelogs_defaults = vgui.Create("bVGUI.Button", livelogs_content.btncontainer)
		livelogs_defaults:SetColor(bVGUI.BUTTON_COLOR_RED)
		livelogs_defaults:SetText(L"reset_to_defaults")
		livelogs_defaults:SetSize(150,30)
		livelogs_defaults.DoClick = function()
			GAS:PlaySound("success")
			bVGUI.MouseInfoTooltip.Create(L"done_exclamation")
			GAS.Logging.LiveLogs_Config = table.Copy(GAS.Logging.LiveLogs_DefaultConfig)
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_DefaultConfig)
			LiveLogsSettings()
		end

		function livelogs_content.btncontainer:PerformLayout()
			local w = (self:GetWide() - livelogs_help:GetWide() - 10 - livelogs_defaults:GetWide()) / 2
			livelogs_help:SetPos(w, (self:GetTall() - livelogs_help:GetTall()) / 2)
			livelogs_defaults:SetPos(w + livelogs_help:GetWide() + 10, (self:GetTall() - livelogs_defaults:GetTall()) / 2)
		end

		local livelogs_enabled = vgui.Create("bVGUI.Switch", livelogs_content)
		livelogs_enabled:Dock(TOP)
		livelogs_enabled:DockMargin(10,10,10,10)
		livelogs_enabled:SetText(L"livelogs_enabled")
		livelogs_enabled:SetChecked(GAS.Logging.LiveLogs_Config.enabled)
		function livelogs_enabled:OnChange()
			GAS.Logging.LiveLogs_Config.enabled = self:GetChecked()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
			if (self:GetChecked()) then
				GAS.Logging:OpenLiveLogs()
			else
				if (IsValid(GAS_Logging_LiveLogs)) then
					GAS_Logging_LiveLogs:Remove()
				end
				GAS:netStart("logging:LiveLogs")
					net.WriteBool(false)
				net.SendToServer()
			end
		end
		
		local livelogs_color = vgui.Create("bVGUI.Switch", livelogs_content)
		livelogs_color:Dock(TOP)
		livelogs_color:DockMargin(10,0,10,10)
		livelogs_color:SetText(L"color")
		livelogs_color:SetHelpText(L"livelogs_color_help")
		livelogs_color:SetChecked(GAS.Logging.LiveLogs_Config.color)
		function livelogs_color:OnChange()
			GAS.Logging.LiveLogs_Config.color = self:GetChecked()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_rows = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_rows:Dock(TOP)
		livelogs_rows:DockMargin(10,0,10,10)
		livelogs_rows:SetText(L"livelogs_rows")
		livelogs_rows:SetHelpText(L"livelogs_rows_help")
		livelogs_rows.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.rows)
		livelogs_rows.NumberWang:SetDecimals(0)
		livelogs_rows.NumberWang:SetMin(1)
		livelogs_rows.NumberWang:SetMax(100)
		function livelogs_rows.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.rows = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_show_logs_for = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_show_logs_for:Dock(TOP)
		livelogs_show_logs_for:DockMargin(10,0,10,10)
		livelogs_show_logs_for:SetText(L"livelogs_show_logs_for")
		livelogs_show_logs_for:SetHelpText(L"livelogs_show_logs_for_help")
		livelogs_show_logs_for.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.y)
		livelogs_show_logs_for.NumberWang:SetDecimals(0)
		livelogs_show_logs_for.NumberWang:SetMin(0)
		function livelogs_show_logs_for.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.show_logs_for = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_width = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_width:Dock(TOP)
		livelogs_width:DockMargin(10,0,10,10)
		livelogs_width:SetText(L"width")
		livelogs_width.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.width)
		livelogs_width.NumberWang:SetDecimals(0)
		livelogs_width.NumberWang:SetMin(1)
		livelogs_width.NumberWang:SetMax(ScrW())
		function livelogs_width.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.width = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_padding = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_padding:Dock(TOP)
		livelogs_padding:DockMargin(10,0,10,10)
		livelogs_padding:SetText(L"padding")
		livelogs_padding.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.padding)
		livelogs_padding.NumberWang:SetDecimals(0)
		livelogs_padding.NumberWang:SetMin(0)
		function livelogs_padding.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.padding = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_position_x = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_position_x:Dock(TOP)
		livelogs_position_x:DockMargin(10,0,10,10)
		livelogs_position_x:SetText(L"livelogs_position_x")
		livelogs_position_x.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.x)
		livelogs_position_x.NumberWang:SetDecimals(0)
		livelogs_position_x.NumberWang:SetMin(0)
		livelogs_position_x.NumberWang:SetMax(ScrW())
		function livelogs_position_x.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.x = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local livelogs_position_y = vgui.Create("bVGUI.NumberWang", livelogs_content)
		livelogs_position_y:Dock(TOP)
		livelogs_position_y:DockMargin(10,0,10,10)
		livelogs_position_y:SetText(L"livelogs_position_y")
		livelogs_position_y.NumberWang:SetValue(GAS.Logging.LiveLogs_Config.y)
		livelogs_position_y.NumberWang:SetDecimals(0)
		livelogs_position_y.NumberWang:SetMin(0)
		livelogs_position_y.NumberWang:SetMax(ScrH())
		function livelogs_position_y.NumberWang:OnValueChanged()
			GAS.Logging.LiveLogs_Config.y = self:GetValue()
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local background_color = vgui.Create("bVGUI.ColorMixer", livelogs_content)
		background_color:Dock(TOP)
		background_color:DockMargin(10,0,10,0)
		background_color:SetTall(150)
		background_color:SetColor(GAS.Logging.LiveLogs_Config.bgcolor)
		background_color:SetLabel(L"background_color")
		function background_color.ColorMixer:ValueChanged(col)
			GAS.Logging.LiveLogs_Config.bgcolor = col
			GAS:SaveLocalConfig("logging_livelogs", GAS.Logging.LiveLogs_Config)
		end

		local padding = vgui.Create("bVGUI.BlankPanel", livelogs_content)
		padding:Dock(TOP)
		padding:SetTall(10)
	end
	livelogs_tab:SetFunction(LiveLogsSettings)

	local log_coloring_tab_content, log_coloring_tab = settings_tabs:AddTab(L"log_colouring", Color(75,75,216))
	local function LogColouringSettings()
		if (IsValid(log_coloring_tab_content.Content)) then log_coloring_tab_content.Content:Remove() end
		if (IsValid(log_coloring_tab_content.Reset)) then log_coloring_tab_content.Reset:Remove() end

		log_coloring_tab_content.Content = vgui.Create("bVGUI.Grid", log_coloring_tab_content)
		log_coloring_tab_content.Content:Dock(FILL)
		log_coloring_tab_content.Content:SetPadding(15,15)
		function log_coloring_tab_content.Content:Think()
			if (self.UpdateTimer ~= nil and self.UpdateTimer - CurTime() <= 0) then
				self.UpdateTimer = nil
				GAS:SaveLocalConfig("logging_log_formatting", GAS.Logging.LogFormattingSettings)
			end
		end

		log_coloring_tab_content.Reset = vgui.Create("bVGUI.BlankPanel", log_coloring_tab_content)
		local reset_to_defaults_c = log_coloring_tab_content.Reset
		reset_to_defaults_c:Dock(BOTTOM)
		reset_to_defaults_c:SetTall(50)
		function reset_to_defaults_c:Paint(w,h)
			surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
			surface.DrawRect(0,0,w,h)
			surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
			surface.DrawTexturedRect(0,0,w,h)
		end

		local reset_to_defaults = vgui.Create("bVGUI.Button", reset_to_defaults_c)
		reset_to_defaults:SetText(L"reset_to_defaults")
		reset_to_defaults:SetColor(bVGUI.BUTTON_COLOR_RED)
		reset_to_defaults:SetSize(150,30)
		function reset_to_defaults:DoClick()
			GAS:PlaySound("success")
			bVGUI.MouseInfoTooltip.Create(L"done_exclamation")
			GAS.Logging.LogFormattingSettings = table.Copy(GAS.Logging.LogFormattingSettings_Default)
			GAS:SaveLocalConfig("logging_log_formatting", GAS.Logging.LogFormattingSettings_Default)
			LogColouringSettings()
		end

		function reset_to_defaults_c:PerformLayout()
			reset_to_defaults:Center()
		end

		for _,v in ipairs({
			{
				label = L"highlight_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Highlight,
			},
			{
				label = L"weapon_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Weapon,
			},
			{
				label = L"money_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Money,
			},
			{
				label = L"vehicle_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Vehicle,
			},
			{
				label = L"entity_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Entity,
			},
			{
				label = L"health_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Health,
			},
			{
				label = L"armor_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Armor,
			},
			{
				label = L"usergroup_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Usergroup,
			},
			{
				label = L"unavailable_color",
				setting = GAS.Logging.LogFormattingSettings.Colors.Unavailable,
			},
		}) do
			local colormixer = vgui.Create("bVGUI.ColorMixer", log_coloring_tab_content.Content)
			colormixer:SetSize(250,150)
			colormixer:SetColor(v.setting)
			colormixer:SetLabel(v.label)
			function colormixer.ColorMixer:ValueChanged(col)
				v.setting.r = col.r
				v.setting.g = col.g
				v.setting.b = col.b
				log_coloring_tab_content.Content.UpdateTimer = CurTime() + .5
			end
			log_coloring_tab_content.Content:AddToGrid(colormixer)
		end
	end
	log_coloring_tab:SetFunction(LogColouringSettings)

	if (is_operator) then
		local operator_content, operator_tab = ModuleFrame.Tabs:AddTab(L"operator", Color(216,75,75))
		operator_tab:SetFunction(function()
			local save_btn_disabled = not IsValid(operator_content.save_btn) or operator_content.save_btn:GetDisabled()
			if (IsValid(operator_content.Content)) then operator_content.Content:Remove() end
			operator_content.Content = vgui.Create("bVGUI.BlankPanel", operator_content)
			operator_content.Content:Dock(FILL)

			local categories_container = vgui.Create("bVGUI.BlankPanel", operator_content.Content)
			categories_container:Dock(LEFT)
			categories_container:SetWide(175)

			local categories = vgui.Create("bVGUI.Categories", categories_container)
			categories:Dock(FILL)
			categories:SetWide(175)
			categories:SetLoading(true)

			local save_btn_container = vgui.Create("bVGUI.BlankPanel", categories_container)
			save_btn_container:Dock(BOTTOM)
			save_btn_container:SetTall(64)
			save_btn_container:DockPadding(7,0,7,7)
			function save_btn_container:Paint(w,h)
				surface.SetDrawColor(bVGUI.COLOR_SLATE)
				surface.DrawRect(0,0,w,h)
			end

			local permissions_btn = vgui.Create("bVGUI.Button", save_btn_container)
			permissions_btn:Dock(TOP)
			permissions_btn:DockMargin(0,0,0,7)
			permissions_btn:SetTall(25)
			permissions_btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
			permissions_btn:SetText(L"permissions")
			function permissions_btn:DoClick()
				GAS:PlaySound("flash")
				RunConsoleCommand("openpermissions", "gmodadminsuite_logging")
			end

			local save_btn = vgui.Create("bVGUI.Button", save_btn_container)
			operator_content.save_btn = save_btn
			save_btn:Dock(TOP)
			save_btn:SetText(L"save_settings")
			save_btn:SetColor(bVGUI.BUTTON_COLOR_RED)
			save_btn:SetSize(150,25)
			save_btn:SetDisabled(save_btn_disabled)

			function operator_content:PaintOver(w,h)
				surface.SetDrawColor(255,255,255,255)
				surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
				surface.DrawTexturedRect(categories:GetWide(),0,10,h)
			end

			local settings_content
			local function init_content()
				if (IsValid(settings_content)) then
					settings_content:Remove()
				end
				settings_content = vgui.Create("bVGUI.BlankPanel", operator_content.Content)
				settings_content:Dock(FILL)
			end

			local function OpenFilterEditor(filter_data, title, text, placeholder, callback)
				if (not IsValid(ModuleFrame)) then return end

				GAS:PlaySound("popup")

				local filter_editor = vgui.Create("bVGUI.Frame")

				ModuleFrame.CloseFrames = ModuleFrame.CloseFrames or {}
				ModuleFrame.CloseFrames[filter_editor] = true

				filter_editor:SetSize(250,300)
				filter_editor:SetTitle(title)
				filter_editor:MakePopup()
				filter_editor:Center()

				local filters = vgui.Create("bVGUI.Table", filter_editor)
				filters:Dock(FILL)
				filters:AddColumn(L"weapon_class")
				filters:SetRowCursor("hand")
				for weapon_class in pairs(filter_data) do
					filters:AddRow(weapon_class)
				end
				function filters:OnRowClicked(row)
					GAS:PlaySound("delete")
					filters:RemoveRow(row.RowIndex)
				end

				local save_btn_container = vgui.Create("bVGUI.BlankPanel", filter_editor)
				save_btn_container:Dock(BOTTOM)
				save_btn_container:SetTall(45)
				function save_btn_container:Paint(w,h)
					surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
					surface.DrawRect(0,0,w,h)
				end

				local add_btn = vgui.Create("bVGUI.Button", save_btn_container)
				add_btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
				add_btn:SetText(L"add_new")
				add_btn:SetSize(150,25)
				function add_btn:DoClick()
					GAS:PlaySound("popup")

					ModuleFrame.CloseFrames = ModuleFrame.CloseFrames or {}
					ModuleFrame.CloseFrames[
						bVGUI.StringQuery(title, text, placeholder, function(class_name)
							filters:AddRow(class_name)
						end)
					] = true
				end

				local save_btn = vgui.Create("bVGUI.Button", save_btn_container)
				save_btn:SetColor(bVGUI.BUTTON_COLOR_GREEN)
				save_btn:SetText(L"save")
				save_btn:SetSize(150,25)
				function save_btn:DoClick()
					GAS:PlaySound("success")
					local new_filter_data = {}
					for _,row in ipairs(filters.Rows) do
						new_filter_data[row.LabelsData[1]] = true
					end
					bVGUI.MouseInfoTooltip.Create(L"saved_exclamation")
					callback(new_filter_data)
				end

				function save_btn_container:PerformLayout()
					local w = (self:GetWide() - 20 - 10) / 2
					add_btn:SetWide(w)
					save_btn:SetWide(w)
					add_btn:SetPos(10, self:GetTall() / 2 - add_btn:GetTall() / 2)
					save_btn:SetPos(10 + add_btn:GetWide() + 10, self:GetTall() / 2 - save_btn:GetTall() / 2)
				end
			end

			GAS.ConfigCache["logging"] = nil
			GAS:GetConfig("logging", function(logging_config)
				if (not IsValid(categories)) then return end
				categories:SetLoading(false)

				function save_btn:DoClick()
					GAS:PlaySound("success")
					local data = util.Compress(GAS:SerializeTable(logging_config))
					GAS:netStart("logging:SaveConfig")
						net.WriteData(data, #data)
					net.SendToServer()
					bVGUI.MouseInfoTooltip.Create(L"saved_exclamation")
					self:SetDisabled(true)
				end

				local category = categories:AddCategory(L"settings", bVGUI.COLOR_GMOD_BLUE)

				category:AddItem(L"logging_settings", function()
					init_content()

					settings_content:DockPadding(15,15,15,15)

					local form = vgui.Create("bVGUI.Form", settings_content)
					form:Dock(FILL)
					form:SetPaddings(15,15)

					form:AddSwitch(L"Player_RecordTeam", logging_config.Player_RecordTeam, "", function(state)
						logging_config.Player_RecordTeam = state
						save_btn:SetDisabled(false)
					end)
					form:AddSwitch(L"Player_RecordUsergroup", logging_config.Player_RecordUsergroup, "", function(state)
						logging_config.Player_RecordUsergroup = state
						save_btn:SetDisabled(false)
					end)
					form:AddSwitch(L"Player_RecordHealth", logging_config.Player_RecordHealth, "", function(state)
						logging_config.Player_RecordHealth = state
						save_btn:SetDisabled(false)
					end)
					form:AddSwitch(L"Player_RecordArmor", logging_config.Player_RecordArmor, "", function(state)
						logging_config.Player_RecordArmor = state
						save_btn:SetDisabled(false)
					end)
					form:AddSwitch(L"Player_RecordWeapon", logging_config.Player_RecordWeapon, "", function(state)
						logging_config.Player_RecordWeapon = state
						save_btn:SetDisabled(false)
					end)
					form:AddButton(L"Player_RecordWeapon_DoNotRecord", bVGUI.BUTTON_COLOR_BLUE, L"Player_RecordWeapon_DoNotRecord_help", function()
						OpenFilterEditor(logging_config.Player_RecordWeapon_DoNotRecord, L"Player_RecordWeapon_DoNotRecord", L"enter_weapon_class", L"weapon_class", function(filter_data)
							logging_config.Player_RecordWeapon_DoNotRecord = filter_data
							save_btn:SetDisabled(false)
						end)
					end)

					form:AddSpacing(15)

					form:AddSwitch(L"OverrideMoneyFormat", logging_config.OverrideMoneyFormat, L"OverrideMoneyFormat_help", function(state)
						logging_config.OverrideMoneyFormat = state
						save_btn:SetDisabled(false)
					end)
					form:AddTextEntry(L"MoneyFormat", logging_config.MoneyFormat, L"MoneyFormat_help", function(val)
						logging_config.MoneyFormat = val
						save_btn:SetDisabled(false)
					end, function(val)
						return val:find("%%s") ~= nil
					end)
				end, Color(55,0,255))

				category:AddItem(L"module_settings", function()
					init_content()

					local tabs = vgui.Create("bVGUI.Tabs", settings_content)
					tabs:Dock(TOP)
					tabs:SetTall(40)

					local enabled_modules, enabled_modules_tab = tabs:AddTab(L"enabled_modules", Color(216,75,75))
					enabled_modules_tab:SetFunction(function()
						if (IsValid(enabled_modules.Content)) then enabled_modules.Content:Remove() end
						enabled_modules.Content = vgui.Create("bVGUI.BlankPanel", enabled_modules)
						enabled_modules.Content:Dock(FILL)
						enabled_modules.Content:DockMargin(15,15,15,15)

						local label = vgui.Create("DLabel", enabled_modules.Content)
						label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
						label:SetText(L"server_restart_required")
						label:SetTextColor(bVGUI.COLOR_WHITE)
						label:SetContentAlignment(5)
						label:Dock(TOP)
						label:SetTall(35)

						local enabled_modules_selector = vgui.Create("bVGUI.PermissionsSelector", enabled_modules.Content)
						enabled_modules_selector:Dock(FILL)
						enabled_modules_selector:DockMargin(15,15,15,15)

						enabled_modules_selector:NormalCheckboxes()
						enabled_modules_selector:AddPermission(L"enabled")

						function enabled_modules_selector:OnPermissionsChanged()
							for category_name, modules in pairs(self:GetPermissions()) do
								for module_name, _enabled in pairs(modules) do
									local enabled = _enabled[1]
									if (not enabled) then
										logging_config.Modules[category_name] = logging_config.Modules[category_name] or {}
										logging_config.Modules[category_name][module_name] = logging_config.Modules[category_name][module_name] or {}
										logging_config.Modules[category_name][module_name].Disabled = true
									else
										if (logging_config.Modules[category_name]) then
											if (logging_config.Modules[category_name][module_name]) then
												logging_config.Modules[category_name][module_name].Disabled = nil
												if (GAS:table_IsEmpty(logging_config.Modules[category_name][module_name])) then
													logging_config.Modules[category_name][module_name] = nil
												end
											end
											if (GAS:table_IsEmpty(logging_config.Modules[category_name])) then
												logging_config.Modules[category_name] = nil
											end
										end
									end
								end
							end
							save_btn:SetDisabled(false)
						end

						for category_name, modules in pairs(GAS.Logging.Modules) do
							local rows = {}
							local category_color
							for module_name, module_data in pairs(modules) do
								if (not category_color) then
									category_color = module_data.Colour
								end
								local checked = true
								if (logging_config.Modules[category_name] and logging_config.Modules[category_name][module_name]) then
									checked = logging_config.Modules[category_name][module_name].Disabled ~= true
								end
								table.insert(rows, {
									text = module_name,
									checked = {checked}
								})
							end
							enabled_modules_selector:AddPermissionGroup(category_name, category_color, rows)
						end
					end)
					enabled_modules_tab:OnMouseReleased(MOUSE_LEFT)

					local gamemode_modules, gamemode_modules_tab = tabs:AddTab(L"gamemode_modules", Color(75,75,216))
					gamemode_modules_tab:SetFunction(function()
						if (IsValid(gamemode_modules.Content)) then gamemode_modules.Content:Remove() end
						gamemode_modules.Content = vgui.Create("bVGUI.BlankPanel", gamemode_modules)
						gamemode_modules.Content:Dock(FILL)

						local label = vgui.Create("DLabel", gamemode_modules.Content)
						label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
						label:SetText(L"server_restart_required" .. "\n\n" .. L"gamemode_modules_tip")
						label:SetTextColor(bVGUI.COLOR_WHITE)
						label:SetContentAlignment(5)
						label:SizeToContents()
						label:SetPos(15,15)

						local form = vgui.Create("bVGUI.Form", gamemode_modules.Content)
						form:Dock(FILL)
						form:SetPaddings(15,15)
						form:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK)

						form:AddCheckbox("DarkRP", logging_config.ForcedGamemode_DarkRP, "", function(state)
							logging_config.ForcedGamemode_DarkRP = state
							save_btn:SetDisabled(false)
						end)
						form:AddCheckbox("Trouble in Terrorist Town", logging_config.ForcedGamemode_TTT, "", function(state)
							logging_config.ForcedGamemode_TTT = state
							save_btn:SetDisabled(false)
						end)
						form:AddCheckbox("Murder", logging_config.ForcedGamemode_Murder, "", function(state)
							logging_config.ForcedGamemode_Murder = state
							save_btn:SetDisabled(false)
						end)
						form:AddCheckbox("Cinema", logging_config.ForcedGamemode_Cinema, "", function(state)
							logging_config.ForcedGamemode_Cinema = state
							save_btn:SetDisabled(false)
						end)
						form:AddCheckbox("Sandbox", logging_config.ForcedGamemode_Sandbox, "", function(state)
							logging_config.ForcedGamemode_Sandbox = state
							save_btn:SetDisabled(false)
						end)

						function gamemode_modules.Content:PerformLayout()
							self:DockPadding(15,15 + label:GetTall() + 15,15,15)
						end
					end)

					local third_party_addons, third_party_addons_tab = tabs:AddTab(L"third_party_addons", Color(216,100,0))
					third_party_addons_tab:SetFunction(function()
						if (IsValid(third_party_addons.Content)) then third_party_addons.Content:Remove() end
						third_party_addons.Content = vgui.Create("bVGUI.BlankPanel", third_party_addons)
						third_party_addons.Content:Dock(FILL)

						local label = vgui.Create("DLabel", third_party_addons.Content)
						label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
						label:SetText(L"server_restart_required" .. "\n\n" .. L"third_party_addons_tip")
						label:SetTextColor(bVGUI.COLOR_WHITE)
						label:SetContentAlignment(5)
						label:SizeToContents()
						label:SetPos(15,15)

						local form = vgui.Create("bVGUI.Form", third_party_addons.Content)
						form:Dock(FILL)
						form:SetPaddings(15,15)
						form:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK)

						for name, info in pairs(GAS.Logging.ThirdPartyAddons) do
							local btn = ""
							if (info.workshop) then
								btn = vgui.Create("bVGUI.Button", form)
								btn:SetColor(Color(26,26,26))
								btn:SetText("Steam Workshop")
								function btn:DoClick()
									GAS:OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. info.workshop)
								end
							elseif (info.website) then
								btn = vgui.Create("bVGUI.Button", form)
								btn:SetColor(bVGUI.BUTTON_COLOR_RED)
								btn:SetText(L"website")
								function btn:DoClick()
									GAS:OpenURL(info.website)
								end
							elseif (info.gmodstore) then
								btn = vgui.Create("bVGUI.Button", form)
								btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
								btn:SetText("GmodStore")
								function btn:DoClick()
									GAS:OpenURL("https://gmodstore.com/market/view/" .. info.gmodstore)
								end
							end
							if (ispanel(btn)) then
								btn:SetSize(150,25)
							end
							form:AddCheckbox(name, logging_config.InstalledAddons[name] or 0, btn, function(state)
								if (state == 0) then
									logging_config.InstalledAddons[name] = nil
								else
									logging_config.InstalledAddons[name] = state
								end
							end)
						end

						function third_party_addons.Content:PerformLayout()
							self:DockPadding(15,15 + label:GetTall() + 15,15,15)
						end
					end)

					local discord, discord_tab = tabs:AddTab("Discord", Color(114, 137, 218))
					discord_tab:SetFunction(function()
						if (IsValid(discord.Content)) then discord.Content:Remove() end
						discord.Content = vgui.Create("bVGUI.BlankPanel", discord)
						discord.Content:Dock(FILL)
						discord.Content:DockMargin(15,15,15,15)

						local discord_selector
						local function CreateDiscordSelector()
							discord_selector = vgui.Create("bVGUI.PermissionsSelector", discord.Content)
							discord_selector:Dock(FILL)
							discord_selector:DockMargin(15,15,15,15)

							discord_selector:NormalCheckboxes()

							local sorted_webhooks = {}
							for name, webhook in pairs(logging_config.DiscordWebhooks) do
								table.insert(sorted_webhooks, {name = name, webhook = webhook})
							end
							table.SortByMember(sorted_webhooks, "name")

							for _,webhook in ipairs(sorted_webhooks) do
								discord_selector:AddPermission(webhook.name)
							end

							function discord_selector:OnPermissionsChanged()
								for category_name, modules in pairs(self:GetPermissions()) do
									for module_name, webhooks_enabled in pairs(modules) do
										for webhook_index, webhook_enabled in ipairs(webhooks_enabled) do
											if (webhook_enabled) then
												logging_config.Modules[category_name] = logging_config.Modules[category_name] or {}
												logging_config.Modules[category_name][module_name] = logging_config.Modules[category_name][module_name] or {}
												logging_config.Modules[category_name][module_name].DiscordWebhooks = logging_config.Modules[category_name][module_name].DiscordWebhooks or {}
												logging_config.Modules[category_name][module_name].DiscordWebhooks[sorted_webhooks[webhook_index].name] = true
											else
												if (logging_config.Modules[category_name]) then
													if (logging_config.Modules[category_name][module_name]) then
														if (logging_config.Modules[category_name][module_name].DiscordWebhooks) then
															logging_config.Modules[category_name][module_name].DiscordWebhooks[sorted_webhooks[webhook_index].name] = nil
														end
													end
												end
											end
										end
									end
								end
								logging_config.Modules = GAS:table_RemoveEmptyChildren(logging_config.Modules)
								save_btn:SetDisabled(false)
							end

							for category_name, modules in pairs(GAS.Logging.Modules) do
								local rows = {}
								local category_color
								for module_name, module_data in pairs(modules) do
									if (not category_color) then
										category_color = module_data.Colour
									end
									local checked = {}
									for _,webhook in ipairs(sorted_webhooks) do
										if (logging_config.Modules[category_name]) then
											if (logging_config.Modules[category_name][module_name]) then
												if (logging_config.Modules[category_name][module_name].DiscordWebhooks) then
													if (logging_config.Modules[category_name][module_name].DiscordWebhooks[webhook.name] == true) then
														table.insert(checked, true)
														continue
													end
												end
											end
										end
										table.insert(checked, false)
									end
									table.insert(rows, {
										text = module_name,
										checked = checked
									})
								end
								discord_selector:AddPermissionGroup(category_name, category_color, rows)
							end
						end

						local btn_container = vgui.Create("bVGUI.BlankPanel", discord.Content)
						btn_container:Dock(TOP)
						btn_container:SetTall(40)

						local btn = vgui.Create("bVGUI.Button", btn_container)
						btn:SetSize(150,25)
						btn:SetText(L"edit_discord_webhooks")
						btn:SetColor(Color(114,137,218))
						function btn:DoClick()
							if (not IsValid(ModuleFrame)) then return end

							GAS:PlaySound("popup")

							local discord_webhook_editor = vgui.Create("bVGUI.Frame")

							ModuleFrame.CloseFrames = ModuleFrame.CloseFrames or {}
							ModuleFrame.CloseFrames[discord_webhook_editor] = true

							discord_webhook_editor:SetSize(450,300)
							discord_webhook_editor:SetTitle(L"edit_discord_webhooks")
							discord_webhook_editor:Center()
							discord_webhook_editor:MakePopup()

							local discord_webhooks = vgui.Create("bVGUI.Table", discord_webhook_editor)
							discord_webhooks:Dock(FILL)
							discord_webhooks:AddColumn(L"name")
							discord_webhooks:AddColumn(L"webhook")
							discord_webhooks:SetRowCursor("hand")

							function discord_webhooks:OnRowClicked(row)
								GAS:PlaySound("btn_heavy")
								local menu = DermaMenu()
								menu:AddOption(L"remove", function()
									GAS:PlaySound("delete")
									discord_webhooks:RemoveRow(row.RowIndex)
								end):SetIcon("icon16/delete.png")
								menu:AddOption(L"copy_webhook", function()
									GAS:SetClipboardText(row.LabelsData[2])
								end):SetIcon("icon16/page_copy.png")
								menu:Open()
							end

							for name, webhook in pairs(logging_config.DiscordWebhooks) do
								discord_webhooks:AddRow(name, webhook)
							end

							local save_btn_container = vgui.Create("bVGUI.BlankPanel", discord_webhook_editor)
							save_btn_container:Dock(BOTTOM)
							save_btn_container:SetTall(45)
							function save_btn_container:Paint(w,h)
								surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
								surface.DrawRect(0,0,w,h)
							end

							local add_btn = vgui.Create("bVGUI.Button", save_btn_container)
							add_btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
							add_btn:SetText(L"add_new")
							add_btn:SetSize(150,25)
							function add_btn:DoClick()
								GAS:PlaySound("popup")
								
								discord_webhook_editor.CloseFrames = discord_webhook_editor.CloseFrames or {}
								discord_webhook_editor.CloseFrames[
									bVGUI.StringQuery(L"webhook_name", L"webhook_name_tip", L"webhook_name", function(webhook_name)
										GAS:PlaySound("jump")
										discord_webhook_editor.CloseFrames[
											bVGUI.StringQuery(webhook_name, L"webhook_url_tip", L"webhook_url", function(webhook_url)
												discord_webhooks:AddRow(webhook_name, webhook_url)
											end, function(text)
												return text:lower():gsub("discordapp%.com", "discord%.com"):find("^https://discord%.com/api/webhooks/%d+/.-$") ~= nil
											end)
										] = true
									end)
								] = true
							end

							local discord_save_btn = vgui.Create("bVGUI.Button", save_btn_container)
							discord_save_btn:SetColor(bVGUI.BUTTON_COLOR_GREEN)
							discord_save_btn:SetText(L"save")
							discord_save_btn:SetSize(150,25)
							function discord_save_btn:DoClick()
								GAS:PlaySound("success")
								bVGUI.MouseInfoTooltip.Create(L"saved_exclamation")
								for webhook_name in pairs(logging_config.DiscordWebhooks) do
									local found = false
									for _,row in ipairs(discord_webhooks.Rows) do
										if (row.LabelsData[1] == webhook_name) then
											found = true
											break
										end
									end
									if (not found) then
										for category, modules in pairs(logging_config.Modules) do
											for module_name, data in pairs(modules) do
												if (data.DiscordWebhooks) then
													data.DiscordWebhooks[webhook_name] = nil
													if (GAS:table_IsEmpty(data.DiscordWebhooks)) then
														data.DiscordWebhooks = nil
														if (GAS:table_IsEmpty(data)) then
															modules[module_name] = nil
															if (GAS:table_IsEmpty(modules)) then
																logging_config.Modules[category] = nil
															end
														end
													end
												end
											end
										end
									end
								end
								logging_config.DiscordWebhooks = {}
								for _,row in ipairs(discord_webhooks.Rows) do
									logging_config.DiscordWebhooks[row.LabelsData[1]] = row.LabelsData[2]
								end
								CreateDiscordSelector()
								save_btn:SetDisabled(false)
							end

							function save_btn_container:PerformLayout()
								local w = (self:GetWide() - 20 - 10) / 2
								add_btn:SetWide(w)
								discord_save_btn:SetWide(w)
								add_btn:SetPos(10, self:GetTall() / 2 - add_btn:GetTall() / 2)
								discord_save_btn:SetPos(10 + add_btn:GetWide() + 10, self:GetTall() / 2 - discord_save_btn:GetTall() / 2)
							end
						end

						local btn2 = vgui.Create("bVGUI.Button", btn_container)
						btn2:SetColor(bVGUI.BUTTON_COLOR_GREEN)
						btn2:SetText(L"help")
						btn2:SetSize(150,25)
						function btn2:DoClick()
							GAS:OpenURL("https://gmodsto.re/blogs-webhooks-help")
						end

						function btn_container:PerformLayout()
							local w = (self:GetWide() - btn:GetWide() - 10 - btn2:GetWide()) / 2
							btn:SetPos(w, self:GetTall() / 2 - btn:GetTall() / 2)
							btn2:SetPos(w + 10 + btn:GetWide(), self:GetTall() / 2 - btn2:GetTall() / 2)
						end

						CreateDiscordSelector()
					end)
				end, Color(255,0,120))

				category:AddItem(L"storage_settings", function()
					init_content()

					settings_content:DockPadding(15,15,15,15)

					local form = vgui.Create("bVGUI.Form", settings_content)
					form:Dock(FILL)
					form:SetPaddings(15,15)

					form:AddSwitch(L"DeepStorageEnabled", logging_config.DeepStorageEnabled == nil or logging_config.DeepStorageEnabled == true, L"DeepStorageEnabled_help", function(state)
						logging_config.DeepStorageEnabled = state
						save_btn:SetDisabled(false)
					end)

					form:AddSwitch(L"DeepStorageCommitOnShutdown", logging_config.DeepStorageCommitOnShutdown == nil or logging_config.DeepStorageCommitOnShutdown == true, L"DeepStorageCommitOnShutdown_help", function(state)
						logging_config.DeepStorageCommitOnShutdown = state
						save_btn:SetDisabled(false)
					end)

					form:AddNumberEntry(L"DeepStorageCommitPeriod", logging_config.DeepStorageCommitPeriod or 60, L"DeepStorageCommitPeriod_help", function(state)
						logging_config.DeepStorageCommitPeriod = state
						save_btn:SetDisabled(false)
					end)

					form:AddNumberEntry(L"DeepStorageTooOld", logging_config.DeepStorageTooOld, L"DeepStorageTooOld_help", function(state)
						logging_config.DeepStorageTooOld = state
						save_btn:SetDisabled(false)
					end)
				end, Color(0,150,255))

				category:AddItem(L"pvp_settings", function()
					init_content()

					settings_content:DockPadding(15,15,15,15)

					local form = vgui.Create("bVGUI.Form", settings_content)
					form:Dock(FILL)
					form:SetPaddings(15,15)

					form:AddNumberEntry(L"TimeBetweenPvPEvents", logging_config.TimeBetweenPvPEvents, L"TimeBetweenPvPEvents_help", function(val)
						logging_config.TimeBetweenPvPEvents = val
						save_btn:SetDisabled(false)
					end)

					form:AddButton(L"NonPvPWeapons", bVGUI.BUTTON_COLOR_BLUE, L"NonPvPWeapons_help", function(val)
						OpenFilterEditor(logging_config.NonPvPWeapons, L"NonPvPWeapons", L"enter_weapon_class", L"weapon_class", function(filter_data)
							logging_config.NonPvPWeapons = filter_data
							save_btn:SetDisabled(false)
						end)
					end)
				end, Color(255,0,0))

				category:AddItem(L"live_logs_settings", function()
					init_content()

					local livelogs_settings_tabs = vgui.Create("bVGUI.Tabs", settings_content)
					livelogs_settings_tabs:Dock(TOP)
					livelogs_settings_tabs:SetTall(40)

					local general_content = livelogs_settings_tabs:AddTab(L"general", Color(76,216,76))

						general_content:DockPadding(15,15,15,15)

						local form = vgui.Create("bVGUI.Form", general_content)
						form:Dock(FILL)
						form:SetPaddings(15,15)

						form:AddSwitch(L"LiveLogsEnabled", logging_config.LiveLogsEnabled, L"LiveLogsEnabled_help", function(state)
							logging_config.LiveLogsEnabled = state
							save_btn:SetDisabled(false)
						end)

						form:AddNumberEntry(L"LiveLogsIn10Seconds", logging_config.LiveLogsIn10Seconds, L"LiveLogsIn10Seconds_help", function(val)
							logging_config.LiveLogsIn10Seconds = val
							save_btn:SetDisabled(false)
						end)

						form:AddSwitch(L"NotifyLiveLogsAntispam", logging_config.NotifyLiveLogsAntispam, L"NotifyLiveLogsAntispam_help", function(state)
							logging_config.NotifyLiveLogsAntispam = state
							save_btn:SetDisabled(false)
						end)

					local modules_content = livelogs_settings_tabs:AddTab(L"modules", Color(216,76,216))

						modules_content:DockPadding(15,15,15,15)

						local modules_permission_editor

						local btns_container = vgui.Create("bVGUI.BlankPanel", modules_content)
						btns_container:Dock(TOP)
						btns_container:SetTall(40)

						local check_all = vgui.Create("bVGUI.Button", btns_container)
						check_all:SetSize(150,25)
						check_all:SetColor(bVGUI.BUTTON_COLOR_GREEN)
						check_all:SetText(L"check_all")
						function check_all:DoClick()
							GAS:PlaySound("flash")
							for _,row in ipairs(modules_permission_editor.Rows) do
								for _,checkbox in ipairs(row.Checkboxes) do
									checkbox:SetChecked(true)
								end
							end
							save_btn:SetDisabled(false)
						end

						local uncheck_all = vgui.Create("bVGUI.Button", btns_container)
						uncheck_all:SetSize(150,25)
						uncheck_all:SetColor(bVGUI.BUTTON_COLOR_RED)
						uncheck_all:SetText(L"uncheck_all")
						function uncheck_all:DoClick()
							GAS:PlaySound("delete")
							for _,row in ipairs(modules_permission_editor.Rows) do
								for _,checkbox in ipairs(row.Checkboxes) do
									checkbox:SetChecked(false)
								end
							end
							save_btn:SetDisabled(false)
						end

						function btns_container:PerformLayout(w)
							local _w = (w - check_all:GetWide() - 10 - uncheck_all:GetWide()) / 2
							check_all:AlignLeft(_w)
							uncheck_all:AlignLeft(_w + 10 + 150)
						end

						modules_permission_editor = vgui.Create("bVGUI.PermissionsSelector", modules_content)
						modules_permission_editor:Dock(FILL)
						modules_permission_editor:NormalCheckboxes()
						modules_permission_editor:AddPermission(L"livelogs_enabled")

						function modules_permission_editor:OnPermissionsChanged()
							for category_name, modules in pairs(self:GetPermissions()) do
								for module_name, _enabled in pairs(modules) do
									local enabled = _enabled[1]
									if (not enabled) then
										logging_config.Modules[category_name] = logging_config.Modules[category_name] or {}
										logging_config.Modules[category_name][module_name] = logging_config.Modules[category_name][module_name] or {}
										logging_config.Modules[category_name][module_name].LiveLogsDisabled = true
									else
										if (logging_config.Modules[category_name]) then
											if (logging_config.Modules[category_name][module_name]) then
												logging_config.Modules[category_name][module_name].LiveLogsDisabled = nil
												if (GAS:table_IsEmpty(logging_config.Modules[category_name][module_name])) then
													logging_config.Modules[category_name][module_name] = nil
												end
											end
											if (GAS:table_IsEmpty(logging_config.Modules[category_name])) then
												logging_config.Modules[category_name] = nil
											end
										end
									end
								end
							end
							save_btn:SetDisabled(false)
						end

						for category_name, modules in pairs(GAS.Logging.Modules) do
							local rows = {}
							local category_color
							for module_name, module_data in pairs(modules) do
								if (not category_color) then
									category_color = module_data.Colour
								end
								local checked = true
								if (logging_config.Modules[category_name] and logging_config.Modules[category_name][module_name]) then
									checked = logging_config.Modules[category_name][module_name].LiveLogsDisabled ~= true
								end
								table.insert(rows, {
									text = module_name,
									checked = {checked}
								})
							end
							modules_permission_editor:AddPermissionGroup(category_name, category_color, rows)
						end

				end, Color(0,255,115))

				category:AddItem(L"wipes_and_resets", function()
					init_content()

					settings_content:DockPadding(15,15,15,15)

					local enable_buttons = vgui.Create("bVGUI.Button", settings_content)
					enable_buttons:SetText(L"enable_buttons")
					enable_buttons:SetColor(bVGUI.BUTTON_COLOR_RED)
					enable_buttons:SetSize(150, 30)
					enable_buttons:AlignTop(15)
					enable_buttons:AlignLeft(15)

					local wipe_deepstorage = vgui.Create("bVGUI.Button", settings_content)
					wipe_deepstorage:SetText(L"wipe_deepstorage")
					wipe_deepstorage:SetColor(bVGUI.BUTTON_COLOR_RED)
					wipe_deepstorage:SetSize(150, 30)
					wipe_deepstorage:AlignTop(15 + 30 + 10)
					wipe_deepstorage:AlignLeft(15)
					wipe_deepstorage:SetDisabled(true)
					function wipe_deepstorage:DoClick()
						GAS:PlaySound("delete")
						GAS:netStart("logging:WipeDeepStorage")
						net.SendToServer()
					end

					local wipe_session = vgui.Create("bVGUI.Button", settings_content)
					wipe_session:SetText(L"wipe_session")
					wipe_session:SetColor(bVGUI.BUTTON_COLOR_RED)
					wipe_session:SetSize(150, 30)
					wipe_session:AlignTop(15 + 30 + 10 + 30 + 10)
					wipe_session:AlignLeft(15)
					wipe_session:SetDisabled(true)
					function wipe_session:DoClick()
						GAS:PlaySound("delete")
						GAS:netStart("logging:WipeSession")
						net.SendToServer()
					end

					local wipe_all_logs = vgui.Create("bVGUI.Button", settings_content)
					wipe_all_logs:SetText(L"wipe_all_logs")
					wipe_all_logs:SetColor(bVGUI.BUTTON_COLOR_RED)
					wipe_all_logs:SetSize(150, 30)
					wipe_all_logs:AlignTop(15 + 30 + 10 + 30 + 10 + 30 + 10)
					wipe_all_logs:AlignLeft(15)
					wipe_all_logs:SetDisabled(true)
					function wipe_all_logs:DoClick()
						GAS:PlaySound("delete")
						GAS:netStart("logging:WipeAllLogs")
						net.SendToServer()
					end

					local reset_config = vgui.Create("bVGUI.Button", settings_content)
					reset_config:SetText(L"reset_config")
					reset_config:SetColor(bVGUI.BUTTON_COLOR_RED)
					reset_config:SetSize(150, 30)
					reset_config:AlignTop(15 + 30 + 10 + 30 + 10 + 30 + 10 + 30 + 10)
					reset_config:AlignLeft(15)
					reset_config:SetDisabled(true)
					function reset_config:DoClick()
						GAS:PlaySound("delete")
						GAS:netStart("logging:ResetConfig")
						net.SendToServer()
						GAS:netReceive("logging:ResetConfig", function()
							operator_tab:OnMouseReleased(MOUSE_LEFT)
							net.Receivers["gmodadminsuite:logging:ResetConfig"] = nil
						end)
					end

					function enable_buttons:DoClick()
						if (wipe_deepstorage:GetDisabled()) then
							GAS:PlaySound("error")
							self:SetColor(bVGUI.BUTTON_COLOR_BLUE)
							self:SetText(L"disable_buttons")
							wipe_deepstorage:SetDisabled(false)
							wipe_session:SetDisabled(false)
							wipe_all_logs:SetDisabled(false)
							reset_config:SetDisabled(false)
						else
							GAS:PlaySound("success")
							self:SetColor(bVGUI.BUTTON_COLOR_RED)
							self:SetText(L"enable_buttons")
							wipe_deepstorage:SetDisabled(true)
							wipe_session:SetDisabled(true)
							wipe_all_logs:SetDisabled(true)
							reset_config:SetDisabled(true)
						end
					end
				end, Color(255,0,0))
			end)
		end)
	end

	GAS:StartNetworkTransaction("logging:GetModules", nil, function()
		if (not IsValid(livelogs_tab)) then return end
		
		livelogs_tab:SetEnabled(net.ReadBool())
		local data_len = net.ReadUInt(16)

		if (not IsValid(ModuleFrame)) then return end

		GAS.Logging.Modules = {}
		GAS.Logging.IndexedModules = GAS:DeserializeTable(util.Decompress(net.ReadData(data_len)))
		for module_id, module_data in pairs(GAS.Logging.IndexedModules) do
			if (module_data.Offline) then continue end
			GAS.Logging.Modules[module_data.Category] = GAS.Logging.Modules[module_data.Category] or {}
			GAS.Logging.Modules[module_data.Category][module_data.Name] = module_data
		end

		ModuleFrame.logs_content.Categories:SetLoading(false)

		ModuleFrame.logs_content.Categories:Clear()

		all_logs_category_item = ModuleFrame.logs_content.Categories:AddItem(L"all_logs", function()
			if (GAS.Logging.Menu.DamageLogs.SearchPanel.Open) then
				GAS.Logging.Menu.DamageLogs.SearchPanel.Open = false
				GAS.Logging.Menu.DamageLogs.SearchPanel:SetWide(0)
			end
			GAS.Logging.Menu.LogsTable.CurrentPage = 1
			damage_logs_mode = false
			GAS.Logging.Menu.LogsTable.ModuleID = false
			LoadLogs()
		end, Color(0,150,255))
		all_logs_category_item:OnMouseReleased(MOUSE_LEFT)
		
		if (GAS.Logging.Config.DeepStorageEnabled ~= false) then
			deep_storage_category_item = ModuleFrame.logs_content.Categories:AddItem(L"deep_storage", function()
				if (GAS.Logging.Menu.DamageLogs.SearchPanel.Open) then
					GAS.Logging.Menu.DamageLogs.SearchPanel.Open = false
					GAS.Logging.Menu.DamageLogs.SearchPanel:SetWide(0)
				end
				damage_logs_mode = false
				GAS.Logging.Menu.DamageLogs.NoData:SetVisible(false)
				ModuleFrame.AdvancedSearch:SetVisible(false)
				ModuleFrame.DeepStorage:SetVisible(true)
				time_taken:SetVisible(false)
				GAS.Logging.Menu.LogsTable:SetVisible(false)
				GAS.Logging.Menu.DamageLogs:SetVisible(false)
				GAS.Logging.Menu.DamageLogs.Padding:SetVisible(false)
				pagination_container:SetVisible(false)
				GAS.Logging.Menu.SearchTab:SetVisible(false)
				GAS.Logging.Menu.QuickSearch:SetVisible(false)
			end, Color(130,0,255))
		end

		advanced_search_category_item = ModuleFrame.logs_content.Categories:AddItem(L"advanced_search", function()
			if (GAS.Logging.Menu.DamageLogs.SearchPanel.Open) then
				GAS.Logging.Menu.DamageLogs.SearchPanel.Open = false
				GAS.Logging.Menu.DamageLogs.SearchPanel:SetWide(0)
			end
			GAS.Logging.Menu.DamageLogs.NoData:SetVisible(false)
			ModuleFrame.AdvancedSearch:SetVisible(true)
			ModuleFrame.DeepStorage:SetVisible(false)
			time_taken:SetVisible(false)
			GAS.Logging.Menu.LogsTable:SetVisible(false)
			GAS.Logging.Menu.DamageLogs:SetVisible(false)
			GAS.Logging.Menu.DamageLogs.Padding:SetVisible(false)
			pagination_container:SetVisible(false)
			GAS.Logging.Menu.SearchTab:SetVisible(false)
			GAS.Logging.Menu.QuickSearch:SetVisible(false)
		end, Color(76,255,76))

		local sorted_categories = {}
		for category_name, modules in pairs(GAS.Logging.Modules) do
			table.insert(sorted_categories, category_name)
		end
		table.sort(sorted_categories)
		for _,category_name in ipairs(sorted_categories) do
			local modules = GAS.Logging.Modules[category_name]
			local category
			local sorted_modules = table.ClearKeys(modules)
			table.ClearKeys(sorted_modules)
			table.SortByMember(sorted_modules, "Name", true)
			for i, module_data in ipairs(sorted_modules) do
				if (module_data.Disabled) then continue end
				if (not is_operator and OpenPermissions:GetPermission(LocalPlayer(), "gmodadminsuite_logging/" .. category_name .. "/" .. module_data.Name) == OpenPermissions.CHECKBOX.CROSSED) then continue end
				if (not category) then
					category = ModuleFrame.logs_content.Categories:AddCategory(category_name, module_data.Colour)
				end
				if (category_name == "PvP" and module_data.Name == "Combat Events") then
					damage_logs_category_item = ModuleFrame.logs_content.Categories:AddItem(L"player_combats", function()
						if (GAS.Logging.Menu.QuickSearch.Open) then
							GAS.Logging.Menu.SearchTab:OnMouseReleased(MOUSE_LEFT)
						end
						GAS.Logging.Menu.DamageLogs.CurrentPage = 1
						damage_logs_mode = true
						LoadDamageLogs()
					end, Color(255,0,0))
				else
					category:AddItem(module_data.Name, function()
						if (GAS.Logging.Menu.DamageLogs.SearchPanel.Open) then
							GAS.Logging.Menu.DamageLogs.SearchPanel.Open = false
							GAS.Logging.Menu.DamageLogs.SearchPanel:SetWide(0)
						end
						GAS.Logging.Menu.LogsTable.CurrentPage = 1
						damage_logs_mode = false
						GAS.Logging.Menu.LogsTable.ModuleID = module_data.ModuleID
						LoadLogs()
					end, module_data.Colour)
				end
			end
		end

		if (GAS.Logging.ViewLogs) then
			GAS.Logging.Menu:ViewPlayerLogs(GAS.Logging.ViewLogs, GAS.Logging.ViewLogsPly, GAS.Logging.ViewLogsDeepStorage)

			GAS.Logging.ViewLogs = nil
			GAS.Logging.ViewLogsPly = nil
			GAS.Logging.ViewLogsDeepStorage = nil
		end
	end)

	GAS.Logging.Menu.SearchTab = vgui.Create("bVGUI.BlankPanel", ModuleFrame.logs_content)
	GAS.Logging.Menu.SearchTab:SetSize(50,25)
	GAS.Logging.Menu.SearchTab:SetMouseInputEnabled(true)
	GAS.Logging.Menu.SearchTab:SetCursor("hand")
	function GAS.Logging.Menu.SearchTab:OnCursorEntered()
		bVGUI.CreateTooltip({
			Text = L"quick_search",
			VGUI_Element = self
		})
	end
	function GAS.Logging.Menu.SearchTab:OnCursorExited()
		bVGUI.DestroyTooltip()
	end
	function GAS.Logging.Menu.SearchTab:OnMouseReleased(m)
		local this = self
		if (m ~= MOUSE_LEFT) then return end
		if (damage_logs_mode) then
			GAS.Logging.Menu.DamageLogs.SearchPanel.Open = not GAS.Logging.Menu.DamageLogs.SearchPanel.Open
			GAS.Logging.Menu.DamageLogs.SearchPanel:SetTall(ModuleFrame.logs_content:GetTall() - 30 - 24)
			if (GAS.Logging.Menu.DamageLogs.SearchPanel.Open) then
				GAS:PlaySound("btn_on")
				GAS.Logging.Menu.DamageLogs.SearchPanel:Stop()
				GAS.Logging.Menu.DamageLogs.SearchPanel:SizeTo(175, -1, .25)
				GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer:Refresh()
				timer.Create("GAS:logging:DamageLogsSearchPanelPlayerRefresh", 1, 0, function()
					if (not IsValid(this) or not IsValid(GAS.Logging.Menu) or not IsValid(GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer)) then timer.Remove("GAS:logging:DamageLogsSearchPanelPlayerRefresh")return end		
					GAS.Logging.Menu.DamageLogs.SearchPanel.CheckboxContainer:Refresh()
				end)
			else
				GAS:PlaySound("btn_off")
				GAS.Logging.Menu.DamageLogs.SearchPanel:Stop()
				GAS.Logging.Menu.DamageLogs.SearchPanel:SizeTo(0, -1, .25)
				timer.Remove("GAS:logging:DamageLogsSearchPanelPlayerRefresh")
			end
		else
			GAS.Logging.Menu.QuickSearch.Open = not GAS.Logging.Menu.QuickSearch.Open
			if (not GAS.Logging.Menu.QuickSearch.Open) then
				GAS:PlaySound("btn_off")
				for _,row in ipairs(GAS.Logging.Menu.LogsTable.Rows) do
					row:SetVisible(true)
				end
				GAS.Logging.Menu.LogsTable:SortRows()
			else
				GAS:PlaySound("btn_on")
				GAS.Logging.Menu.QuickSearch.TextEntry:OnValueChange(GAS.Logging.Menu.QuickSearch.TextEntry:GetValue())
			end
		end
	end
	function GAS.Logging.Menu.SearchTab:Paint(w,h)
		surface.SetDrawColor(255,255,255,235)
		surface.SetMaterial(search_tab_mat)
		surface.DrawTexturedRect(0,0,64,64)
	end

	GAS.Logging.Menu.QuickSearch = vgui.Create("DPanel", ModuleFrame.logs_content)
	GAS.Logging.Menu.QuickSearch.Open = false
	GAS.Logging.Menu.QuickSearch:SetSize(160,30)
	GAS.Logging.Menu.QuickSearch:DockPadding(5,5,5,5)
	GAS.Logging.Menu.QuickSearch:SetMouseInputEnabled(true)
	function GAS.Logging.Menu.QuickSearch:Paint(w,h)
		surface.SetDrawColor(19,19,19,235)
		surface.DrawRect(0,0,w,h)
	end
	function GAS.Logging.Menu.QuickSearch:Think()
		if (not self.Y) then
			self.Y = ModuleFrame.logs_content:GetTall() - pagination_container:GetTall()
		end
		if (not GAS.Logging.Menu.SearchTab.Y) then
			GAS.Logging.Menu.SearchTab.Y = ModuleFrame.logs_content:GetTall() - pagination_container:GetTall() - GAS.Logging.Menu.SearchTab:GetTall()
		end
		local x = ModuleFrame.logs_content:GetWide() - self:GetWide() - 10
		local x2 = ModuleFrame.logs_content:GetWide() - GAS.Logging.Menu.SearchTab:GetWide() - GAS.Logging.Menu.DamageLogs.SearchPanel:GetWide() - 10
		if (self.Open) then
			self.Y = math.floor(Lerp(0.05, self.Y, ModuleFrame.logs_content:GetTall() - pagination_container:GetTall() - self:GetTall()))

			GAS.Logging.Menu.SearchTab.Y = math.floor(Lerp(0.05, GAS.Logging.Menu.SearchTab.Y, ModuleFrame.logs_content:GetTall() - pagination_container:GetTall() - self:GetTall() - GAS.Logging.Menu.SearchTab:GetTall()))
		else
			self.Y = math.ceil(Lerp(0.05, self.Y, ModuleFrame.logs_content:GetTall() - pagination_container:GetTall()))

			GAS.Logging.Menu.SearchTab.Y = math.ceil(Lerp(0.05, GAS.Logging.Menu.SearchTab.Y, ModuleFrame.logs_content:GetTall() - pagination_container:GetTall() - GAS.Logging.Menu.SearchTab:GetTall()))
		end
		self:SetPos(x, self.Y)
		GAS.Logging.Menu.SearchTab:SetPos(x2, GAS.Logging.Menu.SearchTab.Y)
	end

	GAS.Logging.Menu.QuickSearch.TextEntry = vgui.Create("bVGUI.TextEntry", GAS.Logging.Menu.QuickSearch)
	GAS.Logging.Menu.QuickSearch.TextEntry:Dock(FILL)
	GAS.Logging.Menu.QuickSearch.TextEntry:SetPlaceholderText(L"quick_search_ellipsis")
	GAS.Logging.Menu.QuickSearch.TextEntry:SetUpdateOnType(true)
	function GAS.Logging.Menu.QuickSearch.TextEntry:OnValueChange(_val)
		local val = _val:lower()
		for _,row in ipairs(GAS.Logging.Menu.LogsTable.Rows) do
			row:SetVisible(row.LabelsData[3]:lower():find(val) ~= nil)
		end
		GAS.Logging.Menu.LogsTable:SortRows()
	end
	
	pagination_container = vgui.Create("DPanel", ModuleFrame.logs_content)
	function pagination_container:Paint(w,h)
		surface.SetDrawColor(19,19,19,255)
		surface.DrawRect(0,0,w,h)
	end
	pagination_container:Dock(BOTTOM)
	pagination_container:SetTall(30)

	pagination = vgui.Create("bVGUI.Pagination", pagination_container)
	pagination:SetPages(1)
	pagination:Dock(FILL)

	function pagination:OnPageSelected(page)
		if (damage_logs_mode == true) then
			GAS.Logging.Menu.DamageLogs:SetLoading(true)
			GAS.Logging.Menu.DamageLogs.CurrentPage = page
			LoadDamageLogs()
		else
			GAS.Logging.Menu.LogsTable:SetLoading(true)
			GAS.Logging.Menu.LogsTable.CurrentPage = page
			LoadLogs()
		end
	end

	function GAS.Logging.Menu:ViewPlayerLogs(account_id, ply, deep_storage)
		local item = vgui.Create("GAS.Logging.AdvancedSearchItem", ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems.PlayerPnl)
		item:SetAccountID(account_id)
		item:SetValue(tostring(account_id))
		if (IsValid(ply)) then
			item:SetText(ply:Nick())
			item:SetColor(team.GetColor(ply:Team()))
		end
		ModuleFrame.AdvancedSearch.Filters.AdvancedSearchItems:AddItem(2, item)

		ModuleFrame.AdvancedSearch.Greedy:SetChecked(true)
		if (deep_storage) then
			GAS.Logging.Menu.LogsTable.DeepStorage = true
			ModuleFrame.DeepStorage.Button:SetColor(bVGUI.BUTTON_COLOR_RED)
			ModuleFrame.DeepStorage.Button:SetText(L"exit_deep_storage")
		else
			GAS.Logging.Menu.LogsTable.DeepStorage = false
			ModuleFrame.DeepStorage.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
			ModuleFrame.DeepStorage.Button:SetText(L"view_deep_storage")
		end
		if (IsValid(deep_storage_category_item)) then deep_storage_category_item:SetForcedActive(GAS.Logging.Menu.LogsTable.DeepStorage) end

		ModuleFrame.AdvancedSearch.Filters.DoSearch:DoClick()
	end
end)

GAS:netReceive("logging:SendLogs", function(len)
	local data = GAS:DeserializeTable(util.Decompress(net.ReadData(len)))
	if (not IsValid(GAS.Logging.Menu)) then return end
	if (GAS.Logging.Menu.SendLogs_TransactionID ~= data[1]) then return end

	local module_data
	if (GAS.Logging.Menu.LogsTable.ModuleID) then
		module_data = GAS.Logging.IndexedModules[GAS.Logging.Menu.LogsTable.ModuleID]
	end
	for _,log in ipairs(data[2]) do
		module_data = module_data or GAS.Logging.IndexedModules[log[2]]

		local formatted_log = GAS.Logging:FormatMarkupLog(log, GAS.Logging.Config.ColoredLogs or true)
		local log_row = GAS.Logging.Menu.LogsTable:AddRow("<color=" .. GAS:Unvectorize(module_data.Colour or bVGUI.COLOR_WHITE) .. ">" .. GAS:EscapeMarkup(module_data.Name) .. "</color>", GAS:SimplifyTimestamp(log[3]), formatted_log)
		log_row.Data = log
		log_row.IsColored = GAS.Logging.Config.ColoredLogs or true

		module_data = nil
	end
	if (GAS.Logging.Menu.QuickSearch.Open) then
		GAS.Logging.Menu.QuickSearch.TextEntry:OnValueChange(GAS.Logging.Menu.QuickSearch.TextEntry:GetValue())
	end
end)

GAS:netReceive("logging:SendDamageLogs", function(len)
	local data = GAS:DeserializeTable(util.Decompress(net.ReadData(len)))
	if (not data) then return end
	if (not IsValid(GAS.Logging.Menu)) then return end
	if (GAS.Logging.Menu.SendLogs_TransactionID ~= data[1]) then return end
	for i,row in ipairs(data[2]) do
		local dmg_log = vgui.Create("GAS.Logging.DamageLog", GAS.Logging.Menu.DamageLogs)
		dmg_log.RowIndex = i
		dmg_log:Dock(TOP)
		dmg_log:Setup(row)
	end
end)

GAS:netReceive("logging:PvPEventReport", function(len)
	local data = net.ReadData(len)
	data = GAS:DeserializeTable(util.Decompress(data))

	local dmglog = vgui.Create("GAS.Logging.DamageLog")
	dmglog:SetSize(0,0)
	dmglog:Setup(data)
	dmglog.DeleteMeOnClose = true
	dmglog:DoClick()
end)

GAS:ContextProperty("gas_logging", {
	MenuLabel = L"module_name",
	MenuIcon = "icon16/database_lightning.png",
	MenuOpen = function(self, option, ply, tr)
		option:AddOption(L"open_menu", function()
			RunConsoleCommand("gmodadminsuite", "logging")
		end):SetIcon("icon16/application_form_magnify.png")

		option:AddSpacer()

		option:AddOption(L"view_logs", function()
			if (IsValid(GAS.Logging.Menu)) then
				GAS.Logging.Menu:ViewPlayerLogs(ply:AccountID(), ply)
			else
				GAS.Logging.ViewLogs = ply:AccountID()
				GAS.Logging.ViewLogsPly = ply
				GAS.Logging.ViewLogsDeepStorage = nil
				RunConsoleCommand("gmodadminsuite", "logging")
			end
		end):SetIcon("icon16/user_go.png")

		option:AddOption(L"deep_storage", function()
			if (IsValid(GAS.Logging.Menu)) then
				GAS.Logging.Menu:ViewPlayerLogs(ply:AccountID(), ply, true)
			else
				GAS.Logging.ViewLogs = ply:AccountID()
				GAS.Logging.ViewLogsPly = ply
				GAS.Logging.ViewLogsDeepStorage = true
				RunConsoleCommand("gmodadminsuite", "logging")
			end
		end):SetIcon("icon16/database_lightning.png")
	end,
	Filter = function(self, ent, ply)
		return ent:IsPlayer() and not ent:IsBot() and OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/logging")
	end
})