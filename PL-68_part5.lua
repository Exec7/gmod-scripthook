--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 5/10 - 06/04/2025


--PATH lua/autorun/aarivaros.lua:
return gluapack()()
--PATH lua/autorun/adverts.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/serv_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSERV = {}
GMSERV.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("serv_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SERVStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SERVStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SERVStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("SERV_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("SERV_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSERV:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSERV.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--PATH lua/arccw/shared/sh_0_ttt.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_effects.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_stock_short.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_closecombat.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_closecombat.lua:
att.PrintName = "15a Close-combat top"
att.Description = "Short length customized top. Improves handling, though offers much worse range and accuracy."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_a280c_barrel.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_top"
att.ActivateElements = {"15a_top_closecombat"}

att.Mult_Range = 0.79
att.Mult_Recoil = 1.10
att.Mult_RPM = 1.12 
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2
att.Mult_ShootPitch = 1.1
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_short.lua:
att.PrintName = "15a Short Top"
att.Description = "DC-15a short-top. Designed short-range combat."
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280_barrel2.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = {"15a_top"}
att.ActivateElements = {"15a_top_short"}

att.Mult_MoveSpeed = 0.9

att.Mult_Range = 0.90
att.Mult_Damage = 1.15
att.Mult_Recoil = 0.95
att.Mult_SightTime = 1.1
att.Mult_AccuracyMOA = 0.75
att.Mult_ShootPitch = 0.9
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_a280.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_ext.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_barrel_short.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_barrel_short.lua:
att.PrintName = "Shortbarrel"
att.Icon = Material("entities/kraken/sops/atts/cfeshort.png", "mips smooth")
att.Description = "Offers superior handling at the cost of performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_barrel"
att.ActivateElements = {"a280cfe_barrel_short"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2

att.Mult_ShootPitch = 1.1
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_stock_assault.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_stock_heavy.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_slug.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_slug.lua:
att.PrintName = "Slug-Blaster"
att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/2759850485_469778067.png")
att.Description = "Your shotgun now shoots a slug."
att.Override_MuzzleEffect = nil
att.Override_Tracer = nil
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "shotgun_ammo"

att.Override_Num = 1

att.Mult_AccuracyMOA = 0.4
att.Mult_HipDispersion = 0.2
att.Mult_SightsDispersion = 0.1

att.Mult_Range = 2.3
att.Mult_Penetration = 1.4
att.Mult_ShootPitch = 0.6
att.Reload = 0.9
att.Mult_DamageMin = 0.74
att.Mult_Recoil = 2
att.Mult_SightTime = 1
att.Mult_RPM = 0.9
att.Mult_Damage = 1.7
att.Mult_MuzzleVelocity = 1.4
--PATH lua/arccw/shared/attachments/charm_dingus.lua:

att.PrintName = "Dingus"
att.Icon = Material("entities/dingus-icon.png")
att.Description = "dingus, a tribute to my best-friend cat."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/dingus/dingus.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.05, 0.05, 0.05)
att.CharmOffset = Vector(0, -0.4, 0)
att.CharmAngle = Angle(-60, 0, 90)

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_powerpack.lua:
att.PrintName = "DC-17 Powerpack"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/cooling.png")
att.Description = "More magazine capacity at the cost of less damage."

att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "dc17_powerpack"
att.ActivateElements = {"dc17_powerpack"}

att.Mult_MoveDispersion = 1.05
att.Mult_AccuracyMOA = 0.95
att.Mult_Damage = 0.90
att.OverrideClipSize = 20
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_stun.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_thermal.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_at.lua:
att.PrintName = "Anti-Tank Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/at.png")
att.Description = "Set the weapon mode to anti-tank. It will greatly improve its performance against vehicles"

att.Slot = "sw_mode_rifle"

att.Override_MuzzleEffect = "blaster_muzzle_red"
att.Override_Tracer = "tracer_red"
att.Override_DamageType = DMG_BLAST
att.Mult_RPM = 0.5
att.MuzzleFlashColor = Color(250, 0, 0)

att.Mult_Damage = 0.8
att.Mult_DamageMin = 1.10
att.Mult_Range = 0.3

att.Mult_Recoil = 2.5
att.Mult_RecoilSide = 1.2
att.Mult_VisualRecoilMult = 1.2

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

att.Hook_GetCapacity = function(wep, cap)
    return math.Clamp(math.Round(wep.RegularClipSize * 1), 1, 15)
end

att.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_charged.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_heatbased.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_overcharged.lua:
att.PrintName = "Overcharged Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/charged.png")
att.Description = "Set the weapon mode to Overcharged Mode."

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

att.Slot = "sw_mode_sniper"

att.Override_MuzzleEffect = "blaster_muzzle_green"
att.Override_Tracer = "tracer_green"
att.Override_DamageType = DMG_DISSOLVE
att.Override_AmmoPerShot = 5
att.Mult_RPM = 0.35

att.Mult_Damage = 1.2
att.Mult_Range = 1.25

att.Mult_Recoil = 1.2
att.Mult_RecoilSide = 1.55
att.Mult_VisualRecoilMult = 1.25


--PATH lua/arccw/shared/attachments/muzzle_a280cfe_default_mod.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_a280cfe_scope.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_experimental.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonearc.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_pointshooting.lua:
att.PrintName = "Point Shooting"

att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/3136448382_2347094400.png")
att.Description = "Dedicated practice at shooting without using the sights has given you the ability to fire from the hip more effectively. If ARC Troopers can do it, so can you."
att.Desc_Pros = {
    "Better hip dispersion"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 6

att.Mult_HipDispersion = 0.70

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_strafe.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_grip_e11.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/sw_perk_standardtraining.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_stock_e11b.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun5.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/valken38_sling.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_localization.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_physbullet2.lua:
ArcCW.PhysBullets = {
}

-- intentionally not 10 despite there being 10 default profiles.
-- for some reason profile indices are previously referenced as zero-indexed but stored as one-indexed
ArcCW.BulletProfileNum = 9
ArcCW.BulletProfileBits = nil
ArcCW.BulletProfiles = {
    [0] = "default0",
    [1] = "default1",
    [2] = "default2",
    [3] = "default3",
    [4] = "default4",
    [5] = "default5",
    [6] = "default6",
    [7] = "default7",
    [8] = "default8",
    [9] = "default9",
}
ArcCW.BulletProfileDict = {
    ["default0"] = {id = 0, name = "default0", color = Color(255, 225, 200)},
    ["default1"] = {id = 1, name = "default1", color = Color(255, 0, 0)},
    ["default2"] = {id = 2, name = "default2", color = Color(0, 255, 0)},
    ["default3"] = {id = 3, name = "default3", color = Color(0, 0, 255)},
    ["default4"] = {id = 4, name = "default4", color = Color(255, 255, 0)},
    ["default5"] = {id = 5, name = "default5", color = Color(255, 0, 255)},
    ["default6"] = {id = 6, name = "default6", color = Color(0, 255, 255)},
    ["default7"] = {id = 7, name = "default7", color = Color(0, 0, 0)},
    ["default8"] = {id = 8, name = "default8", color = Color(100, 255, 100)},
    ["default9"] = {id = 9, name = "default9", color = Color(100, 0, 255)},
--[[]
    ["profile_name"] = {
        color = Color(255, 255, 255),
        sprite_head = Material("effects/whiteflare"), -- set false to not draw a sprite, set nil to use default
        sprite_tail = Material("effects/smoke_trail"), -- ditto
        size = 1, -- Size growth factor of the physbullet (from distance)
        size_min = 1, -- Base size of the physbullet
        tail_length = 0.02, -- as a fraction of the bullet's velocity
        model = "models/weapons/w_bullet.mdl", -- clientside model is not created without this path
        model_nodraw = false, -- true to not draw model
        particle = "myparticle", -- requires a model path; set to nodraw if you don't wish it to be visible

        ThinkBullet = function(bulinfo, bullet) end, -- set bullet.Dead = true to stop processing and delete bullet.
        DrawBullet = function(bulinfo, bullet) end, -- return true to prevent default drawing behavior
        PhysBulletHit = function(bulinfo, bullet, tr) end,
    }
]]
}

local vector_down = Vector(0, 0, 1)

function ArcCW:AddBulletProfile(name, bulinfo)

    if istable(name) and !bulinfo then
        bulinfo = name
        name = tostring(ArcCW.BulletProfileNum + 1)
    end

    local new = !ArcCW.BulletProfileDict[name]
    if new then
        ArcCW.BulletProfileNum = ArcCW.BulletProfileNum + 1
        ArcCW.BulletProfiles[ArcCW.BulletProfileNum] = name
        ArcCW.BulletProfileBits = nil
    end
    ArcCW.BulletProfileDict[name] = bulinfo
    if new then
        ArcCW.BulletProfileDict[name].name = name
        ArcCW.BulletProfileDict[name].id = ArcCW.BulletProfileNum
    end
end

function ArcCW:BulletProfileBitNecessity()
    if !ArcCW.BulletProfileBits then
        ArcCW.BulletProfileBits = math.min(math.ceil(math.log(ArcCW.BulletProfileNum + 1, 2)), 32)
    end
    return ArcCW.BulletProfileBits
end

function ArcCW:SendBullet(bullet, attacker)
    net.Start("arccw_sendbullet", true)
    net.WriteVector(bullet.Pos)
    net.WriteAngle(bullet.Vel:Angle())
    net.WriteFloat(bullet.Vel:Length())
    net.WriteFloat(bullet.Drag)
    net.WriteFloat(bullet.Gravity)
    net.WriteUInt(bullet.Profile or 0, ArcCW:BulletProfileBitNecessity())
    net.WriteBool(bullet.PhysBulletImpact)
    net.WriteEntity(bullet.Weapon)

    if attacker and attacker:IsValid() and attacker:IsPlayer() and !game.SinglePlayer() then
        net.SendOmit(attacker)
    else
        if game.SinglePlayer() then
            net.WriteEntity(attacker)
        end
        net.Broadcast()
    end
end

function ArcCW:ShootPhysBullet(wep, pos, vel, prof, ovr)
    ovr = ovr or {}
    local pbi = ovr.PhysBulletImpact or wep:GetBuff_Override("Override_PhysBulletImpact")
    local num = ovr.Num or wep:GetBuff("Num")

    if !prof then
        prof = wep:GetBuff_Override("Override_PhysTracerProfile", wep.PhysTracerProfile) or 1
    end
    if isstring(prof) then
        prof = ArcCW.BulletProfileDict[prof].id
    end

    local bullet = {
        DamageMax = wep:GetDamage(0) / num,
        DamageMin = wep:GetDamage(math.huge) / num,
        Range = wep:GetBuff("Range"),
        DamageType = wep:GetBuff_Override("Override_DamageType", wep.DamageType),
        Penleft = wep:GetBuff("Penetration"),
        Penetration = wep:GetBuff("Penetration"),
        ImpactEffect = wep:GetBuff_Override("Override_ImpactEffect", wep.ImpactEffect),
        ImpactDecal = wep:GetBuff_Override("Override_ImpactDecal", wep.ImpactDecal),
        PhysBulletImpact = pbi == nil and true or pbi,
        Gravity = wep:GetBuff("PhysBulletGravity"),
        HullSize = wep:GetBuff("HullSize"),
        Num = num,
        Pos = pos,
        Vel = vel,
        Drag = wep:GetBuff("PhysBulletDrag"),
        Travelled = 0,
        StartTime = CurTime(),
        Imaginary = false,
        Underwater = false,
        WeaponClass = wep:GetClass(),
        Weapon = wep,
        Attacker = wep:GetOwner(),
        Filter = {wep:GetOwner()},
        Damaged = {},
        Burrowing = false,
        Dead = false,
        Profile = prof
    }
    table.Merge(bullet, ovr)

    table.Add(bullet.Filter, wep.Shields or {})

    local owner = wep:GetOwner()

    --[[]
    if owner and owner:IsNPC() then
        bullet.DamageMax = bullet.DamageMax * ArcCW.ConVars["mult_npcdamage"]:GetFloat()
        bullet.DamageMin = bullet.DamageMin * ArcCW.ConVars["mult_npcdamage"]:GetFloat()
    end
    ]]

    if SERVER and owner and owner:IsPlayer() then
        table.Add(bullet.Filter, ArcCW:GetVehicleFilter(owner) or {})
    end

    if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
        bullet.Underwater = true
    end

    table.insert(ArcCW.PhysBullets, bullet)

    -- TODO: This is still bad but unless we can access FLOW_OUTGOING from inside INetChannelInfo I can't think of any better way to do this.
    if owner:IsPlayer() and SERVER then
        --local ping = owner:Ping() / 1000
        --ping = math.Clamp(ping, 0, 0.5)

        -- local latency = util.TimeToTicks((owner:Ping() / 1000) * 0.5)
        local latency = math.floor(engine.TickCount() - owner:GetCurrentCommand():TickCount() - 1) -- FIXME: this math.floor does nothing
        local timestep = engine.TickInterval()

        while latency > 0 do
            ArcCW:ProgressPhysBullet(bullet, timestep)
            latency = latency - 1
        end

        -- while ping > 0 do
        --     ArcCW:ProgressPhysBullet(bullet, timestep)
        --     ping = ping - timestep
        -- end
    end

    if SERVER then
        -- ArcCW:ProgressPhysBullet(bullet, engine.TickInterval())
        ArcCW:SendBullet(bullet, wep:GetOwner())
    end
end

if CLIENT then

net.Receive("arccw_sendbullet", function(len, ply)
    local pos = net.ReadVector()
    local ang = net.ReadAngle()
    local vel = net.ReadFloat()
    local drag = net.ReadFloat()
    local grav = net.ReadFloat()
    local profile = net.ReadUInt(ArcCW:BulletProfileBitNecessity())
    local impact = net.ReadBool()
    local weapon = net.ReadEntity()
    local ent = nil

    if game.SinglePlayer() then
        ent = net.ReadEntity()
    end

    local bullet = {
        Pos = pos,
        Vel = ang:Forward() * vel,
        Travelled = 0,
        StartTime = CurTime(),
        Imaginary = false,
        Underwater = false,
        Dead = false,
        Damaged = {},
        Drag = drag,
        Attacker = ent or weapon:GetOwner(),
        Gravity = grav,
        Profile = profile,
        PhysBulletImpact = impact,
        Weapon = weapon,
        Filter = {weapon:GetOwner()},
    }

    if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
        bullet.Underwater = true
    end

    table.insert(ArcCW.PhysBullets, bullet)
end)

end

function ArcCW:DoPhysBullets()
    local new = {}
    local deltatime = engine.TickInterval()

    for _, i in pairs(ArcCW.PhysBullets) do
        ArcCW:ProgressPhysBullet(i, deltatime)
        -- On the client, bullets must live for at least one tick so we get to render it
        -- This prevents invisible tracers up close
        if !i.Dead or (CLIENT and CurTime() - i.StartTime <= engine.TickInterval()) then
            table.insert(new, i)
        elseif CLIENT and IsValid(i.CSModel) then
            i.CSModel:Remove()
            if i.CSParticle then
                i.CSParticle:StopEmission()
                i.CSParticle = nil
            end
        end
    end

    ArcCW.PhysBullets = new
end

hook.Add("Tick", "ArcCW_DoPhysBullets", ArcCW.DoPhysBullets)

local function indim(vec, maxdim)
    if math.abs(vec.x) > maxdim or math.abs(vec.y) > maxdim or math.abs(vec.z) > maxdim then
        return false
    else
        return true
    end
end

local ArcCW_BulletGravity = ArcCW.ConVars["bullet_gravity"]
local ArcCW_BulletDrag = ArcCW.ConVars["bullet_drag"]
function ArcCW:ProgressPhysBullet(bullet, timestep)
    if bullet.Dead then return end

    local oldpos = bullet.Pos
    local oldvel = bullet.Vel
    local dir = bullet.Vel:GetNormalized()
    local spd = bullet.Vel:Length() * timestep
    local drag = bullet.Drag * spd * spd * (1 / 150000)
    local gravity = timestep * ArcCW_BulletGravity:GetFloat() * (bullet.Gravity or 1)

    local attacker = bullet.Attacker

    if !IsValid(attacker) then
        bullet.Dead = true
        return
    end

    if bullet.Underwater then
        drag = drag * 3
    end

    drag = drag * ArcCW_BulletDrag:GetFloat()

    if spd <= 0.001 then bullet.Dead = true return end

    local bulinfo = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[bullet.Profile or 1] or ""]
    if bulinfo == nil then
        return
    end
    if bulinfo.ThinkBullet then
        bulinfo:ThinkBullet(bullet)
    end

    local newpos = oldpos + (oldvel * timestep)
    local newvel = oldvel - (dir * drag)
    newvel = newvel - (vector_down * gravity)

    if bullet.Imaginary then
        -- the bullet has exited the map, but will continue being visible.
        bullet.Pos = newpos
        bullet.Vel = newvel
        bullet.Travelled = bullet.Travelled + spd

        if CLIENT and !ArcCW.ConVars["bullet_imaginary"]:GetBool() then
            bullet.Dead = true
        end
    else
        if attacker:IsPlayer() then
            attacker:LagCompensation(true)
        end

        local tr
        if bullet.HullSize then
            local bb = Vector(bullet.HullSize / 2, bullet.HullSize / 2, bullet.HullSize / 2)
            tr = util.TraceHull({
                start = oldpos,
                endpos = newpos,
                filter = bullet.Filter,
                mask = MASK_SHOT,
                mins = -bb,
                maxs = bb,
            })
            if ArcCW.ConVars["dev_shootinfo"]:GetInt() > 0 then
                debugoverlay.Line(oldpos, tr.HitPos, 5, SERVER and Color(100,100,255) or Color(255,200,100), true)
                debugoverlay.Box(tr.HitPos, -bb, bb, 5, SERVER and Color(100,100,255,0) or Color(255,200,100,0))
            end
        else
            tr = util.TraceLine({
                start = oldpos,
                endpos = newpos,
                filter = bullet.Filter,
                mask = MASK_SHOT
            })
            if ArcCW.ConVars["dev_shootinfo"]:GetInt() > 0 then
                debugoverlay.Line(oldpos, tr.HitPos, 5, SERVER and Color(100,100,255) or Color(255,200,100), true)
                debugoverlay.Cross(tr.HitPos, 16, 0.05, SERVER and Color(100,100,255) or Color(255,200,100), true)
            end
        end

        if attacker:IsPlayer() then
            attacker:LagCompensation(false)
        end

        if tr.HitSky then
            if CLIENT and ArcCW.ConVars["bullet_imaginary"]:GetBool() then
                bullet.Imaginary = true
            else
                bullet.Dead = true
            end

            bullet.Pos = newpos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if SERVER then
                bullet.Dead = true
            end
        elseif tr.Hit then
            bullet.Travelled = bullet.Travelled + (oldpos - tr.HitPos):Length()
            bullet.Pos = tr.HitPos
            -- if we're the client, we'll get the bullet back when it exits.

            if attacker:IsPlayer() then
                attacker:LagCompensation(true)
            end

            if SERVER then
                debugoverlay.Cross(tr.HitPos, 5, 5, Color(100,100,255), true)
            else
                debugoverlay.Cross(tr.HitPos, 5, 5, Color(255,200,100), true)
            end

            local eid = tr.Entity:EntIndex()

            if CLIENT then
                -- do an impact effect and forget about it
                if !game.SinglePlayer() and bullet.PhysBulletImpact then
                    attacker:FireBullets({
                        Src = oldpos,
                        Dir = dir,
                        Distance = spd + 16,
                        Tracer = 0,
                        Damage = 0,
                        IgnoreEntity = bullet.Attacker
                    })
                end
                bullet.Dead = true
                if IsValid(bullet.Weapon) then
                    bullet.Weapon:GetBuff_Hook("Hook_PhysBulletHit", {bullet = bullet, tr = tr})
                end
                if bullet.PhysBulletHit then
                    bullet:PhysBulletHit(bullet, tr)
                end
                if bulinfo.PhysBulletHit then
                    bulinfo:PhysBulletHit(bullet, tr)
                end
                return
            elseif SERVER then
                local dmgtable
                if IsValid(bullet.Weapon) then
                    bullet.Weapon:GetBuff_Hook("Hook_PhysBulletHit", {bullet = bullet, tr = tr})

                    dmgtable = bullet.Weapon.BodyDamageMults
                    dmgtable = bullet.Weapon:GetBuff_Override("Override_BodyDamageMults") or dmgtable
                end
                if bullet.PhysBulletHit then
                    bullet:PhysBulletHit(bullet, tr)
                end
                if bullet.PhysBulletImpact then

                    local delta = bullet.Travelled / (bullet.Range / ArcCW.HUToM)
                    delta = math.Clamp(delta, 0, 1)
                    -- deal some damage
                    attacker:FireBullets({
                        Src = oldpos,
                        Dir = dir,
                        Distance = spd + 16,
                        Tracer = 0,
                        Damage = 0,
                        IgnoreEntity = bullet.Attacker,
                        Callback = function(catt, ctr, cdmg)
                            ArcCW:BulletCallback(catt, ctr, cdmg, bullet, true)
                        end
                    }, true)
                end
                bullet.Damaged[eid] = true
                bullet.Dead = true
            end

            if attacker:IsPlayer() then
                attacker:LagCompensation(false)
            end
        else
            -- bullet did not impact anything
            bullet.Pos = tr.HitPos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if bullet.Underwater then
                if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) != CONTENTS_WATER then
                    local utr = util.TraceLine({
                        start = tr.HitPos,
                        endpos = oldpos,
                        filter = bullet.Attacker,
                        mask = MASK_WATER
                    })

                    if utr.Hit then
                        local fx = EffectData()
                        fx:SetOrigin(utr.HitPos)
                        fx:SetScale(10)
                        util.Effect("gunshotsplash", fx)
                    end

                    bullet.Underwater = false
                end
            else
                if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) == CONTENTS_WATER then
                    local utr = util.TraceLine({
                        start = oldpos,
                        endpos = tr.HitPos,
                        filter = bullet.Attacker,
                        mask = MASK_WATER
                    })

                    if utr.Hit then
                        local fx = EffectData()
                        fx:SetOrigin(utr.HitPos)
                        fx:SetScale(10)
                        util.Effect("gunshotsplash", fx)
                    end

                    bullet.Underwater = true
                end
            end
        end
    end

    bullet.OldPos = oldpos

    local MaxDimensions = 16384 * 4
    local WorldDimensions = 16384

    if bullet.StartTime <= (CurTime() - ArcCW.ConVars["bullet_lifetime"]:GetFloat()) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, MaxDimensions) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, WorldDimensions) then
        bullet.Imaginary = true
    end
end

local head = Material("particle/fire")
local tracer = Material("effects/smoke_trail")

function ArcCW:DrawPhysBullets()
    cam.Start3D()
    for _, i in pairs(ArcCW.PhysBullets) do

        local pro = i.Profile or 1
        if pro == 7 then continue end -- legacy behavior: 7 is the "invisible" tracer
        local bulinfo = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[pro] or ""]

        if bulinfo == nil then
            print("Failed to find bullet info for profile " .. tostring(i) .. "!")
            continue
        end

        -- Draw function override
        if bulinfo.DrawBullet and bulinfo:DrawBullet(i) then
            continue
        end

        i.VelStart = i.VelStart or Vector(i.Vel)
        i.PosStart = i.PosStart or Vector(i.Pos)

        local rpos = i.Pos

        local vel = i.Vel - LocalPlayer():GetVelocity()
        local veldir = vel:GetNormalized()
        local dampfraction = 1

        -- Solve two problems presented by physbullets
        -- 1: they come out of the player's eyes and it looks jarring
        -- 2: they fly too fast and so tracers aren't that noticeable
        if !i.DampenVelocity then i.DampenVelocity = math.Clamp(math.floor(i.VelStart:Length() ^ (bulinfo.dampen_factor or 0.65)), 128, 4096) end
        if !i.Imaginary and i.Travelled <= i.DampenVelocity then
            if IsValid(i.Weapon) and i.Weapon:GetOwner() == LocalPlayer() then
                -- Lerp towards the muzzle position, effectively slowing and dragging the bullet back.
                -- Bullet will appear to accelerate suddenly near the threshold, but it should be too fast to notice.

                if !i.TracerOrigin then
                    i.TracerOrigin = i.Weapon:GetTracerOrigin() or i.StartPos
                end

                dampfraction = (i.Travelled / i.DampenVelocity) ^ 0.5
                rpos = LerpVector(dampfraction, i.TracerOrigin or i.PosStart, i.Pos)

                if GetConVar("developer"):GetInt() >= 2 then
                    debugoverlay.Cross(i.TracerOrigin, 2, 5, Color(255, 0, 0), true)
                    debugoverlay.Cross(rpos, 8, 5, Color(0, 255, 255), true)
                    debugoverlay.Line(rpos, i.Pos, 5, Color(250, 150, 255), true)
                    debugoverlay.Cross(i.Pos, 4, 5, Color(255, 0, 255), true)
                    debugoverlay.Text(rpos, math.Round(dampfraction, 2), 5)
                end
            else
                -- don't draw too close to the firing position if we can't lerp, or it will look ugly
                continue
            end
        end

        local col = bulinfo.color

        -- TODO: Tracer sizes are still kinda wacky
        local sqrdist = EyePos():DistToSqr(rpos)
        local distgrow = math.log(sqrdist) ^ 0.5
        local size = math.max(0, (bulinfo.size_min or 1) * 0.25 + (bulinfo.size or 1) * distgrow)
        local headsize = size * math.Clamp(sqrdist / 4000000, 1, 16)

        -- Head is less visible on the sides; it's mostly useful for the shooter and target as tracers aren't very visible from front and back
        local dot = EyeAngles():Forward():Dot(veldir)
        dot = math.Clamp(((dot * dot) - 0.5) * 2, 0, 1)
        headsize = headsize * dot
        --size = size * math.Clamp(1 - dot, 0.5, 1)

        if bulinfo.sprite_head != false then
            render.SetMaterial(bulinfo.sprite_head or head)
            render.DrawSprite(rpos, headsize, headsize, col)
        end

        if bulinfo.sprite_tracer != false and !ArcCW.ConVars["fasttracers"]:GetBool() then
            render.SetMaterial(bulinfo.sprite_tracer or tracer)
            local len = math.min(vel:Length() * (bulinfo.tail_length or 0.015), 512, (rpos - (i.TracerOrigin or i.PosStart)):Length())
            local pos2 = rpos - veldir * len
            if i.TracerOrigin and CurTime() - i.StartTime <= engine.TickInterval() then
                pos2 = rpos - (rpos - i.TracerOrigin):GetNormalized() * len
            end
            render.DrawBeam(rpos, pos2, size * 0.25, 0, 0.5, col)
            debugoverlay.Line(rpos, pos2, 7, Color(0, 255, 0), true)
        end

        if bulinfo.model then
            if !IsValid(i.CSModel) then
                i.CSModel = ClientsideModel(bulinfo.model)
                i.CSModel:SetNoDraw(bulinfo.model_nodraw)
                if bulinfo.particle then
                    i.CSParticle = CreateParticleSystem(i.CSModel, bulinfo.particle, PATTACH_ABSORIGIN_FOLLOW, 1)
                end
            end
            i.CSModel:SetPos(rpos)
            i.CSModel:SetAngles(i.Vel:Angle())
            i.CSModel:SetVelocity(i.Vel)
            if i.CSParticle then
                i.CSParticle:StartEmission()
                i.CSParticle:SetSortOrigin(IsValid(i.Weapon) and i.Weapon:GetShootSrc() or vector_origin)
            end
        end
    end
    cam.End3D()
end

hook.Add("PreDrawEffects", "ArcCW_DrawPhysBullets", ArcCW.DrawPhysBullets)

hook.Add("PostCleanupMap", "ArcCW_CleanPhysBullets", function()
    ArcCW.PhysBullets = {}
end)

-- Can't run now or files after this in load order cannot add them properly
hook.Add("InitPostEntity", "ArcCW_AddPhysBullets", function()
    hook.Run("ArcCW_InitBulletProfiles")
end)
--PATH lua/arccw/client/cl_singleplayer.lua:
net.Receive("arccw_sp_anim", function(len, ply)
    local wep    = LocalPlayer():GetActiveWeapon()
    local key    = net.ReadString()
    local mul    = net.ReadFloat()
    local start  = net.ReadFloat()
    local time   = net.ReadBool()
    --local skip   = net.ReadBool() Unused
    local ignore = net.ReadBool()

    if !wep.ArcCW then return end

    wep:PlayAnimation(key, mul, false, start, time, false, ignore)
end)

net.Receive("arccw_sp_checkpoints", function(len, ply)
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep.ArcCW then return end

    wep.CheckpointAnimation = nil
end)

net.Receive("arccw_sp_lhikanim", function(len, ply)
    local wep  = LocalPlayer():GetActiveWeapon()
    local key  = net.ReadString()
    local time = net.ReadFloat() or -1

    if !wep.ArcCW then return end

    wep:DoLHIKAnimation(key, time)
end)

net.Receive("arccw_sp_health", function(len, ply)
    local ent = net.ReadEntity()

    if !IsValid(ent) then return end

    ent:SetHealth(0)
    ent.ArcCWCLHealth = 0
end)

local clr_b = Color(160, 190, 255)
local clr_r = Color(255, 190, 190)

concommand.Add("arccw_listvmanims", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetSequenceList()

    for i = 0, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\t", alist[i], "\n     [")
        MsgC(clr_r, "\t", vm:SequenceDuration(i), "\n")
    end
end)

concommand.Add("arccw_listvmbones", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    for i = 0, (vm:GetBoneCount() - 1) do
        print(i .. " - " .. vm:GetBoneName(i))
    end
end)

concommand.Add("arccw_listvmatts", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetAttachments()

    for i = 1, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\tindex : ", alist[i].id, "\n     [")
        MsgC(clr_r, "\tname: ", alist[i].name, "\n")
    end
end)

concommand.Add("arccw_listvmbgs", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetBodyGroups()

    for i = 1, #alist do
        local alistsm = alist[i].submodels
        local active = vm:GetBodygroup(alist[i].id)
        MsgC(clr_b, alist[i].id, " --  ")
        MsgC(color_white, "\t", alist[i].name, "\n")
        if alistsm then
            for j = 0, #alistsm do
                MsgC(active == j and color_white or clr_b, "\t" .. j, " - ")
                MsgC(active == j and color_white or clr_r, alistsm[j], "\n")
            end
        end
    end
end)

local lastwpn = nil

hook.Add("Think", "ArcCW_FixDeploy", function()
    --if !game.SinglePlayer() then return end
    local wep = LocalPlayer():GetActiveWeapon()

    if wep.ArcCW and wep != lastwpn then wep:Deploy() end

    lastwpn = wep
end)
--PATH lua/arccw/client/cl_sway.lua:
local enabled = ArcCW.ConVars["enable_sway"]
local mult = ArcCW.ConVars["mult_sway"]

ArcCW.SwayDir = 0

function ArcCW.Sway(cmd)

    local ply = LocalPlayer()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    local ang = cmd:GetViewAngles()

    if wpn:GetState() == ArcCW.STATE_SIGHTS and !wpn.NoSway and enabled:GetBool() then
        local sway = mult:GetFloat() * wpn:GetBuff("Sway")
        --sway = sway * math.Clamp(1 / (wpn:GetActiveSights().ScopeMagnification or 1), 0.1, 1)
        if wpn:InBipod() then
            sway = sway * (wpn.BipodDispersion * wpn:GetBuff_Mult("Mult_BipodDispersion"))
        end
        if sway > 0.05 then
            ang.p = math.Clamp(ang.p + math.sin(CurTime() * 1.25) * FrameTime() * sway, -89, 89)

            ArcCW.SwayDir = ArcCW.SwayDir + math.Rand(-360, 360) * FrameTime() / math.min(sway, 1)

            ang.p = ang.p + math.sin(ArcCW.SwayDir) * FrameTime() * sway
            ang.y = ang.y + math.cos(ArcCW.SwayDir) * FrameTime() * sway

            -- ang.p = ang.p + math.Rand(-1, 1) * FrameTime() * sway
            -- ang.y = ang.y + math.Rand(-1, 1) * FrameTime() * sway

            cmd:SetViewAngles(ang)
        end
    end
end

hook.Add("CreateMove", "ArcCW_Sway", ArcCW.Sway)
--PATH lua/arccw/client/cl_ttt.lua:
if engine.ActiveGamemode() != "terrortown" then return end

ArcCW.ConVars["ttt_inforoundstart"] = CreateClientConVar("arccw_ttt_inforoundstart", "1", true, false, "Whether to show ArcCW config every round.")
ArcCW.ConVars["ttt_rolecrosshair"] = CreateClientConVar("arccw_ttt_rolecrosshair", "1", true, false, "Whether to color your crosshair according to your role.")

ArcCW.TTT_AttInfo = ArcCW.TTT_AttInfo or {}

local TTTPanel = {
    { type = "h", text = "#arccw.ttt_serverhelp" },
    { type = "b", text = "#arccw.cvar.ttt_replace", var = "arccw_ttt_replace", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_replace", var = "arccw_ttt_ammo", sv = true },
    { type = "b", text = "#arccw.cvar.ttt_atts", var = "arccw_ttt_atts", sv = true },
    { type = "o", text = "#arccw.cvar.ttt_customizemode", var = "arccw_ttt_customizemode", sv = true,
            choices = {[0] = "#arccw.cvar.ttt_customizemode.0", [1] = "#arccw.cvar.ttt_customizemode.1", [2] = "#arccw.cvar.ttt_customizemode.2", [3] = "#arccw.cvar.ttt_customizemode.3"}},
    { type = "o", text = "#arccw.cvar.ttt_bodyattinfo", var = "arccw_ttt_bodyattinfo", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.ttt_bodyattinfo.1", [2] = "#arccw.cvar.ttt_bodyattinfo.2"}},
    { type = "c", text = "#arccw.cvar.ttt_bodyattinfo.help"},
}

net.Receive("arccw_ttt_bodyattinfo", function()
    local rag = net.ReadEntity()
    rag = rag:EntIndex()
    ArcCW.TTT_AttInfo[rag] = {}
    local atts = net.ReadUInt(8)
    for i = 1, atts do
        local id = net.ReadUInt(ArcCW.GetBitNecessity())
        if id != 0 then
            --ArcCW.TTT_AttInfo[rag][i] = ArcCW.AttachmentIDTable[id]
            table.insert(ArcCW.TTT_AttInfo[rag], ArcCW.AttachmentIDTable[id])
        end
    end
end)

hook.Add("TTTBodySearchPopulate", "ArcCW_PopulateHUD", function(processed, raw)

    -- Attachment Info
    local mode = ArcCW.ConVars["ttt_bodyattinfo"]:GetInt()
    local attTbl = ArcCW.TTT_AttInfo[raw.eidx]
    if attTbl and !table.IsEmpty(attTbl) and (mode == 2 or (mode == 1 and raw.detective_search)) then
        local finalTbl = {
            img    = "arccw/ttticons/arccw_dropattinfo.png",
            p = 10.5, -- Right after the murder weapon
            text = ArcCW.GetTranslation(mode == 1 and "ttt.bodyatt.founddet" or "ttt.bodyatt.found")
        }
        local count = table.Count(attTbl)
        if count == 1 then
            if !ArcCW.AttachmentTable[attTbl[1]] then return end
            local printName = ArcCW.GetTranslation("name." .. attTbl[1]) or ArcCW.AttachmentTable[attTbl[1]].PrintName
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att1", {att = printName})
        elseif count == 2 then
            if !ArcCW.AttachmentTable[attTbl[1]] or !ArcCW.AttachmentTable[attTbl[2]] then return end
            local printName1 = ArcCW.GetTranslation("name." .. attTbl[1]) or ArcCW.AttachmentTable[attTbl[1]].PrintName
            local printName2 = ArcCW.GetTranslation("name." .. attTbl[2]) or ArcCW.AttachmentTable[attTbl[2]].PrintName
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att2", {att1 = printName1, att2 = printName2})
        else
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att3")
            local comma = false
            for i, v in pairs(attTbl) do
                if v and ArcCW.AttachmentTable[v] then
                    local printName = ArcCW.GetTranslation("name." .. v) or ArcCW.AttachmentTable[v].PrintName
                    finalTbl.text = finalTbl.text .. (comma and ", " or "") .. printName
                    comma = true
                end
            end
            finalTbl.text = finalTbl.text .. "."
        end
        processed.arccw_atts = finalTbl
    end

    -- kill info
    if bit.band(raw.dmg, DMG_BUCKSHOT) == DMG_BUCKSHOT then
        processed.dmg.text = LANG.GetTranslation("search_dmg_buckshot")
        processed.dmg.img = "arccw/ttticons/kill_buckshot.png"
    elseif bit.band(raw.dmg, DMG_NERVEGAS) == DMG_NERVEGAS then
        processed.dmg.text = LANG.GetTranslation("search_dmg_nervegas")
        processed.dmg.img = "arccw/ttticons/kill_nervegas.png"
    end
end)

local function AddLine(parent, str)
    local pw, ph = parent:GetSize()
    local label = vgui.Create("DLabel", parent)
    label:SetSize(pw, ScreenScale(8))
    label:Dock(TOP)
    label:DockMargin(ScreenScale(4), ScreenScale(1), ScreenScale(4), ScreenScale(1))
    label:SetFont("ArcCW_8")
    label:SetTextColor(Color(255,255,255,255))
    label:SetText(str)
    return label
end

local infoBox = nil
local function CreateInfoBox(t)
    if infoBox then
        infoBox:Remove()
        timer.Remove("ArcCW_TTT_InfoBox")
    end

    local totalw, totalh = ScrW() * 0.25, ScrH() * 0.2
    infoBox = vgui.Create("DPanel")
    infoBox:SetSize(totalw, totalh)
    infoBox:SetPos(ScreenScale(2), ScrH() * 0.5)
    infoBox.Paint = function(span, w, h)
        surface.SetDrawColor(Color(0, 0, 0, 150))
        surface.DrawRect(0, 0, w, h)
    end

    local label = vgui.Create("DLabel", infoBox)
    label:SetSize(totalw, ScreenScale(12))
    label:Dock(TOP)
    label:DockMargin(ScreenScale(4), ScreenScale(2), ScreenScale(4), ScreenScale(2))
    label:SetTextColor(Color(255,255,255,255))
    label:SetFont("ArcCW_12")
    label:SetText(ArcCW.GetTranslation("ttt.roundinfo"))

    if ArcCW.ConVars["ttt_replace"]:GetBool() then
        AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.replace"))
    end

    local cmode_str = "ttt.roundinfo.cmode" .. ArcCW.ConVars["ttt_customizemode"]:GetInt()
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.cmode") .. " " .. ArcCW.GetTranslation(cmode_str))

    local att_str = ""
    local att_cvar = ArcCW.ConVars["attinv_free"]:GetBool()
    local att_cvar2 = ArcCW.ConVars["attinv_lockmode"]:GetBool()
    local att_cvar3 = ArcCW.ConVars["attinv_loseondie"]:GetBool()
    if att_cvar then
        att_str = "ttt.roundinfo.free"
    elseif att_cvar2 then
        att_str = "ttt.roundinfo.locking"
    else
        att_str = "ttt.roundinfo.inv"
    end
    att_str = ArcCW.GetTranslation(att_str)
    if att_cvar3 == 0 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.persist")
    elseif !att_cvar and !att_cvar2 and att_cvar3 == 2 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.drop")
    end
    if ArcCW.ConVars["atts_pickx"]:GetInt() > 0 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.pickx") .. " " .. ArcCW.ConVars["atts_pickx"]:GetInt()
    end
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.attmode") .. " " .. att_str)

    local binfo_cvar = ArcCW.ConVars["ttt_bodyattinfo"]:GetInt()
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.bmode") .. " " .. ArcCW.GetTranslation("ttt.roundinfo.bmode" .. binfo_cvar))

    if ArcCW.ConVars["ammo_replace"]:GetBool() and ArcCW.ConVars["mult_ammohealth"]:GetFloat() > 0 then
        local ainfo_cvar = ArcCW.ConVars["ammo_detonationmode"]:GetInt()
        local ainfo_str = ArcCW.GetTranslation("ttt.roundinfo.amode" .. ainfo_cvar)
        if ArcCW.ConVars["ammo_chaindet"]:GetBool() then
            ainfo_str = ainfo_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.achain")
        end
        AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.amode") .. " " .. ainfo_str)
    end


    timer.Create("ArcCW_TTT_InfoBox", t, 1, function()
        if infoBox then infoBox:Remove() end
    end)
end
concommand.Add("arccw_ttt_info", function()
    CreateInfoBox(20)
end, nil, "Shows a panel detailing current ArcCW settings.")

local turnoff = true
hook.Add("TTTPrepareRound", "ArcCW_TTT_Info", function()
    if ArcCW.ConVars["ttt_inforoundstart"]:GetBool() then
        CreateInfoBox(15)
        if turnoff then
            turnoff = false
            chat.AddText(Color(255,255,255), "To turn off ArcCW config info, type 'arccw_ttt_inforoundstart 0' in console.")
        end
    end
    ArcCW.TTT_AttInfo = {}
end)

if !TTT2 then
    hook.Add("TTTSettingsTabs", "ArcCW_TTT", function(dtabs)

        local padding = dtabs:GetPadding() * 2

        local panellist = vgui.Create("DPanelList", dtabs)
        panellist:StretchToParent(0,0,padding,0)
        panellist:EnableVerticalScrollbar(true)
        panellist:SetPadding(10)
        panellist:SetSpacing(10)

        local dgui = vgui.Create("DForm", panellist)
        dgui:SetName("#arccw.menus.ttt_client")
        dgui:Help("#arccw.ttt_clienthelp")
        dgui:CheckBox("#arccw.cvar.ttt_inforoundstart", "arccw_ttt_inforoundstart")
        dgui:CheckBox("#arccw.cvar.ttt_rolecrosshair", "arccw_ttt_rolecrosshair")
        panellist:AddItem(dgui)

        local dgui2 = vgui.Create("DForm", panellist)
        dgui2:SetName("#arccw.menus.ttt_server")
        ArcCW.GeneratePanelElements(dgui2, TTTPanel)
        panellist:AddItem(dgui2)

        for menu, data in SortedPairs(ArcCW.ClientMenus) do
            local form = vgui.Create("DForm", panellist)
            form:SetName(data.text)
            data.func(form, true)
            form:SetExpanded(false)
            panellist:AddItem(form)
        end

        dtabs:AddSheet("ArcCW", panellist, "icon16/gun.png", false, false, "ArcCW")
    end)
end

-----------------------------
-- TTT2-specific support
-----------------------------

hook.Add("TTTRenderEntityInfo", "ArcCW_TTT2_Weapons", function(tData)
    local client = LocalPlayer()
    local ent = tData:GetEntity()


    if !IsValid(client) or !client:IsTerror() or !client:Alive()
    or !IsValid(ent) or tData:GetEntityDistance() > 100 or !ent:IsWeapon()
    or !ent.ArcCW or ent.Throwing then
        return
    end

    if tData:GetAmountDescriptionLines() > 0 then
        tData:AddDescriptionLine()
    end

    local pickx = ArcCW.ConVars["atts_pickx"]:GetInt()

    if !ent.CertainAboutAtts then
        tData:AddDescriptionLine("??? Attachments")
    elseif ent.Attachments and ent:CountAttachments() > 0 then
        tData:AddDescriptionLine(tostring(ent:CountAttachments()) .. (pickx > 0 and ("/" .. pickx) or "") .. ArcCW.GetTranslation("ttt.attachments"), nil)
        for i, v in pairs(ent.Attachments) do
            local attName = v.Installed
            if !attName and !v.MergeSlots then
                continue
            elseif v.MergeSlots and !attName then
                for _, s in pairs(v.MergeSlots) do
                    if ent.Attachments[s] and ent.Attachments[s].Installed then
                        attName = ent.Attachments[s].Installed
                        break
                    end
                end
                if !attName then continue end
            end
            local attTbl = ArcCW.AttachmentTable[attName]
            if attTbl and v.PrintName and attTbl.PrintName then
                local printName = ArcCW.GetTranslation("name." .. attName) or attTbl.PrintName
                tData:AddDescriptionLine(ArcCW.TryTranslation(v.PrintName) .. ": " .. printName, nil, {attTbl.Icon})
            end
        end
    end
end)

hook.Add("TTTRenderEntityInfo", "ArcCW_TTT2_Ammo", function(tData)
    local client = LocalPlayer()
    local ent = tData:GetEntity()

    if !IsValid(client) or !client:IsTerror() or !client:Alive()
    or !IsValid(ent) or tData:GetEntityDistance() > 100 or !scripted_ents.IsBasedOn(ent:GetClass(), "arccw_ammo") then
        return
    end

    -- enable targetID rendering
    tData:EnableText()
    tData:EnableOutline()
    tData:SetOutlineColor(client:GetRoleColor())

    tData:SetTitle(ent.PrintName)
    tData:SetSubtitle(ArcCW.GetTranslation("ttt.ammo") .. ent:GetNWInt("truecount", ent.AmmoCount))
end)

function ArcCW.TTT2_PopulateSettings(parent, title, tbl)

    local form = vgui.CreateTTT2Form(parent, title)

    for _, data in pairs(tbl) do

        local name = data.text
        if string.Left(name, 1) == "#" then name = string.sub(name, 2) end

        if data.type == "h" or data.type == "c" then
            form:MakeHelp({
                label = name
            })
        end

        local cvar = GetConVar(data.var or "")
        if !cvar then continue end
        local option

        if data.type == "b" then
            option = form:MakeCheckBox({
                label = name,
                default = tobool(cvar:GetDefault()),
                initial = cvar:GetBool(),
                OnChange = function(self, value)
                    ArcCW.NetworkConvar(data.var, value, self)
                end,
            })
            option.TickCreated = UnPredictedCurTime()
        elseif data.type == "i" or data.type == "f" then
               option = form:MakeSlider({
                    label = name,
                    min = data.min,
                    max = data.max,
                    decimal = data.type == "i" and 0 or 2,
                    default = tonumber(cvar:GetDefault()),
                    initial = data.type == "i" and cvar:GetInt() or cvar:GetFloat(),
                    OnChange = function(self, value)
                        ArcCW.NetworkConvar(data.var, value, self)
                    end,
                })
                option.TickCreated = UnPredictedCurTime()
        elseif data.type == "o" then
            option = form:MakeComboBox({
                label = name,
                default = tonumber(cvar:GetDefault()),
                initial = cvar:GetInt(),
                --choices = data.choices,
                OnChange = function(self, _, _, value)
                    ArcCW.NetworkConvar(data.var, value, self)
                end,
            })
            option.TickCreated = UnPredictedCurTime()
            for k, v in pairs(data.choices) do
                option:AddChoice(v, k)
            end
        end
    end
end

-- In almost all cases TTT2 lang names are identical to ISO 639-1; except for simplified / traditional Chinese
local ttt_langtranslate = {
    ["zh-cn"] = "zh_hans", -- i find it funny the original ttt's lang name for this is "simpchinese". haha simp
    ["zh-tw"] = "zh_tw",
}

-- This is only necessary in TTT2, where we use its interface for convars
function ArcCW.TTT2_LoadClientLangs()
    if !TTT2 then return end
    local files = file.Find("arccw/client/cl_languages/*", "LUA")
    for _, v in pairs(files) do
        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))

        local lang = exp[#exp]
        lang = ttt_langtranslate[lang] or LANG.GetNameFromAlias(lang)

        -- cannot add to languages that do not exist
        if !LANG.IsLanguage(lang) then
            continue
        end

        include("arccw/client/cl_languages/" .. v)
        for phrase, str in pairs(L) do
            LANG.AddToLanguage(lang, phrase, str)
        end
        print("Loaded ArcCW cl_language file " .. v .. " with " .. table.Count(L) .. " strings for TTT2.")
        L = nil
    end
end
hook.Add("PostGamemodeLoaded", "ArcCW_TTT2_Localization", ArcCW.TTT2_LoadClientLangs)
--PATH lua/autorun/arccw_kraken_sharedsounds.lua:
-- Interaction
sound.Add( {
    name = "ArcCW_Kraken.Grab",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/manual_reset_1.mp3",
        "shared/manual_reset_2.mp3",
        "shared/manual_reset_3.mp3",
        "shared/manual_reset_4.mp3",
    }
} )

-- Corebass
sound.Add( {
    name = "ArcCW_Kraken.HeavyCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/heavy/corebass_heavy_1.wav",
        "shared/corebass/heavy/corebass_heavy_2.wav",
        "shared/corebass/heavy/corebass_heavy_3.wav",
        "shared/corebass/heavy/corebass_heavy_4.wav",
        "shared/corebass/heavy/corebass_heavy_5.wav",
        "shared/corebass/heavy/corebass_heavy_6.wav",
        "shared/corebass/heavy/corebass_heavy_7.wav",
        "shared/corebass/heavy/corebass_heavy_8.wav",
        "shared/corebass/heavy/corebass_heavy_9.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.LightCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/light/corebass_light_1.wav",
        "shared/corebass/light/corebass_light_2.wav",
        "shared/corebass/light/corebass_light_3.wav",
        "shared/corebass/light/corebass_light_4.wav",
        "shared/corebass/light/corebass_light_5.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.StandardCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/rifle/corebass_rifle_1.wav",
        "shared/corebass/rifle/corebass_rifle_2.wav",
        "shared/corebass/rifle/corebass_rifle_3.wav",
        "shared/corebass/rifle/corebass_rifle_4.wav",
        "shared/corebass/rifle/corebass_rifle_6.wav",
        "shared/corebass/rifle/corebass_rifle_5.wav",
    }
} )
--PATH lua/autorun/atrt_sounds.lua:
return gluapack()()
--PATH lua/autorun/aura_canofen_lvs_capital_ship_config.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/it.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/pt-br.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/autorun/bodyman_init.lua:
print("Initializing Darkrp Bodygroups Manager")

BODYMAN = {}

if SERVER then
	include("bodyman/bodyman_server.lua")
	include("bodyman/bodyman_server_hooks.lua")
	include("bodyman/bodyman_config.lua")

	AddCSLuaFile("bodyman/bodyman_client.lua")
	AddCSLuaFile("bodyman/arizard_derma.lua")
	AddCSLuaFile("bodyman/bodyman_config.lua")
else
	include("bodyman/bodyman_config.lua")
	include("bodyman/bodyman_client.lua")
	include("bodyman/arizard_derma.lua")
end

function InverseLerp( pos, p1, p2 )

	local range = 0
	range = p2-p1

	if range == 0 then return 1 end

	return ((pos - p1)/range)

end

function BODYMAN:HasSkin( ply, skindex )
	local has = true
	local skincount = ply:SkinCount()
	-- skins start at 0 but lua tables start at 1
	-- skincount-1 is last skin
	-- therefore skindex must be between 0 and skincount-1 inclusive
	if skindex > skincount-1 then has = false end
	if skindex < 0 then has = false end

	return has
end

-- need an algorithm which checks if a bodygroups exists for a player
function BODYMAN:HasBodyGroup( ply, name, idx )
	-- PLAYER ply, STRING name, INT idx
	local modelgroups = ply:GetBodyGroups()
	local has = false
	local bgid = -1

	for k,v in ipairs( modelgroups ) do
		if v.name == name then
			bgid = v.id
		end
	end

	if bgid >= 0 then
		-- add 1 to the bgid to get the table index
		-- because lua tables start at 1
		-- but bg ids start at 0

		-- we already know that it exists, because it's been set by the previous for loop.
		-- lets make sure the submodel (idx) exists
		if modelgroups[bgid + 1].submodels[idx] then
			has = true -- we can set it to true if we know it exists
		end
	end

	return has
end

-- For when we are Closets-only
function BODYMAN:CloseEnoughCloset( ply )
	-- check if a player is A) looking at a closet and B) within 128 units.
	local range = 128
	local tr = ply:GetEyeTrace()
	local dist = ply:EyePos():Distance( tr.HitPos )

	if tr.Entity then
		if tr.Entity:GetClass() == "bodyman_closet" then
			if dist <= range then
				return true
			end
		end
	end

	return false

end

function BODYMAN:GetAccessLevel( ply )
	if not ply or not IsValid( ply ) then
		return 100
	end
	local access = BODYMAN.Ranks[ ply:GetUserGroup() ] or 10

	local id64 = ply:SteamID64()
	local id = ply:SteamID()

	if BODYMAN.PlayerAccess[id] then
		access = BODYMAN.PlayerAccess[id]
	end

	if BODYMAN.PlayerAccess[id64] then
		access = BODYMAN.PlayerAccess[id64]
	end
	
	return access or 1
end

function BODYMAN:CanAccessCommand( ply, cmd )
	local access = BODYMAN:GetAccessLevel( ply )
	local perm = BODYMAN.Permissions[ cmd ] or 99
	if access >= perm then
		return true
	else
		return false
	end
end
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_config.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/arizard_derma.lua:
return gluapack()()
--PATH lua/autorun/bx_npc.lua:
return gluapack()()
--PATH lua/autorun/civ_pm_female.lua:
return gluapack()()
--PATH lua/autorun/cl_roll.lua:
return gluapack()()
--PATH lua/autorun/dathomir_npc.lua:
return gluapack()()
--PATH lua/autorun/dathomir_npc.lua:
local NPC = {
	Name = "Nightsister (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_f", NPC )


local NPC = {
	Name = "Nightsister (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_h.mdl",
}
list.Set( "NPC", "npc_nightsister_h", NPC )


local NPC = {
	Name = "Nightbrother (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightbrother_f", NPC )


local NPC = {
	Name = "Nightbrother (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_h.mdl",
}
list.Set( "NPC", "npc_nightbrother_h", NPC )

local NPC = {
	Name = "Nightbrother Brawler (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_brawler_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightbrother_brawler_f", NPC )


local NPC = {
	Name = "Nightbrother Brawler (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_brawler_h.mdl",
}
list.Set( "NPC", "npc_nightbrother_brawler_h", NPC )

local NPC = {
	Name = "Old Daka (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_olddaka_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_olddaka_f", NPC )


local NPC = {
	Name = "Old Daka (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_olddaka_h.mdl",
}
list.Set( "NPC", "npc_nightsister_olddaka_h", NPC )

local NPC = {
	Name = "Mother Talzin (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_mothertalzin_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_mothertalzin_f", NPC )


local NPC = {
	Name = "Mother Talzin (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_mothertalzin_h.mdl",
}
list.Set( "NPC", "npc_nightsister_mothertalzin_h", NPC )

local Category = "CGI Dathomir Warriors"




--PATH addons/!discordintegration/lua/discord/core/classes/eventemitter.lua:
return gluapack()()
--PATH lua/autorun/gmodadminsuite.lua:
return gluapack()()
--PATH lua/gmodadminsuite/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = _G.pon or pon

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end
--PATH lua/gmodadminsuite/modules/fpsbooster/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "FPS Booster",

		--####################### UI PHRASES #######################--

		fps_booster          = "FPS Booster",
		never_show_again     = "Never Show Again",
		never_show_again_tip = "You'll lose the benefits of this menu! Type \"gmodadminsuite fpsbooster\" in your console to open this menu in future.",

		--####################### SETTING PHRASES #######################--

		show_fps                 = "Show FPS",
		multicore_rendering      = "Enable Multicore Rendering",
		multicore_rendering_help = "This is an experimental feature of GMod which boosts FPS by rendering frames using more than a single CPU core.",
		hardware_acceleration    = "Enable Hardware Acceleration",
		shadows                  = "Disable Shadows",
		disable_skybox           = "Disable Skybox",
		sprays                   = "Disable Player Sprays",
		gibs                     = "Disable Gibs",
		gibs_help                = "\"Gibs\" are particles and objects that can fly off of corpses and ragdolls.",

} end }
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/chinese.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/chinese.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "",

            open_menu = "",
            custom_ellipsis = "...",
            usergroup_ellipsis = "...",
            players = "",
            settings = "",
            give_usergroup = "",
            usergroup_is_main = "",
            help = "",
            offline_btn = "...",
            loading_ellipsis = "...",
            unknown = "",
        }
    end
}
--PATH lua/gmodadminsuite/sh_registry_tbl.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Command Manager",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	OperatorOnly = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-commands-wiki",
	Icon = "icon16/script_gear.png",
}
--PATH lua/gmodadminsuite/modules/fpsbooster/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("cl_menu.lua")
else
	GAS:hook("gmodadminsuite:LoadModule:fpsbooster", "LoadModule:fpsbooster", function()
		include("gmodadminsuite/modules/fpsbooster/cl_menu.lua")
	end)
end
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/_gas_info.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Billy's Logs",
	Category = GAS.MODULE_CATEGORY_ADMINISTRATION,
	Wiki = "https://gmodsto.re/blogs-wiki",
	Icon = "icon16/database_lightning.png",
	GmodStore = "6016",
	License = '{"licensee":"76561198835351406","keys":{"xeon-de":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","xeon-us":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"}}'
}
--PATH addons/[admin] gprotect_1.15.101/lua/autorun/gprotect_loader.lua:
if slib and slib.loadFolder then slib.loadFolder("g_protect/", true, {{"g_protect/", "sh_gprotect_config.lua"}, {"g_protect/", "sv_mysql_config.lua"}, {"g_protect/", "sh_gprotect_baseconfig.lua"}, {"g_protect/", "sh_util.lua"}, {"g_protect/server/", "sv_gprotect.lua"}, {"g_protect/", "sh_gprotect.lua"}}, {{"g_protect/client/", "cl_blockedmodels.lua"}, {"g_protect/client/", "cl_buddies.lua"}}) end
hook.Add("slib:loadedUtils", "eP:Init_gProtect", function() slib.loadFolder("g_protect/", true, {{"g_protect/", "sh_gprotect_config.lua"}, {"g_protect/", "sv_mysql_config.lua"}, {"g_protect/", "sh_gprotect_baseconfig.lua"}, {"g_protect/", "sh_util.lua"}, {"g_protect/server/", "sv_gprotect.lua"}, {"g_protect/", "sh_gprotect.lua"}}, {{"g_protect/client/", "cl_blockedmodels.lua"}, {"g_protect/client/", "cl_buddies.lua"}}) end)
--PATH lua/autorun/greyjedi_player.lua:
return gluapack()()
--PATH lua/autorun/imagetool_init.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--


--   
include("imagetool/sh_batch.lua")
AddCSLuaFile("imagetool/sh_batch.lua")
--PATH lua/imagetool/cl_image.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--

--    ,   
if !file.Exists(ImageTool.path .. "/" .. ImageTool.history, "DATA") then
    file.Write(ImageTool.path .. "/" .. ImageTool.history, "[]")
end


--  
function ImageTool:GetHistory()
    local data = {}

    if file.Exists(ImageTool.path .. "/" .. ImageTool.history, "DATA") then
        local info = file.Read(ImageTool.path .. "/" .. ImageTool.history)

        data = util.JSONToTable(info)
    end

    return data
end

--  
function ImageTool:SaveHistory(data)
    data = util.TableToJSON(data)

    file.Write(ImageTool.path .. "/" .. ImageTool.history, data)
end

--     ,   
function ImageTool:FindInCache(data)
    if self.cacheMaterials[data] then
        return self.cacheMaterials[data]
    end
end

--    uniqueID
function ImageTool:GetImage(data)
    local path = Format("%s/%s", self.path, game.GetMap())
    local filename = data .. ".png"

    local cache = self:FindInCache(data)
    if cache then
        return cache
    end

    return Material("data/" .. path .. "/" .. filename)
end

--  
function ImageTool:DownloadImage(path, data)
    if !self.requestList[data] or CurTime() >= self.requestList[data] then
        if self:IsUsesTool(LocalPlayer()) then
            LocalPlayer():ChatPrint(self.prefix .. " Download the picture: " .. data)
        end

        --   
        http.Fetch(data, function(body, size, headers)
            local extension = self:CheckExtensionImage(body, headers)
            if !extension then return end

            file.Write(path, body)
        end)

        self.requestList[data] = CurTime() + 10
    end
end

--    URL
function ImageTool:LoadingURL(data)
    local uniqueID = util.CRC(data) --  ID 

    --    ,   
    if self:FindInCache(uniqueID) then
        return self:FindInCache(uniqueID)
    end

    local path = Format("%s/%s", self.path, game.GetMap())
    local filename = uniqueID .. ".png"

    --     
    if file.Exists(path .. "/" .. filename, "DATA") then
        local mat = self:GetImage(uniqueID)

        if mat and !mat:IsError() then
            if self:IsUsesTool(LocalPlayer()) then
                LocalPlayer():ChatPrint(self.prefix .. " Image has been uploaded successfully: " .. data)
            end

            self.cacheMaterials[uniqueID] = mat --    

            return mat
        end

        if !self.notifyErr[data] or CurTime() >= self.notifyErr[data] then
            if self:IsUsesTool(LocalPlayer()) then
                LocalPlayer():ChatPrint(self.prefix .. " It is not possible to upload a picture: " .. data .. ". Repeated request in 5 seconds!")
            end

            self.notifyErr[data] = CurTime() + 5

            --     
            return self:DownloadImage(path .. "/" .. filename, data)
        end
    end

    --    ,   
    self:DownloadImage(path .. "/" .. filename, data)
end

--     TOOL-
function ImageTool:DrawImageTool()
    local client = LocalPlayer()

    --       ,   
    local data = self:GetToolData(client)
    if !data then return end

    self:Start3D2D(data)
end

local function clear()
    if IsValid(ImageTool.historyPanel.List) then
        ImageTool.historyPanel.List:Remove()
    end

    local historylist = ImageTool.historyPanel:GetChildren()[1]

    for k, v in ipairs(historylist:GetChildren()) do
        if v.image then
            v:Remove()
        end
    end
end

local scale = 0.2
local function set_size(panel1, panel2, mat)
    if panel1.setsize then return end

    local w, h = mat:Width() * scale, mat:Height() * scale

    panel1:SetSize(w, h)
    panel2:SetSize(w, h)

    panel1.setsize = true
end

local function drawing(url, w, h, panel1, panel2)
    local imageMaterial = ImageTool:LoadingURL(url)

    if type(imageMaterial) == "IMaterial" and !imageMaterial:IsError() then
        set_size(panel1, panel2, imageMaterial)

        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(imageMaterial)
        surface.DrawTexturedRect(5, 5, w - 10, h - 10)
    else
        local alpha, dotStr = ImageTool:Anim()

        surface.SetDrawColor(255, alpha, 255)
        surface.DrawRect(0, 0, w, h)
        draw.DrawText("Loading" .. dotStr, "Default", w / 2, h / 2 - 10, Color(alpha, 0, 0), TEXT_ALIGN_CENTER)
    end
end

local function derma_menu(image, id, url)
    local menu = DermaMenu() 
        menu:AddOption("Replace URL", function()
            local l = "imagetool_"

            RunConsoleCommand(l .. "url", url)
        end):SetIcon("icon16/disconnect.png")

        menu:AddOption("Copy URL", function()
            SetClipboardText(url)
        end):SetIcon("icon16/disk.png")

        menu:AddOption("Remove", function()
            local history = ImageTool:GetHistory() or {}
            table.remove(history, id)

            ImageTool:SaveHistory(history)

            if IsValid(image) then
                image:Remove()
            end
        end):SetIcon("icon16/delete.png")
    menu:Open()
end

--  
function ImageTool:LoadingHistory()
    local panel = ImageTool.historyPanel
    if !IsValid(panel) then return end

    clear()

    local history = ImageTool:GetHistory() or {}
    for id, url in SortedPairs(history, true) do
        local image = panel:Add("Panel")
        image.image = true
        image:SetTall(100)
        image:Dock(TOP)
        image:DockMargin(2, 2, 2, 2)

        local button = image:Add("DButton")
        button:SetText("")
        button:SetSize(100, 100)
        button:Dock(LEFT)
        button.alpha = 0
        button.Paint = function(this, w, h)
            this.alpha = Lerp(FrameTime() * 10, this.alpha, this:IsHovered() and 200 or 0)

            surface.SetDrawColor(255, 61, 96, this.alpha)
            surface.DrawRect(0, 0, w, h)

            drawing(url, w, h, image, this)

            surface.SetDrawColor(255, 61, 96, 150)
            surface.DrawOutlinedRect(0, 0, w, h, 1)
        end
        button.DoClick = function()
            derma_menu(image, id, url)
        end
    end

    panel.List = ListImage

    panel:Rebuild()
end

--   )
function ImageTool:Anim()
    local systime = SysTime()
    local alpha = math.sin(systime * 2) * 255
    local dotA = math.sin(systime * 1) * 255
    local dot = math.floor(math.abs(dotA) * 0.015)
    local dotStr = string.rep(".", dot + 1)

    return alpha, dotStr
end

--  cam3d2d   
function ImageTool:Start3D2D(data)
    if !data then return end

    local alpha = tonumber(data.alpha) or 255
    local scale = (tonumber(data.scale) or 40) / 100
    local brightness = tonumber(data.brightness) or 255
    local imageMaterial = self:LoadingURL(data.url)

    local w, h = tonumber(data.width), tonumber(data.height)
    if !isnumber(w) or !isnumber(h) then return end -- number expected, got string

    -- 
    cam.Start3D2D(data.position, data.angles, scale)
        render.PushFilterMin(TEXFILTER.ANISOTROPIC)
        render.PushFilterMag(TEXFILTER.ANISOTROPIC)
            if type(imageMaterial) == "IMaterial" and !imageMaterial:IsError() then --    
                surface.SetDrawColor(brightness, brightness, brightness, alpha)
                surface.SetMaterial(imageMaterial)
                surface.DrawTexturedRect(0, 0, w, h)
            else
                local alphaStr, dotStr = ImageTool:Anim()

                surface.SetDrawColor(255, alphaStr, 255)
                surface.DrawRect(0, 0, w, h)
                draw.DrawText("Loading" .. dotStr, "Default", w / 2, h / 2 - 10, Color(alphaStr, 0, 0), TEXT_ALIGN_CENTER)
            end
        render.PopFilterMag()
        render.PopFilterMin()
    cam.End3D2D()
end
--PATH lua/autorun/kalani.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_hud.lua:

LSCS_HUD_POINTS_FORCE = 1
LSCS_HUD_POINTS_BLOCK = 2
LSCS_HUD_POINTS_ADVANTAGE = 3
LSCS_HUD_STANCE = 4

function LSCS:HUDShouldHide( LSCS_HUD )
	local ShouldDraw = hook.Run( "LSCS:HUDShouldDraw", LSCS_HUD )

	if ShouldDraw == false then return true end

	-- if ShouldDraw == true then return false end -- should the hook overpower client settings? i dont know.. If you have this edgecase please make a github issue and i will change this.

	return not LSCS.DrawHud
end

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_convar.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_lscs_menu.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 20,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LSCS_FONT", THE_FONT )

THE_FONT.size = 12
THE_FONT.weight = 500
surface.CreateFont( "LSCS_FONT_SMALL", THE_FONT )

THE_FONT.font = "Ink Free"
THE_FONT.size = 16
THE_FONT.weight = 1000
surface.CreateFont( "LSCS_VERSION", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 1000
surface.CreateFont( "LSCS_FONT_MAXIMUM", THE_FONT )

local function bezier(p0, p1, p2, p3, t)
	local e = p0 + t * (p1 - p0)
	local f = p1 + t * (p2 - p1)
	local g = p2 + t * (p3 - p2)

	local h = e + t * (f - e)
	local i = f + t * (g - f)

	local p = h + t * (i - h)

	return p
end

local function DrawFrame( w, h, offset, thickness )
	surface.DrawRect( offset, offset, thickness, h - offset * 2 )
	surface.DrawRect( w - offset - thickness, offset, thickness, h - offset * 2 )

	surface.DrawRect( offset, offset, w - offset * 2 - thickness, thickness )
	surface.DrawRect( offset, h - offset - thickness, w - offset * 2 - thickness, thickness )
end

local function DrawBezier( startPos, endPos )
	local detail = 15
	local p2 = Vector(endPos.x,startPos.y,0)
	local p3 = Vector(startPos.x,endPos.y,0)

	for i = 1,detail do
		local sp = bezier(startPos, p2, p3, endPos, (i - 1) / detail)
		local ep = bezier(startPos, p2, p3, endPos, i / detail)
		surface.DrawLine( sp.x, sp.y, ep.x, ep.y )
	end
end

local Gradient = Material("vgui/gradient-l")
local ClickMat = Material("sun/overlay")

local menu_white_dim = Color(100,100,100,255)
local menu_white = Color(255,255,255,255)
local menu_dark = Color(24,30,54,255)
local menu_dim = Color(37,42,64,255)
local menu_light = Color(46,51,73,255)
local menu_black = Color(31,31,31,255)
local menu_text = Color(0,127,255,255)

local icon_lscs = Material("lscs/ui/icon256.png")

local icon_inventory = Material("lscs/ui/inventory.png")
local icon_hilt = Material("lscs/ui/hilt.png")
local icon_stance = Material("lscs/ui/stance.png")
local icon_force = Material("lscs/ui/force.png")
local icon_settings = Material("lscs/ui/settings.png")

local icon_check = Material("lscs/ui/check.png")
local icon_cross = Material("lscs/ui/cross.png")

local icon_hand = Material("lscs/ui/hand.png")
local icon_lhand = Material("lscs/ui/hand_l.png")
local icon_rhand = Material("lscs/ui/hand_r.png")

local icon_load_version = Material("gui/html/refresh")

local icon_missing = Material( "lscs/ui/noicon.png" )
local icon_invert = Material( "lscs/ui/logo_invert.png")
local icon_steam = Material("lscs/ui/steam.png")
local icon_youtube = Material("lscs/ui/youtube.png")
local icon_discord = Material("lscs/ui/discord.png")
local icon_github = Material("lscs/ui/github.png")

local zoom_mat = Material( "vgui/zoom" )
local gradient_mat = Material( "gui/gradient" )
local adminMat = Material( "icon16/shield.png" )

local function BaseButtonClick( self, sound )
	if not self:IsEnabled() then return end

	sound = sound or "ui/buttonclick.wav"

	surface.PlaySound( sound )
	self.smScale = 1
end

local function DrawButtonClick( self, w, h ) 
	local Col = menu_white_dim
	if self:IsHovered() then
		Col = menu_white
	end
	if not self:IsEnabled() then
		Col = menu_text
	end

	self.smScale = self.smScale or 0
	self.smScale = self.smScale - math.min(self.smScale,RealFrameTime() * 3)

	local Size = self.smScale

	if Size > 0.05 then
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 25), 150, 200, 255, 255 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 15), 150, 200, 255, 255 * 0.5 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 10), 150, 200, 255, 255 * 0.2 * Size )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150 * Size, 200 * Size, 255 * Size, 255 * Size )
		surface.DrawTexturedRect( w * 0.5 - w * 0.5 * Size * 2, h * 0.5 - h * 0.5 * Size * 2, w * Size * 2, h * Size * 2 )
	end

	return Col
end

local ForceNum = 1
local StanceNum = 1
local Frame

local FrameBarHeight = 30

local FrameSizeX = 870
local FrameSizeY = 550 + FrameBarHeight

local SelectorHeight = 80 * 6
local SelectorWidth = 80
local SelectorWidthActive = 196

local PanelPosX = SelectorWidth
local PanelPosY = FrameBarHeight
local PanelSizeX = FrameSizeX - SelectorWidth
local PanelSizeY = FrameSizeY - FrameBarHeight * 3

function LSCS:SetActivePanel( newpanel )
	if not IsValid( Frame ) then
		LSCS:OpenMenu()
	end

	if IsValid( Frame.PANEL ) then
		Frame.PANEL:Remove()
	end

	Frame.PANEL = newpanel
end

local function BaseButtonClickSB( self, sound )
	sound = sound or "ui/buttonclick.wav"

	surface.PlaySound( sound )

	Frame.buttons = Frame.buttons or {}
	Frame.buttons[ self.ID ] = 1
end

local function DrawButtonClickSB( self, w, h ) 
	local Col = menu_white_dim
	if self:IsHovered() then
		Col = menu_white
	end

	Frame.buttons = Frame.buttons or {}
	Frame.buttons[ self.ID ] = Frame.buttons[ self.ID ] or 0

	Frame.buttons[ self.ID ] = Frame.buttons[ self.ID ] - math.min(Frame.buttons[ self.ID ],RealFrameTime() * 3)

	local Size = Frame.buttons[ self.ID ]

	if Size > 0.05 then
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 25), 150, 200, 255, 255 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 15), 150, 200, 255, 255 * 0.5 * Size )
		surface.DrawCircle( w * 0.5, h * 0.5, (1 - Size) * (w - 10), 150, 200, 255, 255 * 0.2 * Size )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150 * Size, 200 * Size, 255 * Size, 255 * Size )
		surface.DrawTexturedRect( w * 0.5 - w * 0.5 * Size * 2, h * 0.5 - h * 0.5 * Size * 2, w * Size * 2, h * Size * 2 )
	end

	return Col
end

local function CreateSideBarButton( icon, ID, text )
	local button = vgui.Create( "Button", Frame.SideBar )
	button.text = text or ""
	button:SetText( "" )	
	button:SetSize( SelectorWidthActive,  80 )
	button:SetPos( 0,  (ID - 1) * 80 )
	button.DoClick = function( self )
	end
	button.Paint = function(self, w, h )
		Frame._smSB = Frame._smSB or SelectorWidth

		local xPos = Frame._smSB - 8 - 64

		local Col = DrawButtonClickSB( self, w, h ) 
		if Frame.ID == self.ID then
			Col = menu_text

			draw.DrawText( self.text, "LSCS_FONT", -110 + xPos, h * 0.5 - 10, Col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			surface.SetMaterial( Gradient )
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawTexturedRect( 0, 0, 6, h )
		else
			draw.DrawText( self.text, "LSCS_FONT", -110 + xPos, h * 0.5 - 10, Col, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end

		surface.SetMaterial( icon )
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawTexturedRect( xPos, 8, 64, 64 )
	end
	button.ID = ID

	return button
end

function LSCS:SideBar( Frame )
	if IsValid( Frame.SideBar ) then
		Frame.SideBar:Remove()
	end
	Frame.SideBar = vgui.Create( "DPanel", Frame )
	Frame.SideBar:SetPos( 0, FrameBarHeight )
	Frame.SideBar:SetSize( (Frame:SideBarIsActive() and SelectorWidthActive or SelectorWidth), SelectorHeight )
	Frame.SideBar.Paint = function(self, w, h )
		draw.RoundedBoxEx( 8, 0, 0, w, h, menu_dark, false, false, true, false )
	end

	local button = CreateSideBarButton( icon_lscs, 1, "Home" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildMainMenu( Frame )
	end

	local button = CreateSideBarButton( icon_inventory, 2, "Inventory" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildInventory( Frame )
	end

	local button = CreateSideBarButton( icon_hilt, 3, "Lightsaber" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildSaberMenu( Frame )
	end

	local button = CreateSideBarButton( icon_stance, 4, "Stance" )
	button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildStanceMenu( Frame )
	end

	local button = CreateSideBarButton( icon_force, 5, "Force" )
		button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildForceMenu( Frame )
	end

	local button = CreateSideBarButton( icon_settings, 6, "Settings" )
		button.DoClick = function( self )
		BaseButtonClickSB( self )
		LSCS:BuildSettings( Frame )
	end
end

function LSCS:BuildMainMenu( Frame )
	local smMove = 0

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		local Col = Color( 255, 191, 0, 255 ) 

		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 4, h - 64, w - 8, 60 )

		if LSCS.VERSION_GITHUB == 0 then
			surface.SetMaterial( icon_load_version )
			surface.SetDrawColor( Col )
			surface.DrawTexturedRectRotated( w - 14, h - 14, 16, 16, -CurTime() * 200 )

			draw.SimpleText( "v"..LSCS:GetVersion()..LSCS.VERSION_TYPE, "LSCS_VERSION", w - 23, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		else
			local Current = LSCS:GetVersion()
			local Latest = LSCS.VERSION_GITHUB

			local Pref = "v"

			if Current >= Latest then
				Col = Color(0,255,0,255)
			else
				Col = Color(255,0,0,255)
				Pref = "OUTDATED v"
			end

			draw.SimpleText( Pref..LSCS:GetVersion()..LSCS.VERSION_TYPE, "LSCS_VERSION", w - 7, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		end
	end

	local Header = vgui.Create( "DPanel", Panel )
	Header:SetSize( 0, 136 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		-- showoff lmao
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		local A = math.rad( CurTime() * 150 )
		local X = math.cos( A ) * w * 0.5
		local Y = math.sin( A ) * h * 0.5

		surface.SetDrawColor( menu_dim )
		surface.DrawRect( w - 132, 4, 128, 128 )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( menu_text )

		surface.DrawTexturedRectRotated( w * 0.5 + X - 5, h * 0.5 + Y, 150, 150, 0 )

		surface.SetDrawColor( menu_dim )
		surface.SetMaterial( icon_invert )
		surface.DrawTexturedRect( w - 132, 4, 128, 128 )
		surface.DrawRect( 4, 4, w - 136, 128 )

		draw.SimpleText( "THANK YOU FOR USING", "LSCS_FONT_MAXIMUM", w * 0.5 - 18, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "LSCS", "LSCS_FONT_MAXIMUM", w * 0.5 - 18, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end

	local Bar = vgui.Create( "DPanel", Panel )
	Bar:SetSize( 0, 136 )
	Bar:Dock( TOP )
	Bar:DockMargin( 4, 0, 4, 4 )
	Bar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local B = vgui.Create( "DButton", Bar )
	B:SetText("")
	B:SetSize( PanelSizeX * 0.45 , 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "PROBLEMS?", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "REPORT HERE", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://github.com/SpaxscE/lscs_public" )
		end )
	end

	local B = vgui.Create( "DButton", Bar )
	B:SetText("")
	B:SetSize( PanelSizeX * 0.5 , 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "THIS PROJECT", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "ON STEAM", "LSCS_FONT_MAXIMUM", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://steamcommunity.com/sharedfiles/filedetails/?id=2837856621" )
		end )
	end

	local ToolBar = vgui.Create( "DPanel", Panel )
	ToolBar:SetSize( 0, 136 )
	ToolBar:Dock( TOP )
	ToolBar:DockMargin( 4, 0, 4, 4 )
	ToolBar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 60, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_steam )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "STEAM", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://steamcommunity.com/profiles/76561197995010235/myworkshopfiles/" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_discord )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "DISCORD", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://discord.gg/BeVtn7uwNH" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_youtube )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "YOUTUBE", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://www.youtube.com/channel/UCoXuTyv69fGOUv7hZcAPHoQ" )
		end )
	end

	local B = vgui.Create( "DButton", ToolBar )
	B:SetText("")
	B:SetSize( 128, 128 )
	B:Dock( LEFT )
	B:DockMargin( 4, 4, 4, 4 )
	B.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_github )
		surface.SetDrawColor( Col )
		surface.DrawTexturedRectRotated( w * 0.5, h * 0.5, w, h, 0 )

		draw.SimpleText( "GITHUB", "LSCS_FONT", w * 0.5, h - 4, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	end
	B.DoClick = function( self )
		BaseButtonClick( self )
		timer.Simple( 0.5, function()
			gui.OpenURL( "https://github.com/SpaxscE" )
		end )
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 1
end

function LSCS:BuildInventory( Frame )
	local ply = LocalPlayer()

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 255, 255, 255, 255 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )

		local Col = menu_light
		surface.SetDrawColor( Col.r, Col.g, Col.b, 240 )
		surface.DrawRect( 0, 0, w, h  )
	end

	local ToolBar = vgui.Create( "DPanel", Panel )
	ToolBar:SetSize( PanelSizeX, 100 )
	ToolBar:Dock( BOTTOM )
	ToolBar:DockMargin( 10, 0, 24, 0 )
	ToolBar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 20, w, h )
	end

	local DropAll = vgui.Create( "DButton", ToolBar )
	DropAll:SetText("")
	DropAll:SetSize( 180, 100 )
	DropAll:Dock( LEFT )
	DropAll:DockMargin( 1-10, 10, 0, -10 ) -- Left width, top height, right width, bottom height
	DropAll.SafetyEnabled = 1
	DropAll.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP ALL", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP ALL!!", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 20, 2 )
	end
	DropAll.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( false )
			net.SendToServer()
		end
	end

	local DropUnEq = vgui.Create( "DButton", ToolBar )
	DropUnEq:SetText("")
	DropUnEq:SetSize( 180, 100 )
	DropUnEq:Dock( LEFT )
	DropUnEq:DockMargin( -30, 10, 0, -10 )
	DropUnEq.SafetyEnabled = 1
	DropUnEq.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "UNEQUIPPED", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP!!", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "!!UNEQUIPPED!!", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 20, 2 )
	end
	DropUnEq.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( true )
			net.SendToServer()
		end
	end

	    local EquipAllButton = vgui.Create("DButton", ToolBar)
    EquipAllButton:SetText("")
    EquipAllButton:SetSize(180, 180)
    EquipAllButton:Dock( LEFT )
    EquipAllButton:DockMargin( -30, 10, 0, -10 )
    EquipAllButton.Paint = function(self, w, h)
        local Col = DrawButtonClick(self, w, h)
			draw.SimpleText( "EQUIP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "STANCES", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
        surface.SetDrawColor(Col.r, Col.g, Col.b, Col.a)
		DrawFrame( w, h, 20, 2 )
    end
    EquipAllButton.DoClick = function(self)
        BaseButtonClick(self)
        local inventory = ply:lscsGetInventory()

        for id, class in pairs(inventory) do
            local item = LSCS:ClassToItem(class)
            if item and item.type == "stance" then
                ply:lscsEquipItem(id, true) -- Equip the stance
            end
        end
    end

    	    local EquipAllButton = vgui.Create("DButton", ToolBar)
    EquipAllButton:SetText("")
    EquipAllButton:SetSize(180, 180)
    EquipAllButton:Dock(LEFT)
    EquipAllButton:DockMargin( -30, 10, 0, -10 )
    EquipAllButton.Paint = function(self, w, h)
        local Col = DrawButtonClick(self, w, h)
			draw.SimpleText( "EQUIP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "POWERS", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
        surface.SetDrawColor(Col.r, Col.g, Col.b, Col.a)
		DrawFrame( w, h, 20, 2 )
    end
    EquipAllButton.DoClick = function(self)
        BaseButtonClick(self)
        local inventory = ply:lscsGetInventory()

        for id, class in pairs(inventory) do
            local item = LSCS:ClassToItem(class)
            if item and item.type == "force" then
                ply:lscsEquipItem(id, true) -- Equip the stance
            end
        end

        surface.PlaySound("buttons/button14.wav")
        notification.AddLegacy("All force powers equipped!", NOTIFY_GENERIC, 5)
    end

    	local Refresh = vgui.Create( "DButton", ToolBar )
	Refresh:SetText("")
	Refresh:SetSize( 180, 100 )
	Refresh:Dock( LEFT )
	Refresh:DockMargin( -30, 10, 0, -10 )
	Refresh.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "REFRESH", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 20, 2 )
	end
	Refresh.DoClick = function( self )
		BaseButtonClick( self )

		self:SetEnabled( false )

		timer.Simple( 0.2, function()
			if not IsValid( self ) then return end
			self:SetEnabled( true )
			net.Start("lscs_inventory_refresh")
				net.WriteBool( false )
			net.SendToServer()
		end )
	end


	local DScrollPanel = vgui.Create( "DScrollPanel", Panel )
	DScrollPanel:SetSize( PanelSizeX, PanelSizeY - 80 )
	DScrollPanel:Dock( BOTTOM )

	local Inventory = LocalPlayer():lscsGetInventory()

	local X = 8
	local Y = 8
	for index, class in pairs( Inventory ) do
		local DButton = vgui.Create( "DButton", DScrollPanel )
		DButton:SetText( "" )
		DButton:SetPos( X, Y )
		DButton:SetSize( 128, 128 )

		DButton.SetID = function( self, id ) self.ID = id end
		DButton.GetID = function( self ) return self.ID end

		DButton.SetItem = function( self, item ) self.Item = LSCS:ClassToItem( item ) self.ClassName = class end
		DButton.GetItem = function( self ) return self.Item end

		DButton:SetItem( class )
		DButton:SetID( index )

		DButton.Paint = function(self, w, h )
			local InventoryItem = self:GetItem()

			if not self:IsEnabled() then
				local Col = menu_dim
				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 2, 2, w - 4, h - 4 )
				return
			end

			surface.SetMaterial( InventoryItem and InventoryItem.icon or icon_missing )
			surface.SetDrawColor( 255,255,255,255 )
			surface.DrawTexturedRect( 2, 2, w - 4, h - 4 )

			DrawButtonClick( self, w, h ) 

			if not self:IsHovered() and not IsValid( self.menu ) then
				local Col = menu_dark

				surface.SetDrawColor( 0,0,0,100 )
				surface.DrawRect( 2, 2, w - 4, h - 4 )

				surface.SetDrawColor( Color(255,255,255,255) )
				surface.SetMaterial(zoom_mat ) 

				local BoxSize = w - 4
				local xPos = 2
				local yPos = 2

				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 90 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 0 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 180 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 270 )

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )
		
				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				local eq = ply:lscsGetEquipped()[ self:GetID() ] 
				if isbool( eq ) then
					surface.SetDrawColor( 255, 191, 0, 255 )
					DrawFrame( w, h, 2, 2 )

					if Item and (Item.type == "hilt" or Item.type == "crystal") then
						if eq == true then
							surface.SetMaterial( icon_rhand )
						else
							surface.SetMaterial( icon_lhand )
						end
					else
						surface.SetMaterial( icon_hand )
					end
					surface.DrawTexturedRect( 4, 4, 64, 64 )

				end
			else
				local Col = menu_light

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )

				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				Col = menu_text

				if IsValid( self.menu ) then
					surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
					DrawFrame( w, h, 2, 2 )
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 4, 2 )
					end
				else
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 2, 2 )
					else
						if self:IsHovered() then
							surface.SetDrawColor( Color(255,255,255,255) )
							DrawFrame( w, h, 2, 2 )
						end
					end
				end
			end
		end
		DButton.DoClick = function( self )
			BaseButtonClick( self )

			self.menu = DermaMenu()

			if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
				self.menu:AddOption( "Unequip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" or Item.type == "crystal" then
						ply:lscsEquipItem( self:GetID(), nil )
						ply:lscsCraftSaber()
					else
						ply:lscsEquipItem( self:GetID(), nil )
					end
				end )
			else
				self.menu:AddOption( "Equip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" then
						ply:lscsClearEquipped( "hilt" )
					end

					if Item.type == "crystal" then
						ply:lscsClearEquipped( "crystal" )
					end

					ply:lscsEquipItem( self:GetID(), true )

					if Item.type =="hilt" or Item.type == "crystal" then
						local A, _ = ply:lscsGetHilt()
						local B, _ = ply:lscsGetBlade()
						if A and A ~= "" and B and B ~= "" then
							ply:lscsCraftSaber()
						end
					end
				end )
			end
			self.menu:AddOption( "Drop", function() ply:lscsDropItem( self:GetID() ) self:SetEnabled( false ) end )
			self.menu:Open()
		end
		DButton.DoRightClick = function( self )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			X = 8
			Y = Y + 128
		end
	end

	while Y < (PanelSizeY - 128) or X < (PanelSizeX - 128) do
		local Panel = vgui.Create( "DPanel", DScrollPanel )
		Panel:SetPos( X, Y )
		Panel:SetSize( 128, 128 )
		Panel.Paint = function(self, w, h )
			local Col = menu_dim
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 2, 2, w - 4, h - 4 )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			if Y < (PanelSizeY - 128) then
				X = 8
			end
			Y = Y + 128
		end
	end

	local ToolBar = vgui.Create( "DPanel", Panel )
	ToolBar:SetSize( PanelSizeX, 50 )
	ToolBar:Dock( BOTTOM )
	ToolBar:DockMargin( 10, 4, 24, 10 )
	ToolBar.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
	end

	local Refresh = vgui.Create( "DButton", ToolBar )
	Refresh:SetText("")
	Refresh:SetSize( 130, 100 )
	Refresh:Dock( LEFT )
	Refresh:DockMargin( 4, 4, 4, 4 )
	Refresh.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		draw.SimpleText( "REFRESH", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 20, 2 )
	end
	Refresh.DoClick = function( self )
		BaseButtonClick( self )

		self:SetEnabled( false )

		timer.Simple( 0.2, function()
			if not IsValid( self ) then return end
			self:SetEnabled( true )
			net.Start("lscs_inventory_refresh")
				net.WriteBool( false )
			net.SendToServer()
		end )
	end

	local DropAll = vgui.Create( "DButton", ToolBar )
	DropAll:SetText("")
	DropAll:SetSize( 180, 100 )
	DropAll:Dock( LEFT )
	DropAll:DockMargin( 4, 4, 4, 4 )
	DropAll.SafetyEnabled = 1
	DropAll.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP ALL", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP ALL!!", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 0, 2 )
	end
	DropAll.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( false )
			net.SendToServer()
		end
	end

	local DropUnEq = vgui.Create( "DButton", ToolBar )
	DropUnEq:SetText("")
	DropUnEq:SetSize( 180, 100 )
	DropUnEq:Dock( LEFT )
	DropUnEq:DockMargin( 4, 4, 4, 4 )
	DropUnEq.SafetyEnabled = 1
	DropUnEq.Paint = function(self, w, h )
		local Col = DrawButtonClick( self, w, h )

		if self.SafetyEnabled == 1 then
			draw.SimpleText( "DROP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "UNEQUIPPED", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		elseif self.SafetyEnabled == 2 then
			draw.SimpleText( "ARE YOU SURE??", "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			Col = Color(255, 0, 0, 255)
			surface.SetMaterial( ClickMat )
			surface.SetDrawColor( 150, 0, 0, 255 )
			surface.DrawTexturedRect( 0, 0, w, h )

			draw.SimpleText( "!!DROP!!", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "!!UNEQUIPPED!!", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		DrawFrame( w, h, 0, 2 )
	end
	DropUnEq.DoClick = function( self )
		BaseButtonClick( self )

		if self.SafetyEnabled < 3 then
			self:SetEnabled( false )

			timer.Simple( 1, function()
				if not IsValid( self ) then return end
				self:SetEnabled( true )
				self.SafetyEnabled = self.SafetyEnabled + 1
			end )
		else
			self:SetEnabled( false )

			net.Start("lscs_inventory_refresh")
				net.WriteBool( true )
				net.WriteBool( true )
			net.SendToServer()
		end
	end

	    local EquipAllButton = vgui.Create("DButton", ToolBar)
    EquipAllButton:SetText("")
    EquipAllButton:SetSize(180, 180)
    EquipAllButton:Dock(LEFT)
    EquipAllButton:DockMargin(4, 4, 4, 4)
    EquipAllButton.Paint = function(self, w, h)
        local Col = DrawButtonClick(self, w, h)
			draw.SimpleText( "EQUIP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "STANCES", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
        surface.SetDrawColor(Col.r, Col.g, Col.b, Col.a)
		DrawFrame( w, h, 0, 2 )
    end
    EquipAllButton.DoClick = function(self)
        BaseButtonClick(self)
        local inventory = ply:lscsGetInventory()

        for id, class in pairs(inventory) do
            local item = LSCS:ClassToItem(class)
            if item and item.type == "stance" then
                ply:lscsEquipItem(id, true) -- Equip the stance
            end
        end

        surface.PlaySound("buttons/button14.wav")
        notification.AddLegacy("All stances equipped!", NOTIFY_GENERIC, 5)
    end

    	    local EquipAllButton = vgui.Create("DButton", ToolBar)
    EquipAllButton:SetText("")
    EquipAllButton:SetSize(180, 180)
    EquipAllButton:Dock(LEFT)
    EquipAllButton:DockMargin(4, 4, 4, 4)
    EquipAllButton.Paint = function(self, w, h)
        local Col = DrawButtonClick(self, w, h)
			draw.SimpleText( "EQUIP", "LSCS_FONT", w * 0.5, h * 0.5 + 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( "POWERS", "LSCS_FONT", w * 0.5, h * 0.5 - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
        surface.SetDrawColor(Col.r, Col.g, Col.b, Col.a)
		DrawFrame( w, h, 0, 2 )
    end
    EquipAllButton.DoClick = function(self)
        BaseButtonClick(self)
        local inventory = ply:lscsGetInventory()

        for id, class in pairs(inventory) do
            local item = LSCS:ClassToItem(class)
            if item and item.type == "force" then
                ply:lscsEquipItem(id, true) -- Equip the stance
            end
        end

        surface.PlaySound("buttons/button14.wav")
        notification.AddLegacy("All force powers equipped!", NOTIFY_GENERIC, 5)
    end


	local DScrollPanel = vgui.Create( "DScrollPanel", Panel )
	DScrollPanel:SetSize( PanelSizeX, PanelSizeY - 40 )
	DScrollPanel:Dock( BOTTOM )

	local Inventory = LocalPlayer():lscsGetInventory()

	local X = 8
	local Y = 8
	for index, class in pairs( Inventory ) do
		local DButton = vgui.Create( "DButton", DScrollPanel )
		DButton:SetText( "" )
		DButton:SetPos( X, Y )
		DButton:SetSize( 128, 128 )

		DButton.SetID = function( self, id ) self.ID = id end
		DButton.GetID = function( self ) return self.ID end

		DButton.SetItem = function( self, item ) self.Item = LSCS:ClassToItem( item ) self.ClassName = class end
		DButton.GetItem = function( self ) return self.Item end

		DButton:SetItem( class )
		DButton:SetID( index )

		DButton.Paint = function(self, w, h )
			local InventoryItem = self:GetItem()

			if not self:IsEnabled() then
				local Col = menu_dim
				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 2, 2, w - 4, h - 4 )
				return
			end

			surface.SetMaterial( InventoryItem and InventoryItem.icon or icon_missing )
			surface.SetDrawColor( 255,255,255,255 )
			surface.DrawTexturedRect( 2, 2, w - 4, h - 4 )

			DrawButtonClick( self, w, h ) 

			if not self:IsHovered() and not IsValid( self.menu ) then
				local Col = menu_dark

				surface.SetDrawColor( 0,0,0,100 )
				surface.DrawRect( 2, 2, w - 4, h - 4 )

				surface.SetDrawColor( Color(255,255,255,255) )
				surface.SetMaterial(zoom_mat ) 

				local BoxSize = w - 4
				local xPos = 2
				local yPos = 2

				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 90 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.25, BoxSize * 0.5, BoxSize * 0.5, 0 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.25, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 180 )
				surface.DrawTexturedRectRotated( xPos + BoxSize * 0.75, yPos + BoxSize * 0.75, BoxSize * 0.5, BoxSize * 0.5, 270 )

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )
		
				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				local eq = ply:lscsGetEquipped()[ self:GetID() ] 
				if isbool( eq ) then
					surface.SetDrawColor( 255, 191, 0, 255 )
					DrawFrame( w, h, 2, 2 )

					if Item and (Item.type == "hilt" or Item.type == "crystal") then
						if eq == true then
							surface.SetMaterial( icon_rhand )
						else
							surface.SetMaterial( icon_lhand )
						end
					else
						surface.SetMaterial( icon_hand )
					end
					surface.DrawTexturedRect( 4, 4, 64, 64 )

				end
			else
				local Col = menu_light

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				surface.DrawRect( 4, h - 24, w-8, 20  )

				local Item = self:GetItem()
				if Item then
					draw.SimpleText( Item.name.." ["..Item.Type.."]", "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( self.ClassName, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end

				Col = menu_text

				if IsValid( self.menu ) then
					surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
					DrawFrame( w, h, 2, 2 )
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 4, 2 )
					end
				else
					if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
						surface.SetDrawColor( 255, 191, 0, 255 )
						DrawFrame( w, h, 2, 2 )
					else
						if self:IsHovered() then
							surface.SetDrawColor( Color(255,255,255,255) )
							DrawFrame( w, h, 2, 2 )
						end
					end
				end
			end
		end
		DButton.DoClick = function( self )
			BaseButtonClick( self )

			self.menu = DermaMenu()

			if isbool( ply:lscsGetEquipped()[ self:GetID() ] ) then
				self.menu:AddOption( "Unequip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" or Item.type == "crystal" then
						ply:lscsEquipItem( self:GetID(), nil )
						ply:lscsCraftSaber()
					else
						ply:lscsEquipItem( self:GetID(), nil )
					end
				end )
			else
				self.menu:AddOption( "Equip", function()
					if not self.GetItem then return end -- what happened ?

					local Item = self:GetItem()

					if not Item then return end

					if Item.type == "hilt" then
						ply:lscsClearEquipped( "hilt" )
					end

					if Item.type == "crystal" then
						ply:lscsClearEquipped( "crystal" )
					end

					ply:lscsEquipItem( self:GetID(), true )

					if Item.type =="hilt" or Item.type == "crystal" then
						local A, _ = ply:lscsGetHilt()
						local B, _ = ply:lscsGetBlade()
						if A and A ~= "" and B and B ~= "" then
							ply:lscsCraftSaber()
						end
					end
				end )
			end
			self.menu:AddOption( "Drop", function() ply:lscsDropItem( self:GetID() ) self:SetEnabled( false ) end )
			self.menu:Open()
		end
		DButton.DoRightClick = function( self )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			X = 8
			Y = Y + 128
		end
	end

	while Y < (PanelSizeY - 128) or X < (PanelSizeX - 128) do
		local Panel = vgui.Create( "DPanel", DScrollPanel )
		Panel:SetPos( X, Y )
		Panel:SetSize( 128, 128 )
		Panel.Paint = function(self, w, h )
			local Col = menu_dim
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 2, 2, w - 4, h - 4 )
		end

		X = X + 128
		if X > (PanelSizeX - 128) then
			if Y < (PanelSizeY - 128) then
				X = 8
			end
			Y = Y + 128
		end
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 2
end

local CrafterButtonPaint = function(self, w, h )
	if self.Item then
		surface.SetMaterial( self.Item.icon )
		surface.SetDrawColor( 255, 255, 255 ,255 )
		surface.DrawTexturedRect( 2, h * 0.5 - w * 0.5 - 2, w - 4, w - 4 )

		local IsMainHovered = IsValid(self.Main) and self.Main:IsHovered()
		if self:IsHovered() or IsValid( self.menu ) or IsMainHovered then
			Col = menu_light

			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 4, h - 24, w-8, 20  )

			draw.SimpleText( self.Item.name, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		else
			surface.SetDrawColor( Color(255,255,255,255) )
			surface.SetMaterial(zoom_mat ) 
			local BoxSizeX = w - 4
			local BoxSizeY = h - 4
			local xPos = 2
			local yPos = 2

			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.25, yPos + BoxSizeY * 0.25, BoxSizeY * 0.5, BoxSizeX * 0.5, 90 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.75, yPos + BoxSizeY * 0.25, BoxSizeX * 0.5, BoxSizeY * 0.5, 0 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.25, yPos + BoxSizeY * 0.75, BoxSizeX * 0.5, BoxSizeY * 0.5, 180 )
			surface.DrawTexturedRectRotated( xPos + BoxSizeX * 0.75, yPos + BoxSizeY * 0.75, BoxSizeY * 0.5, BoxSizeX * 0.5, 270 )

			Col = menu_dark
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			surface.DrawRect( 4, h - 24, w-8, 20  )
	
			draw.SimpleText( self.Item.name, "LSCS_FONT_SMALL", w * 0.5, h - 8, menu_white_dim, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		end

		local Col = DrawButtonClick( self, w, h )
		
		if IsMainHovered then
			Col = menu_white
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		DrawFrame( w, h, 0, 2 )


		local Col = menu_text
		if IsValid( self.menu ) then
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawFrame( w, h, 0, 2 )
		end
	else
		local Col = menu_dark
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		Col = DrawButtonClick( self, w, h )

		surface.SetMaterial( icon_cross )

		if self:IsHovered() then
			Col = Color(255,0,0,255)
		end
		if IsValid( self.menu ) then
			Col = menu_white
		end

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )

		surface.DrawTexturedRect( 32, 32, 64, 64 )

		DrawFrame( w, h, 0, 2 )

		draw.SimpleText( self.InfoText, "LSCS_FONT", w * 0.5, h - 8, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

		if IsValid( self.menu ) then
			Col = menu_text
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawFrame( w, h, 0, 2 )
		end
	end
end

function LSCS:BuildSaberMenu( Frame )
	local ply = LocalPlayer()
	local HiltR, HiltL = ply:lscsGetHilt()
	local BladeR, BladeL = ply:lscsGetBlade()

	local AAA = 80

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )

		draw.RoundedBoxEx( 8, 4, 4, w - 8, h - 8, menu_dim, false, false, false, true )

		draw.SimpleText( "Information", "LSCS_FONT", 8, 14, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		draw.SimpleText( "NOTE: For this to work you need a Hilt and a Blade-Crystal in your Inventory and you must have permission to spawn SWEP's", "LSCS_FONT_SMALL", 8, 30, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		if IsValid( self.Main ) and self.Main:IsHovered() then
			local Col = menu_white_dim
			if HiltR and BladeR then
				Col = menu_white
			end
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,35+64+AAA,0) )
			surface.DrawLine( 163, 99+AAA, PanelSizeX * 0.5 - 64,35+64+AAA )
			Col = menu_white_dim
			if HiltL and BladeL then
				Col = menu_white
			end
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,PanelSizeY - 64 - 35,0) )
			surface.DrawLine( 163, PanelSizeY - 64 - 35, PanelSizeX * 0.5 - 64,PanelSizeY - 64 - 35 )
		else
			local Col = menu_white_dim
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,35+64+AAA,0) )
			surface.DrawLine( 163, 99+AAA, PanelSizeX * 0.5 - 64,35+64+AAA )
			DrawBezier( Vector(PanelSizeX - 125,PanelSizeY - 54,0), Vector(PanelSizeX * 0.5 + 64,PanelSizeY - 64 - 35,0) )
			surface.DrawLine( 163, PanelSizeY - 64 - 35, PanelSizeX * 0.5 - 64,PanelSizeY - 64 - 35 )
		end
	end

	local Main = vgui.Create( "DButton", Panel )
	Main:SetText( "" )
	Main:SetPos( PanelSizeX - 125, PanelSizeY - 104 )
	Main:SetSize( 100, 100 )
	Main.Paint = function(self, w, h )
		local Col = menu_dark
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )

		Col = DrawButtonClick( self, w, h )
		local Col2 = Col

		surface.SetMaterial( icon_check )
		if self:IsHovered() then
			Col2 = Color(0,255,0)
		end
		surface.SetDrawColor( Col2.r, Col2.g, Col2.b, Col2.a )
		surface.DrawTexturedRect( 18, 18, w - 36, h - 36 )

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		DrawFrame( w, h, 0, 2 )
	end
	Main.DoClick = function( self )
		BaseButtonClick( self )
		ply:lscsCraftSaber()
		Frame:Remove()
	end
	Panel.Main = Main

	-- RIGHT
	local ButtonHilt = vgui.Create( "DButton", Panel )
	ButtonHilt.InfoText = "Hilt [RH]"
	ButtonHilt:SetText( "" )
	ButtonHilt:SetPos( PanelSizeX * 0.5 - 64, 35 + AAA )
	ButtonHilt:SetSize( 128, 128 )
	ButtonHilt.Item = LSCS:GetHilt( HiltR )
	ButtonHilt.Paint = CrafterButtonPaint
	ButtonHilt.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "hilt", true )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )
				if item.type == "hilt" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, true )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonHilt.Main = Main

	local ButtonBlade = vgui.Create( "DButton", Panel )
	ButtonBlade.InfoText = "Crystal [RH]"
	ButtonBlade:SetText( "" )
	ButtonBlade:SetPos( 35, 35+AAA )
	ButtonBlade:SetSize( 128, 128 )
	ButtonBlade.Item = LSCS:GetBlade( BladeR )
	ButtonBlade.Paint = CrafterButtonPaint
	ButtonBlade.DoClick = function( self )
		BaseButtonClick( self )

		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "crystal", true )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )
				if item.type == "crystal" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, true )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonBlade.Main = Main

	-- LEFT
	local ButtonHilt = vgui.Create( "DButton", Panel )
	ButtonHilt.InfoText = "Hilt [LH]"
	ButtonHilt:SetText( "" )
	ButtonHilt:SetPos( PanelSizeX * 0.5 - 64, PanelSizeY - 128 - 35 )
	ButtonHilt:SetSize( 128, 128 )
	ButtonHilt.Item = LSCS:GetHilt( HiltL )
	ButtonHilt.Paint = CrafterButtonPaint
	ButtonHilt.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "hilt", false )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )

				if not item then continue end

				if item.type == "hilt" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, false )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonHilt.Main = Main

	local ButtonBlade = vgui.Create( "DButton", Panel )
	ButtonBlade.InfoText = "Crystal [LH]"
	ButtonBlade:SetText( "" )
	ButtonBlade:SetPos( 35, PanelSizeY - 128 - 35 )
	ButtonBlade:SetSize( 128, 128 )
	ButtonBlade.Item = LSCS:GetBlade( BladeL )
	ButtonBlade.Paint = CrafterButtonPaint
	ButtonBlade.DoClick = function( self )
		BaseButtonClick( self )
		if self.Item then
			self.menu = DermaMenu()
			self.menu:AddOption( "Unequip", function()
				ply:lscsClearEquipped( "crystal", false )
				ply:lscsCraftSaber()
			end )
			self.menu:Open()
		else
			self.menu = DermaMenu()
			local Num = 0
			for k, v in pairs( ply:lscsGetInventory() ) do
				if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

				local item = LSCS:ClassToItem( v )

				if not item then continue end

				if item.type == "crystal" then
					Num = Num + 1
					self.menu:AddOption( item.name, function()
						ply:lscsEquipItem( k, false )
					end )
				end
			end
			if Num >= 1 then
				self.menu:Open()
			else
				surface.PlaySound("buttons/button10.wav")
				self.menu:Remove()
			end
		end
	end
	ButtonBlade.Main = Main

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 3
end

function LSCS:BuildStanceMenu( Frame )
	local ply = LocalPlayer()

	if StanceNum > #ply:lscsGetCombo() then
		StanceNum = 1
	end

	local combo = ply:lscsGetCombo( StanceNum )

	local ColHead = menu_text
	local ColText = menu_white

	local LastID

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		draw.RoundedBoxEx( 8, 0, 0, w, h, menu_light, false, false, false, true )

		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local mdl = vgui.Create( "DModelPanel", Panel )
	mdl:SetSize( 250, 0)
	mdl:Dock( RIGHT )
	mdl:DockMargin( 4, 4, 4, 4 )
	mdl:SetFOV( 30 )
	mdl:SetCamPos( vector_origin )
	mdl:SetDirectionalLight( BOX_RIGHT, Color( 255, 160, 80, 255 ) )
	mdl:SetDirectionalLight( BOX_LEFT, Color( 80, 160, 255, 255 ) )
	mdl:SetAmbientLight( Vector( -64, -64, -64 ) )
	mdl:SetAnimated( true )
	mdl.Angles = angle_zero
	mdl:SetLookAt( Vector( -100, 0, -22 ) )
	mdl:SetModel( LocalPlayer():GetModel() )
	function mdl.Entity:GetPlayerColor() return LocalPlayer():GetPlayerColor() end
	mdl.Entity:SetPos( Vector( -100, 0, -61 ) )

	function mdl:DragMousePress()
		self.PressX, self.PressY = gui.MousePos()
		self.Pressed = true
	end

	function mdl:DragMouseRelease() self.Pressed = false end

	function mdl:LayoutEntity( ent )
		if ( self.bAnimated ) then self:RunAnimation() end

		if ( self.Pressed ) then
			local mx = gui.MousePos()
			self.Angles = self.Angles - Angle( 0, ( ( self.PressX or mx ) - mx ) / 2, 0 )

			self.PressX, self.PressY = gui.MousePos()
		end

		ent:SetAngles( self.Angles )
	end

	mdl.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	
		if not IsValid( self.Entity ) then return end

		local x, y = self:LocalToScreen( 0, 0 )

		self:LayoutEntity( self.Entity )

		local ang = self.aLookAngle
		if not ang then
			ang = ( self.vLookatPos - self.vCamPos ):Angle()
		end

		cam.Start3D( self.vCamPos, ang, self.fFOV, x, y, w, h, 5, self.FarZ )

		render.SuppressEngineLighting( true )
		render.SetLightingOrigin( self.Entity:GetPos() )
		render.ResetModelLighting( self.colAmbientLight.r / 255, self.colAmbientLight.g / 255, self.colAmbientLight.b / 255 )
		render.SetColorModulation( self.colColor.r / 255, self.colColor.g / 255, self.colColor.b / 255 )
		render.SetBlend( ( self:GetAlpha() / 255 ) * ( self.colColor.a / 255 ) ) -- * surface.GetAlphaMultiplier()

		for i = 0, 6 do
			local col = self.DirectionalLight[ i ]
			if ( col ) then
				render.SetModelLighting( i, col.r / 255, col.g / 255, col.b / 255 )
			end
		end

		self:DrawModel()

		render.SuppressEngineLighting( false )
		cam.End3D()

		self.LastPaint = RealTime()
	end

	local descriptionHeader = vgui.Create( "DPanel", Panel )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Information", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	local SPB = vgui.Create( "DPanel", Panel )
	SPB:SetSize( 0, 280 )
	SPB:Dock( BOTTOM )
	SPB:DockMargin( 4, 4, 0, 4 )
	SPB.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local DScrollPanel = vgui.Create( "DScrollPanel", SPB )
	DScrollPanel:Dock( FILL )

	local nice_combo = {}

	for index, obj in pairs( combo.Attacks ) do
		local info = LSCS.ComboInfo[ index ]

		local data = {
			text = info.description,
			name = info.name,
			AttackAnim = (obj.AttackAnimMenu or obj.AttackAnim),
			id = info.order,
		}
		table.insert( nice_combo, data )
	end
	table.sort( nice_combo, function( a, b ) return a.id < b.id end )

	for index, data in ipairs( nice_combo ) do
		local DButton = DScrollPanel:Add( "DButton" )
		DButton.InfoText = data.text
		DButton.InfoName = data.name
		DButton:SetSize(100,50)
		DButton:SetText("")
		DButton:Dock( TOP )
		DButton:DockMargin( 5, 5, 5, 2.5 )
		DButton.Paint = function(self, w, h )
			DrawButtonClick( self, w, h ) 
			local Col = menu_white_dim

			if LastID == index then
				Col = menu_text
				draw.SimpleText( "["..self.InfoName.."]", "LSCS_FONT", w * 0.5, 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )

				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
				DrawFrame( w, h, 0, 2 )
				Col = menu_white
			else
				if self:IsHovered() then
					Col = menu_white
					surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
					DrawFrame( w, h, 0, 2 )
				end

				draw.SimpleText( self.InfoName, "LSCS_FONT", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

				return
			end

			local words = string.Explode( "\n", self.InfoText )
			if #words > 1 then
				draw.SimpleText( words[1], "LSCS_FONT_SMALL", w * 0.5, h - 2 - 12, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				draw.SimpleText( words[2], "LSCS_FONT_SMALL", w * 0.5, h - 2, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			else
				draw.SimpleText( words[1], "LSCS_FONT_SMALL", w * 0.5, h - 8, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			end
		end
		DButton.DoClick = function( self )
			BaseButtonClick( self )

			LastID = index

			local model = mdl.Entity
			if IsValid( model ) then
				local seqID = model:LookupSequence( data.AttackAnim )
				model:SetSequence( seqID )
				model:ResetSequence( seqID )
				model:SetCycle( 0 )
			end
		end
	end

	local description = vgui.Create( "DPanel", Panel )
	description:SetSize( 275, 0 )
	description:Dock( LEFT )
	description:DockMargin( 4, 4, 0, 0 )
	description.Paint = function(self, w, h ) 
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end
	local richtext = vgui.Create( "RichText", description )
	richtext:Dock( FILL )
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	richtext:AppendText("Name:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.name or combo.id).."\n\n")
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	richtext:AppendText("Description:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.description or "").."\n\n")

	if combo.LeftSaberActive then
		richtext:InsertColorChange( 0,255,0,255 )
		richtext:AppendText("This Stance supports Left Hand Sabers\n\n")
	else
		richtext:InsertColorChange( 255,200,0,255 )
		richtext:AppendText("This Stance does not support Left Hand Sabers\n\n")
	end

	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )

	richtext:AppendText("Author:\n")
	richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
	richtext:AppendText((combo.author or "").."\n\n")
	richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )

	local Button = vgui.Create( "DButton", Panel )
	Button.Item = combo
	Button:SetText( "" )
	Button:SetSize( 130, 0 )
	Button:Dock( LEFT )
	Button:DockMargin( 4, 4, 4, 0 )
	Button.Paint = function( self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		CrafterButtonPaint( self, w, h )
	end
	Button.DoClick = function( self )
		BaseButtonClick( self )

		local NumCombo = #ply:lscsGetCombo()

		self.menu = DermaMenu()

		self.menu:AddOption( "view next", function()
			StanceNum = StanceNum + 1
			if StanceNum > NumCombo then
				StanceNum = 1
			end
			combo = ply:lscsGetCombo( StanceNum )
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )
		self.menu:AddOption( "view previous", function()
			StanceNum = StanceNum - 1
			if StanceNum <= 0 then
				StanceNum = NumCombo
			end
			combo = ply:lscsGetCombo( StanceNum )
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )

		local subMenu = self.menu:AddSubMenu("equip")

		local Num = 0
		for k, v in pairs( ply:lscsGetInventory() ) do
			if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

			local item = LSCS:ClassToItem( v )

			if not item then continue end

			if item.type == "stance" then
				Num = Num + 1
				subMenu:AddOption( item.name, function()
					ply:lscsEquipItem( k, true )
				end )
			end
		end

		self.menu:Open()
	end
	Button.DoRightClick = function( self )
		BaseButtonClick( self )

		local NumCombo = #ply:lscsGetCombo()

		StanceNum = StanceNum + 1
		if StanceNum > NumCombo then
			StanceNum = 1
		end
		combo = ply:lscsGetCombo( StanceNum )
		LSCS:RefreshMenu()
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 4
end

function LSCS:BuildForceMenu( Frame )
	local ply = LocalPlayer()
	local ForceAbilities = ply:lscsGetForceAbilities()

	if ForceNum > #ForceAbilities then
		ForceNum = 1
	end

	local Force = ForceAbilities[ ForceNum ] and ForceAbilities[ ForceNum ].item or false

	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local L = vgui.Create( "DPanel", Panel )
	L:SetSize( PanelSizeX - 250, 800 )
	L:Dock( LEFT )
	L:DockMargin( 0, 0, 0, 0 )
	L.Paint = function(self, w, h )
	end

	local descriptionHeader = vgui.Create( "DPanel", L )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Information", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local SelectBind = vgui.Create( "DPanel", L )
	SelectBind:SetSize( 0, 280 )
	SelectBind:Dock( BOTTOM )
	SelectBind:DockMargin( 4, 4, 0, 4 )
	SelectBind.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local description = vgui.Create( "DPanel", L )
	description:SetSize( 324, 0 )
	description:Dock( LEFT )
	description:DockMargin( 4, 4, 0, 0 )
	description.Paint = function(self, w, h ) 
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local ColHead = menu_text
	local ColText = menu_white

	local richtext = vgui.Create( "RichText", description )
	richtext:Dock( FILL )
	if Force then
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Name:\n")

		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText("Force "..(Force.name or Force.id).."\n\n")

		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Description:\n")
		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText((Force.description or "").."\n\n")
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("Author:\n")
		richtext:InsertColorChange( ColText.r, ColText.g, ColText.b, ColText.a )
		richtext:AppendText((Force.author or "").."\n\n")
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
	else
		richtext:InsertColorChange( ColHead.r, ColHead.g, ColHead.b, ColHead.a )
		richtext:AppendText("You don't have any Force Powers")
	end

	local Button = vgui.Create( "DButton", L )
	Button.Item = Force
	Button.InfoText = "N/A"
	Button:SetText( "" )
	Button:SetSize( 130, 0 )
	Button:Dock( LEFT )
	Button:DockMargin( 4, 4, 4, 0 )
	Button.Paint = function( self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		CrafterButtonPaint( self, w, h )
	end
	Button.DoClick = function( self )
		BaseButtonClick( self )

		local NumForce = #ForceAbilities

		self.menu = DermaMenu()

		self.menu:AddOption( "view next", function()
			ForceNum = ForceNum + 1
			if ForceNum > NumForce then
				ForceNum = 1
			end
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )
		self.menu:AddOption( "view previous", function()
			ForceNum = ForceNum - 1
			if ForceNum <= 0 then
				ForceNum = NumForce
			end
			self.menu:Remove()
			LSCS:RefreshMenu()
		end )

		local subMenu = self.menu:AddSubMenu("equip")

		local Num = 0
		for k, v in pairs( ply:lscsGetInventory() ) do
			if isbool( ply:lscsGetEquipped()[ k ] ) then continue end

			local item = LSCS:ClassToItem( v )

			if not item then continue end

			if item.type == "force" then
				Num = Num + 1
				subMenu:AddOption( item.name, function()
					ply:lscsEquipItem( k, true )
				end )
			end
		end

		self.menu:Open()
	end
	Button.DoRightClick = function( self )
		BaseButtonClick( self )

		local NumForce = #ForceAbilities

		ForceNum = ForceNum + 1
		if ForceNum > NumForce then
			ForceNum = 1
		end
		LSCS:RefreshMenu()
	end


	local descriptionHeader = vgui.Create( "DPanel", SelectBind )
	descriptionHeader:Dock( TOP )
	descriptionHeader:DockMargin( 4, 4, 0, 0 )
	descriptionHeader.Paint = function(self, w, h )
		local Col = menu_dim

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h )
		draw.SimpleText( "Force Selector Keybinding", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ActivatorBG = vgui.Create( "DPanel", SelectBind )
	ActivatorBG:SetSize( 250, 30 )
	ActivatorBG:Dock( TOP )
	ActivatorBG:DockMargin( 4, 4, 4, 0 )
	ActivatorBG.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Mouse Override (LMB to use Force, Scroll Wheel to select)", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local ActivatorBinder = vgui.Create( "DBinder", ActivatorBG )
	ActivatorBinder:SetSize( 100, 30 )
	ActivatorBinder:Dock( RIGHT )
	ActivatorBinder:DockMargin( 2, 2, 2, 2 )
	ActivatorBinder:SetValue( LSCS.ForceSelector.KeyActivate:GetInt() )
	ActivatorBinder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyActivate:SetInt( num )
	end

	local Next = vgui.Create( "DPanel", SelectBind )
	Next:SetSize( 250, 30 )
	Next:Dock( TOP )
	Next:DockMargin( 4, 4, 4, 0 )
	Next.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Next", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Next )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyNext:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyNext:SetInt( num )
	end

	local Prev = vgui.Create( "DPanel", SelectBind )
	Prev:SetSize( 250, 30 )
	Prev:Dock( TOP )
	Prev:DockMargin( 4, 4, 4, 0 )
	Prev.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Previous", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Prev )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyPrev:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyPrev:SetInt( num )
	end


	local Use = vgui.Create( "DPanel", SelectBind )
	Use:SetSize( 250, 30 )
	Use:Dock( TOP )
	Use:DockMargin( 4, 4, 4, 0 )
	Use.Paint = function(self, w, h )
		local Col = menu_light

		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Use", "LSCS_FONT_SMALL", (w - 100) * 0.5, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local Binder = vgui.Create( "DBinder", Use )
	Binder:SetSize( 100, 30 )
	Binder:Dock( RIGHT )
	Binder:DockMargin( 2, 2, 2, 2 )
	Binder:SetValue( LSCS.ForceSelector.KeyUse:GetInt() )
	Binder.OnChange = function( self, num )
		LSCS.ForceSelector.KeyUse:SetInt( num )
	end


	local SPH = vgui.Create( "DPanel", Panel )
	SPH:SetSize( 0, 50 )
	SPH:Dock( TOP )
	SPH:DockMargin( 4, 4, 4, 0 )
	SPH.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )

		draw.SimpleText( "Force Power", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		draw.SimpleText( "Direct Key Binding", "LSCS_FONT", w * 0.5, h * 0.5, menu_text, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	end

	local SPB = vgui.Create( "DPanel", Panel )
	SPB:SetSize( 242, 0 )
	SPB:Dock( RIGHT )
	SPB:DockMargin( 0, 4, 4, 4 )
	SPB.Paint = function(self, w, h )
		local Col = menu_dim
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		surface.DrawRect( 0, 0, w, h  )
	end

	local DScrollPanel = vgui.Create( "DScrollPanel", SPB )
	DScrollPanel:Dock( FILL )

for ID, item in pairs( LSCS.Force ) do
    local P = DScrollPanel:Add( "DPanel" )
    P:SetSize( 250, 30 )
    P:Dock( TOP )
    P:DockMargin( 4, 4, 4, 0 )
    P.Paint = function(self, w, h)
        local Col = menu_light

        if Force and Force.id == ID then
            Col = menu_text
        end

        surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
        surface.DrawRect( 0, 0, w, h )

        draw.SimpleText( item.name, "LSCS_FONT_SMALL", (w - 150) * 0.5 + 70, h * 0.5 - 1, menu_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

  -- Force Binding Input (DBinder to the right of Reset)
    local B = vgui.Create("DBinder", P)
    B:SetSize(50, 30)
    B:Dock(RIGHT)
    B:DockMargin(2, 2, 2, 2)
    B:SetValue(item.cmd:GetInt())

    B.OnChange = function(self, num)
        item.cmd:SetInt(num)
        LSCS:RefreshKeys()
    end

    -- **Reset Button** (to the left of the force power name)
    local ResetButton = vgui.Create("DButton", P)
    ResetButton:SetText("Reset")
    ResetButton:SetSize(40, 30)
    ResetButton:Dock(LEFT)
    ResetButton:DockMargin(4, 4, 4, 0)

    -- Pass `B` to the click handler to maintain scope
    ResetButton.DoClick = function()
        local forceCmdName = item.cmd:GetName()

        if B then  -- Safely check if `B` exists
            item.cmd:SetInt(0)  -- Remove the binding
            B:SetValue(0)        -- Update the UI to reflect no binding
            LSCS:RefreshKeys()    -- Notify the system to refresh everything
        else
            print("Binding input `B` not found")
        end
    end

    ResetButton.Paint = function(self, w, h)
        local Col = DrawButtonClick(self, w, h)
        draw.SimpleText("Reset", "LSCS_FONT_SMALL", w * 0.5, h * 0.5, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        surface.SetDrawColor( 230, 230, 230, Col.a )
        surface.DrawRect( 0, 0, w, h )
        DrawFrame(w, h, 0, 2)
    end

end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 5
end

function LSCS:BuildSettings( Frame )
	local Panel = vgui.Create( "DPanel", Frame )
	Panel:SetPos( PanelPosX, PanelPosY )
	Panel:SetSize( PanelSizeX, PanelSizeY + FrameBarHeight )
	Panel.Paint = function(self, w, h )
		surface.SetMaterial( ClickMat )
		surface.SetDrawColor( 150,150,150,150 )
		local X, Y = self:CursorPos()
		surface.DrawTexturedRectRotated( X, Y, 512, 512, 0 )
	end

	local PerfSettings = vgui.Create( "DPanel", Panel )
	PerfSettings:SetSize( 0, 166 )
	PerfSettings:DockMargin( 4, 4, 4, 4 )
	PerfSettings:Dock( TOP )
	PerfSettings.Paint = function(self, w, h )
		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 0, 0, w, h )
	end

	local Header = vgui.Create( "DPanel", PerfSettings )
	Header:SetSize( 0, 40 )
	Header:DockMargin( 4, 4, 4, 4 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		draw.SimpleText( "Client Settings", "LSCS_FONT", 4, h * 0.5, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local Line = vgui.Create( "DPanel", PerfSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end

	local pLeft = vgui.Create( "DPanel", PerfSettings )
	pLeft:SetSize( PanelSizeX * 0.5, 0 )
	pLeft:DockMargin( 0, 0, 0, 0 )
	pLeft:Dock( LEFT )
	pLeft.Paint = function(self, w, h ) end

	local pRight = vgui.Create( "DPanel", PerfSettings )
	pRight:SetSize( PanelSizeX * 0.5, 0 )
	pRight:DockMargin( 0, 0, 0, 0 )
	pRight:Dock( LEFT )
	pRight.Paint = function(self, w, h ) end

	local T = vgui.Create( "DPanel", pLeft )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Performance", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pLeft )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Dynamic Light")	
	DCheckbox:SetConVar("lscs_dynamiclight")
	DCheckbox:SizeToContents()

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pLeft )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("High Quality Impact Effects")	
	DCheckbox:SetConVar("lscs_impacteffects")
	DCheckbox:SizeToContents()

	local DSlider = vgui.Create( "DNumSlider", pLeft )
	DSlider:Dock( TOP )
	DSlider:DockMargin( 4, 4, 0, 0 )
	DSlider:SetText( "Trail Effect Detail" )
	DSlider:SetMin( 0 )
	DSlider:SetMax( 100 )
	DSlider:SetDecimals( 0 )
	DSlider:SetConVar( "lscs_traildetail" )	

	local T = vgui.Create( "DPanel", pRight )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Hud", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", pRight )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Show HUD")	
	DCheckbox:SetConVar("lscs_drawhud")
	DCheckbox:SizeToContents()


	local SVSettings = vgui.Create( "DPanel", Panel )
	SVSettings:SetSize( 0, 302 )
	SVSettings:DockMargin( 4, 0, 4, 4 )
	SVSettings:Dock( TOP )
	SVSettings.Paint = function(self, w, h )
		surface.SetDrawColor( menu_dim )
		surface.DrawRect( 0, 0, w, h )
	end

	local Header = vgui.Create( "DPanel", SVSettings )
	Header:SetSize( 0, 40 )
	Header:DockMargin( 4, 4, 4, 4 )
	Header:Dock( TOP )
	Header.Paint = function(self, w, h )
		draw.SimpleText( "Server Settings", "LSCS_FONT", 4, h * 0.5, menu_text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( w - 20,  4, 16, 16 )
	end

	local Line = vgui.Create( "DPanel", SVSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
	local T = vgui.Create( "DPanel", SVSettings )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Saber Attacking", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Damage" )
	slider:SetMin( 0 )
	slider:SetMax( 2000 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_saberdamage" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_saberdamage")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local Line = vgui.Create( "DPanel", SVSettings )
	Line:SetSize( PanelSizeX, 1)
	Line:Dock( TOP )
	Line:DockMargin( 0, 4, 4, 4 )
	Line.Paint = function(self, w, h )
		surface.SetDrawColor( menu_text )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
	local T = vgui.Create( "DPanel", SVSettings )
	T:Dock( TOP )
	T:DockMargin( 4, 4, 0, 0 )
	T.Paint = function(self, w, h )
		draw.SimpleText( "Saber Bullet Deflecting", "LSCS_FONT_SMALL", 0, h * 0.5, menu_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Deflect Force Drain Multiplier" )
	slider:SetMin( 0 )
	slider:SetMax( 1 )
	slider:SetDecimals( 2 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_mul" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_mul")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Minimum ForceDrain per Deflect" )
	slider:SetMin( 0 )
	slider:SetMax( 10 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_min" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_min")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local slider = vgui.Create( "DNumSlider", SVSettings )
	slider:Dock( TOP )
	slider:DockMargin( 4, 4, 0, 0 )
	slider:SetText( "Maximum ForceDrain per Deflect" )
	slider:SetMin( 0 )
	slider:SetMax( 100 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lscs_sv_forcedrain_per_bullet_max" )
	function slider:OnValueChanged( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_forcedrain_per_bullet_max")
			net.WriteString( tostring( val ) )
		net.SendToServer()
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", SVSettings )
	DCheckbox:Dock( TOP )
	DCheckbox:DockMargin( 4, 4, 0, 0 )
	DCheckbox:SetText("Player Bullets Interrupt Saber Attack")	
	DCheckbox:SetConVar("lscs_sv_bullet_can_interrupt_attack")
	DCheckbox:SizeToContents()
	function DCheckbox:OnChange( val )
		net.Start("lscs_admin_setconvar")
			net.WriteString("lscs_sv_bullet_can_interrupt_attack")
			net.WriteString( val and "1" or "0" )
		net.SendToServer()
	end

	LSCS:SetActivePanel( Panel )
	LSCS:SideBar( Frame )

	Frame.ID = 6
end

function LSCS:RefreshMenu()
	if not IsValid( Frame ) then return end

	if Frame.ID == 2 then
		LSCS:BuildInventory( Frame )
	end
	if Frame.ID == 3 then
		LSCS:BuildSaberMenu( Frame )
	end
	if Frame.ID == 4 then
		LSCS:BuildStanceMenu( Frame )
	end
	if Frame.ID == 5 then
		LSCS:BuildForceMenu( Frame )
	end
	if Frame.ID == 6 then
		LSCS:BuildSettings( Frame )
	end
end

function LSCS:OpenMenu()
	if not IsValid( Frame ) then
		Frame = vgui.Create( "DFrame" )
		Frame:SetSize( FrameSizeX, FrameSizeY )
		Frame:SetTitle( "" )
		Frame:SetDraggable( true )
		Frame:SetScreenLock( true )
		Frame:MakePopup()
		Frame:Center()
		Frame.Paint = function(self, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, menu_light )
			draw.RoundedBoxEx( 8, 0, 0, w, FrameBarHeight, menu_dark, true, true, false, false)
			draw.SimpleText( "[LSCS] - Control Panel ", "LSCS_FONT", 5, 11, menu_white_dim , TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		Frame.GetSideBar = function(self)
			return self.SideBar 
		end
		Frame.SideBarIsActivated = function( self )
			return self._smSB == SelectorWidthActive
		end
		Frame.SideBarIsActive = function( self )
			return self._isActive == true
		end
		Frame.SideBarSetActive = function( self, active )
			self._isActive = active
		end
		Frame.oldThink = Frame.Think
		Frame.Think = function( self )
			self:oldThink()

			local Rate = RealFrameTime() * 1000
			local Active = self:SideBarIsActive()
			local TargetWidth = Active and SelectorWidthActive or SelectorWidth

			local X, Y = self:CursorPos()

			if Active then
				if X < 0 or X > SelectorWidthActive or Y < 0 or Y > FrameSizeY then
					self:SideBarSetActive( false )
				end
			else
				if X > 0 and X < SelectorWidth and Y > 0 and Y < FrameSizeY then
					self:SideBarSetActive( true )
				end
			end

			self._smSB = self._smSB and (self._smSB + math.Clamp(TargetWidth - self._smSB,-Rate,Rate)) or SelectorWidth

			if self._smSB ~= self.old_smSB then
				self.old_smSB = self._smSB

				local SB = self:GetSideBar()
				if IsValid( SB ) then
					SB:SetSize( self._smSB, SelectorHeight )
				end
			end
		end

		LSCS:BuildMainMenu( Frame )
	end
end

list.Set( "DesktopWindows", "LSCSMenu", {
	title = "[LSCS] Menu",
	icon = "lscs/ui/icon64.png",
	init = function( icon, window )
		LSCS:OpenMenu()
	end
} )

concommand.Add( "lscs_openmenu", function( ply, cmd, args ) LSCS:OpenMenu() end )

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_gesture_anims.lua:

local meta = FindMetaTable( "Player" )

if SERVER then
	util.AddNetworkString( "lscs_animations" )

	function meta:lscsPlayAnimation( anim )
		net.Start( "lscs_animations" )
			net.WriteEntity( self )
			net.WriteBool( false )
			net.WriteString( anim )
		net.Broadcast()
	end
else
	-- just some gesture smoothing taken directly from my Jedi Academy saber. If someone has an idea how to replace the think player.getall please tell me. 
	-- In real tests this never made a difference in performance as the blade rendering is 10000 times worse than this
	hook.Add("Think", "!!!!lscs_unforgiveable_playerGetAll_loop_in_think_hook", function()
		local FT = FrameTime()
		local FT10 = FT * 10

		local Time = CurTime() 

		for _, ply in ipairs( player.GetAll() ) do
			local weapon = ply:GetActiveWeapon()

			if IsValid( weapon ) and weapon.LSCS then
				ply._lscsResetGestures = true

				local TargetWeight = weapon:GetGestureTime() > Time and 1 or 0
				ply._smGestureWeight = ply._smGestureWeight and ply._smGestureWeight + math.Clamp(TargetWeight - ply._smGestureWeight,-FT * 4,FT10) or 0
				ply:AnimSetGestureWeight( GESTURE_SLOT_ATTACK_AND_RELOAD, ply._smGestureWeight )

				local VCDWeight = ((ply.__sm_lscsVCD or 0) < Time) and 0 or (1 - ply._smGestureWeight)
				ply.__sm_lscsVCDWeight = ply.__sm_lscsVCDWeight and ply.__sm_lscsVCDWeight + math.Clamp(VCDWeight - ply.__sm_lscsVCDWeight,-FT10,FT10) or 0
				ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, ply.__sm_lscsVCDWeight )
			else
				if ply._lscsResetGestures then -- in case some other addon uses these slots. Lets not take them hostage by having weight set to 0
					ply._lscsResetGestures = nil
					ply.__sm_lscsVCD = nil

					ply:AnimSetGestureWeight( GESTURE_SLOT_ATTACK_AND_RELOAD, 1 )
					ply:AnimResetGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD )

					ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, 1 )
					ply:AnimResetGestureSlot( GESTURE_SLOT_VCD )
				end
			end
		end
	end)

	net.Receive( "lscs_animations", function( len )
		local ply = net.ReadEntity()

		if not IsValid( ply ) then return end

		local IsAttackAnim = net.ReadBool()

		local seq = net.ReadString()

		if IsAttackAnim then
			local start = tonumber( net.ReadString() )

			if ply == LocalPlayer() then
				if ply.s_vcd_anim ~= seq then
					-- this should only get called when a prediction error occurs or while in singleplayer/as host
					ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( seq ), start, true )
				end
			else
				ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( seq ), start, true )
			end
		else
			local seqid = ply:LookupSequence( seq )

			ply.__sm_lscsVCD = CurTime() + 0.5
			ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, seqid,0, true )
		end
	end )
end

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_movement.lua:
-- alternative to ply:SetVelocity. Much smoother client experience

local meta = FindMetaTable( "Player" )

if CLIENT then
	hook.Add( "CreateMove", "!!!lscs_movementoverride", function( cmd )
		local ply = LocalPlayer()

		if not ply._lscsTimedMove then ply._lscsTimedMove = {} end

		local Time = CurTime()

		if ply._lscsWalkTime then
			if ply._lscsWalkTime < CurTime() then
				ply._lscsWalkTime = nil
			else
				local max = ply:GetSlowWalkSpeed()

				cmd:SetForwardMove( math.Clamp( cmd:GetForwardMove(), -max, max ) )
				cmd:SetUpMove( math.Clamp( cmd:GetUpMove(), -max, max ) )
				cmd:SetSideMove( math.Clamp( cmd:GetSideMove(), -max, max ) )

				return
			end
		end

		if ply:InVehicle() or table.IsEmpty( ply._lscsTimedMove ) then return end

		local Move

		for id, obj in pairs( ply._lscsTimedMove ) do
			if (obj.start + obj.duration) <= Time then
				ply._lscsTimedMove[id] = nil
				continue
			end

			if obj.start <= Time then
				if not Move then
					Move = obj.move
				else
					Move = Move + obj.move
				end
			end
		end

		if not Move then return end

		if ply:GetMoveType() ~= MOVETYPE_WALK then return end

		cmd:ClearMovement()

		cmd:SetForwardMove( Move.x )
		cmd:SetUpMove( Move.z )
		cmd:SetSideMove( Move.y )
	end )

	function meta:lscsSetTimedMove( ID, time_start, time_duration, movement )
		self._lscsTimedMove[ ID ] = {
			start = time_start,
			duration = time_duration,
			move = movement,
		}
	end

	net.Receive( "lscs_nw_movement", function( len )
		local DoWhat = net.ReadBool()

		if DoWhat then
			LocalPlayer():lscsSetTimedMove( -1, CurTime(), 0.5, Vector(0,0,0) )
		else
			local DoHowLong = net.ReadFloat()

			LocalPlayer()._lscsWalkTime = CurTime() + DoHowLong
		end
	end)
else
	util.AddNetworkString( "lscs_nw_movement" )

	function meta:lscsSetTimedMove( ID )
		if ID then return end

		net.Start( "lscs_nw_movement" )
			net.WriteBool( true )
		net.Send( self )
	end

	function meta:lscsForceWalk( seconds )
		net.Start( "lscs_nw_movement" )
			net.WriteBool( false )
			net.WriteFloat( seconds )
		net.Send( self )
	end
end

hook.Add( "PlayerFootstep", "!!!lscs_CustomFootstep", function( ply, pos, foot, sound, volume, rf )
	local weapon = ply:GetActiveWeapon()

	if IsValid( weapon ) and weapon.LSCS then
		if weapon:GetGestureTime() > CurTime() then
			return true
		end
	end
end )

function meta:lscsClearTimedMove()
	if not self._lscsTimedMove then self._lscsTimedMove = {} end

	for ID, _ in pairs( self._lscsTimedMove ) do
		if ID ~= -1 then
			self._lscsTimedMove[ ID ] = nil
		end
	end
end

--PATH lua/lscs/combos/advanced_form2.lua:
COMBO.id = "form2b"
COMBO.PrintName = "Advanced:Makashi(II)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Ysalamiri"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 120-- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form2_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,375) - Angle(0,ply:EyeAngles().y,0):Forward() * 75 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "mak_atk_normal_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "mak_atk_normal_2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["+45+"] = {
		AttackAnim = "mak_atk_normal_2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
	["W_S_"] = {
		AttackAnim = "mak_atk_w_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )


			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.55,
	},
	["__S_"] = {
		AttackAnim = "mak_atk_s_2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(-1,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.55,
	},
	["_A__"] = {
		AttackAnim = "mak_atk_a_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,-1,0) )
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["___D"] = {
		AttackAnim = "mak_atk_d_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,1,0) )
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.55,
	},
	["W__D"] = { 
		AttackAnim = "mak2_atk3_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.45,
	},
	["WA__"] = {
		AttackAnim = "mak2_atk2_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.45,
	},
	["__SD"] = {
		AttackAnim = "mak_atk_sd_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.35,
	},
	["_AS_"] = {
		AttackAnim = "mak_atk_sa_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.35,
	},
	["W___"] = {
		AttackAnim = "mak2_atk1_2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 0.3, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.55,
	},
}

--PATH lua/lscs/combos/advanced_form3.lua:
return gluapack()()
--PATH lua/lscs/combos/advanced_form4.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/agile.lua:
COMBO.id = "agile"
COMBO.PrintName = "Agile"
COMBO.Author = "RareLogan"
COMBO.Description = "Agility on top yuh yuh"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-meleestamina-type"

COMBO.DamageMultiplier = 0.75
COMBO.BPDrainPerHit = 75
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "ryoku_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "b_c4_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH lua/lscs/combos/basic_form3.lua:
return gluapack()()
--PATH lua/lscs/combos/basic_form4.lua:
COMBO.id = "form4a"
COMBO.PrintName = "Basic:Ataru(IV)"
COMBO.Author = "Storm"
COMBO.Description = "the Way of the Hawk-Bat"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 65 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form4_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ataru4_jump_attack",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ataru4_jump_attack_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["-45-"] = {
		AttackAnim = "ataru4_jump_achilles_80s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "ataru4_jump_achilles_80s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "ata_atk_w_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["__S_"] = {
		AttackAnim = "ataru4_back_flip_80s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["_A__"] = {
		AttackAnim = "ataru4_jump_slash_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["___D"] = {
		AttackAnim = "ataru4_jump_stab_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["W__D"] = {
		AttackAnim = "ataru4_wd_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "ataru4_right_spin_v2_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["__SD"] = {
		AttackAnim = "ataru4_sd_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["_AS_"] = {
		AttackAnim = "ataru4_sa_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "ataru4_jump_achilles_80s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/crescentdual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/determinationdual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/diplomat.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/djemso.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juggernaut.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juggernautdual.lua:
return gluapack()()
--PATH lua/lscs/combos/master_form2.lua:
return gluapack()()
--PATH lua/lscs/combos/master_form4.lua:
COMBO.id = "form4c"
COMBO.PrintName = "Master:Ataru(IV)"
COMBO.Author = "Storm"
COMBO.Description = "the Way of the Hawk-Bat"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 8 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form4_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ataru4_jump_attack",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ataru4_jump_attack_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "ataru4_jump_achilles_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["+45+"] = {
		AttackAnim = "ataru4_jump_achilles_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W_S_"] = {
		AttackAnim = "ata_atk_w_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["__S_"] = {
		AttackAnim = "ataru4_back_flip_50s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["_A__"] = {
		AttackAnim = "ataru4_jump_slash_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "ataru4_jump_stab_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "ataru4_wd_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "ataru4_right_spin_v2_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["__SD"] = {
		AttackAnim = "ataru4_sd_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "ataru4_sa_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W___"] = {
		AttackAnim = "ataru4_jump_achilles_50s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
						if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_ihatemylife.lua:
local blade = {}
blade.PrintName = "Kylos Blade" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "rubind" -- internal ID. Always lower case.
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.9 -- width
blade.widthWiggle = 1.5 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_core = Material( "lscs/effects/lightsaber_core" ) -- material of the inner cores blade
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Azurite" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "azurite" -- internal ID. Always lower case.
blade.color_blur = Color(0,255,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Diamond" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "diamond" -- internal ID. Always lower case.
blade.color_blur = Color(0,152,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Almandine" -- nice name in the menu
blade.Author = "Midnight"
blade.id = "almandine" -- internal ID. Always lower case.
blade.color_blur = Color(99,13,59)
blade.color_core = Color(42,13,128)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Orange" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "orange" -- internal ID. Always lower case.
blade.color_blur = Color(255,108,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Gold" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "gold" -- internal ID. Always lower case.
blade.color_blur = Color(255,209,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Chartreuse" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "chartreuse" -- internal ID. Always lower case.
blade.color_blur = Color(185,255,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Quartz" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "quartz" -- internal ID. Always lower case.
blade.color_blur = Color(135,135,135)
blade.color_core = Color(135,135,135)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Red Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "redinner" -- internal ID. Always lower case.
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Blue Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "blueinner" -- internal ID. Always lower case.
blade.color_blur = Color(0,0,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Green Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "greeninner" -- internal ID. Always lower case.
blade.color_blur = Color(0,255,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Purple Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "purpleinner" -- internal ID. Always lower case.
blade.color_blur = Color(150,0,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Yellow Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "yellowinner" -- internal ID. Always lower case.
blade.color_blur = Color(255,255,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Orange Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "orangeinner" -- internal ID. Always lower case.
blade.color_blur = Color(255,162,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Cyan Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "cyaninner" -- internal ID. Always lower case.
blade.color_blur = Color(0,255,230)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Pink Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "pinkinner" -- internal ID. Always lower case.
blade.color_blur = Color(255,0,247)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "White Dark Inner" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "whiteinner" -- internal ID. Always lower case.
blade.color_blur = Color(255,255,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Pike Crystal" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "pike" -- internal ID. Always lower case.
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 25 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Sith Crystal" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "sith" -- internal ID. Always lower case.
blade.color_blur = Color(255,0,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Light Red" -- nice name in the menu
blade.Author = "InGame"
blade.id = "lightred" -- internal ID. Always lower case.
blade.color_blur = Color(250,70,80)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Yellow" -- nice name in the menu
blade.Author = "InGame"
blade.id = "yellow" -- internal ID. Always lower case.
blade.color_blur = Color(255,217,0)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Purple" -- nice name in the menu
blade.Author = "InGame"
blade.id = "purple" -- internal ID. Always lower case.
blade.color_blur = Color(100,0,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity

local blade = {}
blade.PrintName = "Pink"-- nice name in the menu
blade.Author = "InGame"
blade.id = "pink" -- internal ID. Always lower case.
blade.color_blur = Color(255,65,210)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_cloak.lua:
local force = {}
force.PrintName = "Cloak"
force.Author = "Blu-x92 / Luna"
force.Description = "Hide yourself from all but the most perceptive."
force.id = "cloak"
force.OnClk =  function( ply, TIME )

	local _HeldSwep = ply:GetActiveWeapon()

	if not ply:GetNWBool( "_lscsForceCloak", false ) then return end 
	-- Anywhere you see a ply:SetNWBool or ply:GetNWBool is either setting or checking a true or false to see if the cloak is active
	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then -- If the player is dead or in an observer mode, they shouldn't be cloaked
		ply:SetNWBool( "_lscsForceCloak", false )
		return
	end

	ply:lscsTakeForce() -- Keeps force from regenerating while cloak is active
 
	if (ply._lscsCloakTime or 0) < TIME then -- If the cloak runs out...
		ply:SetNWBool( "_lscsForceCloak", false ) -- Turn off cloak
		ply:SetRenderMode( 0 ) -- Make the player and weapon  opaque
		_HeldSwep:SetRenderMode( 0 )
		ply:SetColor( Color(255, 255, 255, 255) ) -- Reset player and weapon color
		_HeldSwep:SetColor( Color(255, 255, 255, 255) )
		ply._lscsNextForce = CurTime() + 15 -- Starts a 15 second cooldown
		ply:SetNoTarget( false ) -- Makes the player targetable by NPCS
		hook.Add( "PlayerSwitchWeapon", "WeaponSwitchCloak", function( ply, oldWeapon, newWeapon )
			newWeapon:SetRenderMode( 0 )
			newWeapon:SetColor( Color(255, 255, 255, 255) )
		end)
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceCloak", false ) end -- Turns off cloak if the power is unequipped
force.StartUse = function( ply )
	local Time = CurTime()
	
	local _HeldSwep = ply:GetActiveWeapon()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end -- Stops people from spamming the ability

	ply._lscsNextForce = Time + 1 -- Use the integer here to edit the base cooldown
	
	if ply:GetNWBool( "_lscsForceCloak", false ) then
		ply:SetNWBool( "_lscsForceCloak", false )
		ply._lscsNextForce = Time + 15 -- If the player turns off the cloak manually, have a 15 second cooldown before they can turn it back on
	else
		if ply:lscsGetForce() >= 30 then -- cannot turn on cloak if you have less than 30 force
			ply:SetNWBool( "_lscsForceCloak", true )
			ply._lscsCloakTime = CurTime() + 15 -- Cloak will only stay on for 15 seconds, change the integer if you want it longer or shorter

			ply:lscsTakeForce( 30 ) -- Change integer to set force cost
			ply:EmitSound("lscs/force/pull.mp3")
		end
	end
	if ply:GetNWBool( "_lscsForceCloak", true ) == true then -- Makes the player and weapon able to be translucent and then sets their color
		ply:SetRenderMode( 1 )
		_HeldSwep:SetRenderMode( 1 )
		ply:SetColor( Color(0, 0, 0, 20) )
		_HeldSwep:SetColor( Color(0, 0, 0, 20) )
		ply:SetNoTarget( true ) -- Makes NPCS ignore the player (This is so easy, why do so few cloaks actually do it? e_e)
		hook.Add( "PlayerSwitchWeapon", "WeaponSwitchCloak", function( ply, oldWeapon, newWeapon )
			newWeapon:SetRenderMode( 1 )
			newWeapon:SetColor( Color(0, 0, 0, 20) )
		end)
	end
	if ply:GetNWBool( "_lscsForceCloak", false ) == false then -- Makes the player and weapon opaque if the player manually turns off the cloak
		ply:SetRenderMode( 0 )
		_HeldSwep:SetRenderMode( 0 )
		ply:SetColor( Color(255, 255, 255, 255) )
		_HeldSwep:SetColor( Color(255, 255, 255, 255) )
		ply:SetNoTarget( false )
		hook.Add( "PlayerSwitchWeapon", "WeaponSwitchCloak", function( ply, oldWeapon, newWeapon )
			newWeapon:SetRenderMode( 0 )
			newWeapon:SetColor( Color(255, 255, 255, 255) )
		end)
	end
end
LSCS:RegisterForce( force )


	
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_extinguish.lua:
local force = {}
force.PrintName = "Extinguish"
force.Author = "Midnight"
force.Description = "Extinguishes a burning target using the Force."
force.id = "extinguish" -- lowercase only
--force.Spawnable = false  -- uncomment to unlist in q-menu

force.StartUse = function(ply)
    if ply:lscsGetForce() < 20 then return end -- Check if the player has enough Force points (30 in this case)

    local target = FindTargetInView(ply, 200) -- We set a view range of 200 units

    if not IsValid(target) or (not target:IsPlayer() and not target:IsNPC()) or not target:IsOnFire() then return end -- Exit if no valid target or the target isn't burning

    ply:lscsTakeForce(20) -- Deduct Force points required to use the power

    --ply:EmitSound("vehicles/Airboat/pontoon_fast_water_loop1.wav") -- Play extinguishing sound

    LSCS:PlayVCDSequence(ply, "wos_jedi_forceblast", 0.7) 

    ExtinguishTarget(target)

    -- Example of using a particle system for visual effect
    local effectData = EffectData()
    effectData:SetStart(ply:GetPos()) -- Set the effect's starting point to the main player's location
    effectData:SetOrigin(target:GetPos()) -- Make the effect go to the target's location
    effectData:SetScale(1)
    effectData:SetEntity(ply) -- Set the entity that the effect is linked to as the main player
    util.Effect("extinguish_effect", effectData) -- Replace with an appropriate extinguishing effect
end

-- Function to find a target (player or NPC) in view within a specific distance
function FindTargetInView(ply, distance)
    local trace = util.TraceLine({
        start = ply:EyePos(),
        endpos = ply:EyePos() + ply:GetAimVector() * distance,
        filter = function(ent) return (ent:IsPlayer() or ent:IsNPC()) and ent ~= ply end
    })

    return trace.Entity
end

-- Function to extinguish a burning target (player or NPC)
function ExtinguishTarget(target)
    if IsValid(target) and target:IsOnFire() then
        target:Extinguish() -- Stop the fire effect on the target
        print("Extinguished target: " .. tostring(target))
    end
end

force.StopUse = function(ply)
    -- Called when the force power key is released
end

LSCS:RegisterForce(force)

--PATH lua/lscs/content/force_judgement.lua:
local force = {}
force.PrintName = "Purify"
force.Author = "Valkorius"
force.Description = "A Light Side ability that fires healing lightning bolts out of your hand"
force.id = "purifyi"
force.OnClk =  function( ply, TIME )
	if not ply._lscsJudgementiiTime then return end

	ply:lscsTakeForce( 6 )

	ForceJIIFry( ply, TIME )

	if ply._lscsJudgementiiStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsJudgementiiTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsJudgementiiTime = nil
		ply._lscsJudgementiiStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsJudgementiiTime or 0) > Time then
		ply._lscsJudgementiiTime = nil
		ply._lscsJudgementiiStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsJudgementiiTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 4 )

	ForceJIIFry( ply, Time )

	if not ply._lscsJudgementiiTime then
		ply._lscsJudgementiiTime = CurTime() + 3.5
		ply._lscsJudgementiiStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsJudgementiiTime = nil
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_massheal.lua:
local force = {}
force.PrintName = "Mass Heal"
force.Author = "Solace"
force.Description = "Heal a group using the Force"
force.id = "massheal"
local function ForceMassHeal( ply, TIME )
	local MyPos = ply:GetShootPos()
	for _, nEntity in pairs( ents.FindInSphere( MyPos, 200 ) ) do -- Are you in a certain distance?
		
		if nEntity:IsPlayer() then -- Are you a player?
			local need = nEntity:GetMaxHealth() - nEntity:Health() -- Do you actually need healing?
			if need > 0 then
				nEntity:SetHealth( math.Clamp( nEntity:Health() + 10, 0, nEntity:GetMaxHealth() ) ) --Increases their health by 10 but does not go past their max HP
				ply:lscsTakeForce(5) -- Costs 5 force
				local effectdata = EffectData()
					effectdata:SetOrigin( nEntity:GetPos() )
					effectdata:SetEntity( nEntity )
				util.Effect( "force_heal", effectdata, true, true )
			end
		end
	end
end
force.OnClk =  function( ply, TIME )
	if not ply._lscsMassHealTime then return end -- Stops healing after a certain amount of time (Defined on line 48)
	
	ForceMassHeal( ply, TIME )
	
	if ply._lscsMassHealTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsMassHealTime = nil
	end
end
force.StartUse = function( ply )

	local Time = CurTime()
	
	if ply:lscsGetForce() < 10 then return end -- Need at least 10 force

	local CanDo = (ply._lscsNextForce or 0) < Time
	if not CanDo then return end

	ply._lscsNextForce = Time + 2 -- Cooldown
		
	ForceMassHeal( ply, TIME )
	
	ply:EmitSound("lscs/force/heal.mp3")
	
	if not ply._lscsMassHealTime then
		ply._lscsMassHealTime = CurTime() + 3.5 -- Only lets you heal for 3.5 seconds at a time
	end
end
force.StopUse = function( ply )
	ply._lscsMassHealTime = nil
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_purify.lua:
local force = {}
force.PrintName = "Purify"
force.Author = "Douglas"
force.Description = "A Light Side ability that fires healing lightning bolts out of your hand"
force.id = "purifytest1"  -- Updated ID to purifytest1

-- Define the function to heal the target player upon impact
local function HealTargetPlayer(ply, target)
    if not IsValid(target) or not target:IsPlayer() then return end

    local need = target:GetMaxHealth() - target:Health()
    if need > 0 then
        local newHealth = math.Clamp(target:Health() + 20, 0, target:GetMaxHealth())  -- Adjust healing amount as needed
        target:SetHealth(newHealth)

        local effectdata = EffectData()
        effectdata:SetOrigin(ply:GetPos())
        effectdata:SetEntity(ply)
        util.Effect("force_judgementii", effectdata, true, true)  -- Visual effect for healing
    end
end

force.OnClk = function(ply, TIME)
    if not ply._lscspurifytest1Time then return end  -- Updated to _lscspurifytest1Time

    ply:lscsTakeForce(6)  -- Deduct force points

    -- Assuming ForceJIIFry function is used for impact logic
    -- ForceJIIFry(ply, TIME)

    if ply._lscspurifytest1StartTime < TIME then
        LSCS:PlayVCDSequence(ply, "gesture_item_give", 0.7)  -- Example gesture or animation
    end

    -- Check if the healing time is up or conditions are no longer met
    if ply._lscspurifytest1Time < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
        ply._lscspurifytest1Time = nil
        ply._lscspurifytest1StartTime = nil
    else
        -- Detect and heal the player the ability is aiming at
        local aimPos = ply:GetEyeTrace().HitPos
        local entities = ents.FindInSphere(aimPos, 50)  -- Adjust the radius as needed

        for _, ent in pairs(entities) do
            if ent:IsPlayer() and ent ~= ply then
                HealTargetPlayer(ply, ent)
            end
        end
    end
end

force.Equip = function(ply) end
force.UnEquip = function(ply) end

force.StartUse = function(ply)
    local Time = CurTime()

    if (ply._lscspurifytest1Time or 0) > Time then
        ply._lscspurifytest1Time = nil
        ply._lscspurifytest1StartTime = nil
        return
    end

    if ply:lscsGetForce() < 10 then return end  -- Minimum force requirement

    local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscspurifytest1Time or 0) < Time
    if not CanDo then return end

    ply._lscsNextForce = Time + 2  -- Cooldown

    ply:EmitSound("lscs/force/lightning.mp3")  -- Sound effect

    ply:lscsTakeForce(0.1)  -- Deduct force points

    -- Assuming ForceJIIFry function is used for impact logic
    -- ForceJIIFry(ply, Time)

    if not ply._lscspurifytest1Time then
        ply._lscspurifytest1Time = CurTime() + 3.5  -- Duration of healing effect
        ply._lscspurifytest1StartTime = CurTime() + 0.15

        LSCS:PlayVCDSequence(ply, "gesture_signal_forward", 0.1)  -- Example gesture or animation
    end
end

force.StopUse = function(ply)
    ply._lscspurifytest1Time = nil
    ply._lscspurifytest1StartTime = nil
end

LSCS:RegisterForce(force)
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_ink.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_swtor2.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/lscs_hilts.lua:

--[[
	v v v Hilt v v v
]]
local hilt = {}
hilt.PrintName = "Katarn"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "katarn"
hilt.mdl = "models/lscs/weapons/katarn.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(4.25, -1.5, -1),
			ang = Angle(172, 0, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 1),
			ang = Angle(8, 0, -10),
		},
	},
	GetBladePos = function( ent )
		if not ent.BladeID then
			ent.BladeID = ent:LookupAttachment( "primary_blade" )
		end

		local att = ent:GetAttachment( ent.BladeID )

		if att then
			local blades = {
				[1] = {
					pos = att.Pos,
					dir = att.Ang:Up(),
				}
			}
			return blades
		end
	end,
}
LSCS:RegisterHilt( hilt )


-- modify previous hilt, only change what we need to change
hilt.PrintName = "Nano Sword"
hilt.Author = "Salza"
hilt.id = "nanosword"
hilt.mdl = "models/lscs/weapons/nanosword.mdl"
LSCS:RegisterHilt( hilt )


-- modify previous hilt, only change what we need to change
hilt.PrintName = "Vibro Sword"
hilt.Author = "Blu-x92 / Luna"
hilt.Spawnable = false -- special case, not spawnable from menu
hilt.id = "vibrosword"
hilt.mdl = "models/lscs/weapons/vibrosword.mdl"
LSCS:RegisterHilt( hilt )


-- entirely new  hilt
local hilt = {}
hilt.PrintName = "Staff"
hilt.Author = "Blu-x92 / Luna"
hilt.id = "guard"
hilt.mdl = "models/lscs/weapons/staff.mdl"
hilt.info = {
	ParentData = {
		["RH"] = {
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector(4.25, -1.5, -3),
			ang = Angle(172, 0, 10),
		},
		["LH"] = {
			bone = "ValveBiped.Bip01_L_Hand",
			pos = Vector(4.25, -1.5, 3),
			ang = Angle(8, 0, -10),
		},
	},
	GetBladePos = function( ent )
		if not ent.BladeID1 then
			ent.BladeID1 = ent:LookupAttachment( "primary_blade" )
		end
		if not ent.BladeID2 then
			ent.BladeID2 = ent:LookupAttachment( "secondary_blade" )
		end

		local att1 = ent:GetAttachment( ent.BladeID1 )
		local att2 = ent:GetAttachment( ent.BladeID2 )

		if att1 and att2 then
			local blades = {
				[1] = {
					pos = att1.Pos,
					dir = att1.Ang:Up(),
				},
				[2] = {
					pos = att2.Pos,
					dir = att2.Ang:Up(),
				}
			}
			return blades
		end
	end,
}
LSCS:RegisterHilt( hilt )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/private_blades.lua:
local blade = {}
blade.PrintName = "Blue" 
blade.Author = "RareLogan"
blade.id = "bluehor" -- internal ID. Always lower case.
blade.color_blur = Color(0, 0, 190)
blade.color_core = Color(255, 255, 255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
--blade.mdl_poseparameter = "blade_retract" 
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/saber_on1.wav",
	Disable = "lightsaber/saber_off1.wav",
	Idle =  "lightsaber/saber_loop1.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Light Blue" 
blade.Author = "RareLogan"
blade.id = "lblue" -- internal ID. Always lower case.
blade.color_blur = Color(0, 120, 190)
blade.color_core = Color(255, 255, 255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
--blade.mdl_poseparameter = "blade_retract" 
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/saber_on1.wav",
	Disable = "lightsaber/saber_off1.wav",
	Idle =  "lightsaber/saber_loop1.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Green" 
blade.Author = "RareLogan"
blade.id = "greenhor" -- internal ID. Always lower case.
blade.color_blur = Color(0, 200, 0)
blade.color_core = Color(255, 255, 255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
--blade.mdl_poseparameter = "blade_retract" 
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/saber_on1.wav",
	Disable = "lightsaber/saber_off1.wav",
	Idle =  "lightsaber/saber_loop1.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Red" 
blade.Author = "RareLogan"
blade.id = "redhor" -- internal ID. Always lower case.
blade.color_blur = Color(200, 0, 0)
blade.color_core = Color(255, 255, 255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
--blade.mdl_poseparameter = "blade_retract" 
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/saber_on3.wav",
	Disable = "lightsaber/saber_off3.wav",
	Idle =  "lightsaber/saber_loop3.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "White" 
blade.Author = "RareLogan"
blade.id = "white" -- internal ID. Always lower case.
blade.color_blur = Color(255,255,255)
blade.color_core = Color(255, 255, 255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl"
--blade.mdl_poseparameter = "blade_retract" 
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "saber_turnon",
	Disable = "saber_turnoff",
	Idle =  "lscs/saber/saberhum4.wav",
}
LSCS:RegisterBlade( blade )

local blade = {}
blade.PrintName = "Dark Crystal" -- nice name in the menu
blade.Author = "RareLogan"
blade.id = "darksaber" -- internal ID. Always lower case.
blade.color_blur = Color(255,255,255)
blade.color_core = Color(255,255,255)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 45 -- blade length
blade.width = 0.6 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core = Material( "lscs/effects/lightsaber_coreblack")
blade.material_trail = Material( "lscs/effects/lightsaber_trailblack" ) -- what material to use for the trail
blade.material_core_tip = Material( "lscs/effects/lightsaber_tipblack" )
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "saber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Attack1 = "saber_spin1", -- SWEP:DoAttackSound( 1, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack2 = "saber_spin2", -- SWEP:DoAttackSound( 2, NUMBER_HAND) for NUMBER_HAND see comment above
	Attack3 = "saber_spin3", -- SWEP:DoAttackSound( 3, NUMBER_HAND) for NUMBER_HAND see comment above
	Activate = "lightsaber/darksaber_on.wav",
	Disable = "lightsaber/darksaber_off.wav",
	Idle =  "lightsaber/darksaber_loop.wav",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity
--PATH lua/lvs_framework/init.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/cl_fonts.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/cl_menu.lua:
return gluapack()()
--PATH lua/autorun/maul.lua:
return gluapack()()
--PATH addons/[mrs] mc_ranks/lua/autorun/mc_ranks.lua:
-- 
-- 
-- By MacTavish <3
-- 
-- 
-- 

MRS = {}
MRS.Config = {}
MRS.Ranks = {}
MRS.PlayerStats = {}
MRS.Version = "1.2.3"
MRS.ServerID = "MRS77656119819628010502ID"
MRS.MainUserID = "76561198196280105"
MRS.DB = {}

if SERVER then
	util.AddNetworkString( "MRS.Notify" )
	util.AddNetworkString( "MRS.TaskNotify" )
	util.AddNetworkString( "MRS.SetPData" )
	util.AddNetworkString( "MRS.GetBigData" )
	util.AddNetworkString( "MRS.DataShare" )
	util.AddNetworkString( "MRS.GetPData" )
	util.AddNetworkString( "MRS.OpenEditor" )
	util.AddNetworkString( "MRS.GetConfigData" )
	util.AddNetworkString( "MRS.SaveConfig" )
	util.AddNetworkString( "MRS.RanksRemove" )
	util.AddNetworkString( "MRS.RanksSubmit" )
	util.AddNetworkString( "MRS.RanksUpdate" )
	util.AddNetworkString( "MRS.GetPlayersRanks" )
	util.AddNetworkString( "MRS.SavePlayerRankList" )
	util.AddNetworkString( "MRS.RequestStoredData" )
	resource.AddWorkshop( "2689168958" )
end

function MRS.Load()
	MsgC(Color(0, 255, 0), "[MRS] Initialization started\n")

	if not file.Exists(MRS.ServerID, "DATA") then
		file.CreateDir(MRS.ServerID)
		MsgC(Color(0, 255, 0), "[MRS] Server DATA Dir created \n")
	end

	MsgC(Color(0, 255, 0), "[MRS] Initialization started\n")

	if SERVER then
		include("mc_ranks/sh_config.lua")
		AddCSLuaFile("mc_ranks/sh_config.lua")
		local f = file.Find("mc_ranks/core/*", "LUA")

		for _, v in ipairs(f) do
			if string.StartWith(v, "sh_") then
				include("mc_ranks/core/" .. v)
				AddCSLuaFile("mc_ranks/core/" .. v)
			elseif string.StartWith(v, "sv_") then
				include("mc_ranks/core/" .. v)
			elseif string.StartWith(v, "cl_") then
				AddCSLuaFile("mc_ranks/core/" .. v)
			end
		end

		f = file.Find("mc_ranks/ui/*", "LUA")

		for _, v in ipairs(f) do
			AddCSLuaFile("mc_ranks/ui/" .. v)
		end
	else
		include("mc_ranks/sh_config.lua")
		local f = file.Find("mc_ranks/core/*", "LUA")

		for _, v in ipairs(f) do
			if string.StartWith(v, "sh_") then
				include("mc_ranks/core/" .. v)
			elseif string.StartWith(v, "cl_") then
				include("mc_ranks/core/" .. v)
			end
		end

		f = file.Find("mc_ranks/ui/*", "LUA")

		for _, v in ipairs(f) do
			include("mc_ranks/ui/" .. v)
		end
	end

	MsgC(Color(0, 255, 0), "[MRS] Initialization done\n")
end

if SERVER then
	hook.Add("PostGamemodeLoaded", "MRS.Load.SV", function()
		MRS.Load()
	end)
else
	hook.Add("InitPostEntity", "MRS.Load.CL", function()
		MRS.Load()
	end)
end

if GAMEMODE then
	MRS.Load()
end
--PATH lua/mediaplayer/controls/dmediaplayerhtml.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/cl_init.lua:
include "shared.lua"
include "cl_draw.lua"
include "cl_fullscreen.lua"
include "net.lua"

local CeilPower2 = MediaPlayerUtils.CeilPower2

function MEDIAPLAYER:NetReadUpdate()
	-- Allows for another media player type to extend update net messages
end

function MEDIAPLAYER:OnNetReadMedia( media )
	-- Allows for another media player type to extend media net messages
end

function MEDIAPLAYER:OnQueueKeyPressed( down, held )
	self._LastMediaUpdate = RealTime()
end


--[[---------------------------------------------------------
	Networking
-----------------------------------------------------------]]

local function OnMediaUpdate( len )

	local mpId = net.ReadString()
	local mpType = net.ReadString()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Update", mpId, mpType )
	end

	local mp = MediaPlayer.GetById(mpId)
	if not mp then
		mp = MediaPlayer.Create( mpId, mpType )
	end

	-- Read owner; may be NULL
	local owner = net.ReadEntity()
	if IsValid( owner ) then
		mp:SetOwner( owner )
	end

	local state = mp.net.ReadPlayerState()

	local queueRepeat = net.ReadBool()
	mp:SetQueueRepeat( queueRepeat )

	local queueShuffle = net.ReadBool()
	mp:SetQueueShuffle( queueShuffle )

	local queueLocked = net.ReadBool()
	mp:SetQueueLocked( queueLocked )

	-- Read extended update information
	mp:NetReadUpdate()

	-- Clear old queue
	mp:ClearMediaQueue()

	-- Read queue information
	local count = net.ReadUInt( mp:GetQueueLimit(true) )
	for i = 1, count do
		local media = mp.net.ReadMedia()
		mp:OnNetReadMedia(media)
		mp:AddMedia(media)
	end

	mp:QueueUpdated()

	mp:SetPlayerState( state )

	hook.Run( "OnMediaPlayerUpdate", mp )

end
net.Receive( "MEDIAPLAYER.Update", OnMediaUpdate )

local function OnMediaSet( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Media" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)

	if not mp then
		if MediaPlayer.DEBUG then
			ErrorNoHalt("Received media for invalid mediaplayer\n")
			print("ID: " .. tostring(mpId))
			debug.Trace()
		end
		return
	end

	if mp:GetPlayerState() >= MP_STATE_PLAYING then
		mp:OnMediaFinished()
		mp:QueueUpdated()
	end

	local media = mp.net.ReadMedia()

	if media then
		local startTime = mp.net.ReadTime()
		media:StartTime( startTime )

		mp:OnNetReadMedia(media)

		local state = mp:GetPlayerState()

		if state == MP_STATE_PLAYING then
			media:Play()
		else
			media:Pause()
		end
	end

	mp:SetMedia( media )

end
net.Receive( "MEDIAPLAYER.Media", OnMediaSet )

local function OnMediaRemoved( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Remove" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	mp:Remove()

end
net.Receive( "MEDIAPLAYER.Remove", OnMediaRemoved )

local function OnMediaSeek( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not ( mp and (mp:GetPlayerState() >= MP_STATE_PLAYING) ) then return end

	local startTime = mp.net.ReadTime()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Seek", mpId, startTime )
	end

	local media = mp:CurrentMedia()

	if media then
		media:StartTime( startTime )
	else
		ErrorNoHalt('ERROR: MediaPlayer received seek message while no media is playing' ..
			'[' .. mpId .. ']\n')
		MediaPlayer.RequestUpdate( mp )
	end

end
net.Receive( "MEDIAPLAYER.Seek", OnMediaSeek )

local function OnMediaPause( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	local state = mp.net.ReadPlayerState()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Pause", mpId, state )
	end

	mp:SetPlayerState( state )

end
net.Receive( "MEDIAPLAYER.Pause", OnMediaPause )

--PATH lua/mediaplayer/players/entity/sh_meta.lua:
return gluapack()()
--PATH lua/mediaplayer/services/base/shared.lua:
local string = string
local urllib = url
local os = os

local FormatSeconds = MediaPlayerUtils.FormatSeconds

SERVICE.Name 	= "Base Service"
SERVICE.Id 		= "base"
SERVICE.Abstract = true

-- Inherit EventEmitter for all service instances
EventEmitter:new(SERVICE)

local OwnerInfoPattern = "%s [%s]"

function SERVICE:New( url )
	local obj = setmetatable( {}, {
		__index = self,
		__tostring = self.__tostring
	} )

	obj.url = url

	local success, urlinfo = pcall(urllib.parse2, url)
	obj.urlinfo = success and urlinfo or {}

	if CLIENT then
		obj._playing = false
		obj._volume = 0.33
	end

	return obj
end

function SERVICE:__tostring()
	return string.format( '%s, %s, %s',
		self:Title(),
		FormatSeconds(self:Duration()),
		self:OwnerName() )
end

--
-- Determines if the media is valid.
--
-- @return boolean
--
function SERVICE:IsValid()
	return true
end

--
-- Determines if the media supports the given URL.
--
-- @param url URL.
-- @return boolean
--
function SERVICE:Match( url )
	return false
end

--
-- Gives the unique data used as part of the primary key in the metadata
-- database.
--
-- @return String
--
function SERVICE:Data()
	return self._data
end

function SERVICE:Owner()
	return self._Owner
end

SERVICE.GetOwner = SERVICE.Owner

function SERVICE:OwnerName()
	return self._OwnerName or ""
end

function SERVICE:OwnerSteamID()
	return self._OwnerSteamID or ""
end

function SERVICE:OwnerInfo()
	return OwnerInfoPattern:format( self._OwnerName, self._OwnerSteamID )
end

function SERVICE:IsOwner( ply )
	return ply == self:GetOwner() or
		ply:SteamID() == self:OwnerSteamID()
end

function SERVICE:Title()
	return self._metadata and self._metadata.title or "Unknown"
end

function SERVICE:Duration( duration )
	if duration then
		self._metadata = self._metadata or {}
		self._metadata.duration = duration
	end

	return self._metadata and self._metadata.duration or -1
end

--
-- Determines whether the media is timed.
--
-- @return boolean
--
function SERVICE:IsTimed()
	return true
end

function SERVICE:Thumbnail()
	return self._metadata and self._metadata.thumbnail
end

function SERVICE:Url()
	return self.url
end

SERVICE.URL = SERVICE.Url

function SERVICE:SetMetadata( metadata, new )
	self._metadata = metadata

	if new then
		local title = self._metadata.title or "Unknown"
		title = title:sub(1, MaxTitleLength)

		-- Escape any '%' char with a letter following it
		title = title:gsub('%%%a', '%%%%')

		self._metadata.title = title
	end
end

function SERVICE:SetMetadataValue( key, value )
	if not self._metadata then
		self._metadata = {}
	end

	self._metadata[key] = value
end

function SERVICE:GetMetadataValue( key )
	return self._metadata and self._metadata[key]
end

function SERVICE:UniqueID()
	if not self._id then
		local data = self:Data()
		if not data then
			data = util.CRC(self.url)
		end

		-- e.g. yt-G2MORmw703o
		self._id = string.format( "%s-%s", self.Id, data )
	end

	return self._id
end

--[[----------------------------------------------------------------------------
	Playback
------------------------------------------------------------------------------]]

function SERVICE:StartTime( seconds )
	if type(seconds) == 'number' then
		if self._PauseTime then
			self._PauseTime = RealTime()
		end

		self._StartTime = seconds
	end

	if self._PauseTime then
		local diff = self._PauseTime - self._StartTime
		return RealTime() - diff
	else
		return self._StartTime
	end
end

function SERVICE:CurrentTime()
	if self._StartTime then
		if self._PauseTime then
			return self._PauseTime - self._StartTime
		else
			return RealTime() - self._StartTime
		end
	else
		return -1
	end
end

function SERVICE:ResetTime()
	self._StartTime = nil
	self._PauseTime = nil
end

function SERVICE:IsPlaying()
	return self._playing
end

function SERVICE:Play()
	if self._PauseTime then
		-- Update start time to match the time when paused
		self._StartTime = RealTime() - (self._PauseTime - self._StartTime)
		self._PauseTime = nil
	end

	self._playing = true

	if CLIENT then
		self:emit('play')
	end
end

function SERVICE:Pause()
	self._PauseTime = RealTime()
	self._playing = false

	if CLIENT then
		self:emit('pause')
	end
end

--PATH lua/mediaplayer/services/youtube/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/googledrive/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

-- data:text/html,<object type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" data="https://video.google.com/get_player?docid=0B1K_ByAqaFKGamdrajd6WXFUSEs0VHI4eTJHNHpPdw&partnerid=30&el=leaf&cc_load_policy=1&enablejsapi=1&autoplay=1&start=30" width="100%" height="100%" style="visibility: visible;"></object>

-- https://docs.google.com/file/d/0B1K_ByAqaFKGamdrajd6WXFUSEs0VHI4eTJHNHpPdw/preview

local EmbedHtml = [[
<object type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" data="%s" width="100%%" height="100%%" style="visibility: visible;"></object>]]

SERVICE.VideoUrlFormat = "https://video.google.com/get_player?docid=%s&enablejsapi=1&autoplay=1&controls=0&modestbranding=1&rel=0&showinfo=0&wmode=opaque&ps=docs&partnerid=30"

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local fileId = self:GetGoogleDriveFileId()

	local url = self.VideoUrlFormat:format(fileId)
	local curTime = self:CurrentTime()

	-- Add start time to URL if the video didn't just begin
	if self:IsTimed() and curTime > 3 then
		url = url .. "&start=" .. math.Round(curTime)
	end

	local html = self.WrapHTML( EmbedHtml:format(url) )
	browser:SetHTML( html )

end

--PATH lua/mediaplayer/services/vimeo/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/audiofile/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/audiofile/shared.lua:
local urllib = url

SERVICE.Name 	= "Audio file"
SERVICE.Id 		= "af"

SERVICE.PrefetchMetadata = true

local SupportedEncodings = {
	'([^/]+%.mp3)',    -- mp3
	'([^/]+%.wav)', -- wav
	'([^/]+%.ogg)'  -- ogg
}

function SERVICE:Match( url )
	url = string.lower(url or "")

	-- check supported encodings
	for _, encoding in pairs(SupportedEncodings) do
		if url:find(encoding) then
			return true
		end
	end

	return false
end

--PATH lua/mediaplayer/services/soundcloud/shared.lua:
return gluapack()()
--PATH lua/mp_menu/common.lua:
local ceil = math.ceil
local clamp = math.Clamp

local FormatSeconds = MediaPlayerUtils.FormatSeconds

--[[--------------------------------------------
	Sidebar fonts
----------------------------------------------]]

local FontTbl = {
	font = "Roboto Medium",
	size = 21,
	weight = 400,
	antialias = true
}

surface.CreateFont( "MP.MediaTitle", FontTbl )

FontTbl.font = "Roboto Medium"
FontTbl.size = 18
surface.CreateFont( "MP.MediaTime", FontTbl )

FontTbl.font = "Roboto Medium"
FontTbl.size = 18
surface.CreateFont( "MP.QueueHeader", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 18
surface.CreateFont( "MP.MediaDuration", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 13
surface.CreateFont( "MP.Prefix", FontTbl )

FontTbl.font = "Roboto Light"
FontTbl.size = 13
surface.CreateFont( "MP.VoteCount", FontTbl )

FontTbl.font = "Roboto Bold"
FontTbl.size = 16
surface.CreateFont( "MP.AddedByName", FontTbl )


--[[--------------------------------------------
	Common media player panels
----------------------------------------------]]

local MEDIA_TITLE = {}

function MEDIA_TITLE:Init()
	self.BaseClass.Init( self )
	self:SetFont( "MP.MediaTitle" )
	self:SetTextColor( color_white )
end

derma.DefineControl( "MP.MediaTitle", "", MEDIA_TITLE, "DLabel" )


local MEDIA_TIME = {}

AccessorFunc( MEDIA_TIME, "m_Media", "Media" )
AccessorFunc( MEDIA_TIME, "m_bShowCurrentTime", "ShowCurrentTime" )
AccessorFunc( MEDIA_TIME, "m_bShowDuration", "ShowDuration" )

function MEDIA_TIME:Init()

	self.TimeLbl = vgui.Create( "DLabel", self )
	self.TimeLbl:SetFont( "MP.MediaTime" )
	self.TimeLbl:SetText( "" )
	self.TimeLbl:SetTextColor( color_white )

	self.DividerLbl = vgui.Create( "DLabel", self )
	self.DividerLbl:SetText( "" )
	self.DividerLbl:SetFont( "MP.MediaDuration" )
	-- self.DividerLbl:SetTextColor( color_white )

	self.DurationLbl = vgui.Create( "DLabel", self )
	self.DurationLbl:SetText( "" )
	self.DurationLbl:SetFont( "MP.MediaDuration" )
	-- self.DurationLbl:SetTextColor( color_white )

	self:SetShowCurrentTime( false )
	self:SetShowDuration( true )

	self.NextThink = 0

end

function MEDIA_TIME:SetMedia( media )
	self.m_Media = media

	if media then
		self.DurationLbl:SetText( FormatSeconds( media:Duration() ) )
		self:UpdateDivider()
	end
end

function MEDIA_TIME:UpdateDivider()
	local text = (self.m_bShowCurrentTime and self.m_bShowDuration) and "/" or ""
	self.DividerLbl:SetText( text )
end

function MEDIA_TIME:SetListenForSeekEvents( listen )
	if listen and not self._listening then
		hook.Add( MP.EVENTS.UI.START_SEEKING, self, function(_, pnl) self:OnStartSeeking(pnl) end )
		hook.Add( MP.EVENTS.UI.STOP_SEEKING, self, function() self:OnStopSeeking() end )
	elseif not listen and self._listening then
		self:StopListeningForSeekEvents()
	end

	self._listening = listen
end

function MEDIA_TIME:StopListeningForSeekEvents()
	hook.Remove( MP.EVENTS.UI.START_SEEKING, self )
	hook.Remove( MP.EVENTS.UI.STOP_SEEKING, self )
end

function MEDIA_TIME:OnStartSeeking( seekbarPnl )
	self._seekbar = seekbarPnl
end

function MEDIA_TIME:OnStopSeeking()
	self._seekbar = nil
end

function MEDIA_TIME:OnRemove()
	if self._listening then
		self:StopListeningForSeekEvents()
	end
end

function MEDIA_TIME:Think()

	local rt = RealTime()

	if self.NextThink > rt then return end

	if self.m_Media then

		if self.m_bShowCurrentTime then
			local mediaTime
			local duration = self.m_Media:Duration()

			if self._seekbar then
				local progress = self._seekbar.m_fSlideX or 0
				mediaTime = progress * duration
			else
				mediaTime = self.m_Media:CurrentTime()
			end

			mediaTime = clamp(mediaTime, 0, duration)
			self.TimeLbl:SetText( FormatSeconds( mediaTime ) )
			self:UpdateDivider()
		end

	else
		-- TODO: hide info?
	end

	self:InvalidateLayout(true)

	self.NextThink = rt + 0.1

end

function MEDIA_TIME:PerformLayout()

	self.TimeLbl:SizeToContents()
	self.DividerLbl:SizeToContents()
	self.DurationLbl:SizeToContents()

	self.TimeLbl:CenterVertical()
	self.TimeLbl:AlignLeft( 0 )

	self.DividerLbl:CenterVertical()
	self.DividerLbl:MoveRightOf( self.TimeLbl )

	self.DurationLbl:CenterVertical()
	self.DurationLbl:MoveRightOf( self.DividerLbl )

	local totalwidth = self.DurationLbl:GetPos() + self.DurationLbl:GetWide()
	self:SetWide( totalwidth )

end

derma.DefineControl( "MP.MediaTime", "", MEDIA_TIME, "Panel" )


local ADDED_BY = {}

ADDED_BY.Height = 21
ADDED_BY.NameOffset = 4

function ADDED_BY:Init()

	self.PrefixLbl = vgui.Create( "DLabel", self )
	self.PrefixLbl:SetFont( "MP.Prefix" )
	self.PrefixLbl:SetText( "ADDED BY" )
	self.PrefixLbl:SetTextColor( color_white )
	self.PrefixLbl:SetContentAlignment( 8 )

	self.NameLbl = vgui.Create( "DLabel", self )
	self.NameLbl:SetFont( "MP.AddedByName" )
	self.NameLbl:SetText( "Unknown" )
	self.NameLbl:SetTextColor( color_white )
	self.NameLbl:SetContentAlignment( 8 )

end

function ADDED_BY:SetPlayer( ply, name, steamId )
	self.NameLbl:SetText( name )
	self.NameLbl:SetTooltip( steamId )
end

function ADDED_BY:SetMaxWidth( width )
	self.maxWidth = width
	self:InvalidateLayout(true)
end

function ADDED_BY:PerformLayout()

	local name = self.NameLbl:GetText()
	if name == "" then
		self:SetSize( 0, self.Height )
		return
	end

	self.PrefixLbl:SizeToContents()
	self.NameLbl:SizeToContents()

	local pw = self.PrefixLbl:GetWide()
	local nw = self.NameLbl:GetWide()
	local w = pw + nw + self.NameOffset

	if self.maxWidth then
		w = math.min( w, self.maxWidth )

		-- Clips name label to the maximum width; looks kind of bad since the
		-- ellipsis start too early for some reason.
		-- nw = math.max( 0, w - self.NameOffset - pw )
		-- self.NameLbl:SetWide( nw )
	end

	self:SetSize( w, self.Height )

	self.PrefixLbl:AlignLeft( 0 )
	self.NameLbl:MoveRightOf( self.PrefixLbl, self.NameOffset )

	-- align text baselines
	self.PrefixLbl:AlignBottom( 3 )
	self.NameLbl:AlignBottom( 3 )

end

derma.DefineControl( "MP.AddedBy", "", ADDED_BY, "Panel" )

--[[--------------------------------------------
	Sidebar buttons
----------------------------------------------]]

local BTN_ALPHA_HIGHLIGHTED = 255
local BTN_ALPHA_NORMAL = 84 -- 33% opacity

local SIDEBAR_BTN = {
	Width = 21
}

AccessorFunc( SIDEBAR_BTN, "m_Media", "Media" )
AccessorFunc( SIDEBAR_BTN, "m_bHighlighted", "Highlighted" )
AccessorFunc( SIDEBAR_BTN, "m_HighlightColor", "HighlightColor" )

function SIDEBAR_BTN:Init()
	self:SetSize( self.Width, self.Width )
	self:SetAlpha( BTN_ALPHA_NORMAL )
end

function SIDEBAR_BTN:Think()
	if self.m_bHighlighted or self:IsHovered() and not self.m_bDisabled then
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_HighlightColor then
		self:SetColor( self.m_HighlightColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	else
		self:SetAlpha( BTN_ALPHA_NORMAL )
	end
end

-- function SIDEBAR_BTN:Paint(w,h)
-- 	surface.SetDrawColor(255,0,0)
-- 	surface.DrawRect(0,0,w,h)
-- end

derma.DefineControl( "MP.SidebarButton", "", SIDEBAR_BTN, "DIconButton" )


local SIDEBAR_TOGGLE_BTN = {
	m_EnabledColor = color_white
}

AccessorFunc( SIDEBAR_TOGGLE_BTN, "m_bEnabled", "Enabled" )
AccessorFunc( SIDEBAR_TOGGLE_BTN, "m_EnabledColor", "EnabledColor" )

function SIDEBAR_TOGGLE_BTN:Think()
	if self.m_bEnabled then
		self:SetColor( self.m_EnabledColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_bHighlighted or self:IsHovered() and not self.m_bDisabled then
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	elseif self.m_HighlightColor then
		self:SetColor( self.m_HighlightColor )
		self:SetAlpha( BTN_ALPHA_HIGHLIGHTED )
	else
		self:SetAlpha( BTN_ALPHA_NORMAL )
	end
end

function SIDEBAR_TOGGLE_BTN:DoClick()
	local enabled = not self:GetEnabled()
	self:SetEnabled( enabled )

	if not enabled then
		self:SetColor( color_white )
	end
end

derma.DefineControl( "MP.SidebarToggleButton", "", SIDEBAR_TOGGLE_BTN, "MP.SidebarButton" )


local FAVORITE_BTN = {}

AccessorFunc( FAVORITE_BTN, "Favorited", "Favorited" )

function FAVORITE_BTN:Init()
	self.BaseClass.Init( self )

	self:SetIcon( "mp-favorite-outline" )
	self:SetFavorited( false )
	self.Outlined = true
end

function FAVORITE_BTN:Think()
	self.BaseClass.Think(self)

	if not self.Favorited then
		local hovered = self:IsHovered()

		if self.Outlined then
			if hovered then
				self:SetIcon( "mp-favorite" )
				self:SetHighlighted( true )
				self.Outlined = false
			end
		else
			if not hovered then
				self:SetIcon( "mp-favorite-outline" )
				self:SetHighlighted( false )
				self.Outlined = true
			end
		end
	end
end

function FAVORITE_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.FAVORITE_MEDIA, self.m_Media )
end

derma.DefineControl( "MP.FavoriteButton", "", FAVORITE_BTN, "MP.SidebarButton" )


local REMOVE_BTN = {}

function REMOVE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-delete" )
end

function REMOVE_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.REMOVE_MEDIA, self.m_Media )
end

derma.DefineControl( "MP.RemoveButton", "", REMOVE_BTN, "MP.SidebarButton" )


local SKIP_BTN = {}

function SKIP_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-skip" )
end

function SKIP_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.SKIP_MEDIA )
end

derma.DefineControl( "MP.SkipButton", "", SKIP_BTN, "MP.SidebarButton" )


--[[--------------------------------------------
	Vote controls
----------------------------------------------]]

local VOTE_POSITIVE = 1
local VOTE_NEGATIVE = -1

local VOTE_CONTROLS = {
	Width = 60,
	Height = 21,
	VoteCountPadding = 5
}

AccessorFunc( VOTE_CONTROLS, "m_iVoteCount", "VoteCount" )
AccessorFunc( VOTE_CONTROLS, "m_iVoteValue", "VoteValue" )

AccessorFunc( VOTE_CONTROLS, "m_bUpvoteEnabled", "UpvoteEnabled" )
AccessorFunc( VOTE_CONTROLS, "m_bDownvoteEnabled", "DownvoteEnabled" )

function VOTE_CONTROLS:Init()
	self:SetSize( self.Width, self.Height )

	self.UpvoteBtn = vgui.Create( "MP.UpvoteButton", self )
	self.UpvoteBtn.OnVote = function(btn) self:OnUpvote(btn) end

	self.DownvoteBtn = vgui.Create( "MP.DownvoteButton", self )
	self.DownvoteBtn.OnVote = function(btn) self:OnDownvote(btn) end

	self.VoteCountLbl = vgui.Create( "DLabel", self )
	self.VoteCountLbl:SetTextColor( color_white )
	self.VoteCountLbl:SetFont( "MP.VoteCount" )

	-- TODO: setup event handlers for voting and set the vote count

	-- TODO: listen for global media vote events and update count

	self:SetVoteCount( 0 )
	self:SetVoteValue( 0 )

	self:SetUpvoteEnabled( true )
	self:SetDownvoteEnabled( true )
end

function VOTE_CONTROLS:SetMedia( media )
	self.m_Media = media

	local voteCount = media:GetMetadataValue("votes") or 0
	self:SetVoteCount(voteCount)

	local localVote = media:GetMetadataValue("localVote") or 0
	self:SetVoteValue( localVote )

	self.UpvoteBtn:SetMedia( media )
	self.DownvoteBtn:SetMedia( media )
end

function VOTE_CONTROLS:SetVoteCount( count )
	self.m_iVoteCount = count
	self.VoteCountLbl:SetText( count )
	self:InvalidateLayout(true)
end

function VOTE_CONTROLS:SetVoteValue( value )
	self.m_iVoteValue = value

	if value > 0 then
		-- highlight upvote button
		self.UpvoteBtn:SetHighlighted( true )
		self.DownvoteBtn:SetHighlighted( false )
	elseif value < 0 then
		-- highlight downvote button
		self.UpvoteBtn:SetHighlighted( false )
		self.DownvoteBtn:SetHighlighted( true )
	else
		-- don't highlight either button
		self.UpvoteBtn:SetHighlighted( false )
		self.DownvoteBtn:SetHighlighted( false )
	end
end

function VOTE_CONTROLS:OnUpvote()
	local value = self:GetVoteValue()

	if value > 0 then
		value = 0 -- remove vote
	else
		value = 1 -- set vote
	end

	self:SetVoteCount( self:GetVoteCount() + value )
	self:SetVoteValue( value )

	hook.Run( MP.EVENTS.UI.VOTE_MEDIA, self.m_Media, value )
end

function VOTE_CONTROLS:OnDownvote()
	local value = self:GetVoteValue()

	if value < 0 then
		value = 0 -- remove vote
	else
		value = -1 -- set vote
	end

	self:SetVoteCount( self:GetVoteCount() + value )
	self:SetVoteValue( value )

	hook.Run( MP.EVENTS.UI.VOTE_MEDIA, self.m_Media, value )
end

function VOTE_CONTROLS:PerformLayout()
	local align
	local w = self.Width

	local upvoteEnabled = self:GetUpvoteEnabled()
	local downvoteEnabled = self:GetDownvoteEnabled()

	if upvoteEnabled and downvoteEnabled then
		align = TEXT_ALIGN_CENTER
		w = w - SIDEBAR_BTN.Width * 2
	elseif upvoteEnabled then
		align = TEXT_ALIGN_RIGHT
		w = w - SIDEBAR_BTN.Width
	else
		align = TEXT_ALIGN_LEFT
		w = w - SIDEBAR_BTN.Width
	end

	self:SetSize( w, self.Height )

	if upvoteEnabled then
		self.UpvoteBtn:Show()
		self.UpvoteBtn:AlignLeft()
		self.UpvoteBtn:CenterVertical()
	else
		self.UpvoteBtn:Hide()
	end

	if downvoteEnabled then
		self.DownvoteBtn:Show()
		self.DownvoteBtn:AlignRight()
		self.DownvoteBtn:CenterVertical()
	else
		self.DownvoteBtn:Hide()
	end

	self.VoteCountLbl:SizeToContents()
	self.VoteCountLbl:CenterVertical()

	if align == TEXT_ALIGN_LEFT then
		self.VoteCountLbl:SetContentAlignment(4)
		self.VoteCountLbl:AlignLeft( self.VoteCountPadding )
	elseif align == TEXT_ALIGN_RIGHT then
		self.VoteCountLbl:SetContentAlignment(6)
		self.VoteCountLbl:AlignRight( self.VoteCountPadding )
	else -- TEXT_ALIGN_CENTER
		self.VoteCountLbl:SetContentAlignment(5)
		self.VoteCountLbl:CenterHorizontal()
	end

end

derma.DefineControl( "MP.VoteControls", "", VOTE_CONTROLS, "DPanel" )


local UPVOTE_BTN = {}

function UPVOTE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-thumbs-up" )
end

function UPVOTE_BTN:DoClick()
	self:OnVote( VOTE_POSITIVE )
end

function UPVOTE_BTN:OnVote( value )
end

derma.DefineControl( "MP.UpvoteButton", "", UPVOTE_BTN, "MP.SidebarButton" )


local DOWNVOTE_BTN = {}

function DOWNVOTE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-thumbs-down" )
end

function DOWNVOTE_BTN:DoClick()
	self:OnVote( VOTE_NEGATIVE )
end

function DOWNVOTE_BTN:OnVote( value )
end

derma.DefineControl( "MP.DownvoteButton", "", DOWNVOTE_BTN, "MP.SidebarButton" )

--PATH lua/mp_menu/sidebar_tabs.lua:
return gluapack()()
--PATH lua/autorun/mediaplayer_spawnables.lua:
local MediaPlayerClass = "mediaplayer_tv"

local function AddMediaPlayerModel( spawnName, name, model, playerConfig )
	list.Set( "SpawnableEntities", spawnName, {
		PrintName = name,
		ClassName = MediaPlayerClass,
		Category = "Media Player",
		DropToFloor = true,
		KeyValues = {
			model = model
		}
	} )

	list.Set( "MediaPlayerModelConfigs", model, playerConfig )
end

AddMediaPlayerModel(
	"../spawnicons/models/hunter/plates/plate5x8",
	"Huge Billboard",
	"models/hunter/plates/plate5x8.mdl",
	{
		angle = Angle(0, 90, 0),
		offset = Vector(-118.8, 189.8, 2.5),
		width = 380,
		height = 238
	}
)

AddMediaPlayerModel(
	"../spawnicons/models/props_phx/rt_screen",
	"Small TV",
	"models/props_phx/rt_screen.mdl",
	{
		angle = Angle(-90, 90, 0),
		offset = Vector(6.5, 27.9, 35.3),
		width = 56,
		height = 33
	}
)

if SERVER then

	-- fix for media player owner not getting set on alternate model spawn
	hook.Add( "PlayerSpawnedSENT", "MediaPlayer.SetOwner", function(ply, ent)
		if not ent.IsMediaPlayerEntity then return end
		ent:SetCreator(ply)
		local mp = ent:GetMediaPlayer()
		mp:SetOwner(ply)
	end )

end

--PATH lua/autorun/menu.lua:
return gluapack()()
--PATH lua/autorun/menu.lua:
if SERVER then

function SWV_Spawn_SENT( player, EntityName, tr )
	if ( EntityName == nil ) then return end
	-- Ask the gamemode if it's ok to spawn this
	if ( !gamemode.Call( "PlayerSpawnSENT", player, EntityName ) ) then return end

	local vStart = player:EyePos()
	local vForward = player:GetAimVector()

	if ( !tr ) then

		local trace = {}
		trace.start = vStart
		trace.endpos = vStart + (vForward * 4096)
		trace.filter = player

		tr = util.TraceLine( trace )

	end

	local entity = nil
	local PrintName = nil
	local sent = scripted_ents.GetStored( EntityName )
	if ( sent ) then
            
		local sent = sent.t
        if(sent.AdminOnly and !player:IsAdmin()) then return end;
		ClassName = EntityName

		entity = sent:SpawnFunction( player, tr, EntityName )

		ClassName = nil

		PrintName = sent.PrintName

	else

		-- Spawn from list table
		local SpawnableEntities = list.Get( "SWVehicles" )
		if (!SpawnableEntities) then return end
		local EntTable = SpawnableEntities[ EntityName ]
		if (!EntTable) then return end
        if(EntTable.AdminOnly and !player:IsAdmin()) then return end;
		PrintName = EntTable.PrintName

		local SpawnPos = tr.HitPos + tr.HitNormal * 16
		if ( EntTable.NormalOffset ) then SpawnPos = SpawnPos + tr.HitNormal * EntTable.NormalOffset end

		entity = ents.Create( EntTable.ClassName )
			entity:SetPos( SpawnPos )
		entity:Spawn()
		entity:Activate()
		if ( EntTable.DropToFloor ) then
			entity:DropToFloor()
		end

	end


	if ( IsValid( entity ) ) then

		if ( IsValid( player ) ) then
			gamemode.Call( "PlayerSpawnedSENT", player, entity )
		end

		undo.Create("SENT")
			undo.SetPlayer(player)
			undo.AddEntity(entity)
			if ( PrintName ) then
				undo.SetCustomUndoText( "Undone "..PrintName )
			end
		undo.Finish( "Scripted Entity ("..tostring( EntityName )..")" )

		player:AddCleanup( "sents", entity )
		entity:SetVar( "Player", player )

	end


end
concommand.Add( "swv_spawnsent", function( ply, cmd, args ) SWV_Spawn_SENT( ply, args[1] ) end ) 

function SWV_CCGiveSWEP( player, command, arguments )

	if ( arguments[1] == nil ) then return end

	-- Make sure this is a SWEP
	local swept = list.Get( "SWVehicles.Weapons" );
	local swep;

	for k,v in pairs(swept) do
		if (v.ClassName==arguments[1]) then
			swep = v; break;
		end
	end

	if (swep == nil) then return end

	if ( !gamemode.Call( "PlayerGiveSWEP", player, arguments[1], swep ) ) then return end

	MsgAll( "Giving "..player:Nick().." a "..swep.ClassName.."\n" )
	player:Give( swep.ClassName )
	-- And switch to it
	player:SelectWeapon( swep.ClassName )

end

concommand.Add( "swv_giveswep", SWV_CCGiveSWEP )

--[[---------------------------------------------------------
	-- Give a swep.. duh.
-----------------------------------------------------------]]
function SWV_Spawn_Weapon( Player, wepname, tr )

	if ( wepname == nil ) then return end

	local swept = list.Get( "SWVehicles.Weapons" );
	local swep;

	for k,v in pairs(swept) do
		if (v.ClassName==wepname) then
			swep = v; break;
		end
	end

	-- Make sure this is a SWEP
	if ( swep == nil ) then return end

	if ( !gamemode.Call( "PlayerSpawnSWEP", Player, wepname, swep ) ) then return end

	if ( !tr ) then
		tr = Player:GetEyeTraceNoCursor()
	end

	if ( !tr.Hit ) then return end

	local entity = ents.Create( swep.ClassName )

	if ( IsValid( entity ) ) then

		entity:SetPos( tr.HitPos + tr.HitNormal * 32 )
		entity:Spawn()

		gamemode.Call( "PlayerSpawnedSWEP", Player, entity )

	end


end

concommand.Add( "swv_spawnswep", function( ply, cmd, args ) SWV_Spawn_Weapon( ply, args[1] ) end )    

end

if(CLIENT) then
spawnmenu.AddCreationTab( "Star Wars Vehicles", function()
	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
    ctrl:CallPopulateHook( "SWVehiclesTab" );
    return ctrl;
end, "icons16/other.png", 60 )

spawnmenu.AddContentType( "swvehicle", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
    icon:SetContentType( "entity" )
    icon:SetSpawnName( obj.spawnname )
    icon:SetName( obj.nicename )
    icon:SetMaterial( obj.material )
    icon.SetAdminOnly = function(self,admin)
        if (admin) then
            self.imgAdmin = vgui.Create( "DImage", self )
            self.imgAdmin:SetImage( "icon16/shield.png" )
            self.imgAdmin:SetSize(16,16);
            self.imgAdmin:SetPos(self:GetWide()-22,5);
            self.imgAdmin:SetTooltip( "Admin Only" )
        end
    end
    icon:SetAdminOnly( obj.admin )
    local Tooltip =  Format( "%s", obj.nicename )
    if ( obj.info and obj.info!="" ) then Tooltip = Format( "%s\n\n%s", Tooltip, obj.info ) end
    icon:SetTooltip(Tooltip);
    icon:SetColor( Color( 205, 92, 92, 255 ) )
    icon.DoClick = function()
        RunConsoleCommand( "swv_spawnsent", obj.spawnname );
        surface.PlaySound( "ui/buttonclickrelease.wav" )
    end
    icon.OpenMenu = function( icon )
        local menu = DermaMenu()
        menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
        menu:Open()
    end
	icon.OpenMenu = function( icon )

		local menu = DermaMenu()
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "0" ) RunConsoleCommand( "creator_name", obj.spawnname ) end )
		menu:Open()

	end
	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon;

end )
spawnmenu.AddContentType( "swweapon", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "weapon" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( obj.material )
	icon:SetAdminOnly( obj.admin )
	icon:SetColor( Color( 135, 206, 250, 255 ) )
	icon.DoClick = function()

		RunConsoleCommand( "swv_giveswep", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )

	end

	icon.DoMiddleClick = function()

		RunConsoleCommand( "swv_spawnswep", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )

	end

	icon.OpenMenu = function( icon )

		local menu = DermaMenu()
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "3" ) RunConsoleCommand( "creator_name", obj.spawnname ) end )
		menu:Open()

	end

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )
hook.Add( "SWVehiclesTab", "AddEntityContent", function( pnlContent, tree, node )

	local Categorised = {}

	-- Add this list into the tormoil
	local SpawnableEntities = list.Get( "SWVehicles" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do

			v.SpawnName = k
            if(v.Category == "Star Wars") then
                v.Category = "Other";
            else
                v.Category = string.gsub(v.Category, "%Star Wars Vehicles: ", "") or "Other";
            end
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert( Categorised[ v.Category ], v )

		end
	end
            
    SpawnableEntities = list.Get( "SWVehicles.Weapons" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do

			v.SpawnName = k
            v.Category = "Weapons";
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert( Categorised[ v.Category ], v )

		end
	end

	--
	-- Add a tree node for each category
	--
	for CategoryName, v in SortedPairs( Categorised ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icons16/" .. string.lower(CategoryName) .. ".png" )

			-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end
            
                    
			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
                local enttype = "swvehicle"
                if(CategoryName == "Weapons") then
                    enttype = "weapon";
                end
				spawnmenu.CreateContentIcon(enttype, self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/" .. ent.ClassName .. ".png",
					admin		= ent.AdminOnly or false,
                    author		= ent.Author,
                    info		= ent.Instructions,
				} )
			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

    
end
--PATH addons/[mrs] mc_quests/lua/autorun/mqs_autorun.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/en.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/elements.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/msdmenu.lua:
if SERVER then return end
local tblOpenMenus = {}

function RegisterDermaMenuForClose(dmenu)
	table.insert(tblOpenMenus, dmenu)
end

function MSD.MenuOpen(parentmenu, parent, bg)
	if (not parentmenu) then
		CloseDermaMenus()
	end

	local dmenu = vgui.Create("MSD.DMenu", parent)
	dmenu.ShadowStatic = 0
	dmenu.ShadowInt = 1

	dmenu.Paint = function(self, w, h)
		if bg then
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d_na"])
		else
			MSD.Blur(self, 1, 2, 255, 55, w, h)
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d"])
		end
	end

	return dmenu
end

function CloseDermaMenus()
	for k, dmenu in pairs(tblOpenMenus) do
		if (IsValid(dmenu)) then
			dmenu:SetVisible(false)

			if (dmenu:GetDeleteSelf()) then
				dmenu:Remove()
			end
		end
	end

	tblOpenMenus = {}
	hook.Run("CloseDermaMenus")
end

local function DermaDetectMenuFocus(panel, mousecode)
	if (IsValid(panel)) then
		if (panel.m_bIsMenuComponent) then return end

		return DermaDetectMenuFocus(panel:GetParent(), mousecode)
	end

	CloseDermaMenus()
end

hook.Add("VGUIMousePressed", "MatDMenuDetectMenuFocus", DermaDetectMenuFocus)
local PANEL = {}
AccessorFunc(PANEL, "m_bBorder", "DrawBorder")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_bDrawColumn", "DrawColumn")
AccessorFunc(PANEL, "m_iMaxHeight", "MaxHeight")
AccessorFunc(PANEL, "m_pOpenSubMenu", "OpenSubMenu")

function PANEL:Init()
	self:SetIsMenu(true)
	self:SetDrawBorder(true)
	self:SetPaintBackground(true)
	self:SetMinimumWidth(100)
	self:SetDrawOnTop(true)
	self:SetMaxHeight(ScrH() * 0.9)
	self:SetDeleteSelf(true)
	self:SetPadding(0)
	RegisterDermaMenuForClose(self)
end

function PANEL:AddOption(strText, funcFunction, icon, check)
	if check and not check() then return end

	local pnl = vgui.Create("MSD.DMenuOption", self)
	pnl:SetMenu(self)
	pnl:SetText(strText)
	if icon then
		pnl.icon = icon
		pnl:SetTextInset(38, 0)
	end

	if (funcFunction) then
		pnl.DoClick = funcFunction
	end

	self:AddPanel(pnl)

	return pnl
end

function PANEL:AddSubMenu(strText, funcFunction)
	local pnl = vgui.Create("MSD.DMenuOption", self)
	local SubMenu = pnl:AddSubMenu(strText, funcFunction)
	pnl:SetText(strText)

	if (funcFunction) then
		pnl.DoClick = funcFunction
	end

	self:AddPanel(pnl)

	return SubMenu, pnl
end

derma.DefineControl("MSD.DMenu", "A Menu 2", PANEL, "DMenu")

PANEL = {}
AccessorFunc(PANEL, "m_pMenu", "Menu")
AccessorFunc(PANEL, "m_bChecked", "Checked")
AccessorFunc(PANEL, "m_bCheckable", "IsCheckable")

function PANEL:Init()
	self:SetContentAlignment(4)
	self:SetTextInset(10, 0)
	self:SetFont("MSDFont.16")
	self:SetTextColor(MSD.Text["s"])
	self:SetChecked(false)
	self.ChangeCC = true
	self.ColorText = MSD.Text["s"]
end

function PANEL:OnCursorEntered()
	self.ColorText = MSD.Config.MainColor["p"]
	self.ChangeCC = true

	if (IsValid(self.ParentMenu)) then
		self.ParentMenu:OpenSubMenu(self, self.SubMenu)

		return
	end

	self:GetParent():OpenSubMenu(self, self.SubMenu)
end

function PANEL:OnCursorExited()
	self.ColorText = MSD.Text["l"]
	self.ChangeCC = true
end

function PANEL:AddSubMenu()
	local SubMenu = MSD.MenuOpen(true, self)
	SubMenu:SetVisible(false)
	SubMenu:SetParent(self)
	self:SetSubMenu(SubMenu)

	return SubMenu
end

function PANEL:Paint(w, h)
	if self.ChangeCC then
		self:SetTextColor(self.ColorText)
		self.ChangeCC = nil
	end

	if self.icon then
		local ih = h - 6
		MSD.DrawTexturedRect(5, 3, ih, ih, self.icon, self.ColorText)
	end
end

function PANEL:PerformLayout( w, h )

	self:SizeToContents()
	self:SetWide( self:GetWide() + 30 )

	w = math.max( self:GetParent():GetWide(), self:GetWide() )

	self:SetSize( w, self.icon and 30 or 22 )

	if ( IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow:SetSize( 15, 15 )
		self.SubMenuArrow:CenterVertical()
		self.SubMenuArrow:AlignRight( 4 )

	end

	DButton.PerformLayout( self, w, h )

end

derma.DefineControl("MSD.DMenuOption", "Menu Option Line 2", PANEL, "DMenuOption")
--PATH addons/[ui] msd_ui/lua/msd/ui/msdpanellist.lua:
local PANEL = {}
AccessorFunc(PANEL, "m_bSizeToContents", "AutoSize")
AccessorFunc(PANEL, "m_bStretchHorizontally", "StretchHorizontally")
AccessorFunc(PANEL, "m_bNoSizing", "NoSizing")
AccessorFunc(PANEL, "m_bSortable", "Sortable")
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_fAnimEase", "AnimEase")
AccessorFunc(PANEL, "m_strDraggableName", "DraggableName")
AccessorFunc(PANEL, "Spacing", "Spacing")
AccessorFunc(PANEL, "Padding", "Padding")

function PANEL:Init()
	self:SetDraggableName("GlobalDPanel")
	self.pnlCanvas = vgui.Create("DPanel", self)
	self.pnlCanvas:SetPaintBackground(false)

	self.pnlCanvas.OnMousePressed = function(s, code)
		s:GetParent():OnMousePressed(code)
	end

	self.pnlCanvas.OnChildRemoved = function()
		self:OnChildRemoved()
	end

	self.pnlCanvas:SetMouseInputEnabled(true)

	self.pnlCanvas.InvalidateLayout = function()
		self:InvalidateLayout()
	end

	self.pnlCanvas.MasterPanel = self
	self.Items = {}
	self.YOffset = 0
	self.m_fAnimTime = 0
	self.m_fAnimEase = -1
	self.m_iBuilds = 0
	self.IgnoreVbar = true
	self:SetSpacing(0)
	self:SetPadding(0)
	self:EnableHorizontal(false)
	self:SetAutoSize(false)
	self:SetPaintBackground(true)
	self:SetNoSizing(false)
	self:SetMouseInputEnabled(true)

	self:SetPaintBackgroundEnabled(false)
	self:SetPaintBorderEnabled(false)
end

function PANEL:OnModified()
	-- Override me
end

function PANEL:SizeToContents()
	self:SetSize(self.pnlCanvas:GetSize())
end

function PANEL:GetItems()
	return self.Items
end

function PANEL:EnableHorizontal(bHoriz)
	self.Horizontal = bHoriz
end

local sdw = Color(0, 0, 0, 70)

function PANEL:EnableVerticalScrollbar()
	if (self.VBar) then return end
	self.VBar = vgui.Create("DVScrollBar", self)

	self.VBar.Paint = function(s, w, h)
		draw.RoundedBox(4, 3, 13, 8, h - 24, sdw)
	end

	self.VBar.btnUp.Paint = function(s, w, h) end
	self.VBar.btnDown.Paint = function(s, w, h) end

	self.VBar.btnGrip.Paint = function(s, w, h)
		draw.RoundedBox(4, 5, 0, 4, h + 22, sdw)
	end
end

function PANEL:GetCanvas()
	return self.pnlCanvas
end

function PANEL:Clear(nDelete)
	for k, panel in pairs(self.Items) do
		if (not IsValid(panel)) then continue end
		panel:Remove()

		if (nDelete) then
			panel:SetVisible(false)
		end
	end

	self.Items = {}
end

function PANEL:ClearEX(ex_panel)
	if (not IsValid(ex_panel)) then return end

	for k, panel in pairs(self.Items) do
		if (not IsValid(panel)) then continue end

		if (panel ~= ex_panel) then
			panel:Remove()
		end
	end

	self.Items = {}
	table.insert(self.Items, ex_panel)
end

function PANEL:AddItem(item, strLineState)
	if (not IsValid(item)) then return end
	item:SetVisible(true)
	item:SetParent(self:GetCanvas())
	item.m_strLineState = strLineState or item.m_strLineState
	table.insert(self.Items, item)
	item:SetSelectable(self.m_bSelectionCanvas)
	self:InvalidateLayout()
end

function PANEL:InsertBefore(before, insert, strLineState)
	table.RemoveByValue(self.Items, insert)
	self:AddItem(insert, strLineState)
	local key = table.KeyFromValue(self.Items, before)

	if (key) then
		table.RemoveByValue(self.Items, insert)
		table.insert(self.Items, key, insert)
	end
end

function PANEL:InsertAfter(before, insert, strLineState)
	table.RemoveByValue(self.Items, insert)
	self:AddItem(insert, strLineState)
	local key = table.KeyFromValue(self.Items, before)

	if (key) then
		table.RemoveByValue(self.Items, insert)
		table.insert(self.Items, key + 1, insert)
	end
end

function PANEL:InsertAtTop(insert, strLineState)
	table.RemoveByValue(self.Items, insert)
	self:AddItem(insert, strLineState)
	local key = 1

	if (key) then
		table.RemoveByValue(self.Items, insert)
		table.insert(self.Items, key, insert)
	end
end

function PANEL.DropAction(Slot, RcvSlot)
	local PanelToMove = Slot.Panel

	if (dragndrop.m_MenuData == "copy") then
		if (PanelToMove.Copy) then
			PanelToMove = Slot.Panel:Copy()
			PanelToMove.m_strLineState = Slot.Panel.m_strLineState
		else
			return
		end
	end

	PanelToMove:SetPos(RcvSlot.Data.pnlCanvas:ScreenToLocal(gui.MouseX() - dragndrop.m_MouseLocalX, gui.MouseY() - dragndrop.m_MouseLocalY))

	if (dragndrop.DropPos == 4 or dragndrop.DropPos == 8) then
		RcvSlot.Data:InsertBefore(RcvSlot.Panel, PanelToMove)
	else
		RcvSlot.Data:InsertAfter(RcvSlot.Panel, PanelToMove)
	end
end

function PANEL:RemoveItem(item, bDontDelete)
	for k, panel in pairs(self.Items) do
		if (panel == item) then
			self.Items[k] = nil

			if (not bDontDelete) then
				panel:Remove()
			end

			self:InvalidateLayout()
		end
	end
end

function PANEL:CleanList()
	for k, panel in pairs(self.Items) do
		if (not IsValid(panel) or panel:GetParent() ~= self.pnlCanvas) then
			self.Items[k] = nil
		end
	end
end

function PANEL:HorizontalRebuild(Offset)
	local x, y = self.Padding, self.Padding
	local l_highest = 0

	for k, panel in pairs(self.Items) do
		if (panel:IsVisible()) then
			if panel.StaticScale then
				local w, h

				if isstring(panel.StaticScale.w) then
					w = tonumber(panel.StaticScale.w)
					w = (self.pnlCanvas:GetWide() - (self.pnlCanvas:GetWide() / w)) - (self.Spacing + self.Padding)
				elseif panel.StaticScale.w == 1 then
					w = self.pnlCanvas:GetWide() / panel.StaticScale.w - (self.Spacing + self.Padding)
				else
					w = self.pnlCanvas:GetWide() / panel.StaticScale.w - (self.Spacing + self.Padding) / 1.5
				end

				if panel.StaticScale.fixed_h then
					h = panel.StaticScale.fixed_h
				elseif panel.StaticScale.h_w then
					h = w
				elseif panel.StaticScale.h then
					if isstring(panel.StaticScale.h) then
						h = tonumber(panel.StaticScale.h)
						h = (self:GetTall() - (self:GetTall() / h)) - (self.Spacing + self.Spacing / h + self.Padding)
					elseif panel.StaticScale.h == 1 then
						h = self:GetTall() / panel.StaticScale.h - (self.Spacing + self.Padding)
					else
						h = self:GetTall() / panel.StaticScale.h - (self.Spacing + self.Padding)
					end
				end

				if panel.StaticScale.minw > w then
					w = panel.StaticScale.minw
				end

				if panel.StaticScale.h and panel.StaticScale.minh > h then
					h = panel.StaticScale.minh
				end

				panel:SetSize(w, h)
			end

			local OwnLine = (panel.m_strLineState and panel.m_strLineState == "ownline")
			local w = panel:GetWide()
			local h = panel:GetTall()
			local vbar = 0

			if (self.VBar and self.VBar.Enabled and not self.IgnoreVbar) then
				vbar = 13
			end

			if (x > self.Padding and (x + w > (self:GetWide() - vbar) or OwnLine)) then
				x = self.Padding
				y = y + l_highest + self.Spacing
				l_highest = h
			end

			if h > l_highest then
				l_highest = h
			end

			if (self.m_fAnimTime > 0 and self.m_iBuilds > 1) then
				panel:MoveTo(x, y, self.m_fAnimTime, 0, self.m_fAnimEase)
			else
				panel:SetPos(x, y)
			end

			x = x + w + self.Spacing
			Offset = y + l_highest + self.Spacing

			if (OwnLine) then
				x = self.Padding
				y = y + h + self.Spacing
			end
		end
	end

	return Offset
end

function PANEL:NormalRebuild(Offset)
	for k, panel in pairs(self.Items) do
		if (panel:IsVisible()) then
			if (self.m_bNoSizing) then
				panel:SizeToContents()

				if (self.m_fAnimTime > 0 and self.m_iBuilds > 1) then
					panel:MoveTo((self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + Offset, self.m_fAnimTime, 0, self.m_fAnimEase)
				else
					panel:SetPos((self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + Offset)
				end
			else
				panel:SetWide(self:GetCanvas():GetWide() - self.Padding * 2)

				if (self.m_fAnimTime > 0 and self.m_iBuilds > 1) then
					panel:MoveTo(self.Padding, self.Padding + Offset, self.m_fAnimTime, self.m_fAnimEase)
				else
					panel:SetPos(self.Padding, self.Padding + Offset)
				end
			end

			panel:InvalidateLayout(true)
			Offset = Offset + panel:GetTall() + self.Spacing
		end
	end

	Offset = Offset + self.Padding

	return Offset
end

function PANEL:Rebuild()
	local Offset = 0
	self.m_iBuilds = self.m_iBuilds + 1
	self:CleanList()

	if (self.Horizontal) then
		Offset = self:HorizontalRebuild(Offset)
	else
		Offset = self:NormalRebuild(Offset)
	end

	self:GetCanvas():SetTall(Offset + self.Padding - self.Spacing)

	if (self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall()) then
		self:GetCanvas():SetPos(0, (self:GetTall() - self:GetCanvas():GetTall()) * 0.5)
	end
end

function PANEL:OnMouseWheeled(dlta)
	if (self.VBar) then return self.VBar:OnMouseWheeled(dlta) end
end

function PANEL:Paint(w, h)
	derma.SkinHook("Paint", "PanelList", self, w, h)

	return true
end

function PANEL:OnVScroll(iOffset)
	self.pnlCanvas:SetPos(0, iOffset)
end

function PANEL:PerformLayout()
	local Wide = self:GetWide()
	local Tall = self.pnlCanvas:GetTall()
	local YPos = 0

	if (not self.Rebuild) then
		debug.Trace()
	end

	self:Rebuild()

	if (self.VBar) then
		self.VBar:SetPos(self:GetWide() - 13, 0)
		self.VBar:SetSize(13, self:GetTall())
		self.VBar:SetUp(self:GetTall(), self.pnlCanvas:GetTall())
		YPos = self.VBar:GetOffset()

		if not self.IgnoreVbar then
			Wide = Wide - 13
		end
	end

	self.pnlCanvas:SetPos(0, YPos)
	self.pnlCanvas:SetWide(Wide)

	if (self:GetAutoSize()) then
		self:SetTall(self.pnlCanvas:GetTall())
		self.pnlCanvas:SetPos(0, 0)
	end

	if (self.VBar and not self:GetAutoSize() and Tall ~= self.pnlCanvas:GetTall()) then
		self.VBar:SetScroll(self.VBar:GetScroll())
	end
end

function PANEL:OnChildRemoved()
	self:CleanList()
	self:InvalidateLayout()
end

function PANEL:ScrollToChild(panel)
	local _, y = self.pnlCanvas:GetChildPosition(panel)
	local _, h = panel:GetSize()
	y = y + h * 0.5
	y = y - self:GetTall() * 0.5
	self.VBar:AnimateTo(y, 0.5, 0, 0.5)
end

function PANEL:SortByMember(key, desc)
	desc = desc or true

	table.sort(self.Items, function(a, b)
		if (desc) then
			local ta = a
			local tb = b
			a = tb
			b = ta
		end

		if (a[key] == nil) then return false end
		if (b[key] == nil) then return true end

		return a[key] > b[key]
	end)
end

derma.DefineControl("MSDPanelList", "Fancy DpanelList", PANEL, "DPanel")
--PATH lua/autorun/mvp_terminal.lua:
-- This is entry point of the addon, do not edit this file unless you know what you're doing.
--
-- Name: Terminal
-- Author: Kot @ <github.com/Kotyarishka> @ <steamcommunity.com/id/Kotyarishka>
-- Description: 
-- @todo: Add description
-- License: MIT

mvp = {}

AddCSLuaFile()

if (SERVER) then
    AddCSLuaFile("mvp/cl_init.lua")
    AddCSLuaFile("mvp/sh_init.lua")

    include("mvp/sv_init.lua")
else
    include("mvp/cl_init.lua")
end

include("mvp/sh_init.lua")
--PATH lua/mvp/loggers/console.lua:
local LOGGER = mvp.meta.logger:New()

function LOGGER:Init()
    -- not needed
end

local LEVEL_TO_COLOR_MAP = {
    [mvp.LOG.INFO] = Color(0, 174, 255),
    [mvp.LOG.WARN] = Color(255, 255, 0),
    [mvp.LOG.ERROR] = Color(255, 0, 0),
    [mvp.LOG.FATAL] = Color(174, 0, 255),

    [mvp.LOG.DEBUG] = Color(4, 0, 255),
}

function LOGGER:Log(level, caller, ...)
    local shouldDisplayDebug = mvp.config and mvp.config.Get("debug", false)
    if (not shouldDisplayDebug and level == mvp.LOG.DEBUG) then
        return
    end

    local color = LEVEL_TO_COLOR_MAP[level] or Color(255, 255, 255)

    local msg = {}

    msg[#msg + 1] = color
    msg[#msg + 1] = " "
    msg[#msg + 1] = mvp.LOG[level]
    msg[#msg + 1] = "\t"
    msg[#msg + 1] = Color(255, 255, 255)
    
    if (caller) then
        msg[#msg + 1] = "["
        msg[#msg + 1] = Color(255, 255, 0)
        msg[#msg + 1] = caller
        msg[#msg + 1] = Color(255, 255, 255)
        msg[#msg + 1] = "] "
    end

    table.Add(msg, {...})

    MsgC(unpack(msg))
    Msg("\n")
end

mvp.logger.Register(LOGGER)
--PATH lua/mvp/core/credits/sh_contributors.lua:
return gluapack()()
--PATH lua/mvp/core/credits/sh_icons.lua:
return gluapack()()
--PATH lua/mvp/core/package/sh_package.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/sh_package.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/configs/perfecthands.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/cl_credits.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/languages/de.lua:
--
-- This translation was done by TheCookieYT
-- https://steamcommunity.com/id/76561198293343119/
--

local l = {}

l["section.simpledefcons"] = "Simple DEFCONs"
l["section.simpledefcons.general"] = "Allgemein"
l["section.simpledefcons.appearance"] = "Aussehen"

l["value.simpledefcons.timeOnScreen.description"] = "Zeit in Sekunden, wie lange der Basisstatus angezeigt werden soll, wenn kein Ton damit verbunden ist."
l["value.simpledefcons.defcons.description"] = "Liste der DEFCONs. Jedes DEFCON hat einen Namen und eine Farbe."
l["value.simpledefcons.allowedJobs.description"] = "Liste der Jobs, die berechtigt sind, den Basisstatus zu ndern."

l["value.simpledefcons.showHUD.description"] = "Zeige den Basisstatus auf dem HUD an."
l["value.simpledefcons.hudPosition.description"] = "Position des Basisstatus auf dem HUD"
l["value.simpledefcons.entityManagerModel.description"] = "Modell fr die Basisstatus-Manager-Entitt."
l["value.simpledefcons.entityDisplayModel.description"] = "Modell fr die Basisstatus-Anzeige-Entitt"

l["simpledefcons.configure_allowed_jobs"] = "Erlaubte Jobs konfigurieren"
l["simpledefcons.search_jobs"] = "Suchen..."
l["simpledefcons.configure_defcons"] = "DEFCONs konfigurieren"
l["simpledefcons.add_defcon"] = "Neues DEFCON hinzufgen"
l["simpledefcons.defcon_name"] = "DEFCON Titel"
l["simpledefcons.defcon_color"] = "DEFCON Farbe"
l["simpledefcons.defcon_description"] = "DEFCON Beschreibung"
l["simpledefcons.defcon_sound"] = "DEFCON Sound (optional)"

l["simpledefcons.set"] = "Setzen"
l["simpledefcons.apply"] = "Anwenden"
l["simpledefcons.active"] = "Aktiv"
l["simpledefcons.attention"] = "ACHTUNG"
l["simpledefcons.base_status"] = "Basis Status"
l["simpledefcons.initiated_by"] = "{{color:Accent}}{{lang:simpledefcons.attention}}{{color:Text}} - {{color:%s}}%s{{color:Text}} initiiert von {{color:%s}}%s{{color:Text}}!"

l["simpledefcons.managerEntity"] = "Basis Status Manager"
l["simpledefcons.managerEntity.description"] = "Verwaltet den Basis Status."

l["simpledefcons.displayEntity"] = l["simpledefcons.base_status"] .. ":"

mvp.language.Register("de", l)
--PATH lua/mvp/packages/simpledefcons/commands/defcons.lua:
local P = mvp.package.Get()

local C = mvp.meta.command:New()

C:SetID("defcons")
C:SetName("Simple Defcons | Control Defcons")
C:SetDescription("Control the defcons on the server")

function C:Execute(ply)
    if not mvp.config.Get("simpledefcons.allowChatCommand") then
        mvp.q.NotifyFail(mvp.q.Lang("simpledefcons.managerEntity"), mvp.q.Lang("general.disabled"), nil, ply)
        return
    end

    if (not P.manage.CheckPermissions(ply)) then
        mvp.q.NotifyError(mvp.q.Lang("simpledefcons.managerEntity"), mvp.q.Lang("general.no_permission"), nil, ply)
        return 
    end

    net.Start("mvp.simpledefcons.Open")
    net.Send(ply)
end

mvp.command.Register(C)
--PATH lua/mvp/packages/simpledefcons/cl_credits.lua:
-- <a href="https://www.flaticon.com/free-icons/alarm" title="alarm icons">Alarm icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/simpledefcons/alert.png", "smooth mips"), "Alarm", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")

-- <a href="https://www.flaticon.com/free-icons/delete" title="delete icons">Delete icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/simpledefcons/delete.png", "smooth mips"), "Delete", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")

mvp.credits.AddContributor("76561198293343119", "TheCookieYT", "Translator (German, Simple DEFCONs)")
--PATH lua/mvp/gamemodes/blank.lua:
return gluapack()()
--PATH lua/mvp/gamemodes/helix.lua:
local gm = mvp.meta.gamemode:New()

gm:SetName("Helix")
gm:SetDescription("Support for Helix gamemode.")
gm:SetAuthor("Kot")
gm:SetVersion("1.0.0")
gm:SetLicense("MIT")

function gm:GetMoney(ply)
    return ply:GetCharacter():GetMoney() or 0
end

function gm:CanAfford(ply, sum)
    return ply:GetCharacter():HasMoney(sum)
end

function gm:AddMoney(ply, sum)
    return ply:GetCharacter():GiveMoney(sum)
end

function gm:TakeMoney(ply, sum)
    return ply:GetCharacter():TakeMoney(sum)
end

function gm:FormatMoney(ply, sum)
    return ix.currency.Get(amount)
end

mvp.gamemode.Register(gm)
--PATH lua/mvp/gamemodes/nutscript.lua:
return gluapack()()
--PATH lua/mvp/vgui/sidebar/cl_sidebar.lua:
local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)
local spaceBetween = mvp.ui.Scale(10)

function PANEL:Init()
    self.backgroundColor = mvp.colors.BackgroundHover

    self.colors = {}
    self.colors.Background = mvp.colors.BackgroundHover
end

function PANEL:Paint(w, h)
    draw.RoundedBox(0, 0, 0, w, h, self.backgroundColor)

    return true
end

vgui.Register("mvp.SidebarSeparator", PANEL, "EditablePanel")

PANEL = {}

function PANEL:Init()
    self.buttons = {}

    self.close = vgui.Create("mvp.SidebarButton", self)
    self.close:Dock(BOTTOM)
    self.close:InvalidateParent(true)
    self.close:SetTall(self.close:GetWide())
    self.close:SetAnimations(false)
    self.close:SetIcon("mvp/terminal/close.png", "smooth")

    self.close:SetText(mvp.q.Lang("ui.general.close"))

    self.close.colors.BackgroundHover = mvp.colors.Red
end

function PANEL:AddButton(text, icon, matParams, onClicked, activeByDefault)
    local button = vgui.Create("mvp.SidebarButton", self)
    button:Dock(TOP)
    button:DockMargin(0, 0, 0, 0)
    button:InvalidateParent(true)
    button:SetTall(button:GetWide() - spaceBetween * 3)
    button:SetIcon(icon, matParams)
    button:SetText(text)

    button.OnClicked = onClicked

    if (activeByDefault) then
        button:SetActive(true)

        if (onClicked) then
            onClicked()
        end
    end

    table.insert(self.buttons, button)

    return button
end

function PANEL:AddSeparator()
    local separator = vgui.Create("mvp.SidebarSeparator", self)
    separator:Dock(TOP)
    separator:DockMargin(spaceBetween, spaceBetween * .5, spaceBetween * 3 + spaceBetween, spaceBetween * .5)
    separator:InvalidateParent(true)
    separator:SetTall(2)

    return separator
end

function PANEL:OnButtonClickedInternal()
    for k, v in pairs(self.buttons) do
        v:SetActive(false)
    end
end

function PANEL:PerformLayout()
end

vgui.Register("mvp.Sidebar", PANEL, "EditablePanel")
--PATH lua/mvp/vgui/sidebar/cl_sidebar_button.lua:
return gluapack()()
--PATH addons/[medic] defib/lua/autorun/ncs_defibrilator_autorun.lua:
return gluapack()()
--PATH lua/autorun/ncs_shared_init.lua:
return gluapack()()
--PATH lua/ncs_shared/cl_imgur.lua:
local materials = {}
local grabbingMaterials = {}

function NCS_SHARED.GetImgur(id, callback, useproxy, matSettings)
    if materials[id] then return callback(materials[id]) end

    file.CreateDir("ncs/")

    if file.Exists("ncs/" .. id .. ".png", "DATA") then
        materials[id] = Material("../data/ncs/" .. id .. ".png", matSettings or "noclamp smooth mips")
        return callback(materials[id])
    end

    http.Fetch(useproxy and "https://proxy.duckduckgo.com/iu/?u=https://i.imgur.com" or "https://i.imgur.com/" .. id .. ".png",
        function(body, len, headers, code)
            if len > 2097152 then
                materials[id] = Material("nil")
                return callback(materials[id])
            end

            file.Write("ncs/" .. id .. ".png", body)
            materials[id] = Material("../data/ncs/" .. id .. ".png", matSettings or "noclamp smooth mips")

            return callback(materials[id])
        end,
        function(error)
            if useproxy then
                materials[id] = Material("nil")
                return callback(materials[id])
            end
            return NCS_SHARED.GetImgur(id, callback, true)
        end
    )
end

function NCS_SHARED.DrawImgur(x, y, w, h, imgurId, col)
    col = col or color_white

    if not materials[imgurId] then
        if grabbingMaterials[imgurId] then return end
        grabbingMaterials[imgurId] = true

        NCS_SHARED.GetImgur(imgurId, function(mat)
            materials[imgurId] = mat
            grabbingMaterials[imgurId] = nil
        end)

        return
    end

    surface.SetMaterial( materials[imgurId] )
        surface.SetDrawColor( col.r, col.g, col.b, col.a )
    surface.DrawTexturedRect(x, y, w, h)
end
--PATH lua/ncs_shared/sh_lang.lua:
return gluapack()()
--PATH lua/ncs_shared/characters/list/sh_nutscript.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_darkrp.lua:
NCS_SHARED.RegisterCurrency("darkrp", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        P:addMoney(AMOUNT)
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return P:canAfford(AMOUNT)
    end,
    getMoney = function(P)
        return P:getDarkRPVar("money")
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return DarkRP.formatMoney(AMOUNT)
    end,
})
--PATH lua/ncs_shared/currencies/currencies/sh_gwg.lua:
NCS_SHARED.RegisterCurrency("gatewaygaming", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        P:AddBalance(AMOUNT)
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if P:GetBalance() >= AMOUNT then
            return true
        else
            return false
        end
    end,
    getMoney = function(P)
        return P:GetBalance()
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return string.Comma(AMOUNT).."RC"
    end,
})
--PATH lua/ncs_shared/currencies/currencies/sh_santos.lua:
NCS_SHARED.RegisterCurrency("santos", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)
        P:AddMoney(AMOUNT)
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        if not P:CanAfford(AMOUNT) then
            return false
        else
            return true
        end
    end,
    getMoney = function(P)
        return P:GetMoney() -- I DON'T KNOW IF THIS WORKS
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return "$"..string.Comma(AMOUNT)
    end,
})
--PATH lua/ncs_shared/vgui/cl_frame.lua:
local function CreateFonts()
    surface.CreateFont( "NCS_SHARED_FRAME_TITLE", {
        font = "Bebas Neue", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
        extended = false,
        size = ScreenScale(7),
    } )

    surface.CreateFont( "NCS_SHARED_DESCRIPTION", {
        font = "Bebas Neue", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
        extended = false,
        size = ScreenScale(7),
    } )
end
hook.Add("OnScreenSizeChanged", "NCS_SHARED_UpdateFonts", CreateFonts)
CreateFonts()

local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
    local x, y = panel:LocalToScreen(0, 0)

    local scrW, scrH = ScrW(), ScrH()

    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)

    for i = 1, 3 do
        blur:SetFloat("$blur", (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end

local PANEL = {}

PANEL.Paint = function(s, w, h)
    DrawBlur(s, 6)
    
    surface.SetDrawColor( Color(0,0,0, 250) )
    surface.DrawRect( 0, 0, w, h )

    surface.SetDrawColor( Color(122,132,137, 180) )
    surface.DrawOutlinedRect( 0, 0, w, h )
end

PANEL.Init = function(s)
    local FRAME = s

    FRAME.OnSizeChanged = function(s)
            s.Header = vgui.Create("Panel", s)
            s.Header:Dock(TOP)
            s.Header:PaintManual(true)
            s.Header:SetTall(s:GetTall() * 0.06)
            s.Header.Paint = function(_, w, h)
                surface.SetDrawColor( Color(122,132,137, 180) )
                surface.DrawOutlinedRect( 0, 0, w, h )

                draw.SimpleText((FRAME:GetTitle() or ""), "NCS_SHARED_FRAME_TITLE", w * 0.01, h * 0.5, COL_2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end

        local w, h = s.Header:GetSize()

        s.CloseButton = vgui.Create("DButton", s.Header)
        s.CloseButton:SetWide(w * 0.05)
        s.CloseButton:Dock(RIGHT)
        s.CloseButton:SetText("X")
        s.CloseButton:SetFont("NCS_SHARED_FRAME_TITLE")
        s.CloseButton:SetTextColor(Color(255,0,0))
        
        s.CloseButton.DoClick = function(pnl)
            s:Remove()
        end

        s.CloseButton.Paint = function(pnl, w ,h)
            if pnl:IsHovered() then
                pnl:SetTextColor(Color(255,0,0))
            else
                pnl:SetTextColor(Color(255,255,255))
            end
        end
    end

end

AccessorFunc(PANEL, "m_rd_titletext", "Title", FORCE_STRING)

vgui.Register("NCS_SHARED_FRAME", PANEL, "EditablePanel")
--PATH lua/autorun/nyssa_addon.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
---  **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
---  **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
---  **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
---  **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
---  **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
---  **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
---  **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
---  **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_bshadows.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_anim.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

onyx.anim = {}
onyx.anim.list = {}

-- Reservation
onyx.anim.ANIM_HOVER = 0x100
onyx.anim.ANIM_X = 0x101
onyx.anim.ANIM_Y = 0x102
onyx.anim.ANIM_SCALE = 0x103

local anim = onyx.anim
local tween = onyx.tween
local cv = CreateClientConVar('cl_onyx_smooth', '1', true, false, 'Enable smooth animations')

function anim.Create(panel, duration, data)
    if not panel.onyxAnims then
        anim.list[#anim.list + 1] = panel
        panel.onyxAnims = {}
    end

    local index = data.index
    local subject = data.subject or panel
    local target = data.target
    local easing = data.easing or 'linear'
    local think = data.think
    local onFinished = data.onFinished

    local instance = tween.new(duration, subject, target, easing)

    instance.index = index
    instance.think = think
    instance.onFinished = onFinished

    if (cv:GetBool() and not data.skipAnimation) then
        instance:set(0)
    else
        instance:set(duration)
    end

    panel.onyxAnims[index] = instance
end

function anim.Simple(panel, duration, target, index, think, onFinished, easing)
    anim.Create(panel, duration, {
        index = index,
        target = target,
        think = think,
        onFinished = onFinished,
        easing = easing
    })
end

function anim.Remove(panel, index)
    if panel.onyxAnims and panel.onyxAnims[index] then
        panel.onyxAnims[index] = nil
    end
end

do
    local table_remove = table.remove
    local RealFrameTime = RealFrameTime
    local pairs = pairs
    local IsValid = IsValid

    local function handle(index, instance, panel, time)
        local isFinished = instance:update(time)
        local onFinished = instance.onFinished
        local think = instance.think

        if think then
            think(instance, panel)
        end

        if isFinished then
            panel.onyxAnims[index] = nil

            if onFinished then
                onFinished(instance, panel)
            end

            return true
        end

        return false
    end

    hook.Add('Think', 'onyx.anim.Controller', function()
        local time = FrameTime() -- lol, `RealFrameTime` in some rare cases it might return 0 all the time (how is it even possible???)
        local index = 0

        while (true) do
            index = index + 1
            local panel = anim.list[index]
            if panel == nil then
                break
            end
            if IsValid(panel) then
                for animIndex, instance in pairs(panel.onyxAnims) do
                    handle(animIndex, instance, panel, time)
                end
            else
                table_remove(anim.list, index)
            end
        end
        -- for i = 1, anim.index do
        --     local panel = anim.list[i]
        --     if IsValid(panel) then
        --         for index, instance in pairs(panel.onyxAnims) do
        --             handle(index, instance, panel, time)
        --         end
        --     else
        --         anim.index = anim.index - 1
        --         table_remove(anim.list, i)
        --     end
        -- end
    end)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_draw_functions.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_button.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_button.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_colIdle', 'ColorIdle')
AccessorFunc(PANEL, 'm_colHover', 'ColorHover')
AccessorFunc(PANEL, 'm_colPressed', 'ColorPressed')
AccessorFunc(PANEL, 'm_colGradient', 'GradientColor')
AccessorFunc(PANEL, 'm_iGradientDirection', 'GradientDirection')
AccessorFunc(PANEL, 'm_bMasking', 'Masking')

local colorAccent = onyx:Config('colors.accent')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(ScreenScale(10))
    self:CenterText()

    local _SetColorIdle = self.SetColorIdle
    self.SetColorIdle = function(panel, color)
        _SetColorIdle(panel, color)

        local h, s, v = ColorToHSV(color)
        if (v > .5) then
            panel:SetTextColor(color_black)
        else
            panel:SetTextColor(color_white)
        end
    end

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorAccent)
    -- self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -80))
    self:SetColorHover(onyx.ColorEditHSV(self:GetColorIdle(), nil, nil, .66))
    self:SetGradientDirection(RIGHT)
end

function PANEL:Paint(w, h)
    local isMaskingEnabled = self.m_bMasking
    local colorGradient = self.m_colGradient

    draw.RoundedBox(8, 0, 0, w, h, self.backgroundColor)

    if (isMaskingEnabled and colorGradient) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, self.m_iGradientDirection, colorGradient)
        end)
    end
end

function PANEL:PerformLayout(w, h)
    if (self.m_bMasking) then
        self.mask = onyx.CalculateRoundedBox(8, 0, 0, w, h)
    end
end

onyx.gui.Register('onyx.Button', PANEL, 'onyx.Label')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     for i = 1, 10 do
--         local btn = self:Add('onyx.Button')
--         btn:Dock(TOP)
--         btn:SetText('Button #' .. i)
--         btn.DoClickInternal = function()

--         end
--         btn.DoClick = function()
--             print('test')
--         end

--         if i % 2 == 0 then
--             btn:SetDisabled(true)
--         end
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_color_wheel.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_frame_header.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

function PANEL:Init()
    self.colorBG = onyx:Config('colors.secondary')
    
    self.lblText = self:Add('onyx.Label')
    self.lblText:CenterText()

    self.btnClose = self:Add('onyx.ImageButton')
    self.btnClose:SetWebImage('close', 'smooth mips')
    self.btnClose:InstallHoverAnim()
    self.btnClose:SetColorHover(Color(255, 87, 87))
    self.btnClose:SetColorPressed(Color(204, 38, 38))
    self.btnClose:SetImageScale(.6)
    self.btnClose.DoClick = function()
        self:GetParent():Close()
    end

    self:SetTitle('Title')
end

function PANEL:PerformLayout(w, h)
    self.lblText:SetSize(w, h)

    self.btnClose:Dock(RIGHT)
    self.btnClose:SetWide(h)
end

function PANEL:Paint(w, h)
    draw.RoundedBoxEx(8, 0, 0, w, h, self.colorBG, true, true)
end

function PANEL:SetTitle(text)
    self.lblText:SetText(onyx.utf8.upper(text))
end

onyx.gui.Register('onyx.Frame.Header', PANEL)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_label.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_menu.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_pie_chart.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scroll.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

22.08.2021

--]]

local PANEL = {}

function PANEL:Init()
    onyx.gui.Extend(self.btnGrip)

    self:Import('smoothscroll')
    self:SetHideButtons(true)

    self.bgColor = ColorAlpha(onyx.cfg.colors.accent, 40)

    self.btnGrip.color = Color(0, 0, 0)
    self.btnGrip:Import('hovercolor')
    self.btnGrip:SetColorKey('color')
    self.btnGrip:SetColorIdle(onyx.cfg.colors.accent)
    self.btnGrip:SetColorHover(onyx.OffsetColor(onyx.cfg.colors.accent, -30))
    self.btnGrip.Paint = function(panel, w, h)
        draw.RoundedBox(4, 0, 0, w, h, panel.color)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, self.bgColor)
end

function PANEL:OnMouseWheeled(delta)
    local hovered = vgui.GetHoveredPanel()

    if IsValid(hovered) and hovered ~= self and hovered.OnMouseWheeled then
        return
    end

    self.BaseClass.OnMouseWheeled(self, delta)
end

onyx.gui.Register('onyx.Scroll', PANEL, 'DVScrollBar')
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

22.08.2021

--]]

local PANEL = {}

function PANEL:Init()
    self.canvas = vgui.Create('onyx.ScrollPanel.Canvas', self)

    self.scroll = vgui.Create('onyx.Scroll', self)

    self.canvas:On('OnContainerTallUpdated', function(panel, canvasTall, containerTall)
        self.scroll:SetUp(canvasTall, containerTall)
    end)

    self:Combine(self.canvas, 'AddPanel')
    self:Combine(self.canvas, 'OnPanelAdded')
    self:Combine(self.scroll, 'OnMouseWheeled')
    self:CombineMutator(self.canvas, 'Space')
end

function PANEL:PerformLayout(w, h)
    self.canvas:Dock(FILL)

    self.scroll:Dock(RIGHT)
    self.scroll:SetWide(onyx.ScaleWide(6))
    self.scroll:DockMargin(ScreenScale(2), 0, 0, 0)
end

function PANEL:OnVScroll(offset)
    self:GetContainer():SetY(offset)
end

function PANEL:GetContainer()
    return self.canvas.container
end

function PANEL:GetItems()
    return self:GetContainer():GetChildren()
end

function PANEL:Add(class)
    local panel = vgui.Create(class)

    assert(panel, 'Panel class \"' .. class .. '\" doesn\'t exist')

    self:AddPanel(panel)

    return panel
end

-- hack
function PANEL:Think()
    local scroll = self.scroll:GetScroll()
    local canvasSize = self.scroll.CanvasSize
    if (scroll ~= canvasSize) then
        local target = math.min(scroll, canvasSize)
        self.scroll:SetScroll(target)
        if (canvasSize <= 1) then
            self.canvas.container:SetPos(0, -scroll)
            self.scroll.Current = 0
            self.scroll.Scroll = 0
        end
    end
end

onyx.gui.Register('onyx.ScrollPanel', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .66, .66, function(self)
--     self:MakePopup()

--     local list = self:Add('onyx.ScrollPanel')
--     list:Dock(FILL)

--     for i = 1, 32 do
--         local button = list:Add('onyx.Button')
--         button:SetText('Button #' .. i)
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_sidebar.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/stats/cl_stats.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/01/2024

--]]

netchunk.Callback('onyx.f4:SendStats', function(data)
    hook.Run('onyx.f4.StatsReceived', data)
end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_dashboard.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local L = function( ... ) return onyx.lang:Get( ... ) end

local COLOR_PRIMARY = onyx:Config( 'colors.primary' )
local COLOR_SECONDARY = onyx:Config( 'colors.secondary' )
local COLOR_BG = onyx.LerpColor( .1, COLOR_PRIMARY, color_black )

function onyx.hud.OpenSettings()
    local padding = onyx.ScaleTall( 15 )
    local conPadding = onyx.ScaleTall( 10 )

    RunConsoleCommand( 'cl_onyx_hud_show_help', 0 )
    
    local frame = vgui.Create( 'onyx.Frame' )
    frame:SetSize( ScrW() * .5, ScrH() * .65 )
    frame:Center()
    frame:MakePopup()
    frame:SetTitle( 'ONYX HUD' )

    local content = frame:Add( 'Panel' )
    content:DockPadding( padding, padding, padding, padding )
    content:Dock( FILL )

    local navbar = content:Add( 'onyx.Navbar' )
    navbar:SetTall( onyx.ScaleTall( 30 ) )
    navbar:Dock( TOP )
    navbar.Paint = function(panel, w, h)
        draw.RoundedBoxEx( 8, 0, 0, w, h, COLOR_SECONDARY, true, true )
    end

    local container = content:Add( 'Panel' )
    container:Dock( FILL )
    container:DockPadding( conPadding, conPadding, conPadding, conPadding )
    container.Paint = function( panel, w, h )
        draw.RoundedBoxEx( 8, 0, 0, w, h, COLOR_SECONDARY, false, false, true, true )
        draw.RoundedBoxEx( 8, 1, 1, w - 2, h - 2, COLOR_BG, false, false, true, true )
    end

    navbar:SetContainer( container )

    CAMI.PlayerHasAccess( LocalPlayer(), 'onyx_hud_edit', function( bHasAccess )
        if ( IsValid( frame ) ) then
            local tabsAmount = bHasAccess and 2 or 1
            local tabWidth = ( frame:GetWide() - padding * 2 ) / tabsAmount

            navbar:AddTab({
                name = L( 'settings_u' ),
                class = 'onyx.hud.ClientSettings',
                icon = 'https://i.imgur.com/41kCW0x.png'
            }):SetWide( tabWidth )
        
            if ( bHasAccess ) then
                navbar:AddTab({
                    name = L( 'configuration_u' ),
                    icon = 'https://i.imgur.com/Wg3syNS.png',
                    class = 'onyx.Configuration',
                    onBuild = function( panel )
                        panel:LoadAddonSettings( 'hud' )
                        panel:OpenCategories()
                    end
                }):SetWide( tabWidth )
            end

            navbar:ChooseTab( 1 )
            navbar:SetVisible( bHasAccess )
        end
    end )

    return frame
end

concommand.Add( 'onyx_hud', function() onyx.hud.OpenSettings() end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_notifications.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

11/08/2024

--]]

local hud = onyx.hud
local cache = {}

local COLOR_BAR = Color( 0, 0, 0, 200 ) -- Only for light themes
local FONT_TEXT = 'onyx.hud.Small'
local NOTIFICATION_TYPES = {
    [ NOTIFY_GENERIC ] = {
        color = Color( 255, 228, 52),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/2muiD5k.png', 'smooth mips' )
    },
    [ NOTIFY_ERROR ] = {
        color = Color( 235, 57, 57),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/vNzFBlK.png', 'smooth mips' )
    },
    [ NOTIFY_UNDO ] = {
        color = Color( 69, 78, 255),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/sgLeDjb.png', 'smooth mips' )
    },
    [ NOTIFY_HINT ] = {
        color = Color( 37, 222, 225),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/vAjbKzK.png', 'smooth mips' )
    },
    [ NOTIFY_CLEANUP ] = {
        color = Color( 235, 81, 255),
        wimg = onyx.wimg.Simple( 'https://i.imgur.com/V3TyKJ9.png', 'smooth mips' )
    },
}

local function addNotification( text, type, length )
    table.insert( cache, 1, {
        text = text,
        type = type,
        endtime = CurTime() + length,
        duration = length
    } )
end

local function overrideNotifications()
    hud.original_AddLegacy = hud.original_AddLegacy or notification.AddLegacy

    function notification.AddLegacy( text, type, length )
        local text = tostring( text )
        local type = type or NOTIFY_GENERIC
        local length = length or 3
        local isEnabled = onyx.hud.IsElementEnabled( 'notifications' )
        
        if ( isEnabled ) then
            addNotification( text:Trim():gsub('\n', ' '), type, length )
        else
            hud.original_AddLegacy( text, type, length )
        end
    end
end
onyx.hud.OverrideGamemode( 'onyx.hud.OverrideNotifications', overrideNotifications )

local function drawNotifications( self, client, scrW, scrH )
    local theme = hud:GetCurrentTheme()
    local colorPrimary = theme.colors.primary
    local colorSecondary = theme.colors.secondary
    local colorTertiary = theme.colors.tertiary
    local colorText = theme.colors.textPrimary
    local isDark = theme.dark

    local space = onyx.hud.GetScreenPadding()
    local horPadding = onyx.hud.ScaleTall( 10 )
    local notifH = onyx.hud.ScaleTall( 30 )
    local hudRoundness = onyx.hud.GetRoundness()
    local notifSpace = onyx.hud.ScaleTall( 5 )
    local iconSpace = onyx.hud.ScaleTall( 10 )
    local iconSize = onyx.hud.ScaleTall( 18 )
    local lineH = onyx.hud.ScaleTall( 2 )

    local amount = #cache
    local posY = scrH * .75
    local speed = FrameTime() * 8

    -- to avoid overlapping
    if ( #onyx.hud.VoicePanels > 0 ) then
        for _, data in ipairs( onyx.hud.VoicePanels ) do
            local panel = data.panel
            if ( IsValid( panel ) and panel:IsVisible() ) then
                posY = math.min( posY, select( 2, panel:GetPos() ) )
            end
        end
        posY = posY - notifSpace
    end
    
    posY = posY - notifH

    for index = 1, amount do
        local data = cache[ index ]
        if ( not data ) then continue end

        local notifText = data.text
        local notifType = data.type or 0
        local notifTypeData = NOTIFICATION_TYPES[ notifType ] or NOTIFICATION_TYPES[ NOTIFY_GENERIC ]
        local notifColor = notifTypeData.color
        local timeLeft = math.max( 0, data.endtime - CurTime() )
        local lifeFraction = timeLeft / data.duration
        local expired = lifeFraction == 0
        local targetFraction = expired and 0 or 1
        local wimgObject = notifTypeData.wimg

        -- Get size
        surface.SetFont( FONT_TEXT )
        local textW, textH = surface.GetTextSize( notifText )
        local notifW = textW + horPadding * 2 + iconSize + iconSpace

        -- Calculate pos
        local posX = expired and scrW or ( scrW - notifW - space )

        data.x = Lerp( speed, data.x or scrW, posX )
        data.y = Lerp( speed, data.y or posY, posY )
        data.fraction = math.Approach( data.fraction or 0, targetFraction, speed )

        local x = data.x
        local y = math.ceil( data.y )

        -- Draw
        local prevAlpha = surface.GetAlphaMultiplier()
        local lineColor = isDark and ColorAlpha( notifColor, 20 ) or COLOR_BAR

        surface.SetAlphaMultiplier( data.fraction )

            onyx.hud.DrawRoundedBox( x, y, notifW, notifH, colorPrimary )

            wimgObject:Draw( x + horPadding, y + notifH * .5 - iconSize * .5, iconSize, iconSize, notifColor )

            render.SetScissorRect( x, y + notifH - lineH, x + notifW, y + notifH, true )
                onyx.hud.DrawRoundedBox( x, y, notifW, notifH, lineColor )
            render.SetScissorRect( x, y + notifH - lineH, x + notifW * lifeFraction, y + notifH, true )
                onyx.hud.DrawRoundedBox( x, y, notifW, notifH, notifColor )
            render.SetScissorRect( 0, 0, 0, 0, false )

            onyx.hud.DrawCheapText( notifText, FONT_TEXT, x + horPadding + iconSize + iconSpace, y + notifH * .5 - textH * .5, colorText )

        surface.SetAlphaMultiplier( prevAlpha )

        posY = posY - notifH - notifSpace

        if ( expired and data.fraction == 0 ) then
            table.remove( cache, index )
        end
    end
end

onyx.hud:RegisterElement( 'notifications', {
    priority = 90,
    drawFn = drawNotifications,
    hideElements = {}
} )

concommand.Add( 'onyx_hud_test_notifications', function( ply )
    if ( ply:IsAdmin() ) then
        local index = 0
        for type in pairs( NOTIFICATION_TYPES ) do
            index = index + 1
            notification.AddLegacy( 'Onyx HUD Notification', type, 10 - index )
        end
    end
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_weapon_selector.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SHOW_DURATION = 1.5
local MAX_SLOTS = 6
local CONVAR_SOUNDS = CreateClientConVar( 'cl_onyx_hud_wpnsel_sounds', '1', true, false, '', 0, 1 )

local hud = onyx.hud
local toggleFraction = 0
local toggleState = false
local slotsCache = {}
local selectorData = {
    selectedSlot = 1,
    selectedPos = 0,
    activeWeapon = NULL
}

local quickSwitchEnabled = GetConVar( 'hud_fastswitch' ):GetBool()

cvars.AddChangeCallback( 'hud_fastswitch', function(cname, old, new)
    quickSwitchEnabled = tobool( new )
end, 'onyx.hud' )

local function resetSlotsCache()
    slotsCache = {}
    for index = 1, MAX_SLOTS do
        slotsCache[ index ] = {}
    end
end

local function toggleWeaponSelector( state, bScroll )
    local oldState = toggleState
    
    toggleState = state

    if ( not state ) then
        toggleFraction = 0
        timer.Remove( 'onyx.hud.HideWeaponSelector' )
    else
        timer.Create( 'onyx.hud.HideWeaponSelector', SHOW_DURATION, 1, function()
            toggleWeaponSelector( false )
        end )

        if ( bScroll and not oldState and toggleFraction == 0 ) then
            local activeWeapon = selectorData.activeWeapon
            for slotIndex, slotWeapons in ipairs( slotsCache ) do
                for pos, weapon in ipairs( slotWeapons ) do
                    if ( weapon == activeWeapon ) then
                        selectorData.selectedSlot = slotIndex
                        selectorData.selectedPos = pos
                        break
                    end
                end
            end
        end
    end
end

local function drawWeaponSelector( client, scrW, scrH )
    toggleFraction = math.Approach( toggleFraction, toggleState and 1 or 0, FrameTime() * 8 )
    if ( toggleFraction <= 0 ) then return end 

    local prevAlpha = surface.GetAlphaMultiplier()
    local screenPadding = onyx.hud.GetScreenPadding()

    local activeSlots, emptySlots = 0, 0
    for _, cachedWeapons in ipairs( slotsCache ) do
        if ( #cachedWeapons > 0 ) then
            activeSlots = activeSlots + 1
        else
            emptySlots = emptySlots + 1
        end
    end

    local slotSpace = onyx.hud.ScaleTall( 3 )
    local baseSlotH = onyx.hud.ScaleTall( 27.5 )
    local slotActiveW = onyx.hud.ScaleWide( 150 )
    local slotEmptyW = baseSlotH

    local totalW = slotSpace * ( MAX_SLOTS - 1) + activeSlots * slotActiveW + emptySlots * slotEmptyW

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorAccent = colors.accent
    local colorPrimaryText = colors.textPrimary
    local colorSecondaryText = colors.textSecondary
    local colorTertiaryText = colors.textTertiary
    local isDark = theme.dark

    local y = screenPadding
    local x = scrW * .5 - totalW * .5
    
    surface.SetAlphaMultiplier( toggleFraction )

    for slotIndex = 1, MAX_SLOTS do
        local slotWeapons = slotsCache[ slotIndex ]
        if ( not slotWeapons ) then break end

        local amount = #slotWeapons
        local isEmpty = amount == 0
        local isSlotSelected = selectorData.selectedSlot == slotIndex
        local slotW = isEmpty and slotEmptyW or slotActiveW
        local slotY = y

        hud.DrawRoundedBox( x, slotY, slotW, baseSlotH, isEmpty and colorPrimary or colorSecondary )
        draw.SimpleText( slotIndex, onyx.hud.fonts.SmallBold, x + slotW * .5, slotY + baseSlotH * .5, isEmpty and colorTertiaryText or colorSecondaryText, 1, 1 )

        slotY = slotY + baseSlotH + slotSpace

        if ( not isEmpty ) then
            for index = 1, amount do
                local wep = slotWeapons[ index ]
                if ( IsValid( wep ) ) then
                    local wepName = wep:GetPrintName()
                    local isSelected = isSlotSelected and ( index == selectorData.selectedPos )
                    local isActive = selectorData.activeWeapon == wep
                    local textColor = isSelected and ( isDark and colorAccent or onyx.LerpColor( .5, colorAccent, colorPrimaryText ) ) or ( isActive and colorPrimaryText or colorSecondaryText)
                    local slotH = isSelected and baseSlotH * 1.33 or baseSlotH
                    local slotFont = onyx.hud.fonts.TinyBold

                    if ( isSelected ) then
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorAccent )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, colorPrimary )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, ColorAlpha( colorAccent, isDark and 5 or 150 ) )
                    else
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorPrimary )
                    end
                    
                    -- This guarantee that weapon's name won't render outside slot's bounds
                    render.SetScissorRect( x, slotY, x + slotW, slotY + slotH, true )
                        draw.SimpleText( wepName, slotFont, x + slotW * .5, slotY + slotH * .5, textColor, 1, 1 )
                    render.SetScissorRect( 0, 0, 0, 0, false )

                    slotY = slotY + slotH + slotSpace
                end
            end
        end

        x = x + slotW + slotSpace
    end

    surface.SetAlphaMultiplier( prevAlpha )
end

local playSelectSound do
    local soundStation
    function playSelectSound()
        if ( not CONVAR_SOUNDS:GetBool() ) then return end

        soundStation = soundStation or CreateSound( LocalPlayer(), 'common/wpn_moveselect.wav' )
    
        if ( soundStation:IsPlaying() ) then
            soundStation:Stop()
        end
    
        soundStation:PlayEx( .5, 100 )
    end
end

do
    local binds = {}
    for index = 1, MAX_SLOTS do
        binds[ ( 'slot' .. index ) ] = index
    end

    local lastWeapon = NULL

    local function selectWeapon()
        local data = selectorData
        local slotWeapons = slotsCache[ data.selectedSlot ]
    
        if ( slotWeapons ) then
            local weapon = slotWeapons[ data.selectedPos ]
            if ( IsValid( weapon ) ) then
                lastWeapon = LocalPlayer():GetActiveWeapon()
                input.SelectWeapon( weapon )
                toggleWeaponSelector( false )
            end
        end
    end

    local function cycleWeapons( slot )
        local data = selectorData
        local wasActive = toggleState
        local prevSlot = data.selectedSlot
        
        toggleWeaponSelector( true )
        playSelectSound()

        if ( not wasActive and prevSlot == slot and not quickSwitchEnabled ) then return end

        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        if ( prevSlot ~= slot ) then
            pos = 0
        end
        
        data.selectedSlot = slot
        data.selectedPos = pos + 1

        if ( data.selectedPos > weaponsAmount ) then
            data.selectedPos = 1
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    local function scrollWeapons( delta )
        toggleWeaponSelector( true, true )
        playSelectSound()

        local data = selectorData
        local slot = data.selectedSlot or 1
        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        data.selectedPos = pos + delta

        local bNext = data.selectedPos > weaponsAmount
        local bPrev = data.selectedPos < 1

        if ( bNext or bPrev ) then
            local newSlot = data.selectedSlot
            for _ = 1, MAX_SLOTS do
                newSlot = newSlot + delta
                if ( newSlot < 1 ) then newSlot = MAX_SLOTS end 
                if ( newSlot > MAX_SLOTS ) then newSlot = 1 end

                local amount = #slotsCache[ newSlot ]

                if ( amount > 0 ) then
                    data.selectedPos = ( bPrev and amount or 1 )
                    data.selectedSlot = newSlot
                    break
                end
            end
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    hook.Add( 'PlayerBindPress', 'onyx.hud.HandleBinds', function( ply, bind, pressed, code )
        local slot = binds[ bind ]

        if ( ply:InVehicle() ) then return end

        if ( slot ) then
            cycleWeapons( slot )
        elseif ( bind == '+attack' and not quickSwitchEnabled ) then
            if ( toggleState ) then
                selectWeapon()
                return true
            end
        elseif ( not ply:KeyDown( IN_ATTACK ) ) then
            if ( bind == 'invprev' ) then
                scrollWeapons( -1 )
            elseif ( bind == 'invnext' ) then
                scrollWeapons( 1 )
            elseif ( bind == 'lastinv' ) then
                if ( IsValid( lastWeapon ) ) then
                    local wep = ply:GetActiveWeapon()
                    input.SelectWeapon( lastWeapon )
                    lastWeapon = wep
                end
            end
        end
    end )
end

hook.Add( 'PostDrawHUD', 'onyx.hud.DrawWeaponSelector', function()
    -- cam.Start2D fixes weird font issue in this hook
    cam.Start2D()
        drawWeaponSelector( LocalPlayer(), ScrW(), ScrH() )
    cam.End2D()
end )

hook.Add( 'HUDShouldDraw', 'onyx.hud.HideWeaponSelector', function( name )
    if ( name == 'CHudWeaponSelection' ) then
        return false
    end
end )

hook.Add( 'Think', 'onyx.hud.UpdateWeaponSelector', function()
    local client = LocalPlayer()
    local weaponsList = client:GetWeapons()
    
    resetSlotsCache()

    selectorData.activeWeapon = client:GetActiveWeapon()

    for _, wep in ipairs( weaponsList ) do
        if ( IsValid( wep ) ) then
            local slotIndex = math.Clamp( wep:GetSlot() + 1, 1, MAX_SLOTS )
            local slotWeapons = slotsCache[ slotIndex ]
            assert( slotWeapons, string.format( 'invalid slot index %d', slotIndex ) )
            table.insert( slotWeapons, wep )
        end
    end

    for index, cacheList in ipairs( slotsCache ) do
        table.sort( cacheList, function( a, b )
            return a:GetSlotPos() < b:GetSlotPos()
        end )
    end
end )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/sh_ranks.lua:
return gluapack()()
--PATH lua/autorun/openpermissions.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-config-master/lua/openpermissions_lua_functions.lua:
return gluapack()()
--PATH lua/autorun/palpy.lua:
player_manager.AddValidModel( "palpatine", 		"models/player/gpalpatine.mdl" );
list.Set( "PlayerOptionsModel", "palpatine", 	"models/player/gpalpatine.mdl" );
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_fonts.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_elements.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_config.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/config/sh_config.lua:
-----------------------
--      IMPORTANT     -
-----------------------
-- The creation of the entities is done in-game with the toolgun.
-- This allows for you to easily have several of the same machine with different configurations,
-- making the addon easier to use in the process.


/* ============
 General Config
=============*/

-- Chat prefix
PerfectCasino.Config.PrefixColor = Color(175, 0, 0)
PerfectCasino.Config.Prefix = "[pCasino]"

--- The usergroups/SteamIDs that get access to the in-game entity maker
PerfectCasino.Config.AccessGroups = {}
PerfectCasino.Config.AccessGroups["superadmin"] = true
PerfectCasino.Config.AccessGroups["STEAM_0:1:123456"] = true



-- The following functions are for developers to add support to the currency they're using. By default it's set up for DarkRP
function PerfectCasino.Config.AddMoney(ply, amount)
	ply:addMoney(amount)
end
function PerfectCasino.Config.CanAfford(ply, amount)
	return ply:canAfford(amount)
end
function PerfectCasino.Config.FormatMoney(amount)
	return DarkRP.formatMoney(tonumber(amount))
end


-- These are the reward functions that are run when prize wheels are triggered
-- ply is the user that is receiving the reward.
-- ent is the entity that is linked to the win. Most likely a slot machine or a prize wheel.
-- inputValue is the custom input used in the in-game config menu. This way, you can have 1 function for giving money, and just
-- provide it with different inputs
-- You can also return a string that will be a custom message, otherwise it will default to a preset one in the language file.
PerfectCasino.Config.RewardsFunctions = {}

-- No reward
PerfectCasino.Config.RewardsFunctions["nothing"] = function(ply, ent, inputValue)
	-- They won nothing, do nothing
end
-- RP money
PerfectCasino.Config.RewardsFunctions["money"] = function(ply, ent, inputValue)
	PerfectCasino.Config.AddMoney(ply, inputValue)
end
-- The machines Jackpot. This will only work on machines with jackpots.
PerfectCasino.Config.RewardsFunctions["jackpot"] = function(ply, ent, inputValue)
	local jackpotAmount = ent:GetCurrentJackpot()

	PerfectCasino.Config.AddMoney(ply, jackpotAmount)
	ent:SetCurrentJackpot(ent.data.jackpot.startValue) -- Reset the jackpot

	return "You have hit the jackpot, the payout is "..PerfectCasino.Config.FormatMoney(jackpotAmount)
end
-- Prize Wheel
PerfectCasino.Config.RewardsFunctions["prize_wheel"] = function(ply, ent, inputValue)
	PerfectCasino.Core.GiveFreeSpin(ply)
end
-- A weapon
PerfectCasino.Config.RewardsFunctions["weapon"] = function(ply, ent, inputValue)
	ply:Give(inputValue)
end
-- Health
PerfectCasino.Config.RewardsFunctions["health"] = function(ply, ent, inputValue)
	ply:SetHealth(inputValue)
end
-- Armor
PerfectCasino.Config.RewardsFunctions["armor"] = function(ply, ent, inputValue)
	ply:SetArmor(inputValue)
end
-- Kill
PerfectCasino.Config.RewardsFunctions["kill"] = function(ply, ent, inputValue)
	ply:Kill()
end
-- Set Playermodel
PerfectCasino.Config.RewardsFunctions["setmodel"] = function(ply, ent, inputValue)
	ply:SetModel(inputValue)
end
-- Pointshop 1 Points
PerfectCasino.Config.RewardsFunctions["ps1_points"] = function(ply, ent, inputValue)
	ply:PS_GivePoints(inputValue)
end
-- Pointshop 1 Item
PerfectCasino.Config.RewardsFunctions["ps1_item"] = function(ply, ent, inputValue)
	ply:PS_GiveItem(inputValue)
end
-- Pointshop 2 Points
PerfectCasino.Config.RewardsFunctions["ps2_points"] = function(ply, ent, inputValue)
	ply:PS2_AddStandardPoints(inputValue)
end
-- Pointshop 2 Item
PerfectCasino.Config.RewardsFunctions["ps2_item"] = function(ply, ent, inputValue)
	local item = Pointshop2.GetItemClassByPrintName(inputValue) 
	ply:PS2_EasyAddItem(item.className)
end
-- Pointshop 2 Premium Points
PerfectCasino.Config.RewardsFunctions["ps2_prempoints"] = function(ply, ent, inputValue)
	ply:PS2_AddPremiumPoints(inputValue)
end
-- SH Pointshop Points
PerfectCasino.Config.RewardsFunctions["pssh_points"] = function(ply, ent, inputValue)
	ply:SH_AddStandardPoints(inputValue)
end
-- SH Pointshop Item
PerfectCasino.Config.RewardsFunctions["pssh_item"] = function(ply, ent, inputValue)
	ply:SH_AddItem(inputValue)
end
-- SH Pointshop Premium Points
PerfectCasino.Config.RewardsFunctions["pssh_prempoints"] = function(ply, ent, inputValue)
	ply:SH_AddPremiumPoints(inputValue)
end
-- William's Car Dealer
PerfectCasino.Config.RewardsFunctions["wcd_givecar"] = function(ply, ent, inputValue)
    RunConsoleCommand("wcd_givevehicle", ply:SteamID(), inputValue)
end
-- Fresh Car Dealer Give Car
PerfectCasino.Config.RewardsFunctions["fcd_givecar"] = function(ply, ent, inputValue)
	fcd.giveVehicle(ply, inputValue)
end
-- Brick Wall's Essentials
PerfectCasino.Config.RewardsFunctions["bwe_givexp"] = function(ply, ent, inputValue)
	ply:AddExperience(inputValue, "pCasino")
end
-- mTokens tokens
PerfectCasino.Config.RewardsFunctions["mtkn_tokens"] = function(ply, ent, inputValue)
	mTokens.AddPlayerTokens(ply, tonumber(inputValue))
end
-- SantosRP (Credit to Finnet [76561198369907384])
PerfectCasino.Config.RewardsFunctions["srp_givecar"] = function(ply, ent, inputValue)
	ply:GetCharacter().Vehicles[inputValue] = {
		color = Color(255, 255, 255, 255)
    }
	GAMEMODE.Player:SetGameVar(ply, "vehicles", ply:GetCharacter().Vehicles)
	GAMEMODE.SQL:MarkDiffDirty(ply, "vehicles")
end
-- Brick's Credits
PerfectCasino.Config.RewardsFunctions["bc_credits"] = function(ply, ent, inputValue)
	ply:AddBRCS_Credits(inputValue)
end
-- VCMod (Credit to slaVAC [76561198095033845])
PerfectCasino.Config.RewardsFunctions["vcmod_givecar"] = function(ply, ent, inputValue)
    if not ply:VC_CD_getOwnedVehicleData(inputValue) then
        ply:VC_CD_addVehicle(inputValue)
    end
end
-- Modern Car Dealer. "Car Dealer" will need to be changed to the name of the vendor
PerfectCasino.Config.RewardsFunctions["mcd_givecar"] = function(ply, ent, inputValue)
    RunConsoleCommand("mcd_givecar", ply:SteamID64(), "Car Dealer", inputValue)
end

if SERVER then return end
-- Here you can add custom icons that can be used in the prize wheels.
-- The formatting is as follows:
-- 1st argument: A unique name. This must be lowercase and have no spaces or special characters.
-- 2nd argument: This is the display name. This can be anything you like and will be what shows up the UIs
-- 3rd argument: This is the URL to the image. It must be a PNG and will be rescaled to a 1:1 aspect ration, so to provide it as a square image will help keep quality.
-- Example:
PerfectCasino.Core.AddIcon("car", "Car", "https://i.imgur.com/Wk8k3HN.png")

--PATH lua/autorun/pommes_patrol_seat.lua:
local Category = "Vehicle Utilities"

local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_HL2MP_IDLE_PASSIVE )
end

local V = {
	Name = "Patrol Transport Passenger Seat",
	Model = "models/nova/airboat_seat.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	Author = "Syphadias, Oninoni, KingPommes",
	Information = "Seat with custom animation",
	Offset = 0,

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt",
		limitview = "0"
	},
	Members = {
		HandleAnimation = StandAnimation
	}
}
list.Set( "Vehicles", "pommes_patrol_seat", V )
--PATH lua/autorun/r4.lua:
return gluapack()()
--PATH lua/reality_development/client/cl_functions.lua:
return gluapack()()
--PATH lua/reality_development/client/cl_functions.lua:
local plyMeta = FindMetaTable("Player")

--[[---------------------------------]]--
--  HUD Removal
--[[---------------------------------]]--

net.Receive("RDV.LIBRARY.RemoveHUD", function()
	local time = net.ReadInt(32)

	hook.Add("HUDShouldDraw", "RDV.LIBRARY.RemoveHUD", function(name)
		if ( name == "CHudWeaponSelection" ) then return true end
		if ( name == "CHudChat" ) then return true end

		return false
	end)

	timer.Simple(time, function()
		hook.Remove("HUDShouldDraw", "RDV.LIBRARY.RemoveHUD")
	end)
end)

--[[---------------------------------]]--
--  [LEGACY] Old AddText support.
--[[---------------------------------]]--

function plyMeta:RD_SendNotification(...)
    RDV.LIBRARY.AddText(self, ...)
end

--[[

	Shorten a string and, like- add dots?

--]]

function EPS_ShortenString(text, length)
    if string.len(text) > length then
        return string.sub(text, 0, length).."..."
    end

    return text
end

hook.Add( "InitPostEntity", "RDV.LIBRARY.PlayerReadyForNetworking", function()
	if !IsValid(LocalPlayer()) then return end
	
	LocalPlayer().RDV = LocalPlayer().RDV or {}

	net.Start( "RDV.LIBRARY.PlayerReadyForNetworking" )
	net.SendToServer()
end )

--PATH lua/reality_development/client/vgui/cl_collapsiblecategory.lua:
local PANEL = {}

function PANEL:Init()
    local CAT_LABEL = self:GetChildren()[1]

    CAT_LABEL:SetTextColor(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme"))
    CAT_LABEL:SetContentAlignment(5)
    CAT_LABEL:SetFont("RDV_LIB_FRAME_TITLE")
    CAT_LABEL:SetTall(CAT_LABEL:GetTall() * 1.5) 
    CAT_LABEL.Paint = function(s, w, h) 
        surface.SetDrawColor( RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme") )
        surface.DrawOutlinedRect( 0, 0, w, h )
    end
end

function PANEL:OnToggle(B)
    local CAT_LABEL = self:GetChildren()[1]

    if B then
        CAT_LABEL:SetTextColor(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme"))
    else
        CAT_LABEL:SetTextColor(color_white)
    end
end

function PANEL:Paint(w, h)
    surface.SetDrawColor( RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme") )
    surface.DrawOutlinedRect( 0, 0, w, h )
end



vgui.Register("RDV_LIBRARY_CollapsibleCategory", PANEL, "DCollapsibleCategory")
--PATH lua/reality_development/functions/text_wrap/cl_functions.lua:
RDV = RDV or {}

-- Taken from DarkRP. Credits to the contributors.
-- https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/base/cl_util.lua#L24

local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if totalWidth >= remainingWidth then
            -- totalWidth needs to include the character width because it's inserted in a new line
            totalWidth = surface.GetTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

function RDV.textWrap(text, font, maxWidth)
    return RDV.LIBRARY.textWrap(text, font, maxWidth)
end

function RDV.LIBRARY.textWrap(text, font, maxWidth)
    local totalWidth = 0

    surface.SetFont(font)

    local spaceWidth = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                totalWidth = 0
            end

            local wordlen = surface.GetTextSize(word)
            totalWidth = totalWidth + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= maxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
                totalWidth = splitPoint
                return splitWord
            elseif totalWidth < maxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                totalWidth = wordlen - spaceWidth
                return '\n' .. string.sub(word, 2)
            end

            totalWidth = wordlen
            return '\n' .. word
        end)

    return text
end
--PATH lua/reality_development/functions/timer/sh_functions.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/list/sh_helix.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_nmoney2.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("nmoney2")

function OBJ:AddMoney(p, amount)
    local MONEY = tonumber(p:GetNWString( "WalletMoney", "0" ))

    p:SetNWString( "WalletMoney", tostring((MONEY + amount)) )
end

function OBJ:CanAfford(p, amount)
    local MONEY = p:GetNWString( "WalletMoney", "0" )

    return tonumber(MONEY) >= amount
end

function OBJ:FormatMoney(money)
    return string.Comma(money)
end
--PATH lua/autorun/rsb.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_mp.lua:
if SAM_LOADED then return end

local sam = sam
local mp = sam.load_file("sam/libs/message_pack/sh_messagepack.lua")
local EXT_VECTOR  = 1
local EXT_ANGLE   = 2
local EXT_ENTITY  = 3
local EXT_PLAYER  = 4
local EXT_COLOR   = 5
local EXT_CONSOLE = 6

mp.packers["Entity"] = function(buffer, ent)
	local buf = {}
	mp.packers["number"](buf, ent:EntIndex())
	mp.packers["ext"](buffer, EXT_ENTITY, buf[1])
end
mp.packers["Vehicle"] = mp.packers["Entity"]
mp.packers["Weapon"] = mp.packers["Entity"]
mp.packers["NPC"] = mp.packers["Entity"]
mp.packers["NextBot"] = mp.packers["Entity"]
mp.packers["PhysObj"] = mp.packers["Entity"]

mp.packers["Player"] = function(buffer, ply)
	local buf = {}
	mp.packers["number"](buf, ply:UserID())
	mp.packers["ext"](buffer, EXT_PLAYER, buf[1])
end

local VECTOR = {}
mp.packers["Vector"] = function(buffer, vec)
	VECTOR[1] = vec.x
	VECTOR[2] = vec.y
	VECTOR[3] = vec.z

	local buf = {}
	mp.packers["_table"](buf, VECTOR)
	mp.packers["ext"](buffer, EXT_VECTOR, table.concat(buf))
end

local ANGLE = {}
mp.packers["Angle"] = function(buffer, ang)
	ANGLE[1] = ang.p
	ANGLE[2] = ang.y
	ANGLE[3] = ang.r

	local buf = {}
	mp.packers["_table"](buf, ANGLE)
	mp.packers["ext"](buffer, EXT_ANGLE, table.concat(buf))
end

local COLOR = {}
mp.packers["Color"] = function(buffer, col)
	COLOR[1] = col.r
	COLOR[2] = col.g
	COLOR[3] = col.b
	COLOR[4] = col.a

	local buf = {}
	mp.packers["_table"](buf, COLOR)
	mp.packers["ext"](buffer, EXT_COLOR, table.concat(buf))
end

mp.packers["console"] = function(buffer)
	mp.packers["ext"](buffer, EXT_CONSOLE, "")
end

local Entity = Entity
local Player = Player
local Color = Color
local Vector = Vector
local Angle = Angle
local unpackers = {
	[EXT_ENTITY] = function(v)
		return Entity(v)
	end,
	[EXT_PLAYER] = function(v)
		return Player(v)
	end,
	[EXT_VECTOR] = function(v)
		return Vector(v[1], v[2], v[3])
	end,
	[EXT_ANGLE] = function(v)
		return Angle(v[1], v[2], v[3])
	end,
	[EXT_COLOR] = function(v)
		return Color(v[1], v[2], v[3], v[4])
	end,
	[EXT_CONSOLE] = function(v)
		return sam.console
	end
}

mp.build_ext = function(tag, data)
	local f = mp.unpacker(data)
	local _, v = f()
	return unpackers[tag](v)
end

sam.mp = mp

--PATH addons/[admin] sam-160/lua/sam/libs/sh_globals.lua:
if SAM_LOADED then return end

local sam, netstream = sam, sam.netstream

local globals

if SERVER then
	globals = {}
	local order = {}

	local get_order_key = function(key)
		for i = 1, #order do
			if order[i] == key then
				return i
			end
		end
	end

	function sam.set_global(key, value, force)
		if force or globals[key] ~= value then
			globals[key] = value

			if value ~= nil then
				if not get_order_key(key) then
					table.insert(order, key)
				end
			else
				local i = get_order_key(key)
				if i then
					table.remove(order, i)
				end
			end

			netstream.Start(nil, "SetGlobal", key, value)
		end
	end

	hook.Add("SAM.PlayerNetReady", "SAM.SendGlobals", function(ply)
		netstream.StartCompressed(ply, "SendGlobals", globals, order)
	end)
end

if CLIENT then
	function sam.set_global(key, value)
		if globals then
			globals[key] = value
			hook.Call("SAM.ChangedGlobalVar", nil, key, value)
		end
	end
	netstream.Hook("SetGlobal", sam.set_global)

	netstream.Hook("SendGlobals", function(vars, order)
		globals = vars

		for _, key in ipairs(order) do
			hook.Call("SAM.ChangedGlobalVar", nil, key, vars[key])
		end
	end)
end

function sam.get_global(key, default)
	if globals then
		local value = globals[key]
		if value ~= nil then
			return value
		end
	end

	return default
end

--PATH addons/[admin] sam-160/lua/sam/player/sh_player.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

do
	local _player = {}
	sam.player = setmetatable(sam.player, {
		__index = _player,
		__newindex = function(_, k, v)
			_player[k] = v
			if sam.isfunction(v) and debug.getlocal(v, 1) == "ply" then
				FindMetaTable("Player")["sam_" .. k] = v
				sam.console["sam_" .. k] = v
			end
		end
	})
end

function sam.player.find_by_name(name)
	name = name:lower()
	local current, players = nil, player.GetAll()
	for i = 1, #players do
		local ply = players[i]
		local found = ply:Name():lower():find(name, 1, true)
		if found then
			if current then
				if not sam.istable(current) then
					current = {current, ply}
				else
					table.insert(current, ply)
				end
			else
				current = ply
			end
		end
	end
	return current
end

do
	if CLIENT then
		config.add_menu_setting("Chat Prefix (Leave empty for no prefix)", function()
			local entry = vgui.Create("SAM.TextEntry")
			entry:SetPlaceholder("")
			entry:SetNoBar(true)
			entry:SetConfig("ChatPrefix", "")

			return entry
		end)
	end

	function sam.player.send_message(ply, msg, tbl)
		if SERVER then
			if sam.isconsole(ply) then
				local result = sam.format_message(msg, tbl)
				sam.print(unpack(result, 1, result.__cnt))
			else
				return sam.netstream.Start(ply, "send_message", msg, tbl)
			end
		else
			local prefix_result = sam.format_message(config.get("ChatPrefix", ""))
			local prefix_n = #prefix_result

			local result = sam.format_message(msg, tbl, prefix_result, prefix_n)
			chat.AddText(unpack(result, 1, result.__cnt))
		end
	end

	if SERVER then
		function sam.player.add_text(ply, ...)
			if sam.isconsole(ply) then
				sam.print(...)
			else
				sam.netstream.Start(ply, "add_text", ...)
			end
		end
	end

	if CLIENT then
		sam.netstream.Hook("send_message", function(msg, tbl)
			sam.player.send_message(nil, msg, tbl)
		end)

		sam.netstream.Hook("add_text", function(...)
			chat.AddText(...)
		end)
	end
end

do
	local PLAYER = FindMetaTable("Player")

	timer.Simple(0, function()
		function PLAYER:GetUserGroup()
			return self:sam_get_nwvar("rank", "user")
		end
	end)

	function PLAYER:IsAdmin()
		return self:CheckGroup("admin")
	end

	function PLAYER:IsSuperAdmin()
		return self:CheckGroup("superadmin")
	end

	local inherits_from = sam.ranks.inherits_from
	function PLAYER:CheckGroup(name)
		return inherits_from(self:GetUserGroup(), name)
	end

	local has_permission = sam.ranks.has_permission
	function PLAYER:HasPermission(perm)
		return has_permission(self:GetUserGroup(), perm)
	end

	local can_target = sam.ranks.can_target
	function PLAYER:CanTarget(ply)
		return can_target(self:GetUserGroup(), ply:GetUserGroup())
	end

	function PLAYER:CanTargetRank(rank)
		return can_target(self:GetUserGroup(), rank)
	end

	local get_ban_limit = sam.ranks.get_ban_limit
	function PLAYER:GetBanLimit(ply)
		return get_ban_limit(self:GetUserGroup())
	end

	function PLAYER:sam_get_play_time()
		return self:sam_get_nwvar("play_time", 0) + self:sam_get_session_time()
	end

	function PLAYER:sam_get_session_time()
		return os.time() - self:sam_get_nwvar("join_time", 0)
	end

	if SERVER then
		function PLAYER:Ban(length)
			self:sam_ban(length)
		end

		-- if an addon like FPP loads before sam while DarkRP is installed, it will use darkrp.oldSetUserGroup which is gmod default
		-- so we add a timer to make sure sam's SetUserGroup gets called
		-- also i don't use (Set/Get)NwVar because when i send a hook that player rank changed to clients, ply:GetUserGroup won't be updated yet in clientside inside that hook
		timer.Simple(0, function()
			sam.oldSetUserGroup = sam.oldSetUserGroup or PLAYER.SetUserGroup
			function PLAYER:SetUserGroup(name)
				self:sam_set_nwvar("rank", name)
				return sam.oldSetUserGroup(self, name)
			end
		end)

		hook.Remove("PlayerInitialSpawn", "PlayerAuthSpawn")
	end
end

do
	local set_cooldown = function(ply, name, time)
		if not ply.sam_cool_downs then
			ply.sam_cool_downs = {}
		end
		ply.sam_cool_downs[name] = SysTime() + time
		return true
	end

	function sam.player.check_cooldown(ply, name, time)
		if not ply.sam_cool_downs or not ply.sam_cool_downs[name] then
			return set_cooldown(ply, name, time)
		end

		local current_time = SysTime()
		local cool_down = ply.sam_cool_downs[name]
		if cool_down > current_time then
			return false, cool_down - current_time
		else
			return set_cooldown(ply, name, time)
		end
	end
end

--PATH addons/[admin] sam-160/lua/sam/command/sh_command.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/dropdown.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/rank.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local is_good_rank = function(rank, arg, ply)
	if arg.check and not arg.check(rank, ply) then
		return false
	end
	return true
end

command.new_argument("rank")
	:OnExecute(function(arg, input, ply, _, result, i)
		if not input and arg.optional then
			result[i] = nil
			return
		end

		if not sam.ranks.is_rank(input) or not is_good_rank(input, arg, ply) then
			ply:sam_send_message("invalid", {
				S = arg.hint or "rank", S_2 = input
			})
			return false
		end

		result[i] = input
	end)

	:Menu(function(set_result, body, buttons, arg)
		local current_rank = arg.hint or "select rank"

		local ranks = buttons:Add("SAM.ComboBox")
		ranks:SetValue(current_rank)
		ranks:SetTall(25)

		function ranks:OnSelect(_, value)
			set_result(value)
			current_rank = value
		end

		function ranks:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end

			self:Clear()
			self:SetValue(current_rank)

			for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
				if is_good_rank(rank_name, arg, LocalPlayer()) then
					self:AddChoice(rank_name)
				end
			end

			self:OpenMenu()
		end

		return ranks
	end)

	:AutoComplete(function(arg, result, name)
		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if rank_name:lower():find(name, 1, true) and is_good_rank(rank_name, arg, LocalPlayer()) then
				table.insert(result, rank_name)
			end
		end
	end)
:End()
--PATH addons/[lib] sui/lua/sui/libs/types.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/cl_base.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + 20 * 0.012 --[[ slowly increase scroll speed ]]
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- \_()_/ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 17
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 10, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_threegrid.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/bans.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_bans", nil, "superadmin")

local get_pages_count = function(bans_count)
	bans_count = bans_count / 35
	local i2 = math.floor(bans_count)
	return bans_count ~= i2 and i2 + 1 or bans_count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_bans") and ply:sam_check_cooldown("MenuManageBans", 0.1)
	end

	local limit = 35

	local get_page_count = function(res, callback, page, order_by, keyword)
		local current_time = os.time()
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_bans`
			WHERE
				(`unban_date` >= %d OR `unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		SQL.Query(query, callback, true, {res, page, order_by, keyword, current_time})
	end

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_bans = function(count_data, arguments)
		local res, page, order_by, keyword, current_time = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`sam_bans`.*,
				IFNULL(`p1`.`name`, '') AS `name`,
				IFNULL(`p2`.`name`, '') AS `admin_name`
			FROM
				`sam_bans`
			LEFT OUTER JOIN
				`sam_players` AS `p1`
			ON
				`sam_bans`.`steamid` = `p1`.`steamid`
			LEFT OUTER JOIN
				`sam_players` AS `p2`
			ON
				`sam_bans`.`admin` = `p2`.`steamid`
			WHERE
				(`sam_bans`.`unban_date` >= %d OR `sam_bans`.`unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `sam_bans`.`steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		local offset = math.abs(limit * (page - 1))
		query = query .. ([[
			ORDER BY
				`sam_bans`.`id` %s
			LIMIT
				%d OFFSET %d]]):format(order_by, limit, offset)

		SQL.Query(query, resolve_promise, nil, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetBans", function(res, ply, page, order_by, keyword)
		if not isnumber(page) then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(res, get_bans, page, order_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/ban-user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_order, keyword = nil, "DESC", nil

	local bans_body = column_sheet:Add("Panel")
	bans_body:Dock(FILL)
	bans_body:DockMargin(0, 1, 0, 0)
	bans_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(bans_body)

	local title = bans_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Bans")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = bans_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total bans")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	do
		local container = bans_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter()
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				refresh()
			end
		end
	end

	Line(bans_body, nil, -5, 15, -5, 0)

	do
		local columns = bans_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local time_left = columns:Add("SAM.Label")
		time_left:Dock(LEFT)
		time_left:DockMargin(-4, 0, 0, 0)
		time_left:SetFont(COLUMN_FONT)
		time_left:SetText("Time Left")
		time_left:SetTextColor(GetColor("player_list_titles"))
		time_left:SetWide(SUI.Scale(180))
		time_left:SizeToContentsY(3)

		local reason = columns:Add("SAM.Label")
		reason:Dock(LEFT)
		reason:DockMargin(-4, 0, 0, 0)
		reason:SetFont(COLUMN_FONT)
		reason:SetText("Reason")
		reason:SetTextColor(GetColor("player_list_titles"))
		reason:SetWide(SUI.Scale(280))
		reason:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = bans_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local bans, bans_count, current_page_2 = unpack(data)
		total:SetText(bans_count .. " total bans")

		pages = get_pages_count(bans_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(bans) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			local admin_name = v.admin_name ~= "" and v.admin_name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = admin_name or (v.admin == "Console" and "Console"),
				rank_bg = not admin_name and GetColor("player_list_console")
			})

			local unban_date = tonumber(v.unban_date)
			local time_left = line:Add("SAM.Label")
			time_left:Dock(LEFT)
			time_left:DockMargin(-3, 0, 0, 0)
			time_left:SetFont(LINE_FONT)
			time_left:SetText(unban_date == 0 and "Never" or sam.reverse_parse_length((unban_date - os.time()) / 60))
			time_left:SetTextColor(GetColor("player_list_data"))
			time_left:SetContentAlignment(4)
			time_left:SetWide(SUI.Scale(180))

			local reason = line:Add("SAM.Label")
			reason:Dock(LEFT)
			reason:DockMargin(4, 0, 0, 0)
			reason:SetFont(LINE_FONT)
			reason:SetText(v.reason)
			reason:SetTextColor(GetColor("player_list_data"))
			reason:SetContentAlignment(4)
			reason:SetWrap(true)
			reason:SetWide(SUI.Scale(200))

			local old_tall = line.size
			function reason:PerformLayout()
				local _, h = self:GetTextSize()
				if old_tall < h then
					line:SetTall(h)
				end
			end

			local but = line:Actions()
			but:On("DoClick", function()
				local dmenu = vgui.Create("SAM.Menu")
				dmenu:SetInternal(but)
				if name then
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)
				end
				dmenu:AddOption("Copy SteamID", function()
					SetClipboardText(v.steamid)
				end)
				dmenu:AddOption("Copy Reason", function()
					SetClipboardText(v.reason)
				end)
				dmenu:AddOption("Copy Time Left", function()
					SetClipboardText(time_left:GetText())
				end)

				if v.admin ~= "Console" then
					dmenu:AddSpacer()

					if admin_name then
						dmenu:AddOption("Copy Admin Name", function()
							SetClipboardText(admin_name)
						end)
					end

					dmenu:AddOption("Copy Admin SteamID", function()
						SetClipboardText(v.admin)
					end)
				end

				if LocalPlayer():HasPermission("unban") then
					dmenu:AddSpacer()
					dmenu:AddOption("Unban", function()
						local user = name and ("%s (%s)"):format(name, v.steamid) or v.steamid
						local querybox = vgui.Create("SAM.QueryBox")
						querybox:SetWide(350)
						querybox:SetTitle(user)

						local check = querybox:Add("SAM.Label")
						check:SetText(sui.wrap_text("Are you sure that you want to unban\n" .. user, LINE_FONT, SUI.Scale(350)))
						check:SetFont(LINE_FONT)
						check:SizeToContents()

						querybox:Done()
						querybox.save:SetEnabled(true)
						querybox.save:SetText("UNBAN")

						querybox.save:SetContained(false)
						querybox.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

						querybox.cancel:SetContained(true)
						querybox.cancel:SetColors()

						querybox:SetCallback(function()
							RunConsoleCommand("sam", "unban", v.steamid)
						end)
					end)
				end
				dmenu:Open()
			end)

			body:Line()
		end

		body:InvalidateLayout(true)
		body:GetCanvas():InvalidateLayout(true)
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_bans") then
			local refresh_query = netstream.async.Start("SAM.GetBans", toggle_loading, current_page.i, current_order, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = bans_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	for k, v in ipairs({"SAM.BannedPlayer", "SAM.BannedSteamID", "SAM.EditedBan", "SAM.UnbannedSteamID"}) do
		hook.Add(v, "SAM.MenuBans", function()
			if IsValid(body) then
				refresh()
			end
		end)
	end

	refresh()

	return bans_body
end, function()
	return LocalPlayer():HasPermission("manage_bans")
end, 4)
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config/server.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

config.add_tab("Server", function(parent)
	local server_body = parent:Add("SAM.ScrollPanel")
	server_body:Dock(FILL)
	server_body:LineMargin(0, 6, 0, 0)

	local i = 0
	server_body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)
	end)

	for k, v in ipairs(sam.config.get_menu_settings()) do
		local panel = v.func(server_body)
		if ispanel(panel) then
			local setting = server_body:Add("SAM.LabelPanel")
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel(v.title)
			setting:SetPanel(panel)
		end

		server_body:Line()
	end

	return server_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 1)
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/ranks.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/chat.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/support_cami.lua:
if SAM_LOADED then return end

local ranks_loaded
if SERVER then
	ranks_loaded = sam.ranks.ranks_loaded()
else
	ranks_loaded = sam.ranks.get_ranks() ~= nil
end

do
	local load_ranks = function()
		for name, rank in pairs(sam.ranks.get_ranks()) do
			if not sam.ranks.is_default_rank(name) then
				CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
			end
		end
	end

	if ranks_loaded then
		load_ranks()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksToCAMI", load_ranks)
	end
end

hook.Add("SAM.AddedRank", "SAM.CAMI.AddedRank", function(name, rank)
	if not sam.ranks.is_default_rank(name) then
		CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
	end
end)

hook.Add("SAM.RemovedRank", "SAM.CAMI.RemovedRank", function(name)
	CAMI.UnregisterUsergroup(name, "SAM")
end)

hook.Add("SAM.RankNameChanged", "SAM.CAMI.RankNameChanged", function(old, new)
	CAMI.UnregisterUsergroup(old, "SAM")
	CAMI.RegisterUsergroup({Name = new, Inherits = sam.ranks.get_rank(new).inherit}, "SAM")
end)

hook.Add("SAM.ChangedPlayerRank", "SAM.CAMI.ChangedPlayerRank", function(ply, new_rank, old_rank)
	CAMI.SignalUserGroupChanged(ply, old_rank, new_rank, "SAM")
end)

hook.Add("SAM.ChangedSteamIDRank", "SAM.CAMI.ChangedSteamIDRank", function(steamid, new_rank, old_rank)
	CAMI.SignalSteamIDUserGroupChanged(steamid, old_rank, new_rank, "SAM")
end)

----------------------------------------------------------------------------------------------------------------------------------------------------------

if SERVER then
	do
		local on_user_group_registered = function(rank, source)
			if source ~= "SAM" then
				sam.ranks.add_rank(rank.Name, sam.ranks.is_rank(rank.Inherits) and rank.Inherits or "user")
			end
		end

		local load_ranks = function()
			for _, rank in pairs(CAMI.GetUsergroups()) do
				on_user_group_registered(rank, "CAMI")
			end
			hook.Add("CAMI.OnUsergroupRegistered", "SAM.CAMI.OnUsergroupRegistered", on_user_group_registered)
		end

		if ranks_loaded then
			load_ranks()
		else
			hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksFromCAMI", load_ranks)
		end
	end

	hook.Add("CAMI.OnUsergroupUnregistered", "SAM.CAMI.OnUsergroupUnregistered", function(rank, source)
		if source ~= "SAM" then
			sam.ranks.remove_rank(rank.Name)
		end
	end)

	hook.Add("CAMI.PlayerUsergroupChanged", "SAM.CAMI.PlayerUsergroupChanged", function(ply, _, new_rank, source)
		if ply and IsValid(ply) and source ~= "SAM" then
			sam.player.set_rank(ply, new_rank)
		end
	end)

	hook.Add("CAMI.SteamIDUsergroupChanged", "SAM.CAMI.SteamIDUsergroupChanged", function(steamid, _, new_rank, source)
		if sam.is_steamid(steamid) and source ~= "SAM" then
			sam.player.set_rank_id(steamid, new_rank)
		end
	end)
end

do
	local on_privilege_registered = function(privilege)
		sam.permissions.add(privilege.Name, "CAMI", privilege.MinAccess)
	end

	local load_privileges = function()
		for _, privilege in pairs(CAMI.GetPrivileges()) do
			on_privilege_registered(privilege)
		end
		hook.Add("CAMI.OnPrivilegeRegistered", "SAM.CAMI.OnPrivilegeRegistered", on_privilege_registered)
	end

	if ranks_loaded then
		load_privileges()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadPrivileges", load_privileges)
	end
end

hook.Add("CAMI.OnPrivilegeUnregistered", "SAM.CAMI.OnPrivilegeUnregistered", function(privilege)
	sam.permissions.remove(privilege.Name)
end)

hook.Add("CAMI.PlayerHasAccess", "SAM.CAMI.PlayerHasAccess", function(ply, privilege, callback, target)
	if sam.type(ply) ~= "Player" then return end

	local has_permission = ply:HasPermission(privilege)
	if sam.type(target) == "Player" then
		callback(has_permission and ply:CanTarget(target))
	else
		callback(has_permission)
	end

	return true
end)
--PATH addons/[admin] sam-160/lua/sam/modules/utime.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/vote.lua:
if SAM_LOADED then return end

-- DONT EVER TALK TO ME ABOUT THIS CODE

local sam, command = sam, sam.command

command.set_category("Voting")

local start_vote, end_vote
if SERVER then
	local vote_on = false
	local options, players_voted

	local shuffle = function(tbl) -- https://gist.github.com/Uradamus/10323382
		for i = #tbl, 2, -1 do
			local j = math.random(i)
			tbl[i], tbl[j] = tbl[j], tbl[i]
		end
		return tbl
	end

	end_vote = function(ply, callback)
		if not vote_on then
			return ply:sam_add_text(color_white, "There is no vote to end.")
		end

		vote_on = false

		sam.set_global("Vote", nil)

		if callback then
			local tbl = {}
			local total_count = 0

			for i = 1, #options do
				local count = sam.get_global("Votings" .. i)
				total_count = total_count + count
				table.insert(tbl, {i, count})
				sam.set_global("Votings" .. i, nil)
			end

			if total_count == 0 then
				return sam.player.add_text(nil, color_white, "The vote have been canceled because nobody voted.")
			end

			table.sort(shuffle(tbl), function(a,b) return a[2] > b[2] end)

			local v = tbl[1]
			local winner, count = v[1], v[2]

			callback(winner, options[winner], count, total_count)
		else
			for i = 1, #options do
				sam.set_global("Votings" .. i, nil)
			end
		end

		options, players_voted = nil, nil

		timer.Remove("SAM.Vote")
	end

	start_vote = function(ply, callback, title, ...)
		if vote_on then
			return ply:sam_add_text(color_white, "There is an active vote, wait for it to finish.")
		end

		vote_on = true

		options, players_voted = {}, {}

		local args, n = {...}, select("#", ...)
		for i = 1, n do
			local v = args[i]
			if v then
				table.insert(options, v)
			end
		end

		sam.set_global("Vote", {title, options, CurTime()})

		for k in ipairs(options) do
			sam.set_global("Votings" .. k, 0)
		end

		timer.Create("SAM.Vote", 25, 1, function()
			end_vote(ply, callback)
		end)

		return true
	end

	sam.netstream.Hook("Vote", function(ply, index)
		if not sam.isnumber(index) or index > 5 then return end

		local votings = sam.get_global("Votings" .. index)
		if not votings then return end

		local old_index = players_voted[ply:AccountID()]
		if old_index == index then return end

		if old_index then
			sam.set_global("Votings" .. old_index, sam.get_global("Votings" .. old_index) - 1)
		end

		sam.set_global("Votings" .. index, votings + 1)

		players_voted[ply:AccountID()] = index
	end)
end

if CLIENT then
	local SUI = sam.SUI
	-- https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/extensions/client/player.lua

	local VOTING_TITLE = SUI.CreateFont("VotingTitle", "Roboto Bold", 15)
	local VOTING_OPTION = SUI.CreateFont("VotingTitle", "Roboto Medium", 14)

	local bind_translation = {}
	for i = 0, 9 do
		bind_translation["slot" .. i] = i
	end

	local voting_frame

	end_vote = function()
		if IsValid(voting_frame) then
			voting_frame:Remove()
		end
		hook.Remove("PlayerBindPress", "SAM.Voting")
		hook.Remove("SAM.ChangedGlobalVar", "SAM.VotingCount")
	end

	hook.Add("SAM.ChangedGlobalVar", "Voting", function(key, value)
		if key ~= "Vote" then return end

		if not value then
			end_vote()
			return
		end

		local title, options, start_time = value[1], value[2], value[3]

		sui.TDLib.Start()

		voting_frame = vgui.Create("EditablePanel")
		voting_frame:SetSize(SUI.Scale(165), SUI.Scale(230))
		voting_frame:SetPos(5, ScrH() * 0.25)
		voting_frame:DockPadding(4, 4, 4, 4)
		voting_frame:Blur()
			:Background(Color(30, 30, 30, 240))

		local voting_title = voting_frame:Add("SAM.Label")
		voting_title:Dock(TOP)
		voting_title:SetFont(VOTING_TITLE)
		voting_title:TextColor(Color(220, 220, 220))
		voting_title:SetText(title)
		voting_title:SetWrap(true)
		voting_title:SetAutoStretchVertical(true)

		local line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local options_added = {}
		for i, v in ipairs(options) do
			local option = voting_frame:Add("SAM.Label")
			option:Dock(TOP)
			option:SetFont(VOTING_OPTION)
			option:TextColor(Color(220, 220, 220), true)
			option:SetText(i .. ". " .. v .. " (0)")
			option:SetWrap(true)
			option:SetAutoStretchVertical(true)

			options_added[i] = option
		end

		function voting_frame:Think() -- fucking gmod
			self:SizeToChildren(false, true)

			local time_left = math.floor(25 - (CurTime() - start_time))
			if time_left <= 0 then
				end_vote()
				voting_frame.Think = nil
				return
			end

			voting_title:SetText(title .. " (" .. time_left .. ")")
		end

		line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local option = voting_frame:Add("SAM.Label")
		option:Dock(TOP)
		option:SetFont(VOTING_OPTION)
		option:TextColor(Color(220, 220, 220), true)
		option:SetText("0. Close")
		option:SetWrap(true)
		option:SetAutoStretchVertical(true)

		sui.TDLib.End()

		local current_index
		hook.Add("PlayerBindPress", "SAM.Voting", function(_, bind, down)
			if not down then return end

			local index = bind_translation[bind]
			if not index then return end

			if index == 0 then
				end_vote()
				return true
			end

			if not options[index] then return true end

			if current_index then
				options_added[current_index]:TextColor(Color(220, 220, 220), true)
			end

			options_added[index]:TextColor(Color(65, 185, 255), true)
			current_index = index

			sam.netstream.Start("Vote", index)

			return true
		end)

		hook.Add("SAM.ChangedGlobalVar", "SAM.VotingCount", function(key2, count)
			if key2:sub(1, 7) ~= "Votings" then return end
			if not count then return end

			local index = tonumber(key2:sub(8))
			options_added[index]:SetText(index .. ". " .. options[index] .. " (" .. count .. ")")
		end)
	end)
end

local vote_check = function(str)
	return str:match("%S") ~= nil
end

command.new("vote")
	:SetPermission("vote", "admin")

	:AddArg("text", {hint = "title", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})

	:Help("Start a vote!")

	:OnExecute(function(ply, title, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Vote {V} for {V_2} has been passed. ({V_3}/{V_4})", {
				V = title, V_2 = option, V_3 = count, V_4 = total_count
			})
		end

		if start_vote(ply, callback, title, ...) then
			sam.player.send_message(nil, "{A} started a vote with title {V}.", {
				A = ply, V = title
			})
		end
	end)
:End()

command.new("endvote")
	:SetPermission("endvote", "admin")

	:Help("End current vote.")

	:OnExecute(function(ply)
		end_vote(ply)
	end)
:End()

command.new("votekick")
	:SetPermission("votekick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to kick a player.")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(ply) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				target:Kick("Vote was successful (" .. (reason or "none") .. ")")

				sam.player.send_message(nil, "Vote was successful, {T} has been kicked. ({V})", {
					T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be kicked.", {
					T = target_name
				})
			end
		end

		local title = "Kick " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votekick against {T} ({V})", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votekick against {T}", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("voteban")
	:SetPermission("voteban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 60, min = 30, max = 120})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to ban a player.")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		local target_steamid, target_name = target:SteamID(), target:Name()
		local ply_steamid = ply:SteamID()

		local callback = function(index, option, count, total_count)
			if index == 1 then
				sam.player.ban_id(target_steamid, length, "Vote was successful (" .. (reason or "none") .. ")", ply_steamid)

				sam.player.send_message(nil, "Vote was successful, {T} has been banned. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be banned.", {
					T = target_name
				})
			end
		end

		local title = "Ban " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V} ({V_2})", {
					A = ply, T = targets, V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V}", {
					A = ply, T = targets, V = sam.format_length(length)
				})
			end
		end
	end)
:End()

command.new("votemute")
	:SetPermission("votemute", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to mute and gag a player.")

	:OnExecute(function(ply, targets, reason)
		local _reason = reason and (" (" .. reason .. ")") or ""

		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(target) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				RunConsoleCommand("sam", "mute", "#" .. target:EntIndex(), 0, "votemute" .. _reason)
				RunConsoleCommand("sam", "gag", "#" .. target:EntIndex(), 0, "votemute" .. _reason)

				sam.player.send_message(nil, "Vote was successful, {T} has been muted. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be muted.", {
					T = target_name
				})
			end
		end

		local title = "Mute " .. target_name .. "?" .. _reason
		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votemute against {T} ({V}).", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votemute against {T}.", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("votemap")
	:SetPermission("votemap", "admin")

	:AddArg("map", {exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})

	:GetRestArgs()

	:Help("Start a vote to change map.")

	:OnExecute(function(ply, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Map vote for {V} has been passed. ({V_2}/{V_3})", {
				V = option, V_2 = count, V_3 = total_count
			})

			if sam.is_valid_map(option) then
				RunConsoleCommand("sam", "map", option)
			end
		end

		local args = {...}
		for i = select("#", ...), 1, -1 do
			if args[i] == "None" then
				args[i] = nil
			end
		end
		table.insert(args, "Extend Current Map")

		if start_vote(ply, callback, "Vote for the next map!", unpack(args)) then
			sam.player.send_message(nil, "{A} started a map change vote.", {
				A = ply
			})
		end
	end)
:End()
--PATH addons/[lib] sui/lua/sui/vgui/sui_frame.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcollapse_category.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/cl_util.lua:
if SCB_LOADED then return end

local tonumber = tonumber
local Color = Color
local bit = bit
local file = file
local SortedPairs = SortedPairs
local table = table
local util = util
local math = math

local scb = scb

function scb.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function scb.rgb_hex(color)
	return ("%x%x%x"):format(color.r, color.g, color.b)
end

function scb.get_extension(path)
	return path:GetExtensionFromFilename():match("(%w+)")
end

function scb.to_new_range(x, old_min, old_max, new_min, new_max)
	return (x - old_min) * (new_max - new_min) / (old_max - old_min) + new_min
end

function scb.is_letter_digit(c)
	return
		(c >= "a" and c <= "z") or
		(c >= "A" and c <= "Z") or
		(c >= "0" and c <= "9")
end

function scb.is_custom_emoji(info)
	return info:sub(1, 4) == "http"
end

do
	local escape_replacements = {
		["\\"] = "\\\\",
		["{"] = "\\{" ,
		["}"] = "\\}"
	}

	function scb.escape(text)
		text = text:gsub(".", escape_replacements)

		local pos = 0
		while true do
			local start, url, _end = scb.find_url(text, pos + 1)
			if not start then break end
			pos = _end + 1
			text = text:sub(1, start - 1) .. "\\" .. url .. text:sub(_end + 1)
		end

		return text
	end
end

do
	-- i feel disgusted
	local insert = table.insert
	local SortByMember = table.SortByMember
	if not file.Exists("scb/emojis_used.txt", "DATA") then
		file.Write("scb/emojis_used.txt", "{}")
	end
	local emojis_times_used = util.JSONToTable(file.Read("scb/emojis_used.txt", "DATA"))

	function scb.search_emojis(text)
		local emojis = {}
		for name in SortedPairs(scb.emojis) do
			name = name:lower()
			local start = name:find(text, 1, true)
			if start then
				if name:sub(start - 1, start - 1) == "_" then
					start = 1
				elseif name == text then
					start = math.huge
				end
				local used_times = emojis_times_used[name]
				if start == 1 then
					if used_times then
						used_times = used_times + (9999999999 + (start ^ 4))
					else
						used_times = 9999999999
					end
				elseif used_times then
					used_times = used_times + (999999999 + (start ^ 4))
				else
					used_times = start
				end
				insert(emojis, {name = name, pos = -used_times})
			end
		end
		SortByMember(emojis, "pos", true)

		return emojis
	end

	function scb.emoji_set_used(emoji)
		emojis_times_used[emoji] = (emojis_times_used[emoji] or 0) + 1
		file.Write("scb/emojis_used.txt", util.TableToJSON(emojis_times_used))
	end
end

do
	-- https://stackoverflow.com/questions/23590304/finding-a-url-in-a-string-lua-pattern?rq=1

	-- https://raw.githubusercontent.com/incognico/list-of-top-level-domains/master/formats/json/tld-list.json
	local domains = [==[["aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","active","actor","ad","adac","ads","adult","ae","aeg","aero","aetna","af","afamilycompany","afl","africa","ag","agakhan","agency","ai","aig","aigo","airbus","airforce","airtel","akdn","al","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","americanexpress","americanfamily","amex","amfam","amica","amsterdam","an","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","bl","black","blackfriday","blanco","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnl","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","boots","bosch","bostik","boston","bot","boutique","box","bq","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","budapest","bugatti","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","cancerresearch","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","cartier","casa","case","caseih","cash","casino","cat","catering","catholic","cba","cbn","cbre","cbs","cc","cd","ceb","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","chloe","christmas","chrome","chrysler","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","coop","corsica","country","coupon","coupons","courses","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","csc","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dodge","dog","doha","domains","doosan","dot","download","drive","dtv","dubai","duck","dunlop","duns","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","eh","email","emerck","energy","engineer","engineering","enterprises","epost","epson","equipment","er","ericsson","erni","es","esq","estate","esurance","et","etisalat","eu","eurovision","eus","events","everbank","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","flsmidth","fly","fm","fo","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fujixerox","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glade","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodhands","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","guardian","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","honeywell","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hr","hsbc","ht","htc","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","iinet","ikano","il","im","imamat","imdb","immo","immobilien","in","industries","infiniti","info","ing","ink","institute","insurance","insure","int","intel","international","intuit","investments","io","ipiranga","iq","ir","irish","is","iselect","ismaili","ist","istanbul","it","itau","itv","iveco","iwc","jaguar","java","jcb","jcp","je","jeep","jetzt","jewelry","jio","jlc","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kim","kinder","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","ladbrokes","lamborghini","lamer","lancaster","lancia","lancome","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","liaison","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","lixil","lk","llc","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","lupin","luxe","luxury","lv","ly","ma","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mc","mcd","mcdonalds","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","meo","merckmsd","metlife","mf","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","mobily","moda","moe","moi","mom","monash","money","monster","montblanc","mopar","mormon","mortgage","moscow","moto","motorcycles","mov","movie","movistar","mp","mq","mr","ms","msd","mt","mtn","mtpc","mtr","mu","museum","mutual","mutuelle","mv","mw","mx","my","mz","na","nab","nadex","nagoya","name","nationwide","natura","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","newholland","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","northwesternmutual","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","off","office","okinawa","olayan","olayangroup","oldnavy","ollo","om","omega","one","ong","onl","online","onyourside","ooo","open","oracle","orange","org","organic","orientexpress","origins","osaka","otsuka","ott","ovh","pa","page","pamperedchef","panasonic","panerai","paris","pars","partners","parts","party","passagens","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","piaget","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","qvc","racing","radio","raid","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","rightathome","ril","rio","rip","rmit","ro","rocher","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sapo","sarl","sas","save","saxo","sb","sbi","sbs","sc","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scjohnson","scor","scot","sd","se","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","shriram","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","space","spiegel","sport","spot","spreadbetting","sr","srl","srt","ss","st","stada","staples","star","starhub","statebank","statefarm","statoil","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiftcover","swiss","sx","sy","sydney","symantec","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","telecity","telefonica","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tp","tr","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","uconnect","ug","uk","um","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","vista","vistaprint","viva","vivo","vlaanderen","vn","vodka","volkswagen","volvo","vote","voting","voto","voyage","vu","vuelos","wales","walmart","walter","wang","wanggou","warman","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","vermgensberater","vermgensberatung","","","","","","","","","","","","","","","xperia","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zippo","zm","zone","zuerich","zw"]]==]
	domains = util.JSONToTable(domains)

	local tlds = {}
	for i = 1, #domains do
		tlds[domains[i]], domains[i] = true, nil
	end

	local protocols = {["http://"] = 0, ["https://"] = 0}
	local pattern = "(([%w_.~!*:@&+$/?%%#-]-)(%w[-.%w]*%.)(%w+)(:?)(%d*)(/?)([%w_.~!*:@&+$/?%%#=-]*))"

	function scb.find_url(text, start)
		local pos = start
		while true do
			local pos_start, pos_end, url, prot, subd, tld, colon, port, slash, path = text:find(pattern, pos)
			if not pos_start then break end

			if protocols[prot:lower()] == (1 - #slash) * #path and not subd:find("%W%W")
				and (colon == "" or port ~= "" and port + 0 < 65536)
				and (tlds[tld:lower()] or tld:find("^%d+$") and subd:find("^%d+%.%d+%.%d+%.$")
				and math.max(tld, subd:match("^(%d+)%.(%d+)%.(%d+)%.$")) < 256)
			then
				return pos_start, url, pos_end
			end

			pos = pos_end + 1
		end
	end
end

--PATH addons/[chat] scb-29/lua/scb/settings/tabs/tags.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/cl_chatbox.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/vgui/scb_emojis_select.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_es-es.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_es-es.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "DPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Municion de Pistola"
L["ammo.357"] = "Municion de Magnum"
L["ammo.smg1"] = "Municion de Carabina"
L["ammo.ar2"] = "Municion de Rifle"
L["ammo.buckshot"] = "Municion de Escopeta"
L["ammo.sniperpenetratedround"] = "Municion de Sniper"
L["ammo.smg1_grenade"] = "Granadas de Rifle"
L["ammo.xbowbolt"] = "Pernos de Ballesta"
L["ammo.rpg_round"] = "Cohetes"
L["ammo.grenade"] = "Granadas"
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Municin del Arma de Alyx"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "FALLO!"
L["hud.therm_deco"] = "TEMP CAON"

L["hud.firemode.single"] = "SEMI"
L["hud.firemode.burst"] = "RFAGA"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SEGURO"

L["hud.hint.bash"] = "Golpear"
L["hud.hint.bipod"] = "Alternar Bpode"
L["hud.hint.breath"] = "Mantener Respiracion"
L["hud.hint.customize"] = "Customizar"
L["hud.hint.cycle"] = "Ciclo"
L["hud.hint.firemode"] = "Cambiar Modo de Disparo"
L["hud.hint.inspect"] = "Inspeccionar"
L["hud.hint.lean"] = "Inclinarse"
L["hud.hint.peek"] = "Vistazo"
L["hud.hint.reload"] = "Recarga"
L["hud.hint.safe"] = "Poner Seguro"
L["hud.hint.switchsights"] = "Cambiar Miras"
L["hud.hint.toggleatts"] = "Alternar Accesorios"
L["hud.hint.ubgl"] = "Alternar"
L["hud.hint.unjam"] = "Desatascar"
L["hud.hint.zoom"] = "Cambiar Zoom"
-- L["hud.hint.quicknade"] = "Quickthrow "

L["hud.hint.lowammo"] = "Municin Baja"
L["hud.hint.noammo"] = "Sin Municin"

L["hud.error.missingbind"] = "Ningn botn vinculado a %s"
L["hud.error.missingbind_zoom"] = "Vincular \"Zoom de Traje\" en ajustes!"
L["hud.error.missingbind_context"] = "Vincular \"Open Context Menu\" en ajustes!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "CUSTOMIZAR"
L["customize.panel.personalize"] = "PERSONALIZAR"
L["customize.panel.stats"] = "ESTADSTICAS & BALSTICAS"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPECCIONAR"
L["customize.panel.presets"] = "PREAJUSTES"

L["customize.stats.aimtime"] = "Tiempo para Apuntar"
L["customize.stats.ammo"] = "Tipo de Municin"
L["customize.stats.armorpiercing"] = "Penetracin de Armadura"
L["customize.stats.burstdelay"] = "Tiempo entre Rfagas"
L["customize.stats.capacity"] = "Capacidad"
L["customize.stats.cyclic"] = "DPM Cclicos"
L["customize.stats.explosive"] = "Dao Explosivo"
L["customize.stats.firemodes"] = "Modos de Disparo"
L["customize.stats.firepower"] = "Potencia de fuego"
L["customize.stats.freeaim"] = "Radio de Vista Libre"
L["customize.stats.muzzlevelocity"] = "Velocidad de salida"
L["customize.stats.noise"] = "Ruido"
L["customize.stats.penetration"] = "Penetracin"
L["customize.stats.precision"] = "Precisin"
L["customize.stats.range"] = "Rango"
L["customize.stats.ricochet"] = "Probablidad de Rebote"
L["customize.stats.rof"] = "DPM"
L["customize.stats.speed"] = "Velocidad de Movimiento"
L["customize.stats.sprinttofire"] = "Tiempo de Esprint a Disparo"
L["customize.stats.supplylimit"] = "Limite de Suministros"
L["customize.stats.sway"] = "Estabilidad"
L["customize.stats.triggerdelay"] = "Retraso de Gatillo"

L["customize.hint.attach"] = "Acoplar"
L["customize.hint.controller"] = "Modo con Mando esta Activo."
L["customize.hint.cursor"] = "Cursor"
L["customize.hint.cycle"] = "Mover de Ranura"
L["customize.hint.delete"] = "Borrar"
L["customize.hint.deselect"] = "Deseleccionar"
L["customize.hint.expand"] = "Expandir"
L["customize.hint.export"] = "Exportar"
L["customize.hint.favorite"] = "Favorito"
L["customize.hint.import"] = "Importar"
L["customize.hint.install"] = "Instalar"
L["customize.hint.last"] = "Ultima Ranura"
L["customize.hint.lastmode"] = "ltimo Modo"
L["customize.hint.nextmode"] = "Siguiente Modo"
L["customize.hint.open"] = "Abrir"
L["customize.hint.pan"] = "Paneo"
L["customize.hint.quicksave"] = "Guardado Rapido"
L["customize.hint.randomize"] = "Adjuntar aleatorio"
L["customize.hint.recalculate"] = "Recalcular"
L["customize.hint.recenter"] = "Recentrar"
L["customize.hint.rotate"] = "Rotar"
L["customize.hint.save"] = "Guardar"
L["customize.hint.select"] = "Seleccionar"
L["customize.hint.unattach"] = "Desacoplar"
L["customize.hint.unfavorite"] = "Remover favorito"
L["customize.hint.zoom"] = "Zoom"

L["customize.trivia.description"] = "Descripcin"

L["customize.stats.explain.firepower"] = "El potencial de dao a quemarropa."
L["customize.stats.explain.rof"] = "La cadencia de fuego del arma."
L["customize.stats.explain.cyclic"] = "La cadencia de tiro cclica del arma. Ignora factores como el retardo de la rfaga o los requisitos de recarga."
L["customize.stats.explain.capacity"] = "Cunta municin puede contener el arma en el cargador + recmara."
L["customize.stats.explain.range"] = "Alcance en el que el arma inflige el dao mnimo."
L["customize.stats.explain.precision"] = "La precisin del arma. Se mide en minutos de angulo (MOA)."
L["customize.stats.explain.muzzlevelocity"] = "La velocidad de salida de las balas disparadas con esta arma."
L["customize.stats.explain.ammo"] = "El tipo de municin que utiliza esta arma."
L["customize.stats.explain.penetration"] = "Cantidad de material que puede penetrar esta pistola."
L["customize.stats.explain.ricochet"] = "Mxima probabilidad de que las balas de esta arma reboten."
L["customize.stats.explain.armorpiercing"] = "Cantidad de dao de esta arma que ignora por completo la mayora de las resistencias al dao."
L["customize.stats.explain.explosive"] = "Cantidad de dao explosivo que har esta arma."
L["customize.stats.explain.speed"] = "Velocidad a la que puedes moverte mientras usas esta arma."
L["customize.stats.explain.aimtime"] = "El tiempo que se tarda en apuntar con la mira desde la cadera."
L["customize.stats.explain.sprinttofire"] = "El tiempo que se tarda en salir del sprint y empezar a disparar."
L["customize.stats.explain.firemodes"] = "A qu modos de disparo tiene acceso esta arma."
L["customize.stats.explain.burstdelay"] = "Tiempo que transcurre tras disparar una rfaga antes de que el arma pueda volver a disparar."
L["customize.stats.explain.triggerdelay"] = "Retraso entre apretar el gatillo y disparar."
L["customize.stats.explain.noise"] = "Lo ruidosos que son los disparos del arma."
L["customize.stats.explain.sway"] = "Cantidad de estabilidad aplicada al arma."
L["customize.stats.explain.freeaim"] = "ngulo mximo de puntera libre. Cuanto ms bajo, mejor."
L["customize.stats.explain.supplylimit"] = "Cantidad de municin que el arma puede recibir de las fuentes de municin ARC9."

L["customize.bench.dummy"] = "PRUEBA BALSTICA CON MANIQU"
L["customize.bench.effect"] = "EFECTO A DISTANCIA"
L["customize.bench.ballistics"] = "EVALUACIN DEL RENDIMIENTO BALSTICO TERMINAL"
L["customize.bench.precision"] = "ENSAYO MECNICO DE PRECISIN"

L["folder.back"] = "Atras"
L["folder.deselect"] = "Deseleccionar"
L["folder.favorites"] = "Favoritos"
L["folder.select"] = "Seleccionar"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Habilita"
L["autostat.disable.pre"] = "Deshabilita"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Tiemp. al Apuntar con la Mira"
L["autostat.alwaysphysbullet"] = "Siempre Balas Fsicas"
L["autostat.ammopershot"] = "Municion por Disparo"
L["autostat.armdamage"] = "Dao a Brazo"
L["autostat.armorpiercing"] = "Penetracin de Armadura"
L["autostat.autoburst"] = "Disparo a Rfagas Automatico"
L["autostat.autoreload"] = "Recarga Pasiva"
L["autostat.bash"] = "Ataques Cuerpo a Cuerpo"
L["autostat.bashdamage"] = "Dao Cuerpo a Cuerpo"
L["autostat.bashlungerange"] = "Alcance de Estocada Cuerpo a Cuerpo"
L["autostat.bashrange"] = "Rango Cuerpo a Cuerpo"
L["autostat.bashspeed"] = "Velocidad cuerpo a cuerpo"
L["autostat.bipod"] = "Bipode"
L["autostat.bottomlessclip"] = "Cargador Sin Fondo"
L["autostat.breathholdtime"] = "Tiempo de Enfoque"
L["autostat.bulletguidance"] = "Rondas Guiadas"
L["autostat.bulletguidanceamount"] = "Factor de Guia"
L["autostat.canfireunderwater"] = "Disparar Bajo el Agua"
L["autostat.cantpeek"] = "Desactiva el Vistazo"
L["autostat.chambersize"] = "Capacidad de la Cmara"
L["autostat.chestdamage"] = "Dao al Torso"
L["autostat.clipsize"] = "Capacidad del Cargador"
L["autostat.cycletime"] = "Tiempo de Ciclo"
L["autostat.damagemax"] = "Dao a Corta Distancia"
L["autostat.damagemin"] = "Dao a Larga Distancia"
L["autostat.damagerand"] = "Variacin de Daos"
L["autostat.deploytime"] = "Tiempo de Desenfundar"
L["autostat.distance"] = "Distancia de la Bala"
L["autostat.entitymuzzlevelocity"] = "Velocidad del Proyectil"
L["autostat.explosiondamage"] = "Dao por Explosin"
L["autostat.explosionradius"] = "Radio de la Explosin"
L["autostat.fixtime"] = "Tiempo de Desatasco"
L["autostat.freeaimradius"] = "Radio de Vista Libre"
L["autostat.headshotdamage"] = "Dao a la Cabeza"
L["autostat.heatcapacity"] = "Capacidad de Calor"
L["autostat.heatdissipation"] = "Disipacin del Calor"
L["autostat.heatpershot"] = "Calor por Disparo"
L["autostat.hybridreload"] = "Recarga Individual Hibrida"
L["autostat.infiniteammo"] = "Municin Infinita"
L["autostat.legdamage"] = "Dao a Pierna"
L["autostat.malfunction"] = "Atasco"
L["autostat.malfunctionmeanshotstofail"] = "Media de Disparos para Fallo"
L["autostat.malfunctionwait"] = "Tiempo de Espera por Fallo"
L["autostat.manualaction"] = "Accin Manual"
L["autostat.manualactionchamber"] = "Disparos por Ciclo"
L["autostat.neverphysbullet"] = "Nunca Balas Fsicas"
L["autostat.noflash"] = "No Fogonazo"
L["autostat.num"] = "Conteo de Proyectiles"
L["autostat.overheat"] = "Sobrecalentamiento"
L["autostat.overheattime"] = "Tiempo de Reparacin por Sobrecalentamiento"
L["autostat.pelletspread"] = "Esparcin de perdigones"
L["autostat.penetration"] = "Penetracin de Material"
L["autostat.penetrationdelta"] = "Dao Tras Penetracion"
L["autostat.physbulletdrag"] = "Arrastre de Bala"
L["autostat.physbulletgravity"] = "Cada de Bala"
L["autostat.physbulletmuzzlevelocity"] = "Velocidad de Salida de la Bala"
L["autostat.postburstdelay"] = "Tiempo entre Rfagas"
L["autostat.pushbackforce"] = "Fuerza de Contragolpe"
L["autostat.rangemax"] = "Rango Mximo"
L["autostat.rangemin"] = "Rango Mnimo"
L["autostat.recoil"] = "Retroceso"
L["autostat.recoilautocontrol"] = "Tiempo de Reseteo del Retroceso"
L["autostat.recoildissipationrate"] = "Tasa de Disipacin del Retroceso"
L["autostat.recoilkick"] = "Retroceso Sentido"
L["autostat.recoilmodifiercap"] = "Mximo retroceso acumulado"
L["autostat.recoilpatterndrift"] = "Desviacin del Retroceso"
L["autostat.recoilpershot"] = "Retroceso por disparo"
L["autostat.recoilrandomside"] = "Propagacion del Retroceso Horizontal"
L["autostat.recoilrandomup"] = "Propagacion del Retroceso Vertical"
L["autostat.recoilresettime"] = "Recoil Reset Time"
L["autostat.recoilside"] = "Retroceso Horizontal"
L["autostat.recoilup"] = "Retroceso Vertical"
L["autostat.reloadtime"] = "Tiempo de Recarga"
L["autostat.ricochetanglemax"] = "ngulo de Rebote"
L["autostat.ricochetchance"] = "Probablidad de Rebote"
L["autostat.rpm"] = "Disparos por Minuto"
L["autostat.runawayburst"] = "Rfaga Incontrolable"
L["autostat.secondarysupplylimit"] = "Municion Secundaria de Reserva"
L["autostat.shootvolume"] = "Volumen de Informe"
L["autostat.shootwhilesprint"] = "Disparar al Esprintar"
L["autostat.shotgunreload"] = "Recarga Individual"
L["autostat.speed"] = "Velocidad de Movimiento"
L["autostat.spread"] = "Precisin"
L["autostat.sprinttofiretime"] = "Tiempo de Sprint Hasta el Disparo"
L["autostat.stomachdamage"] = "Dao al Estomago"
L["autostat.supplylimit"] = "Cargadores de Reserva"
L["autostat.sway"] = "Estabilidad"
L["autostat.triggerdelay"] = "Tiempo de Retraso del Disparo"
L["autostat.triggerdelaytime"] = "Tiempo de Retardo de Gatillo"
L["autostat.visualrecoil"] = "Retroceso Visual"
L["autostat.visualrecoilpunch"] = "Golpe de Retroceso Visual"
L["autostat.visualrecoilroll"] = "Giro de Retroceso Visual"
L["autostat.visualrecoilside"] = "Retroceso Horizontal Visual"
L["autostat.visualrecoilup"] = "Retroceso Vertical Visual"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
L["autostat.secondary.bipod"] = "en Bpode"
L["autostat.secondary.crouch"] = "mientras est agachado"
L["autostat.secondary.empty"] = "en la ultima ronda del cargador"
L["autostat.secondary.evenreload"] = "cada recarga pareja"
L["autostat.secondary.evenshot"] = "cada disparo parejo"
L["autostat.secondary.first"] = "en el primer disparo"
L["autostat.secondary.firstshot"] = "en el primer disparo"
L["autostat.secondary.heated"] = "mientras Calentado"
L["autostat.secondary.hipfire"] = "en Hipfire"
L["autostat.secondary.hot"] = "del Calor"
L["autostat.secondary.last"] = "en la ultima ronda del cargador"
L["autostat.secondary.lastshot"] = "en la ultima ronda del cargador"
L["autostat.secondary.midair"] = "en el aire"
L["autostat.secondary.move"] = "mientras se mueve"
L["autostat.secondary.oddreload"] = "cada recarga rara"
L["autostat.secondary.oddshot"] = "cada disparo raro"
L["autostat.secondary.recoil"] = "del retroceso" --"Con Cada Disparo"
L["autostat.secondary.shooting"] = "mientras dispara"
L["autostat.secondary.sighted"] = "mientras Avistado"
L["autostat.secondary.sights"] = "en la mira"
L["autostat.secondary.silenced"] = "cuando est silenciado"
L["autostat.secondary.sprint"] = "al Esprintar"
L["autostat.secondary.true"] = "cuando Verdaderos Nombres est activo"
L["autostat.secondary.ubgl"] = "en UBGL"

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9 Lista negra de accesorios"
L["blacklist.desc"] = "Se bloquear el uso de los accesorios marcados aqu"
L["blacklist.blisted"] = "MARCADO"
L["blacklist.all"] = "TODO"
L["blacklist.id"] = "ID"
L["blacklist.name"] = "NOMBRE"
L["blacklist.filter"] = "FILTRAR"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: ADDONS NO COMPATIBLES"
L["incompatible.line1"] = "Usted tiene algunos addons que se sabe que no funcionan con ARC9."
L["incompatible.line2"] = "Desactvelos o espere un comportamiento defectuoso."
L["incompatible.confirm"] = "Confirmar"
L["incompatible.wait"] = "Esperar {time}s"
L["incompatible.never"] = "No volver a advertirme."
L["incompatible.never.hover"] = "Ests completamente seguro de que entiendes las consecuencias?"
L["incompatible.never.confirm"] = "Ha elegido no volver a mostrar advertencias de incompatibilidad. Si encuentras errores o comportamientos rotos, es tu responsabilidad."

////////////////////// Warning panel
-- L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
-- L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
-- L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
-- L["badconf.confirm"] = "Acknowledge"
-- L["badconf.wait"] = "Wait {time}s"

-- L["badconf.directx.title"] = "Outdated DirectX version"
-- L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
-- L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

-- L["badconf.tickrate.title"] = "Too low server tickrate"
-- L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
-- L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

-- L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
-- L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
-- L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

-- L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
-- L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
-- L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

-- L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
-- L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

-- L["badconf.x64.title"] = " Slow 32-Bit branch Detected"
-- L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

-- Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

-- Google "gmod x64" to find a tutorial online.]]

-- L["badconf.multicore.title"] = " No Multicore Rendering commands"
-- L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

-- Solution: You need to put certain commands into autoexec.cfg

-- Google "gmod multicore" to find a tutorial online.

-- All commands that can increase performance:
-- gmod_mcore_test 1
-- mat_queue_mode 2
-- cl_threaded_bone_setup 1
-- cl_threaded_client_leaf_system 1
-- r_threaded_client_shadow_manager 1
-- r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Accesorios"
L["customize.presets.back"] = "Atras"
L["customize.presets.cancel"] = "Cancelar"
L["customize.presets.code"] = "Codigo de Preajuste (Copiado a Portapapeles)"
L["customize.presets.default"] = "Por Defecto"
L["customize.presets.default.long"] = "Preajuste Por Defecto"
L["customize.presets.dumb"] = "Eres tonto"
L["customize.presets.import"] = "Importar"
L["customize.presets.invalid"] = "Cadena no valida!"
L["customize.presets.new"] = "Nuevo Nombre de Preajuste"
L["customize.presets.paste"] = "Pega Codigo de Preajuste Aqui"
L["customize.presets.random"] = "Aleatorio"
L["customize.presets.save"] = "Guardar"
L["customize.presets.unnamed"] = "Sin Nombre"

L["customize.presets.deldef"] = "Ests seguro de que quieres borrar \"{name}\" preajuste por defecto?"
L["customize.presets.deldef2"] = "Tendras que resetear arma en ajustes de desarrollador para devolverla."
L["customize.presets.yes"] = "Si"

////////////////////// Tips
L["tips.arc-9"] = "Es ARC9, no ARC-9, no Arc9."
L["tips.blacklist"] = "Puede poner los archivos adjuntos en una lista negra. Consulte la descripcin del workshop de ARC9 para obtener ms informacin."
L["tips.bugs"] = "Informa de los errores en el servidor oficial de Discord o, mejor an, abre una propuesta en Github."
L["tips.custombinds"] = "Las combinaciones de teclas ARC9 se pueden sustituir por vinculaciones personalizadas. Empieza a escribir +arc9_ para encontrar las vinculaciones disponibles."
L["tips.cyberdemon"] = "Para matar al terrorista, disprale hasta que est muerto."
L["tips.description"] = "Le aconsejamos que lea las descripciones de los addons antes de hacer comentarios."
L["tips.development"] = "Quieres desarrollar contenido para ARC9? El servidor oficial de Discord tiene muchos recursos para ayudarte."
L["tips.discord"] = "nete a Diamond Doves en Discord! El enlace est en la descripcin ARC9 y en la parte superior de la configuracin."
L["tips.external"] = "Si utiliza la versin Github de ARC9, asegrese de actualizarla con frecuencia."
L["tips.hints"] = "Mantn encendido el HUD de ARC9 para ver las pistas de controles."
L["tips.lean"] = "Para inclinarse manualmente, vincule las teclas a +alt1 y +alt2."
L["tips.love"] = "No dudes en decir a los desarrolladores que aprecias su trabajo. Nos ayuda mucho a seguir adelante."
L["tips.m9k"] = "Hecha un vistazo a las armas M9K!."
L["tips.official"] = "Descargue ARC9 nicamente de fuentes oficiales. Las cargas de terceros pueden ser maliciosas o estar desactualizadas."
L["tips.presets"] = "Comparte tus preajustes favoritos con tus amigos exportndolos."
L["tips.settings"] = "Puede desactivar estos consejos, y muchos ms, en los ajustes de ARC9. Haga clic en el botn de la esquina superior izquierda."
L["tips.tips"] = "Los consejos tienen un orden fijo. Siga leyendo y acabar vindolos todos."
L["tips.tolerance"] = "Todas las bases de armas funcionan bien juntas. No hay necesidad de favoritismos."

////////////////////// Other
L["atts.favourites"] = "Favoritos"
L["atts.filter"] = "Filtrar"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "Ajustes ARC9"
L["settings.desc"] = "Descripcin"

L["settings.default_convar"] = "Valor predeterminado"
-- L["settings.convar_server"] = "Server variable"
-- L["settings.convar_client"] = "Client variable"

////////////////////// General
L["settings.tabname.general"] = "General"

L["settings.general.client"] = "Cliente"
L["settings.language_id.title"] = "Idioma"
L["settings.language_id.desc"] = "Paquete de idiomas a utilizar para ARC9."
L["settings.truenames.title"] = "Nombres reales"
L["settings.truenames.desc"] = "Establece si usar los nombres reales de las armas o nombres ficticios hechos por los desarrolladores. No todas las armas lo utilizan.\n\nLa configuracin del servidor puede anular esta preferencia."
L["settings.resetsettings.cl.title"] = "Restablecer todos los ajustes del CLIENTE"

L["settings.general.server"] = "Servidor"
L["settings.truenames_default.title"] = "Nombres reales por defecto"
L["settings.truenames_default.desc"] = "Establece el modo de nombres reales por defecto en el servidor. Todos los jugadores que utilicen \"Default\" en preferencia lo utilizarn."
L["settings.truenames_enforced.title"] = "Nombres reales por defecto forcado"
L["settings.truenames_enforced.desc"] = "Establecer para obligar a todos los jugadores a utilizar la configuracin del servidor para los nombres verdaderos."

L["settings.resetsettings.sv.title"] = "Restablecer todos los ajustes del SERVIDOR"

L["settings.reset"] = "Restablecer!"

////////////////////// Performance
L["settings.tabname.performance"] = "Rendimiento"

L["settings.performance.important"] = "Importante"
L["settings.cheapscopes.title"] = "Miras Baratas"
L["settings.cheapscopes.desc"] = "Una implementacin barata de miras RT mediante el zoom de toda la vista para apuntar, en lugar de renderizar el mundo de nuevo en una mira. Aumenta significativamente el rendimiento en mapas grandes."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) es un sistema que permite que la mayora de las armas se muestren detalladas e igual que en primera persona, posiciones de manos, recarga y animaciones de disparo en tercera persona.\n\nConfigralo en la pestaa Visuales."
L["settings.allflash.title"] = "Todas las Linternas"
L["settings.allflash.desc"] = "Renderiza completamente todas las linternas de otros jugadores.\n\nMuy caro en los servidores."

L["settings.performance.blur.title"] = "Difuminacion"
L["settings.cust_blur.title"] = "Fondo de personalizacin"
L["settings.cust_blur.desc"] = "Difumina Fondo de personalizacin."
L["settings.fx_reloadblur.title"] = "Mientras Recarga"
L["settings.fx_reloadblur.desc"] = "Difumina el Mundo Mientras Recarga."
L["settings.fx_animblur.title"] = "Mientras se Prepara"
L["settings.fx_animblur.desc"] = "Difumina el mundo mientras despliegas un arma por primera vez."
L["settings.fx_rtblur.title"] = "En miras telescpicas"
L["settings.fx_rtblur.desc"] = "Difumina el mundo mientras utilizas un miras telescpicas."
L["settings.fx_adsblur.title"] = "En miras normales"
L["settings.fx_adsblur.desc"] = "Difumina el arma mientras apuntas con miras de hierro u hologrficas."
L["settings.fx_rtvm.title"] = "Renderizar Arma a travs de Miras RT"
L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenderiza el arma y sus accesorios a travs de miras RT. Requiere que \"Miras Baratas\" se desactiven.\nReduce significativamente el rendimiento."
L["settings.fx_rtblur.title2"] = "Desenfoque detrs de los visores"

L["settings.performance.shelleject.title"] = "Expulsin del proyectil"
L["settings.eject_fx.title"] = "Efectos de Humo"
L["settings.eject_fx.desc"] = "Producir efectos de humo a partir de los casquillos expulsados, cuando el arma admita esta funcin."
L["settings.eject_time.title"] = "Tiemp. Vida"
L["settings.eject_time.desc"] = "Permiten que los casquillos permanezcan ms tiempo en el mundo. Puede afectar al rendimiento."

L["settings.performance.fx.title"] = "Efectos"
L["settings.muzzle_light.title"] = "Fogonazo"
L["settings.muzzle_light.desc"] = "Habilita la luz emitida por los fogonazos al disparar un arma."
L["settings.muzzle_others.title"] = "Otros efectos de fogonazos"
L["settings.muzzle_others.desc"] = "Activa los efectos de boca de las armas de otros jugadores."

////////////////////// Optics
L["settings.tabname.optics"] = "Miras"

L["settings.optics.control"] = "Control"
L["settings.optics.sensmult.title"] = "Multiplicar sensibilidad ADS"
L["settings.optics.sensmult.desc"] = "Multiplique la sensibilidad de la mirada por esta cantidad al apuntar.\nCuanto menor sea el valor, menor ser la sensibilidad.\ntil cuando se utilizan mandos, o si el usuario slo desea una menor sensibilidad de puntera."
L["settings.optics.compensate_sens.title"] = "Compensar Sensibilidad"
L["settings.optics.compensate_sens.desc"] = "Compensar sensibilidad por ampliados."
L["settings.optics.toggleads.title"] = "Alternar ADS"
L["settings.optics.toggleads.desc"] = "Al apuntar se alternar la mira."

L["settings.optics.dtap_sights.title"] = "Doble Toque para Cambiar las Miras"
L["settings.optics.dtap_sights.desc"] = "Permite Pulsar Dos Veces la Tecla USAR para Cambiar de Mira."

L["settings.optics.color"] = "Color"
L["settings.optics.reflex.title"] = "Miras Hologrficas"
L["settings.optics.reflex.desc"] = "Color a utilizar para miras hologrficas.\n\nNo todas las miras admiten esta funcin."
L["settings.optics.scope.title"] = "Visores"
L["settings.optics.scope.desc"] = "Color a utilizar para visores ampliados.\n\nNo todas las miras admiten esta funcin."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Punto de Mira"

L["settings.crosshair.crosshair"] = "Punto de Mira"
L["settings.crosshair.cross_enable.title"] = "Habilitar Punto de Mira"
L["settings.crosshair.cross_enable.desc"] = "Habilitar el punto de mira. Algunas armas no permiten utilizar el punto de mira."
L["settings.crosshair.cross.title"] = "Color de Punto de Mira"
L["settings.crosshair.cross.desc"] = "El color de tu punto de mira."
L["settings.crosshair.cross_size_mult.title"] = "Tamao de Punto de Mira"
L["settings.crosshair.cross_size_mult.desc"] = "Multiplica el tamao de tu punto de mira"
L["settings.crosshair.cross_size_dot.title"] = "Tamao de Punto"
L["settings.crosshair.cross_size_dot.desc"] = "Multiplica el tamao del punto medio"
L["settings.crosshair.cross_size_prong.title"] = "Tamao de Puntas"
L["settings.crosshair.cross_size_prong.desc"] = "Multiplica el tamao de las puntas exteriores."
L["settings.crosshair.crosshair_static.title"] = "Punto de Mira Esttico"
L["settings.crosshair.crosshair_static.desc"] = "Activa el punto de mira esttica, que no se mueve al disparar."
L["settings.crosshair.crosshair_force.title"] = "Forzar Punto de Mira"
L["settings.crosshair.crosshair_force.desc"] = "Fuerza el punto de mira incluso en armas que no quieren que la veas.\n\nConfiguracion del servidor."
L["settings.crosshair.crosshair_target.title"] = "Punto de mira rojo en el blanco"
L["settings.crosshair.crosshair_target.desc"] = "Haz que la retcula sea roja al apuntar a un objetivo.\nTambin activa el asistente de puntera si est activado."
L["settings.crosshair.crosshair_peeking.title"] = "Mostrar la retcula al dar vistazo"
L["settings.crosshair.crosshair_peeking.desc"] = "Muestra la retcula al apuntar y utilizar la funcin de vistazo."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Customizacin"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "Tamao del HUD"
L["settings.hud_cust.hud_scale.desc"] = "Multiplicador de escala para el HUD de ARC9."
L["settings.hud_cust.hud_deadzonex.title"] = "Anchura de zona muerta del HUD"
L["settings.hud_cust.hud_deadzonex.desc"] = "\"Zona Muerta\" Horizontal para el men de personalizacin y el panel HUD.\ntil para monitores ultrawide."
L["settings.hud_cust.hud_color.title"] = "Color del HUD"
L["settings.hud_cust.hud_color.desc"] = "Color de realce para el HUD.\nEl color de acento."
L["settings.hud_cust.hud_holiday.title"] = "Temas Festivos"
L["settings.hud_cust.hud_holiday.desc"] = "Temas que se activan durante determinadas fiestas.\nAnular el color de resaltado"
L["settings.hud_cust.hud_darkmode.title"] = "Tema Oscuro"
L["settings.hud_cust.hud_darkmode.desc"] = "Activa los colores oscuros en el HUD en lugar del gris claro y desactiva el efecto vieta en el fondo."
L["settings.hud_cust.cust_light.title"] = "Habilitar Luz"
L["settings.hud_cust.cust_light.desc"] = "Activa la iluminacin del arma en el men de personalizacin.\n\nLo mismo que el botn cerca del botn de configuracin."
L["settings.hud_cust.cust_light_brightness.title"] = "Brillo de Luz"
L["settings.hud_cust.cust_light_brightness.desc"] = "Cmo de brillante ser la luz del panel de personalizacin.\n\nPero no olvides encenderlo antes!"

L["settings.hud_cust.customization"] = "Customizacin"
L["settings.hud_cust.cust_hints.title"] = "Pistas"
L["settings.hud_cust.cust_hints.desc"] = "Habilita pistas en el menu de modificacion."
L["settings.hud_cust.cust_tips.title"] = "Consejos"
L["settings.hud_cust.cust_tips.desc"] = "Consejos sobre la base ARC9 cerca de pistas."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Salir Restablece la seleccin"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Al salir del men de personalizacin se restablece la seleccin de ranura activa."
L["settings.hud_cust.imperial.title"] = "Medida Imperial"
L["settings.hud_cust.imperial.desc"] = "Sustituye varios sistemas de medida por sus variantes imperiales.\nSlo afecta a la pantalla de personalizacin \"Estadsticas y balsticas\"."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "HUD"

L["settings.hud_game.lcd"] = "Panel LCD"
L["settings.hud_game.hud_arc9.title"] = "Habilitar HUD"
L["settings.hud_game.hud_arc9.desc"] = "Habilita HUD para armas ARC9."
L["settings.hud_game.hud_always.title"] = "En todas las armas"
L["settings.hud_game.hud_always.desc"] = "Habilita el HUD en todas las armas."
L["settings.hud_game.hud_compact.title"] = "Modo Compacto"
L["settings.hud_game.hud_compact.desc"] = "Aspecto compacto para el panel HUD."
L["settings.hud_game.hud_nohints.title"] = "Deshabilita Pistas"
L["settings.hud_game.hud_nohints.desc"] = "Deshabilita completamente las pistas. No aparecern en el HUD 3D ni en el HUD 2D."
L["settings.hud_game.hud_keephints.title"] = "Mantener Pistas"
L["settings.hud_game.hud_keephints.desc"] = "Mostrar las pistas de control ARC9 en la parte superior en el panel HUD."
L["settings.hud_game.hud_force_disable.title"] = "Forzar Desactivacin del HUD"
L["settings.hud_game.hud_force_disable.desc"] = "Desactivar HUD ARC9 para todos los jugadores. No afecta a las pistas."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Iconos del Killfeed"
L["settings.hud_game.killfeed_enable.desc"] = "Activar la generacin automtica de iconos de killfeed para armas ARC9."
L["settings.hud_game.killfeed_dynamic.title"] = "Actualizacion Dinamica"
L["settings.hud_game.killfeed_dynamic.desc"] = "Los iconos de Killfeed se regenerarn despus de cada muerte.\n\nDesactvalo si quieres conseguir esos 0,1 fps."
L["settings.hud_game.killfeed_colour.title"] = "Iconos a todo color"
L["settings.hud_game.killfeed_colour.desc"] = "Los iconos generados dinmicamente estn totalmente coloreados."

L["settings.hud_game.breath"] = "Respiracin"
L["settings.hud_game.breath_hud.title"] = "HUD de respiracin"
L["settings.hud_game.breath_hud.desc"] = "Muestra una barra que indica el aliento que te queda mientras estabilizas el arma en la mira."
L["settings.hud_game.breath_pp.title"] = "Post-procesado de respiracin"
L["settings.hud_game.breath_pp.desc"] = "Mantener la respiracin tambin aadir efectos de post-procesado a tu pantalla."
L["settings.hud_game.breath_sfx.title"] = "SFX de respiracin"
L["settings.hud_game.breath_sfx.desc"] = "Si mantienes la respiracin, se reproducirn los efectos de sonido asociados."

L["settings.hud_game.centerhint"] = "Consejos"
L["settings.hud_game.centerhint_reload.title"] = "Mostrar Consejo de Recarga"
L["settings.hud_game.centerhint_reload.desc"] = "Muestra un aviso de recarga cuando te quede poca municin."
L["settings.hud_game.centerhint_reload_percent.title"] = "Porcentaje de Cargador"
L["settings.hud_game.centerhint_reload_percent.desc"] = "Muestra un aviso de recarga cuando el cargador actual est en este valor porcentual."
L["settings.hud_game.centerhint_bipod.title"] = "Mostrar Alternar Bpode"
L["settings.hud_game.centerhint_bipod.desc"] = "Mostrar un aviso cuando el bpode se puede conmutar."
L["settings.hud_game.centerhint_jammed.title"] = "Mostrar Consejo de Atascamiento"
L["settings.hud_game.centerhint_jammed.desc"] = "Muestra un aviso cuando tu arma se atasca."

L["settings.hud_game.centerhint_firemode.title"] = "Mostrar Consejo de Modo de Fuego"
L["settings.hud_game.centerhint_firemode.desc"] = "Muestra un aviso cuando cambias de modo de disparo o activas el seguro."
L["settings.hud_game.centerhint_firemode_time.title"] = "Mostrar Tiempo de Modo de Fuego"
L["settings.hud_game.centerhint_firemode_time.desc"] = "Cunto tiempo debe mostrarse el modo de disparo."

-- L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
-- L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = "Tipo de Glifo"

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "Cambia la familia de glifos a utilizar.\nEsto afecta los consejos del HUD."

L["settings.hud_game.hud_glyph_type_cust.title"] = "Men de Personalizacin"
L["settings.hud_game.hud_glyph_type_cust.desc"] = "Cambia la familia de glifos a utilizar.\nEsto afecta a los consejos del men de personalizacin.\nLos cambios se aplicarn la prxima vez que se abra el men de personalizacin."

L["settings.hud_game.hud_glyph_light"] = "Claro"
L["settings.hud_game.hud_glyph_dark"] = "Oscuro"
L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs"

L["settings.npc.weapons"] = "Armas de NPCs"
L["settings.npc.npc_equality.title"] = "Igualdad de daos"
L["settings.npc.npc_equality.desc"] = "Los NPCs hacen tanto dao como los jugadores.\n\nEsto es una variable del servidor."
L["settings.npc.npc_spread.title"] = "Precisin de NPCs"
L["settings.npc.npc_spread.desc"] = "Multiplicador de la imprecisin de los NPCs al disparar."
L["settings.npc.npc_atts.title"] = "Dar Accesorios"
L["settings.npc.npc_atts.desc"] = "Las armas ARC9 creadas o entregadas reciben un conjunto aleatorio de accesorios.\n\nEsto es una variable del servidor."
L["settings.npc.npc_autoreplace.title"] = "Reemplazar armas de NPCs"
L["settings.npc.npc_autoreplace.desc"] = "Reemplazar armas NPCs con armas ARC9 elegidas al azar.\n\nEsta es una variable del servidor."
L["settings.npc.replace_spawned.title"] = "Sustituir armas terrestres"
L["settings.npc.replace_spawned.desc"] = "Reemplazar armas de HL2 del mapa/generadas con armas ARC9 elegidos al azar.\n\nEsta es una variable de servidor."
L["settings.npc.npc_give_weapons.title"] = "Jugadores pueden dar armas"
L["settings.npc.npc_give_weapons.desc"] = "Los jugadores pueden pulsar E en los NPCs para darles su arma.\n\nEsta es una variable del servidor."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gameplay"

L["settings.gameplay.controls"] = "Controles"
L["settings.gameplay.toggleads.title"] = "Habilitar ADS"
L["settings.gameplay.toggleads.desc"] = "Al apuntar se alternarn las miras."
L["settings.gameplay.autolean.title"] = "Inclinacion Automatica"
L["settings.gameplay.autolean.desc"] = "La puntera intentar inclinarse automticamente si es posible."
L["settings.gameplay.autoreload.title"] = "Recarga Automatica"
L["settings.gameplay.autoreload.desc"] = "Las armas de ARC9 vacas se recargarn automticamente."
L["settings.gameplay.togglelean.title"] = "Alternar Inclinacin"
L["settings.gameplay.togglelean.desc"] = "Al pulsar las teclas de inclinacin se alternar la inclinacin en lugar de tener que mantenerlas pulsadas.\n\nFunciona mal en conjunto a autoinclinacion. Si se utiliza la alternacion de inclinacin, debe desactivar autoinclinacion"
L["settings.gameplay.togglepeek.title"] = "Alternar Vistazo"
L["settings.gameplay.togglepeek.desc"] = "Al pulsar la tecla de vistazo se activar el vistazo en lugar de tener que mantenerla pulsada."
L["settings.gameplay.togglepeek_reset.title"] = "Restablecer estado de Vistazo despus de apuntar"
L["settings.gameplay.togglepeek_reset.desc"] = "(Slo si Alternar Vistazo est activado)\nEl estado de vistazo no se conservar al salir de las miras de puntera."
L["settings.gameplay.togglebreath.title"] = "Alternar contener la respiracin"
L["settings.gameplay.togglebreath.desc"] = "Al pulsar la tecla Contener la respiracin se activar Contener la respiracin en lugar de tener que mantenerla pulsada."

L["settings.gameplay.mechanics"] = "Mecnicas de Juego"
L["settings.gameplay.infinite_ammo.title"] = "Municin Infinita"
L["settings.gameplay.infinite_ammo.desc"] = "Las armas tienen municin infinita.\n\nEsta es una variable del servidor."
L["settings.gameplay.realrecoil.title"] = "Retroceso Visual Fisico"
L["settings.gameplay.realrecoil.desc"] = "Las armas configuradas para esta funcin experimentan una elevacin fsica de la boca del can, lo que significa que dispararn donde lo muestre su modelo de vista y no en el centro de la pantalla. Esto es muy importante para el equilibrio de algunos paquetes de armas.\n\nEsta es una variable del servidor."
L["settings.gameplay.lean.title"] = "Inclinacion"
L["settings.gameplay.lean.desc"] = "Si los jugadores pueden inclinarse con +alt1 y +alt2, incluyendo inclinacin automtica.\n\nEsta es una variable del servidor."
L["settings.gameplay.mod_sway.title"] = "Estabilidad"
L["settings.gameplay.mod_sway.desc"] = "Las armas tendrn estabilidad, si estn configuradas para usarlo.\n\nEsta es una variable del servidor."
L["settings.gameplay.mod_freeaim.title"] = "Vista Libre"
L["settings.gameplay.mod_freeaim.desc"] = "Las armas tendrn puntera libre, y no siempre dispararn en el centro de la pantalla.\n\nEsta es una variable del servidor."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Cancelacin del dao corporal"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "Anula el multiplicador de dao corporal por defecto. Slo desactivar si se utiliza otro mod que proporciona este tipo de funcionalidad.\ne.g. Mods que cambian los multiplicadores de las extremidades por defecto.\n\nEsta es una variable de servidor."
L["settings.gameplay.breath_slowmo.title"] = "Respiracin Slow-Mo"
L["settings.gameplay.breath_slowmo.desc"] = "Contener la respiracin ralentiza el tiempo.\n\nNo disponible en multijugador."
L["settings.gameplay.manualbolt.title"] = "Ciclado Manual"
L["settings.gameplay.manualbolt.desc"] = "Las armas de cerrojo o bombeo configuradas para esta funcin slo se cerrojarn cuando se pulse R, y no cuando se suelte la tecla de ataque."
L["settings.gameplay.never_ready.title"] = "Anims \"No Preparado\""
L["settings.gameplay.never_ready.desc"] = "Deshabilitar animaciones de preparacion al desplegar arma."
L["settings.gameplay.recoilshake.title"] = "Sacudida FOV de retroceso"
L["settings.gameplay.recoilshake.desc"] = "Sacude el campo de visin al disparar"
L["settings.gameplay.equipment_generate_ammo.title"] = "Tipos de municin nicos para equipamiento"
L["settings.gameplay.equipment_generate_ammo.desc"] = "Hay un lmite de 255 tipos de municin, y desactivar esta opcin puede ayudar a solucionar algunos problemas si tienes muchos addons.\n\nEsta es una variable del servidor.\n\nRequiere reinicio."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = "Municin de reserva por defecto"
L["settings.gameplay.mult_defaultammo.desc"] = "Cuntos cargadores/granadas/equipos se dan al jugador cuando coge el arma por primera vez?\n\nEsta es una variable del servidor."
L["settings.gameplay.nearwall.title"] = "Cerca de la pared"
L["settings.gameplay.nearwall.desc"] = "No permite disparar el arma cuando se est demasiado cerca de la pared o cualquier obstculo."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuales"

L["settings.visuals.viewmodel"] = "Modelo de 1ra Persona"
L["settings.visuals.vm_bobstyle.title"] = "Estilo de Balanceo"
L["settings.visuals.vm_bobstyle.desc"] = "Seleccione diferentes estilos de balanceo, al gusto de los diferentes miembros del equipo ARC9 (y valve software)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Aade FOV (CAMPO DE VISION) al modelo de 1ra persona. Aumenta o disminuye el modelo. Uso responsable."
L["settings.visuals.vm_addx.title"] = "Agregar X"
L["settings.visuals.vm_addx.desc"] = "Desplaza el modelo a la derecha o a la izquierda."
L["settings.visuals.vm_addy.title"] = "Agregar Y"
L["settings.visuals.vm_addy.desc"] = "Desplaza el modelo hacia delante y hacia atrs."
L["settings.visuals.vm_addz.title"] = "Agregar Z"
L["settings.visuals.vm_addz.desc"] = "Desplaza el modelo arriba y abajo."

L["settings.visuals.cambob"] = "Balanceo de Vista"
L["settings.visuals.vm_cambob.title"] = "Balanceo al Esprintar"
L["settings.visuals.vm_cambob.desc"] = "Hace que tu cmara se mueva cuando esprintas"
L["settings.visuals.vm_cambobwalk.title"] = "Balanceo de Vista al Caminar"
L["settings.visuals.vm_cambobwalk.desc"] = "Hace que tu cmara se mueva ligeramente cuando caminas (requiere balanceo al esprintar)"
L["settings.visuals.vm_cambobintensity.title"] = "Intensidad"
L["settings.visuals.vm_cambobintensity.desc"] = "Qu tan intenso ser el balanceo"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "Habilitar TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) es un sistema que permite que la mayora de las armas se muestren detalladas e igual que en primera persona, posiciones de manos, recarga y animaciones de disparo en tercera persona."
L["settings.visuals.tpik_others.title"] = "TPIK de otros jugadores"
L["settings.visuals.tpik_others.desc"] = "Mostrar TPIK para otros jugadores que no seas t. Impacta negativamente en el rendimiento."
L["settings.visuals.tpik_framerate.title"] = "TPIK FPS"
L["settings.visuals.tpik_framerate.desc"] = "Velocidad de fotogramas mxima a la que puede funcionar TPIK. Establecer a 0 para ilimitado."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Balas Fisicas"

L["settings.bullets.bullets"] = "Balas Fsicas"
L["settings.bullets.bullet_physics.title"] = "Balas Fsicas"
L["settings.bullets.bullet_physics.desc"] = "Las armas que admitan esta caracterstica dispararn balas fsicas, que tienen cada, tiempo de recorrido y arrastre.\n\nEsta es una variable del servidor."
L["settings.bullets.bullet_gravity.title"] = "Gravedad"
L["settings.bullets.bullet_gravity.desc"] = "Multiplicador para la gravedad de la bala.\n\nEsta es una variable del servidor."
L["settings.bullets.bullet_drag.title"] = "Arrastre"
L["settings.bullets.bullet_drag.desc"] = "Multiplicador para el arrastre de balas.\n\nEsta es una variable del servidor."
L["settings.bullets.ricochet.title"] = "Rebote"
L["settings.bullets.ricochet.desc"] = "Las balas disparadas con armas seleccionadas a veces pueden rebotar en las superficies y seguir viajando y causando dao.\n\nEsta es una variable del servidor."
L["settings.bullets.mod_penetration.title"] = "Penetracion"
L["settings.bullets.mod_penetration.desc"] = "Las balas disparadas desde armas seleccionadas pueden penetrar superficies e infligir dao a lo que haya al otro lado.\n\nEsta es una variable del servidor."
L["settings.bullets.bullet_lifetime.title"] = "Tiempo De Vida"
L["settings.bullets.bullet_lifetime.desc"] = "Tiempo en segundos tras el cual se borrar una bala.\n\nEsta es una variable del servidor."
L["settings.bullets.bullet_imaginary.title"] = "Balas Imaginarias"
L["settings.bullets.bullet_imaginary.desc"] = "Las balas parecern viajar hacia la skybox, ms all de los lmites del mapa."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Accesorios"

L["settings.attachments.customization"] = "Customizacin"
L["settings.attachments.atts_nocustomize.title"] = "Deshabilitar Customizacin"
L["settings.attachments.atts_nocustomize.desc"] = "Deshabilita toda customizacin a travs del men.\n\nEsta es una variable del servidor."
L["settings.attachments.atts_max.title"] = "Accesorios Mx."
L["settings.attachments.atts_max.desc"] = "El nmero mximo de accesorios que se pueden poner en un arma, incluidos los accesorios cosmticos.\n\nEsta es una variable del servidor."
L["settings.attachments.autosave.title"] = "Autoguardado"
L["settings.attachments.autosave.desc"] = "Tus ltimas opciones de customizacin del arma se guardarn y se aplicarn automticamente la prxima vez que aparezca esa arma."
L["settings.attachments.blacklist.title"] = "Men Lista negra"
L["settings.attachments.blacklist.open"] = "Abrir"

L["settings.attachments.inventory"] = "Inventario"
L["settings.attachments.free_atts.title"] = "Accesorios Gratis"
L["settings.attachments.free_atts.desc"] = "Los archivos adjuntos se pueden utilizar sin ser recogidos primero.\n\nEsta es una variable del servidor."
L["settings.attachments.atts_lock.title"] = "Uno Para Todos"
L["settings.attachments.atts_lock.desc"] = "Recoger una instancia de un accesorio te permite usarlo infinitas veces en todas tus armas.\n\nEsta es una variable del servidor."
L["settings.attachments.atts_loseondie.title"] = "Perder En Muerte"
L["settings.attachments.atts_loseondie.desc"] = "Tu inventario de accesorios se perder cuando mueras.\n\nEsta es una variable del servidor."
L["settings.attachments.atts_generateentities.title"] = "Generar Entidades"
L["settings.attachments.atts_generateentities.desc"] = "Genera entidades que pueden ser engendradas, permitindote recoger accesorios cuando los accesorios gratis estn desactivados.\n\nPuede aumentar el tiempo de carga.\n\nEsta es una variable del servidor."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modificadores"

L["settings.modifiers.quick.title"] = "Modificadores rpidos de estadsticas"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Dao"
L["settings.mod_spread.title"] = "Precisin"
L["settings.mod_recoil.title"] = "Retroceso"
L["settings.mod_visualrecoil.title"] = "Retroceso Visual"
L["settings.mod_adstime.title"] = "Tiempo para apuntar con mira"
L["settings.mod_sprinttime.title"] = "Tiempo de Esprint a Disparo"
L["settings.mod_damagerand.title"] = "Variacin de daos"
L["settings.mod_muzzlevelocity.title"] = "Velocidad de salida"
L["settings.mod_rpm.title"] = "DPM"
L["settings.mod_headshotdamage.title"] = "Dao por tiro a cabeza"
L["settings.mod_malfunction.title"] = "Probabilidad de fallo"

////////////////////// Controller
L["settings.tabname.controller"] = "Mando"

L["settings.controller.misc"] = "Varios"
L["settings.controller.misc.desc"] = "Debera haber un botn que abra el panel con la configuracin avanzada del controlador, pero por ahora est en spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Glifos del mando"
L["settings.controller.controller.desc"] = "Habilitar glifos personalizados compatibles con el mando, mostrando los botones del controlador en lugar de las teclas predeterminadas."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Configuracion avanzada"
L["settings.controller.controller_config.content"] = "Abrir panel"
L["settings.controller.controller_config.desc"] = "Abra el panel de configuracin avanzada del mando."

L["settings.controller.glyphs.title"] = "Tipo de Glifo"
L["settings.controller.glyphs.desc"] = "Cambia la familia de glifos a utilizar.\nConfigurar glifos en \"Menu de Spawn\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "Asistente de Apuntado"
L["settings.tabname.aimassist.desc"] = "Puedes activar la asistencia para apuntar si tienes problemas para mantener la puntera en el blanco o si prefieres no esforzarte en disparar."

L["settings.aimassist.enable.title"] = "Habilitar Asistencia de Apuntado"
L["settings.aimassist.enable.desc"] = "Activa una funcin de ayuda a la puntera que ralentiza la sensibilidad al apuntar sobre un objetivo vlido.\n\nEsta es una variable del servidor.\n\nTambin requiere que Asistente de Apuntado est activado en CLIENTE."

L["settings.aimassist.enable_general.desc"] = "Activa una funcin de ayuda a la puntera que desplaza tu puntera hacia un objetivo cuando apuntas cerca de l.\n\nConfigrelo en la pestaa de \"Asistente de Apuntado\"."

L["settings.aimassist.enable_client.desc"] = "Activa una funcin de ayuda a la puntera que ralentiza la sensibilidad al apuntar sobre un objetivo vlido.\n\nTambin requiere que Asistente de Apuntado est activado en SERVIDOR."

L["settings.aimassist.intensity.title"] = "Intensidad"
L["settings.aimassist.intensity.desc"] = "Que tan intenso es el Asistente de Apuntado\n\nEsto es una variable del servidor."

L["settings.aimassist.cone.title"] = "Cono"
L["settings.aimassist.cone.desc"] = "Lo cerca o lejos que debe mirar hacia un objetivo antes de que se active el asistente de puntera.\n\nEsto es una variable del servidor."

L["settings.aimassist.head.title"] = "Fijacin en la cabeza"
L["settings.aimassist.head.desc"] = "Si el asistente de apuntado debe fijarse en la cabeza del objetivo en lugar de en su pecho.\n\nEsto es una variable del servidor."

L["settings.aimassist.sensmult.desc"] = "Multiplica la sensibilidad de la mirada por esta cantidad cuando se cierne sobre un objetivo vlido.\nCuanto menor sea el valor, menor ser la sensibilidad."

////////////////////// Asset Caching
L["settings.tabname.caching"] = "Almac. en cach"
L["settings.caching.title"] = "Almac. en cach"
L["settings.caching.desc"] = "Puede almacenar en cach algunos recursos ARC9 (guardarlos en memoria sin cargarlos mientras juega) para evitar tartamudeos y disfrutar de un juego ms cmodo!\n\nSeguramente deberas habilitar algunas cosas si tu gmod funciona en HDD."

L["settings.caching.precache_sounds_onfirsttake.title"] = "Al equipar: Almacena los sonidos de arma"
L["settings.caching.precache_sounds_onfirsttake.desc"] = "Almacena todos los sonidos del arma que acabas de recoger (excepto los sonidos de recarga).\n\nNo es nada impactante, ms bien ayuda a evitar tartamudeos al disparar."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "Al equipar: Almacena los accesorios"
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Almacena todos los modelos de accesorios ARC9 cuando cualquier arma ARC9 fue equipada por primera vez.\n\nCausa un gran congelamiento, especialmente cuando tienes muchas armas."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "Al equipar: Almacena los modelos de arma"
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Almacena en cach todos los modelos de armas ARC9 cuando cualquier arma ARC9 se equipa por primera vez.\n\nCausa GRAN congelacin, especialmente cuando tienes muchas armas."

L["settings.caching.precache_allsounds_onstartup.title"] = "Al inicio: Almacena los sonidos de arma"
L["settings.caching.precache_allsounds_onstartup.desc"] = "Almacena en cach todos los sonidos de todas las armas al iniciar el servidor. (excepto los sonidos de recarga).\n\nNo es tan impactante, pero de todos modos es mejor utilizar la primera opcin aqu."
L["settings.caching.precache_attsmodels_onstartup.title"] = "Al inicio: Almacena los accesorios"
L["settings.caching.precache_attsmodels_onstartup.desc"] = "Almacena en cach todos los modelos de accesorios ARC9 al iniciar el servidor.\n\nProvoca un aumento bastante grande del tiempo de carga, especialmente cuando tienes muchas armas."
L["settings.caching.precache_wepmodels_onstartup.title"] = "Al inicio: Almacena los modelos de arma"
L["settings.caching.precache_wepmodels_onstartup.desc"] = "Almacena en cach todos los modelos de armas ARC9 al iniciar el servidor.\n\nProvoca un aumento REALMENTE GRANDE del tiempo de carga, especialmente cuando tienes muchas armas."

L["settings.caching.precache_allsounds.title"] = "Todos los sonidos de armas"
L["settings.caching.precache_wepmodels.title"] = "Todos los modelos de armas"
L["settings.caching.precache_attsmodels.title"] = "Todos los modelos de accesorios"

L["settings.developer.cache"] = "Almacenar Cach"

////////////////////// Developer
L["settings.tabname.developer"] = "Desarollador"

L["settings.developer.developer"] = "Opciones de Desarollador"
L["settings.developer.dev_always_ready.title"] = "Siempre listo"
L["settings.developer.dev_always_ready.desc"] = "Reproduce siempre la animacin \"listo\"cuando despliegues un arma.\n\nEsta es una variable del servidor."
L["settings.developer.dev_benchgun.title"] = "Modelo de Arma Esttico"
L["settings.developer.dev_benchgun.desc"] = "Mantn el modelo arma donde est actualmente. Utilidad para ayudar a posicionar accesorios correctamente."
L["settings.developer.dev_crosshair.title"] = "Punto de Mira Dev"
L["settings.developer.dev_crosshair.desc"] = "Un punto de mira de aspecto gracioso que muestra el punto exacto de puntera y algunos nmeros tiles.\n\nEsta es una variable del servidor, y slo funciona para los administradores - no hagas trampas con esto!"
L["settings.developer.dev_show_affectors.title"] = "Mostrar Afectores"
L["settings.developer.dev_show_affectors.desc"] = "Muestra los afectores que se estn aplicando actualmente.\n\nRequiere \"Punto de Mira Dev\"."
L["settings.developer.dev_show_shield.title"] = "Mostrar Escudo"
L["settings.developer.dev_show_shield.desc"] = "Muestra el modelo del escudo del jugador."
L["settings.developer.dev_greenscreen.title"] = "Pantalla Verde"
L["settings.developer.dev_greenscreen.desc"] = "Mostrar un fondo de pantalla verde en el men de personalizacin para capturas de pantalla.\n\nSi estas utilizando HDR, no olvides de ajustar mat_bloom_scalefactor_scalar a 0!"
L["settings.developer.reloadatts.title"] = "Recargar Accesorios"
L["settings.developer.reloadlangs.title"] = "Recargar Idiomas"
L["settings.developer.dev_listmyatts.title"] = "Listar mis accesorios"
L["settings.developer.dev_listanims.title"] = "Lista de Animaciones"
L["settings.developer.dev_listbones.title"] = "Lista de Huesos"
L["settings.developer.dev_listbgs.title"] = "Lista de Bodygroups"
L["settings.developer.dev_listatts.title"] = "Lista de QCAttachments"
L["settings.developer.dev_listmats.title"] = "Lista de Materiales"
L["settings.developer.dev_export.title"] = "Exportar Cdigo"
L["settings.developer.dev_getjson.title"] = "JSON del Arma"

L["settings.developer.presets_clear.title"] = "Limpiar datos de armas"
L["settings.developer.presets_clear.desc"] = "Borrar preajustes, todos los iconos y preajustes por defecto para el arma que actualmente sostiene.\n\nAdvertencia: Si el men se abre sin un arma de ARC9 en las manos, se borrarn todos los preajustes e iconos de ARC9 existentes!"

L["settings.developer.clear"] = "Limpiar"
L["settings.developer.print"] = "Imprimir en Consola"
L["settings.developer.reload"] = "Recargar"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium permite una personalizacin adicional como mayor agradecimiento por apoyar econmicamente el addon."

L["premium.requires"] = "Requiere <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Suscribirse a <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Sin propietario</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Propiedad de</color>"

L["premium.help"] = "Qu es ARC9 Premium?"
L["premium.help.header"] = "Gua de ARC9 Premium"
L["premium.help.desc"] = "Crear addons lleva tiempo y recursos. ARC9 siempre ha estado disponible de forma gratuita, y seguir siendo as. Sin embargo, si desea apoyar financieramente la base, puede hacerlo, y ser recompensado por ello!"

L["premium.help.ownedbutnoaccess"] = "Ha comprado recientemente ARC9 Premium, pero no tiene acceso automtico a l? Ponte en contacto con nosotros en el servidor Discord de Diamond Doves para obtener ayuda.\nAsegrese de que puede proporcionar una prueba de compra antes de ponerse en contacto. Decir simplemente \"compro, ahora doy\" no es suficiente."

L["premium.content"] = "Incluido en <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Ranuras de personalizacin ilimitadas (aumentadas de 32)
- Ranuras de preajuste ilimitadas (en lugar de 10 por arma)
- Acceso a ajustes de supermodificador*.
- Acceso a un exclusivo modo Dark UI
- Posibilidad de colorear las retculas pticas, la IU y ms.
- Camuflajes exclusivos disponibles a travs de la base
- Canal de soporte exclusivo en Discord

*Requiere administrador si ests en un servidor
]]

L["premium.payment.month"] = [[
$%s
Adquiera ARC9 Premium durante 1 Mes.
]]

L["premium.payment.months"] = [[
$%s
Adquiera ARC9 Premium por %s Meses y obtenga un <color=100,255,100>%s%% de descuento</color>!
]]

L["premium.payment.info"] = [[
Adquirir ARC9 Premium otorga acceso inmediato a todos los contenidos listados anteriormente durante el tiempo adquirido.
El tiempo se puede ampliar comprando de nuevo cualquiera de las opciones, y el tiempo se actualizar automticamente una vez transcurrido el tiempo original.
Una vez transcurrido el tiempo, y si no se ha realizado ningn pago adicional, se eliminar el acceso a ARC9 Premium.

Todas las opciones de personalizacin, incluidas las ranuras para accesorios, los preajustes y las retculas de colores realizadas con ARC9 Premium seguirn estando disponibles, pero no podr modificarlas ni aadir otras adicionales.
]]

L["premium.purchased"] = "Ha adquirido <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
Gracias por comprar ARC9 Premium! Ha hecho muy feliz al pjaro!

Un recibo ser enviado a su Email conectado.

Si usted no ha adquirido inmediatamente el acceso a las bonificaciones ARC9 Premium, por favor vuelva a unirse al servidor, o reinicie su juego.

Si sigues teniendo problemas, o si todava no se te ha concedido Premium, entonces visita el servidor Discord de Diamond Doves y proporciona una prueba vlida de compra, y lo arreglaremos para ti.
]]

--PATH lua/arc9/common/localization/content_base_sv-se.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Gemenskap"

L["attachment.sticker"] = "Klistermrke"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Olivgrn"
L["camo_arc9_base_flat_od.compactname"] = "OG"
L["camo_arc9_base_flat_od.description"] = "Standard Olivgrn kamouflage."

L["camo_arc9_base_flat_deserttan.printname"] = "Gulbrun ken"
L["camo_arc9_base_flat_deserttan.compactname"] = "ken"
L["camo_arc9_base_flat_deserttan.description"] = "Standard Gulbrun kenkamouflage."

L["camo_arc9_base_flat_arctic.printname"] = "Arktiskt Vit"
L["camo_arc9_base_flat_arctic.compactname"] = "Arktisk"
L["camo_arc9_base_flat_arctic.description"] = "Standard Arktiskt Vit kamouflage."

L["camo_arc9_base_flat_black.printname"] = "Fabrikssvart"
L["camo_arc9_base_flat_black.compactname"] = "Svart"
L["camo_arc9_base_flat_black.description"] = "Standard Fabrikssvart."

L["camo_arc9_base_flat_urbangray.printname"] = "Stadsgr"
L["camo_arc9_base_flat_urbangray.compactname"] = "Stad"
L["camo_arc9_base_flat_urbangray.description"] = "Standard Stadsgr kamouflage."

L["camo_arc9_base_flat_forestgreen.printname"] = "Skogsgrn"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Skog"
L["camo_arc9_base_flat_forestgreen.description"] = "Standard Skogsgrn kamouflage."

L["camo_arc9_base_flat_navy.printname"] = "Marinbl"
L["camo_arc9_base_flat_navy.compactname"] = "Marin"
L["camo_arc9_base_flat_navy.description"] = "Standard Marinbl frg."

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink kamouflage.\nChockande effektiv i kenomgivning."

L["camo_arc9_base_flat_fde.printname"] = "Platt Mrk Jord"
L["camo_arc9_base_flat_fde.compactname"] = "PMJ"
L["camo_arc9_base_flat_fde.description"] = "Standard Platt Mrk Jord kamouflage."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Rd"
L["camo_arc9_base_flat_red.compactname"] = "Rd"
L["camo_arc9_base_flat_red.description"] = "Simpel rd frg."

L["camo_arc9_base_flat_orange.printname"] = "Orange"
L["camo_arc9_base_flat_orange.compactname"] = "Orange"
L["camo_arc9_base_flat_orange.description"] = "Simpel orange frg."

L["camo_arc9_base_flat_yellow.printname"] = "Gul"
L["camo_arc9_base_flat_yellow.compactname"] = "Gul"
L["camo_arc9_base_flat_yellow.description"] = "Simpel gul frg."

L["camo_arc9_base_flat_green.printname"] = "Grn"
L["camo_arc9_base_flat_green.compactname"] = "Grn"
L["camo_arc9_base_flat_green.description"] = "Simpel grn frg."

L["camo_arc9_base_flat_blue.printname"] = "Bl"
L["camo_arc9_base_flat_blue.compactname"] = "Bl"
L["camo_arc9_base_flat_blue.description"] = "Simpel bl frg."

L["camo_arc9_base_flat_purple.printname"] = "Lila"
L["camo_arc9_base_flat_purple.compactname"] = "Lila"
L["camo_arc9_base_flat_purple.description"] = "Simpel lila frg."

L["camo_arc9_base_flat_pink.printname"] = "Rosa"
L["camo_arc9_base_flat_pink.compactname"] = "Rosa"
L["camo_arc9_base_flat_pink.description"] = "gon brnnande stark rosa frg."

L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9-Orange"
L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9-Orange"
L["camo_arc9_base_flat_arc9orange.description"] = "Den perfekta nyans av orange fr den sta lilla ARC9-logga klistermrket."

//////// Charms
L["charm_gs_killcounter.printname"] = "Drp Rknare"
L["charm_gs_killcounter.compactname"] = "DRP"
L["charm_gs_killcounter.description"] = "Enhet som sprar ditt vapens drp statistik."

L["charm_gs_clock.printname"] = "Simpel Klocka"
L["charm_gs_clock.compactname"] = "KLOCKA"
L["charm_gs_clock.description"] = "Enhet som visar tiden i realtid."

L["charm_gs_sticker.printname"] = "Klistermrke Panel"
L["charm_gs_sticker.compactname"] = "KLISTER."
L["charm_gs_sticker.description"] = "Enhet som tillter en att stta sitt egna klistermrke p dess skrm."

//////// Stickers, Base
L["sticker_spray.printname"] = "Spelare Sprej"
L["sticker_spray.compactname"] = "Sprej"
L["sticker_spray.description"] = [[Din egna sprej som ett klistermrkte!
Du kommer endast kunna se din egna och inte ngra frn andra spelare.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_arc9.printname"] = "ARC9-Logga (Lg Syn.)"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[Mrk version av ARC9-loggan.
Design av The Villain.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_arc9_lowvis.printname"] = "ARC9-Logga"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[Till dig.
Design av The Villain.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[detta r vad "arc9" egentligen betyder

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_a9cylo.printname"] = "ARC9-Logga koncept av CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[En av dem frsta koncepten fr ARC9-loggan/ikonen av CyloWalker (han r schysst!)

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[Den misstnkte kan vara vart som helst bland oss...
Design av Darsu.

Klistermrke inkluderad i ARC9-basen.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalisera Utomjording Lutning"
L["sticker_alien_lean.compactname"] = "LUT"
L["sticker_alien_lean.description"] = [[Hoppa ner till Agartha med den vita pojkarna fr en kopp av utomjordiskt lutning och... andra grejer.
Design av Opt1ca.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_tomatocat.printname"] = "Tomat Katt"
L["sticker_tomatocat.compactname"] = "Tomat Katt"
L["sticker_tomatocat.description"] = [[Ibland frgar folk om tomater r frukter eller grnsaker... detta kan vara en tuff frga.
Design av Ender2Point0.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_actionbird.printname"] = "Handling Fgel"
L["sticker_actionbird.compactname"] = "Handling Fgel"
L["sticker_actionbird.description"] = [[Detta r hur Arctic ser ut som p verkligt.
Design av CyloWalker.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_warcrimes.printname"] = "Krigsbrott"
L["sticker_warcrimes.compactname"] = "Krigsbrott"
L["sticker_warcrimes.description"] = [[Du utfr dem redan, s varfr inte skrika hgt om det? Vem ska stoppa dig, FN?
Design av Rimuchii. Gjord med Project Sekai sticker base.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_sillycat.printname"] = "Dum Katt"
L["sticker_sillycat.compactname"] = "Dum Katt"
L["sticker_sillycat.description"] = [[jagrtokigjagrtokigjagrtokigjagrtokigjagrtokig
Design av Stan_Jacobs.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["detta borde vara min sista version tror jag, om inte ngon ger mig freslag p att ndra den, namnet: "Dia de los muertos calavera" beskrivningen: kan inte tnka mig en, ngot om dem ddas dag i mexiko blah blah blah"
Design av rooneyviz.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_bandaid.printname"] = "Plster"
L["sticker_bandaid.compactname"] = "Plster"
L["sticker_bandaid.description"] = [[Stt den p ditt sr och pussa p den tills det blir bttre.
Design av Itzal.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_peacedove.printname"] = "Fred Genom verlgsen Eldkraft"
L["sticker_peacedove.compactname"] = "FGE"
L["sticker_peacedove.description"] = [[Duvan ger frid, men vapnet ger frid genom verlgsen eldkraft.
Design av Xipil.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_borntomodify.printname"] = "Fdd Att Anpassa"
L["sticker_borntomodify.compactname"] = "FAA"
L["sticker_borntomodify.description"] = [[nnu ett sikte - nnu ett kikarsikte - en granattillsats, hr och dr...
Design av Duck.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
Design av Opt1ca.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[T-Titta inte p mig sdr, raifu-kun...
Design av Itzal.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_hotlead.printname"] = "Varmt Bly"
L["sticker_hotlead.compactname"] = "Varmt Bly"
L["sticker_hotlead.description"] = [[Frsiktigt! Det r varmt!
Design av Arqu.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Glad om det
Design frn Steam.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[Varfr nja sig med originalet nr man kan ha en billig knockoff?!
Design frn Optica.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_arcglory.printname"] = "ra!"
L["sticker_arcglory.compactname"] = "ra!"
L["sticker_arcglory.description"] = [[Krvde nio hjrnceller att gra detta
Design frn Optica.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_wp.printname"] = "Vrldsfred!"
L["sticker_wp.compactname"] = "Vrldsfred!"
L["sticker_wp.description"] = [[Villfarelse!
Design frn Fidget.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_tonkr.printname"] = "Skicka Det"
L["sticker_tonkr.compactname"] = "Skicka Det"
L["sticker_tonkr.description"] = [[Ja, den r s tung. Ja, den r s kraftfull.
Design frn CyloWalker.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_s6amblem.printname"] = "Sektion 6"
L["sticker_s6amblem.compactname"] = "Sektion 6"
L["sticker_s6amblem.description"] = [[Sikte mot stjrnorna. Framt mot ran!
Design frn CyloWalker.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_babies.printname"] = "Fara fr Bbisar"
L["sticker_babies.compactname"] = "Fara"
L["sticker_babies.description"] = [[Barn i ldrarna 0-3 borde hllas borta frn detta... skjutvapnet.
Design frn Itzal.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_drawberf.printname"] = "Berf"
L["sticker_drawberf.compactname"] = "Berf"
L["sticker_drawberf.description"] = [[Rita Berf.
Design av The Villain.

Klistermrke inkluderad i ARC9-basen.]]

L["sticker_arcbird.printname"] = "Arc-Fgel"
L["sticker_arcbird.compactname"] = "Arc-Fgel"
L["sticker_arcbird.description"] = [[Arc-Fgel.
Design av Nori/Chewable.

Klistermrke inkluderad i ARC9-basen.]]

--PATH lua/arc9/common/localization/font_zh-cn.lua:
L = {}

/////////////////////////////////////// Font
//////////////////// If a custom font should be used, rename the string. Useful for Pinyin, Kanji, etc.
////////// Do not create a font file if your language does not need it.

L["font"] = "Microsoft YaHei UI"
--PATH lua/arc9/shared/sh_effects.lua:

game.AddParticles( "particles/muzzleflashes_test.pcf" )
--game.AddParticles( "particles/muzzleflashes_test_b.pcf" ) -- Why and What is this?
game.AddParticles( "particles/fas_explosions.pcf" )

PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_2" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
---- Muzzle Weapon Specific
PrecacheParticleSystem( "muzzleflash_pistol_cleric"  )
PrecacheParticleSystem( "muzzleflash_pistol_red"  )
PrecacheParticleSystem( "muzzleflash_pistol_rbull"  )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_M3" )
PrecacheParticleSystem( "muzzleflash_FAMAS"  )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_MINIMI"  )
PrecacheParticleSystem( "muzzleflash_OTS" )
PrecacheParticleSystem( "muzzleflash_svd" )
PrecacheParticleSystem( "muzzleflash_SR25" )
PrecacheParticleSystem( "muzzleflash_m24" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_M82" )
PrecacheParticleSystem( "muzzleflash_vollmer"  )
PrecacheParticleSystem( "muzzleflash_m79" )
---- Muzzle Weapon Types
PrecacheParticleSystem( "muzzleflash_pistol"  )
PrecacheParticleSystem( "muzzleflash_pistol_deagle"  )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_ar" )
PrecacheParticleSystem( "muzzleflash_shotgun"  )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_lmg" )
PrecacheParticleSystem( "muzzleflash_dmr" )
PrecacheParticleSystem( "muzzleflash_suppressed"  )
PrecacheParticleSystem( "muzzleflash_suppressed_shotgun"  )
---- Shell eject
PrecacheParticleSystem( "shellsmoke" )
PrecacheParticleSystem( "port_shellsmoke" )
PrecacheParticleSystem( "port_smoke" )
PrecacheParticleSystem( "port_smoke_heavy" )
---- After Effects
PrecacheParticleSystem( "barrel_smoke" )
PrecacheParticleSystem( "barrel_smoke_2" )
PrecacheParticleSystem( "barrel_smoke_3" )
PrecacheParticleSystem( "barrel_smoke_heavy" )

---- Explosion Effects
PrecacheParticleSystem("explosion_grenade" )
PrecacheParticleSystem("explosion_mortarb" )
PrecacheParticleSystem("explosion_water" )
PrecacheParticleSystem("explosion_claymore" )
PrecacheParticleSystem("explosion_m79" )
PrecacheParticleSystem("explosion_m79_body" )
PrecacheParticleSystem("explosion_HE_m79" )
PrecacheParticleSystem("explosion_HE_claymore" )
PrecacheParticleSystem("explosion_he_grenade" )
PrecacheParticleSystem("grenade_final" )
PrecacheParticleSystem("claymore_final" )
PrecacheParticleSystem("party_fireworks" )
PrecacheParticleSystem("grenade_flash" )
PrecacheParticleSystem("explosion_flash" )
PrecacheParticleSystem("smoke_plume" )

--PATH lua/arc9/shared/sh_move.lua:
return gluapack()()
--PATH lua/arc9/client/cl_singleplayer.lua:
if game.SinglePlayer() then
    net.Receive("arc9_sp_health", function(len, ply)
        local ent = net.ReadEntity()
        if !IsValid(ent) then return end
        ent:SetHealth(0)
        ent.ARC9CLHealth = 0
    end)
end

local clr_b = Color(160, 190, 255)
local clr_r = Color(255, 190, 190)

concommand.Add("arc9_dev_printirons", function()
    MsgC(clr_b, "{\n")
    MsgC(color_white, "    Pos")
    MsgC(clr_b, " = ")
    MsgC(clr_r, "Vector")
    MsgC(color_white, "(")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_x"):GetFloat()))
    MsgC(color_white, ",")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_y"):GetFloat()))
    MsgC(color_white, ",")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_z"):GetFloat()))
    MsgC(color_white, "),\n")
    MsgC(color_white, "    Ang")
    MsgC(clr_b, " = ")
    MsgC(clr_r, "Angle")
    MsgC(color_white, "(")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_pitch"):GetFloat()))
    MsgC(color_white, ",")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_yaw"):GetFloat()))
    MsgC(color_white, ",")
    MsgC(clr_b, tostring(GetConVar("arc9_dev_irons_roll"):GetFloat()))
    MsgC(color_white, "),\n")
    MsgC(clr_b, "}\n")

    -- Pos = Vector(GetConVar("arc9_dev_irons_x"):GetFloat(), GetConVar("arc9_dev_irons_y"):GetFloat(), GetConVar("arc9_dev_irons_z"):GetFloat()),
    --                     Ang = Angle(GetConVar("arc9_dev_irons_pitch"):GetFloat(), GetConVar("arc9_dev_irons_yaw"):GetFloat(), GetConVar("arc9_dev_irons_roll"):GetFloat()),
end)

concommand.Add("arc9_dev_listanims", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local vm = LocalPlayer():GetViewModel()
    if !vm then return end
    local alist = vm:GetSequenceList()

    for i = 0, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\t", alist[i], "\n     [")
        MsgC(clr_r, "\t", vm:SequenceDuration(i), "\n")
    end
end)

concommand.Add("arc9_dev_listmyatts", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local atts = wep:GetAttachmentList()

    for i = 0, #atts do
        if !atts[i] then continue end
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\t", atts[i], "\n")
    end
end)

local function printattsintable(tbl, depth)
    for k, v in pairs(tbl) do
        if istable(v) and isnumber(k) or k == "SubAttachments" then
            MsgC(clr_b, string.rep("\t", depth), k, " = {\n")
            printattsintable(v, depth + 1)
            MsgC(clr_b, string.rep("\t", depth), "},\n")
        elseif k == "Installed" then
            MsgC(clr_b, string.rep("\t", depth), k, " = ")
            MsgC(clr_r, tostring(v), "\n")
        end
    end
end

concommand.Add("arc9_dev_printatts", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !IsValid(wep) or !wep.ARC9 or !wep.Attachments then MsgC(clr_r, "Not a valid ARC9 weapon with attachments!") return end

    MsgC(clr_b, "{\n")
    printattsintable(wep.Attachments, 1)
    MsgC(clr_b, "}\n")
end)

concommand.Add("arc9_dev_listbones", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local vm = LocalPlayer():GetViewModel()
    if !vm then return end

    for i = 0, (vm:GetBoneCount() - 1) do
        print(i .. " - " .. vm:GetBoneName(i))
    end
end)

concommand.Add("arc9_dev_listatts", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local vm = LocalPlayer():GetViewModel()
    if !vm then return end
    local alist = vm:GetAttachments()

    for i = 1, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\tindex : ", alist[i].id, "\n     [")
        MsgC(clr_r, "\tname: ", alist[i].name, "\n")
    end
end)

concommand.Add("arc9_dev_getjson", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end

    print(wep:GetPresetJSON())
end)

concommand.Add("arc9_dev_export", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    if !wep.ARC9 then return end

    print(wep:GeneratePresetExportCode())
end)

concommand.Add("arc9_dev_import", function(ply, cmd, args)
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    if !wep.ARC9 then return end

    wep:LoadPresetFromCode(args[1] or "")
end)

concommand.Add("arc9_dev_listbgs", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local vm = LocalPlayer():GetViewModel()
    if !vm then return end
    local alist = vm:GetBodyGroups()

    for i = 1, #alist do
        local alistsm = alist[i].submodels
        local active = vm:GetBodygroup(alist[i].id)
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\tid: ", alist[i].id, "\n     [")
        MsgC(clr_r, "\tname: ", alist[i].name, "\n")
        MsgC(clr_r, "\tnum: ", alist[i].num, "\n")

        if alistsm then
            MsgC(clr_r, "\tsubmodels:\n")

            for j = 0, #alistsm do
                MsgC(active == j and color_white or clr_b, "\t" .. j, " --- ")
                MsgC(active == j and color_white or clr_r, alistsm[j], "\n")
            end
        end
    end
end)

concommand.Add("arc9_dev_listsubmats", function()
    local wep = LocalPlayer():GetActiveWeapon()
    if !wep then return end
    local vm = LocalPlayer():GetViewModel()
    if !vm then return end
    local alist = vm:GetMaterials()
    local slist = table.ToString(alist, "Materials Table", true)
    print(slist)
end)
--PATH lua/arc9/client/cl_thirdperson.lua:
ARC9.RelativeCamAngles = Angle(0, 0, 0)
ARC9.RelativePlayerAngles = Angle(0, 0, 0)
ARC9.FOV = 90

ARC9.RealCamPos = Vector(0, 0, 0)
ARC9.RealCamAng = Angle(0, 0, 0)

local arc9_cam_shoulder = GetConVar("arc9_cam_shoulder")
local sensitivity = GetConVar("sensitivity")
local m_yaw = GetConVar("m_yaw")
local m_pitch = GetConVar("m_pitch")
local arc9_thirdperson_force = GetConVar("arc9_thirdperson_force")
local arc9_thirdperson = GetConVar("arc9_thirdperson")

function ARC9.CalcView( ply, pos, angles, fov )
    local cam_enabled = ARC9.ShouldThirdPerson()
    local znear = 2

    local att = ARC9.EyeAtt
    local cam_forward = 0
    local cam_up = 0
    local cam_right = 0
    local cam_drawviewer = true
    local cam_angoffset = Angle(0, 0, 0)

    local tracestart = pos
    local traceend = nil

    local wpn = ply:GetActiveWeapon()

    -- local view = {}

    if !wpn.ARC9 then return end

    -- if wpn:BeingOvertaken() then return end

    if !cam_enabled then return end
    if wpn:GetInSights() then return end
    --if wpn:GetSightAmount() >= 0.1 then return end

    -- local targetfov = GetConVar("ARC9_fov"):GetFloat()
    -- local basefov = targetfov

    -- att = GetConVar("ARC9_cam_att"):GetString()
    -- cam_forward = GetConVar("ARC9_cam_forward"):GetFloat()
    -- cam_right = GetConVar("ARC9_cam_right"):GetFloat()
    -- cam_up = GetConVar("ARC9_cam_up"):GetFloat()

    -- if GetConVar("ARC9_rcam"):GetBool() then
    --     att = GetConVar("ARC9_rcam_att"):GetString()
    --     cam_forward = GetConVar("ARC9_rcam_forward"):GetFloat()
    --     cam_right = GetConVar("ARC9_rcam_right"):GetFloat()
    --     cam_up = GetConVar("ARC9_rcam_up"):GetFloat()
    -- end

    -- att = "eyes"
    cam_forward = -48
    cam_right = 16
    cam_up = 4

    -- if wpn:GetCustomize() then
    --     targetfov = targetfov * 0.8
    -- end

    -- local approachspeed = 180

    -- if wpn:GetSighted() then
    --     targetfov = basefov / wpn:GetValue("Magnification")
    --     -- approachspeed = math.huge

    --     if !wpn:GetSafe() then
    --         targetfov = basefov * 0.8
    --     end
    -- end

    -- local attob = ply:LookupAttachment(att)

    local attpos = ply:EyePos() -- pos

    -- if attob > 0 then
    --     attpos = ply:GetAttachment(attob).Pos
    -- end

    -- if GetConVar("ARC9_cam_obj"):GetBool() then
    --     attpos = pos
    -- end

    local trfilter = {ply}

    angles = ARC9.RelativeCamAngles

    local up = angles:Up()
    local right = angles:Right()
    local forward = angles:Forward()

    if !traceend then
        traceend = attpos + (up * cam_up) + (right * cam_right * arc9_cam_shoulder:GetInt()) + (forward * cam_forward)
    end

    local view = {}
    local origin, viewang

    if !wpn.CalcView then return end
    origin, viewang, fov = wpn:CalcView(ply, pos, angles, fov)
    if !origin or !viewang or !fov then return end

    view.origin = origin
    view.angles = viewang
    view.fov = fov
    view.znear = znear
    view.drawviewer = cam_drawviewer
    -- view.viewmodelfov = 90

    -- ARC9.FOV = math.Approach(ARC9.FOV, targetfov, FrameTime() * approachspeed)

    -- view.fov = ARC9.FOV

    local tr = util.TraceLine({
        start = tracestart,
        endpos = traceend,
        filter = trfilter,
        mask = MASK_OPAQUE,
    })

    vorigin = tr.HitPos
    if tr.Hit then
        vorigin = tr.HitPos + (tr.HitNormal * znear * 2)
    end

    view.origin = vorigin
    view.angles:Add(cam_angoffset + LocalPlayer():GetViewPunchAngles())

    ARC9.RealCamPos = view.origin
    ARC9.RealCamAng = view.angles

    return view
end

hook.Add( "CalcView", "ARC9.CalcView", ARC9.CalcView )

ARC9.TurningSpeed = 360
ARC9.CamPitch = 85

function ARC9.InputMouseApply( cmd, x, y, ang )
    if !ARC9.ShouldThirdPerson() then return end

    local ply = LocalPlayer()
    local wpn = ply:GetActiveWeapon()
    local turnspeed = ARC9.TurningSpeed

    if !IsValid(wpn) or !wpn.ARC9 or wpn:GetInSights() then--wpn:GetSightAmount() >= 0.1 then
        ARC9.RelativeCamAngles = EyeAngles()
        ARC9.RelativePlayerAngles = EyeAngles()
        ARC9.RealCamAng = EyeAngles()
        return
    end

    local relative = false

    if wpn:GetSprintAmount() > 0 then
        relative = true
    end

    if wpn:GetSafe() then
        relative = true
    end

    local mult = 1

    -- if wpn:GetSighted() then
    --     turnspeed = math.huge
    --     mult = 1 / wpn:GetValue("Magnification")
    -- end

    -- if !GetConVar("ARC9_cam_relativemotion"):GetBool() then
    --     relative = false
    -- end

    local targetplayerangles = ARC9.RelativePlayerAngles

    if !relative then
        -- if GetConVar("ARC9_aim_correction"):GetBool() and
        if LocalPlayer():GetMoveType() != MOVETYPE_NOCLIP then
            local eyetrace = util.TraceLine({
                start = ARC9.RealCamPos,
                endpos = ARC9.RealCamPos + ARC9.RealCamAng:Forward() * 2048,
                mask = MASK_SHOT,
                filter = LocalPlayer()
            })

            targetplayerangles = (eyetrace.HitPos - LocalPlayer():EyePos()):GetNormalized():Angle()

            local movevec = Vector(cmd:GetForwardMove(), cmd:GetSideMove(), cmd:GetUpMove())

            movevec = LocalToWorld(movevec, angle_zero, vector_origin, targetplayerangles - ARC9.RealCamAng)

            cmd:SetForwardMove(movevec.x)
            cmd:SetSideMove(movevec.y)
            cmd:SetUpMove(movevec.z)
        else
            targetplayerangles = ARC9.RelativeCamAngles
        end
    else
        local movevec = Vector(cmd:GetForwardMove(), cmd:GetSideMove(), cmd:GetUpMove())

        if movevec:Length() > 0 then
            targetplayerangles = ARC9.RelativeCamAngles - movevec:Angle()

            cmd:SetForwardMove(movevec:Length())
            cmd:SetSideMove(0)
            cmd:SetUpMove(0)
        end
    end

    if ply:InVehicle() then
        targetplayerangles = targetplayerangles - ply:GetVehicle():GetAngles()
    end

    ARC9.RelativePlayerAngles = targetplayerangles

    local c_angles = cmd:GetViewAngles()

    if ply:InVehicle() then
        c_angles = c_angles
    end

    local sensa = mult * sensitivity:GetFloat() / 100

    local deltax = x * sensa
    local deltay = y * sensa

    if m_yaw:GetFloat() < 0 then
        deltax = deltax * -1
    end

    if m_pitch:GetFloat() < 0 then
        deltay = deltay * -1
    end

    ARC9.RelativeCamAngles.p = math.Clamp(ARC9.RelativeCamAngles.p + deltay, -ARC9.CamPitch, ARC9.CamPitch)

    ARC9.RelativeCamAngles.y = ARC9.RelativeCamAngles.y - deltax

    ARC9.RelativeCamAngles.r = 0

    c_angles[1] = math.ApproachAngle(c_angles[1], targetplayerangles[1], FrameTime() * turnspeed)
    c_angles[2] = math.ApproachAngle(c_angles[2], targetplayerangles[2], FrameTime() * turnspeed)
    c_angles[3] = math.ApproachAngle(c_angles[3], targetplayerangles[3], FrameTime() * turnspeed)

    cmd:SetViewAngles(c_angles)

    return
end

hook.Add( "InputMouseApply", "ARC9.InputMouseApply", ARC9.InputMouseApply )

ARC9.ShouldThirdPerson = function()
    local force = arc9_thirdperson_force:GetInt()
    local should = arc9_thirdperson:GetBool()

    if force == 1 then
        should = true
    elseif force >= 2 then
        should = false
    end

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ARC9 then return false end

    if wpn:GetCustomize() then return false end

    return should
end


--PATH lua/pixelui/core/cl_scaling.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local scrH = ScrH
local max = math.max
function PIXEL.Scale(value)
    return max(value * (scrH() / 1080), 1)
end

local constants = {}
local scaledConstants = {}
function PIXEL.RegisterScaledConstant(varName, size)
    constants[varName] = size
    scaledConstants[varName] = PIXEL.Scale(size)
end

function PIXEL.GetScaledConstant(varName)
    return scaledConstants[varName]
end

hook.Add("OnScreenSizeChanged", "PIXEL.UI.UpdateScaledConstants", function()
    for varName, size in pairs(constants) do
        scaledConstants[varName] = PIXEL.Scale(size)
    end
end)

--PATH lua/pixelui/drawing/cl_text.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local ceil = math.ceil
local setFont = PIXEL.SetFont
local getTextSize = PIXEL.GetTextSize
local setTextPos = surface.SetTextPos
local setTextColor = surface.SetTextColor
local drawText = surface.DrawText

function PIXEL.DrawSimpleText(text, font, x, y, col, xAlign, yAlign)
    setFont(font)
    local w, h = getTextSize(text)

    if xAlign == 1 then
        x = x - w / 2
    elseif xAlign == 2 then
        x = x - w
    end

    if yAlign == 1 then
        y = y - h / 2
    elseif yAlign == 4 then
        y = y - h
    end

    setTextPos(ceil(x), ceil(y))
    setTextColor(col.r, col.g, col.b, col.a)
    drawText(text)

    return w, h
end

local drawSimpleText = PIXEL.DrawSimpleText
local gmatch = string.gmatch
local find = string.find
local max = math.max
local select = select

function PIXEL.DrawText(text, font, x, y, col, xAlign, yAlign)
    local curX = x
    local curY = y

    setFont(font)
    local lineHeight = select(2, getTextSize("\n"))
    local tabWidth = 50

    for str in gmatch(text, "[^\n]*") do
        if #str > 0 then
            if find(str, "\t") then
                for tabs, str2 in gmatch(str, "(\t*)([^\t]*)") do
                    curX = ceil((curX + tabWidth * max(#tabs - 1, 0 )) / tabWidth) * tabWidth

                    if #str2 > 0 then
                        drawSimpleText(str2, font, curX, curY, col, xAlign)
                        curX = curX + getTextSize(str2)
                    end
                end
            else
                drawSimpleText(str, font, curX, curY, col, xAlign)
            end
        else
            curX = x
            curY = curY + lineHeight / 2
        end
    end
end

function PIXEL.DrawShadowText(text, font, x, y, col, xAlign, yAlign, depth, shadow)
    shadow = shadow or 50

    for i = 1, depth do
        drawSimpleText(text, font, x + i, y + i, Color(0, 0, 0, i * shadow), xAlign, yAlign)
    end

    drawSimpleText(text, font, x, y, col, xAlign, yAlign)
end

local drawShadowText = PIXEL.DrawShadowText

function PIXEL.DrawDualText(title, subtitle, x, y, h)
    x = x or 0
    y = y or 0

    setFont(title[2])
    local tH = select(2, getTextSize(title[1]))

    setFont(subtitle[2])
    local sH = select(2, getTextSize(subtitle[1]))

    drawShadowText(title[1], title[2], x, y - sH / 2, title[3], title[4], 1, title[5], title[6])
    drawShadowText(subtitle[1], subtitle[2], x, y + tH / 2, subtitle[3], subtitle[4], 1, subtitle[5], subtitle[6])
end

local textWrapCache = {}

local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + getTextSize(char)

        if totalWidth >= remainingWidth then
            totalWidth = getTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

local subString = string.sub

function PIXEL.WrapText(text, width, font) --Edit of https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/base/cl_util.lua#L21
    local chachedName = text .. width .. font
    if textWrapCache[chachedName] then return textWrapCache[chachedName] end

    setFont(font)
    local textWidth = getTextSize(text)

    if textWidth <= width then
        textWrapCache[chachedName] = text
        return text
    end

    local totalWidth = 0
    local spaceWidth = getTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
        local char = subString(word, 1, 1)
        if char == "\n" or char == "\t" then
            totalWidth = 0
        end

        local wordlen = getTextSize(word)
        totalWidth = totalWidth + wordlen

        if wordlen >= width then
            local splitWord, splitPoint = charWrap(word, width - (totalWidth - wordlen), width)
            totalWidth = splitPoint
            return splitWord
        elseif totalWidth < width then
            return word
        end

        if char == ' ' then
            totalWidth = wordlen - spaceWidth
            return '\n' .. subString(word, 2)
        end

        totalWidth = wordlen
        return '\n' .. word
    end)

    textWrapCache[chachedName] = text
    return text
end

local left = string.Left

local ellipsesTextCache = {}

function PIXEL.EllipsesText(text, width, font)
    local chachedName = text .. width .. font
    if ellipsesTextCache[chachedName] then return ellipsesTextCache[chachedName] end

    setFont(font)
    local textWidth = getTextSize(text)

    if textWidth <= width then
        ellipsesTextCache[chachedName] = text
        return text
    end

    local infiniteLoopPrevention = 0 --Just in case we really fuck up

    repeat
        text = left(text, #text - 1)
        textWidth = getTextSize(text .. "...")

        infiniteLoopPrevention = infiniteLoopPrevention + 1
    until textWidth <= width or infiniteLoopPrevention > 10000

    text = text .. "..."

    ellipsesTextCache[chachedName] = text
    return text
end
--PATH lua/pixelui/elements/cl_button.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "IsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "Toggle", "Toggle", FORCE_BOOL)

function PANEL:Init()
    self:SetIsToggle(false)
    self:SetToggle(false)
    self:SetMouseInputEnabled(true)

    self:SetCursor("hand")

    local btnSize = PIXEL.Scale(30)
    self:SetSize(btnSize, btnSize)

    self.NormalCol = PIXEL.CopyColor(PIXEL.Colors.Primary)
    self.HoverCol = PIXEL.OffsetColor(self.NormalCol, -15)
    self.ClickedCol = PIXEL.OffsetColor(self.NormalCol, 15)
    self.DisabledCol = PIXEL.CopyColor(PIXEL.Colors.Disabled)

    self.BackgroundCol = self.NormalCol
end

function PANEL:DoToggle(...)
    if not self:GetIsToggle() then return end

    self:SetToggle(not self:GetToggle())
    self:OnToggled(self:GetToggle(), ...)
end

local localPly
function PANEL:OnMousePressed(mouseCode)
    if not self:IsEnabled() then return end

    if not localPly then
        localPly = LocalPlayer()
    end

    if self:IsSelectable() and mouseCode == MOUSE_LEFT and (input.IsShiftDown() or input.IsControlDown()) and not (localPly:KeyDown(IN_FORWARD) or localPly:KeyDown(IN_BACK) or localPly:KeyDown(IN_MOVELEFT) or localPly:KeyDown(IN_MOVERIGHT)) then
        return self:StartBoxSelection()
    end

    self:MouseCapture(true)
    self.Depressed = true
    self:OnPressed(mouseCode)

    self:DragMousePress(mouseCode)
end

function PANEL:OnMouseReleased(mouseCode)
    self:MouseCapture(false)

    if not self:IsEnabled() then return end
    if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

    if self.Depressed then
        self.Depressed = nil
        self:OnReleased(mouseCode)
    end

    if self:DragMouseRelease(mouseCode) then
        return
    end

    if self:IsSelectable() and mouseCode == MOUSE_LEFT then
        local canvas = self:GetSelectionCanvas()
        if canvas then
            canvas:UnselectAll()
        end
    end

    if not self.Hovered then return end

    self.Depressed = true

    if mouseCode == MOUSE_RIGHT then
        self:DoRightClick()
    elseif mouseCode == MOUSE_LEFT then
        self:DoClick()
    elseif mouseCode == MOUSE_MIDDLE then
        self:DoMiddleClick()
    end

    self.Depressed = nil
end

function PANEL:PaintExtra(w, h) end

function PANEL:Paint(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.DisabledCol)
        self:PaintExtra(w, h)
        return
    end

    local bgCol = self.NormalCol

    if self:IsDown() or self:GetToggle() then
        bgCol = self.ClickedCol
    elseif self:IsHovered() then
        bgCol = self.HoverCol
    end

    self.BackgroundCol = PIXEL.LerpColor(FrameTime() * 12, self.BackgroundCol, bgCol)

    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)

    self:PaintExtra(w, h)
end

function PANEL:IsDown() return self.Depressed end
function PANEL:OnPressed(mouseCode) end
function PANEL:OnReleased(mouseCode) end
function PANEL:OnToggled(enabled) end
function PANEL:DoClick(...) self:DoToggle(...) end
function PANEL:DoRightClick() end
function PANEL:DoMiddleClick() end

vgui.Register("PIXEL.Button", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_labelled_checkbox.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_menu.lua:
return gluapack()()
--PATH lua/pixelui/libraries/cl_arc.lua:
return gluapack()()
--PATH addons/[misc] siadanie/lua/autorun/sitanywhere.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sbutton.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor, accentcolor, successcolor, failcolor = slib.getTheme("textcolor"), slib.getTheme("accentcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor")

function PANEL:Init()
    self.font = font
    self:SetText("")
    self.bg = slib.getTheme("maincolor")
    self.alignment = TEXT_ALIGN_CENTER
    self.accentheight = 2
    self.selCol = accentcolor
    self.textcolor = textcolor
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "DockPadding", nil, function() return self end, true)
    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
    slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetVisible", nil, function() return self end, true)
end

function PANEL:setTitle(title, alignment, noresize)
    if self.title == title then return end
    self.title = title

    if alignment then self.alignment = alignment end
    
    if !noresize then
        surface.SetFont(self.font)
        local w = select(1, surface.GetTextSize(title))

        self:SetWide(w + (slib.getTheme("margin") * 2))
    end
    
    return self
end

function PANEL:getTitle()
    return self.title
end

function PANEL:SetLinePos(h)
    self.linepos = h

    return self
end

function PANEL:setToggleable(bool)
    self.toggleable = bool

    return self
end

function PANEL:Paint(w,h)
    local wantedcolor = self.toggleable and (isfunction(self.toggleCheck) and self.toggleCheck() and istable(self.toggleCheck()) and self.toggleCheck() or self.toggleCheck() and successcolor or failcolor) or self.selCol

    if !self.toggleable then
        wantedcolor.a = (self:IsHovered() or self.forcehover) and 120 or 20
    end

    surface.SetDrawColor(self.bg)
    surface.DrawRect(0, 0, w, h)

    surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
    surface.DrawRect(0, self.linepos ~= nil and self.linepos or (h - self.accentheight), w, self.accentheight)
    local x
    if self.alignment == TEXT_ALIGN_CENTER then
        x = w * .5
    elseif self.alignment == TEXT_ALIGN_RIGHT then
        x = w - slib.getTheme("margin")
    elseif self.alignment == TEXT_ALIGN_LEFT then
        x = slib.getTheme("margin")
    end

    draw.SimpleText(self.title, self.font, x, h * .5, self.textcolor, self.alignment, TEXT_ALIGN_CENTER)
end

vgui.Register("SButton", PANEL, "DButton")
--PATH lua/slib/vgui/cl_sdropdown.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor = slib.getTheme("textcolor")
local hovercolor, margin, maincolor_5, maincolor_10 = slib.getTheme("hovercolor"), slib.getTheme("margin"), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 10)
local icon = Material("slib/down-arrow.png", "smooth")

function PANEL:Init()
    self:SetTall(slib.getScaledSize(25, "y"))
    self:setTitle("Select Option", TEXT_ALIGN_LEFT)
    self.iteration = 0
    self.options = {}
    self.maxHeightChilds = 0

    self.close = vgui.Create("DButton")
    self.close:Dock(FILL)
    self.close:SetText("")
    self.close:SetVisible(false)

    self.close.Paint = function() end

    self.close.DoClick = function()
        self.close:SetVisible(false)
        if IsValid(self.droppedMenu) then
            self.droppedMenu:SetVisible(false)
        end

        if isfunction(self.onClose) then self.onClose(self) end
    end

    self.droppedMenu = vgui.Create("SScrollPanel")
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetVisible(false)
    self.droppedMenu.scrollbg = Color(42, 42, 42)
end

function PANEL:SetPlaceholder(str)
    self:setTitle(str, TEXT_ALIGN_LEFT)
end

function PANEL:OnRemove()
    if IsValid(self.droppedMenu) then self.droppedMenu:Remove() end
end

function PANEL:popupAlone()
    self:DoClick()

    local x, y = input.GetCursorPos()
    if !IsValid(self.droppedMenu) then return end
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetPos(x, y)
    self.droppedMenu:MakePopup()
    self:SetVisible(false)
    self.poppedOut = true

    self.onClose = function() self:Remove() end

    return self
end

function PANEL:SizeToChilds()
    local canvas = self.droppedMenu:GetCanvas()
    local childsHeight = 0

    for k,v in ipairs(canvas:GetChildren()) do
        if self.maxHeightChilds > 0 and k > self.maxHeightChilds then
            break
        end
        
        childsHeight = childsHeight + v:GetTall()
    end

    canvas:InvalidateLayout(true)
    canvas:SetTall(childsHeight)

    self.droppedMenu:SetHeight(canvas:GetTall())
end

function PANEL:addOption(val)
    local iteration = self.iteration
    self.options[iteration] = vgui.Create("SButton", self.droppedMenu)
    :Dock(TOP)
    :SetLinePos(0)
    :SetTall(slib.getScaledSize(25, "y"))

    if self.buttonfont then
        self.options[iteration].font = self.buttonfont
    end

    local is_func = isfunction(val)

    self.options[iteration]:setTitle(is_func and val() or val, TEXT_ALIGN_LEFT)

    local wide = self.options[iteration]:GetWide()

    self.options[iteration].accentheight = 1

    self:SizeToChilds()

    self.options[iteration].DoClick = function(called)
        self.close.DoClick()
        self:setTitle(is_func and val() or val, TEXT_ALIGN_LEFT, true)
        self.sel_int = iteration + 1
        
        if isfunction(self.onValueChange) then
            self.onValueChange(is_func and val() or val)
        end
    end
    local isFirst = !self.firstchild
    self.options[iteration].Paint = function(s,w,h)
        if is_func then self.options[iteration]:setTitle(val(), TEXT_ALIGN_LEFT) end

        surface.SetDrawColor(s:IsHovered() and maincolor_5 or maincolor_10)
        surface.DrawRect(0, 0, w, h)

        draw.SimpleText(is_func and val() or val, self.buttonfont or self.options[iteration].font, margin, h * .5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    
    if iteration == 0 then
        self.options[iteration].DoClick()
    end
    
    if wide > self:GetWide() then
        self:SetWide(wide)
    end
    
    self.iteration = self.iteration + 1

    self.firstchild = self.firstchild or self.options[iteration]
    self.lastchild = self.options[iteration]

    return self
end

function PANEL:SelectOption(int)
    self.options[int].DoClick(true)

    return self
end

function PANEL:Reposition()
    local x, y = self:LocalToScreen(0,self:GetTall())
    if !IsValid(self.droppedMenu) then return end
    self.droppedMenu:SetWide(self:GetWide())
    self.droppedMenu:SetPos(x, y)
    self.droppedMenu:MakePopup()
end

function PANEL:DoClick()
    self.close:SetVisible(!self.droppedMenu:IsVisible())
    self.close:MakePopup()

    self.droppedMenu:SetVisible(!self.droppedMenu:IsVisible())

    self:Reposition()
end

function PANEL:OnSizeChanged()
    self:Reposition()
end

function PANEL:PaintOver(w,h)
    local size = math.min(h * .7, slib.getScaledSize(12, "y"))
    local thickness = slib.getScaledSize(2, "x")

    draw.NoTexture()

    local wantedCol = self:IsHovered() and color_white or hovercolor

    surface.SetDrawColor(wantedCol)
    surface.SetMaterial(icon)
    surface.DrawTexturedRect(w - size - margin * 2, h * .5 - size * .5, size, size)
end

vgui.Register("SDropDown", PANEL, "SButton")
--PATH lua/slib/vgui/cl_splayerselector.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_sstatement.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_gprotect_config.lua:
gProtect = gProtect or {}
gProtect.config = gProtect.config or {}

gProtect.config.Prefix = "[gProtect] "

gProtect.config.FrameSize = {x = 720, y = 530}

gProtect.config.SelectedLanguage = "en"

gProtect.config.StorageType = "sql_local" -- (sql_local, mysql)

gProtect.config.EnableOwnershipHUD = true

gProtect.config.IgnoreEntitiesHUD = { -- Entities in this list will be ignored by the ray used for the ownership HUD.
	["mg_viewmodel"] = true,
}

gProtect.config.DisableOwnershipRayDetection = false -- Enable this if you dont have fading doors and such to slightly improve performance.

gProtect.config.DisableBuddySystem = false

gProtect.config.HideToolsInSpawnMenu = true -- Enable this to hide tools and categories if you dont have permission to use them

gProtect.config.Permissions = {
	["gProtect_Settings"] = { -- This is for modifying the values in gProtect
		["owner"] = true,
		["superadmin"] = true
	},
	["gProtect_StaffNotifications"] = { -- These groups will receive notifications from detections
		["owner"] = true,
		["superadmin"] = true
	},
	["gProtect_DashboardAccess"] = { -- These groups will be able to open the gProtect menu
		["owner"] = true,
		["superadmin"] = true
	}
}
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_english.lua:
if SERVER then
	slib.setLang("gprotect", "en", "colliding-too-much", "%s's entities are colliding too much, the trigger has a class of '%s' with %s collisions!")
	slib.setLang("gprotect", "en", "props-colliding-too-much", "%s's props are colliding too much with a total of %s collisions!")
	slib.setLang("gprotect", "en", "too-many-obstructs", "%s's entity is obstructing too many bad entities!")
	slib.setLang("gprotect", "en", "blacklisted-multiple", "You have successfully added %s models to the blocked models!")
	slib.setLang("gprotect", "en", "unblacklisted-multiple", "You have successfully removed %s models from the blocked models!")
	slib.setLang("gprotect", "en", "blacklisted-multiple-ent", "You have successfully added %s ents to the blacklisted entities!")
	slib.setLang("gprotect", "en", "unblacklisted-multiple-ent", "You have successfully removed %s ents from the blacklisted entities!")
	slib.setLang("gprotect", "en", "added-blacklist", "You have successfully added %s to the blocked models!")
	slib.setLang("gprotect", "en", "removed-blacklist", "You have successfully removed %s from the blocked models!")
	slib.setLang("gprotect", "en", "added-blacklist-ent", "You have successfully added %s to the entity blacklist!")
	slib.setLang("gprotect", "en", "removed-blacklist-ent", "You have successfully removed %s from the entity blacklist!")
	slib.setLang("gprotect", "en", "attempted-unfreeze-all", "%s has tried to unfreeze all after spawning a dupe!")
	slib.setLang("gprotect", "en", "attempted-upscaled-ent", "%s has tried to spawn an upscaled entity with adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-rope-spawning", "%s has tried to spawn ropes using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-no-gravity", "%s has tried to spawn props with no gravity using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-trail", "%s has tried to spawn props with trails using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-advdupe-out-of-bounds", "%s has tried to spawn entities out of bounds using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-advdupe-weird-angles", "%s has tried to spawn entities with weird angles using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-instacrash-server", "%s may have attempted to insta-crash the server!")

	slib.setLang("gprotect", "en", "model-restricted", "This model has been restricted!")
	slib.setLang("gprotect", "en", "classname-restricted", "This entity class has been restricted!")
	slib.setLang("gprotect", "en", "attempted-blacklistedmaterial", "%s has attempted to use a blacklisted material with fading door!")
	slib.setLang("gprotect", "en", "spam-spawning", "%s is trying to spam spawning of entites/props.")

	slib.setLang("gprotect", "en", "too-complex-model", "This model has been restricted, it's too complex!")
	slib.setLang("gprotect", "en", "too-big-prop", "Your prop is too big so we removed it!")
	slib.setLang("gprotect", "en", "successfull-fpp-blockedmodels", "You have successfully transferred the blockedmodels from FPP to gProtect!")
	slib.setLang("gprotect", "en", "successfull-fpp-grouptools", "You have successfully transferred the grouptools from FPP to gProtect!")
	slib.setLang("gprotect", "en", "unsuccessfull-transfer", "There seems to be an issue while transferring the data over! (MySQL isnt supported)")

	slib.setLang("gprotect", "en", "blocked-secondaryusergroup", "Blocked due to secondary usergroup!")
	slib.setLang("gprotect", "en", "blocked-usergroup", "Blocked due to usergroup!")
	slib.setLang("gprotect", "en", "blocked-teamname", "Blocked due to team name!")
	slib.setLang("gprotect", "en", "blocked-sid", "Blocked due to SteamID!")

	slib.setLang("gprotect", "en", "you-ghosted-props", "You have ghosted %s's props!")
	slib.setLang("gprotect", "en", "you-frozen-props", "You have frozen %s's props!")
	slib.setLang("gprotect", "en", "you-removed-props", "You have removed %s's props!")
	slib.setLang("gprotect", "en", "you-removed-ents", "You have removed %s's entities!")

	slib.setLang("gprotect", "en", "props-ghosted", "Your props has been ghosted!")
	slib.setLang("gprotect", "en", "props-frozen", "Your props has been frozen!")
	slib.setLang("gprotect", "en", "props-removed", "Your props has been removed!")
	slib.setLang("gprotect", "en", "ents-removed", "Your entities has been removed!")

	slib.setLang("gprotect", "en", "everyones-props-ghosted", "Someone has ghosted everyones props!")
	slib.setLang("gprotect", "en", "everyones-props-frozen", "Someone has frozen everyones props!")
	slib.setLang("gprotect", "en", "disconnected-ents-removed", "You have removed every disconnected players entities!")

	slib.setLang("gprotect", "en", "spawn-to-close", "Your prop cannot be spawned inside someone!")
	slib.setLang("gprotect", "en", "entity-ghosted", "Your entity has been ghosted!")

	slib.setLang("gprotect", "en", "ratelimited_toolgun", "This tool has a ratelimit, please wait!")
	slib.setLang("gprotect", "en", "too_many_obstructs_purchase", "We have removed the entity and refunded you, there are too many obstructs!")

	slib.setLang("gprotect", "en", "mysql_successfull", "We have successfully connected to the database!")
    slib.setLang("gprotect", "en", "mysql_failed", "We have failed connecting to the database!")
elseif CLIENT then
	slib.setLang("gprotect", "en", "title", "gProtect - Settings")
	slib.setLang("gprotect", "en", "buddies-title", "gProtect - Buddies")

	slib.setLang("gprotect", "en", "world", "World")
	slib.setLang("gprotect", "en", "disconnected", "Disconnected")
	slib.setLang("gprotect", "en", "toolgun-name", "Blacklist Props")
	slib.setLang("gprotect", "en", "toolgun-desc", "Manage blocked models")
	slib.setLang("gprotect", "en", "toolgun-leftclick", "Add to blacklisted models")
	slib.setLang("gprotect", "en", "toolgun-rightclick", "Remove from blacklisted models")
	slib.setLang("gprotect", "en", "toolgun-help", "Shoot on a prop with the tool")
	slib.setLang("gprotect", "en", "remove-on-blacklist", "Remove prop on blacklist")
	slib.setLang("gprotect", "en", "player-list", "Player List")

	slib.setLang("gprotect", "en", "submit", "Submit")
	slib.setLang("gprotect", "en", "input_number", "Input number")

	slib.setLang("gprotect", "en", "toolgun", "Toolgun")
	slib.setLang("gprotect", "en", "physgun", "Physgun")
	slib.setLang("gprotect", "en", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "en", "canproperty", "Can Property")
	slib.setLang("gprotect", "en", "canuse", "Can Use")

	slib.setLang("gprotect", "en", "add-blocked-models", "Add to blocked models")
	slib.setLang("gprotect", "en", "remove-blocked-models", "Remove from blocked models")

	slib.setLang("gprotect", "en", "add-blacklisted-ents", "Add to blacklisted entities")
	slib.setLang("gprotect", "en", "remove-blacklisted-ents", "Remove from blacklisted entities")
	slib.setLang("gprotect", "en", "copy-clipboard", "Copy to clipboard")

	slib.setLang("gprotect", "en", "general", "General")
	slib.setLang("gprotect", "en", "ghosting", "Ghosting")
	slib.setLang("gprotect", "en", "damage", "Damage")
	slib.setLang("gprotect", "en", "anticollide", "Anti Collide")
	slib.setLang("gprotect", "en", "spamprotection", "Spam Protection")
	slib.setLang("gprotect", "en", "spawnrestriction", "Spawn Restriction")
	slib.setLang("gprotect", "en", "toolgunsettings", "Toolgun Settings")
	slib.setLang("gprotect", "en", "physgunsettings", "Physgun Settings")
	slib.setLang("gprotect", "en", "gravitygunsettings", "Gravgun Settings")
	slib.setLang("gprotect", "en", "canpropertysettings", "Can Property Settings")
	slib.setLang("gprotect", "en", "canusesettings", "Can Use Settings")
	slib.setLang("gprotect", "en", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "en", "miscs", "Miscs")

	slib.setLang("gprotect", "en", "ghost-props", "Ghost Props")
	slib.setLang("gprotect", "en", "remove-props", "Remove Props")
	slib.setLang("gprotect", "en", "freeze-props", "Freeze Props")
	slib.setLang("gprotect", "en", "remove-entities", "Remove Entities")
	slib.setLang("gprotect", "en", "highlight-ents", "Highlight Entities")
	slib.setLang("gprotect", "en", "unhighlight-ents", "Unhighlight Entities")

	slib.setLang("gprotect", "en", "ghost-everyones-props", "Ghost everyones props")
	slib.setLang("gprotect", "en", "freeze-everyones-props", "Freeze everyones props")
	slib.setLang("gprotect", "en", "remove-disconnected-entities", "Remove disconnected players entities")

	slib.setLang("gprotect", "en", "general_remDiscPlyEnt", "Remove disconnect players entities")
	slib.setLang("gprotect", "en", "general_remDiscPlyEnt_tooltip", "This removes disconnected players entities on timer (If -1 it will be disabled)")
	slib.setLang("gprotect", "en", "general_remDiscPlyEntSpecific", "Remove disconnected players entities specific")
	slib.setLang("gprotect", "en", "general_remDiscPlyEntSpecific_tooltip", "Specific time for removal of entities, if nothing specified it will use the default one specified above. Making it -1 for classname will ignore it fully")

	slib.setLang("gprotect", "en", "general_remOutOfBounds", "Remove out of bounds timer")
	slib.setLang("gprotect", "en", "general_remOutOfBounds_tooltip", "This will remove entities that are outside of the map (If -1 it will be disabled)")
	slib.setLang("gprotect", "en", "general_remOutOfBoundsWhitelist", "Remove out of bounds whitelist")
	slib.setLang("gprotect", "en", "general_remOutOfBoundsWhitelist_tooltip", "Entities in this list will be removed if out of bounds.")

	slib.setLang("gprotect", "en", "general_blacklist", "Blacklist")
	slib.setLang("gprotect", "en", "general_blacklist_tooltip", "This is where add classnames that should be protected by generally all the modules.")
	slib.setLang("gprotect", "en", "general_protectedFrozenEnts", "Protected frozen entities")
	slib.setLang("gprotect", "en", "general_protectedFrozenEnts_tooltip", "This is the list of entities to protect whilst frozen")
	slib.setLang("gprotect", "en", "general_protectedFrozenGroup", "Protected frozen group")
	slib.setLang("gprotect", "en", "general_protectedFrozenGroup_tooltip", "This is the collision group to put frozen entities in!")

	slib.setLang("gprotect", "en", "ghosting_enabled", "Enabled")
	slib.setLang("gprotect", "en", "ghosting_enabled_tooltip", "Enable the ghosting module?")
	slib.setLang("gprotect", "en", "ghosting_ghostColor", "Ghosting color")
	slib.setLang("gprotect", "en", "ghosting_ghostColor_tooltip", "Select a color for ghosted entities")
	slib.setLang("gprotect", "en", "ghosting_antiObscuring", "Anti-obscuring")
	slib.setLang("gprotect", "en", "ghosting_antiObscuring_tooltip", "This will prevent the props from being unghosted while they obscure an object, Simply add entities that shouldnt be obscured!")
	slib.setLang("gprotect", "en", "ghosting_obscureOffset", "Anti-obscuring offset")
	slib.setLang("gprotect", "en", "ghosting_obscureOffset_tooltip", "This offset is used to add a gap outside of the bounding box that will trigger obscuring.")
	slib.setLang("gprotect", "en", "ghosting_onPhysgun", "Ghost on physgun?")
	slib.setLang("gprotect", "en", "ghosting_onPhysgun_tooltip", "This will ghost entities while being physgunned.")
	slib.setLang("gprotect", "en", "ghosting_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "ghosting_useBlacklist_tooltip", "This option will ghost the blacklisted items from the blacklist if the module is enabled.")
	slib.setLang("gprotect", "en", "ghosting_entities", "Entities")
	slib.setLang("gprotect", "en", "ghosting_entities_tooltip", "Classnames in this list will be ghosted, this wont modify the blacklist usable by other modules.")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozen", "Force ghost unfrozen ents")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozen_tooltip", "This will force ghost entities that arent frozen.")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozenEntities", "Force ghost unfrozen ents whitelist")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozenEntities_tooltip", "The entities in this list will be ghosted if not frozen.")
	slib.setLang("gprotect", "en", "ghosting_enableMotion", "Enable motion while ghosted")
	slib.setLang("gprotect", "en", "ghosting_fenableMotion_tooltip", "If enabled ghosting will not disable motion for entities.")

	slib.setLang("gprotect", "en", "damage_enabled", "Enabled")
	slib.setLang("gprotect", "en", "damage_enabled_tooltip", "Enable the damage module?")
	slib.setLang("gprotect", "en", "damage_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "damage_useBlacklist_tooltip", "This option will consider the general blacklist as a blacklisted ent in this module!")
	slib.setLang("gprotect", "en", "damage_entities", "Blacklisted Entities")
	slib.setLang("gprotect", "en", "damage_entities_tooltip", "Classnames in this list wont deal damage if the disable damage is ticked, this wont modify the blacklist usable by other modules.")
	slib.setLang("gprotect", "en", "damage_blacklistedEntPlayerDamage", "Disable blacklisted ents damage")
	slib.setLang("gprotect", "en", "damage_blacklistedEntPlayerDamage_tooltip", "If this is ticked then players wont receive damage from blacklisted entities.")
	slib.setLang("gprotect", "en", "damage_vehiclePlayerDamage", "Disable vehicle damage")
	slib.setLang("gprotect", "en", "damage_vehiclePlayerDamage_tooltip", "If this is ticked then players wont receive damage by vehicles.")
	slib.setLang("gprotect", "en", "damage_worldPlayerDamage", "Disable world damage")
	slib.setLang("gprotect", "en", "damage_worldPlayerDamage_tooltip", "If this is ticked then players wont receive damage from 'world', this can break certain addons unless they set damage to come from an entity.")
	slib.setLang("gprotect", "en", "damage_immortalEntities", "Immortal Entities")
	slib.setLang("gprotect", "en", "damage_immortalEntities_tooltip", "Classnames in this list wont take damage, except if the player is in the bypass group!")
	slib.setLang("gprotect", "en", "damage_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "damage_bypassGroups_tooltip", "Add usergroups in this list to bypass do damage restrictions, '*' means everyone!")
	slib.setLang("gprotect", "en", "damage_canDamageWorldEntities", "Can damage world entities")
	slib.setLang("gprotect", "en", "damage_canDamageWorldEntities_tooltip", "The groups that are in this list can damage world entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "anticollide_enabled", "Enabled")
	slib.setLang("gprotect", "en", "anticollide_enabled_tooltip", "Enable the anticollide module?")
	slib.setLang("gprotect", "en", "anticollide_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "anticollide_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "anticollide_protectDarkRPEntities", "Protect DarkRP Entities")
	slib.setLang("gprotect", "en", "anticollide_protectDarkRPEntities_tooltip", "Should we protect DarkRP Entities? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Remove & Refund)")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesThreshold", "DRP entities threshold")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesException", "DRP entities exception")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedEntities", "Protect Spawned Entities")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedEntities_tooltip", "Should we protect Spawned Entities? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove)")
	slib.setLang("gprotect", "en", "anticollide_entitiesThreshold", "Spawned entities threshold")
	slib.setLang("gprotect", "en", "anticollide_entitiesThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_entitiesException", "Spawned entities exception")
	slib.setLang("gprotect", "en", "anticollide_entitiesException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedProps", "Protect Spawned Props")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedProps_tooltip", "Should we protect Spawned Props? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Ghost & Unghost)")
	slib.setLang("gprotect", "en", "anticollide_propsThreshold", "Spawned props threshold")
	slib.setLang("gprotect", "en", "anticollide_propsThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_propsException", "Spawned props exception")
	slib.setLang("gprotect", "en", "anticollide_propsException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_playerPropAction", "Player specific props action")
	slib.setLang("gprotect", "en", "anticollide_playerPropAction_tooltip", "What action do we do once threshold is reached? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Ghost & Unghost)")
	slib.setLang("gprotect", "en", "anticollide_playerPropThreshold", "Player specific props threshold")
	slib.setLang("gprotect", "en", "anticollide_playerPropThreshold_tooltip", "This is the max collisions a player's props can have per second this will target all of their props! This only registers their own props as a collision.")
	slib.setLang("gprotect", "en", "anticollide_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "anticollide_useBlacklist_tooltip", "The blacklisted entities will be ghosted if the collide to much if this is enabled.")
	slib.setLang("gprotect", "en", "anticollide_ghostEntities", "Entities")
	slib.setLang("gprotect", "en", "anticollide_ghostEntities_tooltip", "Classnames in this list will be ghosted if they collide to much.")
	slib.setLang("gprotect", "en", "anticollide_specificEntities", "Specific entities")
	slib.setLang("gprotect", "en", "anticollide_specificEntities_tooltip", "Add classnames in here to make specific rules for them, meaning that the number here will be their threshold anything below 0 will count them as bypass.")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsMaxSize", "Squared physics max size")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsMaxSize_tooltip", "This is a global protection which will automatically make complex and smaller collsionboxes into squares, this is effective at prventing mid sized spheres from causing lag.")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsEnts", "Squared physics ents")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsEnts_tooltip", "This is a global anti collide feature, which makes entities sleep after they hit the defined threshold (Threshold is cleared every 1 secound)")

	slib.setLang("gprotect", "en", "spamprotection_enabled", "Enabled")
	slib.setLang("gprotect", "en", "spamprotection_enabled_tooltip", "Enable the spamprotection module?")
	slib.setLang("gprotect", "en", "spamprotection_threshold", "Threshold")
	slib.setLang("gprotect", "en", "spamprotection_threshold_tooltip", "If you spawn these many props at once then it will kick in unless the delay defined below has cleared.")
	slib.setLang("gprotect", "en", "spamprotection_delay", "Delay")
	slib.setLang("gprotect", "en", "spamprotection_delay_tooltip", "This timer will clear the threshold above.")
	slib.setLang("gprotect", "en", "spamprotection_action", "Punishment")
	slib.setLang("gprotect", "en", "spamprotection_action_tooltip", "This will decide how to deal with spammers! (1 = disallow spawning, 2 = ghost entity/prop)")
	slib.setLang("gprotect", "en", "spamprotection_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "spamprotection_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "spamprotection_protectProps", "Protect Props")
	slib.setLang("gprotect", "en", "spamprotection_protectProps_tooltip", "This will protect props from being spam spawned.")
	slib.setLang("gprotect", "en", "spamprotection_protectEntities", "Protect Entities")
	slib.setLang("gprotect", "en", "spamprotection_protectEntities_tooltip", "This will protect entities from being spam spawned.")

	slib.setLang("gprotect", "en", "spawnrestriction_enabled", "Enabled")
	slib.setLang("gprotect", "en", "spawnrestriction_enabled_tooltip", "Enable the spawnrestriction module?")
	slib.setLang("gprotect", "en", "spawnrestriction_propSpawnPermission", "Prop spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_propSpawnPermission_tooltip", "This will limit spawning props totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_SENTSpawnPermission", "SENT spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_SENTSpawnPermission_tooltip", "This will limit spawning SENTS totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_SWEPSpawnPermission", "SWEP spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_SWEPSpawnPermission_tooltip", "This will limit spawning SWEP totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_vehicleSpawnPermission", "Vehicle spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_vehicleSpawnPermission_tooltip", "This will limit spawning vehicle totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_NPCSpawnPermission", "NPC spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_NPCSpawnPermission_tooltip", "This will limit spawning NPC totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_ragdollSpawnPermission", "Ragdoll spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_ragdollSpawnPermission_tooltip", "This will limit spawning ragdoll totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_effectSpawnPermission", "Effect spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_effectSpawnPermission_tooltip", "This will limit spawning effects totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntities_tooltip", "Place classnames of entities that should never be spawned in here, this also works for SWEPs!")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntitiesIsBlacklist", "Blocked entities is a blacklist")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "If ticked it will make the classes in the list blocked from being spawned, otherwise you can only spawn those classes.")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModels", "Blocked models")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModels_tooltip", "Place model names so props with the model name wont spawn!")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsisBlacklist", "Blocked models is a blacklist")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsisBlacklist_tooltip", "If ticked it will make the models in the list blocked from being spawned, otherwise you can only spawn those models.")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsVehicleBypass", "Spawn vehicle bypass blocked models")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsVehicleBypass_tooltip", "If ticked vehicles will ignore the blocked models list.")
	slib.setLang("gprotect", "en", "spawnrestriction_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "spawnrestriction_bypassGroups_tooltip", "These groups will be able to bypass the blocked sents and models.")
	slib.setLang("gprotect", "en", "spawnrestriction_maxPropModelComplexity", "Max prop model complexity")
	slib.setLang("gprotect", "en", "spawnrestriction_maxPropModelComplexity_tooltip", "This will prevent from spawning models with complex shapes, recommended value is 10. (0 = Disabled)")
	slib.setLang("gprotect", "en", "spawnrestriction_maxModelSize", "Max model size")
	slib.setLang("gprotect", "en", "spawnrestriction_maxModelSize_tooltip", "If this is above 0 it will remove bigger props right after they are spawned.")

	slib.setLang("gprotect", "en", "toolgunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "toolgunsettings_enabled_tooltip", "Enable the toolgunsettings module?")
	slib.setLang("gprotect", "en", "toolgunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "toolgunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetVehiclePermission", "Target vehicle permission")
	slib.setLang("gprotect", "en", "toolgunsettings_targetVehiclePermission_tooltip", "If people are in the usergroups in this list they can use toolgun on vehicles!")

	slib.setLang("gprotect", "en", "toolgunsettings_restrictTools", "Restricted tools")
	slib.setLang("gprotect", "en", "toolgunsettings_restrictTools_tooltip", "The tools in here wont be usable by anyone but the ones in the bypassGroups option below.")
	slib.setLang("gprotect", "en", "toolgunsettings_groupToolRestrictions", "Group tool restrictions")
	slib.setLang("gprotect", "en", "toolgunsettings_groupToolRestrictions_tooltip", "Configure tool restrictions by tool, you can define with the following types: SteamID, Usergroup & Job name! (Whitelists has privlege over blacklists)")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassGroups_tooltip", "Groups in here will bypass the tool restrictions from the lists above!")
	slib.setLang("gprotect", "en", "toolgunsettings_entityTargetability", "Entity targetability")
	slib.setLang("gprotect", "en", "toolgunsettings_entityTargetability_tooltip", "This is neat to make it so people can only use the toolgun on their props for example!")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityTools", "Bypass targetability tools")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityTools_tooltip", "The tools in this list will bypass the targetability settings!")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityGroups", "Bypass targetability groups")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityGroups_tooltip", "The groups in this list will bypass the targetability settings!")
	slib.setLang("gprotect", "en", "toolgunsettings_antiSpam", "Anti spam")
	slib.setLang("gprotect", "en", "toolgunsettings_antiSpam_tooltip", "Add tools in here and specify how many times they can use the tool per second!")

	slib.setLang("gprotect", "en", "physgunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "physgunsettings_enabled_tooltip", "Enable the physgun settings module?")
	slib.setLang("gprotect", "en", "physgunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "physgunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedPropsGroupLevel", "Group target level player owned props")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedPropsGroupLevel_tooltip", "Set the group level for each usergroup, this will determine if you can target someones prop based on the usergroup. Higher level means more immunity.")
	slib.setLang("gprotect", "en", "physgunsettings_DisableReloadUnfreeze", "Disable reload unfreeze")
	slib.setLang("gprotect", "en", "physgunsettings_DisableReloadUnfreeze_tooltip", "This will prevent people from unfreezing props using reload.")
	slib.setLang("gprotect", "en", "physgunsettings_PickupVehiclePermission", "Pickup vehicle permission")
	slib.setLang("gprotect", "en", "physgunsettings_PickupVehiclePermission_tooltip", "If people are in the usergroups in this list they can pickup vehicles!")
	slib.setLang("gprotect", "en", "physgunsettings_StopMotionOnDrop", "Stop motion on drop")
	slib.setLang("gprotect", "en", "physgunsettings_StopMotionOnDrop_tooltip", "This will prevent proppushing/propkilling.")
	slib.setLang("gprotect", "en", "physgunsettings_blockMultiplePhysgunning", "Block multiple physgunning")
	slib.setLang("gprotect", "en", "physgunsettings_blockMultiplePhysgunning_tooltip", "This will block an entity that is being physgunned from being physgunned by someone else!")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructs", "Max obstruct threshold")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructs_tooltip", "This is the threshold of how many obsctructs from blacklisted entities till it triggers!")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructsAction", "Max obstruct trigger action")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructsAction_tooltip", "This is the how to threat triggers (1 = Ghost, 2 = Freeze, 3 = Remove)")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbing", "Prevent prop climbing")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbing_tooltip", "This is a feature ment to make it more difficult to prop climb with a single prop.")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingThreshold", "Prop climbing threshold")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingThreshold_tooltip", "How many triggers should we allow per 10 seconds?")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingAction", "Prop climbing trigger action")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingAction_tooltip", "This is the how to threat triggers (1 = Ghost, 2 = Remove)")
	slib.setLang("gprotect", "en", "physgunsettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "physgunsettings_blockedEntities_tooltip", "Add entities into this and it wont be physgunable by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "physgunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "physgunsettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "gravitygunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "gravitygunsettings_enabled_tooltip", "Enable the gravity gun settings module?")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_DisableGravityGunPunting", "Disable gravity gun punting")
	slib.setLang("gprotect", "en", "gravitygunsettings_DisableGravityGunPunting_tooltip", "This is the throwing attack of the gravity gun.")
	slib.setLang("gprotect", "en", "gravitygunsettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_blockedEntities_tooltip", "Add entities into this and it cant be picked up by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "gravitygunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "gravitygunsettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "canpropertysettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "canpropertysettings_enabled_tooltip", "Enable the can property settings module?")
	slib.setLang("gprotect", "en", "canpropertysettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "canpropertysettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedProperties", "Blocked properties")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedProperties_tooltip", "Add properties to this list")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedPropertiesisBlacklist", "Blocked properties is blacklist")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "If ticked it will block the properties in the list from being used, otherwise you can only use those properties.")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedEntities_tooltip", "Add entities into this and it wont be targetable by anyone except for people in the bypass group!")
	slib.setLang("gprotect", "en", "canpropertysettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "canpropertysettings_bypassGroups_tooltip", "Groups in here will bypass the can property restriction list from above!")

	slib.setLang("gprotect", "en", "canusesettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "canusesettings_enabled_tooltip", "Enable the can use settings module?")
	slib.setLang("gprotect", "en", "canusesettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "canusesettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntities_tooltip", "Add entities into this and it cant be used by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntitiesisBlacklist", "Blocked entities is blacklist")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntitiesisBlacklist_tooltip", "If ticked it will block the entities in the list from being used, otherwise you can only use those entities.")
	slib.setLang("gprotect", "en", "canusesettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "canusesettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "advdupe2_enabled", "Enabled")
	slib.setLang("gprotect", "en", "advdupe2_enabled_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "advdupe2_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "advdupe2_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "advdupe2_PreventRopes", "Prevent rope spawning")
	slib.setLang("gprotect", "en", "advdupe2_PreventRopes_tooltip", "Prevent ropes from spawning! (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventScaling", "Prevent scaling")
	slib.setLang("gprotect", "en", "advdupe2_PreventScaling_tooltip", "Prevent Upscaled Props from spawning. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventNoGravity", "Prevent no gravity")
	slib.setLang("gprotect", "en", "advdupe2_PreventNoGravity_tooltip", "Prevent spawning props with no gravity. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventTrail", "Prevent trails")
	slib.setLang("gprotect", "en", "advdupe2_PreventTrail_tooltip", "Prevent spawning props with trails. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnreasonableValues", "Prevent unreasonable values")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnreasonableValues_tooltip", "Prevent entities with unreasonable values, this means position and or angles.")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnfreezeAll", "Prevent unfreeze all")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnfreezeAll_tooltip", "Prevent people from unfreezing all props.")
	slib.setLang("gprotect", "en", "advdupe2_BlacklistedCollisionGroups", "Blacklisted collision groups")
	slib.setLang("gprotect", "en", "advdupe2_BlacklistedCollisionGroups_tooltip", "This protects from props that you cannot target. NB:Values has to be collision ENUMs")
	slib.setLang("gprotect", "en", "advdupe2_WhitelistedConstraints", "Whitelisted constraints")
	slib.setLang("gprotect", "en", "advdupe2_WhitelistedConstraints_tooltip", "This is to prevent any unwanted constraints from being spawned.")
	slib.setLang("gprotect", "en", "advdupe2_whitelistedClasses", "Whitelisted entities")
	slib.setLang("gprotect", "en", "advdupe2_whitelistedClasses_tooltip", "This is a whitelist for SENTs to be spawned.")
	slib.setLang("gprotect", "en", "advdupe2_DelayBetweenUse", "Delay between use")
	slib.setLang("gprotect", "en", "advdupe2_DelayBetweenUse_tooltip", "This will prevent the people from spamming the tool, preventing lag. (0 = Disabled)")

	slib.setLang("gprotect", "en", "miscs_enabled", "Enabled")
	slib.setLang("gprotect", "en", "miscs_enabled_tooltip", "Enable the miscs module?")
	slib.setLang("gprotect", "en", "miscs_ClearDecals", "Clear decals timer")
	slib.setLang("gprotect", "en", "miscs_ClearDecals_tooltip", "Timer in seconds this will clear the decals for all the players on a timer :)")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_punishment", "Punishment blacklisted fading door mats")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_punishment_tooltip", "Int this will punish people for trying to use blacklisted mats (0 = Nothing, 1 = Notify, 2 = kick, 3 = ban).")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats", "Blacklisted fading door mats")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_tooltip", "Add bad materials into this list, 'pp/copy' and 'dev/upscale' for example.")
	slib.setLang("gprotect", "en", "miscs_FadingDoorLag", "Prevent fading door lag")
	slib.setLang("gprotect", "en", "miscs_FadingDoorLag_tooltip", "This will prevent people from crashing the server with fading door tool.")
	slib.setLang("gprotect", "en", "miscs_DisableMotion", "Disable motion")
	slib.setLang("gprotect", "en", "miscs_DisableMotion_tooltip", "This will disable the motion for all blacklisted entities.")
	slib.setLang("gprotect", "en", "miscs_DisableMotionEntities", "Disable motion entities")
	slib.setLang("gprotect", "en", "miscs_DisableMotionEntities_tooltip", "Entities in this list cannot be unfrozen.")
	slib.setLang("gprotect", "en", "miscs_freezeOnSpawn", "Freeze on spawn")
	slib.setLang("gprotect", "en", "miscs_freezeOnSpawn_tooltip", "This will freeze props on spawn")
	slib.setLang("gprotect", "en", "miscs_preventFadingDoorAbuse", "Prevent fading door abuse")
	slib.setLang("gprotect", "en", "miscs_preventFadingDoorAbuse_tooltip", "This will prevent obscuring people in fading doors")
	slib.setLang("gprotect", "en", "miscs_precisionMoveFix", "Prevent precision move abuse")
	slib.setLang("gprotect", "en", "miscs_precisionMoveFix_tooltip", "Prevents the move mode from being abused, could be used to bypass anti-obscuring and such.")
	slib.setLang("gprotect", "en", "miscs_preventSpawnNearbyPlayer", "Prevent spawn nearby player")
	slib.setLang("gprotect", "en", "miscs_preventSpawnNearbyPlayer_tooltip", "If someone are closer to the spawn position than this value it wont spawn the prop (0 Means disabled)")
	slib.setLang("gprotect", "en", "miscs_DRPEntForceOwnership", "Force ownership on DarkRP Entities")
	slib.setLang("gprotect", "en", "miscs_DRPEntForceOwnership_tooltip", "This will force the ownership of entities bought in the F4 Menu")
	slib.setLang("gprotect", "en", "miscs_DRPMaxObstructsOnPurchaseEnts", "Max obstructs on purchase for DarkRP Ents")
	slib.setLang("gprotect", "en", "miscs_DRPMaxObstructsOnPurchaseEnts_tooltip", "This will prevent spawning alot of DRP Entities inside of eachother!")
	slib.setLang("gprotect", "en", "miscs_DRPObstructsFilter", "Max obstructs filter DarkRP entities")
	slib.setLang("gprotect", "en", "miscs_DRPObstructsFilter_tooltip", "This is the filter for the max obstructs(1 = DRP Entitities, 2 = Props)")
end

slib.setLang("gprotect", "en", "insufficient-permission", "You do not have the privilege to do this!")
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/cl_menu.lua:
//
/*
	Smart Spawn Manager Menu
	5/12/2018
	Author: Smart ( Badass Development )
*/

local menu = {
	
	spawnData = {},
	configData = {},
	lastTab = "",
};

local sDerma = include("plugins/cl_derma.lua");
sDerma:SetTransitionDuration(0.2);
sDerma:GenerateFont("smartspawn_font_small", "Trebuchet MS", 18, 400);
sDerma:GenerateFont("smartspawn_font_medium", "Trebuchet MS", 20, 400);
sDerma:GenerateFont("smartspawn_font_large", "Trebuchet MS", 32, 400);

/*	
	Gets a team color by team name 
*/
function menu:GetTeamColorByName(name)

	for k,v in next, team.GetAllTeams() do 
	
		if (v.Name == name) then 
			return v.Color;
		end
	end
end

/*	
	Sends a net message to the server to edit spawns
*/
function menu:Edit(action, key, uniqueID)

	net.Start("smartspawn_edit");
	
		net.WriteTable({
			action = action,
			key = key,
			uniqueID = uniqueID,
		});
	net.SendToServer();
end

/*
	Sends a net message to the server to save config 
*/
function menu:SaveConfig()

	net.Start("smartspawn_edit");
	
		net.WriteTable({
			action = "config",
			bRenderSpawns = self.configData.bRenderSpawns,
			bPlayerSpawns = self.configData.bPlayerSpawns,
			bEntitySpawns = self.configData.bEntitySpawns,
			bOverrideSpawns = self.configData.bOverrideSpawns,
		});
	net.SendToServer();
end

/*
	Opens the control panel 
*/
function menu:ControlPanel()

	local frame = sDerma:Frame(nil, nil, 600, 500, smartspawn_config.lang.menuTitle);
	frame:MakePopup();
	
	local sheet = sDerma:PropertySheet();
	sheet:SetParent(frame);
	sheet:SetPos(5, 25);
	sheet:SetSize(frame:GetWide() - 10, frame:GetTall() - 30);
	
	// Config 
	local tab1 = sDerma:Panel();
	
	local list1 = sDerma:List();
	list1:SetParent(tab1);
	list1:SetPos(0, 10);
	list1:SetSize(sheet:GetWide() - 20, sheet:GetTall() - 42);
	list1:SetPadding(10);
	
	local renderSpawns = sDerma:DropDownSheet(smartspawn_config.lang.renderSpawns, {"Enabled", "Disabled"}, self.configData.bRenderSpawns && 1 || 2, sheet:GetWide(), 20, function(s, index, value, data)

		if (value == "Enabled") then 
			self.configData.bRenderSpawns = true;
		else 
			self.configData.bRenderSpawns = false;
		end
	end);
	list1:AddItem(renderSpawns);
	
	local playerSpawns = sDerma:DropDownSheet(smartspawn_config.lang.playerSpawns, {"Enabled", "Disabled"}, self.configData.bPlayerSpawns && 1 || 2, sheet:GetWide(), 20, function(s, index, value, data)

		if (value == "Enabled") then 
			self.configData.bPlayerSpawns = true;
		else 
			self.configData.bPlayerSpawns = false;
		end
	end);
	list1:AddItem(playerSpawns);
	
	local entitySpawns = sDerma:DropDownSheet(smartspawn_config.lang.entitySpawns, {"Enabled", "Disabled"}, self.configData.bEntitySpawns && 1 || 2, sheet:GetWide(), 20, function(s, index, value, data)

		if (value == "Enabled") then 
			self.configData.bEntitySpawns = true;
		else 
			self.configData.bEntitySpawns = false;
		end
	end);
	list1:AddItem(entitySpawns);
	
	local override = sDerma:DropDownSheet(smartspawn_config.lang.overrideSpawns, {"Enabled", "Disabled"}, self.configData.bOverrideSpawns && 1 || 2, sheet:GetWide(), 20, function(s, index, value, data)

		if (value == "Enabled") then 
			self.configData.bOverrideSpawns = true;
		else 
			self.configData.bOverrideSpawns = false;
		end
	end);
	list1:AddItem(override);
	
	local save = sDerma:Button(smartspawn_config.lang.saveChanges, function()
		self:SaveConfig();
		frame.Dismiss();
	end);
	list1:AddItem(save);
	
	local sheet1 = sheet:AddSheet(smartspawn_config.lang.tab1Title, tab1, "icon16/page.png");
	
	// Player spawns tab
	local tab2 = sDerma:Panel();
	
	local list2 = sDerma:List();
	list2:SetParent(tab2);
	list2:SetPos(0, 10);
	list2:SetSize(sheet:GetWide() - 20, sheet:GetTall() - 42);
	list2:SetPadding(10);
	
	for teamName, spawnTable in next, self.spawnData.playerSpawnPoints do 
	
		if (table.Count(spawnTable) < 1) then continue end
	
		local catList = sDerma:CollapsibleCategoryList(list1:GetWide(), 20, self:GetTeamColorByName(teamName));
		if (teamName == "all") then 
			catList:SetLabel("All Teams");
		else 
			catList:SetLabel(teamName);
		end
		
		for uniqueID, spawn in next, spawnTable do 
			local panel = sDerma:Panel();
			panel:SetSize(catList:GetWide(), 26);
			panel.Paint = function(s)
				
				draw.RoundedBox(4, 0, 0, s:GetWide(), s:GetTall(), Color(50, 50, 50, 255));
			end
			
			local idLabel = sDerma:Label(smartspawn_config.lang.uniqueID .. " " .. uniqueID, "smartspawn_font_small");
			idLabel:SetParent(panel);
			idLabel:SetPos(5, 5);
			
			local remove = sDerma:Button(smartspawn_config.lang.remove, function()
				
				self:Edit("remove_player_spawn", teamName, uniqueID);
				frame.Dismiss();
			end);
			remove:SetSize(100, 20);
			remove:SetParent(panel);
			remove:SetPos(panel:GetWide()-125, 3);
		
			catList:AddItem(panel);
		end
		list2:AddItem(catList);
	end
	
	local sheet2 = sheet:AddSheet(smartspawn_config.lang.tab2Title, tab2, "icon16/status_online.png");
	
	// Entity spawns tab 
	local tab3 = sDerma:Panel();

	local list3 = sDerma:List();
	list3:SetParent(tab3);
	list3:SetPos(0, 10);
	list3:SetSize(sheet:GetWide() - 20, sheet:GetTall() - 42);
	list3:SetPadding(10);
	
	for class, spawnTable in next, self.spawnData.entitySpawnPoints do 
	
		if (table.Count(spawnTable) < 1) then continue end
	
		local catList = sDerma:CollapsibleCategoryList(list1:GetWide(), 20);
		catList:SetLabel(class);
		
		for uniqueID, spawn in next, spawnTable do 
			local panel = sDerma:Panel();
			panel:SetSize(catList:GetWide(), 26);
			panel.Paint = function(s)
				
				draw.RoundedBox(4, 0, 0, s:GetWide(), s:GetTall(), Color(50, 50, 50, 255));
			end
			
			local idLabel = sDerma:Label(smartspawn_config.lang.uniqueID .. " " .. uniqueID .. " | Limit: " .. spawn.limit || 0, "smartspawn_font_small");
			idLabel:SetParent(panel);
			idLabel:SetPos(5, 5);
			
			local remove = sDerma:Button(smartspawn_config.lang.remove, function()
				
				self:Edit("remove_entity_spawn", class, uniqueID);
				frame.Dismiss();
			end);
			remove:SetSize(100, 20);
			remove:SetParent(panel);
			remove:SetPos(panel:GetWide()-125, 3);
		
			catList:AddItem(panel);
		end
		list3:AddItem(catList);
	end
	
	local sheet3 = sheet:AddSheet(smartspawn_config.lang.tab3Title, tab3, "icon16/box.png");
	
	frame.Think = function()
		if (sheet:GetActiveTab() == sheet1.Tab) then 
			self.lastTab = smartspawn_config.lang.tab1Title;
		elseif(sheet:GetActiveTab() == sheet2.Tab) then 
			self.lastTab = smartspawn_config.lang.tab2Title;
		elseif(sheet:GetActiveTab() == sheet3.Tab) then 
			self.lastTab = smartspawn_config.lang.tab3Title;
		end
	end
	
	sheet:SwitchToName(self.lastTab);
	
	sheet:DoPaintSetup();
	frame.Request();
end 

/*
	Receives a net message to open the control panel 
*/
function menu.ReceiveOpenControlPanel()
	// Process data
	local dataBuffer = net.ReadTable();
	
	menu.spawnData = dataBuffer.spawnData;
	menu.configData = dataBuffer.configData;
	menu:ControlPanel();
end 
net.Receive("smartspawn_controlpanel", menu.ReceiveOpenControlPanel);
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_french.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_german.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_darkrpmoney.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_darkrpmoney.lua:
sReward.RegisterReward("darkrp_money", function(ply, amount)
    if !isfunction(ply.addMoney) then return end
    ply:addMoney(amount)
end, Material("sreward/money.png", "smooth"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_elevel.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_wos.lua:
return gluapack()()
--PATH lua/streamradio_core/_load.lua:
return gluapack()()
--PATH lua/streamradio_core/string_accents.lua:
return gluapack()()
--PATH lua/streamradio_core/util.lua:
return gluapack()()
--PATH lua/streamradio_core/util.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Util = StreamRadioLib.Util or {}

local LIB = StreamRadioLib.Util
table.Empty(LIB)

local LIBString = StreamRadioLib.String

local g_debug = false
local g_debug_nextcheck = 0

function LIB.IsDebug()
	local now = RealTime()

	if g_debug_nextcheck > now then
		return g_debug
	end

	g_debug_nextcheck = now + 1
	g_debug = false

	local devconvar = GetConVar("developer")
	if not devconvar then
		return false
	end

	if devconvar:GetInt() <= 0 then
		return false
	end

	g_debug = true
	return true
end

function LIB.GameIsPaused()
	local frametime = FrameTime()

	if frametime > 0 then
		return false
	end

	return true
end

function LIB.ErrorNoHaltWithStack(err)
	err = tostring(err or "")
	ErrorNoHaltWithStack(err)
end

local catchAndNohalt = function(err)
	local msgstring = tostring(err or "")
	msgstring = string.Trim(StreamRadioLib.AddonPrefix .. msgstring) .. "\n"

	LIB.ErrorNoHaltWithStack(err)

	return err
end

function LIB.CatchAndErrorNoHaltWithStack(func, ...)
	return xpcall(func, catchAndNohalt, ...)
end

function LIB.Hash(str)
	str = tostring(str or "")

	local salt = "StreamRadioLib_Hash20230810"

	local data = string.format(
		"[%s][%s]",
		salt,
		str
	)

	local hash = util.SHA256(data)
	return hash
end

local g_uid = 0
function LIB.Uid()
	g_uid = (g_uid + 1) % (2 ^ 30)
	return g_uid
end

local g_createCacheArrayMeta = {
	Set = function(self, cacheid, data, expires)
		if cacheid == nil then
			return
		end

		if data == nil then
			self:Remove(cacheid)
			return
		end

		if self.limit > 0 and self.count > self.limit then
			self:Empty()
		end

		local cache = self.cache
		local cacheItem = cache[cacheid]

		if not cacheItem then
			cacheItem = {}
			cache[cacheid] = cacheItem

			self.count = self.count + 1
		end

		cacheItem.data = data
		cacheItem.expires = expires
	end,

	Get = function(self, cacheid, now)
		if cacheid == nil then
			return nil
		end

		local cache = self.cache
		local cacheItem = cache[cacheid]

		if not cacheItem then
			return nil
		end

		local data = cacheItem.data
		if data == nil then
			self:Remove(cacheid)
			return nil
		end

		now = now or 0
		local expires = cacheItem.expires or 0

		if now > 0 and expires > 0 and expires < now then
			self:Remove(cacheid)
			return nil
		end

		return data
	end,

	Remove = function(self, cacheid)
		if cacheid == nil then
			return
		end

		local cache = self.cache
		if cache[cacheid] == nil then
			return
		end

		cache[cacheid] = nil
		self.count = math.max(self.count - 1, 0)
	end,

	Has = function(self, cacheid, now)
		return self:Get(cacheid, now) ~= nil
	end,

	Empty = function(self)
		LIB.EmptyTableSafe(self.cache)
		self.count = 0
	end,

	Count = function(self)
		return self.count
	end,
}

g_createCacheArrayMeta.__index = g_createCacheArrayMeta

function LIB.CreateCacheArray(limit)
	local cache = {}

	cache.cache = {}
	cache.limit = math.max(limit or 0, 0)
	cache.count = 0

	setmetatable(cache, g_createCacheArrayMeta)

	return cache
end

function LIB.EmptyTableSafe(tab)
	if not tab then
		return
	end

	table.Empty(tab)
end

function LIB.GetMainDirectory(directory)
	local baseDirectory = StreamRadioLib.DataDirectory or ""

	if baseDirectory == "" then
		error("StreamRadioLib.DataDirectory is empty")
		return
	end

	directory = tostring(directory or "")

	local mainPath = baseDirectory .. "/" .. directory
	mainPath = LIBString.NormalizeSlashes(mainPath)

	return mainPath
end

function LIB.CreateDirectoryForFile(path)
	local baseDirectory = StreamRadioLib.DataDirectory or ""

	if baseDirectory == "" then
		return false
	end

	path = tostring(path or "")

	if path == "" then
		return false
	end

	if not string.StartsWith(path, baseDirectory) then
		return false
	end

	local directory = string.GetPathFromFilename(path) or ""
	if directory == "" then return true end

	if not file.IsDir(directory, "DATA") then
		file.CreateDir(directory)
	end

	return file.IsDir(directory, "DATA")
end

function LIB.DeleteFolder(path)
	local baseDirectory = StreamRadioLib.DataDirectory or ""

	if baseDirectory == "" then
		return false
	end

	path = tostring(path or "")

	if path == "" then
		return false
	end

	if not string.StartsWith(path, baseDirectory) then
		return false
	end

	local files, folders = file.Find(path .. "/*", "DATA")

	for k, v in ipairs(files or {}) do
		file.Delete(path .. "/" .. v)
	end

	for k, v in ipairs(folders or {}) do
		LIB.DeleteFolder(path .. "/" .. v)
	end

	file.Delete(path)

	if file.Exists(path, "DATA") then
		return false
	end

	if file.IsDir(path, "DATA") then
		return false
	end

	return true
end

local g_cache_IsValidModel = {}
local g_cache_IsValidModelFile = {}

function LIB.GetDefaultModel()
	local defaultModel = Model("models/sligwolf/grocel/radio/radio.mdl")
	return defaultModel
end

function LIB.IsValidModel(model)
	model = tostring(model or "")

	if g_cache_IsValidModel[model] then
		return true
	end

	g_cache_IsValidModel[model] = nil

	if not LIB.IsValidModelFile(model) then
		return false
	end

	util.PrecacheModel(model)

	if not util.IsValidModel(model) then
		return false
	end

	if not util.IsValidProp(model) then
		return false
	end

	g_cache_IsValidModel[model] = true
	return true
end

function LIB.IsValidModelFile(model)
	model = tostring(model or "")

	if g_cache_IsValidModelFile[model] then
		return true
	end

	g_cache_IsValidModelFile[model] = nil

	if model == "" then
		return false
	end

	if IsUselessModel(model) then
		return false
	end

	if not file.Exists(model, "GAME") then
		return false
	end

	g_cache_IsValidModelFile[model] = true
	return true
end

function LIB.FrameNumber()
	local frame = nil

	if CLIENT then
		frame = FrameNumber()
	else
		frame = engine.TickCount()
	end

	return frame
end

function LIB.RealFrameTime()
	local frameTime = nil

	if CLIENT then
		frameTime = RealFrameTime()
	else
		frameTime = FrameTime()
	end

	return frameTime
end

function LIB.RealTimeFps()
	local fps = LIB.RealFrameTime()

	if fps <= 0 then
		return 0
	end

	fps = 1 / fps

	return fps
end

local g_LastFrameRegister = {}
local g_LastFrameRegisterCount = 0

function LIB.IsSameFrame(id)
	local id = tostring(id or "")
	local lastFrame = g_LastFrameRegister[id]

	local frame = LIB.FrameNumber()

	if not lastFrame or frame ~= lastFrame then

		-- prevent the cache from overflowing
		if g_LastFrameRegisterCount > 1024 then
			LIB.EmptyTableSafe(g_LastFrameRegister)
			g_LastFrameRegisterCount = 0
		end

		g_LastFrameRegister[id] = frame

		if not lastFrame then
			g_LastFrameRegisterCount = g_LastFrameRegisterCount + 1
		end

		return false
	end

	return true
end

function LIB.IsAdmin(ply)
	if CLIENT and not IsValid(ply) then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return false
	end

	if not ply:IsAdmin() then
		return false
	end

	return true
end

function LIB.IsAdminForCMD(ply)
	if not IsValid(ply) then
		return true
	end

	if not LIB.IsAdmin(ply) then
		return false
	end

	return true
end

return true


--PATH lua/streamradio_core/convar.lua:
local StreamRadioLib = StreamRadioLib

local g_allowSpectrum = false
local g_streamUrlLogMode = 1
local g_enableUrlWhitelist = true
local g_enableUrlWhitelistOnCFCWhitelist = true
local g_enableUrlWhitelistTrustAdminRadios = true

local g_lastThink = 0

local g_cvMaxServerSpectrum = CreateConVar(
	"sv_streamradio_max_spectrums",
	"5",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Sets the maximum count of radios that can have advanced wire outputs such as FFT spectrum or song tags. 0 = Off, Default: 5"
)

local g_cvStreamUrlLogMode = CreateConVar(
	"sv_streamradio_url_log_mode",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Log stream URLs to console. Always logs all URLs on developer > 0. 0 = Disable, 1 = Online URLs only, 2 = All URLs, Default: 1"
)

local g_cvUrlWhitelistEnable = CreateConVar(
	"sv_streamradio_url_whitelist_enable",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Enables the Stream URL whitelist. When enabled only URLs listed in playlists can be played. DATA SECURITY: Keep it enabled for better server security. Only turn it off if you know what you are doing! 0 = Disable, 1 = Enable, Default: 1"
)

local g_cvUrlWhitelistEnableOnCFCWhitelist = CreateConVar(
	"sv_streamradio_url_whitelist_enable_on_cfcwhitelist",
	"0",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Enables built-in Stream URL whitelist even if 'CFC Client HTTP Whitelist' is installed and 'sv_streamradio_url_whitelist_enable' is on. Otherwise built-in whitelist stays inactive as long CFC's one is active. 0 = Disable, 1 = Enable, Default: 0"
)

local g_cvUrlWhitelistTrustAdminRadios = CreateConVar(
	"sv_streamradio_url_whitelist_trust_admin_radios",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Trust Stream URLs from radios owned by admins. Skips built-in whitelist checks for admin radios. 0 = No, 1 = Yes, Default: 1"
)

local g_cvRebuildCommunityPlaylists = CreateConVar(
	"sv_streamradio_rebuildplaylists_community_auto",
	"2",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Set how the community playlists are rebuild on server start. 0 = Off, 1 = Rebuild only, 2 = Delete and rebuild, Default: 2"
)

CreateConVar(
	"sv_streamradio_bass3_allow_client",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Allows connected clients to use GM_BASS3 when set to 1. Overrides cl_streamradio_bass3_enable. Default: 1",
	0,
	1
)

CreateConVar(
	"sv_streamradio_bass3_enable",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL ),
	"Use GM_BASS3 on the server if installed and when the ConVar is set to 1. Default: 1",
	0,
	1
)

function StreamRadioLib.AllowSpectrum()
	return g_allowSpectrum
end

function StreamRadioLib.IsUrlWhitelistEnabled()
	return g_enableUrlWhitelist
end

function StreamRadioLib.IsUrlWhitelistEnabledOnCFCWhitelist()
	return g_enableUrlWhitelistOnCFCWhitelist
end

function StreamRadioLib.IsUrlWhitelistAdminRadioTrusted()
	return g_enableUrlWhitelistTrustAdminRadios
end

function StreamRadioLib.GetStreamLogMode()
	return g_streamUrlLogMode
end

function StreamRadioLib.GetRebuildCommunityPlaylistsMode()
	local mode = g_cvRebuildCommunityPlaylists:GetInt()
	mode = math.Clamp(mode, 0, 2)

	return mode
end

local function calcAllowSpectrum()
	if not WireAddon then return false end
	if not StreamRadioLib.Bass.CanLoadDLL() then return false end

	local max = g_cvMaxServerSpectrum:GetInt()
	if max == 0 then return false end

	return StreamRadioLib.GetStreamingRadioCount() < max
end

local function calcStreamUrlLogMode()
	if StreamRadioLib.Util.IsDebug() then
		return StreamRadioLib.LOG_STREAM_URL_ALL
	end

	local mode = g_cvStreamUrlLogMode:GetInt()
	mode = math.Clamp(mode, 0, 2)

	return mode
end

local function calcUrlWhitelistEnabled()
	if game.SinglePlayer() then return false end
	if not g_cvUrlWhitelistEnable:GetBool() then return false end

	if g_enableUrlWhitelistOnCFCWhitelist then
		-- We always enable the built-in whitelist then
		return true
	end

	if StreamRadioLib.Cfchttp.CanCheckWhitelist() then
		-- CFC Client HTTP whitelist is available, disable our whitelist system then.
		return false
	end

	return true
end

local function calcUrlWhitelistEnabledOnCFCWhitelist()
	if game.SinglePlayer() then return false end
	if not g_cvUrlWhitelistEnableOnCFCWhitelist:GetBool() then return false end

	return true
end

local function calcUrlWhitelistEnabledTrustAdminRadios()
	if game.SinglePlayer() then return true end
	if not g_cvUrlWhitelistTrustAdminRadios:GetBool() then return false end

	return true
end

local function updateUrlWhitelistEnabled()
	if CLIENT then return end

	StreamRadioLib.Whitelist.InvalidateCache()
end

StreamRadioLib.Hook.Add("Think", "ConvarsUpdate", function()
	local now = RealTime()

	if g_lastThink < now then
		g_allowSpectrum = calcAllowSpectrum()
		g_streamUrlLogMode = calcStreamUrlLogMode()

		local old_enableUrlWhitelist = g_enableUrlWhitelist
		local old_enableUrlWhitelistOnCFCWhitelist = g_enableUrlWhitelistOnCFCWhitelist

		g_enableUrlWhitelistTrustAdminRadios = calcUrlWhitelistEnabledTrustAdminRadios()
		g_enableUrlWhitelistOnCFCWhitelist = calcUrlWhitelistEnabledOnCFCWhitelist()
		g_enableUrlWhitelist = calcUrlWhitelistEnabled()

		if old_enableUrlWhitelist ~= g_enableUrlWhitelist or old_enableUrlWhitelistOnCFCWhitelist ~= g_enableUrlWhitelistOnCFCWhitelist then
			updateUrlWhitelistEnabled()
		end

		g_lastThink = now + 1 + math.random()
	end
end)

return true


--PATH lua/streamradio_core/skin.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Skin = StreamRadioLib.Skin or {}

local LIB = StreamRadioLib.Skin
table.Empty(LIB)

local _default_json = [[
{
	"children":
	{
		"main":
		{
			"children":
			{
				"browser":
				{
					"children":
					{
						"error":
						{
							"children":
							{
								"textbox":
								{
									"data":
									{
										"color_foreground":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_shadow":
										{
											"r": 40,
											"b": 40,
											"a": 255,
											"g": 40
										},
										"color":
										{
											"r": 128,
											"b": 0,
											"a": 255,
											"g": 32
										}
									},
									"children":
									{
										"scrollbar":
										{
											"children":
											{
												"bar":
												{
													"data":
													{
														"color_foreground_hover":
														{
															"r": 0,
															"b": 0,
															"a": 255,
															"g": 0
														},
														"color_icon_disabled":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color":
														{
															"r": 0,
															"b": 128,
															"a": 255,
															"g": 128
														},
														"color_foreground_disabled":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_hover":
														{
															"r": 150,
															"b": 150,
															"a": 255,
															"g": 150
														},
														"color_icon":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_foreground":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_shadow":
														{
															"r": 40,
															"b": 40,
															"a": 255,
															"g": 40
														},
														"color_disabled":
														{
															"r": 100,
															"b": 100,
															"a": 255,
															"g": 100
														},
														"color_icon_hover":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														}
													}
												},
												"button":
												{
													"data":
													{
														"color_foreground_hover":
														{
															"r": 0,
															"b": 0,
															"a": 255,
															"g": 0
														},
														"color_icon_disabled":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color":
														{
															"r": 0,
															"b": 128,
															"a": 255,
															"g": 128
														},
														"color_foreground_disabled":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_hover":
														{
															"r": 150,
															"b": 150,
															"a": 255,
															"g": 150
														},
														"color_icon":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_foreground":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														},
														"color_shadow":
														{
															"r": 40,
															"b": 40,
															"a": 255,
															"g": 40
														},
														"color_disabled":
														{
															"r": 100,
															"b": 100,
															"a": 255,
															"g": 100
														},
														"color_icon_hover":
														{
															"r": 255,
															"b": 255,
															"a": 255,
															"g": 255
														}
													}
												}
											}
										}
									}
								},
								"button":
								{
									"data":
									{
										"color_foreground_hover":
										{
											"r": 0,
											"b": 0,
											"a": 255,
											"g": 0
										},
										"color_icon_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color":
										{
											"r": 0,
											"b": 128,
											"a": 255,
											"g": 128
										},
										"color_foreground_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_hover":
										{
											"r": 150,
											"b": 150,
											"a": 255,
											"g": 150
										},
										"color_icon":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_foreground":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_shadow":
										{
											"r": 40,
											"b": 40,
											"a": 255,
											"g": 40
										},
										"color_disabled":
										{
											"r": 100,
											"b": 100,
											"a": 255,
											"g": 100
										},
										"color_icon_hover":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										}
									}
								}
							}
						},
						"header":
						{
							"data":
							{
								"color_foreground":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_shadow":
								{
									"r": 40,
									"b": 40,
									"a": 255,
									"g": 40
								},
								"color":
								{
									"r": 0,
									"b": 0,
									"a": 255,
									"g": 100
								}
							}
						},
						"list":
						{
							"children":
							{
								"button":
								{
									"data":
									{
										"color_foreground_hover":
										{
											"r": 0,
											"b": 0,
											"a": 255,
											"g": 0
										},
										"color_icon_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color":
										{
											"r": 0,
											"b": 128,
											"a": 255,
											"g": 128
										},
										"color_foreground_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_hover":
										{
											"r": 150,
											"b": 150,
											"a": 255,
											"g": 150
										},
										"color_icon":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_foreground":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_shadow":
										{
											"r": 40,
											"b": 40,
											"a": 255,
											"g": 40
										},
										"color_disabled":
										{
											"r": 100,
											"b": 100,
											"a": 255,
											"g": 100
										},
										"color_icon_hover":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										}
									}
								},
								"scrollbar":
								{
									"children":
									{
										"bar":
										{
											"data":
											{
												"color_foreground_hover":
												{
													"r": 0,
													"b": 0,
													"a": 255,
													"g": 0
												},
												"color_icon_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color":
												{
													"r": 0,
													"b": 128,
													"a": 255,
													"g": 128
												},
												"color_foreground_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_hover":
												{
													"r": 150,
													"b": 150,
													"a": 255,
													"g": 150
												},
												"color_icon":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_foreground":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_shadow":
												{
													"r": 40,
													"b": 40,
													"a": 255,
													"g": 40
												},
												"color_disabled":
												{
													"r": 100,
													"b": 100,
													"a": 255,
													"g": 100
												},
												"color_icon_hover":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												}
											}
										},
										"button":
										{
											"data":
											{
												"color_foreground_hover":
												{
													"r": 0,
													"b": 0,
													"a": 255,
													"g": 0
												},
												"color_icon_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color":
												{
													"r": 0,
													"b": 128,
													"a": 255,
													"g": 128
												},
												"color_foreground_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_hover":
												{
													"r": 150,
													"b": 150,
													"a": 255,
													"g": 150
												},
												"color_icon":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_foreground":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_shadow":
												{
													"r": 40,
													"b": 40,
													"a": 255,
													"g": 40
												},
												"color_disabled":
												{
													"r": 100,
													"b": 100,
													"a": 255,
													"g": 100
												},
												"color_icon_hover":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												}
											}
										}
									}
								}
							}
						},
						"sidebutton":
						{
							"data":
							{
								"color_foreground_hover":
								{
									"r": 0,
									"b": 0,
									"a": 255,
									"g": 0
								},
								"color_icon_disabled":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color":
								{
									"r": 0,
									"b": 128,
									"a": 255,
									"g": 128
								},
								"color_foreground_disabled":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_hover":
								{
									"r": 150,
									"b": 150,
									"a": 255,
									"g": 150
								},
								"color_icon":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_foreground":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_shadow":
								{
									"r": 40,
									"b": 40,
									"a": 255,
									"g": 40
								},
								"color_disabled":
								{
									"r": 100,
									"b": 100,
									"a": 255,
									"g": 100
								},
								"color_icon_hover":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								}
							}
						}
					}
				},
				"player":
				{
					"children":
					{
						"header":
						{
							"data":
							{
								"color_foreground":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_shadow":
								{
									"r": 40,
									"b": 40,
									"a": 255,
									"g": 40
								},
								"color":
								{
									"r": 0,
									"b": 0,
									"a": 255,
									"g": 100
								}
							}
						},
						"button":
						{
							"data":
							{
								"color_foreground_hover":
								{
									"r": 0,
									"b": 0,
									"a": 255,
									"g": 0
								},
								"color_icon_disabled":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color":
								{
									"r": 0,
									"b": 128,
									"a": 255,
									"g": 128
								},
								"color_foreground_disabled":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_hover":
								{
									"r": 150,
									"b": 150,
									"a": 255,
									"g": 150
								},
								"color_icon":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_foreground":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								},
								"color_shadow":
								{
									"r": 40,
									"b": 40,
									"a": 255,
									"g": 40
								},
								"color_disabled":
								{
									"r": 100,
									"b": 100,
									"a": 255,
									"g": 100
								},
								"color_icon_hover":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								}
							}
						},
						"controls":
						{
							"children":
							{
								"button":
								{
									"data":
									{
										"color_foreground_hover":
										{
											"r": 0,
											"b": 0,
											"a": 255,
											"g": 0
										},
										"color_icon_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color":
										{
											"r": 0,
											"b": 128,
											"a": 255,
											"g": 128
										},
										"color_foreground_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_hover":
										{
											"r": 150,
											"b": 150,
											"a": 255,
											"g": 150
										},
										"color_icon":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_foreground":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_shadow":
										{
											"r": 40,
											"b": 40,
											"a": 255,
											"g": 40
										},
										"color_disabled":
										{
											"r": 100,
											"b": 100,
											"a": 255,
											"g": 100
										},
										"color_icon_hover":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										}
									}
								},
								"progressbar":
								{
									"data":
									{
										"color_foreground_hover":
										{
											"r": 0,
											"b": 0,
											"a": 255,
											"g": 0
										},
										"color_icon_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color":
										{
											"r": 0,
											"b": 128,
											"a": 255,
											"g": 128
										},
										"color_foreground_disabled":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_hover":
										{
											"r": 150,
											"b": 150,
											"a": 255,
											"g": 150
										},
										"color_icon":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_foreground":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										},
										"color_shadow":
										{
											"r": 40,
											"b": 40,
											"a": 255,
											"g": 40
										},
										"color_disabled":
										{
											"r": 100,
											"b": 100,
											"a": 255,
											"g": 100
										},
										"color_icon_hover":
										{
											"r": 255,
											"b": 255,
											"a": 255,
											"g": 255
										}
									}
								}
							}
						},
						"spectrum":
						{
							"children":
							{
								"error":
								{
									"children":
									{
										"textbox":
										{
											"data":
											{
												"color_foreground":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_shadow":
												{
													"r": 40,
													"b": 40,
													"a": 255,
													"g": 40
												},
												"color":
												{
													"r": 128,
													"b": 0,
													"a": 255,
													"g": 32
												}
											},
											"children":
											{
												"scrollbar":
												{
													"children":
													{
														"bar":
														{
															"data":
															{
																"color_foreground_hover":
																{
																	"r": 0,
																	"b": 0,
																	"a": 255,
																	"g": 0
																},
																"color_icon_disabled":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color":
																{
																	"r": 0,
																	"b": 128,
																	"a": 255,
																	"g": 128
																},
																"color_foreground_disabled":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_hover":
																{
																	"r": 150,
																	"b": 150,
																	"a": 255,
																	"g": 150
																},
																"color_icon":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_foreground":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_shadow":
																{
																	"r": 40,
																	"b": 40,
																	"a": 255,
																	"g": 40
																},
																"color_disabled":
																{
																	"r": 100,
																	"b": 100,
																	"a": 255,
																	"g": 100
																},
																"color_icon_hover":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																}
															}
														},
														"button":
														{
															"data":
															{
																"color_foreground_hover":
																{
																	"r": 0,
																	"b": 0,
																	"a": 255,
																	"g": 0
																},
																"color_icon_disabled":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color":
																{
																	"r": 0,
																	"b": 128,
																	"a": 255,
																	"g": 128
																},
																"color_foreground_disabled":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_hover":
																{
																	"r": 150,
																	"b": 150,
																	"a": 255,
																	"g": 150
																},
																"color_icon":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_foreground":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																},
																"color_shadow":
																{
																	"r": 40,
																	"b": 40,
																	"a": 255,
																	"g": 40
																},
																"color_disabled":
																{
																	"r": 100,
																	"b": 100,
																	"a": 255,
																	"g": 100
																},
																"color_icon_hover":
																{
																	"r": 255,
																	"b": 255,
																	"a": 255,
																	"g": 255
																}
															}
														}
													}
												}
											}
										},
										"button":
										{
											"data":
											{
												"color_foreground_hover":
												{
													"r": 0,
													"b": 0,
													"a": 255,
													"g": 0
												},
												"color_icon_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color":
												{
													"r": 0,
													"b": 128,
													"a": 255,
													"g": 128
												},
												"color_foreground_disabled":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_hover":
												{
													"r": 150,
													"b": 150,
													"a": 255,
													"g": 150
												},
												"color_icon":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_foreground":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												},
												"color_shadow":
												{
													"r": 40,
													"b": 40,
													"a": 255,
													"g": 40
												},
												"color_disabled":
												{
													"r": 100,
													"b": 100,
													"a": 255,
													"g": 100
												},
												"color_icon_hover":
												{
													"r": 255,
													"b": 255,
													"a": 255,
													"g": 255
												}
											}
										}
									}
								}
							},
							"data":
							{
								"color_shadow":
								{
									"r": 40,
									"b": 40,
									"a": 255,
									"g": 40
								},
								"color_foreground":
								{
									"r": 192,
									"b": 0,
									"a": 255,
									"g": 0
								},
								"color":
								{
									"r": 64,
									"b": 0,
									"a": 255,
									"g": 32
								},
								"color_icon":
								{
									"r": 255,
									"b": 255,
									"a": 255,
									"g": 255
								}
							}
						}
					}
				}
			},
			"data":
			{
				"color":
				{
					"r": 0,
					"b": 64,
					"a": 255,
					"g": 0
				}
			}
		}
	},
	"data":
	{
		"color_border":
		{
			"r": 0,
			"b": 128,
			"a": 255,
			"g": 64
		},
		"color_cursor":
		{
			"r": 255,
			"b": 255,
			"a": 255,
			"g": 255
		}
	}
}
]]

LIB._default = nil
function LIB.GetDefaultSkin()
	if LIB._default and LIB._default.data then
		return table.Copy(LIB._default)
	end

	LIB._default = StreamRadioLib.JSON.Decode(_default_json or "") or {}
	if not LIB._default.data then
		LIB._default = nil
		error("Default skin is corrupted!")
		return nil
	end

	return table.Copy(LIB._default)
end

return true


--PATH lua/streamradio_core/models/cs_office_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/default.lua:
return gluapack()()
--PATH lua/streamradio_core/models/hl2_crtscreen_small.lua:
return gluapack()()
--PATH lua/streamradio_core/models/hl2_crtscreen_small.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- HL2 Small CRT Screen
RADIOMDL.model = "models/props_lab/monitor01b.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0.25, 0, 4.5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 89.65)

                              --      F,     R,     U
RADIOMDL.DisplayOffset    = Vector(6.30, -5.45,  4.95) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(6.30,  3.40, -4.10) -- Bottom Right

RADIOMDL.DisplayWidth = 700
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {25,	1000},
	Small	= {18,	700},
	Default	= {23,	700},
	Tooltip	= {23,	800},
	Big		= {25,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 45)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/portal_turret.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 1 Turret
RADIOMDL.model = "models/props/turret_01.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SoundPosOffset = Vector( 5, 0, 37 )
RADIOMDL.SoundAngOffset = Angle( 0, 0, 0 )

RADIOMDL.WingCloseTime = 0.371
RADIOMDL.WingOpenTime = 0.319
RADIOMDL.WingSpan = 8

RADIOMDL.WingCloseSound = "NPC_FloorTurret.Retire"
RADIOMDL.WingOpenSound = "NPC_FloorTurret.Deploy"
RADIOMDL.WingSpawnSound = "NPC_FloorTurret.TalkActive"

function RADIOMDL:Initialize(ent)
	if SERVER then return end

	ent:EmitSound(self.WingSpawnSound)

	self.RightWingDir = 1
	self.LeftWingDir = 1

	self.RightSwapTime = CurTime()
	self.LeftSwapTime = CurTime()

	self.WingOpened = false
	self.WingClosed = true
	self.PixVis = util.GetPixelVisibleHandle()
	self.EyeColor = Color(0, 128, 255)
	self.EyeColorDyn = Color(64, 0, 0)
	self.EyeColorLoading = Color(255, 255, 0)
	self.EyeColorError = Color(255, 128, 0)

	self._State = 0

	self:CloseWings(true)
end

function RADIOMDL:AnimReset(ent)
	if SERVER then return end

	self.RightWingDir = 1
	self.LeftWingDir = 1

	self.RightSwapTime = CurTime()
	self.LeftSwapTime = CurTime()

	self.EyeColor = Color(0, 128, 255)

	self:CloseWings(true)
end

function RADIOMDL:OnSearch(ent, stream)
	if SERVER then return end

	self.EyeColor = self.EyeColorLoading
	self:CloseWings()
end

function RADIOMDL:WhileLoading(ent)
	if SERVER then return end

	self.EyeColor = self.EyeColorLoading
	self:CloseWings()
end

function RADIOMDL:WhileError(ent)
	if SERVER then return end

	self.EyeColor = self.EyeColorError
	self:CloseWings()
end

function RADIOMDL:OnPlay(ent, stream)
	if SERVER then return end

	self.RightWingDir = 1
	self.LeftWingDir = 1

	self.RightSwapTime = CurTime()
	self.LeftSwapTime = CurTime()

	self.EyeColor = self.EyeColorDyn
	self:OpenWings()
end

function RADIOMDL:OnError(ent, stream)
	if SERVER then return end

	self.RightWingDir = 1
	self.LeftWingDir = 1

	self.RightSwapTime = CurTime()
	self.LeftSwapTime = CurTime()

	self.EyeColor = self.EyeColorError

	self:CloseWings()
end

function RADIOMDL:OnStop(ent, stream)
	if SERVER then return end

	self.RightWingDir = 1
	self.LeftWingDir = 1

	self.RightSwapTime = CurTime()
	self.LeftSwapTime = CurTime()

	self.EyeColor = Color(0, 128, 255)

	self:CloseWings()
	self._State = 10
end

function RADIOMDL:_StateCloseWings(ent)
	local RightWing = ent:LookupBone( "RT_Wing" ) or 0
	local LeftWing = ent:LookupBone( "LFT_Wing" ) or 0

	local RPos = math.Clamp(self.RightWing or 0, 0, 1)
	local LPos = math.Clamp(self.LeftWing or 0, 0, 1)

	if RPos <= 0 and LPos <= 0 then
		self.WingOpened = false
		self.WingClosed = true
		self._State = 0
		return true
	end

	ent:ManipulateBonePosition( RightWing, Vector( RPos * self.WingSpan, 0, 0 ) )
	ent:ManipulateBonePosition( LeftWing, Vector( -LPos * self.WingSpan, 0, 0 ) )

	self.RightWing = math.max(RPos - self.LastTickTime / self.WingCloseTime, 0)
	self.LeftWing = math.max(LPos - self.LastTickTime / self.WingCloseTime, 0)
end

function RADIOMDL:_StateOpenWings(ent)
	local RightWing = ent:LookupBone( "RT_Wing" ) or 0
	local LeftWing = ent:LookupBone( "LFT_Wing" ) or 0

	local RPos = math.Clamp(self.RightWing or 0, 0, 0.5)
	local LPos = math.Clamp(self.LeftWing or 0, 0, 0.5)

	if RPos >= 0.5 and LPos >= 0.5 then
		self.WingClosed = false
		self.WingOpened = true
		self._State = 0
		return true
	end

	ent:ManipulateBonePosition( RightWing, Vector( RPos * self.WingSpan, 0, 0 ) )
	ent:ManipulateBonePosition( LeftWing, Vector( -LPos * self.WingSpan, 0, 0 ) )

	self.RightWing = math.min(RPos + self.LastTickTime / self.WingOpenTime / 2, 0.5)
	self.LeftWing = math.min(LPos + self.LastTickTime / self.WingOpenTime / 2, 0.5)
end

function RADIOMDL:Think(ent)
	local now = CurTime()

	self.LastTickTime = now - (self.LastTick or now)
	self.LastTick = now

	if self._State == 10 then
		ent:EmitSound(self.WingCloseSound)
		self._State = 1
	end

	if self._State == 1 then
		self:_StateCloseWings(ent)
		return
	end

	if self._State == 20 then
		ent:EmitSound(self.WingOpenSound)
		self._State = 2
	end

	if self._State == 2 then
		self:_StateOpenWings(ent)
		return
	end
end

local g_mat_glow = Material("sprites/light_glow02_add_noz")
local g_mat_bg = Material("debug/debugvertexcolor")
local g_mat_bg2 = Material("sprites/light_glow02_add")
local g_glow_pos = Vector(12.5, 0, 36.75)

function RADIOMDL:Draw(ent)
	local glowpos = ent:LocalToWorld(g_glow_pos)
	local offset = 3

	local quadpos1 = ent:LocalToWorld(g_glow_pos + Vector(-0.30,  offset,  offset))
	local quadpos2 = ent:LocalToWorld(g_glow_pos + Vector(-0.30,  offset, -offset))
	local quadpos3 = ent:LocalToWorld(g_glow_pos + Vector(-0.30, -offset, -offset))
	local quadpos4 = ent:LocalToWorld(g_glow_pos + Vector(-0.30, -offset,  offset))

	render.SetMaterial(g_mat_bg)
	render.DrawQuad(
		quadpos1,
		quadpos2,
		quadpos3,
		quadpos4,
		color_black
	)

	render.SetMaterial(g_mat_bg2)
	render.DrawQuad(
		quadpos1,
		quadpos2,
		quadpos3,
		quadpos4,
		Color(self.EyeColor.r > 0 and 255 or 0, self.EyeColor.g, self.EyeColor.b)
	)

	local Visibile = util.PixelVisible(glowpos, 3, self.PixVis)

	if not Visibile then return end
	if Visibile < 0.50 then return end

	render.SetMaterial(g_mat_glow)
	render.DrawSprite(glowpos, 8, 8, self.EyeColor)
end

function RADIOMDL:CloseWings(nosound)
	if self._State == 1 then
		return
	end

	if self._State == 10 then
		return
	end

	if self.WingClosed then
		return
	end

	self.WingOpened = false
	self.WingClosed = false

	self._State = nosound and 1 or 10
end

function RADIOMDL:OpenWings(nosound)
	if self._State == 2 then
		return
	end

	if self._State == 20 then
		return
	end

	if self.WingOpened then
		return
	end

	self.WingClosed = false
	self.WingOpened = false

	self._State = nosound and 2 or 20
end

RADIOMDL.SpeakerMinFRQ = 20
RADIOMDL.SpeakerMaxFRQ = 3000
RADIOMDL.SpeakerFRQResolution = 12

function RADIOMDL:Speaker(ent, speakerlevel)
	if SERVER then return end

	local now = CurTime()
	self.SL_LastTickTime = now - (self.SL_LastTick or now)
	self.SL_LastTick = now

	if not speakerlevel then
		self:CloseWings(true)
		return
	end

	if not self.WingOpened then
		self:OpenWings(true)
		return
	end

	self.EyeColor = self.EyeColorDyn

	speakerlevel = speakerlevel ^ 2
	speakerlevel = math.Clamp(speakerlevel * 35, 0, 1)

	local RightSwapTime = self.RightSwapTime or 0
	local LeftSwapTime = self.LeftSwapTime or 0
	local SwappedTime = self.SwappedTime or 0

	if speakerlevel >= 0.85 then
		if not self.Swapped then
			if (now - RightSwapTime) > 0.25 then
				self.RightWingDir = ( self.RightWingDir or 1 ) * -1
				self.RightSwapTime = now
				self.Swapped = true
			end
		end

		if not self.Swapped then
			if (now - LeftSwapTime) > 0.25 then
				self.LeftWingDir = ( self.LeftWingDir or 1 ) * -1
				self.LeftSwapTime = now
				self.Swapped = true
			end
		end
	else
		if self.Swapped then
			if (now - SwappedTime) > 0.25 then
				self.SwappedTime = now
				self.Swapped = false
			end
		end
	end

	local RightWing = ent:LookupBone( "RT_Wing" ) or 0
	local LeftWing = ent:LookupBone( "LFT_Wing" ) or 0

	local RPos = math.Clamp(self.RightWing or 0, 0.25, 1)
	local LPos = math.Clamp(self.LeftWing or 0, 0.25, 1)

	ent:ManipulateBonePosition( RightWing, Vector( RPos * self.WingSpan, 0, 0 ) )
	ent:ManipulateBonePosition( LeftWing, Vector( -LPos * self.WingSpan, 0, 0 ) )

	local movelevel = speakerlevel * self.SL_LastTickTime * 3

	self.RightWing = RPos + (self.RightWingDir or 1) * movelevel
	self.LeftWing = LPos + (self.LeftWingDir or 1) * movelevel

	if self.RightWing >= 1 then
		self.RightWingDir = -1
	end

	if self.RightWing <= 0.25 then
		self.RightWingDir = 1
	end

	if self.LeftWing >= 1 then
		self.LeftWingDir = -1
	end

	if self.LeftWing <= 0.25 then
		self.LeftWingDir = 1
	end
end

function RADIOMDL:SoundLevel(ent, soundlevel)
	if SERVER then return end

	soundlevel = soundlevel or 0
	if soundlevel <= 0 then
		soundlevel = 0
	else
		soundlevel = soundlevel * 100000
		soundlevel = math.log10(soundlevel) / 5
		soundlevel = soundlevel ^ 20 * 1.1
	end

	soundlevel = math.Clamp( soundlevel, 0, 1 )

	self.EyeColorDyn.b = 0
	self.EyeColorDyn.g = 0
	self.EyeColorDyn.r = math.floor(31 + 224 * soundlevel)
end

return true


--PATH lua/streamradio_core/models/sw_jukebox.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_subwoofer_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Subwoofer, Big
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/bull/various/speaker.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = true

return true


--PATH lua/streamradio_core/classes/ui/highlighter.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local LIBUtil = StreamRadioLib.Util

function CLASS:Create()
	BASE.Create(self)

	self:SetZPos(9999000)
	self:SetSize(1,1)
	self:SetPos(0,0)

	if CLIENT then
		self.Colors.Main = Color(160, 160, 255, 80)
		self.Colors.Border1 = Color(0, 0, 0, 200)
		self.Colors.Border2 = Color(255, 255, 255, 200)
	end

	if CLIENT then
		self.Highlighted = {}
	end

	self:SetSkinAble(false)
end

function CLASS:Remove()
	self:HighlightClear()
	BASE.Remove(self)
end

function CLASS:SetBorderColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Border1 = color
end

function CLASS:SetBorderColor2(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Border2 = color
end

function CLASS:GetBorderColor()
	if SERVER then return end

	local col = self.Colors.Border1
	return col
end

function CLASS:GetBorderColor2()
	if SERVER then return end

	local col = self.Colors.Border2
	return col
end

function CLASS:HighlightClear()
	if SERVER then return end

	LIBUtil.EmptyTableSafe(self.Highlighted)
	self:QueueCall("PerformRerender")
end

function CLASS:HighlightPanel(panel)
	if SERVER then return end
	if not IsValid(panel) then return end

	self.Highlighted[panel:GetID()] = panel
	self:QueueCall("PerformRerender")
end

function CLASS:HighlightPanels(panels)
	if SERVER then return end

	for _, panel in pairs(panels or {}) do
		self:HighlightPanel(panel)
	end
end

function CLASS:GetHighlightedPanels()
	if SERVER then return end

	return self.Highlighted
end

function CLASS:RenderHighlight(panel)
	if SERVER then return end

	if not IsValid(panel) then return end
	if not self:IsVisibleSimple() then return end
	if not panel:IsVisibleSimple() then return end

	local sp = self:GetSuperParent()
	local spx, spy = sp:GetRenderPos()
	local spw, sph = sp:GetSize()

	local px, py = panel:GetRenderPos()
	local pw, ph = panel:GetSize()

	local thickness = 2
	local lines = 4
	local padding = thickness * lines

	px = math.max(px, spx + padding)
	py = math.max(py, spy + padding)

	pw = math.min(pw, spw - padding * 2)
	ph = math.min(ph, sph - padding * 2)

	local colMain = self.Colors.Main or color_white

	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(px, py, pw, ph)

	local col1 = self.Colors.Border1 or color_white
	local col2 = self.Colors.Border2 or color_black

	for i = 1, lines do
		local col = ((i % 2) == 0) and col2 or col1
		surface.SetDrawColor(col:Unpack())

		for j = 0, thickness - 1 do
			local t = (i - 1) * thickness + j
			local tt = t * 2

			surface.DrawOutlinedRect(px - t, py - t, pw + tt, ph + tt)
		end
	end
end

function CLASS:Render()
	for _, panel in pairs(self.Highlighted) do
		self:RenderHighlight(panel)
	end
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:SetModelSetup()
end

function CLASS:OnModelSetup()
end

function CLASS:ActivateNetworkedMode()
end

return true


--PATH lua/streamradio_core/classes/skin_controller.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNet = StreamRadioLib.Net
local LIBNetwork = StreamRadioLib.Network
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_skincache = StreamRadioLib.Util.CreateCacheArray(128)

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_skin_controller", function()
	g_skincache:Empty()
end)

local function g_encode(value)
	value = {value or {}}
	value = StreamRadioLib.JSON.Encode(value, false) or ""
	value = util.Compress(value) or ""

	return value
end

local function g_decode(value)
	value = value or ""
	value = util.Decompress(value) or ""
	value = StreamRadioLib.JSON.Decode(value) or {}
	value = value[1] or {}

	return value
end

function CLASS:Create()
	BASE.Create(self)

	self.Skin = {}
	self.NetworkPlayerList = {}

	self.Hash = self:CreateListener({
		value = "",
	}, function(this, k, v, oldv)
		if CLIENT then
			self:NetworkSkin()
		else
			self:UpdateSkin()
			self:SetNWString("Hash", v)
		end
	end)

	if CLIENT then
		self:NetReceive("skin", function(this, id, len, ply)
			local skinlen = net.ReadUInt(16)
			local skinencoded = net.ReadData(skinlen)
			local newskindata = g_decode(skinencoded)
			local newhash = LIBNet.ReceiveHash()

			-- Store the result of our request for later use
			g_skincache:Set(newhash, newskindata)
			self:SetSkin(newskindata)
		end)
	else
		LIBNetwork.AddNetworkString("skin")
		LIBNetwork.AddNetworkString("skinrequest")
		LIBNetwork.AddNetworkString("skintoserver")

		self:NetReceive("skinrequest", function(this, id, len, ply)
			self.NetworkPlayerList[ply] = ply

			self:NetworkSkin()
		end)

		self:NetReceive("skintoserver", function(this, id, len, ply)
			self.NetworkPlayerList[ply] = ply

			local players = player.GetHumans()

			for i, thisply in ipairs(players) do
				self.NetworkPlayerList[thisply] = thisply
			end

			local skinlen = net.ReadUInt(16)
			local skinencoded = net.ReadData(skinlen)
			local skindata = g_decode(skinencoded)

			self:SetSkinOnServer(skindata, true)
		end)
	end
end

function CLASS:Remove()
	BASE.Remove(self)
end

function CLASS:NetworkSkin()
	self:QueueCall("NetworkSkinInternal")
end

function CLASS:UpdateSkin()
	self:QueueCall("UpdateSkinInternal")
end

function CLASS:NetworkSkinInternal()
	if CLIENT then
		local hash = self:GetHash()

		if hash ~= "" then
			local cache = g_skincache:Get(hash)

			if cache then
				self:SetSkin(cache)
				return
			end
		end

		self:NetSend("skinrequest")
		return
	end

	self:NetSendToPlayers("skin", function()
		local skinencoded = self:GetSkinEncoded()
		local skinlen = #skinencoded

		net.WriteUInt(skinlen, 16)
		net.WriteData(skinencoded, skinlen)

		LIBNet.SendHash(self:GetHashFromSkin(skinencoded))
	end, self.NetworkPlayerList)

	emptyTableSafe(self.NetworkPlayerList)
end

function CLASS:UpdateSkinInternal()
	self:CallHook("OnUpdateSkin", self:GetSkin())
end

function CLASS:SetSkin(skindata)
	skindata = skindata or {}
	self.Skin = skindata

	self:DelCacheValue("SkinEncoded")

	if SERVER then
		self:CalcHash()
		self:NetworkSkin()
	else
		self:UpdateSkin()
	end
end

function CLASS:_SendSkinToServer()
	if SERVER then return end
	if not self.Network.Active then return end
	if not self._skintoserver then return end

	self:NetSend("skintoserver", function()
		local skinencoded = g_encode(self._skintoserver)
		local skinlen = #skinencoded

		net.WriteUInt(skinlen, 16)
		net.WriteData(skinencoded, skinlen)
	end)

	self._skintoserver = nil
end

function CLASS:SetSkinOnServer(skindata, merge)
	skindata = skindata or {}

	if CLIENT then
		if merge then
			local oldskindata = self._skintoserver or {}
			local newskindata = table.Merge(oldskindata, skindata)

			self._skintoserver = newskindata
		else
			self._skintoserver = skindata
		end

		self:QueueCall("_SendSkinToServer")
		return
	end

	if merge then
		local oldskindata = self:GetSkin()
		local newskindata = table.Merge(oldskindata, skindata)

		self:SetSkin(newskindata)
	else
		self:SetSkin(skindata)
	end
end

function CLASS:GetSkinEncoded()
	local chskinencoded = self:GetCacheValue("SkinEncoded")
	if chskinencoded then return chskinencoded end

	local skinencoded = g_encode(self:GetSkin())
	return self:SetCacheValue("SkinEncoded", skinencoded)
end

function CLASS:GetSkin()
	return self.Skin or {}
end

function CLASS:SetProperty(hierarchy, property, value)
	local skindata = self:GetSkin()

	skindata = StreamRadioLib.SetSkinTableProperty(skindata, hierarchy, property, value)

	self:SetSkin(skindata)
end

function CLASS:SetPropertyOnServer(hierarchy, property, value)
	if SERVER then
		self:SetProperty(hierarchy, property, value)
		return
	end

	local skindata = self._skintoserver or {}
	skindata = StreamRadioLib.SetSkinTableProperty(skindata, hierarchy, property, value)
	self:SetSkinOnServer(skindata, false)
end

function CLASS:GetHashFromSkin(skinEncoded)
	local hash = LIBNetwork.Hash(skinEncoded)
	return hash
end

function CLASS:CalcHash()
	if CLIENT then return end
	if not self.Network.Active then return end

	self:DelCacheValue("SkinEncoded")

	local hash = self:GetHashFromSkin(self:GetSkinEncoded())
	self.Hash.value = hash or ""
end

function CLASS:GetHash()
	local curhash = self.Hash.value or ""

	if CLIENT and self.Network.Active then
		curhash = self:GetNWString("Hash", "")
	end

	return curhash
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:CalcHash()
		return
	end

	local hash = self:GetNWString("Hash", "")
	self.Hash.value = hash

	self:SetNWVarCallback("Hash", "String", function(this, nwkey, oldvar, newvar)
		self.Hash.value = newvar or ""
	end)

	self:NetworkSkin()
	self:UpdateSkin()
end

function CLASS:PreDupe()
	local data = {}

	data.skin = self:GetSkin()

	return data
end

function CLASS:PostDupe(data)
	self:SetSkin(data.skin)
end

return true


--PATH lua/streamradio_core/classes/ui/round_panel.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/button.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/textview.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.CanHaveLabel = false

	self.TextPanel = self:AddPanelByClassname("text", true)
	self.TextPanel:SetPos(0, 0)
	self.TextPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.TextPanel:SetName("text")
	self.TextPanel:SetNWName("txt")

	self.ScrollBar = self:AddPanelByClassname("scrollbar", true)
	self.ScrollBar:SetName("scrollbar")
	self.ScrollBar:SetNWName("sbar")
	self.ScrollBar:SetSkinIdentifyer("scrollbar")
	self.ScrollBar:Hide()

	self.SkinMap["color_foreground"] = {
		set = "SetTextColor",
		get = "GetTextColor",
	}

	self.TextPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnTextChange")
	end

	self.TextPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.TextPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self.TextPanel.OnBuildLines = function(pnl)
		if SERVER then return end
		if not IsValid(self.ScrollBar) then return end

		local lines = self.TextPanel:GetVisibleLines()
		local count = self.TextPanel:GetLineCount() - #lines
		local scroll = self.TextPanel:GetStartLine()

		self.ScrollBar:SetMaxScroll(count)
		self.ScrollBar:SetScroll(scroll - 1)

		self:InvalidateLayout()
	end

	self.ScrollBar.OnScroll = function(pnl, value)
		if SERVER then return end
		if not IsValid(self.TextPanel) then return end
		self.TextPanel:SetStartLine(value + 1)
	end
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local text_panel = self.TextPanel
	local scrollbar = self.ScrollBar

	if not IsValid(text_panel) then
		return
	end

	local w, h = self:GetClientSize()
	local hasscrollbar = IsValid(scrollbar) and scrollbar:IsScrollAble()

	if not hasscrollbar then
		text_panel:SetSize(w, h)

		if IsValid(scrollbar) then
			scrollbar:Hide()
		end

		return
	end

	local barwidth = scrollbar:GetWidth()
	local margin = self:GetMargin()

	text_panel:SetSize(w - margin - barwidth, h)

	scrollbar:SetHeight(h)
	scrollbar:SetPos(w - barwidth, 0)

	scrollbar:SetHorizontal(false)
	scrollbar:Show()
end

function CLASS:GetTextAlign(...)
	return self:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self:SetAlign(...)
end

function CLASS:GetAlign(...)
	return self.TextPanel:GetAlign(...)
end

function CLASS:SetAlign(...)
	return self.TextPanel:SetAlign(...)
end

function CLASS:SetText(...)
	return self.TextPanel:SetText(...)
end

function CLASS:GetText(...)
	return self.TextPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self.TextPanel:SetFont(...)
end

function CLASS:GetFont(...)
	return self.TextPanel:GetFont(...)
end

function CLASS:SetTextColor(...)
	return self.TextPanel:SetColor(...)
end

function CLASS:GetTextColor(...)
	return self.TextPanel:GetColor(...)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/list_playlistview.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local g_mat_sound = StreamRadioLib.GetPNGIcon("sound")

function CLASS:Create()
	BASE.Create(self)

	self.Path.Type = StreamRadioLib.TYPE_FOLDER
	self.Path = self.Path + function(this, k, v_new, v_old)
		if k ~= "Type" then return end

		local v = v_new or StreamRadioLib.TYPE_FOLDER
		v_old = v_old or StreamRadioLib.TYPE_FOLDER

		if v_new ~= v then
			self.Path.Type = v
			return
		end

		self:SetNWInt("PathType", v)
		self:BuildList()
	end

	self.State = self:CreateListener({
		Error = false,
	}, function(this, k, v)
		self:SetNWBool("Error", v)
		self:QueueCall("CallErrorState")
	end)

	self:SetIDIcon(0, g_mat_sound)
end

function CLASS:SetIDIcon(ID, icon)
	ID = ID or -1
	if ID < 0 then return end

	self.IconIDs[ID] = icon or ID
	self:UpdateButtons()
end

function CLASS:GetIDIcon(ID)
	ID = ID or -1
	if ID < 0 then return end

	return self.IconIDs[ID]
end

function CLASS:OnItemClickInternal(button, value, buttonindex, ListX, ListY, i)
	if CLIENT and self.Network.Active then return end
	self:PlayItem(value)
end

function CLASS:PlayItem(value)
	if CLIENT then return end
	if not self.Network.Active then return end
	if not value then return end

	self:CallHook("OnPlayItem", value)
end

function CLASS:CallErrorState()
	if self.State.Error then
		self:CallHook("OnError", self.Path.Value, self.Path.Type)
	else
		self:CallHook("OnErrorRelease", self.Path.Value, self.Path.Type)
	end
end

function CLASS:UpdateErrorState()
	if CLIENT then return end
	self.State.Error = self.tmperror or false
end

function CLASS:HasError()
	return self.State.Error
end

function CLASS:ClearData()
	if SERVER then
		self.State.Error = false
		self.tmperror = nil
	end

	BASE.ClearData(self)
end

function CLASS:BuildListInternal()
	if CLIENT then return end
	if not self.Network.Active then return end

	self:CallHook("OnPlaylistStartBuild")

	self:ClearData()

	if not self:IsVisible() then
		self:UpdateButtons()
		self:RestoreScrollPos()

		self:CallHook("OnPlaylistEndBuild")
		return
	end

	self.PathUid = StreamRadioLib.Util.Uid()

	if self.Path.Value == "" then
		self:UpdateButtons()
		self:RestoreScrollPos()

		self:CallHook("OnPlaylistEndBuild")
		return
	end

	local uid = self.PathUid

	StreamRadioLib.Filesystem.Read(self.Path.Value, self.Path.Type, function(success, playlist)
		if uid ~= self.PathUid then
			return
		end

		if not success then
			self.tmperror = true
			self:QueueCall("UpdateErrorState")
			self:CallHook("OnPlaylistEndBuild")
			return
		end

		self:QueueCall("_BuildListInternalAsyc", uid, playlist or {})
	end)
end

function CLASS:_BuildListInternalAsyc(uid, playlist)
	if uid ~= self.PathUid then
		return
	end

	local playlistItems = {}

	local len = #playlist
	if len <= 0 then
		self.tmperror = true
		self:QueueCall("UpdateErrorState")
		self:CallHook("OnPlaylistEndBuild", playlistItems)
		return
	end

	for i, v in ipairs(playlist) do
		local entry = {
			name = v.name,
			url = v.url,
			index = i,
		}

		playlistItems[i] = entry

		local data = {}
		data.value = entry
		data.text = entry.name
		data.icon = 0

		self:AddData(data, true)
	end

	if len == 1 then
		self:PlayItem(playlistItems[1])
	end

	self:UpdateButtons()
	self:QueueCall("RestoreScrollPos")

	self:CallHook("OnPlaylistEndBuild", playlistItems)
end

function CLASS:GetFile()
	return self.Path.Value or "", self.Path.Type or StreamRadioLib.TYPE_FOLDER
end

function CLASS:SetFile(path, ty)
	if CLIENT and self.Network.Active then return end

	self.Path.Value = path or ""
	self.Path.Type = ty or StreamRadioLib.TYPE_FOLDER
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)

	if SERVER then
		self:SetNWInt("PathType", self.Path.Type)
		self:SetNWBool("Error", self.State.Error)
		return
	end

	self:SetNWVarCallback("PathType", "Int", function(this, nwkey, oldvar, newvar)
		self.Path.Type = newvar
	end)

	self:SetNWVarCallback("Error", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.Error = newvar
	end)

	self.Path.Type = self:GetNWInt("PathType", StreamRadioLib.TYPE_FOLDER)
	self.State.Error = self:GetNWBool("Error", false)
end

function CLASS:PreDupe()
	local data = {}
	local path, ty = self:GetFile()

	data.Path = path
	data.PathType = ty

	return data
end

function CLASS:ApplyLegacyDataFromDupe(dupedata)
	if not dupedata then return end

	local data = dupedata.Playlist
	local pos = dupedata.EntryOpen or 1

	if not data then return end
	if #data <= 1 then return end

	local ent = self:GetEntity()
	if not IsValid(ent) then return end
	if not ent.DupeDataApply then return end

	-- Legacy support:
	--  Old dupes still have the playlist data in this UI element.
	--  We moved the playlist to the entity, so move the legacy playlist data as well.

	ent:DupeDataApply("PlaylistData", {
		data = data,
		pos = pos,
	})
end

function CLASS:PostDupe(dupedata)
	local path = dupedata.Path
	local type = dupedata.PathType

	self.PathUid = StreamRadioLib.Util.Uid()
	local uid = self.PathUid

	StreamRadioLib.Filesystem.Read(path, type, function(success, data)
		if uid ~= self.PathUid then
			return
		end

		if not success or #data <= 0 then
			self:SetFile("", type)
			self:ApplyLegacyDataFromDupe(dupedata)

			self:CallHook("OnInvalidDupeFilepath")
			return
		end

		self:SetFile(path, type)
		self:ApplyLegacyDataFromDupe(dupedata)
	end)
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_main.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/gui_main.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Browser = self:AddPanelByClassname("radio/gui_browser", true)
	self.Browser:SetName("browser")
	self.Browser:SetNWName("brw")
	self.Browser:SetZPos(50)
	self.Browser:Open()
	self.Browser:SetSkinIdentifyer("browser")

	self.Player = self:AddPanelByClassname("radio/gui_player", true)
	self.Player:SetName("player")
	self.Player:SetNWName("ply")
	self.Player:SetZPos(100)
	self.Player:Close()
	self.Player:SetSkinIdentifyer("player")

	self:SetShadowWidth(0)
	self.Browser:SetPadding(5)
	self.Player:SetPadding(5)

	self._showplaylist = true
	self._hasplaylist = false

	self.State = self:CreateListener({
		PlayerOpened = false,
	}, function(this, k, v)
		if not v then
			self.Player:Close()
			self.Browser:ActivateNetworkedMode()
			self.Browser:Open()
			self.Browser:CloseSingleItem()
		end

		if v then
			self.Browser:CloseSingleItem()
			self.Browser:Close()
			self.Player:ActivateNetworkedMode()
			self.Player:Open()

			self:EnablePlaylist(self._showplaylist)
			self:SetHasPlaylist(self._hasplaylist)

			if IsValid(self.StreamOBJ) then
				self.StreamOBJ:Play(true)
			end

			self:CallHook("OnPlayerShown")
		end

		self:SetNWBool(k, v)
		self:ApplyNetworkVars()
		self:InvalidateLayout()
	end)

	self.Browser.OnPlayItem = function(this, item)
		self:EnablePlaylist(true)
		self:Play(item)
	end

	self.Browser.OnPlaylistStartBuild = function(this, ...)
		return self:CallHook("OnPlaylistStartBuild", ...)
	end

	self.Browser.OnPlaylistEndBuild = function(this, ...)
		return self:CallHook("OnPlaylistEndBuild", ...)
	end

	self.Browser.OnPlaylistOpen = function(this, ...)
		return self:CallHook("OnPlaylistOpen", ...)
	end

	self.Browser.OnPlaylistClose = function(this, ...)
		return self:CallHook("OnPlaylistClose", ...)
	end

	self.Browser.OnToolButtonClick = function()
		self:CallHook("OnToolButtonClick")
	end

	self.Browser.OnWireButtonClick = function()
		self:CallHook("OnWireButtonClick")
	end

	self.Player.OnClose = function()
		self:Stop()
		self:CallHook("OnPlayerClosed")
	end

	self.Player.OnPlaylistBack = function()
		self:CallHook("OnPlaylistBack")
	end

	self.Player.OnPlaylistForward = function()
		self:CallHook("OnPlaylistForward")
	end

	self.Player.OnPlaybackLoopModeChange = function(this, newLoopMode)
		self:CallHook("OnPlaybackLoopModeChange", newLoopMode)
	end

	self:QueueCall("ActivateNetworkedMode")
	self:InvalidateLayout()
end

function CLASS:Stop()
	if not self.State.PlayerOpened then
		return
	end

	self:ClosePlayer()
	self:CallHook("OnStop")
end

function CLASS:Play(item)
	if not item then
		self:Stop()
		return
	end

	self:OpenPlayer()
	self:CallHook("OnPlayItem", item)
end

function CLASS:OpenPlayer()
	self.State.PlayerOpened = true
end

function CLASS:ClosePlayer()
	self.State.PlayerOpened = false
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not IsValid(self.Player) then return end
	if not IsValid(self.Browser) then return end

	local w, h = self:GetClientSize()

	self.Player:SetPos(0, 0)
	self.Player:SetSize(w, h)
	self.Browser:SetPos(0, 0)
	self.Browser:SetSize(w, h)
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	if IsValid(self.Player) then
		self.Player:SetStream(stream)
	end
end

function CLASS:GetStream()
	return self.StreamOBJ
end

function CLASS:EnablePlaylist(bool)
	self._showplaylist = bool
	self.Player:EnablePlaylist(bool and self._hasplaylist)
end

function CLASS:GetHasPlaylist()
	return self._hasplaylist or false
end

function CLASS:SetHasPlaylist(bool)
	self._hasplaylist = bool
	self.Player:EnablePlaylist(bool and self._showplaylist)

	self.Player:SetHasPlaylist(bool)
	self.Browser:SetHasPlaylist(bool)
end

function CLASS:IsPlaylistEnabled()
	return self.Player:IsPlaylistEnabled()
end

function CLASS:UpdatePlaybackLoopMode(...)
	self.Player:UpdatePlaybackLoopMode(...)
end

function CLASS:SetSyncMode(...)
	self.Player:SetSyncMode(...)
end

function CLASS:GetSyncMode()
	return self.Player:GetSyncMode()
end

function CLASS:IsPlayerOpen()
	return self.State.PlayerOpened or false
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	self.Browser:ActivateNetworkedMode()
	self.Player:ActivateNetworkedMode()

	if SERVER then
		self:SetNWBool("PlayerOpened", self.State.PlayerOpened)
		return
	end

	self:SetNWVarCallback("PlayerOpened", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.PlayerOpened = newvar
	end)
end

function CLASS:ApplyNetworkVarsInternal()
	BASE.ApplyNetworkVarsInternal(self)

	self.State.PlayerOpened = self:GetNWBool("PlayerOpened", false)
end

function CLASS:PreDupe()
	local data = {}

	data.PlayerOpened = self.State.PlayerOpened

	return data
end

function CLASS:PostDupe(data)
	self.State.PlayerOpened = data.PlayerOpened
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_player_spectrum.lua:
return gluapack()()
--PATH lua/streamradio_core/print.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Print = StreamRadioLib.Print or {}

local LIB = StreamRadioLib.Print
table.Empty(LIB)

local LIBString = StreamRadioLib.String

function LIB.Format(format, ...)
	format = tostring(format or "")
	if format == "" then return "" end

	local empty = table.IsEmpty({...})
	if empty then
		return format
	end

	local result = string.format(format, ...)
	return result
end

function LIB.Debug(format, ...)
	if not StreamRadioLib.Util.IsDebug() then return end

	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	msgstring = LIBString.NormalizeNewlines(msgstring, "\n")
	msgstring = LIBString.IndentTextBlock(msgstring, 1, "  ")

	msgstring = string.Trim(StreamRadioLib.AddonPrefix .. msgstring) .. "\n"

	local hasVr = StreamRadioLib.VR.IsActive()

	local lines = string.Explode("\n", msgstring, false)
	for i, line in ipairs(lines) do
		if hasVr then
			StreamRadioLib.VR.Debug(line)
		else
			MsgN(line)
		end
	end
end

function LIB.Msg(ply, format, ...)
	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	msgstring = LIBString.NormalizeNewlines(msgstring, "\n")
	msgstring = LIBString.IndentTextBlock(msgstring, 1, "  ")

	msgstring = string.Trim(StreamRadioLib.AddonPrefix .. msgstring) .. "\n"

	local hasPly = IsValid(ply)

	local lines = string.Explode("\n", msgstring, false)
	for i, line in ipairs(lines) do
		if hasPly then
			ply:PrintMessage(HUD_PRINTTALK, line)
		else
			MsgN(line)
		end
	end
end

function LIB.GetPlayerString(ply)
	local playerStr = ""

	if IsValid(ply) then
		playerStr = string.format("%s (%s)", ply:Name(), ply:SteamID())
	end

	return playerStr
end

local g_colorSeparator = Color(255, 255, 255)
local g_colorDateTime = Color(180, 180, 180)
local g_colorAddonName = Color(0, 200, 0)
local g_colorPlayer = Color(200, 200, 0)

function LIB.Log(ply, format, ...)
	local msgstring = LIB.Format(format, ...)
	msgstring = string.Trim(msgstring)

	if msgstring == "" then return end

	local playerStr = LIB.GetPlayerString(ply)

	local Timestamp = os.time()
	local TimeString = os.date("%Y-%m-%d %H:%M:%S" , Timestamp)

	MsgC(g_colorSeparator, "[")
	MsgC(g_colorDateTime, TimeString)
	MsgC(g_colorSeparator, "]")

	MsgC(g_colorSeparator, "[")
	MsgC(g_colorAddonName, StreamRadioLib.AddonTitle)
	MsgC(g_colorSeparator, "]")

	if playerStr ~= "" then
		MsgC(g_colorSeparator, "[")
		MsgC(g_colorPlayer, playerStr)
		MsgC(g_colorSeparator, "]")
	end

	Msg(" ")

	MsgN(msgstring)
end

local g_oldfloat = 0

function LIB.PrintFloatBar( float, len, ... )
	local float = math.Clamp( float, 0, 1 )
	local str = ""

	if float >= g_oldfloat then
		g_oldfloat = float
	end

	local bar = math.Round(float * len)
	local space = len - math.Round(float * len)
	local space1 = math.Round((g_oldfloat - float) * len)

	local space2 = space - space1 - 1
	str = string.rep("#", bar) .. string.rep(" ", space1) .. (math.Round(g_oldfloat * len) < len and "|" or "") .. string.rep(" ", space2)
	MsgC(Color(510 * float, 510 * (1 - float), 0, 255), str, " ", string.format("% 7.2f%%\t", float * 100), ..., "\n")

	if float < g_oldfloat then
		g_oldfloat = g_oldfloat - 0.5 * RealFrameTime()
	end

	return str
end

return true


--PATH lua/streamradio_core/vr.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_playlist_edit.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Editor = StreamRadioLib.Editor or {}

local LIB = StreamRadioLib.Editor
table.Empty(LIB)

local LIBNet = StreamRadioLib.Net

local g_listenPath = ""

local g_callbackFunc = nil
local g_callbackArgs = {}
local g_callbackObj = nil

function LIB.ListenToPath( path )
	g_listenPath = tostring( path or "" )

	return g_listenPath
end

function LIB.GetListenPath( )
	return g_listenPath
end

function LIB.CreateDir( path )
	if not path then return false end
	if path == "" then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt( 0, 4 )
	net.WriteString( path )
	net.SendToServer( )

	return true
end

function LIB.Save( path, DataTab )
	if not path then return false end
	if path == "" then return false end

	if not DataTab then return false end
	if not DataTab["format"] then return false end
	if StreamRadioLib.Filesystem.IsFolder(DataTab["format"]) then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	--Start
	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(1, 4)
	net.WriteString(path)
	net.SendToServer()

	StreamRadioLib.TimedpairsStop( "Editor_SaveFile_" .. path )
	StreamRadioLib.Timedpairs( "Editor_SaveFile_" .. path, DataTab, 1, function( k, v )
		if not IsValid(ply) then return false end
		if not ply:IsAdmin() then return false end
		if isstring(k) then return end

		--Body
		LIBNet.Start("Editor_Request_Playlist")
		net.WriteUInt( 2, 4 )
		StreamRadioLib.NetSendPlaylistEditor(v["url"], v["name"], path)
		net.SendToServer( )
	end, function( k, v )
		if not IsValid(ply) then return false end
		if not ply:IsAdmin() then return false end

		--Finish
		LIBNet.Start("Editor_Request_Playlist")
		net.WriteUInt(3, 4)
		net.WriteUInt(DataTab["format"], 8)
		net.WriteUInt(#DataTab, 16)
		net.WriteString(path)
		net.SendToServer()
	end )

	return true
end

function LIB.Remove(path, format)
	if not path then return false end
	if path == "" then return false end

	local ply = LocalPlayer()

	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(4, 4)
	net.WriteUInt(format, 8)
	net.WriteString(path)
	net.SendToServer()

	return true
end

function LIB.Copy(path_old, path_new)
	if not path_old then return false end
	if not path_new then return false end

	if path_old == "" then return false end
	if path_new == "" then return false end
	if path_old == path_new then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(5, 4)
	net.WriteString(path_old)
	net.WriteString(path_new)
	net.SendToServer()

	return true
end

function LIB.Rename(path_old, path_new)
	if not path_old then return false end
	if not path_new then return false end

	if path_old == "" then return false end
	if path_new == "" then return false end
	if path_old == path_new then return false end

	local ply = LocalPlayer()
	if not IsValid(ply) then return false end
	if not ply:IsAdmin() then return false end

	LIBNet.Start("Editor_Request_Playlist")
	net.WriteUInt(6, 4)
	net.WriteString(path_old)
	net.WriteString(path_new)
	net.SendToServer()

	return true
end

function LIB.SetCallback(func, this, ...)
	if not isfunction(func) then
		g_callbackFunc = nil
		g_callbackArgs = {}
		g_callbackObj = nil

		return
	end

	g_callbackFunc = func
	g_callbackArgs = {...}
	g_callbackObj = this
end

LIBNet.Receive("Editor_Return_Files", function( length )
	local path, name, type, filepath = StreamRadioLib.NetReceiveFileEditor( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "files", path, name, filepath, type, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "files", path, name, filepath, type, unpack( g_callbackArgs or {} ) )
	end
end)

LIBNet.Receive("Editor_Return_Playlist", function( length )
	local url, name, filepath = StreamRadioLib.NetReceivePlaylistEditor( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "playlist", url, name, filepath, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "playlist", url, name, filepath, unpack( g_callbackArgs or {} ) )
	end
end)

LIBNet.Receive("Editor_Error", function( length )
	local path, code = StreamRadioLib.NetReceiveEditorError( )
	if not isfunction(g_callbackFunc) then return end

	if g_callbackObj then
		g_callbackFunc( g_callbackObj, "error", path, code, unpack( g_callbackArgs or {} ) )
	else
		g_callbackFunc( "error", path, code, unpack( g_callbackArgs or {} ) )
	end
end)

local MainPanel
local EditorPanel

local function CreateMainPanel( )
	if IsValid(MainPanel) then
		MainPanel:Remove()
	end

	if IsValid(EditorPanel) then
		EditorPanel:Remove()
	end

	MainPanel = vgui.Create("DFrame") -- The main frame.
	MainPanel:SetPos(25, 25)

	local W = math.Clamp(ScrW() - 50, 750, 1200)
	local H = math.Clamp(ScrH() - 50, 400, 800)
	MainPanel:SetSize(W, H)

	MainPanel:SetMinWidth(750)
	MainPanel:SetMinHeight(400)
	MainPanel:SetSizable(true)
	MainPanel:SetDeleteOnClose(false)
	MainPanel:SetTitle("Stream Radio Playlist Editor")
	MainPanel:SetVisible(false)
	MainPanel:GetParent():SetWorldClicker(true)

	EditorPanel = vgui.Create("Streamradio_VGUI_PlaylistEditor", MainPanel)
	EditorPanel:DockMargin(5, 5, 5, 5)
	EditorPanel:Dock(FILL)
end

do
	local function ClosePanel( ply, cmd, args )
		if not IsValid(MainPanel) then
			return
		end

		StreamRadioLib.VR.CloseMenu(MainPanel)
	end

	local function OpenPanel( ply, cmd, args )
		if not IsValid(ply) then return end

		if not ply:IsAdmin() then
			StreamRadioLib.Print.Msg(ply, "You must be admin to use the playlist editor.")
			return
		end

		if not IsValid(MainPanel) then
			CreateMainPanel()
		end

		if not IsValid(MainPanel) then
			return
		end

		-- Open via VR lib regardless so we have smoother transitions without possible leftovers
		StreamRadioLib.VR.MenuOpen("StreamradioPlaylistEditor", MainPanel, true)
	end

	concommand.Add("cl_streamradio_playlisteditor", OpenPanel)
	concommand.Add("+cl_streamradio_playlisteditor", OpenPanel)
	concommand.Add("-cl_streamradio_playlisteditor", ClosePanel)
end

return true


--PATH lua/streamradio_core/client/cl_vgui.lua:
local StreamRadioLib = StreamRadioLib

local LIBError = StreamRadioLib.Error
local LIBUrl = StreamRadioLib.Url

local PANEL = {}
AccessorFunc( PANEL, "m_showLimit", "ShowLimit" )
AccessorFunc( PANEL, "m_maxLength", "MaxLength" )

function PANEL:Init()
	self:SetShowLimit(false)
	self:SetMaxLength(0)

	self:SetDrawLanguageID(false)
end

function PANEL:PaintOver(w, h)
	if not self:IsEditing() then
		return
	end

	if not self:GetShowLimit() then
		return
	end

	local maxLen = self:GetMaxLength()
	if maxLen <= 0 then
		return
	end

	local len = #self:GetText()

	local cx, cy = self:LocalCursorPos()

	local text = string.format("%i / %i", len, maxLen)

	surface.SetFont(self:GetFont())
	local tw, th = surface.GetTextSize(text)

	local tpw, tph = tw + 6, th + 6

	tpw = math.min(tpw, w - 2)
	tph = math.min(tph, h - 2)

	local tpx, tpy = w - tpw - 1, h - tph - 1

	tpx = math.max(tpx, 0)
	tpy = math.max(tpy, 0)

	if cx >= tpx - 5 and cy >= tpy - 10 and cx < w and cy < h then
		return
	end

	surface.SetDrawColor(190, 255, 255)
	surface.DrawRect(tpx, tpy, tpw, tph)

	surface.SetTextColor( 0, 0, 0)
	surface.SetTextPos(tpx + 3, tpy + 3)
	surface.DrawText(text)
end

function PANEL:GetLength()
	local value = self:GetText()
	return #value
end

function PANEL:AllowInput(change)
	local maxLen = self:GetMaxLength()
	if maxLen <= 0 then
		return false
	end

	local valueLen = self:GetLength()
	local changeLen = #change
	local len = valueLen + changeLen

	if len > maxLen then
		-- Limit reached
		return true
	end

	return false
end

vgui.Register( "Streamradio_VGUI_TextEntryWithLimit", PANEL, "DTextEntry" )


local PANEL = {}
AccessorFunc( PANEL, "m_strValue", "Value" )
AccessorFunc( PANEL, "m_strValue", "Text" )

local STATE_FOUND = 2
local STATE_ERROR = 1
local STATE_IDLE = 0

function PANEL:Init( )
	self:SetPaintBackground( false )
	self.URLIcon = self:Add( "DImageButton" )
	self.URLIcon:SetImage( "icon16/arrow_refresh.png" )
	self.URLIcon:SetWide( 20 )
	self.URLIcon:Dock( RIGHT )
	self.URLIcon:SetStretchToFit( false )
	self.URLIcon:DockMargin( 0, 0, 0, 0 )

	self.URLIcon.DoClick = function( panel )
		if not IsValid(self) then
			return
		end

		self.URLText:OnEnter(self.URLText:GetText())
	end

	self.URLIcon.DoRightClick = function( panel )
		if not IsValid(self) then
			return
		end

		local stream = self.Stream
		if not IsValid(stream) then
			return
		end

		local err = self.Error
		local url = stream:GetURL()

		if not err then
			return
		end

		if err == 0 then
			return
		end

		if url == "" then
			return
		end

		StreamRadioLib.ShowErrorHelp(err, url)
	end

	self.URLText = self:Add( "Streamradio_VGUI_TextEntryWithLimit" )
	self.URLText:SetDrawLanguageID(false)
	self.URLText:SetUpdateOnType(true)
	self.URLText:SetHistoryEnabled(false)
	self.URLText:SetEnterAllowed(true)
	self.URLText:SetMultiline(true)
	self.URLText:Dock(FILL)
	self.URLText:DockMargin( 0, 0, 2, 0 )

	self.URLText:SetShowLimit(true)
	self.URLText:SetMaxLength(StreamRadioLib.STREAM_URL_MAX_LEN_ONLINE)

	if self.URLText.SetPlaceholderText then
		-- Some client have addon conflicts
		-- This causes them to not have the panel:SetPlaceholderText() function

		self.URLText:SetPlaceholderText("Enter file path or online URL")
	end

	self.URLTooltip = StreamRadioLib.STREAM_URL_INFO
	self.URLText:SetTooltip(self.URLTooltip)

	local function callChangeEvent(panel, value, enter)
		local newValue = LIBUrl.SanitizeUrl(value)

		self.m_strValue = newValue
		self:CheckURL()

		if enter then
			self:OnEnter(newValue)
		else
			self:OnChange(newValue)
		end
	end

	local oldGetText = self.URLText.GetText
	self.URLText.GetText = function( panel, change )
		local value = oldGetText(panel)

		value = LIBUrl.SanitizeUrl(value)

		return value
	end

	local oldOnValueChange = self.URLText.OnValueChange
	self.URLText.OnValueChange = function( panel, value, ... )
		if not IsValid(self) then
			return oldOnValueChange( panel, value, ... )
		end

		callChangeEvent(panel, value, false)

		return oldOnValueChange( panel, newValue, ... )
	end

	local oldOnKeyCode = self.URLText.OnKeyCode
	self.URLText.OnKeyCode = function( panel, code, ... )
		oldOnKeyCode( panel, code, ... )

		if not IsValid(self) then
			return
		end

		if code == KEY_ENTER or
			code == KEY_PAD_ENTER or
			code == KEY_ESCAPE
		then
			timer.Simple(0, function()
				if not IsValid(self) then
					return
				end

				if not IsValid(panel) then
					return
				end

				local text = panel:GetText()
				panel:SetText(text)

				panel:OnEnter(text)
				panel:FocusNext()
			end)
		end
	end

	local oldOnEnter = self.URLText.OnEnter
	self.URLText.OnEnter = function( panel, ... )
		if not IsValid(self) then
			return oldOnEnter( panel, ... )
		end

		local value = panel:GetText()
		local newValue = LIBUrl.SanitizeUrl(value)

		if value ~= newValue then
			panel:SetText(newValue)
		end

		callChangeEvent(panel, newValue, true)

		return oldOnEnter( panel, ... )
	end

	local oldOnLoseFocus = self.URLText.OnLoseFocus

	self.URLText.OnLoseFocus = function( panel, ... )
		if not IsValid(self) then
			return oldOnLoseFocus( panel, ... )
		end

		panel:OnEnter(panel:GetText())
		self:OnLoseFocus(...)

		return oldOnLoseFocus( panel, ... )
	end

	self:SetValue("")
end

function PANEL:GetOrCreateStream()
	if not StreamRadioLib and StreamRadioLib.Loaded then
		if IsValid(self.Stream) then
			self.Stream:Remove()
		end

		self.Stream = nil
		self.Error = nil

		return nil
	end

	if IsValid(self.Stream) then
		return self.Stream
	end

	local stream = StreamRadioLib.CreateOBJ("stream")
	if not IsValid( stream ) then
		self.Stream = nil
		self.Error = nil

		return nil
	end

	stream:Set3D(false)
	stream:SetLoop(false)
	stream:SetVolume(0)

	stream.OnConnect = function( thisStream, channel )
		thisStream:Stop()

		if not IsValid(self) then
			return
		end

		self.Error = nil
		self:UpdateURLState(STATE_FOUND)
	end

	stream.OnError = function( thisStream, err )
		thisStream:Stop()

		if not IsValid(self) then
			return
		end

		self.Error = err
		self:UpdateURLState(STATE_ERROR)
	end

	stream.OnRetry = function( thisStream )
		if not IsValid(self) then
			return false
		end

		self:UpdateURLState(STATE_IDLE)
		return true
	end

	stream.OnSearch = function( thisStream )
		if not IsValid( self ) then
			return false
		end

		self:UpdateURLState(STATE_IDLE)
		return true
	end

	stream.CanSkipUrlChecks = function( thisStream )
		if not IsValid( self ) then
			return false
		end

		-- This stream is for the local client only and safe to use.
		-- No whitelist is needed here. Avoids UX problems also.
		return true
	end

	stream.OnDownload = function( thisStream, url, interface )
		return false
	end

	self.Stream = stream
	return stream
end

function PANEL:SetValue(value)
	self.m_strValue = tostring(value or "")
	self.URLText:SetValue(self.m_strValue)
	self:CheckURL()
end

function PANEL:SetText(value)
	self.m_strValue = tostring(value or "")
	self.URLText:SetText(self.m_strValue)
	self:CheckURL()
end

function PANEL:SetShowLimit(showLimit)
	self.URLText:SetShowLimit(showLimit)
end

function PANEL:GetShowLimit()
	return self.URLText:GetShowLimit()
end

function PANEL:SetMaxLength(maxLen)
	self.URLText:SetMaxLength(maxLen)
end

function PANEL:GetMaxLength()
	return self.URLText:GetMaxLength()
end

function PANEL:SetMultiline(multiline)
	self.URLText:SetMultiline(multiline)
end

function PANEL:GetMultiline()
	return self.URLText:GetMultiline()
end

function PANEL:GetTextEntry()
	return self.URLText
end

function PANEL:SetConVar(convar)
	self.URLText:SetConVar(convar)
end

function PANEL:UpdateURLState(state)
	if state == STATE_IDLE then
		self.URLIcon:SetImage("icon16/arrow_refresh.png")
		self.URLIcon:SetTooltip("Checking URL...")
		self.URLText:SetTooltip(self.URLTooltip .. "\n\nChecking URL...")

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()
		return
	end

	local err = self.Error or 0
	local url = ""

	if IsValid(self.Stream) then
		url = self.Stream:GetURL()
	end

	if state == STATE_ERROR then
		local tooltipbase = "The URL is not valid!"
		local tooltip = ""
		local tooltipurl = ""

		if err ~= 0 and url ~= "" then
			self.URLIcon:SetImage("icon16/cross.png")

			local errorInfo = LIBError.GetStreamErrorInfo(err)

			local errorName = errorInfo.name
			local errorDescription = errorInfo.description
			local errorHasHelpmenu = errorInfo.helpmenu

			local errorString = string.format("Error %i (%s): %s", err, errorName, errorDescription)

			tooltip = tooltipbase .. "\n" .. errorString
			tooltipurl = tooltipbase .. "\n" .. errorString

			if errorHasHelpmenu then
				tooltip = tooltip .. "\n\nRight click for more details."
				tooltipurl = tooltip .. "\n\nRight click on the red cross button for more details."
			end
		else
			self.URLIcon:SetImage("icon16/information.png")
			tooltip = "The URL is empty!"
		end

		tooltip = string.Trim(tooltip)
		tooltipurl = string.Trim(tooltipurl)

		self.URLIcon:SetTooltip(tooltip)
		self.URLText:SetTooltip(string.Trim(self.URLTooltip .. "\n\n" .. tooltipurl))

		self:OnURLCheck(false, err, url)

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()

		return
	end

	if state == STATE_FOUND then
		self.URLIcon:SetImage("icon16/accept.png")
		self.URLIcon:SetTooltip("The URL is valid!")
		self.URLText:SetTooltip(self.URLTooltip)

		self:OnURLCheck(true, err, url)

		StreamRadioLib.VR.RenderMenu(self)
		self:InvalidateLayout()

		return
	end
end

function PANEL:CheckURL()
	local stream = self:GetOrCreateStream()

	if IsValid(stream) then
		stream:TimerRemove("gui_url_checker")
	end

	self:UpdateURLState(STATE_IDLE)

	if not IsValid(stream) then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		return false
	end

	if not self.m_strValue then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		stream:SetURL("")
		stream:Stop()

		return false
	end

	if self.m_strValue == "" then
		self.Error = nil
		self:UpdateURLState(STATE_ERROR)
		stream:SetURL("")
		stream:Stop()

		return false
	end

	stream:TimerOnce("gui_url_checker", 0.5, function()
		if not IsValid(stream) then
			return
		end

		if not IsValid(self) then
			return
		end

		self:UpdateURLState(STATE_IDLE)
		stream:SetURL(self.m_strValue)
		stream:Play()
	end)

	return true
end

function PANEL:OnRemove()
	if IsValid(self.Stream) then
		self.Stream:TimerRemove("gui_url_checker")
		self.Stream:Remove()
		self.Stream = nil
	end

	if IsValid(self.URLIcon) then
		self.URLIcon:Remove()
		self.URLIcon = nil
	end

	if IsValid(self.URLText) then
		self.URLText:Remove()
		self.URLText = nil
	end
end

function PANEL:OnEnter( ... )
	-- Override me
end

function PANEL:OnChange( ... )
	-- Override me
end

function PANEL:OnLoseFocus( ... )
	-- Override me
end

function PANEL:OnURLCheck( ... )
	-- Override me
end

vgui.Register( "Streamradio_VGUI_URLTextEntry", PANEL, "DPanel" )

local PANEL = {}

function PANEL:Init( )
	self:SetEditable( true )
	self:SetMultiline( true )
	self:SetDrawLanguageID( false )
	self:SetTabbingDisabled( true )
	self:SetHistoryEnabled( false )
	self:SetEnterAllowed( false )
	self:SetDrawBorder( false )
	self:SetPaintBackground( false )
	self:SetUpdateOnType( true )
	self:SetNumeric( false )
	self:SetVerticalScrollbarEnabled( false )
	self:SetHistoryEnabled( false )
	self:SetCursorColor( Color( 0, 0, 0, 0 ) )
	self:SetCursor( "arrow" )

	self._SetText = self._SetText or self.SetText
	self.SetText = function(this, text, ...)
		this.m_text = tostring(text or "")
		this:_SetText(this.m_text, ...)
	end
end

function PANEL:OnValueChange()
	self:_SetText(self.m_text or "")
	self:KillFocus()
end

vgui.Register( "Streamradio_VGUI_ReadOnlyTextEntry", PANEL, "DTextEntry" )

return true


--PATH lua/streamradio_core/client/cl_vgui_editor.lua:
local StreamRadioLib = StreamRadioLib
local LIBNet = StreamRadioLib.Net

local string = string
local math = math
local table = table
local vgui = vgui
local net = net

local IsValid = IsValid
local unpack = unpack
local Derma_Query = Derma_Query
local Derma_StringRequest = Derma_StringRequest
local isstring = isstring
local pairs = pairs
local ipairs = ipairs
local PANEL = {}

AccessorFunc( PANEL, "m_bUnsaved", "Unsaved" ) -- edited list file Saved?
AccessorFunc( PANEL, "m_bSaving", "Saving" ) -- edited list file Saved?
AccessorFunc( PANEL, "m_strPath", "Path" ) -- List file

local OK_CODES = {
	[StreamRadioLib.EDITOR_ERROR_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_WRITE_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_READ_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_FILES_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_DIR_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_DEL_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_COPY_OK] = true,
	[StreamRadioLib.EDITOR_ERROR_RENAME_OK] = true,
}

local WRITE_ERRORS = {
	[StreamRadioLib.EDITOR_ERROR_WPATH] = true,
	[StreamRadioLib.EDITOR_ERROR_WDATA] = true,
	[StreamRadioLib.EDITOR_ERROR_WVIRTUAL] = true,
	[StreamRadioLib.EDITOR_ERROR_WFORMAT] = true,
	[StreamRadioLib.EDITOR_ERROR_WRITE] = true,
	[StreamRadioLib.EDITOR_ERROR_COMMUNITY_PROTECTED] = true,
	[StreamRadioLib.EDITOR_ERROR_VIRTUAL_PROTECTED] = true,
}

local READ_ERRORS = {
	[StreamRadioLib.EDITOR_ERROR_RPATH] = true,
	[StreamRadioLib.EDITOR_ERROR_RDATA] = true,
	[StreamRadioLib.EDITOR_ERROR_RFORMAT] = true,
	[StreamRadioLib.EDITOR_ERROR_READ] = true,
}

local DIR_ERRORS = {
	[StreamRadioLib.EDITOR_ERROR_DIR_WRITE] = true,
	[StreamRadioLib.EDITOR_ERROR_DIR_EXIST] = true,
}

local COPY_ERRORS = {
	[StreamRadioLib.EDITOR_ERROR_COPY_DIR] = true,
	[StreamRadioLib.EDITOR_ERROR_COPY_EXIST] = true,
	[StreamRadioLib.EDITOR_ERROR_COPY_WRITE] = true,
	[StreamRadioLib.EDITOR_ERROR_COPY_READ] = true,
}

local RENAME_ERRORS = {
	[StreamRadioLib.EDITOR_ERROR_RENAME_DIR] = true,
	[StreamRadioLib.EDITOR_ERROR_RENAME_EXIST] = true,
	[StreamRadioLib.EDITOR_ERROR_RENAME_WRITE] = true,
	[StreamRadioLib.EDITOR_ERROR_RENAME_READ] = true,
}

local function ShowError( errorheader, errortext, this, func, ... )
	if not IsValid(this) then return false end
	if not this:IsVisible() then return false end
	local args = {...}

	Derma_Query( errortext, errorheader, "OK", function( )
		if not IsValid(this) then return end
		if this:IsLoading() then return end
		if not func then return end

		func(this, unpack(args))
	end)

	return true
end

--Ask for save: Opens a confirmation box.
local function AsForSave( this, func, ... )
	if not IsValid(this) then return false end
	if not this:IsVisible() then return false end
	if not func then return false end

	if not this.m_bUnsaved then
		func( this, ... )
		return true
	end

	local args = {...}

	Derma_Query("Are you sure to discard the changes?", "Unsaved playlist!", "Yes", function()
		-- Discard the changes.
		if not IsValid(this) then return end
		if this:IsLoading() then return end

		this:RemoveNewFile()
		func( this, unpack( args ) )
	end, "No")

	-- Don't discard the changes.
	return true
end

local function CreateDir( self, defaultString, func, ... )
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end

	local args = {...}
	local path = self.m_strPath or ""
	local name = "new_folder"

	defaultString = string.Trim(defaultString or "")

	if not StreamRadioLib.String.IsValidFilepath(defaultString) then
		defaultString = name
	end

	local helpText = [[
Create a new folder
- All invalid characters are fitered out
- Case insensitive, converted to lowercase
]];

	helpText = string.Trim(helpText)

	Derma_StringRequest("New folder", helpText, defaultString, function( strTextOut )
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		strTextOut = StreamRadioLib.String.SanitizeFilename(strTextOut)

		if not StreamRadioLib.String.IsValidFilepath(strTextOut) then
			CreateDir(self, defaultString, func, unpack(args))
			return
		end

		local fullpath = path .. "/" .. strTextOut
		fullpath = string.Trim(fullpath, "/")

		if StreamRadioLib.String.IsVirtualPath(fullpath) then
			local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_VIRTUAL_PROTECTED )
			ShowError( "Create error!", ErrorText, self, CreateFile, strTextOut, func, unpack( args ) )

			return
		end

		if self.FileItems[strTextOut] then
			local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_DIR_EXIST )
			ShowError( "Directory error!", ErrorText, self, CreateDir, strTextOut, func, unpack( args ) )

			return
		end

		local created = StreamRadioLib.Editor.CreateDir(fullpath)

		if created and func then
			func( self, unpack( args ) )
		end
	end, nil, "Create folder", "Cancel")

	return true
end

local function AsForDelete( self, func, ... )
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if not IsValid(self.Files) then return false end

	local line = self.Files:GetSelectedLine( )
	line = self.Files:GetLine( line )
	if not IsValid( line ) then return false end

	local args = {...}
	local path = line.streamradio_path or ""
	local format = line.streamradio_filetype

	if path == "" then return false end
	if not format then return false end

	Derma_Query( "Are you sure to delete this file/folder?", "Delete file!", "Yes", function( )
		-- Delete.
		if not IsValid(self) then return end
		if not IsValid(line) then return end
		if self:IsLoading() then return end

		if path == "" then return end
		if not format then return end

		local removed = StreamRadioLib.Editor.Remove(path, format)

		if removed and func then
			func( self, unpack( args ) )
		end
	end, "No" )

	-- Don't delete.
	return true
end

local function CreateFile( self, defaultString, func, ... )
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if not func then return false end

	local Default_Format = StreamRadioLib.Filesystem.GetTypeExt(StreamRadioLib.TYPE_DEFAULT)

	local name = "new_playlist." .. Default_Format
	defaultString = string.Trim(defaultString or "")

	if not StreamRadioLib.String.IsValidFilename(defaultString) then
		defaultString = name
	end

	local args = {...}
	local path = self.m_strPath or ""

	local helpText = [[
Create a new playlist
- All invalid characters are fitered out
- Case insensitive, converted to lowercase
- Valid formats are: %s
]]
	helpText = string.format(helpText, StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST or "")
	helpText = string.Trim(helpText)

	AsForSave(self, function( self, func, args )
		Derma_StringRequest( "New playlist..", helpText, defaultString, function( strTextOut )
			if not IsValid(self) then return end
			if self:IsLoading() then return end

			strTextOut = StreamRadioLib.String.SanitizeFilename(strTextOut)

			if not StreamRadioLib.String.IsValidFilename(strTextOut) then
				CreateFile( self, defaultString, func, unpack( args ) )
				return
			end

			local fullpath = path .. "/" .. strTextOut
			fullpath = string.Trim(fullpath, "/")

			if not StreamRadioLib.Filesystem.GuessType(fullpath) then
				strTextOut = strTextOut .. "." .. Default_Format

				CreateFile( self, strTextOut, func, unpack( args ) )
				return
			end

			if StreamRadioLib.String.IsVirtualPath(fullpath) then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_WVIRTUAL )
				ShowError( "Create error!", ErrorText, self, CreateFile, strTextOut, func, unpack( args ) )

				return
			end

			if self.FileItems[strTextOut] then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_FILE_EXIST )
				ShowError( "Create error!", ErrorText, self, CreateFile, strTextOut, func, unpack( args ) )

				return
			end

			local format = StreamRadioLib.Filesystem.GuessType(fullpath)
			if not StreamRadioLib.Filesystem.CanCreateFormat(format) then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_WFORMAT )
				ShowError( "Create error!", ErrorText, self, CreateFile, strTextOut, func, unpack( args ) )

				return
			end

			if func then
				func(self, strTextOut, format, unpack(args))
			end
		end, nil, "Create new file", "Cancel")
	end, func, args)

	return true
end

--Ask for override
local function AsForOverride( self, func, filename, ... )
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if not func then return false end
	local args = {...}

	local filenamelower = string.lower(filename)

	if not self.FileItems[filenamelower] then
		func(self, filename, unpack( args ))
		return true
	end

	Derma_Query( "Overwrite this file?", "Save to..", "Overwrite", function( )
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		func( self, filename, unpack( args ) )
	end, "Cancel" )

	return true
end

local function SaveTo(self, defaultString, func, ...)
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if not IsValid(self.Files) then return false end
	if not func then return false end

	local Default_Format = StreamRadioLib.Filesystem.GetTypeExt(StreamRadioLib.TYPE_DEFAULT)

	local args = {...}
	local path = self.m_strFolderPath or ""
	local line = self.Files:GetSelectedLine( )
	line = self.Files:GetLine( line )
	local name = "new_playlist." .. Default_Format

	if IsValid(line) then
		name = line.streamradio_name
	end

	defaultString = string.Trim(defaultString or "")

	if not StreamRadioLib.String.IsValidFilename(defaultString) then
		defaultString = name
	end

	local helpText = [[
Save a file
- All invalid characters are fitered out
- Case insensitive, converted to lowercase
- Valid formats are: %s
]]
	helpText = string.format(helpText, StreamRadioLib.VALID_FORMATS_EXTENSIONS_LIST or "")
	helpText = string.Trim(helpText)

	Derma_StringRequest("Save to..", helpText, defaultString, function(strTextOut)
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		strTextOut = StreamRadioLib.String.SanitizeFilename(strTextOut)

		if not StreamRadioLib.String.IsValidFilename(strTextOut) then
			SaveTo(self, defaultString, func, unpack(args))
			return
		end

		local fullpath = path .. "/" .. strTextOut
		fullpath = string.Trim(fullpath, "/")

		if not StreamRadioLib.Filesystem.GuessType(fullpath) then
			strTextOut = strTextOut .. "." .. Default_Format

			SaveTo(self, strTextOut, func, unpack(args))
			return
		end

		local format = StreamRadioLib.Filesystem.GuessType(fullpath)

		if not StreamRadioLib.Filesystem.CanWriteFormat(format) then
			if StreamRadioLib.String.IsVirtualPath(fullpath) then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_WVIRTUAL )
				ShowError( "Save error!", ErrorText, self, SaveTo, strTextOut, func, unpack( args ) )

				return
			end

			local ErrorText = StreamRadioLib.DecodeEditorErrorCode(StreamRadioLib.EDITOR_ERROR_WFORMAT)
			ShowError("Save error!", ErrorText, self, SaveTo, strTextOut, func, unpack(args))

			return
		end

		if not self.FileItems[strTextOut] then
			if StreamRadioLib.String.IsVirtualPath(fullpath) then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_WVIRTUAL )
				ShowError( "Create error!", ErrorText, self, SaveTo, strTextOut, func, unpack( args ) )

				return
			end

			if not StreamRadioLib.Filesystem.CanCreateFormat(format) then
				local ErrorText = StreamRadioLib.DecodeEditorErrorCode( StreamRadioLib.EDITOR_ERROR_WFORMAT )
				ShowError( "Create error!", ErrorText, self, SaveTo, strTextOut, func, unpack( args ) )

				return
			end
		end

		AsForOverride(self, function(self, fullpath, strTextOut, format, func, args)
			func(self, fullpath, strTextOut, format, unpack(args))
		end, fullpath, strTextOut, format, func, args)
	end, nil, "Save to file", "Cancel")

	return true
end

local function FileMenu(self, item, path, name, filetype, parentpath)
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if self:IsLoading() then return false end


	local newfile = self.NewFileItem == item
	local Menu = DermaMenu()
	local MenuItem = nil

	MenuItem = Menu:AddOption("Open", function()
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		self.Files:DoDoubleClick(item:GetID(), item)
	end)

	MenuItem:SetImage("icon16/table_add.png")
	Menu:AddSpacer( )

	MenuItem = Menu:AddOption("Refresh", function()
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		self:Refresh()
	end)

	MenuItem:SetImage("icon16/arrow_refresh.png")

	if not StreamRadioLib.String.IsVirtualPath(parentpath) then
		Menu:AddSpacer( )

		--New
		MenuItem = Menu:AddOption("New", function()
			if not IsValid(self) then return end
			if self:IsLoading() then return end

			CreateFile(self, nil, self.CreateNewFile)
		end)

		MenuItem:SetImage("icon16/table_add.png")

		MenuItem = Menu:AddOption("New folder", function()
			if not IsValid(self) then return end
			if self:IsLoading() then return end

			CreateDir(self, nil, self.Lock, true)
		end)

		MenuItem:SetImage("icon16/folder_add.png")

		--Delete
		if StreamRadioLib.Filesystem.CanDeleteFormat(filetype) and not StreamRadioLib.String.IsVirtualPath(path) then
			Menu:AddSpacer( )
			MenuItem = Menu:AddOption("Delete", function()
				if not IsValid(self) then return end
				if self:IsLoading() then return end

				if newfile then
					AsForDelete(self, self.RemoveNewFile)

					return
				end

				AsForDelete(self, self.Lock, true)
			end)

			MenuItem:SetImage("icon16/bin_closed.png")
		end
	end

	Menu:Open()
	return true
end

local function PlaylistMenu( self, item, url, name, parentpath )
	if not IsValid(self) then return false end
	if not self:IsVisible() then return false end
	if self:IsLoading() then return false end

	local Menu = DermaMenu()
	local MenuItem = nil

	MenuItem = Menu:AddOption( "Copy Entry", function( )
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		if self:AddPlaylistItem() then
			self:SetUnsaved(true)
		end
	end)

	MenuItem:SetImage( "icon16/add.png" )

	MenuItem = Menu:AddOption( "Remove Entry", function( )
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		if self:RemovePlaylistItem(item) then
			self:SetUnsaved(true)
		end
	end)

	MenuItem:SetImage( "icon16/delete.png" )
	Menu:AddSpacer( )

	MenuItem = Menu:AddOption( "Move Up", function( )
		if not IsValid(self) then return end
		if self:IsLoading() then return end
		self:PlaylistCheckValid()

		if self:MovePlaylistItemUp(item) then
			self:SetUnsaved(true)
		end
	end )

	MenuItem:SetImage( "icon16/arrow_up.png" )

	MenuItem = Menu:AddOption( "Move Down", function( )
		if not IsValid(self) then return end
		if self:IsLoading() then return end

		self:PlaylistCheckValid()

		if self:MovePlaylistItemDown(item) then
			self:SetUnsaved( true )
		end
	end )

	MenuItem:SetImage( "icon16/arrow_down.png" )
	Menu:Open( )

	return true
end

function PANEL:IsLoading( )
	return self.IsLocked
end

function PANEL:Init( )
	self:SetPaintBackground( false )
	self.FilesPanel = vgui.Create( "DPanel" )
	self.FilesPanel:SetPaintBackground( false )

	self.PlaylistPanel = vgui.Create( "DPanel" )
	self.PlaylistPanel:SetPaintBackground( false )

	self.Files = self.FilesPanel:Add( "DListView" )
	self.Files:SetMultiSelect( false )
	self.Files:Dock( FILL )
	self.Files:AddColumn( "Name" )
	local Column = self.Files:AddColumn( "Type" )
	Column:SetFixedWidth( 70 )
	Column:SetWide( 70 )

	self.Files.DoDoubleClick = function( parent, id, line )
		if self:IsLoading( ) then return end
		if ( self.LastFileItem == line ) then return end
		self.LastFileItem = line
		if ( self.NewFileItem == line ) then return end

		local path = line.streamradio_path
		local filetype = line.streamradio_filetype

		self:SetPath( path, filetype, false, true )
	end

	self.Files.OnRowRightClick = function( parent, id, line )
		if self:IsLoading( ) then return end
		local path = line.streamradio_path
		local name = line.streamradio_name
		local filetype = line.streamradio_filetype
		local parentpath = line.streamradio_parentpath
		FileMenu( self, line, path, name, filetype, parentpath )
	end

	self.PlaylistTabPanel = self.PlaylistPanel:Add( "DPropertySheet" )
	self.PlaylistTabPanel:Dock( FILL )
	self.PlaylistTabPanel:SetFadeTime( 0 )

	self.PlaylistTabPanel.OnActiveTabChanged = function(this, old_panel, new_panel)
		if self:IsLoading( ) then return end

		StreamRadioLib.Timedcall(function()
			self:UpdatePlaylistEditorFromTextPanel()
			self:UpdatePlaylistTextFromEditorPanel()
		end)
	end

	self.PlaylistEditorPanel = vgui.Create( "DPanel" )
	local playlistEditorSheet = self.PlaylistTabPanel:AddSheet( "list", self.PlaylistEditorPanel, "icon16/table.png" )
	self.PlaylistEditorPanel:SetPaintBackground( false )

	self.PlaylistTextPanel = vgui.Create( "DPanel" )
	local playlistTextSheet = self.PlaylistTabPanel:AddSheet( "text", self.PlaylistTextPanel, "icon16/page_white.png" )
	self.PlaylistTextPanel:SetPaintBackground( false )

	playlistEditorSheet.Tab:SetText("List mode")
	playlistEditorSheet.Tab:SetTooltip("Edit the playlist in a list view")
	playlistTextSheet.Tab:SetText("Text mode")
	playlistTextSheet.Tab:SetTooltip("Edit the playlist in a text field (for advanced users)")

	self.Playlist = self.PlaylistEditorPanel:Add( "DListView" )
	self.Playlist:SetMultiSelect( false )
	self.Playlist:Dock( FILL )
	local Column = self.Playlist:AddColumn( "No." )
	Column:SetFixedWidth( 30 )
	Column:SetWide( 30 )
	local Column = self.Playlist:AddColumn( "Name" )
	Column:SetWide( 50 )
	self.Playlist:AddColumn( "URL" )

	self.Playlist.OnRowSelected = function( parent, id, line )
		if self:IsLoading( ) then return end
		self:SelectPlaylistItem( line )
	end

	self.Playlist.DoDoubleClick = function( parent, id, line )
		if self:IsLoading( ) then return end
		self:SelectPlaylistItem( line )
	end

	self.Playlist.OnRowRightClick = function( parent, id, line )
		if self:IsLoading( ) then return end
		local url = line.streamradio_url
		local name = line.streamradio_name

		PlaylistMenu( self, line, url, name, self.PlaylistItems["parentpath"] )
		self:SelectPlaylistItem( line )
	end

	self.PlaylistBottomPanel = self.PlaylistEditorPanel:Add( "DPanel" )
	self.PlaylistBottomPanel:SetPaintBackground( false )
	self.PlaylistBottomPanel:Dock( BOTTOM )
	self.PlaylistBottomPanel:SetTall( 110 )
	self.PlaylistBottomPanel:DockMargin( 0, 3, 0, 0 )

	self.EditNamePanel = self.PlaylistBottomPanel:Add( "DPanel" )
	self.EditNamePanel:SetPaintBackground( false )
	self.EditNamePanel:Dock( TOP )
	self.EditNamePanel:SetTall( 20 )
	self.EditNamePanel:DockMargin( 0, 0, 0, 3 )

	self.EditURLPanel = self.PlaylistBottomPanel:Add( "DPanel" )
	self.EditURLPanel:SetPaintBackground( false )
	self.EditURLPanel:Dock( TOP )
	self.EditURLPanel:SetTall( 60 )
	self.EditURLPanel:DockMargin( 0, 0, 0, 3 )

	self.EditButtonsPanel = self.PlaylistBottomPanel:Add( "DPanel" )
	self.EditButtonsPanel:SetPaintBackground( false )
	self.EditButtonsPanel:Dock( BOTTOM )
	self.EditButtonsPanel:SetTall( 20 )
	self.EditButtonsPanel:DockMargin( 0, 0, 0, 0 )

	self.EditNameText = self.EditNamePanel:Add( "DTextEntry" )
	self.EditNameText:DockMargin( 0, 0, 0, 0 )
	self.EditNameText:Dock( FILL )

	if self.EditNameText.SetPlaceholderText then
		-- Some client have some addon conflicts
		-- This causes them to not have the panel:SetPlaceholderText() function

		self.EditNameText:SetPlaceholderText("Enter a name for this Entry")
	end

	self.EditNameText.OnEnter = function( panel )
		if self:IsLoading() then return end
		self:PlaylistCheckValid()
	end

	self.EditNameText.OnChange = function( panel )
		if self:IsLoading() then return end
		self:PlaylistCheckValid()
	end

	self.EditNameLabel = self.EditNamePanel:Add( "DLabel" )
	self.EditNameLabel:SetText( "Name:" )
	self.EditNameLabel:SetWide( 40 )
	self.EditNameLabel:SetDark( true )
	self.EditNameLabel:DockMargin( 6, 0, 0, 0 )
	self.EditNameLabel:Dock( LEFT )

	self.EditURLText = self.EditURLPanel:Add( "Streamradio_VGUI_URLTextEntry" )
	self.EditURLText:DockMargin( 0, 0, 0, 0 )
	self.EditURLText:Dock( FILL )

	self.EditURLText.OnEnter = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )
	end

	self.EditURLText.OnChange = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )
	end

	self.EditURLLabel = self.EditURLPanel:Add( "DLabel" )
	self.EditURLLabel:SetText( "URL:" )
	self.EditURLLabel:SetWide( 40 )
	self.EditURLLabel:SetDark( true )
	self.EditURLLabel:DockMargin( 6, 0, 0, 0 )
	self.EditURLLabel:Dock( LEFT )

	self.EditChangeButton = self.EditButtonsPanel:Add( "DButton" )
	self.EditChangeButton:SetWide( 100 )
	self.EditChangeButton:DockMargin( 6, 0, 0, 0 )
	self.EditChangeButton:Dock( RIGHT )
	self.EditChangeButton:SetText( "Apply" )
	self.EditChangeButton:SetImage( "icon16/pencil.png" )

	self.EditChangeButton.DoClick = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )

		if ( self:ChangePlaylistItem( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end
	end

	self.EditAddButton = self.EditButtonsPanel:Add( "DButton" )
	self.EditAddButton:SetWide( 100 )
	self.EditAddButton:DockMargin( 6, 0, 0, 0 )
	self.EditAddButton:Dock( RIGHT )
	self.EditAddButton:SetText( "Add" )
	self.EditAddButton:SetImage( "icon16/add.png" )

	self.EditAddButton.DoClick = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )

		if ( self:AddPlaylistItem( ) ) then
			self:SetUnsaved( true )
		end
	end

	local starttimeout = 0.5
	local holdtimeout = 0.075

	self.EditMoveDownButton = self.EditButtonsPanel:Add( "DButton" )
	self.EditMoveDownButton:SetWide( self.EditMoveDownButton:GetTall() + 10 )
	self.EditMoveDownButton:DockMargin( 6, 0, 0, 0 )
	self.EditMoveDownButton:Dock( RIGHT )
	self.EditMoveDownButton:SetText( "" )
	self.EditMoveDownButton:SetTooltip( "Move item down" )

	self.EditMoveDownButtonImage = vgui.Create( "DImage", self.EditMoveDownButton )
	if ( IsValid( self.EditMoveDownButtonImage ) ) then
		self.EditMoveDownButtonImage:SetImage( "icon16/arrow_down.png" )
		self.EditMoveDownButtonImage:SizeToContents()

		local w1, h1 = self.EditMoveDownButton:GetSize()
		local w2, h2 = self.EditMoveDownButtonImage:GetSize()

		self.EditMoveDownButtonImage:SetPos((w1 - w2) / 2, (h1 - h2) / 2)
	end

	self.EditMoveUpButton = self.EditButtonsPanel:Add( "DButton" )
	self.EditMoveUpButton:SetWide( self.EditMoveUpButton:GetTall() + 10 )
	self.EditMoveUpButton:DockMargin( 6, 0, 0, 0 )
	self.EditMoveUpButton:Dock( RIGHT )
	self.EditMoveUpButton:SetText( "" )
	self.EditMoveUpButton:SetTooltip( "Move item up" )

	self.EditMoveUpButtonImage = vgui.Create( "DImage", self.EditMoveUpButton )
	if ( IsValid( self.EditMoveUpButtonImage ) ) then
		self.EditMoveUpButtonImage:SetImage( "icon16/arrow_up.png" )
		self.EditMoveUpButtonImage:SizeToContents()

		local w1, h1 = self.EditMoveUpButton:GetSize()
		local w2, h2 = self.EditMoveUpButtonImage:GetSize()

		self.EditMoveUpButtonImage:SetPos((w1 - w2) / 2, (h1 - h2) / 2)
	end

	self.EditMoveUpButton.DoClick = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )

		if ( self:MovePlaylistItemUp( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end

		self.EditMoveUpButton.streamradio_presstime = nil
		self.EditMoveDownButton.streamradio_presstime = nil
	end
	self.EditMoveUpButton.OnHold = function( panel )
		if ( not panel.streamradio_presstime ) then
			panel.streamradio_presstime = RealTime() + starttimeout
		end

		if ( ( RealTime() - panel.streamradio_presstime ) < holdtimeout ) then return end
		self:PlaylistCheckValid( )

		if ( self:MovePlaylistItemUp( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end

		panel.streamradio_presstime = RealTime()
	end

	self.EditMoveDownButton.DoClick = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )

		if ( self:MovePlaylistItemDown( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end

		self.EditMoveUpButton.streamradio_presstime = nil
		self.EditMoveDownButton.streamradio_presstime = nil
	end
	self.EditMoveDownButton.OnHold = function( panel )
		if ( not panel.streamradio_presstime ) then
			panel.streamradio_presstime = RealTime() + starttimeout
		end

		if ( ( RealTime() - panel.streamradio_presstime ) < holdtimeout ) then return end
		self:PlaylistCheckValid( )

		if ( self:MovePlaylistItemDown( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end

		panel.streamradio_presstime = RealTime()
	end

	self.EditRemoveButton = self.EditButtonsPanel:Add( "DButton" )
	self.EditRemoveButton:SetWide( 100 )
	self.EditRemoveButton:DockMargin( 0, 0, 0, 0 )
	self.EditRemoveButton:Dock( LEFT )
	self.EditRemoveButton:SetText( "Remove" )
	self.EditRemoveButton:SetImage( "icon16/delete.png" )

	self.EditRemoveButton.DoClick = function( panel )
		if self:IsLoading( ) then return end
		self:PlaylistCheckValid( )

		if ( self:RemovePlaylistItem( self.SelectedPlaylistItem ) ) then
			self:SetUnsaved( true )
		end
	end

	self.PlaylistText = self.PlaylistTextPanel:Add( "DTextEntry" )
	self.PlaylistText:Dock( FILL )

	local TextEditorFont = StreamRadioLib.Surface.AddFont(14, 1000, "Lucida Console")

	self.PlaylistText:SetEditable( true )
	self.PlaylistText:SetMultiline( true )
	self.PlaylistText:SetDrawLanguageID( false )
	self.PlaylistText:SetTabbingDisabled( true )
	self.PlaylistText:SetHistoryEnabled( false )
	self.PlaylistText:SetEnterAllowed( true )
	self.PlaylistText:SetDrawBorder( true )
	self.PlaylistText:SetVerticalScrollbarEnabled( true )
	self.PlaylistText:SetUpdateOnType( true )
	self.PlaylistText:SetFont(TextEditorFont)

	self.PlaylistText.OnValueChange = function( )
		if self:IsLoading( ) then return end

		self:MarkPlaylistEditorShouldUpdate()
		self:SetUnsaved( true )
	end

	self.PlaylistTextBottomPanel = self.PlaylistTextPanel:Add( "DPanel" )
	self.PlaylistTextBottomPanel:SetPaintBackground( false )
	self.PlaylistTextBottomPanel:Dock( BOTTOM )
	self.PlaylistTextBottomPanel:SetTall( 100 )
	self.PlaylistTextBottomPanel:DockMargin( 0, 3, 0, 0 )

	local helpTextGeneral = [[
About this text based playlist editor:

- Changes are automatically synchronized between this view and the list view.
- Enter the name and the URL for each entry you want to add.
- The syntax is independent from the playlist format.
- Missing lines are skipped or are filled with placeholders.
- Whitespaces are trimed on each line.
]]

	local helpTextSyntax = [[
Example:

1.FM - ABSOLUTE TOP 40 RADIO [newline]
http://185.33.21.112:80/top40_128 [newline]
1.FM - Alternative Rock X Hits [newline]
http://185.33.21.112:80/x_128 [newline]
...
]]

	helpTextGeneral = string.Trim(helpTextGeneral)
	helpTextSyntax = string.Trim(helpTextSyntax)

	self.PlaylistTextHelpGeneralLabel = self.PlaylistTextBottomPanel:Add( "Streamradio_VGUI_ReadOnlyTextEntry" )
	self.PlaylistTextHelpGeneralLabel:SetText(helpTextGeneral)
	self.PlaylistTextHelpGeneralLabel:DockMargin( 6, 0, 0, 0 )
	self.PlaylistTextHelpGeneralLabel:SetWide( 400 )
	self.PlaylistTextHelpGeneralLabel:Dock( LEFT )
	self.PlaylistTextHelpGeneralLabel:SetZPos(100)

	self.PlaylistTextHelpSyntaxLabel = self.PlaylistTextBottomPanel:Add( "Streamradio_VGUI_ReadOnlyTextEntry" )
	self.PlaylistTextHelpSyntaxLabel:SetText(helpTextSyntax)
	self.PlaylistTextHelpSyntaxLabel:DockMargin( 6, 0, 0, 0 )
	self.PlaylistTextHelpSyntaxLabel:SetWide( 400 )
	self.PlaylistTextHelpSyntaxLabel:Dock( LEFT )
	self.PlaylistTextHelpSyntaxLabel:SetZPos(200)


	self.TopPanel = self:Add( "DPanel" )
	self.TopPanel:SetPaintBackground( false )
	self.TopPanel:Dock( TOP )
	self.TopPanel:SetTall( 20 )
	self.TopPanel:DockMargin( 0, 0, 0, 3 )

	self.SaveIcon = self.TopPanel:Add( "DImageButton" )
	self.SaveIcon:SetImage( "icon16/table_save.png" )
	self.SaveIcon:SetWide( 20 )
	self.SaveIcon:Dock( LEFT )
	self.SaveIcon:SetTooltip( "Save list" )
	self.SaveIcon:SetStretchToFit( false )
	self.SaveIcon:DockMargin( 0, 0, 0, 0 )

	self.SaveIcon.DoClick = function( )
		if self:IsLoading( ) then return end

		if ( not self.m_strPath or self.m_strPath == "" or self.m_strPath == self.m_strFolderPath ) then
			SaveTo( self, nil, self.SavePlaylist )

			return
		end

		self:SavePlaylist( )
	end

	self.SaveToIcon = self.TopPanel:Add( "DImageButton" )
	self.SaveToIcon:SetImage( "icon16/disk.png" )
	self.SaveToIcon:SetWide( 20 )
	self.SaveToIcon:Dock( LEFT )
	self.SaveToIcon:SetTooltip( "Save to.." )
	self.SaveToIcon:SetStretchToFit( false )
	self.SaveToIcon:DockMargin( 0, 0, 0, 0 )

	self.SaveToIcon.DoClick = function( )
		if self:IsLoading( ) then return end
		SaveTo( self, nil, self.SavePlaylist )
	end

	self.NewIcon = self.TopPanel:Add( "DImageButton" )
	self.NewIcon:SetImage( "icon16/table_add.png" )
	self.NewIcon:SetWide( 20 )
	self.NewIcon:Dock( LEFT )
	self.NewIcon:SetTooltip( "New list" )
	self.NewIcon:SetStretchToFit( false )
	self.NewIcon:DockMargin( 10, 0, 0, 0 )

	self.NewIcon.DoClick = function( )
		if self:IsLoading( ) then return end
		CreateFile( self, nil, self.CreateNewFile )
	end

	self.NewFolder = self.TopPanel:Add( "DImageButton" )
	self.NewFolder:SetImage( "icon16/folder_add.png" )
	self.NewFolder:SetWide( 20 )
	self.NewFolder:Dock( LEFT )
	self.NewFolder:SetTooltip( "New folder" )
	self.NewFolder:SetStretchToFit( false )
	self.NewFolder:DockMargin( 0, 0, 0, 0 )

	self.NewFolder.DoClick = function( )
		if self:IsLoading( ) then return end
		CreateDir( self, nil, self.Lock, true )
	end

	self.RefreshIcon = self.TopPanel:Add( "DImageButton" )
	self.RefreshIcon:SetImage( "icon16/arrow_refresh.png" )
	self.RefreshIcon:SetWide( 20 )
	self.RefreshIcon:Dock( LEFT )
	self.RefreshIcon:SetTooltip( "Refresh and reload" )
	self.RefreshIcon:SetStretchToFit( false )
	self.RefreshIcon:DockMargin( 10, 0, 0, 0 )

	self.RefreshIcon.DoClick = function( )
		if self:IsLoading( ) then return end
		self:Refresh( )
	end

	self.ApplySortIcon = self.TopPanel:Add( "DImageButton" )
	self.ApplySortIcon:SetImage( "icon16/lightning.png" )
	self.ApplySortIcon:SetWide( 20 )
	self.ApplySortIcon:Dock( LEFT )
	self.ApplySortIcon:SetTooltip( "Apply current sort to playlist" )
	self.ApplySortIcon:SetStretchToFit( false )
	self.ApplySortIcon:DockMargin( 10, 0, 0, 0 )

	self.ApplySortIcon.DoClick = function( )
		if self:IsLoading( ) then return end
		self:ApplyPlaylistSort( )

		self:SetUnsaved( true )
		self:MarkPlaylistTextShouldUpdate( true )
	end

	self.ListNameLabel = self.TopPanel:Add( "Streamradio_VGUI_ReadOnlyTextEntry" )
	self.ListNameLabel:SetText( "" )
	self.ListNameLabel:SetWide( 20 )
	self.ListNameLabel:Dock( FILL )
	self.ListNameLabel:DockMargin( 12, 0, 0, 0 )
	self.ListNameLabel:SetMultiline( false )

	self.SplitPanel = self:Add( "DHorizontalDivider" )
	self.SplitPanel:Dock( FILL )
	self.SplitPanel:SetRight( self.PlaylistPanel )
	self.SplitPanel:SetLeft( self.FilesPanel )
	self.SplitPanel:SetLeftWidth( 300 )
	self.SplitPanel:SetLeftMin( 200 )
	self.SplitPanel:SetRightMin( 400 )
	self.SplitPanel:SetDividerWidth( 3 )

	self:Reset( )
end

function PANEL:SavePlaylist( filepath, name, filetype )
	if self:IsLoading() then return false end
	if self.m_bSaving then return false end

	if self.PlaylistTextPanel._isDirty then
		self:BuildPlaylistFromTextPanel()
	end

	if filepath and name and filetype then
		self.m_strPath = filepath
		self.Format = filetype

		self.PlaylistItems["format"] = filetype
		self.PlaylistItems["parentpath"] = self.m_strFolderPath
	end

	if not StreamRadioLib.Editor.Save(filepath or self.m_strPath, self.PlaylistItems) then return false end
	local fileitem = self:AddFileItem(filepath, name, self.m_strFolderPath, filetype)

	if IsValid(fileitem) then
		self.Files:ClearSelection()
		self.Files:SortByColumn(1)
		self.Files:SelectItem(fileitem)

		self.NewFileItem = fileitem
		self.LastFileItem = fileitem
	end

	self.m_bSaving = true
	self:Lock(true)

	return true
end

local function EnablePanel( button, bool )
	if ( not bool ) then
		button.Depressed = false
		button.m_bSelected = false
		button.Hovered = false

		button.streamradio_presstime = nil
	end

	button:SetMouseInputEnabled( bool )
	button:SetEnabled( bool )
	button:SetKeyboardInputEnabled( bool )
end

function PANEL:Lock( bool )
	bool = bool or false

	EnablePanel( self, not bool )
	self.IsLocked = bool
end

function PANEL:BuildPlaylistFromTextPanel()
	if not self.PlaylistItems then
		self.PlaylistItems = {}

		self.PlaylistTextPanel._isDirty = nil
		self.PlaylistEditorPanel._isDirty = nil
		return
	end

	local lines = self.PlaylistText:GetText()
	lines = StreamRadioLib.String.NormalizeNewlines(lines, '\n')

	lines = string.Explode("\n", lines, false) or {}

	local len = #lines

	self.Playlist:Clear( )
	self.PlaylistItems = self:GetEmptyPlaylistItems()

	local index = 1

	for i = 1, len, 2 do
		local name = string.Trim(lines[i] or "")
		local url = string.Trim(lines[i + 1] or "")

		if name == "" and url == "" then
			continue
		end

		if name == "" then
			name = string.format("(no name #%d)", index)
		end

		if url == "" then
			url = string.format("(no url #%d)", index)
		end

		self:AddPlaylistItem(url, name)
		index = index + 1
	end

	self:SelectPlaylistItem( )
	self:PlaylistCheckValid( )

	self.PlaylistTextPanel._isDirty = nil
	self.PlaylistEditorPanel._isDirty = nil
end

function PANEL:BuildTextFromPlaylistPanel()
	local lines = {}
	local index = 1

	for i, v in ipairs( self.PlaylistItems or {} ) do
		local name = string.Trim(v.name or "")
		local url = string.Trim(v.url or "")

		if name == "" and url == "" then
			continue
		end

		if name == "" then
			name = string.format("(no name #%d)", index)
		end

		if url == "" then
			url = string.format("(no url #%d)", index)
		end

		table.insert(lines, name)
		table.insert(lines, url)

		index = index + 1
	end

	lines = table.concat(lines, "\n")
	self.PlaylistText:SetText(lines)

	self.PlaylistTextPanel._isDirty = nil
	self.PlaylistEditorPanel._isDirty = nil
end

function PANEL:MarkPlaylistEditorShouldUpdate(alsoTryUpdate)
	self.PlaylistTextPanel._isDirty = true

	if alsoTryUpdate then
		self:UpdatePlaylistEditorFromTextPanel()
	end
end

function PANEL:MarkPlaylistTextShouldUpdate(alsoTryUpdate)
	self.PlaylistEditorPanel._isDirty = true

	if alsoTryUpdate then
		self:UpdatePlaylistTextFromEditorPanel()
	end
end

function PANEL:UpdatePlaylistEditorFromTextPanel()
	if not self.PlaylistItems then
		return
	end

	local tab = self.PlaylistTabPanel:GetActiveTab()
	if not IsValid(tab) then
		return
	end

	local activePanel = tab:GetPanel()
	if not IsValid(activePanel) then
		return
	end

	if activePanel ~= self.PlaylistEditorPanel then
		return
	end

	if not self.PlaylistTextPanel._isDirty then
		return
	end

	self:BuildPlaylistFromTextPanel()
end

function PANEL:UpdatePlaylistTextFromEditorPanel()
	if not self.PlaylistItems then
		return
	end

	local tab = self.PlaylistTabPanel:GetActiveTab()
	if not IsValid(tab) then
		return
	end

	local activePanel = tab:GetPanel()
	if not IsValid(activePanel) then
		return
	end

	if activePanel ~= self.PlaylistTextPanel then
		return
	end

	if not self.PlaylistEditorPanel._isDirty then
		return
	end

	self:BuildTextFromPlaylistPanel()
end

function PANEL:Clear( )
	self:ClearFiles( )
	self:ClearPlaylist( )
end

function PANEL:ClearFiles( )
	self.Files:Clear( )
	self.FileItems = {}
	self:InvalidateLayout( )
end

function PANEL:ClearPlaylist( )
	self.Playlist:Clear( )
	self.PlaylistItems = {}
	self:SelectPlaylistItem( )
	self:PlaylistCheckValid( )
	self:SetUnsaved( false )
	self:ClearPlaylistText( )
	self:InvalidateLayout( )
end

function PANEL:ClearPlaylistText( )
	self.PlaylistText:SetText( "" )
	self:MarkPlaylistTextShouldUpdate( true )
	self:InvalidateLayout( )
end

function PANEL:GetEmptyPlaylistItems()
	local tmpTab = {}

	for k, v in pairs( self.PlaylistItems or {} ) do
		if not isstring( k ) then continue end
		tmpTab[k] = v
	end

	return tmpTab
end

function PANEL:PerformLayout( )
	if ( IsValid( self.SplitPanel ) ) then
		local minw = self:GetWide( ) - self.SplitPanel:GetRightMin( ) - self.SplitPanel:GetDividerWidth( )
		local oldminw = self.SplitPanel:GetLeftWidth( minw )

		if ( oldminw > minw ) then
			self.SplitPanel:SetLeftWidth( minw )
		end
	end

	--Fixes scrollbar glitches on resize
	if ( IsValid( self.Playlist ) ) then
		self.Playlist:OnMouseWheeled( 0 )
	end

	if ( IsValid( self.Files ) ) then
		self.Files:OnMouseWheeled( 0 )
	end

	StreamRadioLib.VR.RenderMenu(self)
end

local function Refresh( self )
	local filepath = self.m_strPath or ""
	local format = self.Format or StreamRadioLib.TYPE_FOLDER
	filepath = string.Trim( filepath, "\\" )
	filepath = string.Trim( filepath, "/" )
	filepath = string.Trim( filepath, "\\" )
	filepath = string.Trim( filepath, "/" )
	self:SetPath( filepath, format, true )

	if not StreamRadioLib.Filesystem.IsFolder(format) then
		self:SetPath( self.m_strFolderPath, StreamRadioLib.TYPE_FOLDER, true, true )
	end

	self.m_strPath = filepath
	self.Format = format
	self:UpdateListNameLabel( )
	self:InvalidateLayout( )
end

function PANEL:Reset( )
	self:Clear( )
	self.m_strPath = nil
	self.Format = nil
	self:Refresh( true )
end

function PANEL:Refresh( force )
	if ( force ) then
		Refresh( self )
	else
		AsForSave( self, Refresh )
	end
end

local function CallOnHold(panel)
	if ( not IsValid( panel ) ) then return end
	if ( not isfunction( panel.OnHold ) ) then return end
	if ( panel.IsDown and (not panel:IsDown() ) ) then return end

	panel.OnHold(panel)
end

function PANEL:Think( )
	if self:IsLoading( ) then return end

	CallOnHold(self.EditMoveUpButton)
	CallOnHold(self.EditMoveDownButton)
end

local loadcol = Color( 255, 0, 0, 255 )

function PANEL:PaintOver( w, h )
	if not self:IsLoading() then return end

	local sqmax, sqmin = math.max(w, h), math.min(w, h)
	local isq = math.min(sqmax * 0.125, sqmin * 0.5)

	StreamRadioLib.Surface.Loading((w - isq) / 2, (h - isq) / 2, isq, isq, loadcol, 8 )
end

function PANEL:PlaylistCheckValid( )
	local url = self.EditURLText:GetText( )
	local name = self.EditNameText:GetText( )
	local EnableEdit = ( url ~= "" and name ~= "" and self.EditURLText:CheckURL( true ) )
	local EnableSelect = IsValid( self.SelectedPlaylistItem ) and self.SelectedPlaylistItem.streamradio_id

	local EnableUp = EnableSelect and self.Playlist:GetSortedID(self.SelectedPlaylistItem:GetID()) > 1
	local EnableDown = EnableSelect and self.Playlist:GetSortedID(self.SelectedPlaylistItem:GetID()) < #self.PlaylistItems

	EnablePanel( self.EditAddButton, EnableEdit )
	EnablePanel( self.EditChangeButton, EnableEdit and EnableSelect )
	EnablePanel( self.EditRemoveButton, EnableSelect )
	EnablePanel( self.EditMoveUpButton, EnableUp )
	EnablePanel( self.EditMoveDownButton, EnableDown )
end

function PANEL:Callback(CallbackType, path, name, parentpath, filetype)
	if CallbackType == "files" then

		self:Lock(true)

		if StreamRadioLib.Filesystem.IsFolder(filetype) then
			self:AddFolderItem( path, name, parentpath, filetype )
		else
			self:AddFileItem( path, name, parentpath, filetype )
		end

	elseif CallbackType == "playlist" then

		self:SetUnsaved( false )
		self:Lock( true )
		self:AddPlaylistItem( path, name, parentpath, filetype )

	elseif CallbackType == "error" then

		if name == StreamRadioLib.EDITOR_ERROR_RESET then
			self:Reset( )
			return
		end

		if OK_CODES[name] then
			self:OnFinish( path, name )
		else
			self:OnError( path, name )
		end

	end
end

function PANEL:OnFinish( path, code )
	if code == StreamRadioLib.EDITOR_ERROR_OK then
		self.m_bSaving = false
		self:Lock( false )
		self:SetUnsaved( false )
		self:MarkPlaylistTextShouldUpdate( true )
	end

	if code == StreamRadioLib.EDITOR_ERROR_WRITE_OK then
		self.m_bSaving = false
		self:Lock( false )
		self:SetUnsaved( false )
	end

	if code == StreamRadioLib.EDITOR_ERROR_READ_OK then
		self:Lock( false )
		self:SetUnsaved( false )
		self:MarkPlaylistTextShouldUpdate( true )
	end

	if code == StreamRadioLib.EDITOR_ERROR_FILES_OK then
		self:Lock( false )
	end

	if code == StreamRadioLib.EDITOR_ERROR_DIR_OK then
		self:Lock( false )
		local name = string.GetFileFromFilename( path ) or ""

		if ( name == "" ) then
			name = path
		end

		local fileitem = self:AddFolderItem( path, name, self.m_strFolderPath, StreamRadioLib.TYPE_FOLDER )
		self.Files:ClearSelection( )
		self.Files:SortByColumn( 1 )
		if ( not IsValid( fileitem ) ) then return end
		self.Files:SelectItem( fileitem )
	end

	if code == StreamRadioLib.EDITOR_ERROR_DEL_OK then
		self:Lock( false )
		local line = self.Files:GetSelectedLine( )
		local linepanel = self.Files:GetLine( line )

		if not IsValid( linepanel ) then
			self:Refresh( true )

			return
		end

		if linepanel.streamradio_path ~= path then
			self:Refresh( true )

			return
		end

		if self.Clipboard == linepanel.streamradio_path then
			self.Clipboard = nil
		end

		if path == self.m_strPath and linepanel.streamradio_filetype ~= StreamRadioLib.TYPE_FOLDER then
			self.m_strPath = self.m_strFolderPath
			self.Format = StreamRadioLib.TYPE_FOLDER
			self:Refresh( true )

			return
		end

		local namelower = string.lower(linepanel.streamradio_name or "")
		self.FileItems[namelower] = nil

		self.Files:RemoveLine( line )
		self.Files:SortByColumn( 1 )
	end
end

function PANEL:OnError( path, code )
	local ErrorString = StreamRadioLib.DecodeEditorErrorCode( code )

	if WRITE_ERRORS[code] then
		self.m_bSaving = false
		self:Lock( false )
		ShowError( "Write error!", ErrorString, self )

		return
	end

	if READ_ERRORS[code] then
		self:Lock( false )
		self:SetUnsaved( false )
		ShowError( "Read error!", ErrorString, self )

		return
	end

	if DIR_ERRORS[code] then
		self:Lock( false )
		ShowError( "Directory error!", ErrorString, self )

		return
	end

	if code == StreamRadioLib.EDITOR_ERROR_DEL_ACCES then
		self:Lock( false )
		ShowError( "Delete error!", ErrorString, self )

		return
	end

	if COPY_ERRORS[code] then
		self:Lock( false )
		ShowError( "Copy error!", ErrorString, self )

		return
	end

	if RENAME_ERRORS[code] then
		self:Lock( false )
		ShowError( "Rename or move error!", ErrorString, self )

		return
	end

	self:Lock( false )
	ShowError( "General error! (" .. code .. ")", ErrorString, self )
end

function PANEL:RemoveNewFile()
	if not IsValid(self.Files) then return end
	if not IsValid(self.NewFileItem) then return end

	if self.Clipboard == self.NewFileItem.streamradio_path then
		self.Clipboard = nil
	end

	local namelower = string.lower(self.NewFileItem.streamradio_name or "")

	self.FileItems[namelower] = nil
	self.Files:RemoveLine(self.NewFileItem:GetID())
end

function PANEL:CreateNewFile(name, filetype)
	if not name then return false end
	if name == "" then return false end
	if not filetype then return false end

	local path = self.m_strFolderPath .. "/" .. name
	path = string.Trim(path, "/")

	local fileitem = self:AddFileItem(path, name, self.m_strFolderPath, filetype)
	if not IsValid(fileitem) then return false end

	self:ClearPlaylist()

	self.m_strPath = path
	self.Format = filetype
	self.PlaylistItems["format"] = filetype
	self.PlaylistItems["parentpath"] = self.m_strFolderPath

	self:SetUnsaved(true)

	self.Files:ClearSelection()
	self.Files:SortByColumn(1)
	self.Files:SelectItem(fileitem)

	self.NewFileItem = fileitem
	self.LastFileItem = fileitem

	self:ClearPlaylistText()
	return true
end

function PANEL:AddFolderItem(path, name, parentpath, filetype)
	if not path then return end
	if not name then return end
	if not parentpath then return end
	if not filetype then return end
	if not IsValid(self.Files) then return end

	local namelower = string.lower(name)
	if self.FileItems[namelower] then return end

	local item = self.Files:AddLine("./" .. name, StreamRadioLib.Filesystem.GetTypeName(filetype))

	item.streamradio_path = path
	item.streamradio_name = name
	item.streamradio_filetype = filetype
	item.streamradio_parentpath = parentpath

	self.FileItems[namelower] = true
	return item
end

function PANEL:AddFileItem( path, name, parentpath, filetype )
	if not path then return end
	if not name then return end
	if not parentpath then return end
	if not filetype then return end
	if not IsValid(self.Files) then return end

	local namelower = string.lower(name)
	if self.FileItems[namelower] then return end

	local item = self.Files:AddLine(name, StreamRadioLib.Filesystem.GetTypeName(filetype))

	item.streamradio_path = path
	item.streamradio_name = name
	item.streamradio_filetype = filetype
	item.streamradio_parentpath = parentpath

	self.FileItems[namelower] = true

	return item
end

function PANEL:AddPlaylistItem(url, name, parentpath)
	if not self.PlaylistItems then return false end

	url = url or self.EditURLText:GetText()
	name = name or self.EditNameText:GetText()
	parentpath = parentpath or self.PlaylistItems["parentpath"]

	if url == "" then return false end
	if name == "" then return false end

	local id = #self.PlaylistItems + 1
	local item = self.Playlist:AddLine(id, name, url)
	if not IsValid(item) then return false end

	item.streamradio_url = url
	item.streamradio_name = name
	item.streamradio_id = id

	self.PlaylistItems[id] = {
		url = url,
		name = name,
		item = item
	}

	self.PlaylistItems["format"] = self.PlaylistItems["format"] or self.Format
	self.PlaylistItems["parentpath"] = parentpath

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:RemovePlaylistItem(item)
	if not IsValid(item) then return false end
	if not self.PlaylistItems then return false end
	if self:IsLoading() then return false end

	local id = item.streamradio_id

	self.PlaylistItems[id] = nil
	self.Playlist:RemoveLine(item:GetID())
	self:SelectPlaylistItem()
	self:CleanUpPlaylist()

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:ChangePlaylistItem(item, url, name)
	if not IsValid(item) then return false end
	if not self.PlaylistItems then return false end
	if self:IsLoading() then return false end

	url = url or self.EditURLText:GetText()
	name = name or self.EditNameText:GetText()
	if url == "" then return false end
	if name == "" then return false end

	item.streamradio_url = url or self.EditURLText:GetText()
	item.streamradio_name = name or self.EditNameText:GetText()

	local id = item.streamradio_id or 0
	if id <= 0 then return false end

	item:SetColumnText(1, id)
	item:SetColumnText(2, name)
	item:SetColumnText(3, url)

	self.PlaylistItems[id] = {
		url = url,
		name = name,
		item = item
	}

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:SelectPlaylistItem( item )
	if not IsValid( item ) then
		self.Playlist:ClearSelection( )
		self.SelectedPlaylistItem = nil

		self.EditNameText:KillFocus()
		self.EditURLText:GetTextEntry():KillFocus()

		self.EditNameText:SetText( "" )
		self.EditURLText:SetText( "" )

		self:PlaylistCheckValid( )

		return false
	end

	if self:IsLoading( ) then return false end

	local url = item.streamradio_url
	local name = item.streamradio_name

	self.EditNameText:KillFocus()
	self.EditURLText:GetTextEntry():KillFocus()

	self.EditNameText:SetText( name )
	self.EditURLText:SetText( url )

	self:PlaylistCheckValid( )

	if self.SelectedPlaylistItem == item then return true end
	self.SelectedPlaylistItem = item
	self.Playlist:ClearSelection( )
	self.Playlist:SelectItem( item )

	return true
end

function PANEL:SwapItem( itemA, itemB )
	if ( not IsValid( itemA ) ) then return false end
	if ( not IsValid( itemB ) ) then return false end
	if ( not self.PlaylistItems ) then return false end
	if self:IsLoading( ) then return false end

	if ( itemA == itemB ) then return false end

	local idA = itemA.streamradio_id or 0
	if ( idA <= 0 ) then return false end
	if ( idA > #self.PlaylistItems ) then return false end

	local idB = itemB.streamradio_id or 0
	if ( idB <= 0 ) then return false end
	if ( idB > #self.PlaylistItems ) then return false end

	if ( idA == idB ) then return false end

	local lineA = self.PlaylistItems[idA]
	local lineB = self.PlaylistItems[idB]

	if ( not lineA ) then return false end
	if ( not lineB ) then return false end

	local temp = nil

	temp = lineA.item.streamradio_url
	lineA.item.streamradio_url = lineB.item.streamradio_url
	lineB.item.streamradio_url = temp

	temp = lineA.item.streamradio_name
	lineA.item.streamradio_name = lineB.item.streamradio_name
	lineB.item.streamradio_name = temp

	temp = lineA.url
	lineA.url = lineB.url
	lineB.url = temp

	temp = lineA.name
	lineA.name = lineB.name
	lineB.name = temp

	lineA.item:SetColumnText( 2, lineA.name )
	lineA.item:SetColumnText( 3, lineA.url )

	lineB.item:SetColumnText( 2, lineB.name )
	lineB.item:SetColumnText( 3, lineB.url )

	self:CleanUpPlaylist()

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:MovePlaylistItemUp( item )
	if ( not IsValid( item ) ) then return false end
	if ( not self.PlaylistItems ) then return false end
	if self:IsLoading( ) then return false end

	local id = item.streamradio_id or 0
	if ( id <= 1 ) then return false end

	local nextitem = nil
	for k, Line in pairs( self.Playlist.Sorted or self.Playlist:GetLines() or {} ) do
		if ( not Line.streamradio_id ) then continue end
		if ( not item.streamradio_id ) then continue end

		if (Line.streamradio_id ~= item.streamradio_id) then
			nextitem = Line
			continue
		end
		break
	end

	if ( not self:SwapItem( item, nextitem ) ) then return false end
	if ( not self:SelectPlaylistItem( nextitem ) ) then return false end

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:MovePlaylistItemDown( item )
	if ( not IsValid( item ) ) then return false end
	if ( not self.PlaylistItems ) then return false end
	if self:IsLoading( ) then return false end

	local id = item.streamradio_id or 0
	if ( id > #self.PlaylistItems ) then return false end

	local nextitem = nil
	for k, Line in pairs( self.Playlist.Sorted or self.Playlist:GetLines() or {} ) do
		if ( not Line.streamradio_id ) then continue end
		if ( not item.streamradio_id ) then continue end

		if (Line.streamradio_id == item.streamradio_id) then
			nextitem = Line
			continue
		end
		if ( not IsValid( nextitem ) ) then continue end

		if (nextitem.streamradio_id == item.streamradio_id) then
			nextitem = Line
			break
		end
	end

	if ( not self:SwapItem( item, nextitem ) ) then return false end
	if ( not self:SelectPlaylistItem( nextitem ) ) then return false end

	self:MarkPlaylistTextShouldUpdate()
	return true
end

function PANEL:ApplyPlaylistSort( )
	if not self.PlaylistItems then
		self.PlaylistItems = {}
		return
	end

	local tmpTab = self:GetEmptyPlaylistItems()
	local i = 0

	for k, v in pairs( self.Playlist.Sorted or self.Playlist:GetLines() or {} ) do
		if ( not IsValid( v ) ) then continue end

		v.streamradio_name = v.streamradio_name or ""
		v.streamradio_url = v.streamradio_url or ""

		if ( v.streamradio_name == "" ) then continue end
		if ( v.streamradio_url == "" ) then continue end

		i = i + 1
		v.streamradio_id = i

		v:SetColumnText( 1, v.streamradio_id )
		v:SetColumnText( 2, v.streamradio_name )
		v:SetColumnText( 3, v.streamradio_url )

		tmpTab[i] =  {
			url = v.streamradio_url,
			name = v.streamradio_name,
			item = v
		}
	end

	self.PlaylistItems = tmpTab
	self:MarkPlaylistTextShouldUpdate()
end

function PANEL:CleanUpPlaylist( )
	if not self.PlaylistItems then
		self.PlaylistItems = {}
		return
	end

	local tmpTab = self:GetEmptyPlaylistItems()
	local i = 0

	for k, v in pairs( self.PlaylistItems ) do
		if isstring( k ) then
			continue
		end

		local item = v.item
		if ( not IsValid( item ) ) then continue end

		item.streamradio_url = v.url or ""
		item.streamradio_name = v.name or ""

		if ( item.streamradio_name == "" ) then continue end
		if ( item.streamradio_url == "" ) then continue end

		i = i + 1
		item.streamradio_id = i

		item:SetColumnText( 1, item.streamradio_id )
		item:SetColumnText( 2, item.streamradio_name )
		item:SetColumnText( 3, item.streamradio_url )

		tmpTab[i] = {
			url = item.streamradio_url,
			name = item.streamradio_name,
			item = item
		}
	end

	self.PlaylistItems = tmpTab
	self:MarkPlaylistTextShouldUpdate()
end

function PANEL:GetPath( )
	return self.m_strPath, self.Format
end

function PANEL:SetPath( filepath, filetype, force, nofullclear )
	filepath = filepath or ""
	filepath = string.Trim( filepath, "\\" )
	filepath = string.Trim( filepath, "/" )
	filepath = string.Trim( filepath, "\\" )
	filepath = string.Trim( filepath, "/" )

	filetype = filetype or StreamRadioLib.TYPE_FOLDER
	local isFolder = StreamRadioLib.Filesystem.IsFolder(filetype)

	local function LoadFile( self, isFolder, filepath, filetype )
		if self:IsLoading() then return end

		if isFolder then
			if nofullclear then
				self:ClearFiles( )
			else
				self:Clear( )
			end

			self:Lock( true )
			self.m_strFolderPath = filepath
		else
			self:ClearPlaylist()
			self:Lock( true )

			local folderpath = string.GetPathFromFilename( filepath ) or ""
			folderpath = string.Trim( folderpath, "\\" )
			folderpath = string.Trim( folderpath, "/" )
			folderpath = string.Trim( folderpath, "\\" )
			folderpath = string.Trim( folderpath, "/" )

			self.m_strFolderPath = folderpath
		end

		self.m_strPath = filepath
		self.Format = filetype

		local backpath = string.GetPathFromFilename( filepath ) or ""

		if filepath ~= "" and not IsValid(self.BackItem) and isFolder then
			self.BackItem = self.Files:AddLine( "../", "" )
			self.BackItem.streamradio_path = backpath
			self.BackItem.streamradio_filetype = StreamRadioLib.TYPE_FOLDER
		end

		self:UpdateListNameLabel()

		local ListenID = StreamRadioLib.Editor.ListenToPath( filepath )
		StreamRadioLib.Editor.SetCallback( self.Callback, self )

		LIBNet.Start( "Editor_Request_Files" )
			StreamRadioLib.NetSendFileEditor( filepath, "", filetype or StreamRadioLib.TYPE_FOLDER, ListenID )
		net.SendToServer( )
	end

	if force or isFolder then
		LoadFile( self, isFolder, filepath, filetype )
	else
		AsForSave( self, LoadFile, isFolder, filepath, filetype )
	end
end

function PANEL:SetUnsaved( bool )
	self.m_bUnsaved = bool

	if not bool then
		self.NewFileItem = nil
	end

	self:UpdateListNameLabel( )
end

function PANEL:UpdateListNameLabel( )
	if not IsValid(self.ListNameLabel) then return end
	self.ListNameLabel:SetText((self.m_bUnsaved and "*" or "") .. (self.m_strPath or ""))
end

vgui.Register( "Streamradio_VGUI_PlaylistEditor", PANEL, "DPanel" )

return true


--PATH lua/streamradio_core/interfaces/shoutcast.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/_folder.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "Folder"
RADIOFS.type = "folder"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("Folder")
RADIOFS.nocreate = true

RADIOFS.loadToWhitelist = true
RADIOFS.priority = 999999

function RADIOFS:IsType(globalpath, vpath)
	if file.Exists(globalpath, "GAME") then
		return true
	end

	if file.IsDir(globalpath, "GAME") then
		return true
	end

	return false
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if not file.Exists(globalpath, "DATA") then
		callback(false, nil, nil)
		return false
	end

	if not file.IsDir(globalpath, "DATA") then
		callback(false, nil, nil)
		return false
	end

	local _, folders = file.Find(globalpath .. "/*", "DATA", "nameasc")
	folders = StreamRadioLib.Filesystem.FilterInvalidFilepaths(folders)

	callback(true, nil, folders)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if not file.Exists(globalpath, "DATA") then
		return false
	end

	if not file.IsDir(globalpath, "DATA") then
		return false
	end

	return true
end

function RADIOFS:Delete(globalpath, vpath, callback)
	local deleted = StreamRadioLib.Util.DeleteFolder(globalpath)
	callback(deleted)

	return deleted
end

RADIOFS.Read = nil

return true


--PATH lua/streamradio_core/filesystem/addon-mx-radio.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/files-sound-folder.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "Sound File"
RADIOFS.type = "soundfile"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("sound")

RADIOFS.rootfolder = "sound"

RADIOFS.priority = 99999
RADIOFS.nocreate = true
RADIOFS.loadToWhitelist = false

RADIOFS._validsoundtypes = {
	-- natively supported by GMod Source Engine
	["mp3"] = true,
	["wav"] = true,
	["ogg"] = true,

	-- supported by BASS
	["aac"] = true,
	["aifc"] = true,
	["aiff"] = true,
	["flac"] = true,
	["it"] = true,
	["m4a"] = true,
	["mod"] = true,
	["webm"] = true,
	["wma"] = true,
	["xm"] = true,
}

function RADIOFS:GetSoundPath(vpath)
	if not self:IsInFolder(vpath) then
		return nil
	end

	local levels = self:GetPathLevels(vpath)
	local path = table.concat(levels, "/", 2)

	return path
end

function RADIOFS:IsInFolder(vpath)
	local levels = self:GetPathLevels(vpath)
	local firstlevel = levels[1] or ""

	if firstlevel ~= ":gamesounds" then
		return false
	end

	return true
end

function RADIOFS:IsType(globalpath, vpath)
	return self:IsInFolder(vpath)
end

function RADIOFS:GetFiles(findpath)
	local validfiles = {}

	local files = file.Find(findpath .. "/*", "GAME", "nameasc") or {}

	for i, v in ipairs(files) do
		local ext = string.GetExtensionFromFilename(v) or ""
		if not self._validsoundtypes[ext] then
			continue
		end

		table.insert(validfiles, v)
	end

	return validfiles
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if vfolder == "" then
		callback(true, nil, {":gamesounds"})
		return true
	end

	if not self:IsInFolder(vfolder) then
		callback(false, nil, nil)
		return false
	end

	globalpath = self:GetSoundPath(vfolder)

	if not globalpath then
		callback(false, nil, nil)
		return false
	end

	local findpath = self.rootfolder .. "/" .. globalpath
	local _, folders = file.Find(findpath .. "/*", "GAME", "nameasc")

	local files = self:GetFiles(findpath)

	if #files > 0 then
		table.insert(files, ":allfiles")
	end

	callback(true, files, folders)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	globalpath = self:GetSoundPath(vpath)

	if not globalpath then
		return false
	end

	local findpath = self.rootfolder .. "/" .. globalpath
	local name = string.GetFileFromFilename(vpath)

	if name == ":allfiles" then
		return true
	end

	if file.Exists(findpath, "GAME") then
		return true
	end

	if file.IsDir(findpath, "GAME") then
		return true
	end

	return false
end

RADIOFS.Delete = nil

function RADIOFS:Read(globalpath, vpath, callback)
	globalpath = self:GetSoundPath(vpath)

	if not globalpath then
		callback(false, nil)
		return false
	end

	local findpath = self.rootfolder .. "/" .. globalpath
	local name = string.GetFileFromFilename(vpath)

	if name == "" then
		callback(false, nil)
		return false
	end

	if name == ":allfiles" then
		local playlist = {}

		local path = string.GetPathFromFilename(findpath)
		local urlpath = string.GetPathFromFilename(globalpath)

		local files = self:GetFiles(path)

		for i, v in ipairs(files) do
			playlist[#playlist + 1] = {
				name = v,
				url = urlpath .. v,
			}
		end

		callback(true, playlist)
		return true
	end

	local playlist = {
		{
			name = name,
			url = globalpath,
		},
	}

	callback(true, playlist)
	return true
end

return true


--PATH lua/autorun/sw_imperial_seats.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_french.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_polish.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/core/cl_core.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Client = TalkModes.Client || {}

function TalkModes.Client:CreateFont(name, size)
	surface.CreateFont(name, {
		font = "Montserrat Medium",
		size = size,
		weight = 500,
        extended = true,
        antialias = true
	})
end

local tblTalkModes = {
    [1] = {
        strMode = "Whisper",
        matImage = Material("talkmodes/whisper.png")
    },
    [2] = {
        strMode = "Talk",
        matImage = Material("talkmodes/normal.png")
    },  
    [3] = {
        strMode = "Yell",
        matImage = Material("talkmodes/yell.png")
    }
}

local tblPositions = {
    ["Top Left"] = {6, 6},
    ["Top Center"] = {ScrW()/2 - 120/2, 6},
    ["Top Right"] = {ScrW() - 120 - 6, 6},
    ["Center Left"] = {6, ScrH()/2 - 44/2},
    ["Center Right"] = {ScrW() - 120 - 6, ScrH()/2 - 44/2},
    ["Bottom Left"] = {6, ScrH() - 44 - 6},
    ["Bottom Center"] = {ScrW()/2 - 120/2, ScrH() - 44 - 6},
    ["Bottom Right"] = {ScrW() - 120 - 6, ScrH() - 44 - 6}
}

TalkModes.Client:CreateFont("TalkModes:Small", 20)
TalkModes.Client:CreateFont("TalkModes:Medium", 26)
TalkModes.Client:CreateFont("TalkModes:Big", 32)
TalkModes.Client:CreateFont("TalkModes:Huge", 48)

local selectionMenu
function TalkModes.Client.InitMenu()
    if (selectionMenu) then
        selectionMenu:Remove()
    end
    selectionMenu = vgui.Create("TalkModes.PlayerMenu")
    local intW, intH = tblPositions[TalkModes.Config:GetSetting("General", "Selection Menu Position")][1], tblPositions[TalkModes.Config:GetSetting("General", "Selection Menu Position")][2]
    selectionMenu:SetPos(intW, intH)
end
net.Receive("TalkModes.InitMenu", TalkModes.Client.InitMenu)


local intCurrentTalkMode = 2
local intCooldown = CurTime()
local intPanelTime = CurTime() + 3
local bFadingOut = false
local bPlayingPiano = false
function TalkModes.Client.MenuControl()
    local bCamera = (LocalPlayer():GetActiveWeapon():IsValid() && LocalPlayer():GetActiveWeapon():GetClass() == "gmod_camera") && true || false

    if (bCamera) then
        if (selectionMenu:IsVisible()) then
            selectionMenu:SetAlpha(0)
            selectionMenu:SetVisible(false)
            print(selectionMenu:IsVisible())
        end
    else
        if (!selectionMenu:IsVisible() && !TalkModes.Config:GetSetting("General", "Auto-Hide")) then
            selectionMenu:SetVisible(true)
            selectionMenu:SetAlpha(255)
        end
    end

    if (TalkModes.Config:GetSetting("General", "Auto-Hide")) then
        if (!input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18)) then
            if (CurTime() > intPanelTime && !bFadingOut && selectionMenu:IsVisible()) then
                bFadingOut = true
                selectionMenu:AlphaTo(0, 0.5, 0, function(_, self)
                    self:SetVisible(!(CurTime() > intPanelTime))
                    bFadingOut = false
                end)
            end
        end
    end

    if (input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18) && TM_ADMIN_PREVIEW.bActive) then 
        net.Start("TalkModes.AttemptPreview")
        net.SendToServer()
        return
    end

    bPianoPlaying = LocalPlayer().Instrument && LocalPlayer().Instrument:GetClass() == "gmt_instrument_piano" && true || false // Playable piano support
    
    if (!input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18) || vgui.CursorVisible() || intCooldown > CurTime() || bPianoPlaying) then return end

    if (TalkModes.Config:GetSetting("General", "Auto-Hide") && !bCamera) then
        selectionMenu:SetVisible(true)
        selectionMenu:AlphaTo(255, 0.25)
        intPanelTime = CurTime() + 3 + 0.75
    end

    for k, v in ipairs(tblTalkModes) do
        if (v.strMode == LocalPlayer():GetTalkMode()) then
            intCurrentTalkMode = k
            break
        end
    end
    
    intCurrentTalkMode = intCurrentTalkMode < 3 && intCurrentTalkMode + 1 || 1
    net.Start("TalkModes.ChangeMode")
        net.WriteString(tblTalkModes[intCurrentTalkMode].strMode)
    net.SendToServer()
    intCooldown = CurTime() + 0.5
end
hook.Add("Think", "TalkModes.Client.MenuControl", TalkModes.Client.MenuControl)
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_base.lua:
local THEME = TalkModes.Client.ActiveTheme
local tblPages = {
    [1] = {
        strName = "General",
        strPanel = "TalkModes.GeneralSettings",
        strMat = Material("talkmodes/config.png")
    },
    [2] = {
        strName = "Modes",
        strPanel = "TalkModes.ModesSettings",
        strMat = Material("talkmodes/modes.png")
    },
    [3] = {
        strName = "Theme",
        strPanel = "TalkModes.ThemesSettings",
        strMat = Material("talkmodes/paint.png")
    }
}

local PANEL = {}
AccessorFunc(PANEL, "loaded_panel", "LoadedPanel")

function PANEL:Init()
    self:SetSize(ScrW()/2.5, ScrH()/2)
    self:Center()
    self:MakePopup()

    local intW, intH = self:GetWide(), self:GetTall()

    self.xBut = self:Add("DButton")
    self.xBut:SetSize(32, intH/12)
    self.xBut:SetText("")
    self.xBut:SetFont("TalkModes:Medium")
    self.xBut:SetPos(intW - 46, 0)
    self.xBut.Paint = nil
    self.xBut.Alpha = 120
    self.xBut.Think = function(self)
        self.Alpha = Lerp(FrameTime() * 8, self.Alpha, self:IsHovered() && 255 || 120)
        self:SetColor(Color(THEME["White"].r, THEME["White"].g, THEME["White"].b, self.Alpha))
    end
    self.xBut.DoClick = function()
        self:Close()
    end
    
    self.navbar = self:Add("TalkModes.Navbar")
    self.navbar:SetSize(intW/4)
    self.navbar:Dock(LEFT)
    self.navbar:DockMargin(0, intH/12, 0, 0)
    for _, v in ipairs(tblPages) do
        self.navbar:AddButton(v.strPanel, v.strMat, v.strName)
    end

    self.docker = self:Add("TalkModes.Docker")
    self.docker:Dock(FILL)
    self.docker:DockMargin(0, intH/12, 0, 0)
    self.docker:ChangePage("TalkModes.GeneralSettings")
end

function PANEL:Close()
    self:AlphaTo(0, 0.2, 0, function()
        self:Remove()
    end)
end

function PANEL:Paint(intW, intH)
    draw.RoundedBoxEx(8, 0, 0, intW, intH/12, THEME["Background"], true, true, false, false)
    draw.SimpleText("Talk Modes - Config", "TalkModes:Medium", 8, intH/12/2, THEME["White"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end
vgui.Register("TalkModes.AdminMenu", PANEL, "EditablePanel")
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_binder.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_dropdown.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_selection.lua:
local circles = include("talk_modes/vgui/libs/cl_circles.lua")
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "mode_mat", "Material")
AccessorFunc(PANEL, "mode", "Mode")
local tblTalkModes = {
    [1] = {
        strMode = "Whisper",
        matImage = Material("talkmodes/whisper.png")
    },
    [2] = {
        strMode = "Talk",
        matImage = Material("talkmodes/normal.png")
    },  
    [3] = {
        strMode = "Yell",
        matImage = Material("talkmodes/yell.png")
    }
}

function PANEL:Init()
    self:SetSize(32, 32)
    self:Dock(LEFT)
    self:DockMargin(6, 6, 0, 6)
end

function PANEL:Paint(intW, intH)
    surface.SetDrawColor((self:GetMode() == LocalPlayer():GetTalkMode()) && THEME["Hover"] || THEME["Gray"])
    surface.SetMaterial(self:GetMaterial())
    surface.DrawTexturedRect(0, 0, 32, 32)
end
vgui.Register("TalkModes.SpeakMode", PANEL, "EditablePanel")


local PANEL = {}
function PANEL:Init()
    self:SetSize(3 * 32 + 4 * 6, 32 + 12)
    for _, val in ipairs(tblTalkModes) do
        self.pMode = self:Add("TalkModes.SpeakMode")
        self.pMode:SetMaterial(val.matImage)
        self.pMode:SetMode(val.strMode)
    end
end
function PANEL:Paint(intW, intH) 
    draw.RoundedBox(8, 0, 0, intW, intH, THEME["Background"])
end

vgui.Register("TalkModes.PlayerMenu", PANEL, "EditablePanel")

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_slider.lua:
local circles = include("talk_modes/vgui/libs/cl_circles.lua")
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "color", "Color")  
function PANEL:Init()
    self:SetSize(260, 12)
    self:SetDecimals(0)
    self.Wang:SetVisible(false)
    self.Label:SetVisible(false)
    self.TextArea:SetFont("TalkModes:Small")
    self.TextArea:SetDrawLanguageID(false)
--  self.TextArea:SetEditable(false)
    self.Circle = circles.New(CIRCLE_FILLED, 6, 6, 6)
    self.Circle:SetDistance(2)
    self.TextArea:SetTextColor(THEME["White"])
    self.Slider.Knob.Paint = function(this)
        draw.NoTexture()
        surface.SetDrawColor(self:GetColor() || THEME["White"])
        self.Circle()
    end
    self.Slider.Paint = nil
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(6, 0, 0, intW - self.TextArea:GetSize() - 4, 12, THEME["Background"])
end
vgui.Register("TalkModes.Slider", PANEL, "DNumSlider")

--PATH lua/tfa/enums/idle.lua:
--IDLE TYPE ENUM
TFA.Enum.IDLE_DISABLED = 0
TFA.Enum.IDLE_LUA = 1
TFA.Enum.IDLE_ANI = 2
TFA.Enum.IDLE_BOTH = 3
--PATH lua/tfa/modules/tfa_attachments.lua:
return gluapack()()
--PATH lua/tfa/ballistics/bullet.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_keybinds.lua:
TFA._KeyBindTable = TFA._KeyBindTable or {}
local KeyBindTable = TFA._KeyBindTable

local cv_prefix = "cl_tfa_keys_"

local sp = game.SinglePlayer()

if sp then -- THANK YOU GARRY FOR HIGH QUALITY PREDICTION IN SINGLEPLAYER
	if SERVER then
		util.AddNetworkString("TFA_KB_State")
		util.AddNetworkString("TFA_KB_Think")
	end

	if CLIENT then
		net.Receive("TFA_KB_State", function()
			local ply = LocalPlayer()

			local bind = net.ReadString()
			local state = net.ReadBool()

			local data = KeyBindTable[bind]

			if data and data.state ~= state then
				data.state = state

				if state then
					data.onpress(ply)
				else
					data.onrelease(ply)
				end
			end
		end)

		net.Receive("TFA_KB_Think", function()
			local ply = LocalPlayer()

			local bind = net.ReadString()

			local data = KeyBindTable[bind]

			if data and data.think and data.state then
				data.think(ply)
			end
		end)
	end
end

local function empty()
end

function TFA.RegisterKeyBind(data_in)
	assert(type(data_in) == "table", "Data must be a table!")
	assert(data_in.bind and type(data_in.bind) == "string", "Invalid bind name!")
	-- assert(not TFA._KeyBindTable[data.bind], "Keybind already registered!")

	local data = table.Copy(data_in)

	if not data.onpress then
		data.onpress = empty
	elseif type(data.onpress) ~= "function" then
		error("data.onpress - function expected, got " .. type(data.onpress))
	end

	if not data.onrelease then
		data.onrelease = empty
	elseif type(data.onrelease) ~= "function" then
		error("data.onrelease - function expected, got " .. type(data.onrelease))
	end

	data.state = false

	if CLIENT and GetConVar(cv_prefix .. data.bind) == nil then
		CreateClientConVar(cv_prefix .. data.bind, 0, true, true, data.desc)
	end

	hook.Add("PlayerButtonDown", "TFA_KB_KeyDown_" .. data.bind, function(ply, button)
		if not IsFirstTimePredicted() then return end
		local cv_key = ply:GetInfoNum(cv_prefix .. data.bind, 0)

		if cv_key > 0 and cv_key == button and not data.state then
			data.state = true
			data.onpress(ply)

			if sp and SERVER then
				net.Start("TFA_KB_State", true)
				net.WriteString(data.bind)
				net.WriteBool(data.state)
				net.Send(ply)
			end
		end
	end)

	hook.Add("PlayerButtonUp", "TFA_KB_KeyUp_" .. data.bind, function(ply, button)
		if not IsFirstTimePredicted() then return end
		local cv_key = ply:GetInfoNum(cv_prefix .. data.bind, 0)

		if cv_key > 0 and cv_key == button and data.state then
			data.state = false
			data.onrelease(ply)

			if sp and SERVER then
				net.Start("TFA_KB_State", true)
				net.WriteString(data.bind)
				net.WriteBool(data.state)
				net.Send(ply)
			end
		end
	end)

	hook.Remove("PlayerPostThink", "TFA_KB_Think_" .. data.bind)

	if data.think and type(data.think) == "function" then
		hook.Add("PlayerPostThink", "TFA_KB_Think_" .. data.bind, function(ply)
			if data.state then
				data.think(ply)

				if sp and SERVER then
					net.Start("TFA_KB_Think", true)
					net.WriteString(data.bind)
					net.Send(ply)
				end
			end
		end)
	end

	KeyBindTable[data.bind] = data
end

if CLIENT then -- Populate spawnmenu settings with registered keybinds
	local function tfaOptionKeys(panel)
		panel:Help("#tfa.keybinds.help.bind")
		panel:Help("#tfa.keybinds.help.bound")
		panel:Help("#tfa.keybinds.help.unbind")
		panel:Help("")

		for _, data in pairs(KeyBindTable) do
			local cv = GetConVar(cv_prefix .. data.bind)

			if cv then
				panel:Help("#tfa.keybind." .. data.bind)

				local binder = vgui.Create("DBinder")

				binder:SetValue(cv:GetInt())

				function binder:OnChange(newcode)
					cv:SetInt(newcode)
				end

				panel:AddItem(binder)
				panel:Help("")
			end
		end
	end

	hook.Add("PopulateToolMenu", "TFA_AddKeyBinds", function()
		spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseKeybinds", "#tfa.smsettings.keybinds", "", "", tfaOptionKeys)
	end)
end

-- Default keybinds
TFA.RegisterKeyBind({
	bind = "bash",

	onpress = function(plyv)
		if not plyv:IsValid() then return end

		plyv.tfa_bash_hack = true
	end,

	onrelease = function(plyv)
		if not plyv:IsValid() then return end

		plyv.tfa_bash_hack = false
	end
})

TFA.RegisterKeyBind({
	bind = "customize",
	onpress = CLIENT and function(plyv)
		if not plyv:IsValid() then return end

		RunConsoleCommand("impulse", TFA.INSPECTION_IMPULSE_STRING)
	end
})

TFA.RegisterKeyBind({
	bind = "inspect",
	onpress = function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if (IsValid(wepv) and wepv.GetStat) and (wepv:GetActivityEnabled(ACT_VM_FIDGET) or wepv.InspectionActions) and wepv:GetStatus() == TFA.Enum.STATUS_IDLE then
			local _, tanim, ttype = wepv:ChooseInspectAnim()
			wepv:ScheduleStatus(TFA.Enum.STATUS_FIDGET, wepv:GetActivityLength(tanim, false, ttype))
		end
	end
})

TFA.RegisterKeyBind({
	bind = "firemode",
	onpress = CLIENT and function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if IsValid(wepv) and wepv.GetStat then
			if wepv:GetStatL("SelectiveFire") and not wepv:GetOwner():KeyDown(IN_SPEED) then
				RunConsoleCommand("impulse", TFA.CYCLE_FIREMODE_IMPULSE_STRING)
			elseif wepv:GetOwner():KeyDown(IN_SPEED) then
				RunConsoleCommand("impulse", TFA.CYCLE_SAFETY_IMPULSE_STRING)
			end
		end
	end
})

TFA.RegisterKeyBind({
	bind = "silencer",
	onpress = function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if (IsValid(wepv) and wepv.GetStat) and wepv:GetStatRawL("CanBeSilenced") and TFA.Enum.ReadyStatus[wepv:GetStatus()] then
			local _, tanim, ttype = wepv:ChooseSilenceAnim(not wepv:GetSilenced())
			wepv:ScheduleStatus(TFA.Enum.STATUS_SILENCER_TOGGLE, wepv:GetActivityLength(tanim, true, ttype))
		end
	end
})

-- EXAMPLE KEYBIND:
--[[
	TFA.RegisterKeyBind({
		bind = "whatever", -- bind id, cvar is cl_tfa_keys_whatever
		onpress = function(ply) end, -- function called on key press
		onrelease = function(ply) end, -- function called on key release
		think = function(ply) end, -- called from PlayerPostThink when key is held down
	})
]]

--PATH lua/tfa/modules/tfa_soundscripts.lua:
sound.Add({
	name = "Weapon_Bow.1",
	channel = CHAN_STATIC,
	volume = 1.0,
	sound = {"weapons/tfbow/fire1.wav", "weapons/tfbow/fire2.wav", "weapons/tfbow/fire3.wav"}
})

sound.Add({
	name = "Weapon_Bow.boltpull",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	sound = {"weapons/tfbow/pull1.wav", "weapons/tfbow/pull2.wav", "weapons/tfbow/pull3.wav"}
})

sound.Add({
	name = "TFA.NearlyEmpty",
	channel = CHAN_USER_BASE + 15,
	volume = 1,
	pitch = 100,
	level = 65,
	sound = "weapons/tfa/lowammo.wav"
})

sound.Add({
	name = "TFA.Bash",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee1.wav",
		")weapons/tfa/melee2.wav",
		")weapons/tfa/melee3.wav",
		")weapons/tfa/melee4.wav",
		")weapons/tfa/melee5.wav",
		")weapons/tfa/melee6.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.BashWall",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee_hit_world1.wav",
		")weapons/tfa/melee_hit_world2.wav",
		")weapons/tfa/melee_hit_world3.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.BashFlesh",
	channel = CHAN_USER_BASE + 14,
	volume = 1.0,
	sound = {
		")weapons/tfa/melee_hit_body1.wav",
		")weapons/tfa/melee_hit_body2.wav",
		")weapons/tfa/melee_hit_body3.wav",
		")weapons/tfa/melee_hit_body4.wav",
		")weapons/tfa/melee_hit_body5.wav",
		")weapons/tfa/melee_hit_body6.wav"
	},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.IronIn",
	channel = CHAN_USER_BASE + 13,
	volume = 1.0,
	sound = {"weapons/tfa/ironin.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.IronOut",
	channel = CHAN_USER_BASE + 13,
	volume = 1.0,
	sound = {"weapons/tfa/ironout.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "Weapon_Pistol.Empty2",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	level = 80,
	sound = {"weapons/pistol/pistol_empty.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "Weapon_AR2.Empty2",
	channel = CHAN_USER_BASE + 11,
	volume = 1.0,
	level = 80,
	sound = {"weapons/ar2/ar2_empty.wav"},
	pitch = {97, 103}
})

sound.Add({
	name = "TFA.LowAmmo",
	channel = CHAN_USER_BASE + 15,
	volume = 1.0,
	level = 75,
	pitch = 100,
	sound = ")weapons/tfa/lowammo_indicator_automatic.wav"
})
sound.Add({
	name = "TFA.LowAmmo_Dry",
	channel = CHAN_USER_BASE + 15,
	volume = 1.0,
	level = 75,
	pitch = 100,
	sound = ")weapons/tfa/lowammo_dry_automatic.wav"
})

local ammos = {
	["Handgun"] = "handgun",
	["Shotgun"] = "shotgun",
	["AutoShotgun"] = "shotgun_auto",
	["MachineGun"] = "mg",
	["AssaultRifle"] = "ar",
	["DMR"] = "dmr",
	["Revolver"] = "revolver",
	["Sniper"] = "sr",
	["SMG"] = "smg",
	["SciFi"] = "scifi",
	["GL"] = "gl",
}
for k,v in pairs(ammos) do
	sound.Add({
		name = "TFA.LowAmmo." .. k, -- "TFA.LowAmmo.Handgun"
		channel = CHAN_USER_BASE + 15,
		volume = 1.0,
		level = 75,
		pitch = 100,
		sound = ")weapons/tfa/lowammo_indicator_" .. v .. ".wav"
	})
	sound.Add({
		name = "TFA.LowAmmo." .. k .. "_Dry", -- "TFA.LowAmmo.Handgun_Dry"
		channel = CHAN_USER_BASE + 15,
		volume = 1.0,
		level = 75,
		pitch = 100,
		sound = ")weapons/tfa/lowammo_dry_" .. v .. ".wav"
	})
end
--PATH lua/tfa/modules/cl_tfa_devtools.lua:
local cv_dba = GetConVar("cl_tfa_debug_animations")
local cv_dbc = GetConVar("cl_tfa_debug_crosshair")

local color_red = Color(255, 0, 0, 255)
local color_white = Color(255, 255, 255, 255)

local state_strings = {}

for i = 1, 32 do
	local strcomp = string.rep("%d", i)
	local slice = {}

	for i2 = 0, i - 1 do
		table.insert(slice, "band(rshift(state, " .. i2 .. "), 1) == 0 and 0 or 1")
	end

	local fn = CompileString([[
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return ]] .. table.concat(slice, ", ") .. [[
		end
	]], "tfa_dev_tools")()

	state_strings[i] = function(state)
		return string.format(strcomp, fn(state))
	end
end

local lastStatusBarWidth = 300
local lastAnimStatusWidth = 300

local STATUS_BAR_COLOR = Color(255, 255, 255)
local STATUS_BAR_COLOR_BG = Color(74, 74, 74)

local function DrawDebugInfo(w, h, ply, wep)
	if not cv_dba:GetBool() then return end

	local x, y = w * .5, h * .2

	if wep.event_table_overflow then
		if wep.EventTableEdict[0] then
			draw.SimpleTextOutlined("UNPREDICTED Event table state:", "TFASleekDebug", x + 240, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
			local y2 = y + TFA.Fonts.SleekHeightDebug

			if not wep._built_event_debug_string_fn then
				local str = ""
				local str2 = ""

				for i = 0, #wep.EventTableEdict do
					str = str .. "%d"

					if (i + 1) % 32 == 0 then
						str = str .. "\n"
					end

					if str2 == "" then
						str2 = "self.EventTableEdict[" .. i .. "].called and 1 or 0"
					else
						str2 = str2 .. ", self.EventTableEdict[" .. i .. "].called and 1 or 0"
					end
				end

				wep._built_event_debug_string_fn = CompileString([[
					local format = string.format
					return function(self)
						return format([==[]] .. str .. [[]==], ]] .. str2 .. [[)
					end
				]], "TFA Base Debug Tools")()
			end

			for line in string.gmatch(wep:_built_event_debug_string_fn(), "(%S+)") do
				draw.SimpleTextOutlined(line, "TFASleekDebug", x + 240, y2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
				y2 = y2 + TFA.Fonts.SleekHeightDebug
			end
		end
	elseif wep._EventSlotCount ~= 0 then
		draw.SimpleTextOutlined("Event table state:", "TFASleekDebug", x + 240, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
		local y2 = y + TFA.Fonts.SleekHeightDebug

		for i = 1, wep._EventSlotCount do
			local state = wep["GetEventStatus" .. i](wep)
			local stringbake

			if i ~= wep._EventSlotCount then
				stringbake = state_strings[32](state)
			else
				local fn = state_strings[wep._EventSlotNum % 32 + 1]

				if not fn then break end
				stringbake = fn(state)
			end

			draw.SimpleTextOutlined(stringbake, "TFASleekDebug", x + 240, y2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
			y2 = y2 + TFA.Fonts.SleekHeightDebug
		end
	end

	local statusText = string.format(
		"%s [%.2f, %.2f, %.2f, %.2f]",
		TFA.Enum.InverseStatus[wep:GetStatus()] or wep:GetStatus(),
		CurTime() + (wep.CurTimePredictionAdvance or 0),
		wep:GetStatusProgress(true),
		wep:GetStatusStart(),
		wep:GetStatusEnd())

	draw.SimpleTextOutlined(statusText, "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)

	--[[if wep:GetStatusProgress() >= 1 then
		local stW, stH = surface.GetTextSize(statusText)

		lastStatusBarWidth = math.max(300, stW)
	end]]

	y = y + TFA.Fonts.SleekHeightDebug + 2

	surface.SetDrawColor(STATUS_BAR_COLOR_BG)
	surface.DrawRect(x - lastStatusBarWidth / 2, y, lastStatusBarWidth, 4)

	surface.SetDrawColor(STATUS_BAR_COLOR)
	surface.DrawRect(x - lastStatusBarWidth / 2, y, lastStatusBarWidth * wep:GetStatusProgress(true), 4)

	y = y + 8

	local vm = wep.OwnerViewModel

	if IsValid(vm) then
		local seq = vm:GetSequence()

		draw.SimpleTextOutlined(string.format("%s [%d] (%s/%d)", vm:GetSequenceName(seq), seq, vm:GetSequenceActivityName(seq), vm:GetSequenceActivity(seq)), "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		y = y + TFA.Fonts.SleekHeightDebug

		local cycle = vm:GetCycle()
		local len = vm:SequenceDuration(seq)
		local rate = vm:GetPlaybackRate()

		local animStatus = string.format("%.2fs / %.2fs (%.2f) @ %d%%", cycle * len, len, cycle, rate * 100)

		draw.SimpleTextOutlined(animStatus, "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		--local stW, stH = surface.GetTextSize(animStatus)
		--lastAnimStatusWidth = math.max(300, stW)

		y = y + TFA.Fonts.SleekHeightDebug + 2

		surface.SetDrawColor(STATUS_BAR_COLOR_BG)
		surface.DrawRect(x - lastAnimStatusWidth / 2, y, lastAnimStatusWidth, 4)

		if len * rate >= 0.2 then
			surface.SetDrawColor(STATUS_BAR_COLOR)
			surface.DrawRect(x - lastAnimStatusWidth / 2, y, lastAnimStatusWidth * cycle, 4)
		end
	end
end

local function DrawDebugCrosshair(w, h, ply, wep)
	if not cv_dbc:GetBool() then return end

	surface.SetDrawColor(color_red)
	surface.DrawRect(w * .5 - 1, h * .5 - 1, 2, 2)

	local tr = util.QuickTrace(ply:GetShootPos(), wep:GetAimVector(), ply)
	local tsc = tr.HitPos:ToScreen()

	if tsc.visible then
		surface.SetDrawColor(color_white)
		surface.DrawRect(tsc.x - 1, tsc.y - 1, 2, 2)
	end
end

local w, h

hook.Add("HUDPaint", "tfa_drawdebughud", function()
	local ply = LocalPlayer() or NULL
	if not ply:IsValid() or not ply:IsAdmin() then return end

	local wep = ply:GetActiveWeapon() or NULL
	if not wep:IsValid() or not wep.IsTFAWeapon then return end

	w, h = ScrW(), ScrH()

	DrawDebugInfo(w, h, ply, wep)
	DrawDebugCrosshair(w, h, ply, wep)
end)

--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1, band(rshift(state, 30), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_settingsmenu.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_settingsmenu.lua:
local IsSinglePlayer = game.SinglePlayer()

function TFA.NumSliderNet(_parent, label, convar, min, max, decimals, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local newpanel

	if IsSinglePlayer then
		newpanel = _parent:NumSlider(label, convar, min, max, decimals, ...)
	else
		newpanel = _parent:NumSlider(label, nil, min, max, decimals, ...)
	end

	decimals = decimals or 0
	local sf = "%." .. decimals .. "f"

	if not IsSinglePlayer then
		local ignore = false

		newpanel.Think = function(_self)
			if _self._wait_for_update and _self._wait_for_update > RealTime() then return end
			local float = gconvar:GetFloat()

			if _self:GetValue() ~= float then
				ignore = true
				_self:SetValue(float)
				ignore = false
			end
		end

		newpanel.OnValueChanged = function(_self, _newval)
			if ignore then return end

			if not LocalPlayer():IsAdmin() then return end
			_self._wait_for_update = RealTime() + 1

			timer.Create("tfa_vgui_" .. convar, 0.5, 1, function()
				if not LocalPlayer():IsAdmin() then return end

				net.Start("TFA_SetServerCommand")
				net.WriteString(convar)
				net.WriteString(string.format(sf, _newval))
				net.SendToServer()
			end)
		end
	end

	return newpanel
end

function TFA.CheckBoxNet(_parent, label, convar, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local newpanel

	if IsSinglePlayer then
		newpanel = _parent:CheckBox(label, convar, ...)
	else
		newpanel = _parent:CheckBox(label, nil, ...)
	end

	if not IsSinglePlayer then
		if not IsValid(newpanel.Button) then return newpanel end

		newpanel.Button.Think = function(_self)
			local bool = gconvar:GetBool()

			if _self:GetChecked() ~= bool then
				_self:SetChecked(bool)
			end
		end

		newpanel.OnChange = function(_self, _bVal)
			if not LocalPlayer():IsAdmin() then return end
			if _bVal == gconvar:GetBool() then return end

			net.Start("TFA_SetServerCommand")
			net.WriteString(convar)
			net.WriteString(_bVal and "1" or "0")
			net.SendToServer()
		end
	end

	return newpanel
end

function TFA.ComboBoxNet(_parent, label, convar, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local combobox, leftpanel

	if IsSinglePlayer then
		combobox, leftpanel = _parent:ComboBox(label, convar, ...)
	else
		combobox, leftpanel = _parent:ComboBox(label, nil, ...)
	end

	if not IsSinglePlayer then
		combobox.Think = function(_self)
			local value = gconvar:GetString()

			if _self:GetValue() ~= value then
				_self:SetValue(value)
			end
		end

		combobox.OnSelect = function(_self, _index, _value, _data)
			if not LocalPlayer():IsAdmin() then return end
			local _newval = tostring(_data or _value)

			net.Start("TFA_SetServerCommand")
			net.WriteString(convar)
			net.WriteString(_newval)
			net.SendToServer()
		end
	end

	return combobox, leftpanel
end

--PATH lua/tfa/modules/cl_tfa_stencilsights.lua:
-- stencil functions
local useStencils = render.SupportsPixelShaders_2_0() and render.SupportsVertexShaders_2_0()

local function defineCanvas(ref)
	render.UpdateScreenEffectTexture()
	render.ClearStencil()
	render.SetStencilEnable(true)
	render.SetStencilCompareFunction(STENCIL_ALWAYS)
	render.SetStencilPassOperation(STENCIL_REPLACE)
	render.SetStencilFailOperation(STENCIL_KEEP)
	render.SetStencilZFailOperation(STENCIL_REPLACE)
	render.SetStencilWriteMask(255)
	render.SetStencilTestMask(255)
	render.SetStencilReferenceValue(ref or 54)
end

local function drawOn()
	render.SetStencilCompareFunction(STENCIL_EQUAL)
end

local function stopCanvas()
	render.SetStencilEnable(false)
end

-- main draw functions
local CachedMaterials = {}

local DrawFunctions = {}

do -- Flat reticle, stays at center or moves with recoil
	local function ScreenScaleH(num)
		return num * (ScrH() / 480)
	end

	DrawFunctions[TFA.Enum.RETICLE_FLAT] = function(vm, ply, wep, SightElementTable)
		local ReticleMaterial = wep:GetStat("StencilSight_ReticleMaterial")
		if not ReticleMaterial then return end

		if type(ReticleMaterial) == "string" then
			CachedMaterials[ReticleMaterial] = CachedMaterials[ReticleMaterial] or Material(ReticleMaterial, "noclamp nocull smooth")
			ReticleMaterial = CachedMaterials[ReticleMaterial]
		end

		local ReticleSize = wep:GetStat("StencilSight_ReticleSize")
		if not ReticleSize then return end

		if wep:GetStat("StencilSight_ScaleReticleByScreenHeight", true) then
			ReticleSize = ScreenScaleH(ReticleSize)
		end

		if wep:GetStat("StencilSight_ScaleReticleByProgress", true) then
			ReticleSize = ReticleSize * wep.IronSightsProgress
		end

		local w, h = ScrW(), ScrH()

		local x, y = w * .5, h * .5
		if wep:GetStat("StencilSight_FollowRecoil", true) then
			x, y = TFA.LastCrosshairPosX or x, TFA.LastCrosshairPosY or y
		end

		local TargetColor = wep:GetStat("StencilSight_ReticleTint", color_white)

		if wep:GetStat("StencilSight_ReticleTintBySightColor", false) and IsValid(wep:GetOwner()) then
			local Owner = wep:GetOwner()

			local _GetNWVector = Owner.GetNW2Vector or Owner.GetNWVector

			local ColorVec = _GetNWVector(Owner, "TFAReticuleColor")

			if ColorVec then
				TargetColor = Color(ColorVec.x, ColorVec.y, ColorVec.z)
			end
		end

		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			TargetColor = ColorAlpha(TargetColor, wep.IronSightsProgress * 255)
		end

		render.DepthRange(0.0, 0.1)
		cam.Start2D(0, 0, w, h)
			surface.SetMaterial(ReticleMaterial)
			surface.SetDrawColor(TargetColor)
			surface.DrawTexturedRect(x - ReticleSize * .5, y - ReticleSize * .5, ReticleSize, ReticleSize)
		cam.End2D()
		if not wep.UseHands then
			render.DepthRange(0.0, 1.0)
		end
	end
end

do -- Model reticle, for when you don't have an attach point
	if IsValid(TFA.SightReticleEnt) then
		TFA.SightReticleEnt:Remove()
		TFA.SightReticleEnt = nil
	end

	TFA.SightReticleEnt = ClientsideModel("models/error.mdl", RENDERGROUP_VIEWMODEL)
	TFA.SightReticleEnt:SetNoDraw(true)

	local SightReticleEnt = TFA.SightReticleEnt

	DrawFunctions[TFA.Enum.RETICLE_MODEL] = function(vm, ply, wep, SightElementTable)
		if not SightElementTable.reticle then return end

		local SightElementModel = SightElementTable.curmodel

		SightReticleEnt:SetModel(SightElementTable.reticle)
		if SightReticleEnt:GetModel() == "models/error.mdl" then return end

		local matrix = Matrix()
		matrix:Scale(SightElementTable.size)
		SightReticleEnt:EnableMatrix("RenderMultiply", matrix)

		if SightReticleEnt:GetParent() ~= SightElementModel then
			SightReticleEnt:SetParent(SightElementModel)
			SightReticleEnt:SetPos(SightElementModel:GetPos())
			SightReticleEnt:SetAngles(SightElementModel:GetAngles())

			if not SightReticleEnt:IsEffectActive(EF_BONEMERGE) then
				SightReticleEnt:AddEffects(EF_BONEMERGE)
				SightReticleEnt:AddEffects(EF_BONEMERGE_FASTCULL)
			end
		end

		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CW) end
		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			local oldBlend = render.GetBlend()

			render.SetBlend(wep.IronSightsProgress)
			SightReticleEnt:DrawModel()
			render.SetBlend(oldBlend)
		else
			SightReticleEnt:DrawModel()
		end
		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CCW) end

		if wep:GetStat("StencilSight_EnableQuad") and bit.band(wep:GetStat("StencilSight_ReticleType")) ~= TFA.Enum.RETICLE_QUAD then
			DrawFunctions[TFA.Enum.RETICLE_QUAD](vm, ply, wep, SightElementTable)
		end
	end
end

do -- Quad/Attach reticle, TFA INS2 method
	local function GetTargetPosition(wep, SightElementTable)
		local TargetEntity = SightElementTable.curmodel
		if not IsValid(TargetEntity) then return end

		local Type = wep:GetStat("StencilSight_PositionType", TFA.Enum.SIGHTSPOS_ATTACH)

		local pos, ang

		if Type == TFA.Enum.SIGHTSPOS_ATTACH then
			local AttachmentID = wep:GetStat("StencilSight_ReticleAttachment")
			if not AttachmentID then return end

			if type(AttachmentID) == "string" then
				AttachmentID = TargetEntity:LookupAttachment(AttachmentID)
			end

			if not AttachmentID or AttachmentID <= 0 then return end

			local Attachment = TargetEntity:GetAttachment(AttachmentID)
			if not Attachment.Pos or not Attachment.Ang then return end

			pos, ang = Attachment.Pos, Attachment.Ang
		elseif Type == TFA.Enum.SIGHTSPOS_BONE then
			local BoneID = wep:GetStat("StencilSight_ReticleBone")

			if type(BoneID) == "string" then
				BoneID = TargetEntity:LookupBone(BoneID)
			end

			if not BoneID or BoneID < 0 then return end

			pos, ang = TargetEntity:GetBonePosition(BoneID)

			if pos == TargetEntity:GetPos() then
				pos = TargetEntity:GetBoneMatrix(BoneID):GetTranslation()
				ang = TargetEntity:GetBoneMatrix(BoneID):GetAngles()
			end
		else
			return
		end

		local OffsetPos = wep:GetStat("StencilSight_ReticleOffsetPos")
		if OffsetPos then
			pos = pos + ang:Right() * OffsetPos.x + ang:Forward() * OffsetPos.y + ang:Up() * OffsetPos.z
		end

		local OffsetAng = wep:GetStat("StencilSight_ReticleOffsetAng")
		if OffsetAng then
			ang:RotateAroundAxis(ang:Right(), OffsetAng.p)
			ang:RotateAroundAxis(ang:Up(), OffsetAng.y)
			ang:RotateAroundAxis(ang:Forward(), OffsetAng.r)
		end

		return pos, ang
	end

	DrawFunctions[TFA.Enum.RETICLE_QUAD] = function(vm, ply, wep, SightElementTable)
		local ReticleMaterial = wep:GetStat("StencilSight_ReticleMaterial")
		if not ReticleMaterial then return end

		if type(ReticleMaterial) == "string" then
			CachedMaterials[ReticleMaterial] = CachedMaterials[ReticleMaterial] or Material(ReticleMaterial, "noclamp nocull smooth")
			ReticleMaterial = CachedMaterials[ReticleMaterial]
		end

		local ReticleSize = wep:GetStat("StencilSight_ReticleSize")
		if not ReticleSize then return end

		if wep:GetStat("StencilSight_ScaleReticleByProgress", false) then
			ReticleSize = ReticleSize * wep.IronSightsProgress
		end

		local TargetColor = wep:GetStat("StencilSight_ReticleTint", color_white)

		if wep:GetStat("StencilSight_ReticleTintBySightColor", false) and IsValid(wep:GetOwner()) then
			local Owner = wep:GetOwner()

			local _GetNWVector = Owner.GetNW2Vector or Owner.GetNWVector

			local ColorVec = _GetNWVector(Owner, "TFAReticuleColor")

			if ColorVec then
				TargetColor = Color(ColorVec.x, ColorVec.y, ColorVec.z)
			end
		end

		if wep:GetStat("StencilSight_FadeReticleByProgress", false) then
			TargetColor = ColorAlpha(TargetColor, wep.IronSightsProgress * 255)
		end

		local p, a = GetTargetPosition(wep, SightElementTable)
		if not p or not a then return end

		render.OverrideDepthEnable(true, true)

		render.SetMaterial(ReticleMaterial)
		render.DrawQuadEasy(p, a:Forward() * -1, ReticleSize, ReticleSize, TargetColor, 180 + a.r * (wep.ViewModelFlip and 1 or -1))

		render.OverrideDepthEnable(false, false)
	end
end

-- hook logic
if IsValid(TFA.SightMaskEnt) then
	TFA.SightMaskEnt:Remove()
	TFA.SightMaskEnt = nil
end

TFA.SightMaskEnt = ClientsideModel("models/error.mdl", RENDERGROUP_VIEWMODEL)
TFA.SightMaskEnt:SetNoDraw(true)

local SightMaskEnt = TFA.SightMaskEnt

local function DrawSight(vm, ply, wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	local shouldDraw = hook.Run("TFA_ShouldDrawStencilSight", wep)
	if shouldDraw == false then return end

	local wep2 = wep:GetTable()

	if wep2.TFA_IsDrawingStencilSights then return end
	wep2.TFA_IsDrawingStencilSights = true

	if not wep2.GetStat(wep, "StencilSight") then wep2.TFA_IsDrawingStencilSights = false return end
	if wep2.IronSightsProgress < wep2.GetStat(wep, "StencilSight_MinPercent", 0.05) then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementName = wep2.GetStat(wep, "StencilSight_VElement")
	if not SightElementName or not wep2.GetStat(wep, "VElements." .. SightElementName .. ".active") then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementTable = wep2.VElements[SightElementName]
	if not SightElementTable then wep2.TFA_IsDrawingStencilSights = false return end

	local SightElementModel = SightElementTable.curmodel
	if not IsValid(SightElementModel) then wep2.TFA_IsDrawingStencilSights = false return end

	if useStencils then
		defineCanvas()

		local SightMaskModel = SightElementModel

		if wep2.GetStat(wep, "StencilSight_UseMask", false) and SightElementTable.mask then
			SightMaskEnt:SetModel(SightElementTable.mask)

			if SightMaskEnt:GetModel() ~= "models/error.mdl" then
				SightMaskModel = SightMaskEnt

				local matrix = Matrix()
				matrix:Scale(SightElementTable.size)
				SightMaskEnt:EnableMatrix("RenderMultiply", matrix)

				if SightMaskEnt:GetParent() ~= SightElementModel then
					SightMaskEnt:SetParent(SightElementModel)
					SightMaskEnt:SetPos(SightElementModel:GetPos())
					SightMaskEnt:SetAngles(SightElementModel:GetAngles())

					if not SightMaskEnt:IsEffectActive(EF_BONEMERGE) then
						SightMaskEnt:AddEffects(EF_BONEMERGE)
						SightMaskEnt:AddEffects(EF_BONEMERGE_FASTCULL)
					end
				end
			end
		end

		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CW) end
		local oldBlend = render.GetBlend()
		render.SetBlend(0)
			SightMaskModel:DrawModel()
		render.SetBlend(oldBlend)
		if wep.ViewModelFlip then render.CullMode(MATERIAL_CULLMODE_CCW) end

		drawOn()
	end

	local retValPre = wep2.CallAttFunc(wep, "PreDrawStencilSight", vm, ply, SightElementTable)
	if retValPre ~= true then
		retValPre = wep2.PreDrawStencilSight(wep, vm, ply, SightElementTable) or retValPre
	end

	if retValPre ~= false then
		local funcType = wep2.GetStat(wep, "StencilSight_ReticleType", TFA.Enum.RETICLE_FLAT)

		for _, retType in ipairs(TFA.Enum.RETICLE_DRAW_ORDER) do
			if bit.band(funcType, retType) == retType and DrawFunctions[retType] then
				ProtectedCall(function()
					DrawFunctions[retType](vm, ply, wep, SightElementTable)
				end)
			end
		end

		local retValPost = wep2.CallAttFunc(wep, "PostDrawStencilSight", vm, ply, SightElementTable)
		if retValPost ~= true then
			wep2.PostDrawStencilSight(wep, vm, ply, SightElementTable)
		end
	end

	if useStencils then
		stopCanvas()
	end

	wep2.TFA_IsDrawingStencilSights = false
end

hook.Add("PostDrawViewModel", "TFA_DrawStencilSight", DrawSight)
--PATH lua/tfa/att/mod_stun10_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Beta"
ATTACHMENT.ShortName = "10s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 10 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun10.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 20,
		["StatusEffectDur"] = 10,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--PATH lua/tfa/att/mod_stun5_servius.lua:
return gluapack()()
--PATH lua/autorun/tfa_comm_sw_magnaguard.lua:
player_manager.AddValidModel("TFA-SW-Magna-Guard-Trainer","models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl")
player_manager.AddValidModel("TFA-SW-Magna-Guard-Combined","models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl")
player_manager.AddValidModel("TFA-SW-Magna-Guard-Season4","models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl")

--Hostile NPC

local NPC = {
	Name = "Magna Guard ( Trainer, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_trainer.mdl"
}
list.Set( "NPC", "npc_sw_magnag_trainer_h", NPC )

local NPC = {
	Name = "Magna Guard ( Combined, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_combined.mdl"
}
list.Set( "NPC", "npc_sw_magnag_combined_h", NPC )

local NPC = {
	Name = "Magna Guard ( Season4, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_season4.mdl"
}
list.Set( "NPC", "npc_sw_magnag_season4_h", NPC )

--Friendly NPC

local NPC = {
	Name = "Magna Guard ( Trainer, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_trainer.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_trainer_f", NPC )

local NPC = {
	Name = "Magna Guard ( Combined, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_combined.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_combined_f", NPC )

local NPC = {
	Name = "Magna Guard ( Season4, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_season4.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_season4_f", NPC )
--PATH lua/autorun/turret_stopfire.lua:
return gluapack()()
--PATH lua/autorun/vj_globals.lua:
return gluapack()()
--PATH lua/autorun/vj_menu_main.lua:
/*--------------------------------------------------
	=============== Main Menu ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
	local cTypes = {
		vjnpcs = "VJ NPCs",
		npcs = "NPCs",
		spawners = "Spawners",
		corpses = "Corpses",
		vjgibs = "Gibs",
		groundweapons = "Ground Weapons",
		props = "Props",
		decals = "Removed All Decals",
		allweapons = "Removed All Your Weapons",
		allammo = "Removed All Your Ammo",
	}
	concommand.Add("vj_cleanup", function(ply, cmd, args)
		if IsValid(ply) && !ply:IsAdmin() then return end
		local cType = args[1]
		local i = 0
		if !cType then -- Not type given, so it means its a clean up all!
			game.CleanUpMap()
		elseif cType == "decals" then
			for _, v in ipairs(player.GetAll()) do
				v:ConCommand("r_cleardecals")
			end
		elseif IsValid(ply) && cType == "allweapons" then
			ply:StripWeapons()
		elseif IsValid(ply) && cType == "allammo" then
			ply:RemoveAllAmmo()
		else
			for _, v in ipairs(ents.GetAll()) do
				if (v:IsNPC() && (cType == "npcs" or (cType == "vjnpcs" && v.IsVJBaseSNPC == true))) or (cType == "spawners" && v.IsVJBaseSpawner == true) or (cType == "corpses" && (v.IsVJBaseCorpse == true or v.IsVJBase_Gib == true)) or (cType == "vjgibs" && v.IsVJBase_Gib == true) or (cType == "groundweapons" && v:IsWeapon() && v:GetOwner() == NULL) or (cType == "props" && v:GetClass() == "prop_physics" && (v:GetParent() == NULL or (IsValid(v:GetParent()) && v:GetParent():Health() <= 0 && (v:GetParent():IsNPC() or v:GetParent():IsPlayer())))) then
					//undo.ReplaceEntity(v, NULL)
					v:Remove()
					i = i + 1
				end
			end
			-- Clean up client side corpses
			-- DOES NOT WORK, FUNCTION IS BROKEN!
			//if cType == "corpses" then
				//game.RemoveRagdolls()
			//end
		end
		if IsValid(ply) then
			if !cType then
				ply:SendLua("GAMEMODE:AddNotify(\"Cleaned Up Everything!\", NOTIFY_CLEANUP, 5)")
			elseif cType == "decals" or cType == "allweapons" or cType == "allammo" then
				ply:SendLua("GAMEMODE:AddNotify(\""..cTypes[cType].."\", NOTIFY_CLEANUP, 5)")
			else
				ply:SendLua("GAMEMODE:AddNotify(\"Removed "..i.." "..cTypes[cType].."\", NOTIFY_CLEANUP, 5)")
			end
			ply:EmitSound("buttons/button15.wav")
		end
	end, nil, "", {FCVAR_DONTRECORD})
else
	local function VJ_MAINMENU_CLEANUP(Panel)
		if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
			Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
			Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
			return
		end
		Panel:ControlHelp(" ") -- Spacer
		Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
		Panel:Button("#vjbase.menu.cleanup.all", "vj_cleanup")
		Panel:Button("#vjbase.menu.cleanup.stopsounds", "stopsound")
		Panel:Button("#vjbase.menu.cleanup.remove.vjnpcs", "vj_cleanup", "vjnpcs")
		Panel:Button("#vjbase.menu.cleanup.remove.npcs", "vj_cleanup", "npcs")
		Panel:Button("#vjbase.menu.cleanup.remove.spawners", "vj_cleanup", "spawners")
		Panel:Button("#vjbase.menu.cleanup.remove.corpses", "vj_cleanup", "corpses")
		Panel:Button("#vjbase.menu.cleanup.remove.vjgibs", "vj_cleanup", "vjgibs")
		Panel:Button("#vjbase.menu.cleanup.remove.groundweapons", "vj_cleanup", "groundweapons")
		Panel:Button("#vjbase.menu.cleanup.remove.props", "vj_cleanup", "props")
		Panel:Button("#vjbase.menu.cleanup.remove.decals", "vj_cleanup", "decals")
		Panel:Button("#vjbase.menu.cleanup.remove.allweapons", "vj_cleanup", "allweapons")
		Panel:Button("#vjbase.menu.cleanup.remove.allammo", "vj_cleanup", "allammo")
	end
	----=================================----
	local function VJ_MAINMENU_MISC(Panel)
		local incomp = vgui.Create("DButton") -- Incompatible Addons
		incomp:SetFont("CloseCaption_Bold")
		incomp:SetText("#vjbase.menu.helpsupport.incompatibleaddons")
		incomp:SetSize(150, 35)
		incomp:SetColor(Color(231, 76, 60))
		incomp:SetFont("VJFont_Trebuchet24_SmallMedium")
		incomp.DoClick = function()
			gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=1129493108")
		end
		Panel:AddPanel(incomp)
		
		local bugr = vgui.Create("DButton") -- Bug Report
		bugr:SetFont("CloseCaption_Bold")
		bugr:SetText("#vjbase.menu.helpsupport.reportbug")
		bugr:SetSize(150, 35)
		bugr:SetColor(Color(231, 76, 60))
		bugr:SetFont("VJFont_Trebuchet24_SmallMedium")
		bugr.DoClick = function()
			gui.OpenURL("http://steamcommunity.com/groups/vrejgaming/discussions/2/")
		end
		Panel:AddPanel(bugr)

		local suggest = vgui.Create("DButton") -- Suggestions
		suggest:SetFont("DermaDefaultBold")
		suggest:SetText("#vjbase.menu.helpsupport.suggestion")
		suggest:SetSize(150, 20)
		suggest:SetColor(Color(211, 84, 0))
		suggest:SetFont("VJFont_Trebuchet24_SmallMedium")
		suggest.DoClick = function()
			gui.OpenURL("http://steamcommunity.com/groups/vrejgaming/discussions/1/")
		end
		Panel:AddPanel(suggest)

		Panel:ControlHelp(" ") -- Spacer

		Panel:AddControl("Label", {Text = "#vjbase.menu.helpsupport.label1"})
		Panel:ControlHelp("#vjbase.menu.helpsupport.thanks")

		local discordl = vgui.Create("DButton") -- Discord
		discordl:SetFont("TargetID")
		discordl:SetText("#vjbase.menu.helpsupport.discord")
		discordl:SetSize(150, 25)
		discordl:SetColor(Color(0, 102, 0))
		discordl:SetFont("VJFont_Trebuchet24_SmallMedium")
		discordl.DoClick = function()
			gui.OpenURL("https://discord.gg/zwQjrdG")
		end
		Panel:AddPanel(discordl)
		
		local steaml = vgui.Create("DButton") -- Steam Group
		steaml:SetFont("TargetID")
		steaml:SetText("#vjbase.menu.helpsupport.steam")
		steaml:SetSize(150, 25)
		steaml:SetColor(Color(0, 102, 0))
		steaml:SetFont("VJFont_Trebuchet24_SmallMedium")
		steaml.DoClick = function()
			gui.OpenURL("http://steamcommunity.com/groups/vrejgaming")
		end
		Panel:AddPanel(steaml)

		local ytl = vgui.Create("DButton") -- YouTube
		ytl:SetFont("TargetID")
		ytl:SetText("#vjbase.menu.helpsupport.youtube")
		ytl:SetSize(150, 25)
		ytl:SetColor(Color(0, 102, 0))
		ytl:SetFont("VJFont_Trebuchet24_SmallMedium")
		ytl.DoClick = function()
			gui.OpenURL("http://www.youtube.com/user/gmod95")
		end
		Panel:AddPanel(ytl)

		local tweetl = vgui.Create("DButton") -- Twitter
		tweetl:SetFont("TargetID")
		tweetl:SetText("#vjbase.menu.helpsupport.twitter")
		tweetl:SetSize(150, 25)
		tweetl:SetColor(Color(0, 102, 0))
		tweetl:SetFont("VJFont_Trebuchet24_SmallMedium")
		tweetl.DoClick = function()
			gui.OpenURL("http://twitter.com/vrejgaming")
		end
		Panel:AddPanel(tweetl)

		Panel:ControlHelp(" ") -- Spacer
		
		local donate = vgui.Create("DButton") -- Donate
		donate:SetFont("TargetID")
		donate:SetText("#vjbase.menu.helpsupport.patreon")
		donate:SetSize(150, 30)
		donate:SetColor(Color(0, 0, 102))
		donate:SetFont("VJFont_Trebuchet24_SmallMedium")
		donate.DoClick = function()
			gui.OpenURL("https://www.patreon.com/drvrej")
		end
		Panel:AddPanel(donate)
		Panel:ControlHelp("#vjbase.menu.helpsupport.label2")

		/*HTMLTest = vgui.Create("HTML")
		HTMLTest:SetPos(50,50)
		HTMLTest:SetSize(ScrW() - 100, ScrH() - 100)
		HTMLTest:OpenURL("http://steamcommunity.com/sharedfiles/filedetails/?id=131759821")	*/
		//Panel:AddPanel(HTMLTest)
	end
	----=================================----
	local function VJ_MAINMENU_ADMINSERVER(Panel)
		if !game.SinglePlayer() && !LocalPlayer():IsAdmin() then
			Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.not"})
			Panel:AddControl( "Label", {Text = "#vjbase.menu.general.admin.only"})
			return
		end
		Panel:AddControl("Label", {Text = "#vjbase.menu.general.admin.only"})
		Panel:AddControl("Label", {Text = "#vjbase.menu.svsettings.label"})
		local vj_resetadminmenu = {Options = {}, CVars = {}, Label = language.GetPhrase("#vjbase.menu.general.reset.everything")..":", MenuButton = "0"}
		//vj_resetadminmenu:SetText("Select Default to reset everything")
		vj_resetadminmenu.Options["#vjbase.menu.general.default"] = {
			sbox_noclip = "1",
			sbox_weapons =	"1",
			sbox_playershurtplayers = "1",
			sbox_godmode = "0",
			sv_gravity = "600",
			host_timescale = "1",
			phys_timescale = "1",
		}
		Panel:AddControl("ComboBox", vj_resetadminmenu)
		Panel:ControlHelp(" ") -- Spacer
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.admin.npcproperties", Command = "vj_npc_admin_properties"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.noclip", Command = "sbox_noclip"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.weapons", Command = "sbox_weapons"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.pvp", Command = "sbox_playershurtplayers"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.godmode", Command = "sbox_godmode"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.bonemanip.npcs", Command = "sbox_bonemanip_npc"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.bonemanip.players", Command = "sbox_bonemanip_player"})
		Panel:AddControl("Checkbox", {Label = "#vjbase.menu.svsettings.bonemanip.others", Command = "sbox_bonemanip_misc"})
		Panel:AddControl("Slider",{Label = "#vjbase.menu.svsettings.timescale.general",Type = "Float",min = 0.1,max = 10,Command = "host_timescale"})
		Panel:AddControl("Slider",{Label = "#vjbase.menu.svsettings.timescale.physics",Type = "Float",min = 0,max = 2,Command = "phys_timescale"})
		Panel:AddControl("Slider",{Label = "#vjbase.menu.svsettings.gravity",Type = "Float",min = -200,max = 600,Command = "sv_gravity"})
		Panel:AddControl("Label", {Text = "#vjbase.menu.svsettings.maxentsprops"})
		for _, x in pairs(cleanup.GetTable()) do -- Simply receives all of the GMod limit convars
			if (!GetConVar("sbox_max"..x)) then continue end
			Panel:AddControl("Slider",{Label = "#max_"..x, Command = "sbox_max"..x, Min = "0", Max = "9999"})
		end
	end
	----=================================----
	hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_MAIN", function()
		spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Clean Up", "#vjbase.menu.cleanup", "", "", VJ_MAINMENU_CLEANUP, {})
		spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Contact and Support", "#vjbase.menu.helpsupport", "", "", VJ_MAINMENU_MISC, {})
		spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Admin Server Settings", "#vjbase.menu.svsettings", "", "", VJ_MAINMENU_ADMINSERVER, {})
	end)
end

--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/extensions/wos_base.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_holdtypes.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_prone_support.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\core\\sh_prone_support.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Prone Compatability:
		Fixes hold types for Prone Mod
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}

hook.Add("prone.Initialized", "wOS.AnimExtension.AddProneTypes", function()
	for holdtype, data in pairs( wOS.AnimExtension.HoldTypes ) do
		local iseq = prone.GetIdleAnimation( data.BaseHoldType ) 
		local mseq = prone.GetMovingAnimation( data.BaseHoldType ) 
		prone.AddNewHoldTypeAnimation( holdtype, mseq, iseq )
	end
end )


--PATH lua/wos/anim_extension/holdtypes/a_combo1.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo1"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo1" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo1" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/butterfly.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/butterfly.lua:

local DATA = {}
DATA.Name = "[LSCS] HoldType Butterfly"
DATA.HoldType = "wos_butterfly_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "vanguard_f_idle"
DATA.Translations[ ACT_MP_WALK ] = "walk_knife"
DATA.Translations[ ACT_MP_RUN ] = "run_knife"
DATA.Translations[ ACT_MP_JUMP ] = "wos_bs_shared_jump_descend"
DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/g_rollback.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollback"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollback" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollback" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/melee2great.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/meleetestholdtype.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/saber_staff_dual.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/slashup.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/warrior.lua:
local DATA = {}
DATA.Name = "melee2"
DATA.HoldType = "wos-warrior-corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_h_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "phalanx_b_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/youngli.lua:
local DATA = {}
DATA.Name = "melee3"
DATA.HoldType = "wos-youngli-corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "idle_all_scared", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH lua/wos/dynabase/registers/exp_register.lua:

wOS.DynaBase:RegisterSource({
    Name = "Experimental Extension",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/anim_extension_wos.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountEXP", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/anim_extension_wos.mdl" )
end )
--PATH lua/autorun/xeninui_load.lua:
return gluapack()()
--PATH lua/xeninui/settings/settings.lua:
XeninUI.Branding = false


XeninUI.Materials = {
	CloseButton = Material("xenin/closebutton.png", "noclamp smooth"),
	Search = Material("xenin/search.png", "noclamp smooth"),
	Tick = Material("xenin/tick.png", "smooth")
}

XeninUI.TransitionTime = 0.15


XeninUI.DisableNotification = false


XeninUI.Theme = {
	Primary = Color(48, 48, 48),
	Navbar = Color(41, 41, 41),
	Background = Color(30, 30, 30),
	Accent = Color(41, 128, 185),
	OrangeRed = Color(228, 104, 78),
	Red = Color(230, 58, 64),
	Green = Color(46, 204, 113),
	Blue = Color(41, 128, 185),
	Yellow = Color(201, 176, 15),
	Purple = Color(142, 68, 173),
	Orange = Color(230, 153, 58),
	LightYellow = Color(189, 201, 15),
	GreenDark = Color(39, 174, 96)
}

XeninUI.Frame = {
	Width = 960,
	Height = 720
}

--PATH lua/xeninui/libs/icon_dl.lua:
return gluapack()()
--PATH lua/xeninui/libs/time.lua:
return gluapack()()
--PATH lua/xeninui/libs/wyvern.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/cache.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/network/client.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/row.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/checkbox.lua:
local x

--PATH lua/xeninui/libs/config/network/client.lua:
net.Receive("Xenin.RequestConfig", function(len, ply)
  local selector = net.ReadString()
  local len = net.ReadUInt(32)
  local tbl = von.deserialize(net.ReadData(len))

  XeninUI.Config:set(selector, tbl)
end)

--PATH lua/xeninui/libs/players/controller.lua:
local Controller
do
  local _class_0
  local _base_0 = {
    __name = "Controller",
    onPlayerInitialSpawn = function(self, ply)
      local db = XeninUI.Players.Database
      db:begin()
      self:playTimeJoin(ply)
      db:commit():next(function()
        if (!IsValid(ply)) then return end

        hook.Run("Xenin.PlayerInitialSpawn", ply)
      end)
    end,
    onPlayerDisconnect = function(self, ply)
      self:playTimeDisconnect(ply)
    end,
    playTimeJoin = function(self, ply)
      local sid64 = ply:SteamID64()
      local db = XeninUI.Players.Database
      db:insertPlayer(sid64)
      db:deleteInactivePlayerJoins(sid64)
      db:insertPlayerJoin(sid64)
      db:getPlayerPlayTime(sid64):next(function(result)
        if (!IsValid(ply)) then return end

        ply.xeninPlaytime = result
      end)
    end,
    getAmountOfUnreadNotifications = function(self, ply)
      return XeninUI.Players.Database:getAmountOfUnreadNotifications(ply:SteamID64())
    end,
    getNotifications = function(self, ply)
      return XeninUI.Players.Database:getNotifications(ply:SteamID64())
    end,
    addNotificationSid64 = function(self, sid64, notification)
      assert(notification ~= nil, "cannot destructure nil value")
      local scriptId, type, content, data = notification.scriptId, notification.type, notification.content, notification.data
      local db = XeninUI.Players.Database

      return db:insertNotification(sid64, scriptId, type, content, data):next(function(id)
        return db:getNotification(id)
      end)
    end,
    markNotificationsRead = function(self, sid64, ids)
      local db = XeninUI.Players.Database
      db:begin()
      for i, v in ipairs(ids) do
        db:markNotificationRead(sid64, v)
      end
      return db:commit()
    end,
    addNotification = function(self, ply, notification)
      return self:addNotificationSid64(ply:SteamID64(), notification):next(function(result)
        return result
      end)
    end,
    playTimeDisconnect = function(self, ply)
      XeninUI.Players.Database:insertPlayerLeave(ply:SteamID64())
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self) end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Controller = _class_0
end

XeninUI.Players.Controller = Controller()

if SERVER then
  hook.Add("PlayerInitialSpawn", "XeninUI.Players", function(ply)
    XeninUI.Players.Controller:onPlayerInitialSpawn(ply)
  end)

  hook.Add("PlayerDisconnected", "XeninUI.Players", function(ply)
    XeninUI.Players.Controller:onPlayerDisconnect(ply)
  end)
end

--PATH lua/xeninui/libs/players/ui/notifications/row.lua:
local PANEL = {}

function PANEL:Init()
  self.OnPaint = {}
  self.BackgroundColor = XeninUI.Theme.Primary
end

function PANEL:SetNotification(notification)
  self.Notification = notification
  if self.Notification.readAt then
    self.BackgroundColor = XeninUI.Theme.Navbar
  end
  self.TypeData = XeninUI.Notification:getType(notification.scriptId, notification.type)

  self.Hooks = self.TypeData.hooks and self.TypeData.hooks(notification)
  local hooks = self.Hooks
  if (hooks and hooks.preInit) then
    hooks.preInit(notification, self)
  end

  local img = self.TypeData.img(notification)
  if img.custom then
    img.custom(notification, self)
  elseif img.src then
    XeninUI:DownloadIcon(self, img.src, "Image")
    self:AddPaint(function(self, w, h)
      XeninUI:DrawIcon(8, 8, 48 - 16, 48 - 16, self, self.color, self.color, "Image")
    end)
  elseif img.ply then
    self.PlayerAvatar = self:Add("XeninUI.Avatar")
    self.PlayerAvatar:SetSteamID(img.ply.sid64, 64)
    self.PlayerAvatar:SetVertices(30)
  end

  self.Title = {
    text = self.Notification.content,
    font = "XeninUI.Players.Notifications.Row.Title",
    color = Color(232, 232, 232)
  }
  self.Subtitle = {
    text = XeninUI:DateToString(self.Notification.createdAt),
    font = "XeninUI.Players.Notifications.Row.Subtitle",
    color = Color(175, 175, 175)
  }

  self.Button = self:Add("DButton")
  self.Button:SetText("")
  self.Button.Color = Color(87, 87, 87)
  XeninUI:DownloadIcon(self.Button, "oRwjOoj")
  self.Button.Paint = function(pnl, w, h)
    local s = 48 - 19
    XeninUI:DrawIcon(h / 2 - s / 4, h / 2 - s / 2, s, s, pnl, pnl.Color)
  end
  self.Button.OnCursorEntered = function(pnl)
    pnl:LerpColor("Color", XeninUI.Theme.Accent)
  end
  self.Button.OnCursorExited = function(pnl)
    pnl:LerpColor("Color", Color(87, 87, 87))
  end
  self.Button.DoClick = function(pnl)
    if self.TypeData.options then
      local options = XeninUI.Options(pnl)
      for i, v in ipairs(self.TypeData.options) do
        v(notification, options, self)
      end
      options:create()
    end
  end
  self.Button:SetVisible(self.TypeData.options)

  if (hooks and hooks.postInit) then
    hooks.postInit(notification, self)
  end
end

function PANEL:AddPaint(func)
  table.insert(self.OnPaint, func)
end

function PANEL:CalculateHeight()
  local h = 7 + draw.GetFontHeight(self.Subtitle.font) + 4
  local w = self:GetWide()

  if (w == 64) then
    w = 719
  end
  local lines = XeninUI:TextToLines(self.Title.text, self.Title.font, w - 48 - 24 - 8)
  h = h + (#lines * (draw.GetFontHeight(self.Title.font) - 2))

  return h
end

XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Title", 18)
XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Subtitle", 12)

function XeninUI:TextToLines(text, font, maxWidth)
  surface.SetFont(font)

  local strings = text:Split("\n")
  local lines = {}

  for i, str in ipairs(strings) do
    local buffer = {}
    for word in str:gmatch("%S+") do
      local w, h = surface.GetTextSize(table.concat(buffer, " ") .. " " .. word)
      if (w > maxWidth) then
        table.insert(lines, table.concat(buffer, " "))
        buffer = {}
      end

      table.insert(buffer, word)
    end

    if (#buffer > 0) then
      table.insert(lines, table.concat(buffer, " "))
    end
  end

  return lines
end

function XeninUI:DrawTextMultiline(text, font, x, y, col, xAlign, yAlign, maxWidth, spacing)
  if spacing == nil then spacing = draw.GetFontHeight(font)
  end
  local lines = self:TextToLines(text, font, maxWidth)

  local offset = y
  for i, v in ipairs(lines) do
    draw.SimpleText(v, font, x, offset, col, xAlign, yAlign)

    offset = offset + (spacing - 3)
  end
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, self.BackgroundColor)

  for i, v in ipairs(self.OnPaint) do
    v(self, w, h)
  end

  local x = 48
  draw.SimpleText("Job Disabled - " .. self.Subtitle.text, self.Subtitle.font, x, 7, self.Subtitle.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
  XeninUI:DrawTextMultiline(self.Title.text, self.Title.font, x, 7 + draw.GetFontHeight(self.Subtitle.font) * 2 + 4, self.Title.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, w - 48 - 24 - 8)
end

function PANEL:PerformLayout(w, h)
  if IsValid(self.PlayerAvatar) then
    self.PlayerAvatar:SetPos(8, 8)
    self.PlayerAvatar:SetSize(h - 16, h - 16)
  end

  if IsValid(self.Button) then
    self.Button:SetSize(h - 8, h - 8)
    self.Button:AlignRight(0)
    self.Button:CenterVertical()
  end
end

vgui.Register("XeninUI.Players.Notifications.Row", PANEL)

--PATH lua/xeninui/libs/players/network/client.lua:
local NetworkClient
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "NetworkClient",
    __base = XeninUI.Network.__base,
    receiveNotification = function(self, ply)
      local noti = XeninUI.Players.NetworkHelper.receiveNotification()

      local str = noti.content:Split("\n")[1]
      local len = math.max(4, #str * 0.065)
      XeninUI:Notify(str, NOTIFY_HINT, len)
    end,
    receiveNotifications = function(self, ply)
      local amt = net.ReadUInt(8)
      local tbl = {}
      for i = 1, amt do
        table.insert(tbl, XeninUI.Players.NetworkHelper.receiveNotification())
      end

      hook.Run("XeninUI.Players.GotNotifications", tbl)
    end,
    sendReceiveNotifications = function(self)
      self:send("notifications", function(self) end)
    end,
    sendReadNotifications = function(self, ids)
      self:send("readNotifications", function(self)
        net.WriteUInt(#ids, 8)
        for i = 1, #ids do
          net.WriteUInt(ids[i], 32)
        end
      end)
    end,
    receiveReadNotifications = function(self, ply) end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self, ...)
      NetworkClient.__parent.__init(self, ...)

      self:setPrefix("Xenin.Players.")

      self:receiver("notification", self.receiveNotification)
      self:receiver("notifications", self.receiveNotifications)
      self:receiver("readNotifications", self.receiveReadNotifications)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  NetworkClient = _class_0
end

XeninUI.Players.Network = NetworkClient()

--PATH lua/xeninui/elements/button.lua:
local PANEL = {}

AccessorFunc(PANEL, "roundness", "Roundness", FORCE_NUMBER)
AccessorFunc(PANEL, "disabled", "Disabled")
AccessorFunc(PANEL, "loading_size", "LoadingImageSizeSub", FORCE_NUMBER)
AccessorFunc(PANEL, "awaiting_response", "AwaitingResponse", FORCE_BOOL)
AccessorFunc(PANEL, "loading_color", "LoadingColor")
AccessorFunc(PANEL, "old_text", "OldText")
AccessorFunc(PANEL, "outline", "Outline", FORCE_NUMBER)

AccessorFunc(PANEL, "clr_background_cur", "BackgroundColor")
AccessorFunc(PANEL, "clr_background_on", "BackgroundColorOn")
AccessorFunc(PANEL, "clr_background_off", "BackgroundColorOff")

AccessorFunc(PANEL, "clr_text_cur", "TextColorCur")
AccessorFunc(PANEL, "clr_text_on", "TextColorOn")
AccessorFunc(PANEL, "clr_text_off", "TextColorOff")

AccessorFunc(PANEL, "enable_shadow", "EnableShadow")
AccessorFunc(PANEL, "shadow_alpha", "ShadowAlpha")
AccessorFunc(PANEL, "shadow_alpha_on", "ShadowAlphaOn")
AccessorFunc(PANEL, "shadow_alpha_off", "ShadowAlphaOff")

XeninUI:CreateFont("XeninUI.Checkbox", 16)
XeninUI:CreateFont("XeninUI.Checkbox.Small", 15)

function PANEL:Init()
	self:SetText("")
	self:SetLoadingImageSizeSub(16)
	self:SetEnableShadow(true)
	self:SetShadowAlphaOn(150)
	self:SetShadowAlphaOff(0)
	self:SetOutline(0)
end

function PANEL:SetAwaitingResponse(b)
	self.awaiting_response = b

	if !b then
		self:SetText(self:GetOldText())
	end
end

function PANEL:Paint(w, h)
	if !self.DidPostInit then return end

	self:SetTextColor(self:GetTextColorCur())

	local r = self:GetRoundness()
	if self:GetEnableShadow() then
		local x, y = self:LocalToScreen(0, 0)
		BSHADOWS.BeginShadow()
		local sub = self:GetOutline()
		if sub > 0 then
			draw.RoundedBox(r or h / 2, x, y, w, h, self:GetTextColorCur())
		end
		draw.RoundedBox(r or h / 2, x + sub, y + sub, w - sub * 2, h - sub * 2, self:GetBackgroundColor())
		BSHADOWS.EndShadow(2, 2, 2, self:GetShadowAlpha(), 0, 0)
	else
		local sub = self:GetOutline()
		if sub > 0 then
			draw.RoundedBox(r or h / 2, 0, 0, w, h, self:GetTextColorCur())
		end
		draw.RoundedBox(r or h / 2, 0 + sub, 0 + sub, w - sub * 2, h - sub * 2, self:GetBackgroundColor())
	end

	if self:GetAwaitingResponse() then
		self:SetText("")
		XeninUI:DrawLoadingCircle(w / 2, h / 2, h - self:GetLoadingImageSizeSub(), self:GetLoadingColor() or self:GetTextColor())
	end
end

function PANEL:RefreshColors(anim)
	for k, v in pairs(self.m_AnimList or {}) do
		if v.OnEnd then v:OnEnd(self)end
		self.m_AnimList[k] = nil
	end

	if self:IsHovered() then
		if anim then
			self:LerpColor("clr_text_cur", self:GetTextColorOn())
			self:LerpColor("clr_background_cur", self:GetBackgroundColorOn())
		else
			self:SetTextColorCur(self:GetTextColorOn())
			self:SetBackgroundColor(self:GetBackgroundColorOn())
		end
	else
		if anim then
			self:LerpColor("clr_text_cur", self:GetTextColorOff())
			self:LerpColor("clr_background_cur", self:GetBackgroundColorOff())
		else
			self:SetTextColorCur(self:GetTextColorOff())
			self:SetBackgroundColor(self:GetBackgroundColorOff())
		end
	end
end

function PANEL:OnCursorEntered()
	if !self.DidPostInit then return end

	if self:GetDisabled() then
		self:SetCursor("no")
		return
	else
		self:SetCursor("hand")
	end

	self:Lerp("shadow_alpha", self:GetShadowAlphaOn())
	self:LerpColor("clr_text_cur", self:GetTextColorOn())
	self:LerpColor("clr_background_cur", self:GetBackgroundColorOn())
end

function PANEL:OnCursorExited()
	if self:GetDisabled() or !self.DidPostInit then return end

	self:Lerp("shadow_alpha", self:GetShadowAlphaOff())
	self:LerpColor("clr_text_cur", self:GetTextColorOff())
	self:LerpColor("clr_background_cur", self:GetBackgroundColorOff())
end

function PANEL:PostInit()
	self:SetOldText(self:GetText())
	self:SetShadowAlpha(self:GetShadowAlphaOff())
	self:SetBackgroundColor(self:GetBackgroundColorOff())
	self:SetTextColorCur(self:GetTextColorOff())

	self.DidPostInit = true
end

vgui.Register("XeninUI.Button", PANEL, "DButton")

--PATH lua/xeninui/elements/dropdown_player.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_parentPanel", "ParentPanel")

function PANEL:Init()
  self.Choices = {}

  self.Search = self:Add("XeninUI.TextEntry")
  self.Search:Dock(TOP)
  self.Search:DockMargin(8, 0, 0, 8)
  self.Search:SetTall(36)
  self.Search:SetPlaceholder("Search by name")
  self.Search:SetIcon(XeninUI.Materials.Search, true)
  self.Search.textentry:SetUpdateOnType(true)
  self.Search.textentry.OnValueChange = function(pnl, text)
    local tbl = {}
    text = text:lower()
    for i, v in pairs(self.Data) do
      if (!IsValid(v)) then continue end
      if (!v:Nick():lower():find(text)) then continue end

      table.insert(tbl, v)
    end

    self:SetData(tbl)
  end
  self.Search.textentry.OnEnter = function(pnl, text)
    local children = self.Layout:GetChildren()
    if IsValid(children[1]) then
      children[1]:DoClick()

      return
    end

    self:Remove()
  end

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Layout = self.Scroll:Add("DListLayout")
  self.Layout:Dock(TOP)

  self.Alpha = 0
  self:LerpAlpha(255, 0.15)

  self:DockPadding(0, 8, 8, 8)
end

function PANEL:OnSelected() end

XeninUI:CreateFont("XeninUI.DropdownPopup.Small", 12)

function PANEL:SetData(tbl)
  if (!self.Data) then
    self.Data = tbl
  end

  self.Layout:Clear()

  self.Choices = {}

  for i, v in ipairs(tbl) do
    if (!IsValid(v)) then return end

    local panel = self.Layout:Add("DButton")
    panel:Dock(TOP)
    panel:DockMargin(8, 0, 8, 0)
    panel:SetTall(48)
    panel:SetText("")
    panel.Text = v:Nick()
    panel.Sid64 = v:SteamID64()
    panel.Sid = v:IsBot() and "BOT" or v:SteamID()
    panel.Usergroup = v:GetUserGroup():sub(1, 1):upper() .. v:GetUserGroup():sub(2)
    panel.Background = XeninUI.Theme.Primary
    panel.TextColor = Color(222, 222, 222)
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Background)

      XeninUI:DrawShadowText(pnl.Text, "XeninUI.DropdownPopup", h + 6, h / 2 + 1, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 1, 150)
      XeninUI:DrawShadowText(pnl.Sid, "XeninUI.DropdownPopup.Small", h + 6, h / 2 + 1, ColorAlpha(pnl.TextColor, 100), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("Background", XeninUI.Theme.Navbar)
      pnl:LerpColor("TextColor", color_white)
    end
    panel.OnCursorExited = function(pnl)
      pnl:LerpColor("Background", XeninUI.Theme.Primary)
      pnl:LerpColor("TextColor", Color(222, 222, 222))
    end
    panel.DoClick = function(pnl)
      self:OnSelected(pnl.Sid64)
      self:Remove()
    end

    panel.Avatar = panel:Add("XeninUI.Avatar")
    panel.Avatar:SetVertices(30)
    panel.Avatar:SetPlayer(v, 64)

    panel.PerformLayout = function(pnl, w, h)
      panel.Avatar:SetPos(6, 6)
      panel.Avatar:SetSize(h - 12, h - 12)
    end

    table.insert(self.Choices, panel)
  end
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, aX, aY, w, h, XeninUI.Theme.Primary)
  BSHADOWS.EndShadow(1, 1, 1, 150)
end

function PANEL:OnFocusChanged(gained)
  if gained then
    self.HasGained = true
  end
end


function PANEL:Think()
  if (!IsValid(self)) then return end
  if (!self.HasGained) then return end
  if self:HasHierarchicalFocus() then return end

  self:Remove()
end

function PANEL:PerformLayout(w, h)
  local longest = 0

  surface.SetFont("XeninUI.DropdownPopup")
  for i, v in pairs(self.Choices) do
    local tw = surface.GetTextSize(v.Text)
    tw = tw + 16
    tw = tw + 16
    tw = tw + 48

    if (tw > longest) then
      longest = math.max(112, tw)
    end
  end

  self:SetWide(math.max(self:GetParentPanel():GetWide(), longest))
  self:SetTall(math.min(#self.Choices * 48, 6 * 48) + 16 + 44)
end

vgui.Register("XeninUI.PlayerDropdown", PANEL, "EditablePanel")

--PATH lua/xeninui/elements/navbar.lua:
XeninUI:CreateFont("XeninUI.Navbar.Button", 25)

local function navbarEase(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t

	return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
end

local PANEL = {}

function PANEL:Init()
	self.buttons = {}
	self.panels = {}
	self.buttonsNum = {}

	self.font = "XeninUI.Navbar.Button"
	self.accent = XeninUI.Theme.Accent
	self.textActive = self.accent
	self.padding = 60
	self.minSize = 80
	self.dockLeft = 0
	self.lineBasedOffText = false
	self.animation = "alpha"

	self.active = 0

	self.line = self:Add("DPanel")
	self.line:SetMouseInputEnabled(false)
	self.line:SetTall(2)
	self.line.Paint = function(pnl, w, h)
		surface.SetDrawColor(self.accent)
		surface.DrawRect(0, 0, w, h)
	end
end

function PANEL:AddTab(name, panel, tbl)

	self.buttonsNum[#self.buttonsNum + 1] = name

	self.buttons[name] = vgui.Create("DButton", self)
	if (!tbl or (tbl and !tbl.dontDock)) then
		self.buttons[name]:Dock(LEFT)
		self.buttons[name]:DockMargin(self.dockLeft, 0, -self.dockLeft, 0)
	end
	self.buttons[name]:SetText(name)
	self.buttons[name]:SetFont(self.font)
	self.buttons[name].textColor = Color(120, 120, 120)
	self.buttons[name].Paint = function(pnl, w, h)
		pnl:SetTextColor(pnl.textColor)
	end
	self.buttons[name].DoClick = function(pnl)
		self:SetActive(name)
	end
	self.buttons[name].OnCursorEntered = function(pnl)
		pnl:LerpColor("textColor", self.textActive)
	end
	self.buttons[name].OnCursorExited = function(pnl)
		if (self.active == name) then return end

		pnl:LerpColor("textColor", Color(120, 120, 120))
	end

	surface.SetFont(self.font)
	local tw, th = surface.GetTextSize(name)
	self.buttons[name]:SetWide(math.max(self.minSize, tw + self.padding))

	if (!panel) then panel = "Panel"end

	self.panels[name] = vgui.Create(panel, self.body)
	self.panels[name]:Dock(FILL)
	self.panels[name]:SetVisible(false)
	self.panels[name].Data = tbl

	if self.panels[name].SetData then
		self.panels[name]:SetData(tbl)
	end

	if (tbl and tbl.PostInit) then
		tbl.PostInit(self.panels[name])
	end

	return self.panels[name]
end

function PANEL:FindIndex(name)
	for i, v in pairs(self.buttonsNum) do
		if (v != name) then continue end

		return i
	end
end

function PANEL:SetActive(name)
	if (self.active == name) then return end

	local instant = !IsValid(self.buttons[self.active])
	if self.buttons[self.active] then
		self.buttons[self.active]:LerpColor("textColor", Color(120, 120, 120))
	end

	if self.panels[self.active] then
		if (self.animation == "alpha") then
			local pnl = self.panels[self.active]
			pnl.DrawAlpha = pnl.DrawAlpha or 0
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 255, 0.15, function()
				pnl.PaintOver = nil
				pnl:SetVisible(false)
			end)
		else
			local pnl = self.panels[self.active]
			pnl:SetVisible(false)
		end

		if self.panels[name].OnSwitchedFrom then
			self.panels[name]:OnSwitchedFrom()
		end
	end

	self.active = name

	if self.buttons[name] then
		if instant then
			self.buttons[name].textColor = self.textActive
			local id = self:FindIndex(name)
			local x = self.dockLeft
			if self.lineBasedOffText then
				x = x + self.padding / 2
			end
			surface.SetFont(self.font)
			for i, v in ipairs(self.buttonsNum) do
				if (i >= id) then break end

				if (self.lineBasedOffText and i == id) then
					local tw = surface.GetTextSize(self.buttons[v]:GetText())
					x = x + tw + self.padding
				else
					x = x + self.buttons[v]:GetWide()
				end
			end

			self.line:SetPos(x, (self.startHeight or 56) - self.line:GetTall())
			local width = self.buttons[name]:GetWide()
			if self.lineBasedOffText then
				surface.SetFont(self.font)
				width = surface.GetTextSize(self.buttons[name]:GetText())
			end
			self.line:SetWide(width)
		else
			self.buttons[name]:LerpColor("textColor", self.textActive)
			local id = self:FindIndex(name)
			local x = self.dockLeft
			if self.lineBasedOffText then
				x = x + self.padding / 2
			end
			surface.SetFont(self.font)
			for i, v in ipairs(self.buttonsNum) do
				if (i >= id) then break end

				if (self.lineBasedOffText and i == id) then
					local tw = surface.GetTextSize(self.buttons[v]:GetText())
					x = x + tw
				else
					x = x + self.buttons[v]:GetWide()
				end
			end

			self.line:LerpMoveX(x, 0.3, nil, navbarEase)
			local width = self.buttons[name]:GetWide()
			if self.lineBasedOffText then
				surface.SetFont(self.font)
				width = surface.GetTextSize(self.buttons[name]:GetText())
			end
			self.line:LerpWidth(width, 0.3, nil, navbarEase)
		end
	end

	if self.panels[name] then
		if instant then
			local pnl = self.panels[name]
			pnl:SetVisible(true)
		else
			if (self.animation == "alpha") then
				timer.Simple(0.15, function()
					if (!IsValid(self)) then return end

					local pnl = self.panels[name]
					pnl.DrawAlpha = pnl.DrawAlpha or 255
					pnl:SetVisible(true)
					pnl.PaintOver = function(pnl, w, h)
						draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
					end
					pnl:Lerp("DrawAlpha", 0, 0.15, function()
						pnl.PaintOver = nil
					end)
				end)
			else
				local pnl = self.panels[name]
				pnl:SetVisible(true)
			end
		end

		if self.panels[name].OnSwitchedTo then
			self.panels[name]:OnSwitchedTo(name)
		end
	end

	self:SwitchedTab(name)
end

function PANEL:SwitchedTab(name) end

function PANEL:GetActive()
	return self.panels[self.active]
end

function PANEL:SetBody(pnl)
	self.body = pnl:Add("Panel")
	self.body:Dock(FILL)
	self.body.Offset = 0
	self.body.PerformLayout = function(pnl, w, h)
		local num = 0
		for i, v in pairs(self.panels) do
			local x = num * w - (pnl.Offset * w)

			v:SetSize(w, h)
			v:SetPos(x, 0)
		end
	end
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(XeninUI.Theme.Navbar)
	surface.DrawRect(0, 0, w, h)
end

vgui.Register("XeninUI.Navbar", PANEL)

--PATH lua/xeninui/elements/panel.lua:
local PANEL = {}

function PANEL:Init()
  self.notifications = {}
end

function PANEL:Notification(title, backgroundCol, textCol)
  local pnl = self:Add("DPanel")
  pnl:SetAlpha(0)
  pnl:AlphaTo(255, 0.1)
  pnl:SetZPos(2)
  pnl.uniqueID = SysTime()
  pnl.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen(0, 0)

    BSHADOWS.BeginShadow()
    draw.RoundedBox(6, x, y, w, h, backgroundCol or XeninUI.Theme.Primary)
    draw.SimpleText(title, "XeninUI.Notification", x + 8, y + 8, textCol or XeninUI:GetContrastColor(backgroundCol, color_white, color_black))
    BSHADOWS.EndShadow(1, 2, 2, 200, 0, 0)
  end

  surface.SetFont("XeninUI.Notification")
  local tw, th = surface.GetTextSize(title)
  pnl:SetSize(tw + 16, th + 16)

  local offset = 16
  for i, v in pairs(self.notifications) do
    offset = offset + v:GetTall() + 8
  end

  pnl:SetPos(self:GetWide() - 16 - pnl:GetWide(), offset)

  table.insert(self.notifications, pnl)

  timer.Simple(3, function()
    if (!IsValid(pnl)) then return end

    pnl:AlphaTo(0, 0.2)

    timer.Simple(0.2, function()
      if (!IsValid(pnl)) then return end

      for i, v in pairs(self.notifications) do
        if (v.uniqueID != pnl.uniqueID) then continue end

        table.remove(self.notifications, i)

        pnl:Remove()
      end
    end)
  end)
end

vgui.Register("XeninUI.Panel", PANEL)

--PATH lua/xeninui/elements/slider_pad.lua:
return gluapack()()
--PATH lua/xeninui/elements/slider_pad.lua:
local PANEL = {}

function PANEL:Init()
  self.Rounding = 0

  self.Slider = self:Add("XeninUI.Slider")
  self.Slider:Dock(FILL)
  self.Slider:DockMargin(0, 0, 8, 0)
  self.Slider.OnValueChanged = function(pnl, frac)
    local value = math.Round(pnl:GetMin() + ((pnl:GetMax() - pnl:GetMin()) * frac), self.Rounding)
    self.Textentry:SetText(value)
    self:OnValueChanged(value)
  end

  self.Textentry = self:Add("XeninUI.TextEntry")
  self.Textentry:Dock(RIGHT)
  self.Textentry:SetNumeric(true)
  self.Textentry:SetUpdateOnType(true)
  self.Textentry.OnValueChange = function(pnl, text)
    local num = tonumber(text)
    if (!isnumber(num)) then return end
    num = math.Clamp(num, self:GetMin(), self:GetMax())
    num = math.Round(num, self.Rounding)

    self:SetValue(num, true)
    self:OnValueChanged(num)
  end

  self:SetValue(5)
end

function PANEL:SetValue(value, dontSetText)
  local frac = (value - self:GetMin()) / (self:GetMax() - self:GetMin())
  self:SetFraction(math.Clamp(frac, 0, 1))

  if (!dontSetText) then
    self.Textentry:SetText(value)
  end
  self.Slider:InvalidateLayout(true)
end

function PANEL:GetValue()
  return math.Clamp(self.Textentry:GetText(), self:GetMin(), self:GetMax())
end


function PANEL:OnValueChanged(value) end

function PANEL:SetMin(min)
  self.Slider:SetMin(min)end
function PANEL:GetMin()
  return self.Slider:GetMin()end
function PANEL:SetMax(max)
  self.Slider:SetMax(max)end
function PANEL:GetMax()
  return self.Slider:GetMax()end
function PANEL:SetColor(color)
  self.Slider:SetColor(color)end
function PANEL:GetColor()
  return self.Slider:GetColor()end
function PANEL:SetFraction(fraction)
  self.Slider.fraction = fraction end
function PANEL:GetFraction()
  return self.Slider.fraction end
function PANEL:SetRounding(rounding)
  self.Rounding = rounding end
function PANEL:GetRounding()
  return self.Rounding end

vgui.Register("XeninUI.SliderPad", PANEL, "Panel")

--PATH lua/xeninui/core/ui/main.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Load", 48)
XeninUI:CreateFont("Xenin.Framework.Tab", 20)

function PANEL:Init()
  self:SetSize(XeninUI.Frame.Width, XeninUI.Frame.Height)
  self:Center()
  self:SetTitle("Xenin Framework - Admin")
  self:MakePopup()

  self:AddHook("Xenin.Framework.ReceivedScripts", "Xenin.Framework", function(self, scripts)
    self:CreateSidebar()
  end)

  XeninUI.ScriptsNetwork:requestScripts()
end

function PANEL:CreateCategory(name, col)
  if col == nil then col = Color(64, 64, 64)
  end
  local panel = self.Sidebar.Scroll:Add("DPanel")
  panel:Dock(TOP)
  panel:SetTall(draw.GetFontHeight("Xenin.Framework.Tab") + 16)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "Xenin.Framework.Tab", w / 2, h / 2, Color(212, 212, 212), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    surface.SetDrawColor(col)
    if (name != "1st party") then
      surface.DrawRect(0, 0, w, 1)
    end
    surface.DrawRect(0, h - 1, w, 1)
  end
end

function PANEL:CreateSidebar(tbl)
  self.Sidebar = self:Add("XeninUI.SidebarV2")
  self.Sidebar:Dock(LEFT)
  self.Sidebar:SetBody(self)

  local scripts = XeninUI.Scripts:getAll()


  for i, v in pairs(scripts) do
    self.Sidebar:CreatePanel(v.name, v.desc, "Xenin.Framework.Tab", v.icon, v)
  end





  self.Sidebar:SetActive(1)
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  if (!IsValid(self.Sidebar)) then return end

  local sw = 0
  for i, v in ipairs(self.Sidebar.Sidebar) do
    surface.SetFont("XeninUI.SidebarV2.Name")
    local nameTw = surface.GetTextSize(v.Name or "")
    surface.SetFont("XeninUI.SidebarV2.Desc")
    local descTw = surface.GetTextSize(v.Desc or "")

    local tw = math.max(nameTw, descTw) + 8
    if v.Icon then
      tw = tw + 68
    end

    sw = math.max(sw, tw)
  end

  self.Sidebar:SetWide(math.max(140, sw))
end

function PANEL:Paint(w, h)
  self.BaseClass.Paint(self, w, h)

  if self.Sidebar then return end

  XeninUI:DrawLoadingCircle(w / 2, h / 2 + 18, h / 4)
  XeninUI:DrawShadowText("Loading all addons", "Xenin.Framework.Load", w / 2, h / 2 - h / 8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, 150)
end

vgui.Register("Xenin.Framework", PANEL, "XeninUI.Frame")

concommand.Add("xenin_admin", function()
  if (!XeninUI.Permissions:canAccessFramework(LocalPlayer())) then
    chat.AddText(XeninUI.Theme.Red, "[Xenin] ", color_white, "You don't have the required authority to do this")

    return
  end

  vgui.Create("Xenin.Framework")
end)

--PATH lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--PATH lua/advdupe2/sh_codec_legacy.lua:
--[[
	Title: Adv. Dupe 2 Codec Legacy Support

	Desc: Facilitates opening of dupes from AD1 and earlier AD2 versions.

	Author: emspike

	Version: 2.0
]]

local pairs = pairs
local type = type
local tonumber = tonumber
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local AD2FF = "AD2F%s\n%s\n%s"

local decode_types_v1, decode_types_v2
local tables = 0
local str,pos
local a,b,c,m,n,w,tblref

local function read_v2()
	local t = byte(str, pos+1)
	if t then
		local dt = decode_types_v2[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v2 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t = {}
		tables[w] = t
		
		while true do
			if byte(str, pos+1) == 1 then
				pos = pos + 1
				return t
			else
				t[read_v2()] = read_v2()
			end
		end
	end,
	[3	] = function() -- array
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t, i = {}, 1
		
		tables[w] = t
		
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v2()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str, "\1", pos)
		if m then
			a = tonumber(sub(str, pos+1, m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str, ".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str, "^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end,
	[10	] = function() -- Table Reference
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		tblref = tables[w]
		
		if tblref then
			return tblref
		else
			error(format("table identifier %s points to nil\n", w))
		end
		
	end
}



local function read_v1()
	local t = byte(str,pos+1)
	if t then
		local dt = decode_types_v1[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v1 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		local t = {}
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[read_v1()] = read_v1()
			end
		end
	end,
	[3	] = function() -- array
		local t, i = {}, 1
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v1()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str,"\1",pos)
		if m then
			a = tonumber(sub(str,pos+1,m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end
}

local function deserialize_v1(data)
	str = data
	pos = 0
	tables = {}
	return read_v1()
end

local function deserialize_v2(data)
	str = data
	pos = 0
	tables = {}
	return read_v2()
end

local function lzwDecode(encoded)
	local dictionary_length = 256
	local dictionary = {}
	for i = 0, 255 do
		dictionary[i] = char(i)
	end
	
	local pos = 2
	local decompressed = {}
	local decompressed_length = 1
	
	local index = byte(encoded)
	local word = dictionary[index]
	
	decompressed[decompressed_length] = dictionary[index]
	
	local entry
	local encoded_length = #encoded
	local firstbyte --of an index
	while pos <= encoded_length do
		firstbyte = byte(encoded,pos)
		if firstbyte > 252 then --now we know it's a length indicator for a multibyte index
			index = 0
			firstbyte = 256 - firstbyte
			
			--[[if pos+firstbyte > encoded_length then	--will test for performance impact
				error("expected index got EOF")
			end]]
			
			for i = pos+firstbyte, pos+1, -1 do
				index = bit.bor(bit.lshift(index, 8), byte(encoded,i))
			end
			pos = pos + firstbyte + 1
		else
			index = firstbyte
			pos = pos + 1
		end
		entry = dictionary[index] or (word..sub(word,1,1))
		decompressed_length = decompressed_length + 1
		decompressed[decompressed_length] = entry
		dictionary[dictionary_length] = word..sub(entry,1,1)
		dictionary_length = dictionary_length + 1
		word = entry
	end
	return concat(decompressed)
end

--http://en.wikipedia.org/wiki/Huffman_coding#Decompression

local invcodes = {[2]={[0]="\254"},[5]={[22]="\1",[11]="\2"},[6]={[13]="\7",[35]="\6",[37]="\5",[58]="\3",[31]="\8",[9]="\13",[51]="\9",[55]="\10",[57]="\4",[59]="\15"},[7]={[1]="\14",[15]="\16",[87]="\31",[89]="\30",[62]="\26",[17]="\27",[97]="\19",[19]="\43",[10]="\12",[39]="\33",[41]="\24",[82]="\40",[3]="\32",[46]="\41",[47]="\38",[94]="\25",[65]="\23",[50]="\39",[26]="\11",[7]="\28",[33]="\18",[61]="\17",[25]="\42"},[8]={[111]="\101",[162]="\29",[2]="\34",[133]="\21",[142]="\36",[5]="\20",[21]="\37",[170]="\44",[130]="\22",[66]="\35"},[9]={[241]="\121",[361]="\104",[365]="\184",[125]="\227",[373]="\198",[253]="\117",[381]="\57",[270]="\49",[413]="\80",[290]="\47",[294]="\115",[38]="\112",[429]="\74",[433]="\0",[437]="\48",[158]="\183",[453]="\107",[166]="\111",[469]="\182",[477]="\241",[45]="\86",[489]="\69",[366]="\100",[497]="\61",[509]="\76",[49]="\53",[390]="\78",[279]="\196",[283]="\70",[414]="\98",[53]="\55",[422]="\109",[233]="\79",[349]="\89",[369]="\52",[14]="\105",[238]="\56",[319]="\162",[323]="\83",[327]="\63",[458]="\65",[335]="\231",[339]="\225",[337]="\114",[347]="\193",[493]="\139",[23]="\209",[359]="\250",[490]="\68",[42]="\54",[63]="\91",[286]="\97",[254]="\50",[510]="\108",[109]="\73",[67]="\103",[255]="\122",[69]="\170",[70]="\110",[407]="\176",[411]="\119",[110]="\120",[83]="\146",[149]="\163",[151]="\224",[85]="\51",[155]="\177",[79]="\251",[27]="\118",[447]="\159",[451]="\228",[455]="\175",[383]="\174",[463]="\243",[467]="\157",[173]="\210",[475]="\167",[177]="\84",[90]="\45",[487]="\206",[93]="\226",[495]="\245",[207]="\64",[127]="\147",[191]="\155",[511]="\153",[195]="\208",[197]="\85",[199]="\178",[181]="\82",[102]="\116",[103]="\71",[285]="\144",[105]="\102",[211]="\199",[213]="\123",[301]="\66",[305]="\46",[219]="\137",[81]="\67",[91]="\88",[157]="\130",[325]="\95",[29]="\58",[231]="\201",[117]="\99",[341]="\222",[237]="\77",[239]="\211",[71]="\223"},[10]={[710]="\149",[245]="\60",[742]="\172",[774]="\81",[134]="\151",[917]="\145",[274]="\216",[405]="\242",[146]="\194",[838]="\246",[298]="\248",[870]="\189",[1013]="\150",[894]="\190",[326]="\244",[330]="\166",[334]="\217",[465]="\179",[346]="\59",[354]="\180",[966]="\212",[974]="\143",[370]="\148",[998]="\154",[625]="\138",[382]="\161",[194]="\141",[198]="\126",[402]="\96",[206]="\185",[586]="\129",[721]="\187",[610]="\135",[618]="\181",[626]="\72",[226]="\62",[454]="\127",[658]="\113",[462]="\164",[234]="\214",[474]="\140",[242]="\106",[714]="\188",[730]="\87",[498]="\237",[746]="\125",[754]="\229",[786]="\128",[202]="\93",[18]="\255",[810]="\173",[846]="\131",[74]="\192",[842]="\142",[977]="\252",[858]="\235",[78]="\134",[874]="\234",[882]="\90",[646]="\92",[1006]="\160",[126]="\165",[914]="\221",[718]="\94",[738]="\238",[638]="\197",[482]="\230",[34]="\220",[962]="\133",[6]="\213",[706]="\219",[986]="\171",[994]="\233",[866]="\200",[1010]="\247",[98]="\169",[518]="\236",[494]="\207",[230]="\205",[542]="\191",[501]="\202",[530]="\203",[450]="\204",[209]="\158",[106]="\186",[590]="\136",[218]="\232",[733]="\124",[309]="\168",[221]="\152",[757]="\240",[113]="\215",[114]="\156",[362]="\239",[486]="\132",[358]="\249",[262]="\75",[30]="\218",[821]="\195",[546]="\253"}}

local function huffmanDecode(encoded)
	
	local h1,h2,h3 = byte(encoded, 1, 3)
	
	if (not h3) or (#encoded < 4) then
		error("invalid input")
	end
	
	local original_length = bit.bor(bit.lshift(h3,16), bit.lshift(h2,8), h1)
	local encoded_length = #encoded+1
	local decoded = {}
	local decoded_length = 0
	local buffer = 0
	local buffer_length = 0
	local code
	local code_len = 2
	local temp
	local pos = 4
	
	while decoded_length < original_length do
		if code_len <= buffer_length then
			temp = invcodes[code_len]
			code = bit.band(buffer, bit.lshift(1, code_len)-1)
			if temp and temp[code] then --most of the time temp is nil
				decoded_length = decoded_length + 1
				decoded[decoded_length] = temp[code]
				buffer = bit.rshift(buffer, code_len)
				buffer_length = buffer_length - code_len
				code_len = 2
			else
				code_len = code_len + 1
				if code_len > 10 then
					error("malformed code")
				end
			end
		else
			buffer = bit.bor(buffer, bit.lshift(byte(encoded, pos), buffer_length))
			buffer_length = buffer_length + 8
			pos = pos + 1
			if pos > encoded_length then
				error("malformed code")
			end
		end
	end
	
	return concat(decoded)
end

local function invEscapeSub(str)
	local escseq,body = match(str,"^(.-)\n(.-)$")
	
	if not escseq then error("invalid input") end
	
	return gsub(body,escseq,"\26")
end

local dictionary
local subtables

local function deserializeChunk(chunk)
	
	local ctype,val = byte(chunk),sub(chunk,3)
	
	if     ctype == 89 then return dictionary[ val ]
	elseif ctype == 86 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Vector( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 65 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Angle( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 84 then 
		local t = {}
		local tv = subtables[val]
		if not tv then
			tv = {}
			subtables[ val ] = tv
		end
		tv[#tv+1] = t
		return t
	elseif ctype == 78 then return tonumber(val)
	elseif ctype == 83 then return gsub(sub(val,2,-2),"",";")
	elseif ctype == 66 then return val == "t"
	elseif ctype == 80 then return 1
	end
	
	error(format("AD1 deserialization failed: invalid chunk (%u:%s)",ctype,val))
	
end

local function deserializeAD1(dupestring)
	
	dupestring = dupestring:Replace("\r\n", "\n")
	local header, extraHeader, dupeBlock, dictBlock = dupestring:match("%[Info%]\n(.+)\n%[More Information%]\n(.+)\n%[Save%]\n(.+)\n%[Dict%]\n(.+)")
	
	if not header then
		error("unknown duplication format")
	end
	
	local info = {}
	for k,v in header:gmatch("([^\n:]+):([^\n]+)") do
		info[k] = v
	end
		
	local moreinfo = {}
	for k,v in extraHeader:gmatch("([^\n:]+):([^\n]+)") do
		moreinfo[k] = v
	end
	
	dictionary = {}
	for k,v in dictBlock:gmatch("(.-):\"(.-)\"\n") do
		dictionary[k] = v
	end

	local dupe = {}
	for key,block in dupeBlock:gmatch("([^\n:]+):([^\n]+)") do
		
		local tables = {}
		subtables = {}
		local head
		
		for id,chunk in block:gmatch('(%w+){(.-)}') do
			
			--check if this table is the trunk
			if byte(id) == 72 then
				id = sub(id,2)
				head = id
			end
			
			tables[id] = {}
			
			for kv in gmatch(chunk,'[^;]+') do
				
				local k,v = match(kv,'(.-)=(.+)')
				
				if k then
					k = deserializeChunk( k )
					v = deserializeChunk( v )
					
					tables[id][k] = v
				else
					v = deserializeChunk( kv )
					local tid = tables[id]
					tid[#tid+1]=v
				end
				
			end
		end
		
		--Restore table references
		for id,tbls in pairs( subtables ) do
			for _,tbl in pairs( tbls ) do
				if not tables[id] then error("attempt to reference a nonexistent table") end
				for k,v in pairs(tables[id]) do
					tbl[k] = v
				end
			end
		end
		
		dupe[key] = tables[ head ]
		
	end
	
	return dupe, info, moreinfo
	
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("attempt to read AD2 file with malformed info block error 1")
	end
	local info = {}
	local ss = str:sub(1,last-1)
	for k,v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end
	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)")
		else
			error("attempt to read AD2 file with malformed info block error 2")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[2] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v2(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[1] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v1(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[0] = deserializeAD1

AdvDupe2.LegacyDecoders = versions
--PATH lua/autorun/client/alydus_destructiblefortificationsextension.lua:
return gluapack()()
--PATH lua/autorun/client/godsenttools_gpu_saver.lua:
local convar = CreateClientConVar("godsenttools_gpu_saver", "1", true, false, language.GetPhrase("#godsenttools.gpusaver.enable.help"), 0, 1)
local manual = false
local KeyboardController = NULL

hook.Add("PopulateToolMenu", "GodSentToolsGPUSaver", function()
	if KeyboardController:IsValid() then
		KeyboardController:Remove()
	end

	KeyboardController = vgui.Create("DPanel")
	KeyboardController.Paint = nil

	function KeyboardController:OnKeyCodeReleased(keyCode)
		manual = false

		KeyboardController:SetKeyboardInputEnabled(false)
		KeyboardController:SetMouseInputEnabled(false)
	end

	spawnmenu.AddToolMenuOption("Utilities", "#godsenttools.name", "GodSentTools_GPU_Saver", "#godsenttools.gpusaver.name", "", "", function(form)
		form:SetName("#godsenttools.gpusaver.name")
		form:Help("#godsenttools.gpusaver.description")

		if system.IsOSX() then
			form:Help("#godsenttools.gpusaver.osxwarning")

			convar:SetBool(false)
		end

		form:CheckBox("#godsenttools.enable", "godsenttools_gpu_saver")
		form:ControlHelp("#godsenttools.gpusaver.enable.help")

		form:Button("#godsenttools.gpusaver.enable.manual").DoClick = function()
			if not convar:GetBool() then return end
			local start = RealTime()

			hook.Add("PostRenderVGUI", "GodSentToolsGPUSaver", function()
				local anim = (RealTime() - start) * 1.5

				surface.SetDrawColor(0, 130, 255, anim * 255)
				surface.DrawRect(0, 0, ScrW(), ScrH())

				if anim > 1.2 then
					manual = true

					hook.Remove("PostRenderVGUI", "GodSentToolsGPUSaver")
				end
			end)
		end
	end)
end)

do
	surface.SetFont("DermaLarge")

	local Line1len = surface.GetTextSize("#godsenttools.gpusaver.screen.enabled") * 0.5

	local Line2len, Line2h = surface.GetTextSize("#godsenttools.gpusaver.screen.presskey")
	Line2len = Line2len * 0.5

	local Line2h2, Line2h02, Line2h15 = Line2h * 2, Line2h * 0.5, Line2h * 1.5
	local Line3len = surface.GetTextSize("#godsenttools.gpusaver.screen.howtodisable") * 0.5

	local where_to_disable = string.format(language.GetPhrase("#godsenttools.gpusaver.screen.wheretodisable"), string.upper(input.LookupBinding("menu") or input.LookupBinding("gm_showhelp") or "Q"))
	local Line4len = surface.GetTextSize(where_to_disable) * 0.5

	local surfaceSetTextColor, systemHasFocus, camStart, surfaceSetTextPos, surfaceSetFont, camEnd2D, surfaceDrawText = surface.SetTextColor, system.HasFocus, cam.Start, surface.SetTextPos, surface.SetFont, cam.End2D, surface.DrawText
	local surfaceSetDrawColor, surfaceDrawRect = surface.SetDrawColor, surface.DrawRect
	local ScrW, ScrH = ScrW, ScrH

	local state = false

	local t2D = {
		type = "2D"
	}

	local function GPUSaver()
		if not systemHasFocus() or manual then
			if not state then
				if KeyboardController:IsValid() then
					KeyboardController:MakePopup()
				end

				state = true
			end

			local W, H = ScrW() * 0.5, ScrH() * 0.5

			camStart(t2D)

			surfaceSetDrawColor(0, 130, 255)
			surfaceDrawRect(0, 0, W * 2, H * 2)

			surfaceSetFont("DermaLarge")
			surfaceSetTextColor(255, 255, 255)

			surfaceSetTextPos(W - Line1len, H - Line2h2)
			surfaceDrawText("#godsenttools.gpusaver.screen.enabled")

			surfaceSetTextPos(W - Line2len, H - Line2h02)
			surfaceDrawText("#godsenttools.gpusaver.screen.presskey")

			surfaceSetTextPos(W - Line3len, H + Line2h02)
			surfaceDrawText("#godsenttools.gpusaver.screen.howtodisable")

			surfaceSetTextPos(W - Line4len, H + Line2h15)
			surfaceDrawText(where_to_disable)

			camEnd2D()

			return true
		elseif state then
			state = false

			if KeyboardController:IsValid() then
				KeyboardController:SetKeyboardInputEnabled(false)
				KeyboardController:SetMouseInputEnabled(false)
			end
		end
	end

	if convar:GetBool() then
		hook.Add("PreRender", "GodSentToolsGPUSaver", GPUSaver)
	end

	cvars.AddChangeCallback("godsenttools_gpu_saver", function(_, _, newValue)
		if newValue == "1" then
			hook.Add("PreRender", "GodSentToolsGPUSaver", GPUSaver)
		else
			hook.Remove("PreRender", "GodSentToolsGPUSaver")
		end
	end, "GodSentToolsGPUSaver")
end
--PATH lua/vgui/bvgui/blankpanel.lua:
return gluapack()()
--PATH lua/vgui/bvgui/checkbox.lua:
return gluapack()()
--PATH lua/vgui/bvgui/colormixer.lua:
return gluapack()()
--PATH lua/vgui/bvgui/pagination.lua:
return gluapack()()
--PATH lua/vgui/bvgui/progressbar.lua:
return gluapack()()
--PATH lua/vgui/gas_circles.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_horizontaldivider.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_listview.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/config/config.lua:
--[[-------------------------------------------------------------------------
DarkRP config settings.
-----------------------------------------------------------------------------

This is the settings file of DarkRP. Every DarkRP setting is listed here.

Warning:
If this file is missing settings (because of e.g. an update), DarkRP will assume default values for these settings.
Don't worry about updating this file. If a new setting is added you can manually add them to this file.
---------------------------------------------------------------------------]]


--[[
Toggle settings.
Set to true or false.
]]

-- voice3D - Enable/disable 3DVoice is enabled.
GM.Config.voice3D                       = true
-- AdminsCopWeapons - Enable/disable admins spawning with cop weapons.
GM.Config.AdminsCopWeapons              = true
-- adminBypassJobCustomCheck - Enable/disable whether an admin can force set a job with whenever customCheck returns false.
GM.Config.adminBypassJobRestrictions    = true
-- Acts/Taunts - Enable/disable Taunts (e.g. act salute)
GM.Config.allowActs                     = false
-- allow people getting their own custom jobs.
GM.Config.allowjobswitch                = true
-- allowrpnames - Allow Players to Set their RP names using the /rpname command.
GM.Config.allowrpnames                  = true
-- allowsprays - Enable/disable the use of sprays on the server.
GM.Config.allowsprays                   = true
-- allowvehicleowning - Enable/disable whether people can own vehicles.
GM.Config.allowvehicleowning            = true
-- allowvnocollide - Enable/disable the ability to no-collide a vehicle (for security).
GM.Config.allowvnocollide               = false
-- alltalk - Enable for global chat, disable for local chat.
GM.Config.alltalk                       = false
-- antimultirun - Disallow people joining your server(s) twice on the same account.
GM.Config.antimultirun                  = true
-- autovehiclelock - Enable/Disable automatic locking of a vehicle when a player exits it.
GM.Config.autovehiclelock               = false
-- babygod - people spawn godded (prevent spawn killing).
GM.Config.babygod                       = true
-- canforcedooropen - whether players can force an unownable door open with lockpick or battering ram or w/e.
GM.Config.canforcedooropen              = true
-- chatsounds - sounds are played when some things are said in chat.
GM.Config.chatsounds                    = true
-- chiefjailpos - Allow the Chief to set the jail positions.
GM.Config.chiefjailpos                  = true
-- cit_propertytax - Enable/disable property tax that is exclusive only for citizens.
GM.Config.cit_propertytax               = false
-- copscanunfreeze - Enable/disable the ability of cops to unfreeze other people's props.
GM.Config.copscanunfreeze               = true
-- copscanunweld - Enable/disable the ability of cops to unweld other people's props.
GM.Config.copscanunweld                 = false
-- cpcanarrestcp - Allow/Disallow CPs to arrest other CPs.
GM.Config.cpcanarrestcp                 = true
-- currencyLeft - The position of the currency symbol. true for left, false for right.
GM.Config.currencyLeft                  = true
-- customjobs - Enable/disable the /job command (personalized job names).
GM.Config.customjobs                    = true
-- customspawns - Enable/disable whether custom spawns should be used.
GM.Config.customspawns                  = true
-- deathblack - Whether or not a player sees black on death.
GM.Config.deathblack                    = false
-- showdeaths - Display kill information in the upper right corner of everyone's screen.
GM.Config.showdeaths                    = true
-- deadtalk - Enable/disable whether people talk and use commands while dead.
GM.Config.deadtalk                      = true
-- deadvoice - Enable/disable whether people talk through the microphone while dead.
GM.Config.deadvoice                     = true
-- deathpov - Enable/disable whether people see their death in first person view.
GM.Config.deathpov                      = false
-- decalcleaner - Enable/Disable clearing every player's decals.
GM.Config.decalcleaner                  = false
-- disallowClientsideScripts - Clientside scripts can be very useful for customizing the HUD or to aid in building. This option bans those scripts.
GM.Config.disallowClientsideScripts     = false
-- doorwarrants - Enable/disable Warrant requirement to enter property.
GM.Config.doorwarrants                  = true
-- dropmoneyondeath - Enable/disable whether people drop money on death.
GM.Config.dropmoneyondeath              = false
-- droppocketarrest - Enable/disable whether people drop the stuff in their pockets when they get arrested.
GM.Config.droppocketarrest              = false
-- droppocketdeath - Enable/disable whether people drop the stuff in their pockets when they die.
GM.Config.droppocketdeath               = true
-- dropweapondeath - Enable/disable whether people drop their current weapon when they die.
GM.Config.dropweapondeath               = false
-- Whether players can drop the weapons they spawn with.
GM.Config.dropspawnedweapons            = false
-- dynamicvoice - Enable/disable whether only people in the same room as you can hear your mic.
GM.Config.dynamicvoice                  = true
-- earthquakes - Enable/disable earthquakes.
GM.Config.earthquakes                   = false
-- enablebuypistol - Turn /buy on of off.
GM.Config.enablebuypistol               = true
-- enforceplayermodel - Whether or not to force players to use their role-defined character models.
GM.Config.enforceplayermodel            = true
-- globalshow - Whether or not to display player info above players' heads in-game.
GM.Config.globalshow                    = false
-- ironshoot - Enable/disable whether people need iron sights to shoot.
GM.Config.ironshoot                     = true
-- showjob - Whether or not to display a player's job above their head in-game.
GM.Config.showjob                       = true
-- letters - Enable/disable letter writing / typing.
GM.Config.letters                       = true
-- license - Enable/disable People need a license to be able to pick up guns.
GM.Config.license                       = false
-- lockdown - Enable/Disable initiating lockdowns for mayors.
GM.Config.lockdown                      = true
-- lockpickfading - Enable/disable the lockpicking of fading doors.
GM.Config.lockpickfading                = true
-- logging - Enable/disable logging everything that happens.
GM.Config.logging                       = true
-- lottery - Enable/disable creating lotteries for mayors.
GM.Config.lottery                       = true
-- showname - Whether or not to display a player's name above their head in-game.
GM.Config.showname                      = true
-- showhealth - Whether or not to display a player's health above their head in-game.
GM.Config.showhealth                    = true
-- needwantedforarrest - Enable/disable Cops can only arrest wanted people.
GM.Config.needwantedforarrest           = false
-- noguns - Enabling this feature bans Guns and Gun Dealers.
GM.Config.noguns                        = false
-- norespawn - Enable/Disable that people don't have to respawn when they change job.
GM.Config.norespawn                     = true
-- keepPickedUp - Enable/Disable keeping picked up weapons when switching jobs.
GM.Config.keepPickedUp                  = false
-- instantjob - Enable/Disable instantly respawning when norespawn is false
GM.Config.instantjob                    = false
-- npcarrest - Enable/disable arresting npc's.
GM.Config.npcarrest                     = true
-- ooc - Whether or not OOC tags are enabled.
GM.Config.ooc                           = true
-- propertytax - Enable/disable property tax.
GM.Config.propertytax                   = false
-- proppaying - Whether or not players should pay for spawning props.
GM.Config.proppaying                    = false
-- propspawning - Enable/disable props spawning. Applies to admins too.
GM.Config.propspawning                  = true
-- removeclassitems - Enable/disable shipments/microwaves/etc. removal when someone changes team.
GM.Config.removeclassitems              = true
-- removeondisconnect - Enable/disable shipments/microwaves/etc. removal when someone disconnects.
GM.Config.removeondisconnect            = true
-- respawninjail - Enable/disable whether people can respawn in jail when they die.
GM.Config.respawninjail                 = true
-- restrictallteams - Enable/disable Players can only be citizen until an admin allows them.
GM.Config.restrictallteams              = false
-- restrictbuypistol - Enabling this feature makes /buy available only to Gun Dealers.
GM.Config.restrictbuypistol             = false
-- restrictdrop - Enable/disable restricting the weapons players can drop. Setting this to true disallows weapons from shipments from being dropped.
GM.Config.restrictdrop                  = false
-- revokeLicenseOnJobChange - Whether licenses are revoked when a player changes jobs.
GM.Config.revokeLicenseOnJobChange      = true
-- shouldResetLaws - Enable/Disable resetting the laws back to the default law set when the mayor changes.
GM.Config.shouldResetLaws               = false
-- strictsuicide - Whether or not players should spawn where they suicided.
GM.Config.strictsuicide                 = false
-- telefromjail - Enable/disable teleporting from jail.
GM.Config.telefromjail                  = true
-- teletojail - Enable/disable teleporting to jail.
GM.Config.teletojail                    = true
-- unlockdoorsonstart - Enable/Disable unlocking all doors on map start.
GM.Config.unlockdoorsonstart            = false
-- voiceradius - Enable/disable local voice chat.
GM.Config.voiceradius                   = true
-- tax - Whether players pay taxes on their wallets.
GM.Config.wallettax                     = false
-- wantedrespawn - Whether players remain wanted on respawn.
GM.Config.wantedrespawn                 = false
-- wantedsuicide - Enable/Disable suiciding while you are wanted by the police.
GM.Config.wantedsuicide                 = false
-- realisticfalldamage - Enable/Disable dynamic fall damage. Setting mp_falldamage to 1 will over-ride this.
GM.Config.realisticfalldamage           = true
-- printeroverheat - Whether the default money printer can overheat on its own.
GM.Config.printeroverheat               = true
-- weaponCheckerHideDefault - Hide default weapons when checking weapons.
GM.Config.weaponCheckerHideDefault      = true
-- weaponCheckerHideNoLicense - Hide weapons that do not require a license.
GM.Config.weaponCheckerHideNoLicense    = false

--[[
Value settings
]]
-- adminnpcs - Whether or not NPCs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminnpcs                     = 3
-- adminsents - Whether or not SENTs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminsents                    = 1
-- adminvehicles - Whether or not vehicles should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminvehicles                 = 3
-- adminweapons - Who can spawn weapons: 0: admins only, 1: supadmins only, 2: no one, 3: everyone
GM.Config.adminweapons                  = 1
-- arrestspeed - Sets the max arrest speed.
GM.Config.arrestspeed                   = 120
-- babygodtime - How long the babygod lasts.
GM.Config.babygodtime                   = 5
-- chatsoundsdelay - How long to wait before letting a player emit a sound from their chat again.
-- Leave this on at least a few seconds to prevent people from spamming sounds. Set to 0 to disable.
GM.Config.chatsoundsdelay               = 5
-- deathfee - the amount of money someone drops when dead.
GM.Config.deathfee                      = 30
-- decaltimer - Sets the time to clear clientside decals (in seconds).
GM.Config.decaltimer                    = 120
-- demotetime - Number of seconds before a player can rejoin a team after demotion from that team.
GM.Config.demotetime                    = 120
-- doorcost - Sets the cost of a door.
GM.Config.doorcost                      = 30
-- EntitySpamTime - Antispam time between spawning entities.
GM.Config.EntitySpamTime                = 2
-- entremovedelay - how long to wait before removing a bought entity after disconnect.
GM.Config.entremovedelay                = 0
-- gunlabweapon - The weapon that the gunlab spawns.
GM.Config.gunlabweapon                  = "weapon_p2282"
-- jailtimer - Sets the jailtimer (in seconds).
GM.Config.jailtimer                     = 120
-- lockdowndelay - The amount of time a mayor must wait before starting the next lockdown.
GM.Config.lockdowndelay                 = 120
-- maxadvertbillboards - The maximum number of /advert billboards a player can place.
GM.Config.maxadvertbillboards           = 3
-- maxCheques - The maximum number of cheques someone can write
GM.Config.maxCheques                    = 5
-- maxdoors - Sets the max amount of doors one can own.
GM.Config.maxdoors                      = 20
-- maxdrugs - Sets max drugs.
GM.Config.maxdrugs                      = 2
-- maxfoods - Sets the max food cartons per Microwave owner.
GM.Config.maxfoods                      = 2
-- maxfooditems - Sets the max amount of food items a player can buy from the F4 menu.
GM.Config.maxfooditems                  = 20
-- maxlawboards - The maximum number of law boards the mayor can place.
GM.Config.maxlawboards                  = 2
-- maxletters - Sets max letters.
GM.Config.maxletters                    = 10
-- maxlotterycost - Maximum payment the mayor can set to join a lottery.
GM.Config.maxlotterycost                = 250
-- maxvehicles - Sets how many vehicles one can buy.
GM.Config.maxvehicles                   = 5
-- microwavefoodcost - Sets the sale price of Microwave Food.
GM.Config.microwavefoodcost             = 30
-- gunlabguncost - Sets the initial price of a gun from a gunlab. Note that the
-- gunlab owner can change this price.
GM.Config.gunlabguncost                 = 200
-- druglabdrugcost - Sets the initial price of drugs from a drugs lab. Note that
-- the drugs lab owner can change this price.
GM.Config.druglabdrugcost               = 100
-- minlotterycost - Minimum payment the mayor can set to join a lottery.
GM.Config.minlotterycost                = 30
-- Money packets will get removed if they don't get picked up after a while. Set to 0 to disable.
GM.Config.moneyRemoveTime               = 600
-- mprintamount - Value of the money printed by the money printer.
GM.Config.mprintamount                  = 250
-- normalsalary - Sets the starting salary for newly joined players.
GM.Config.normalsalary                  = 45
-- npckillpay - Sets the money given for each NPC kill.
GM.Config.npckillpay                    = 10
-- paydelay - Sets how long it takes before people get salary.
GM.Config.paydelay                      = 160
-- pocketitems - Sets the amount of objects the pocket can carry.
GM.Config.pocketitems                   = 10
-- pricecap - The maximum price of items (using /price).
GM.Config.pricecap                      = 500
-- pricemin - The minimum price of items (using /price).
GM.Config.pricemin                      = 50
-- propcost - How much prop spawning should cost (prop paying must be enabled for this to have an effect).
GM.Config.propcost                      = 10
-- quakechance - Chance of an earthquake happening.
GM.Config.quakechance                   = 4000
-- respawntime - Minimum amount of seconds a player has to wait before respawning.
GM.Config.respawntime                   = 1
-- changejobtime - Minimum amount of seconds a player has to wait before changing job.
GM.Config.changejobtime                 = 10
-- runspeed - Sets the max running speed.
GM.Config.runspeed                      = 240
-- runspeed - Sets the max running speed for CP teams.
GM.Config.runspeedcp                    = 255
-- searchtime - Number of seconds for which a search warrant is valid.
GM.Config.searchtime                    = 30
-- ShipmentSpamTime - Antispam time between spawning shipments.
GM.Config.ShipmentSpamTime              = 3
-- shipmenttime - The number of seconds it takes for a shipment to spawn.
GM.Config.shipmentspawntime             = 10
-- startinghealth - the health when you spawn.
GM.Config.startinghealth                = 100
-- startingmoney - your wallet when you join for the first time.
GM.Config.startingmoney                 = 500
-- stunstickdamage - amount of damage the stunstick will do to entities.
-- When between 0 and 1, the damage is relative, where 1 takes the entire health of the entity.
-- When above 1, the damage is absolute
GM.Config.stunstickdamage               = 1000
-- vehiclecost - Sets the cost of a vehicle (To own it).
GM.Config.vehiclecost                   = 40
-- wallettaxmax - Maximum percentage of tax to be paid.
GM.Config.wallettaxmax                  = 5
-- wallettaxmin - Minimum percentage of tax to be paid.
GM.Config.wallettaxmin                  = 1
-- wallettaxtime - Time in seconds between taxing players. Requires server restart.
GM.Config.wallettaxtime                 = 600
-- wantedtime - Number of seconds for which a player is wanted for.
GM.Config.wantedtime                    = 120
-- walkspeed - Sets the max walking speed.
GM.Config.walkspeed                     = 160
-- falldamagedamper - The damper on realistic fall damage. Default is 15. Decrease this for more damage.
GM.Config.falldamagedamper              = 15
-- falldamageamount - The base damage taken from falling for static fall damage. Default is 10.
GM.Config.falldamageamount              = 10
-- printeroverheatchance - The likelyhood of a printer overheating. The higher this number, the less likely (minimum 3, default 22).
GM.Config.printeroverheatchance         = 22
-- printerreward - Reward for destroying a money printer.
GM.Config.printerreward                 = 950

--[[---------------------------------------------------------------------------
Chat distance settings
Distance is in source units (similar to inches)
---------------------------------------------------------------------------]]
GM.Config.talkDistance    = 250
GM.Config.whisperDistance = 90
GM.Config.yellDistance    = 550
GM.Config.meDistance      = 250
GM.Config.voiceDistance   = 550

--[[---------------------------------------------------------------------------
Other settings
---------------------------------------------------------------------------]]

-- The classname of money packets. Use this to create your own money entity!
-- Note: the money packet must support the "Setamount" method (or the amount DTVar).
GM.Config.MoneyClass = "spawned_money"
-- In case you do wish to keep the default money, but change the model, this option is the way to go:
GM.Config.moneyModel = "models/props/cs_assault/money.mdl"
-- You can set your own, custom sound to be played for all players whenever a lockdown is initiated.
-- Note: Remember to include the folder where the sound file is located.
GM.Config.lockdownsound = "npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav"

-- The skin DarkRP uses. Set to "default" to use the GMod default derma theme.
GM.Config.DarkRPSkin = "DarkRP"
GM.Config.currency = "$"
GM.Config.currencyThousandSeparator = ","
GM.Config.chatCommandPrefix = "/"
GM.Config.F1MenuHelpPage = "https://darkrp.miraheze.org/wiki/Main_Page"
GM.Config.F1MenuHelpPageTitle = "DarkRP Wiki"

-- The sound that plays when you get a DarkRP notification
GM.Config.notificationSound = "buttons/lightswitch2.wav"

-- Put Steam ID's and ranks in this list, and the players will have that rank when they join.
GM.Config.DefaultPlayerGroups = {
    ["STEAM_0:0:00000000"] = "superadmin",
    ["STEAM_0:0:11111111"] = "admin",
}

-- Custom modules in this addon that are disabled.
GM.Config.DisabledCustomModules = {
    ["hudreplacement"] = false,
    ["extraf4tab"] = false,
}

-- The list of weapons that players are not allowed to drop. Items set to true are not allowed to be dropped.
GM.Config.DisallowDrop = {
    ["arrest_stick"] = true,
    ["door_ram"] = true,
    ["gmod_camera"] = true,
    ["gmod_tool"] = true,
    ["keys"] = true,
    ["lockpick"] = true,
    ["med_kit"] = true,
    ["pocket"] = true,
    ["stunstick"] = true,
    ["unarrest_stick"] = true,
    ["weapon_keypadchecker"] = true,
    ["weapon_physcannon"] = true,
    ["weapon_physgun"] = true,
    ["weaponchecker"] = true,
}

-- The list of weapons people spawn with.
GM.Config.DefaultWeapons = {
    "keys",
    "weapon_physcannon",
    "gmod_camera",
    "gmod_tool",
    "pocket",
    "weapon_physgun",
}

-- Override categories.
-- NOTE: categories are to be set in the "category" field of the custom jobs/shipments/entities/ammo/pistols/vehicles.
-- Use this only to override the categories of _default_ things.
-- This will NOT work for your own custom stuff.
-- Make sure the category is created in the darkrp_customthings/categories.lua, otherwise it won't work!
GM.Config.CategoryOverride = {
    jobs = {
        ["Citizen"]                             = "Citizens",
        ["Hobo"]                                = "Citizens",
        ["Gun Dealer"]                          = "Citizens",
        ["Medic"]                               = "Citizens",
        ["Civil Protection"]                    = "Civil Protection",
        ["Gangster"]                            = "Gangsters",
        ["Mob boss"]                            = "Gangsters",
        ["Civil Protection Chief"]              = "Civil Protection",
        ["Mayor"]                               = "Civil Protection",
    },
    entities = {
        ["Drug lab"]                            = "Other",
        ["Money printer"]                       = "Other",
        ["Gun lab"]                             = "Other",

    },
    shipments = {
        ["AK47"]                                = "Rifles",
        ["MP5"]                                 = "Rifles",
        ["M4"]                                  = "Rifles",
        ["Mac 10"]                              = "Other",
        ["Pump shotgun"]                        = "Shotguns",
        ["Sniper rifle"]                        = "Snipers",

    },
    weapons = {
        ["Desert eagle"]                        = "Pistols",
        ["Fiveseven"]                           = "Pistols",
        ["Glock"]                               = "Pistols",
        ["P228"]                                = "Pistols",
    },
    vehicles = {}, -- There are no default vehicles.
    ammo = {
        ["Pistol ammo"]                         = "Other",
        ["Shotgun ammo"]                        = "Other",
        ["Rifle ammo"]                          = "Other",
    },
}

-- The list of weapons admins spawn with, in addition to the default weapons, a job's weapons and GM.Config.AdminsCopWeapons.
GM.Config.AdminWeapons = {
    "weapon_keypadchecker",
}

-- These are the default laws, they're unchangeable in-game.
GM.Config.DefaultLaws = {
    "Do not attack other citizens except in self-defence.",
    "Do not steal or break into people's homes.",
    "Money printers/drugs are illegal.",
}

GM.Config.PocketBlacklist = {
    ["fadmin_jail"] = true,
    ["meteor"] = true,
    ["door"] = true,
    ["func_"] = true,
    ["player"] = true,
    ["beam"] = true,
    ["worldspawn"] = true,
    ["env_"] = true,
    ["path_"] = true,
    ["prop_physics"] = true,
    ["money_printer"] = true,
    ["gunlab"] = true,
    ["prop_dynamic"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
    ["keypad_wire"] = true,
    ["gmod_button"] = true,
    ["gmod_rtcameraprop"] = true,
    ["gmod_cameraprop"] = true,
    ["gmod_dynamite"] = true,
    ["gmod_thruster"] = true,
    ["gmod_light"] = true,
    ["gmod_lamp"] = true,
    ["gmod_emitter"] = true,
}

-- These weapons are classed as 'legal' in the weapon checker and are not stripped when confiscating weapons.
-- This setting is used IN ADDITION to GM.Config.weaponCheckerHideDefault and GM.Config.weaponCheckerHideNoLicense.
-- You should use the former if you want to class the default weapons (GM.Config.DefaultWeapons and, if admin, GM.Config.AdminWeapons) and a player's job weapons as legal.
-- The latter takes GM.NoLicense weapons as legal (see licenseweapons.lua).
-- The format of this config is similar to GM.Config.DisallowDrop.
GM.Config.noStripWeapons = {

}

-- The entities listed here will not be removed when a player changes their job.
-- This only applies when removeclassitems is set to true.
-- Note: entities will only be removed when the player changes to a job that is not allowed to have the entity.
GM.Config.preventClassItemRemoval = {
    ["gunlab"] = false,
    ["microwave"] = false,
    ["spawned_shipment"] = false,
}

-- Properties set to true are allowed to be used. Values set to false or are missing from this list are blocked.
GM.Config.allowedProperties = {
    remover = true,
    ignite = false,
    extinguish = true,
    keepupright = true,
    gravity = true,
    collision = true,
    skin = true,
    bodygroups = true,
}

--[[---------------------------------------------------------------------------
F4 menu
---------------------------------------------------------------------------]]
-- hide the items that you can't buy and the jobs you can't get (instead of graying them out).
-- this option hides items when you don't have enough money, when the maximum is reached for a job or any other reason.
GM.Config.hideNonBuyable = false

-- Hide only the items that you have the wrong job for (or for which the customCheck says no).
-- When you set this option to true and hideNonBuyable to false, you WILL see e.g. items that are too expensive for you to buy.
-- but you won't see gundealer shipments when you have the citizen job.
GM.Config.hideTeamUnbuyable = true

--[[---------------------------------------------------------------------------
AFK module
---------------------------------------------------------------------------]]
-- The time of inactivity before being demoted.
GM.Config.afkdemotetime = 600
-- Prevent people from spamming AFK.
GM.Config.AFKDelay = 300

--[[---------------------------------------------------------------------------
Hitmenu module
---------------------------------------------------------------------------]]
-- The minimum price for a hit.
GM.Config.minHitPrice = 200
-- The maximum price for a hit.
GM.Config.maxHitPrice = 50000
-- The minimum distance between a hitman and his customer when they make the deal.
GM.Config.minHitDistance = 150
-- The text that tells the player he can press use on the hitman to request a hit.
GM.Config.hudText = "I am a hitman.\nPress E on me to request a hit!"
-- The text above a hitman when he's got a hit.
GM.Config.hitmanText = "Hit\naccepted!"
-- The cooldown time for a hit target (so they aren't spam killed).
GM.Config.hitTargetCooldown = 120
-- How long a customer has to wait to be able to buy another hit (from the moment the hit is accepted).
GM.Config.hitCustomerCooldown = 240

--[[---------------------------------------------------------------------------
Hungermod module
---------------------------------------------------------------------------]]
-- hungerspeed <Amount> - Set the rate at which players will become hungry (2 is the default).
GM.Config.hungerspeed = 2
-- starverate <Amount> - How much health that is taken away every second the player is starving  (3 is the default).
GM.Config.starverate = 3

--PATH gamemodes/starwarsrp/gamemode/modules/hungermod/sh_interface.lua:
DarkRP.createFood = DarkRP.stub{
    name = "createFood",
    description = "Create food for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the food.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the food.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddFoodItem = DarkRP.createFood

DarkRP.removeFoodItem = DarkRP.stub{
    name = "removeFoodItem",
    description = "Remove a food item from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "onFoodItemRemoved",
    description = "Called when a food item is removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.PLAYER.isCook = DarkRP.stub{
    name = "isCook",
    description = "Whether this player is a cook. This function is only available if hungermod is enabled.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a cook.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.getFoodItems = DarkRP.stub{
    name = "getFoodItems",
    description = "Get all food items.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table with food items.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/starwarsrp/gamemode/modules/hitmenu/cl_interface.lua:
DarkRP.openHitMenu = DarkRP.stub{
    name = "openHitMenu",
    description = "Open the menu that requests a hit.",
    parameters = {
        {
            name = "hitman",
            description = "The hitman to request the hit to.",
            type = "Player",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.PLAYER.drawHitInfo = DarkRP.stub{
    name = "drawHitInfo",
    description = "Start drawing the hit information above a hitman.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.stopHitInfo = DarkRP.stub{
    name = "stopHitInfo",
    description = "Stop drawing the hit information above a hitman.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP.PLAYER
}

--PATH gamemodes/starwarsrp/gamemode/modules/chat/sh_interface.lua:
DarkRP.declareChatCommand = DarkRP.stub{
    name = "declareChatCommand",
    description = "Declare a chat command (describe it)",
    parameters = {
        {
            name = "table",
            description = "The description of the chat command. Has to contain a string: command, string: description, number: delay, optional function: condition",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeChatCommand = DarkRP.stub{
    name = "removeChatCommand",
    description = "Remove a chat command",
    parameters = {
        {
            name = "command",
            description = "The chat command to remove",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.chatCommandAlias = DarkRP.stub{
    name = "chatCommandAlias",
    description = "Create an alias for a chat command",
    parameters = {
        {
            name = "command",
            description = "An already existing chat command.",
            type = "string",
            optional = false
        },
        {
            name = "alias",
            description = "One or more aliases for the chat command.",
            type = "vararg",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getChatCommand = DarkRP.stub{
    name = "getChatCommand",
    description = "Get the information on a chat command.",
    parameters = {
        {
            name = "command",
            description = "The chat command",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "chatTable",
            description = "A table containing the information of the chat command.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getChatCommands = DarkRP.stub{
    name = "getChatCommands",
    description = "Get every chat command.",
    parameters = {

    },
    returns = {
        {
            name = "commands",
            description = "A table containing every command. Table indices are the command strings.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getSortedChatCommands = DarkRP.stub{
    name = "getSortedChatCommands",
    description = "Get every chat command, sorted by their name.",
    parameters = {

    },
    returns = {
        {
            name = "commands",
            description = "A table containing every command.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getIncompleteChatCommands = DarkRP.stub{
    name = "getIncompleteChatCommands",
    description = "chat commands that have been defined, but not declared. Information about these chat commands is missing.",
    parameters = {
    },
    returns = {
        {
            name = "commands",
            description = "A table containing the undeclared chat commands.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_interface.lua:
DarkRP.addChatReceiver = DarkRP.stub{
    name = "addChatReceiver",
    description = "Add a chat command with specific receivers",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        },
        {
            name = "text",
            description = "The text that shows up when it says \"Some people can hear you X\"",
            type = "string",
            optional = false
        },
        {
            name = "hearFunc",
            description = "A function(ply, splitText) that decides whether this player can or cannot hear you.",
            type = "function",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

DarkRP.removeChatReceiver = DarkRP.stub{
    name = "removeChatReceiver",
    description = "Remove a chat command receiver",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "chatHideRecipient",
    description = "Hide a receipent from who can hear/see your text GUI.",
    parameters = {
        {
            name = "ply",
            description = "The player who spoke.",
            type = "Player"
        }
    },
    returns = {

    }
}

--PATH gamemodes/starwarsrp/gamemode/libraries/disjointset.lua:
/*---------------------------------------------------------------------------
Disjoint-set forest implementation
Inspired by the book Introduction To Algorithms (third edition)

by FPtje Atheos

Running time per operation (Union/FindSet): O(a(n)) where a is the inverse of the Ackermann function.
---------------------------------------------------------------------------*/

local ipairs = ipairs
local setmetatable = setmetatable
local string = string
local table = table
local tostring = tostring

module("disjoint")

local metatable

-- Make a singleton set. Parent parameter is optional, must be a disjoint-set as well.
function MakeSet(x, parent)
    local set  = {}
    set.value  = x
    set.rank   = 0
    set.parent = parent or set

    setmetatable(set, metatable)

    return set
end

local function Link(x, y)
    if x == y then return x end

    -- Union by rank
    if x.rank > y.rank then
        y.parent = x
        return x
    end

    x.parent = y

    if x.rank == y.rank then
        y.rank = y.rank + 1
    end

    return y
end

-- Apply the union operation between two sets.
function Union(x, y)
    return Link(FindSet(x), FindSet(y))
end

function FindSet(x)
    local parent = x
    local listParents

    -- Go up the tree to find the parent
    while parent ~= parent.parent do
        parent = parent.parent

        listParents = listParents or {}
        table.insert(listParents, parent)
    end

    -- Path compression, update all parents to refer to the top parent
    if listParents then
        for _, v in ipairs(listParents) do
            v.parent = parent
        end
    end

    return parent
end

function Disconnect(x)
    x.parent = x

    return x
end


metatable = {
    __tostring = function(self)
        return string.format("Disjoint-Set [value: %s][Rank: %s][Parent: %s]", tostring(self.value), self.rank, tostring(self.parent.value))
    end,
    __metatable = true, -- restrict access to metatable
    __add = Union
}

--PATH addons/!jobs/lua/darkrp_config/licenseweapons.lua:
--[[---------------------------------------------------------------------------
License weapons
Add weapons that do NOT require a special license here
ALL other weapons will require a license

Note: this only works if the license setting is enabled
---------------------------------------------------------------------------]]
GM.NoLicense["weapon_physcannon"] = true
GM.NoLicense["weapon_physgun"]    = true
GM.NoLicense["weapon_bugbait"]    = true
GM.NoLicense["gmod_tool"]         = true
GM.NoLicense["gmod_camera"]       = true

--PATH gamemodes/starwarsrp/gamemode/modules/workarounds/sh_workarounds.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_model.lua:
--[[-------------------------------------------------------------------------
The model describes the data that the drives the UI.
Loosely based on the Elm architecture.
---------------------------------------------------------------------------]]

local model = {
    -- The tip jar entity
    tipjar = nil,

    -- Whether the LocalPlayer is the owner of this tipjar
    isOwner = false,

    -- Whether the frame is visible
    frameVisible = false,

    -- The Derma frame object
    frame = nil,

    -- The amount the player is putting in the tip jar
    amount = 0,

    -- The last amount of money the player actually put in the tip jar
    lastTipAmount = 0,

    -- Action: when an active donation changes. The active donations
    -- themselves are fetched from the tipjar, which keeps track of the proper
    -- state for it.
    activeDonationUpdate = nil,

    -- Action: when someone donated. The list of donators is kept track of by
    -- the tipjar.
    donatedUpdate = nil,
}

local updaters = {}

DarkRP.tipJarUIModel = {}

--[[-------------------------------------------------------------------------
Update the model.
Automatically calls the registered update hook functions
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.updateModel(path, value, ...)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl = updTbl and updTbl[path[i]]
    end

    local oldValue = mdlTbl[key]
    mdlTbl[key] = value

    for _, updFunc in ipairs(updTbl and updTbl[key] or {}) do
        updFunc(value, oldValue, ...)

        -- the updFunc changed this value, break off
        if mdlTbl[key] ~= value then break end
    end
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.getModelValue(path)
    path = istable(path) and path or {path}

    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
    end

    return mdlTbl[key]
end

--[[-------------------------------------------------------------------------
Registers a hook that gets triggered when a certain part of the model is
updated
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.onModelUpdate(path, func)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl[path[i]] = updTbl[path[i]] or {}
        updTbl = updTbl[path[i]]
    end

    updTbl[key] = updTbl[key] or {}

    table.insert(updTbl[key], func)

    -- Call update with the initial value
    if mdlTbl[key] ~= nil then
        func(mdlTbl[key], mdlTbl[key])
    end
end

--[[-------------------------------------------------------------------------
Default listeners
---------------------------------------------------------------------------]]
local updateModel, _getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate

onModelUpdate("amount", function(new, _)
    local localply = LocalPlayer()
    if not IsValid(localply) then return end

    local ownMoney = localply:getDarkRPVar("money") or 0

    if new < 0 or new % 1 ~= 0 or new > ownMoney then
        local amount = math.abs(math.floor(new))
        amount = math.min(amount, ownMoney)
        updateModel("amount", amount)
    end
end)

--PATH gamemodes/starwarsrp/gamemode/modules/positions/sh_commands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/positions/sh_commands.lua:
local plyMeta = FindMetaTable("Player")

DarkRP.declareChatCommand{
    command = "setspawn",
    description = "Reset the spawn position for some job and place a new one at your position (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "addspawn",
    description = "Add a spawn position for some job (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "removespawn",
    description = "Remove a spawn position for some job (use the command name of the job as argument)",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "jailpos",
    description = "Reset jail positions and create a new one at your position.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

DarkRP.declareChatCommand{
    command = "setjailpos",
    description = "Reset jail positions and create a new one at your position.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

DarkRP.declareChatCommand{
    command = "addjailpos",
    description = "Add a jail position where you're standing.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.isChief, fn.Compose{fn.Curry(fn.GetValue, 2)("chiefjailpos"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}}
}

--PATH gamemodes/starwarsrp/gamemode/modules/police/sh_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_money.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_english.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hobo/cl_hobo.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_chat.lua:
--[[---------------------------------------------------------------------------
Gamemode function
---------------------------------------------------------------------------]]
function GM:OnPlayerChat()
end

--[[---------------------------------------------------------------------------
Add a message to chat
---------------------------------------------------------------------------]]
local function AddToChat(bits)
    local col1 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local prefixText = net.ReadString()
    local ply = net.ReadEntity()
    ply = IsValid(ply) and ply or LocalPlayer()

    if not IsValid(ply) then return end

    if prefixText == "" or not prefixText then
        prefixText = ply:Nick()
        prefixText = prefixText ~= "" and prefixText or ply:SteamName()
    end

    local col2 = Color(net.ReadUInt(8), net.ReadUInt(8), net.ReadUInt(8))

    local text = net.ReadString()
    local shouldShow
    if text and text ~= "" then
        if IsValid(ply) then
            shouldShow = hook.Call("OnPlayerChat", GAMEMODE, ply, text, false, not ply:Alive(), prefixText, col1, col2)
        end

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText, col2, ": " .. text)
        end
    else
        shouldShow = hook.Call("ChatText", GAMEMODE, "0", prefixText, prefixText, "darkrp")

        if shouldShow ~= true then
            chat.AddNonParsedText(col1, prefixText)
        end
    end
    chat.PlaySound()
end
net.Receive("DarkRP_Chat", AddToChat)

--[[---------------------------------------------------------------------------
Credits

Please only ADD to the credits.
---------------------------------------------------------------------------]]
local creds =
[[

LightRP was created by Rick darkalonio. LightRP was sandbox with some added RP elements.
LightRP was released at the end of January 2007

DarkRP was created as a spoof of LightRP by Rickster, somewhere during the summer of 2007.
Note: There was a DarkRP in 2006, but that was an entirely different gamemode.

Rickster went to serve his country and went to Afghanistan. During that time, the following people updated DarkRP:
Picwizdan
Sibre
[GNC] Matt
PhilXYZ
Chromebolt A.K.A. Unib5 (STEAM_0:1:19045957)

In 2008, Unib5 was administrator on a DarkRP server called EuroRP, owned by Jiggu. FPtje frequently joined this server to prop kill en masse. While Jiggu loved watching the chaos unfold, Unib5 hated it and banned FPtje on sight. Since Jiggu kept unbanning FPtje, Unib5 felt powerless. In an attempt to stop FPtje, Unib5 put FPtje's favourite prop killing props (the locker and the sawblade) in the default blacklist of DarkRP in an update. This in turn enraged FPtje, as he swore to make an update in secret that would suddenly pop up and overthrow the established version. As a result, DarkRP 2.3.1 was released in December 2008. After a bit of a fight, FPtje became the official updater of DarkRP.

Current developer:
    Falco A.K.A. FPtje Atheos (STEAM_0:0:8944068)

People who have contributed (ordered by commits, with at least two commits)
    Bo98
    Drakehawke (STEAM_0:0:22342869) (64 commits on old SVN)
    FiG-Scorn
    Noiwex
    KoZ
    Eusion (STEAM_0:0:20450406) (3 commits on old SVN)
    Gangleider
    MattWalton12
    TypicalRookie
]]

local function credits(um)
    chat.AddNonParsedText(Color(255, 0, 0, 255), "[", Color(50,50,50,255), GAMEMODE.Name, Color(255, 0, 0, 255), "] ", color_white, DarkRP.getPhrase("credits_see_console"))

    MsgC(Color(255, 0, 0, 255), DarkRP.getPhrase("credits_for", GAMEMODE.Name), color_white, creds)
end
usermessage.Hook("DarkRP_Credits", credits)

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_util.lua:
--[[---------------------------------------------------------------------------
Utility functions
---------------------------------------------------------------------------]]

local vector = FindMetaTable("Vector")
local meta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Decides whether the vector could be seen by the player if they were to look at it
---------------------------------------------------------------------------]]
function vector:isInSight(filter, ply)
    ply = ply or LocalPlayer()
    local trace = {}
    trace.start = ply:EyePos()
    trace.endpos = self
    trace.filter = filter
    trace.mask = -1
    local TheTrace = util.TraceLine(trace)

    return not TheTrace.Hit, TheTrace.HitPos
end

--[[---------------------------------------------------------------------------
Turn a money amount into a pretty string
---------------------------------------------------------------------------]]
local function attachCurrency(str)
    local config = GAMEMODE.Config
    return config.currencyLeft and config.currency .. str or str .. config.currency
end

function DarkRP.formatMoney(n)
    if not n then return attachCurrency("0") end

    if n >= 1e14 then return attachCurrency(tostring(n)) end
    if n <= -1e14 then return "-" .. attachCurrency(tostring(math.abs(n))) end

    local config = GAMEMODE.Config

    local negative = n < 0

    n = tostring(math.abs(n))

    local dp = string.find(n, ".", 1, true) or #n + 1

    for i = dp - 4, 1, -3 do
        n = n:sub(1, i) .. config.currencyThousandSeparator .. n:sub(i + 1)
    end

    -- Make sure the amount is padded with zeroes
    if n[#n - 1] == "." then
        n = n .. "0"
    end

    return (negative and "-" or "") .. attachCurrency(n)
end

--[[---------------------------------------------------------------------------
Find a player based on given information

Note that there is a searching priority:
  * UserID
  * SteamID64
  * SteamID
  * Nick
  * SteamName

Note also that there are _separate_ loops. This is to make sure the function
gives the same result, regardless of the order in which players are iterated
over.
---------------------------------------------------------------------------]]
function DarkRP.findPlayer(info)
    if not info or info == "" then return nil end
    local pls = player.GetAll()

    local count = #pls
    local numberInfo = tonumber(info)

    -- First check if the input matches a player by UserID or SteamID64. This is
    -- only necessary if the input can be parsed as a number.
    if numberInfo then
        for k = 1, count do
            local v = pls[k]

            if numberInfo == v:UserID() then
                return v
            end
        end

        for k = 1, count do
            local v = pls[k]

            if info == v:SteamID64() then
                return v
            end
        end
    end

    local lowerInfo = string.lower(tostring(info))
    if string.StartsWith(lowerInfo, "steam_") then
        for k = 1, count do
            local v = pls[k]

            if info == v:SteamID() then
                return v
            end
        end
    end

    for k = 1, count do
        local v = pls[k]

        if string.find(string.lower(v:Nick()), lowerInfo, 1, true) ~= nil then
            return v
        end
    end

    for k = 1, count do
        local v = pls[k]

        if string.find(string.lower(v:SteamName()), lowerInfo, 1, true) ~= nil then
            return v
        end
    end

    return nil
end

--[[---------------------------------------------------------------------------
Find multiple players based on a string criterium
Taken from FAdmin]]
---------------------------------------------------------------------------*/
function DarkRP.findPlayers(info)
    if not info then return nil end
    local pls = player.GetAll()
    local found = {}
    local players

    if string.lower(info) == "*" or string.lower(info) == "<all>" then return pls end

    local InfoPlayers = {}
    for A in string.gmatch(info .. ";", "([a-zA-Z0-9:_.]*)[;(,%s)%c]") do
        if A ~= "" then
            table.insert(InfoPlayers, A)
        end
    end

    for _, PlayerInfo in ipairs(InfoPlayers) do
        -- Playerinfo is always to be treated as UserID when it's a number
        -- otherwise people with numbers in their names could get confused with UserID's of other players
        if tonumber(PlayerInfo) then
            local foundPlayer = Player(PlayerInfo)
            if IsValid(foundPlayer) and not found[foundPlayer] then
                found[foundPlayer] = true
                players = players or {}
                table.insert(players, foundPlayer)
            end
            continue
        end

        local stringPlayerInfo = string.lower(PlayerInfo)
        for _, v in ipairs(pls) do
            -- Prevent duplicates
            if found[v] then continue end
            local steamId = v:SteamID()

            -- Find by Steam ID
            if (PlayerInfo == steamId or steamId == "UNKNOWN") or
            -- Find by Partial Nick
            string.find(string.lower(v:Nick()), stringPlayerInfo, 1, true) ~= nil or
            -- Find by steam name
            (v.SteamName and string.find(string.lower(v:SteamName()), stringPlayerInfo, 1, true) ~= nil) then
                found[v] = true
                players = players or {}
                table.insert(players, v)
            end
        end
    end

    return players
end

function meta:getEyeSightHitEntity(searchDistance, hitDistance, filter)
    searchDistance = searchDistance or 100
    hitDistance = (hitDistance or 15) * (hitDistance or 15)

    filter = filter or function(p) return p:IsPlayer() and p ~= self end

    self:LagCompensation(true)

    local shootPos = self:GetShootPos()
    local entities = ents.FindInSphere(shootPos, searchDistance)
    local aimvec = self:GetAimVector()

    local smallestDistance = math.huge
    local foundEnt

    for _, ent in pairs(entities) do
        if not IsValid(ent) or filter(ent) == false then continue end

        local center = ent:GetPos()

        -- project the center vector on the aim vector
        local projected = shootPos + (center - shootPos):Dot(aimvec) * aimvec

        if aimvec:Dot((projected - shootPos):GetNormalized()) < 0 then continue end

        -- the point on the model that has the smallest distance to your line of sight
        local nearestPoint = ent:NearestPoint(projected)
        local distance = nearestPoint:DistToSqr(projected)

        if distance < smallestDistance then
            local trace = {
                start = self:GetShootPos(),
                endpos = nearestPoint,
                filter = {self, ent}
            }
            local traceLine = util.TraceLine(trace)
            if traceLine.Hit then continue end

            smallestDistance = distance
            foundEnt = ent
        end
    end

    self:LagCompensation(false)

    if smallestDistance < hitDistance then
        return foundEnt, math.sqrt(smallestDistance)
    end

    return nil
end

--[[---------------------------------------------------------------------------
Print the currently available vehicles
---------------------------------------------------------------------------]]
local function GetAvailableVehicles(ply)
    if SERVER and IsValid(ply) and not ply:IsAdmin() then return end
    local print = SERVER and ServerLog or Msg

    print(DarkRP.getPhrase("rp_getvehicles") .. "\n")
    for k in pairs(DarkRP.getAvailableVehicles()) do
        print("\"" .. k .. "\"" .. "\n")
    end
end
if SERVER then
    concommand.Add("rp_getvehicles_sv", GetAvailableVehicles)
else
    concommand.Add("rp_getvehicles", GetAvailableVehicles)
end

--[[---------------------------------------------------------------------------
Whether a player has a DarkRP privilege
---------------------------------------------------------------------------]]
function meta:hasDarkRPPrivilege(priv)
    if FAdmin then
        return FAdmin.Access.PlayerHasPrivilege(self, priv)
    end
    return self:IsAdmin()
end

--[[---------------------------------------------------------------------------
Convenience function to return the players sorted by name
---------------------------------------------------------------------------]]
function DarkRP.nickSortedPlayers()
    local plys = player.GetAll()
    table.sort(plys, function(a,b) return a:Nick() < b:Nick() end)
    return plys
end

--[[---------------------------------------------------------------------------
Convert a string to a table of arguments
---------------------------------------------------------------------------]]
local bitlshift, stringgmatch, stringsub, tableinsert = bit.lshift, string.gmatch, string.sub, table.insert
function DarkRP.explodeArg(arg)
    local args = {}

    local from, to, diff = 1, 0, 0
    local inQuotes, wasQuotes = false, false

    for c in stringgmatch(arg, '.') do
        to = to + 1

        if c == '"' then
            inQuotes = not inQuotes
            wasQuotes = true

            continue
        end

        if c == ' ' and not inQuotes then
            diff = wasQuotes and 1 or 0
            wasQuotes = false
            tableinsert(args, stringsub(arg, from + diff, to - 1 - diff))
            from = to + 1
        end
    end
    diff = wasQuotes and 1 or 0

    if from ~= to + 1 then tableinsert(args, stringsub(arg, from + diff, to + 1 - bitlshift(diff, 1))) end

    return args
end

--[[---------------------------------------------------------------------------
Initialize Physics, throw an error on failure
---------------------------------------------------------------------------]]
function DarkRP.ValidatedPhysicsInit(ent, solidType, hint)
    solidType = solidType or SOLID_VPHYSICS

    if ent:PhysicsInit(solidType) then return true end

    local class = ent:GetClass()

    if solidType == SOLID_BSP then
        DarkRP.errorNoHalt(string.format("%s has no physics and will be motionless", class), 2, {
            "Is this a brush model? SOLID_BSP physics cannot initialize on entities that don't have brush models",
            "The physics limit may have been hit",
            hint
        })

        return false
    end

    if solidType == SOLID_VPHYSICS then
        local mdl = ent:GetModel()

        if not mdl or mdl == "" then
            DarkRP.errorNoHalt(string.format("Cannot init physics on entity \"%s\" because it has no model", class), 2, {hint})
            return false
        end

        mdl = string.lower(mdl)

        if util.IsValidProp(mdl) then
            -- Has physics, we must have hit the limit
            DarkRP.errorNoHalt(string.format("physics limit hit - %s will be motionless", class), 2, {hint})

            return false
        end

        if not file.Exists(mdl, "GAME") then
            DarkRP.errorNoHalt(string.format("%s has missing model \"%s\" and will be invisible and motionless", class, mdl), 2, {
                "Is the model path correct?",
                "Is the model from an addon that is not installed?",
                "Is the model from a game that isn't (properly) mounted? E.g. Counter Strike: Source",
                hint
            })

            return false
        end

        DarkRP.errorNoHalt(string.format("%s has model \"%s\" with no physics and will be motionless", class, mdl), 2, {
            "Does this model have an associated physics model (modelname.phy)?",
            "Is this model supposed to have physics? Many models, like effects and view models aren't made to have physics",
            hint
        })

        return false
    end

    DarkRP.errorNoHalt(string.format("Unable to initilize physics on entity \"%s\"", class, {hint}), 2)

    return false
end

--[[---------------------------------------------------------------------------
Like tonumber, but makes sure it's an integer
---------------------------------------------------------------------------]]
function DarkRP.toInt(value)
    value = tonumber(value)
    return value and math.floor(value)
end

--[[-------------------------------------------------------------------------
Check the database for integrity errors. Use in cases when stuff doesn't load
on restart, or you get corruption errors.
---------------------------------------------------------------------------]]
if SERVER then util.AddNetworkString("DarkRP_databaseCheckMessage") end
if CLIENT then net.Receive("DarkRP_databaseCheckMessage", fc{print, net.ReadString}) end

local function checkDatabase(ply)
    local dbFile = SERVER and "sv.db" or "cl.db"
    local display = (CLIENT or ply == game.GetWorld()) and print or function(msg)
            net.Start("DarkRP_databaseCheckMessage")
            net.WriteString(msg)
            net.Send(ply)
        end

    if SERVER and ply ~= game.GetWorld() and not ply:IsSuperAdmin() then
        display("You must be superadmin")
        return
    end

    if MySQLite and MySQLite.isMySQL() then
        display(string.format([[WARNING: DarkRP is using MySQL. This only
    checks the local SQLite database stored in the %s file in the
    garrysmod/ folder. The check will continue.]], dbFile))
    end

    local check = sql.QueryValue("PRAGMA INTEGRITY_CHECK")
    if check == false then
        display([[The query to check the database failed. Shit's surely
    fucked, but the cause is unknown.]])
        return
    end

    if check == "ok" then
        display(string.format("Your %s database file is good.", dbFile))
        return
    end

    display(string.format([[There are errors in your %s database file. It's corrupt!

    This can cause the following problems:
    - Data not loading, think of blocked models, doors, players' money and RP names
    - Settings resetting to their default values
    - Lua errors on startup

    The cause of the problem is that the %s file in your garrysmod/ folder on
    %s is corrupt. How this came to be is unknown, but here's what you can do to solve it:

    - Delete %s, and run a file integrity check. Warning: You will lose ALL data stored in it!
    - Take the file and try to repair it. This is sadly something that requires some technical knowledge,
      and may not always succeed.

    The specific error, by the way, is as follows:
    %s
    ]], dbFile, dbFile, SERVER and "the server" or "your own computer", dbFile, check))

end
concommand.Add("darkrp_check_db_" .. (SERVER and "sv" or "cl"), checkDatabase)

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_entityvars.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_entityvars.lua:
DarkRP.RegisteredDarkRPVarsMaxId = DarkRP.RegisteredDarkRPVarsMaxId or 0
DarkRP.RegisteredDarkRPVars = DarkRP.RegisteredDarkRPVars or {}
DarkRP.RegisteredDarkRPVarsById = DarkRP.RegisteredDarkRPVarsById or {}

-- the amount of bits assigned to the value that determines which DarkRPVar we're sending/receiving
local DARKRP_ID_BITS = 8
local UNKNOWN_DARKRPVAR = 255 -- Should be equal to 2^DARKRP_ID_BITS - 1
DarkRP.DARKRP_ID_BITS = DARKRP_ID_BITS

function DarkRP.registerDarkRPVar(name, writeFn, readFn)
    -- After a reload, only update the write and read function
    if DarkRP.RegisteredDarkRPVars[name] then
        DarkRP.RegisteredDarkRPVars[name].writeFn = writeFn
        DarkRP.RegisteredDarkRPVars[name].readFn = readFn
        return
    end

    DarkRP.RegisteredDarkRPVarsMaxId = DarkRP.RegisteredDarkRPVarsMaxId + 1

    -- UNKNOWN_DARKRPVAR is reserved for unknown values
    if DarkRP.RegisteredDarkRPVarsMaxId >= UNKNOWN_DARKRPVAR then DarkRP.error(string.format("Too many DarkRPVar registrations! DarkRPVar '%s' triggered this error", name), 2) end

    DarkRP.RegisteredDarkRPVars[name] = {id = DarkRP.RegisteredDarkRPVarsMaxId, name = name, writeFn = writeFn, readFn = readFn}
    DarkRP.RegisteredDarkRPVarsById[DarkRP.RegisteredDarkRPVarsMaxId] = DarkRP.RegisteredDarkRPVars[name]
end

-- Unknown values have unknown types and unknown identifiers, so this is sent inefficiently
local function writeUnknown(name, value)
    net.WriteUInt(UNKNOWN_DARKRPVAR, 8)
    net.WriteString(name)
    net.WriteType(value)
end

-- Read the value of a DarkRPVar that was not registered
local function readUnknown()
    return net.ReadString(), net.ReadType(net.ReadUInt(8))
end

local warningsShown = {}
local function warnRegistration(name)
    if warningsShown[name] then return end
    warningsShown[name] = true

    DarkRP.errorNoHalt(string.format([[Warning! DarkRPVar '%s' wasn't registered!
        Please contact the author of the DarkRP Addon to fix this.
        Until this is fixed you don't need to worry about anything. Everything will keep working.
        It's just that registering DarkRPVars would make DarkRP faster.]], name), 4)
end

function DarkRP.writeNetDarkRPVar(name, value)
    local DarkRPVar = DarkRP.RegisteredDarkRPVars[name]
    if not DarkRPVar then
        warnRegistration(name)

        return writeUnknown(name, value)
    end

    net.WriteUInt(DarkRPVar.id, DARKRP_ID_BITS)
    return DarkRPVar.writeFn(value)
end

function DarkRP.writeNetDarkRPVarRemoval(name)
    local DarkRPVar = DarkRP.RegisteredDarkRPVars[name]
    if not DarkRPVar then
        warnRegistration(name)

        net.WriteUInt(UNKNOWN_DARKRPVAR, 8)
        net.WriteString(name)
        return
    end

    net.WriteUInt(DarkRPVar.id, DARKRP_ID_BITS)
end

function DarkRP.readNetDarkRPVar()
    local DarkRPVarId = net.ReadUInt(DARKRP_ID_BITS)
    local DarkRPVar = DarkRP.RegisteredDarkRPVarsById[DarkRPVarId]

    if DarkRPVarId == UNKNOWN_DARKRPVAR then
        local name, value = readUnknown()

        return name, value
    end

    local val = DarkRPVar.readFn(value)

    return DarkRPVar.name, val
end

function DarkRP.readNetDarkRPVarRemoval()
    local id = net.ReadUInt(DARKRP_ID_BITS)
    return id == 255 and net.ReadString() or DarkRP.RegisteredDarkRPVarsById[id].name
end

-- The money is a double because it accepts higher values than Int and UInt, which are undefined for >32 bits
DarkRP.registerDarkRPVar("money",         net.WriteDouble, net.ReadDouble)
DarkRP.registerDarkRPVar("salary",        fp{fn.Flip(net.WriteInt), 32}, fp{net.ReadInt, 32})
DarkRP.registerDarkRPVar("rpname",        net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("job",           net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("HasGunlicense", net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("Arrested",      net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("wanted",        net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("wantedReason",  net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("agenda",        net.WriteString, net.ReadString)

--[[---------------------------------------------------------------------------
RP name override
---------------------------------------------------------------------------]]
local pmeta = FindMetaTable("Player")
pmeta.SteamName = pmeta.SteamName or pmeta.Name
function pmeta:Name()
    if not self:IsValid() then DarkRP.error("Attempt to call Name/Nick/GetName on a non-existing player!", SERVER and 1 or 2) end
    return GAMEMODE.Config.allowrpnames and self:getDarkRPVar("rpname")
        or self:SteamName()
end
pmeta.GetName = pmeta.Name
pmeta.Nick = pmeta.Name

--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_jobmodels.lua:
-- Create a table for the preferred playermodels
--
-- Note: in DarkRP before 2024-09, there was a different table called
-- `darkp_playermodels` (note the misspelling of "darkp"). This table was
-- missing the server column, meaning that preferred job models would persist
-- across multiple servers. To make preferred job models store per server, this
-- new table (without the spelling mistake) was created.
--
-- See the original issue to create the player model preference feature:
-- https://github.com/FPtje/DarkRP/issues/979 and the subsequent refactor at
-- https://github.com/FPtje/DarkRP/pull/3266
sql.Query([[CREATE TABLE IF NOT EXISTS darkrp_playermodels(
    server TEXT NOT NULL,
    jobcmd TEXT NOT NULL,
    model TEXT NOT NULL,
    PRIMARY KEY (server, jobcmd)
);]])


local preferredModels = {}


--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function DarkRP.setPreferredJobModel(teamNr, model)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    preferredModels[job.command] = model
    sql.Query(string.format([[REPLACE INTO darkrp_playermodels(server, jobcmd, model) VALUES(%s, %s, %s);]], sql.SQLStr(game.GetIPAddress()), sql.SQLStr(job.command), sql.SQLStr(model)))

    net.Start("DarkRP_preferredjobmodel")
        net.WriteUInt(teamNr, 8)
        net.WriteString(model)
    net.SendToServer()
end

function DarkRP.getPreferredJobModel(teamNr)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    return preferredModels[job.command]
end

--[[---------------------------------------------------------------------------
Load the preferred models
---------------------------------------------------------------------------]]
local function sendModels()
    net.Start("DarkRP_preferredjobmodels")
        for _, job in pairs(RPExtraTeams) do
            if not preferredModels[job.command] then net.WriteBit(false) continue end

            net.WriteBit(true)
            net.WriteString(preferredModels[job.command])
        end
    net.SendToServer()
end

local function jobHasModel(job, model)
    return istable(job.model) and table.HasValue(job.model, model) or job.model == model
end

local function setPreferredModels(models)
    for _, v in ipairs(models) do
        local job = DarkRP.getJobByCommand(v.jobcmd)
        if job == nil or not jobHasModel(job, v.model) then continue end

        preferredModels[v.jobcmd] = v.model
    end
end

-- The old table, darkp_playermodels, acts as a global mapping of preferred
-- models for jobs.
local function setModelsFromOldTable()
    local oldTableExists = tobool(sql.QueryValue([[SELECT 1 FROM sqlite_master WHERE type='table' AND name='darkp_playermodels']]))
    if not oldTableExists then return end

    local models = sql.Query([[SELECT jobcmd, model FROM darkp_playermodels;]])

    if not models then return end
    setPreferredModels(models)
end

-- The newer table is server specific.
local function setModelsFromNewTable()
    local models = sql.Query(string.format([[SELECT jobcmd, model FROM darkrp_playermodels WHERE server = %s;]], sql.SQLStr(game.GetIPAddress())))

    if not models then return end
    setPreferredModels(models)
end

timer.Simple(0, function()
    -- Run after the jobs have loaded, to make sure the jobs can be looked up.

    -- Set models from the old table, before overriding them with data from the
    -- new table. That way, server specific preferences always have precedence.
    setModelsFromOldTable()
    setModelsFromNewTable()

    sendModels()
end)

--PATH addons/[technik] darkrp-city-worker/lua/darkrp_modules/cityworker/sh_cityworker.lua:
-- 76561198196280112

--TEAM_CITYWORKER = DarkRP.createJob( CITYWORKER.Config.Job.name, CITYWORKER.Config.Job )
--PATH addons/!jobs/lua/darkrp_customthings/ammo.lua:
--[[---------------------------------------------------------------------------
Ammo types
---------------------------------------------------------------------------
Ammo boxes that can be purchased in the F4 menu.

Add your custom ammo types in this file. Here's the syntax:
DarkRP.createAmmoType("ammoType", {
    name = "Ammo name",
    model = "Model",
    price = 1234,
    amountGiven = 5678,
    customCheck = function(ply) return ply:IsAdmin()
})

ammoType: The name of the ammo that Garry's mod recognizes
   If you open your SWEP's shared.lua, you can find the ammo name next to
   SWEP.Primary.Ammo = "AMMO NAME HERE"
   or
   SWEP.Secondary.Ammo = "AMMO NAME HERE"
   You can find the default gmod ammo types here: https://wiki.facepunch.com/gmod/Default_Ammo_Types

name: The name you want to give to the ammo. This can be anything.

model: The model you want the ammo to have in the F4 menu

price: the price of your ammo in dollars

amountGiven: How much bullets of this ammo is given every time the player buys it

customCheck: (Optional! Advanced!) a Lua function that describes who can buy the ammo.
    Similar to the custom check function for jobs and shipments
    Parameters:
        ply: the player who is trying to buy the ammo

Examples are below!

Pistol ammo type. Used by p228, desert eagle and all other pistols.
This ammo addition is different from the following three due to it making use of the "custom check" line.
Example 1:

DarkRP.createAmmoType("pistol", {
    name = "Pistol ammo",
    model = "models/Items/BoxSRounds.mdl",
    price = 30,
    amountGiven = 24,
    customCheck = function(ply) return
        table.HasValue({TEAM_EX_CONNORKENWAY}, ply:Team())
    end,
    CustomCheckFailMsg = "This ammo is for Connor only!",
})

Buckshot ammo, used by the shotguns
Example 2:

DarkRP.createAmmoType("buckshot", {
    name = "Shotgun ammo",
    model = "models/Items/BoxBuckshot.mdl",
    price = 50,
    amountGiven = 8
})

Rifle ammo, usually used by assault rifles
Example 3:

DarkRP.createAmmoType("ar2", {
    name = "Rifle ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 80,
    amountGiven = 30
})

SMG Ammo, usually used by small lightweight automatic guns.
Example 4:
DarkRP.createAmmoType("smg1", {
    name = "SMG ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 20,
    amountGiven = 30
})

Add new ammo types under the next line!
---------------------------------------------------------------------------]]

--PATH addons/!jobs/lua/darkrp_customthings/demotegroups.lua:
--[[---------------------------------------------------------------------------
Demote groups
---------------------------------------------------------------------------
When a chief of police gets demoted you don't want them to be banned from becoming civil protection officer as well.
That is what demote groups are for.

When someone in a group is demoted, they will be banned from EVERY job in the group.
The examples shown below are the default demote groups

HOW TO CREATE A DEMOTE GROUP:
DarkRP.createDemoteGroup("Name of the group", {TEAM1, TEAM2})
---------------------------------------------------------------------------]]


-- Example: DarkRP.createDemoteGroup("Cops", {TEAM_POLICE, TEAM_CHIEF})
-- Example: DarkRP.createDemoteGroup("Gangsters", {TEAM_GANG, TEAM_MOB})

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_camera.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_devtools.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_flare.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_tpik.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_anim.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_anim.lua:
function SWEP:PlayAnimation(anim, mult, lock, delayidle, noproxy, notranslate, noidle)
    mult = mult or 1
    lock = lock or false
    local untranslatedanim = anim
    anim = (notranslate == true) and anim or self:TranslateAnimation(anim)
    mult = self:RunHook("Hook_TranslateAnimSpeed", {mult = mult, anim = anim}).Mult or mult
    local omult = mult

    if !self:HasAnimation(anim) then return 0, 1 end

    if self:RunHook("Hook_BlockAnimation", anim) == true then return 0, 1 end

    local mdl = self:GetVM()

    if !IsValid(mdl) then return 0, 1 end

    local animation = self:GetAnimationEntry(anim)

    local source = animation.Source

    if animation.RareSource then
        if util.SharedRandom("ARC9_raresource", 0, 1) <= (animation.RareSourceChance or 0.01) then
            source = animation.RareSource
        end
    end

    if istable(source) then
        source = source[math.Round(util.SharedRandom("ARC9_animsource", 1, #source, CurTime()))]
    end

    local tsource = self:RunHook("Hook_TranslateSource", source) or source

    if mdl:LookupSequence(tsource) != -1 then
        source = tsource
    end

    local seq = 0

    if animation.ProxyAnimation and !noproxy then
        if CLIENT then
            mdl = animation.Model

            if !mdl then
                mdl = self:LocateSlotFromAddress(animation.Address).GunDriverModel
            end
        else
            mdl = ents.Create("prop_physics")
            mdl:SetModel(animation.ModelName)
        end

        self:SetSequenceProxy(animation.Address or 0)

        if IsValid(mdl) then

            seq = mdl:LookupSequence(source)

            if seq == -1 then return 0, 1 end

            if animation.AlsoPlayBase then
                self:PlayAnimation(anim, mult, lock, delayidle, true)
            end

        end
    else
        seq = mdl:LookupSequence(source)

        if seq == -1 then return 0, 1 end

        self:SetSequenceProxy(0)
    end

    local time = 0.1
    local minprogress = 1

    if IsValid(mdl) then
        time = animation.Time or mdl:SequenceDuration(seq)

        mult = mult * (animation.Mult or 1)

        if animation.Reverse then
            mult = mult * -1
        end

        local tmult = 1

        tmult = (mdl:SequenceDuration(seq) / time) / mult

        if animation.ProxyAnimation then
            mdl:SetSequence(seq)
            mdl:SetCycle(0)
        else
            mdl:SendViewModelMatchingSequence(seq)
            mdl:SetPlaybackRate(math.Clamp(tmult, -12, 12)) -- It doesn't like it if you go higher
        end

        self:SetSequenceIndex(seq or 0)
        self:SetSequenceSpeed((1 / time) / mult)

        if mult < 0 then
            self:SetSequenceCycle(1)
        else
            self:SetSequenceCycle(0)
        end

        mult = math.abs(mult)

        if animation.EjectAt then
            self:SetTimer(animation.EjectAt * mult, function()
                self:DoEject()
            end, "ejectat")
        end

        if animation.DropMagAt then
            self:SetTimer(animation.DropMagAt * mult, function()
                self:DropMagazine()
            end)
        end

        if animation.DumpAmmo then
            self:SetTimer((animation.MinProgress or 0.5) * mult, function()
                if SERVER then
                    self:Unload()
                end
            end)
        end

        minprogress = animation.MinProgress or 0.8
        minprogress = math.min(minprogress, 1)

        if animation.RestoreAmmo then
            self:SetTimer(time * mult * minprogress, function()
                self:RestoreClip(animation.RestoreAmmo)
            end)
        end

        if animation.IKTimeLine then
            self:SetIKAnimation(anim)
            self:SetIKTimeLineStart(CurTime())
            self:SetIKTime(time * mult)
        end
    end

    self:KillSoundTable()

    if (animation.EventTable or animation.SoundTable) and IsFirstTimePredicted() then
        -- This additional Mult check is necessary because mdl isn't valid above on the client and so the EventTable is off-sync.
        self:PlaySoundTable(animation.EventTable or animation.SoundTable, omult * (animation.Mult or 1))
    end

    self:SetHideBoneIndex(animation.HideBoneIndex or 0)

    if lock then
        local minprogress2 = minprogress
        if !animation.FireASAP then minprogress2 = 1 end
        if isnumber(animation.FireASAP) then minprogress2 = animation.FireASAP end
        
        self:SetAnimLockTime(CurTime() + (time * mult * minprogress2))
    else
        self:SetAnimLockTime(CurTime())
    end

    if !noidle and !animation.NoIdle then
        self:SetNextIdle(CurTime() + ((animation.DelayedIdle or (delayidle and !animation.InstantIdle)) and 0.325 or 0) + (time * mult))
    else
        self:SetNextIdle(math.huge)
    end

    if animation.PoseParamChanges then
        for i, k in pairs(animation.PoseParamChanges) do
            self.PoseParamState[i] = k
        end
    end

    self:SetFinishFiremodeAnimTime(0)

    if SERVER and animation.ProxyAnimation then
        SafeRemoveEntity(mdl)
    end

    self:SetFiremodePose()

    if self.UnbipodOnLockAnims  then
        if lock and (untranslatedanim != "idle" and untranslatedanim != "fire" and untranslatedanim != "dryfire" and untranslatedanim != "enter_sights" and untranslatedanim != "exit_sights") then
            if self:GetBipodAmount() > 0.9 then
                self:SetBipod(false)
                self:SetEnterBipodTime(CurTime())
            end
        end
    end

    return time * mult, minprogress
end

function SWEP:GetAnimationProxyModel(wm)
    local mdl
    if SERVER then
        local atttbl = self:GetFinalAttTableFromAddress(self:GetSequenceProxy())
        local modelname = atttbl.Model
        mdl = ents.Create("prop_physics")
        mdl:SetModel(modelname)
    else
        local slottbl = self:LocateSlotFromAddress(self:GetSequenceProxy())

        if !slottbl then return end

        if wm then
            mdl = slottbl.WModel
        else
            mdl = slottbl.VModel
        end
    end

    return mdl
end

function SWEP:GetAnimationProxyGunDriver()
    local mdl
    if SERVER then
        local atttbl = self:GetFinalAttTableFromAddress(self:GetSequenceProxy())
        local modelname = atttbl.Model
        mdl = ents.Create("prop_physics")
        mdl:SetModel(modelname)
    else
        local slottbl = self:LocateSlotFromAddress(self:GetSequenceProxy())

        if !slottbl then return end

        mdl = slottbl.GunDriverModel
    end

    return mdl
end

function SWEP:GetAnimationProxyReflectDriver()
    local mdl
    if SERVER then
        local atttbl = self:GetFinalAttTableFromAddress(self:GetSequenceProxy())
        local modelname = atttbl.Model
        mdl = ents.Create("prop_physics")
        mdl:SetModel(modelname)
    else
        local slottbl = self:LocateSlotFromAddress(self:GetSequenceProxy())

        if !slottbl then return end

        mdl = slottbl.ReflectDriverModel
    end

    return mdl
end

function SWEP:IdleAtEndOfAnimation()
    local mdl = self:GetVM()

    local cyc
    local duration
    local rate

    if self:GetSequenceProxy() == 0 then
        cyc = mdl:GetCycle()
        duration = mdl:SequenceDuration()
        rate = mdl:GetPlaybackRate()
    else
        mdl = self:GetAnimationProxyModel()

        cyc = self:GetSequenceCycle()
        duration = mdl:SequenceDuration(self:GetSequenceIndex())
        rate = self:GetSequenceSpeed()

        if SERVER then
            SafeRemoveEntity(mdl)
        end
    end

    local time = (1 - cyc) * (duration / rate)

    self:SetNextIdle(CurTime() + time)
end

function SWEP:Idle()
    if self:GetPrimedAttack() then return end
    if self:GetSafe() then return end

    local anim = "idle"
    local clip = self:Clip1()
    local banim = anim

    for i = 1, self:GetCapacity(self:GetUBGL()) - clip do
        if self:HasAnimation(anim .. "_" .. tostring(i)) then
            banim = anim .. "_" .. tostring(i)
        end
    end
    anim = banim

    local speed = 1

    if self:GetIsNearWall() then
        speed = math.huge
    end

    self:PlayAnimation(anim, speed)
end

SWEP.PoseParamState = {}

function SWEP:DoPoseParams()
    local vm = self:GetVM()

    if !vm or !IsValid(vm) then return end

    for i, k in pairs(self.PoseParamState) do
        vm:SetPoseParameter(i, k)
    end
end

function SWEP:ThinkAnimation()
    if CLIENT then 
        local seqprox = self:GetSequenceProxy()

        if seqprox != 0 then
            for _, wm in ipairs({true, false}) do
                local mdl = self:GetAnimationProxyModel(wm)

                if !IsValid(mdl) then continue end

                mdl:SetSequence(self:GetSequenceIndex())
                mdl:SetCycle(self:GetSequenceCycle())

                if seqprox == self.LHIKModelAddress then
                    local lhik_mdl

                    if wm then
                        lhik_mdl = self.LHIKModelWM
                    else
                        lhik_mdl = self.LHIKModel
                    end

                    if !lhik_mdl then return end

                    lhik_mdl:SetSequence(self:GetSequenceIndex())
                    lhik_mdl:SetCycle(self:GetSequenceCycle())
                end

                if seqprox == self.RHIKModelAddress then
                    local rhik_mdl

                    if wm then
                        rhik_mdl = self.RHIKModelWM
                    else
                        rhik_mdl = self.RHIKModel
                    end

                    if !rhik_mdl then return end

                    rhik_mdl:SetSequence(self:GetSequenceIndex())
                    rhik_mdl:SetCycle(self:GetSequenceCycle())
                end

                local anim_mdl = self:GetAnimationProxyGunDriver()

                if IsValid(anim_mdl) then
                    anim_mdl:SetSequence(self:GetSequenceIndex())
                    anim_mdl:SetCycle(self:GetSequenceCycle())
                end
            end
        end
    end

    local mult = self:GetSequenceSpeed()

    self:SetSequenceCycle(self:GetSequenceCycle() + (FrameTime() * mult))
end

function SWEP:FireAnimationEvent(pos, ang, event, options, source)
    if self.SuppressDefaultEvents then return true end
end

function SWEP:HandleAnimEvent(event, eventtime, cycle, type, options)
    if self.SuppressDefaultEvents then return true end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_freeaim.lua:
SWEP.ClientFreeAimAng = Angle(0, 0, 0)

local faconvar = GetConVar("arc9_mod_freeaim")

function SWEP:ThinkFreeAim()
    if !faconvar:GetBool() then return true end

    local diff = self:GetOwner():EyeAngles() - self:GetLastAimAngle()

    local freeaimang = Angle(self:GetFreeAimAngle())

    local max = self:GetProcessedValue("FreeAimRadius")

    diff.p = math.NormalizeAngle(diff.p)
    diff.y = math.NormalizeAngle(diff.y)

    diff = diff * 0.25

    freeaimang.p = math.Clamp(math.NormalizeAngle(freeaimang.p) + math.NormalizeAngle(diff.p), -max, max)
    freeaimang.y = math.Clamp(math.NormalizeAngle(freeaimang.y) + math.NormalizeAngle(diff.y), -max, max)

    local ang2d = math.atan2(freeaimang.p, freeaimang.y)
    local mag2d = math.sqrt(math.pow(freeaimang.p, 2) + math.pow(freeaimang.y, 2))

    mag2d = math.min(mag2d, max)

    freeaimang.p = mag2d * math.sin(ang2d)
    freeaimang.y = mag2d * math.cos(ang2d)

    self:SetFreeAimAngle(freeaimang)

    if CLIENT then
        self.ClientFreeAimAng = freeaimang
    end

    self:SetLastAimAngle(self:GetOwner():EyeAngles())
end

function SWEP:GetFreeAimOffset()
    if !faconvar:GetBool() then return angle_zero end
    if CLIENT then
        return self.ClientFreeAimAng
    else
        return self:GetFreeAimAngle()
    end
end

local arc9_mod_sway = GetConVar("arc9_mod_sway")

local smoothswayamt = 0

function SWEP:GetFreeSwayAngles()
    if !arc9_mod_sway:GetBool() then return end
    local ct = CurTime()
    local swayamt = self:GetFreeSwayAmount()
    if swayamt == 0 then return end

    local swayspeed = 2
    local isScope = self:IsUsingRTScope()

    swayamt = isScope and 0 or swayamt * (1-self:GetSightAmount() * 0.2)
    smoothswayamt = CLIENT and Lerp(RealFrameTime(), smoothswayamt, swayamt) or swayamt

    local ang = Angle(math.sin(ct * 0.6 * swayspeed) + (math.cos(ct * 2) * 0.5), math.sin(ct * 0.4 * swayspeed) + (math.cos(ct * 1.6) * 0.5), 0)

    ang = ang * smoothswayamt

    return ang
end

SWEP.InertiaDiff = Angle()
SWEP.InertiaSideMoveRaw = 0
SWEP.InertiaSideMoveSmooth = 0

function SWEP:GetInertiaSwayAngles()
    if !self.InertiaEnabled then return end
    -- if !arc9_mod_inertia:GetBool() then return end

    local eyee = self:GetOwner():EyeAngles()

    self.InertiaDiff = LerpAngle(FrameTime() * 4, self.InertiaDiff, eyee - self:GetLastAimAngle())
    self.InertiaSideMoveSmooth = Lerp(FrameTime() * 2, self.InertiaSideMoveSmooth, self.InertiaSideMoveRaw * 0.003)

    self:SetLastAimAngle(eyee)

    self.InertiaDiff.x = math.Clamp(self.InertiaDiff.x, -1.5, 1.5)
    self.InertiaDiff.y = math.Clamp(self.InertiaDiff.y, -1, 1) - self.InertiaSideMoveSmooth
    
    return self.InertiaDiff * -2
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_lockon.lua:
-- i heard this lower fps to 5




function SWEP:CanLockOn(ent)
    local _, reject = self:RunHook("HookC_CannotLockOn", ent)
    if reject then return false end
    if !IsValid(ent) then return false end
    if ent:IsWorld() then return false end
    if ent == self:GetOwner() then return false end

    local canlock = false

    if (ent:IsPlayer() or ent:IsNPC() or ent:IsNextBot()) and self:GetProcessedValue("LocksLiving", true) then
        canlock = true
    end

    if !canlock then
        local lockair = self:GetProcessedValue("LocksAir", true)
        local lockground = self:GetProcessedValue("LocksGround", true)

        if lockair and lockground then
            canlock = true
        elseif lockair or lockground then
            local tr = util.TraceHull({
                start = ent:GetPos(),
                endpos = ent:GetPos() - Vector(0, 0, 256),
                filter = ent,
                mask = MASK_NPCWORLDSTATIC,
                mins = ent:OBBMins(),
                maxs = ent:OBBMaxs()
            })

            if lockair and (!tr.HitWorld or tr.HitSky) then
                canlock = true
            elseif lockground and tr.HitWorld and !tr.HitSky then
                canlock = true
            end
        end
    end

    if ent:Health() == 0 then canlock = false end

    if !canlock then
        local _, can = self:RunHook("HookC_CanLockOn", ent)

        if can then return true end
    end

    return canlock
end

function SWEP:GetLockOnScore(ent, pure)
    local score = 0

    local dot = self:GetOwner():GetAimVector():Dot((ent:GetPos() - self:GetShootPos()):GetNormalized())

    if math.deg(math.acos(dot)) > self:GetProcessedValue("LockOnFOV", true) then return 0 end

    score = score + (math.deg(math.acos(dot)) / 2)
    if pure then return score end

    if ent:IsPlayer() then
        score = score + 100
    end

    if ent:IsNPC() then
        score = score + 25
    end

    if ent:Health() > 0 then
        score = score + (ent:Health() / 7.5)
    end

    score = score + (ent:BoundingRadius() / 10)

    local _, newscore = self:RunHook("HookS_GetLockOnScore", ent)

    score = newscore or score

    return score
end

function SWEP:LockOnTargetInFOV(ent)
    local dot = self:GetOwner():GetAimVector():Dot((ent:GetPos() - self:GetShootPos()):GetNormalized())

    local deg_dot = math.deg(math.acos(dot))

    if deg_dot > self:GetProcessedValue("LockOnFOV", true) then return false end

    return true
end

function SWEP:ThinkLockOn()
    if !self:GetProcessedValue("LockOn", true) then
        self:SetLockOnTarget(NULL)
        return
    end

    if IsValid(self:GetLockOnTarget()) then
        if self:GetLockOnScore(self:GetLockOnTarget(), true) == 0 then
            self:SetLockOnTarget(NULL)
        else
            if !self:GetLockedOn() and
            self:GetLockOnStartTime() + self:GetProcessedValue("LockOnTime", true) <= CurTime() then
                self:SetLockedOn(true)
                self:RunHook("Hook_LockOn", self:GetLockOnTarget())

                local soundtab = {
                    name = "lockedon",
                    sound = self:GetProcessedValue("LockedOnSound", true),
                }

                self:PlayTranslatedSound(soundtab)
            end
        end
    end

    local bestent = nil
    local bestscore = 0

    for _, ent in ipairs(ents.GetAll()) do
        if !IsValid(ent) or ent:IsWorld() then continue end

        local score = self:GetLockOnScore(ent)

        if score == 0 then continue end
        if !self:CanLockOn(ent) then continue end

        if score > bestscore then
            bestent = ent
            bestscore = score
        end
    end

    if !bestent then
        self:SetLockOnTarget(NULL)
        return
    end

    if bestent != self:GetLockOnTarget() then
        self:SetLockOnStartTime(CurTime())
        self:SetLockOnTarget(bestent)
        self:SetLockedOn(false)

        local soundtab = {
            name = "lockon",
            sound = self:GetProcessedValue("LockOnSound", true),
        }

        self:PlayTranslatedSound(soundtab)
    end
end

local lockonmat = Material("arc9/lockon.png", "noclamp smooth")
-- local rtsize = math.min(1024, ScrW(), ScrH())
local arc9_cheapscopes = GetConVar("arc9_cheapscopes")

function SWEP:DrawLockOnHUD(iam3d)
    if self:IsScoping() and !iam3d then return end

    if !self:GetProcessedValue("LockOn", true) then
        return
    end

    local locks = {}

    if IsValid(self:GetLockOnTarget()) then
        local toscreen = self:GetLockOnTarget():WorldSpaceCenter():ToScreen()

        table.insert(locks, {
            x = toscreen.x,
            y = toscreen.y,
            locktarget = true
        })
    end

    local bestent = nil
    local bestscore = 0
    local bestlock = {}

    for _, ent in ipairs(ents.GetAll()) do
        if !IsValid(ent) then continue end
        if ent:IsWorld() then continue end
        if ent == self:GetLockOnTarget() then continue end

        if !self:CanLockOn(ent) then continue end

        local score = self:GetLockOnScore(ent)

        local toscreen = ent:WorldSpaceCenter():ToScreen()

        local locktbl = {
            x = toscreen.x,
            y = toscreen.y,
        }

        table.insert(locks, locktbl)

        if score == 0 then
            locktbl.outoffov = true
            continue
        end

        if score > bestscore then
            bestent = ent
            bestscore = score
            bestlock = locktbl
        end
    end

    if bestent then
        bestlock.bestlock = true
    end

    cam.Start2D()

    for _, lock in ipairs(locks) do
        local x = lock.x
        local y = lock.y
        local size = 32

        if iam3d then
            if !arc9_cheapscopes:GetBool() then
                x = x / 2
                size = ScreenScale(32)
            else
                size = ScreenScale(12)
            end
        else
            size = ScreenScale(12)
        end

        if lock.locktarget then
            surface.SetDrawColor(255, 15, 15, 200)
        elseif lock.outoffov then
            surface.SetDrawColor(255, 255, 255, 50)
        else
            surface.SetDrawColor(200, 255, 50, 200)
        end

        surface.SetMaterial(lockonmat)
        surface.DrawTexturedRect(x - size / 2, y - size / 2, size, size)
    end

    cam.End2D()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_mergeslots.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_penetration.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_penetration.lua:
local function IsPenetrating(ptr, ptrent)
    if ptrent:IsWorld() then
        return !ptr.StartSolid or ptr.AllSolid
    elseif IsValid(ptrent) then
        local mins, maxs = ptrent:WorldSpaceAABB()
        local wsc = ptrent:WorldSpaceCenter()
        -- Expand the bounding box by a bit to account for hitboxes outside it
        -- This is more consistent but less accurate
        mins = mins + (mins - wsc) * 0.25
        maxs = maxs + (maxs - wsc) * 0.25
        local withinbounding = ptr.HitPos:WithinAABox(mins, maxs)
        if ARC9.Dev(2) then
            debugoverlay.Cross(ptr.HitPos, withinbounding and 2 or 6, 5, withinbounding and Color(255, 255, 0) or Color(128, 255, 0), true)
        end

        if withinbounding then return true end
    end
    return false
end

SWEP.MaxPenetrationLayers = 3
SWEP.Penned = 0

local arc9_mod_penetration = GetConVar("arc9_mod_penetration")
local ARC9_bullet_physics = GetConVar("ARC9_bullet_physics")
local ARC9_ricochet = GetConVar("ARC9_ricochet")

function SWEP:Penetrate(tr, range, penleft, alreadypenned)
    if !arc9_mod_penetration:GetBool() then return end

    if !IsValid(self) then return end
    if !IsValid(self:GetOwner()) then return end

    if self.Penned > self.MaxPenetrationLayers then return end

    self.Penned = self.Penned + 1

    local hitpos, startpos = tr.HitPos, tr.StartPos
    local dir    = (hitpos - startpos):GetNormalized()

    if tr.HitSky then return end

    if penleft <= 0 then return end

    alreadypenned = alreadypenned or {}

    local skip = false

    local trent = tr.Entity

    local penmult     = ARC9.PenTable[tr.MatType] or 1
    local curr_ent    = trent

    if self:GetRicochetChance(tr) > math.random(0, 100) then
        local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())
        if degree == 0 or degree == 1 then return end
        -- sound.Play(ArcCW.RicochetSounds[math.random(#ArcCW.RicochetSounds)], tr.HitPos)
        if (tr.Normal:Length() == 0) then return end
        -- ACT3_ShootPBullet(tr.HitPos, ((2 * degree * tr.HitNormal) + tr.Normal) * (vel * math.Rand(0.25, 0.75)), owner, inflictor, bulletid, false, 1, penleft, dist)
        -- return

        dir = (2 * degree * tr.HitNormal) + tr.Normal
        ang = dir:Angle()
        ang = ang + (AngleRand() * (1 - degree) * 15 / 360)
        dir = ang:Forward()

        if self:GetProcessedValue("RicochetSeeking", true) then
            local tgt = nil
            for _, e in pairs(ents.FindInCone(tr.StartPos, dir, self:GetProcessedValue("RicochetSeekingRange", true), math.cos(math.rad(self:GetProcessedValue("RicochetSeekingAngle", true))))) do
                if (e:IsNPC() or e:IsPlayer() or e:IsNextBot()) and e:Health() > 0 and e ~= self:GetOwner() then
                    tgt = e
                    break
                end
            end
            if tgt then
                dir = (tgt:WorldSpaceCenter() + (VectorRand() * 2) - tr.StartPos):GetNormalized()
            end
        end

        local d = math.Rand(0.25, 0.95)

        penleft = penleft * d

        local ricochetsounds = self:GetProcessedValue("RicochetSounds", true) or {}

        sound.Play(ricochetsounds[math.random(#ricochetsounds)], tr.HitPos, 75, math.Rand(90, 110), 1)

        skip = true
    end

    -- if !tr.HitWorld then penmult = penmult * 0.5 end

    local endpos = hitpos
    local dist = 8
    local exitpos = endpos

    if !skip then

        if trent.mmRHAe then penmult = trent.mmRHAe end

        penmult = penmult * math.Rand(0.9, 1.1) * math.Rand(0.9, 1.1)

        -- if tr.HitWorld and tr.HitBox > 0 then
        local pentracelen = math.min(math.max(penleft * penmult / 8, 1), 4)

        local ptrent = tr.Entity
        local ptr = util.TraceLine({
            start  = endpos,
            endpos = endpos + (dir * pentracelen),
            mask   = MASK_SHOT
        })

        while penleft > 0 and IsPenetrating(ptr, ptrent) and ptr.Fraction < 1 and ptrent == curr_ent do
            penleft = penleft - (pentracelen * penmult)

            ptr = util.TraceLine({
                start  = endpos,
                endpos = endpos + (dir * pentracelen),
                mask   = MASK_SHOT
            })

            -- if ARC9.Dev(2) then
            --     local pdeltap = penleft / self:GetValue("Penetration")
            --     local colorlr = Lerp(pdeltap, 0, 255)

            --     debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(255, colorlr, colorlr), true)
            -- end

            if ARC9.Dev(2) then
                debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(255, 0, 0), true)
            end

            endpos = endpos + (dir * pentracelen)
            range = range + pentracelen
            exitpos = ptr.HitPos
            dist = pentracelen + 1
        end
        -- else
        --     local td  = {}
        --     td.start  = endpos
        --     td.endpos = endpos + (dir * 520000)
        --     td.mask   = MASK_SHOT

        --     if !tr.HitWorld then
        --         td.filter = tr.Entity
        --     end

        --     td.start = endpos + (dir * 0.25)
        --     local ptr = util.TraceLine(td)

        --     -- Penetrate through to whatever the next thing is

        --     if !ptr.Hit then return end
        --     if ptr.HitSky then return end

        --     -- If we'd shoot through to the sky, then we don't really care if we can penetrate or not.

        --     local ntr = util.TraceLine({
        --         start = ptr.HitPos,
        --         endpos = endpos,
        --         mask = MASK_SHOT
        --     })

        --     -- Go backwards to find out where this thing ends

        --     if ARC9.Dev(2) then
        --         debugoverlay.Line(endpos, ntr.HitPos, 10, Color(255, 0, 0), true)
        --     end
        --     local d1 = (endpos - ntr.HitPos):Length()
        --     local amt = d1 * penmult
        --     endpos = ntr.HitPos

        --     penleft = penleft - amt
        --     range = range + amt

        --     exitpos = ptr.HitPos - (dir * 1)
        --     dist = (ptr.HitPos - ntr.HitPos):Length() + 1
        -- end
    end

    if tr.HitTexture == "**displacement**" then return end -- FUCK DISPLACEMENTS

    if penleft > 0 then
        if (dir:Length() == 0) then return end

        if ARC9_bullet_physics:GetBool() then
            ARC9:ShootPhysBullet(self, endpos, dir * self:GetProcessedValue("PhysBulletMuzzleVelocity", true), {
                Penleft = penleft,
                Travelled = range,
                Damaged = alreadypenned,
                Indirect = true
            })
        else
			if !ARC9.IsPointOutOfBounds(endpos) then
				local bullet_table = {
					Damage = self:GetValue("Damage_Max"),
					Force = 4,
					Tracer = 0,
					Num = 1,
					Dir = dir,
					Src = endpos,
					Callback = function(att, btr, dmg)
						range = range + (btr.HitPos - btr.StartPos):Length()
						self:AfterShotFunction(btr, dmg, range, penleft, alreadypenned)

						if ARC9.Dev(2) then
							if SERVER then
								debugoverlay.Cross(btr.HitPos, 4, 5, Color(255, 0, 0), false)
							else
								debugoverlay.Cross(btr.HitPos, 4, 5, Color(255, 255, 255), false)
							end
						end
					end
				}
				if(table.Count(alreadypenned) == 1) then
					--We penetrated only one entity.
					--The reason why we do this for one entity only is that in 99.99% of cases when we penetrate more than one entity, we won't be penetrating the first entity again with the same penetration instance.
					--God I hope this isn't intensive during firefights, but this is the only way to prevent a double-damage bug where the arm is penetrated and it deals damage to the torso.
					local first_entity = next(alreadypenned)
					if(first_entity:GetMaxHealth()) then
						bullet_table.IgnoreEntity = first_entity
					end
				end
				self:GetOwner():FireBullets(bullet_table)
			end
		end

        if !ARC9.IsPointOutOfBounds(exitpos) then
            self:GetOwner():FireBullets({
                Damage = 0,
                Force = 0,
                Tracer = 0,
                Num = 1,
                Distance = dist,
                Dir = -dir,
                Src = exitpos,
            })
        end
    end
end

function SWEP:GetRicochetChance(tr)
    if !ARC9_ricochet:GetBool() then return 0 end
    local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())

    degree = 90 - math.deg(math.acos(degree))

    local ricmult = ARC9.PenTable[tr.MatType] or 1

    -- 0 at 1
    -- 100 at 0

    if degree > self:GetProcessedValue("RicochetAngleMax", true) then return 0 end

    local c = self:GetProcessedValue("RicochetChance", true)

    c = c * ricmult

    -- c = c * GetConVar("arccw_ricochet_mult"):GetFloat()

    -- c = 100

    c = c * 100

    return math.Clamp(c, 0, 100)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_reload.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sights.lua:
function SWEP:GetSightDelta()
    return self:GetSightAmount()
end

function SWEP:EnterSights()
    if self:GetSprintAmount() > 0.5 then return end
    if !self:GetProcessedValue("HasSights", true) then return end
    if self:GetCustomize() then return end
    if !self:GetProcessedValue("ReloadInSights", true) and self:GetReloading() then return end
    if self:GetHolsterTime() > 0 then return end
    if self:GetProcessedValue("UBGLInsteadOfSights", true) then return end
    if self:GetSafe() then return end
    if self:GetAnimLockTime() > CurTime() and !self:GetReloading() then return end -- i hope this won't cause any issues later
    if self:GetValue("UBGL") and self:GetOwner():KeyDown(IN_USE) then return end
    if self:GetIsNearWall() then return end
	if self:HasAnimation("bash") and self.SetNextAiming then
		if self.SetNextAiming > CurTime() then return end
	end
	
    -- self:ToggleBlindFire(false)
    self:SetInSights(true)
    if IsFirstTimePredicted() then
        local soundtab1 = {
            name = "entersights",
            sound = self:RandomChoice(self:GetProcessedValue("EnterSightsSound", true)),
            channel = ARC9.CHAN_FIDDLE,
        }

        self:PlayTranslatedSound(soundtab1)
    end

    if !self:StillWaiting() or self.NoFireDuringSighting then
        if !(self.SightIsAlsoBipodAnims and self:GetBipod()) then
            if self:GetProcessedValue("InstantSightIdle", true) then
                self:PlayAnimation("idle")
            else
                local anim = self:TranslateAnimation("enter_sights")
                local mult = self:GetProcessedValue("AimDownSightsTime") -- Incorrectly uses a time as a multiplier! Preserved for legacy behavior
                if self:GetAnimationEntry(anim).NoStatAffectors then
                    mult = 1
                end
                self:PlayAnimation(anim, mult, self.NoFireDuringSighting, nil, nil, true)
            end
        end
    end

    self:SetShouldHoldType()
end

function SWEP:ExitSights()
    if self:GetInSights() then
        self:SetInSights(false)

        if IsFirstTimePredicted() then
            local soundtab1 = {
                name = "exitsights",
                sound = self:RandomChoice(self:GetProcessedValue("ExitSightsSound", true)),
                channel = ARC9.CHAN_FIDDLE,
            }

            self:PlayTranslatedSound(soundtab1)
        end

        if !self:StillWaiting() or (self.NoFireDuringSighting and !self:GetJammed()) then
            if !(self.SightIsAlsoBipodAnims and self:GetBipod()) then
                if self:GetProcessedValue("InstantSightIdle", true) then
                    self:PlayAnimation("idle")
                else
                    local anim = self:TranslateAnimation("exit_sights")
                    local mult = self:GetProcessedValue("AimDownSightsTime") -- Incorrectly uses a time as a multiplier! Preserved for legacy behavior
                    if self:GetAnimationEntry(anim).NoStatAffectors then
                        mult = 1
                    end
                    self:PlayAnimation(anim, mult, self.NoFireDuringSighting, nil, nil, true)
                end
            end
        end
    end

    self:SetShouldHoldType()
end

function SWEP:ToggleADS()
    return self:GetOwner():GetInfoNum("arc9_toggleads", 0) >= 1
end

SWEP.MultiSightTable = {
    -- {
    --     Pos = Vector(0, 0, 0),
    --     Ang = Angle(0, 0, 0)
    -- }
}

function SWEP:BuildMultiSight()
    if game.SinglePlayer() then self:CallOnClient("BuildMultiSight", "") end
    self.MultiSightTable = {}
    local modularironsights = {}

    local keepbaseirons = true
    local keepmodularirons = true

    local dev3 = ARC9.Dev(3)

    for i, slottbl in ipairs(self:GetSubSlotList()) do
        if !slottbl.Installed then continue end
        if slottbl.BlockSights then continue end
        local atttbl = self:GetFinalAttTable(slottbl)

        if atttbl.Sights then
            local isirons = false
            local kbi = false

            for _, sight in pairs(atttbl.Sights) do
                if !self:GetUBGL() and sight.UBGLOnly then continue end
                if self:GetUBGL() and self:GetProcessedValue("UBGLExclusiveSights", true) and !sight.UBGLOnly then continue end
                local s = {}

                if CLIENT then
                    if dev3 then
                        s = self:GenerateAutoSight({
                            Pos = Vector(GetConVar("arc9_dev_irons_x"):GetFloat(), GetConVar("arc9_dev_irons_y"):GetFloat(), GetConVar("arc9_dev_irons_z"):GetFloat()),
                            Ang = Angle(GetConVar("arc9_dev_irons_pitch"):GetFloat(), GetConVar("arc9_dev_irons_yaw"):GetFloat(), GetConVar("arc9_dev_irons_roll"):GetFloat()),
                            ViewModelFOV = 40,
                            Magnification = 1.1
                        }, slottbl)
                    else
                        s = self:GenerateAutoSight(sight, slottbl)
                    end
                end

                if sight.Disassociate then s.Disassociate = true end
                if sight.NoSensAdjustment then s.NoSensAdjustment = true end

                s.CrosshairInSights = sight.CrosshairInSights

                s.atttbl = atttbl
                if sight.ExtraSightData then
                    s.atttbl = table.Copy(atttbl)
                    table.Merge(s.atttbl, sight.ExtraSightData)
                    s.ExtraSightData = sight.ExtraSightData
                end

                s.OnSwitchToSight = sight.OnSwitchToSight
                s.OnSwitchFromSight = sight.OnSwitchFromSight

                if dev3 then
                    s.OriginalSightTable = {
                        Pos = Vector(GetConVar("arc9_dev_irons_x"):GetFloat(), GetConVar("arc9_dev_irons_y"):GetFloat(), GetConVar("arc9_dev_irons_z"):GetFloat()),
                        Ang = Angle(GetConVar("arc9_dev_irons_pitch"):GetFloat(), GetConVar("arc9_dev_irons_yaw"):GetFloat(), GetConVar("arc9_dev_irons_roll"):GetFloat()),
                        ViewModelFOV = 40,
                        Magnification = 1.1
                    }
                else
                    s.OriginalSightTable = sight
                end
                s.slottbl = slottbl
                s.ViewModelFOV = sight.ViewModelFOV
                s.InvertColors = sight.InvertColors or false

                if sight.DeferSights then
                    if (slottbl.SubAttachments or {})[1] then
                        s.slottbl = slottbl.SubAttachments[1]
                    end
                end

                if sight.IsIronSight then
                    table.insert(modularironsights, s)
                    isirons = true
                else
                    table.insert(self.MultiSightTable, s)
                end

                if sight.Blur == false then s.Blur = false end -- false exactly, not nil because nil is yes

                if sight.KeepBaseIrons then
                    kbi = true
                end

                if self.ScrollLevels[#self.MultiSightTable] then
                    s.ScrollLevel = self.ScrollLevels[#self.MultiSightTable]
                end
            end

            if !kbi and !slottbl.KeepBaseIrons and !atttbl.KeepBaseIrons then
                keepbaseirons = false

                if !isirons then
                    keepmodularirons = false
                end
            end
        end
    end

    if keepbaseirons then
        local tbl = {}
        if dev3 then
            table.insert(tbl, {
                Pos = Vector(GetConVar("arc9_dev_irons_x"):GetFloat(), GetConVar("arc9_dev_irons_y"):GetFloat(), GetConVar("arc9_dev_irons_z"):GetFloat()),
                Ang = Angle(GetConVar("arc9_dev_irons_pitch"):GetFloat(), GetConVar("arc9_dev_irons_yaw"):GetFloat(), GetConVar("arc9_dev_irons_roll"):GetFloat()),
                ViewModelFOV = 40,
                Magnification = 1.1
            })
        else
            table.insert(tbl, self:GetProcessedValue("IronSights"))
        end
        tbl[1].BaseSight = true
        table.Add(tbl, self.MultiSightTable)
        self.MultiSightTable = tbl
    end

    if keepmodularirons then
        table.Add(self.MultiSightTable, modularironsights)
    end

    if self:GetMultiSight() > #self.MultiSightTable then
        self:SetMultiSight(1)
    end
end

function SWEP:SwitchMultiSight(amt)
    if self.NextSightSwitch and self.NextSightSwitch > CurTime() then return end
    self.NextSightSwitch = CurTime() + 0.15
	
	if self.SwitchSightTime and self.SwitchSightTime > CurTime() then
		if self.SwitchSightDP then self.SwitchSightDP = 0 end
	end
	
    if game.SinglePlayer() then
        self:CallOnClient("InvalidateCache")
    end

    amt = amt or 1
    local old_msi = self:GetMultiSight()
    msi = old_msi
    msi = msi + amt
    
    if msi > #self.MultiSightTable then
        msi = 1
    elseif msi <= 0 then
        msi = #self.MultiSightTable
    end
    
    self:SetMultiSight(msi)

    self:RunHook("Hook_SwitchSight", self.MultiSightTable[msi])

    if self.MultiSightTable[msi] then
        if self.MultiSightTable[msi].OnSwitchToSight then
            self.MultiSightTable[msi].OnSwitchToSight(self, self.MultiSightTable[msi].slottbl)
        end

        if self.MultiSightTable[old_msi].OnSwitchFromSight then
            self.MultiSightTable[old_msi].OnSwitchFromSight(self, self.MultiSightTable[msi].slottbl)
        end
    end

    self:InvalidateCache()

    if msi != old_msi then
		if self:StillWaiting() then return end
		
        if (self.MultiSightTable[old_msi].atttbl or {}).ID == (self.MultiSightTable[msi].atttbl or {}).ID then
            if !self:GetUBGL() then -- for me
                self:PlayAnimation("switchsights", 1, false)
            end
        end
    end
end

do
    local ENTITY = FindMetaTable("Entity")
    local entityGetOwner = ENTITY.GetOwner
    local entitySetPoseParameter = ENTITY.SetPoseParameter

    local PLAYER = FindMetaTable("Player")
    local playerKeyDown = PLAYER.KeyDown
    local playerKeyPressed = PLAYER.KeyPressed

    local swepGetIsNearWall = SWEP.GetIsNearWall
    local swepToggleADS = SWEP.ToggleADS
    local swepExitSights = SWEP.ExitSights
    local swepEnterSights = SWEP.EnterSights
    local swepGetBipodAmount = SWEP.GetBipodAmount
    local swepGetSprintAmount = SWEP.GetSprintAmount
    local swepBuildMultiSight = SWEP.BuildMultiSight
    local swepSwitchMultiSight = SWEP.SwitchMultiSight
    local dtapconvar = GetConVar("arc9_dtap_sights")
    local cvarGetBool = FindMetaTable("ConVar").GetBool

    function SWEP:ThinkSights()
        -- if self:GetSafe() then return end
        local swepDt = self.dt

        local sighted = swepDt.InSights
        if swepDt.Safe or swepGetIsNearWall(self) then
            sighted = false
        end

        local oldamt = swepDt.SightAmount
        local amt = math.Approach(
            oldamt, sighted and 1 or 0, FrameTime() / self:GetProcessedValue("AimDownSightsTime"))

        if oldamt ~= amt then
            self:SetSightAmount(amt)
        end

        local owner = entityGetOwner(self)
        local toggle = swepToggleADS(self)
        local inatt = playerKeyDown(owner, IN_ATTACK2)
        local pratt = playerKeyPressed(owner, IN_ATTACK2)

        if toggle then
            if sighted and pratt then
                swepExitSights(self)
            elseif not sighted and (inatt and self:GetSprintAmount() > 0 or pratt) then
                self:EnterSights()
            end
    
            if pratt then
                swepBuildMultiSight(self)
            end
        else
            if sighted and !inatt then
                swepExitSights(self)
            elseif not sighted and inatt then
                self:EnterSights()
                swepBuildMultiSight(self)
            end
        end

        if sighted and playerKeyPressed(owner, ARC9.IN_SWITCHSIGHTS) then
            swepSwitchMultiSight(self)
        end
	
		if cvarGetBool(dtapconvar) then -- Double-Tap Switching Code
			if sighted and playerKeyPressed(owner, IN_USE) and !self:StillWaiting() then
				self.SwitchSightDP = (self.SwitchSightDP or 0) + 1
				
				if self.SwitchSightDP > 0 then
				self.SwitchSightTime = CurTime() + 0.3
					if self.SwitchSightDP == 2 then
						swepSwitchMultiSight(self)
					end
				end
			end

			if self.SwitchSightDP and self.SwitchSightDP > 2 then
				self.SwitchSightDP = 1
			end
			
			if self.SwitchSightTime and CurTime() > self.SwitchSightTime then
				if self.SwitchSightDP then self.SwitchSightDP = 0 end
			end
		end

        if self.HasSightsPoseparam then
            if CLIENT then
                entitySetPoseParameter(self:GetVM(), "sights", amt)
            end
            entitySetPoseParameter(self:GetVM(), "sights", math.max(swepDt.SightAmount, swepGetBipodAmount(self)))
        end
    end
end

function SWEP:GetSight()
    if ARC9.Dev(2) then
        self:BuildMultiSight() -- this is what was fixing toggle sights
    end
    -- if !self.MultiSightTable and self:GetValue("Sights") then self:BuildMultiSight() end
    return self.MultiSightTable[self:GetMultiSight()] or self:GetValue("IronSights")
end

function SWEP:GetRTScopeFOV()
    local sights = self:GetSight()

    if !sights then return self:GetOwner():GetFOV() end

    local atttbl

    if sights.BaseSight then
        atttbl = self:GetTable()
    else
        atttbl = self:GetFinalAttTable(sights.slottbl)
    end

    local scrolllevel = sights.ScrollLevel or 0

    if atttbl.RTScopeAdjustable then
        return Lerp(scrolllevel / atttbl.RTScopeAdjustmentLevels, atttbl.RTScopeFOVMax, atttbl.RTScopeFOVMin)
    else
        return sights.RTScopeFOV or atttbl.RTScopeFOV
    end
end

SWEP.ScrollLevels = {}

function SWEP:Scroll(amt)
    if self:GetOwner():KeyDown(IN_USE) then return end
    local sights = self:GetSight() or {}

    local atttbl = sights.atttbl

    if !atttbl then return end
    if !atttbl.RTScopeAdjustable then return end
    if !atttbl.RTScopeFOVMax then return end
    if !atttbl.RTScopeFOVMin then return end

    local scrolllevel = sights.ScrollLevel or 0
    local old = scrolllevel

    sights.ScrollLevel = scrolllevel + amt

    sights.ScrollLevel = math.Clamp(sights.ScrollLevel, 0, atttbl.RTScopeAdjustmentLevels)

    self.ScrollLevels[self:GetMultiSight()] = sights.ScrollLevel

    if old != sights.ScrollLevel then
        local soundtab1 = {
            name = "zoom",
            sound = atttbl.ZoomSound or "arc9/useatt.ogg",
            pitch = math.Rand(95, 105),
            vol = 1,
            chan = CHAN_ITEM
        }

        self:PlayTranslatedSound(soundtab1)
    end
end

function SWEP:IsScoping()
    local sight = self:GetSight()

    local atttbl

    if sight.BaseSight then
        atttbl = self:GetTable()
    else
        atttbl = self:GetFinalAttTable(sight.slottbl)
    end

    if sight.ExtraSightData then
        atttbl = table.Copy(atttbl)
        table.Merge(atttbl, sight.ExtraSightData)
    end

    return self:GetSightAmount() > 0 and atttbl.RTScope and atttbl
end
--PATH lua/weapons/arccw_base/cl_laser.lua:
local mth        = math
local m_log10    = mth.log10
local m_rand     = mth.Rand
local rnd        = render
local SetMat     = rnd.SetMaterial
local DrawBeam   = rnd.DrawBeam
local DrawSprite = rnd.DrawSprite
local cam        = cam

local lasermat = Material("arccw/laser")
local flaremat = Material("effects/whiteflare")
local delta    = 1

function SWEP:DoLaser(world, nocontext)
    world = world or false

    if !nocontext then
        if world then
            cam.Start3D()
        else
            cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(self.CurrentViewModelFOV))
        end
    end

    for slot, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local attach = ArcCW.AttachmentTable[k.Installed]

        if self:GetBuff_Stat("Laser", slot) then
            local color = self:GetBuff_Stat("LaserColor", slot) or attach.ColorOptionsTable[k.ColorOptionIndex or 1]

            if world then
                if !k.WElement then continue end
                self:DrawLaser(attach, k.WElement.Model, color, true)
            else
                if !k.VElement then continue end
                self:DrawLaser(attach, k.VElement.Model, color)
            end
        end
    end

    if self.Lasers then
        if world then
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self.WMModel or self, k.LaserColor, true)
            end
        else
            -- cam.Start3D(nil, nil, self.ViewmodelFOV)
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self:GetOwner():GetViewModel(), k.LaserColor)
            end
            -- cam.End3D()
        end
    end

    if !nocontext then
        cam.End3D()
    end
end

function SWEP:DrawLaser(laser, model, color, world)
    local owner = self:GetOwner()
    local behav = ArcCW.LaserBehavior

    if !owner then return end

    if !IsValid(owner) then return end

    if !model then return end

    if !IsValid(model) then return end

    local att = model:LookupAttachment(laser.LaserBone or "laser")

    att = att == 0 and model:LookupAttachment("muzzle") or att

    local pos, ang, dir

    if att == 0 then
        pos = model:GetPos()
        ang = owner:EyeAngles() + self:GetFreeAimOffset()
        dir = ang:Forward()
    else
        local attdata  = model:GetAttachment(att)
        pos, ang = attdata.Pos, attdata.Ang
        dir      = -ang:Right()
    end

    if world then
        dir = owner:IsNPC() and (-ang:Right()) or dir
    else
        ang:RotateAroundAxis(ang:Up(), 90)

        if self.LaserOffsetAngle then
            ang:RotateAroundAxis(ang:Right(), self.LaserOffsetAngle[1])
            ang:RotateAroundAxis(ang:Up(), self.LaserOffsetAngle[2])
            ang:RotateAroundAxis(ang:Forward(), self.LaserOffsetAngle[3])
        end
        if self.LaserIronsAngle and self:GetActiveSights().IronSight then
            local d = 1 - self:GetSightDelta()
            ang:RotateAroundAxis(ang:Right(), d * self.LaserIronsAngle[1])
            ang:RotateAroundAxis(ang:Up(), d * self.LaserIronsAngle[2])
            ang:RotateAroundAxis(ang:Forward(), d * self.LaserIronsAngle[3])
        end

        dir = ang:Forward()

        local eyeang   = EyeAngles() - self:GetOurViewPunchAngles() + self:GetFreeAimOffset()
        local canlaser = self:GetCurrentFiremode().Mode != 0 and !self:GetReloading() and self:BarrelHitWall() <= 0

        delta = Lerp(0, delta, canlaser and self:GetSightDelta() or 1)

        if self.GuaranteeLaser then
            delta = 1
        else
            delta = self:GetSightDelta()
        end

        dir = Lerp(delta, eyeang:Forward(), dir)
    end

    local beamdir, tracepos = dir, pos

    beamdir = world and (-ang:Right()) or beamdir

    if behav and !world then
        -- local cheap = ArcCW.ConVars["cheapscopes"]:GetBool()
        local punch = self:GetOurViewPunchAngles()

        ang = EyeAngles() - punch + self:GetFreeAimOffset()

        tracepos = EyePos() - Vector(0, 0, 1)
        pos, dir = tracepos, ang:Forward()
        beamdir  = dir
    end

    local dist = 128

    local tl = {}
    tl.start  = tracepos
    tl.endpos = tracepos + (dir * 33000)
    tl.filter = owner

    local tr = util.TraceLine(tl)

    tl.endpos = tracepos + (beamdir * dist)

    local btr = util.TraceLine(tl)

    local hit    = tr.Hit
    local hitpos = tr.HitPos
    local solid  = tr.StartSolid

    local strength = laser.LaserStrength or 1
    local laserpos = solid and tr.StartPos or hitpos

    laserpos = laserpos - ((EyeAngles() + self:GetFreeAimOffset()):Forward())

    if solid then return end

    local width = m_rand(0.05, 0.1) * strength * 1

    if (!behav or world) and hit then
        SetMat(lasermat)
        local a = 200
        DrawBeam(pos, btr.HitPos, width * 0.3, 1, 0, Color(a, a, a, a))
        DrawBeam(pos, btr.HitPos, width, 1, 0, color)
    end

    if hit and !tr.HitSky then
        local mul = 1 * strength
        mul = m_log10((hitpos - EyePos()):Length()) * strength
        local rad = m_rand(4, 6) * mul
        local glr = rad * m_rand(0.2, 0.3)

        SetMat(flaremat)

        -- if !world then
        --     cam.IgnoreZ(true)
        -- end
        DrawSprite(laserpos, rad, rad, color)
        DrawSprite(laserpos, glr, glr, color_white)

        -- if !world then
        --     cam.IgnoreZ(false)
        -- end
    end
end

--PATH lua/weapons/arccw_base/sh_firing.lua:
function SWEP:CanPrimaryAttack()
    local owner = self:GetOwner()

    -- Should we not fire? But first.
    if self:GetBuff_Hook("Hook_ShouldNotFireFirst") then return end

    -- We're holstering
    if IsValid(self:GetHolster_Entity()) then return end
    if self:GetHolster_Time() > 0 then return end

    -- Disabled (currently used only by deploy)
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    -- Coostimzing
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        if CLIENT and ArcCW.Inv_Hidden then
            ArcCW.Inv_Hidden = false
            gui.EnableScreenClicker(true)
        elseif game.SinglePlayer() then
            -- Kind of ugly hack: in SP this is only called serverside so we ask client to do the same check
            self:CallOnClient("CanPrimaryAttack")
        end
        return
    end

    -- A priority animation is playing (reloading, cycling, firemode etc)
    if self:GetPriorityAnim() then return end

    -- Inoperable, but internally (burst resetting for example)
    if self:GetWeaponOpDelay() > CurTime() then return end

    -- Safety's on, dipshit
    if self:GetCurrentFiremode().Mode == 0 then
        self:ChangeFiremode(false)
        self:SetNextPrimaryFire(CurTime())
        self.Primary.Automatic = false
        return
    end

    -- If we are an NPC, do our own little methods
    if owner:IsNPC() then self:NPC_Shoot() return end

    -- If we are in a UBGL, shoot the UBGL, not the gun
    if self:GetInUBGL() then self:ShootUBGL() return end

    -- Too early, come back later.
    if self:GetNextPrimaryFire() >= CurTime() then return end

    -- Gun is locked from heat.
    if self:GetHeatLocked() then return end

    -- Attempting a bash
    if self:GetState() != ArcCW.STATE_SIGHTS and owner:KeyDown(IN_USE) or self.PrimaryBash then self:Bash() return end

    -- Throwing weapon
    if self.Throwing then self:PreThrow() return end

    -- Too close to a wall
    if self:BarrelHitWall() > 0 then return end

    -- Can't shoot while sprinting
    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    -- Maximum burst shots
    if (self:GetBurstCount() or 0) >= self:GetBurstLength() then return end

    -- We need to cycle
    if self:GetNeedCycle() then return end

    -- If we have a trigger delay, make sure its progress is done
    if self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) and ((!self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:GetTriggerDelta() < 1)
            or (self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:IsTriggerHeld())) then
        return
    end

    -- Should we not fire?
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return end

    -- We made it
    return true
end

function SWEP:TakePrimaryAmmo(num)
    if self:HasBottomlessClip() or self:Clip1() <= 0 then
        if self:Ammo1() <= 0 then return end
        if self:HasInfiniteAmmo() then return end
        self:GetOwner():RemoveAmmo(num, self:GetPrimaryAmmoType())
    return end
    self:SetClip1(self:Clip1() - num)
end

function SWEP:ApplyRandomSpread(dir, spread)
    local radius = math.Rand(0, 1)
    local theta = math.Rand(0, math.rad(360))
    local bulletang = dir:Angle()
    local forward, right, up = bulletang:Forward(), bulletang:Right(), bulletang:Up()
    local x = radius * math.sin(theta)
    local y = radius * math.cos(theta)

    dir:Set(dir + right * spread * x + up * spread * y)
end

function SWEP:PrimaryAttack()
    local owner = self:GetOwner()

    self.Primary.Automatic = true

    if !self:CanPrimaryAttack() then return end

    local clip = self:Clip1()
    local aps = self:GetBuff("AmmoPerShot")

    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end

    if clip < aps then
        self:SetBurstCount(0)
        self:DryFire()

        self.Primary.Automatic = false

        return
    end

    local dir = (owner:EyeAngles() + self:GetFreeAimOffset()):Forward() --owner:GetAimVector()
    local src = self:GetShootSrc()

    if bit.band(util.PointContents(src), CONTENTS_WATER) == CONTENTS_WATER and !(self.CanFireUnderwater or self:GetBuff_Override("Override_CanFireUnderwater")) then
        self:DryFire()
        return
    end

    if self:GetMalfunctionJam() then
        self:DryFire()
        return
    end

    -- Try malfunctioning
    local mal = self:DoMalfunction(false)
    if mal == true then
        local anim = "fire_jammed"
        self:PlayAnimation(anim, 1, true, 0, true)
        return
    end

    self:GetBuff_Hook("Hook_PreFireBullets")

    local desync = ArcCW.ConVars["desync"]:GetBool()
    local desyncnum = (desync and math.random()) or 0
    math.randomseed(math.Round(util.SharedRandom(self:GetBurstCount(), -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)

    self.Primary.Automatic = true

    local spread = ArcCW.MOAToAcc * self:GetBuff("AccuracyMOA")
    local disp = self:GetDispersion() * ArcCW.MOAToAcc / 10

    --dir:Rotate(Angle(0, ArcCW.StrafeTilt(self), 0))
    --dir = dir + VectorRand() * disp

    self:ApplyRandomSpread(dir, disp)

    if (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 3 and disp > 0 then
        local dev_tr = util.TraceLine({
            start = src,
            endpos = src + owner:GetAimVector() * 33000,
            mask = MASK_SHOT,
            filter = {self, self:GetOwner()}
        })
        local dist = (dev_tr.HitPos - src):Length()
        local r = dist / (1 / math.tan(disp)) -- had to google "trig cheat sheet to figure this one out"
        local a = owner:GetAimVector():Angle()
        local r_sqrt = r / math.sqrt(2)
        debugoverlay.Line(dev_tr.HitPos - a:Up() * r, dev_tr.HitPos + a:Up() * r, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r, dev_tr.HitPos + a:Right() * r, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r_sqrt - a:Up() * r_sqrt, dev_tr.HitPos + a:Right() * r_sqrt + a:Up() * r_sqrt, 5, color_white, true)
        debugoverlay.Line(dev_tr.HitPos - a:Right() * r_sqrt + a:Up() * r_sqrt, dev_tr.HitPos + a:Right() * r_sqrt - a:Up() * r_sqrt, 5, color_white, true)
        debugoverlay.Text(dev_tr.HitPos, math.Round(self:GetDispersion(), 1) .. "MOA (" .. math.Round(disp, 3) .. ")", 5)
    end

    local delay = self:GetFiringDelay()

    local curtime = CurTime()
    local curatt = self:GetNextPrimaryFire()
    local diff = curtime - curatt

    if diff > engine.TickInterval() or diff < 0 then
        curatt = curtime
    end

    self:SetNextPrimaryFire(curatt + delay)
    self:SetNextPrimaryFireSlowdown(curatt + delay) -- shadow for ONLY fire time

    local num = self:GetBuff("Num")

    num = num + self:GetBuff_Add("Add_Num")

    local tracer = self:GetBuff_Override("Override_Tracer", self.Tracer)
    local tracernum = self:GetBuff_Override("Override_TracerNum", self.TracerNum)
    local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
    if lastout >= clip then
        tracernum = 1
        tracer = self:GetBuff_Override("Override_TracerFinal", self.TracerFinal) or self:GetBuff_Override("Override_Tracer", self.Tracer)
    end
    local dmgtable = self.BodyDamageMults
    dmgtable = self:GetBuff_Override("Override_BodyDamageMults") or dmgtable

    -- drive by is cool
    src = ArcCW:GetVehicleFireTrace(self:GetOwner(), src, dir) or src

    local bullet      = {}
    bullet.Attacker   = owner
    bullet.Dir        = dir
    bullet.Src        = src
    bullet.Spread     = Vector(0, 0, 0) --Vector(spread, spread, spread)
    bullet.Damage     = 0
    bullet.Num        = num

    local sglove = math.ceil(num / 3)
    bullet.Force      = self:GetBuff("Force", true) or math.Clamp( ( (50 / sglove) / ( (self:GetBuff("Damage") + self:GetBuff("DamageMin")) / (self:GetBuff("Num") * 2) ) ) * sglove, 1, 3 )
                        -- Overperforming weapons get the jerf, underperforming gets boost
    bullet.Distance   = self:GetBuff("Distance", true) or 33300
    -- Setting AmmoType makes the engine look for the tracer effect on the ammo instead of TracerName!
    --bullet.AmmoType   = self.Primary.Ammo
    bullet.HullSize   = self:GetBuff("HullSize")
    bullet.Tracer     = tracernum or 0
    bullet.TracerName = tracer
    bullet.Weapon     = self
    bullet.Callback = function(att, tr, dmg)
        ArcCW:BulletCallback(att, tr, dmg, self)
    end

    local shootent = self:GetBuff("ShootEntity", true) --self:GetBuff_Override("Override_ShootEntity", self.ShootEntity)
    local shpatt   = self:GetBuff_Override("Override_ShotgunSpreadPattern", self.ShotgunSpreadPattern)
    local shpattov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun", self.ShotgunSpreadPatternOverrun)

    local extraspread = AngleRand() * self:GetDispersion() * ArcCW.MOAToAcc / 10

    local projectiledata = {}

    if shpatt or shpattov or shootent then
        if shootent then
            projectiledata.ent = shootent
            projectiledata.vel = self:GetBuff("MuzzleVelocity")
        end

        bullet = self:GetBuff_Hook("Hook_FireBullets", bullet)

        if !bullet then return end

        local doent = shootent and num or bullet.Num
        local minnum = shootent and 1 or 0

        if doent > minnum then
            for n = 1, bullet.Num do
                bullet.Num = 1

                local dispers = self:GetBuff_Override("Override_ShotgunSpreadDispersion", self.ShotgunSpreadDispersion)
                local offset  = self:GetShotgunSpreadOffset(n)
                local calcoff = dispers and (offset * self:GetDispersion() * ArcCW.MOAToAcc / 10) or offset

                local ang = owner:EyeAngles() + self:GetFreeAimOffset()
                local ang2 = Angle(ang)
                ang2:RotateAroundAxis(ang:Right(), -1 * calcoff.p)
                ang2:RotateAroundAxis(ang:Up(), calcoff.y)
                ang2:RotateAroundAxis(ang:Forward(), calcoff.r)

                if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then -- Needs testing
                    ang2 = ang2 + AngleRand() * spread / 5
                end

                if shootent then
                    projectiledata.ang = ang2

                    self:DoPrimaryFire(true, projectiledata)
                else
                    bullet.Dir = ang2:Forward()

                    self:DoPrimaryFire(false, bullet)
                end
            end
        elseif shootent then
            local ang = owner:EyeAngles() + self:GetFreeAimOffset()

            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
               -- ang = (dir + VectorRand() * spread / 5):Angle()

                local newdir = Vector(dir)
                self:ApplyRandomSpread(newdir, spread / 5)
                ang = newdir:Angle()
            end

            projectiledata.ang = ang

            self:DoPrimaryFire(true, projectiledata)
        end
    else
        if !bullet then return end

        for n = 1, bullet.Num do
            bullet.Num = 1
            local dirry = Vector(dir.x, dir.y, dir.z)
            math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)
            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
                self:ApplyRandomSpread(dirry, spread)
                bullet.Dir = dirry
            end
            bullet = self:GetBuff_Hook("Hook_FireBullets", bullet) or bullet

            self:DoPrimaryFire(false, bullet)
        end
    end

    self:DoRecoil()

    self:SetNthShot(self:GetNthShot() + 1)

    owner:DoAnimationEvent(self:GetBuff_Override("Override_AnimShoot") or self.AnimShoot)

    local shouldsupp = SERVER and !game.SinglePlayer()

    if shouldsupp then SuppressHostEvents(owner) end

    self:DoEffects()

    self:SetBurstCount(self:GetBurstCount() + 1)

    self:TakePrimaryAmmo(aps)

    self:DoShootSound()
    self:DoPrimaryAnim()

    if self:GetCurrentFiremode().Mode < 0 and self:GetBurstCount() == self:GetBurstLength() then
        local postburst = (self:GetCurrentFiremode().PostBurstDelay or 0)
        self:SetWeaponOpDelay(CurTime() + postburst * self:GetBuff_Mult("Mult_PostBurstDelay") + self:GetBuff_Add("Add_PostBurstDelay"))
    end

    if (self:GetIsManualAction()) and !(self.NoLastCycle and self:Clip1() == 0) then
        local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
        local firedelay = self.Animations[fireanim].MinProgress or 0
        self:SetNeedCycle(true)
        self:SetWeaponOpDelay(CurTime() + (firedelay * self:GetBuff_Mult("Mult_CycleTime")))
        self:SetNextPrimaryFire(CurTime() + 0.1)
    end

    self:ApplyAttachmentShootDamage()

    self:AddHeat(self:GetBuff("HeatGain"))

    mal = self:DoMalfunction(true)
    if mal == true then
        local anim = "fire_jammed"
        self:PlayAnimation(anim, 1, true, 0, true)
    end

    if self:GetCurrentFiremode().Mode == 1 then
        self.LastTriggerTime = -1 -- Cannot fire again until trigger released
        self.LastTriggerDuration = 0
    end

    self:GetBuff_Hook("Hook_PostFireBullets")

    if shouldsupp then SuppressHostEvents(nil) end
end

function SWEP:TryBustDoor(ent, dmg)
    ArcCW.TryBustDoor(ent, dmg)
end

function SWEP:DoShootSound(sndoverride, dsndoverride, voloverride, pitchoverride)
    local fsound = self.ShootSound
    local suppressed = self:GetBuff_Override("Silencer")

    if suppressed then
        fsound = self.ShootSoundSilenced
    end

    local firstsound = self.FirstShootSound

    if self:GetBurstCount() == 1 and firstsound then
        fsound = firstsound

        local firstsil = self.FirstShootSoundSilenced

        if suppressed then
            fsound = firstsil and firstsil or self.ShootSoundSilenced
        end
    end

    local lastsound = self.LastShootSound

    local clip = self:Clip1()

    if clip == 1 and lastsound then
        fsound = lastsound

        local lastsil = self.LastShootSoundSilenced

        if suppressed then
            fsound = lastsil and lastsil or self.ShootSoundSilenced
        end
    end

    fsound = self:GetBuff_Hook("Hook_GetShootSound", fsound)

    local distancesound = self.DistantShootSound

    if suppressed then
        distancesound = self.DistantShootSoundSilenced
    end

    distancesound = self:GetBuff_Hook("Hook_GetDistantShootSound", distancesound)

    local spv = self.ShootPitchVariation
    local volume = self.ShootVol
    local pitch  = self.ShootPitch * math.Rand(1 - spv, 1 + spv) * self:GetBuff_Mult("Mult_ShootPitch")

    local v = ArcCW.ConVars["weakensounds"]:GetFloat()

    volume = volume - v

    volume = volume * self:GetBuff_Mult("Mult_ShootVol")

    volume = math.Clamp(volume, 51, 149)
    pitch  = math.Clamp(pitch, 0, 255)

    if    sndoverride        then    fsound    = sndoverride end
    if    dsndoverride    then    distancesound = dsndoverride end
    if    voloverride        then    volume    = voloverride end
    if    pitchoverride    then    pitch    = pitchoverride end

    if distancesound then self:MyEmitSound(distancesound, 149, pitch, 0.5, CHAN_WEAPON + 1) end

    if fsound then self:MyEmitSound(fsound, volume, pitch, 1, CHAN_WEAPON) end

    local data = {
        sound   = fsound,
        volume  = volume,
        pitch   = pitch,
    }

    self:GetBuff_Hook("Hook_AddShootSound", data)
end

function SWEP:GetMuzzleVelocity()
    local vel = self:GetBuff_Override("Override_PhysBulletMuzzleVelocity", self.PhysBulletMuzzleVelocity)

    if !vel then
        vel = self:GetBuff("Range") * 3.5

        if self:GetBuff("DamageMin") > self:GetBuff("Damage") then
            vel = vel * 2
        end
        vel = math.Clamp(vel, 200, 1000)
    end

    vel = vel / ArcCW.HUToM

    vel = vel * self:GetBuff_Mult("Mult_PhysBulletMuzzleVelocity")

    vel = vel * ArcCW.ConVars["bullet_velocity"]:GetFloat()

    return vel
end

function SWEP:DoPrimaryFire(isent, data)
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        if !self:GetOwner():IsPlayer() then
            clip = math.huge
        else
            clip = self:Ammo1()
        end
    end
    local owner = self:GetOwner()

    local shouldphysical = ArcCW.ConVars["bullet_enable"]:GetBool()

    if self.AlwaysPhysBullet or self:GetBuff_Override("Override_AlwaysPhysBullet") then
        shouldphysical = true
    end

    if self.NeverPhysBullet or self:GetBuff_Override("Override_NeverPhysBullet") then
        shouldphysical = false
    end

    if isent then
        self:FireRocket(data.ent, data.vel, data.ang, self.PhysBulletDontInheritPlayerVelocity)
    else
        -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end
        if !IsFirstTimePredicted() then return end

        if shouldphysical then
            local tracernum = data.Tracer or 1
            local phystracer = self:GetBuff_Override("Override_PhysTracerProfile", self.PhysTracerProfile)
            local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
            if lastout >= self:Clip1() then
                phystracer = self:GetBuff_Override("Override_PhysTracerProfileFinal", self.PhysTracerProfileFinal) or phystracer
            elseif tracernum == 0 or clip % tracernum != 0 then
                phystracer = 7
            end

            local vel = self:GetMuzzleVelocity()

            vel = vel * data.Dir:GetNormalized()

            ArcCW:ShootPhysBullet(self, data.Src, vel, phystracer or 0)
        else
            owner:FireBullets(data, true)
        end
    end
end

function SWEP:DoPrimaryAnim()
    local anim = "fire"

    local inbipod = self:InBipod()
    local iron    = self:GetState() == ArcCW.STATE_SIGHTS

    -- Needs testing
    if inbipod then
        anim = self:SelectAnimation("fire_bipod") or self:SelectAnimation("fire") or anim
    else
        anim = self:SelectAnimation("fire") or anim
    end

    if (self.ProceduralIronFire and iron) or (self.ProceduralRegularFire and !iron) then anim = nil end

    anim = self:GetBuff_Hook("Hook_SelectFireAnimation", anim) or anim

    local time = self:GetBuff_Mult("Mult_FireAnimTime", anim) or 1

    if anim then self:PlayAnimation(anim, time, true, 0, false) end
end

function SWEP:DoPenetration(tr, penleft, alreadypenned)
    local bullet = {
        Damage = self:GetDamage((tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM),
        DamageType = self:GetBuff_Override("Override_DamageType") or self.DamageType,
        Weapon = self,
        Penetration = self:GetBuff("Penetration"),
        Attacker = self:GetOwner(),
        Travelled = (tr.HitPos - tr.StartPos):Length()
    }

    ArcCW:DoPenetration(tr, bullet.Damage, bullet, penleft, false, alreadypenned)
end

function SWEP:GetFiringDelay()
    local delay = (self.Delay * (1 / self:GetBuff_Mult("Mult_RPM")))
    delay = self:GetBuff_Hook("Hook_ModifyRPM", delay) or delay

    return delay
end

function SWEP:GetShootSrc()
    local owner = self:GetOwner()

    if !IsValid(owner) then return self:GetPos() end
    if owner:IsNPC() then return owner:GetShootPos() end

    local dir    = owner:EyeAngles()
    local offset = Vector(0, 0, 0)

    if self:GetOwner():Crouching() then
        offset = self:GetBuff_Override("Override_BarrelOffsetCrouch") or self.BarrelOffsetCrouch or offset
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS then
        offset = LerpVector(self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetSighted", self.BarrelOffsetSighted) or offset)
    else
        offset = LerpVector(1 - self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetHip", self.BarrelOffsetHip) or offset)
    end

    local src = owner:EyePos()


    src = src + dir:Right()   * offset[1]
    src = src + dir:Forward() * offset[2]
    src = src + dir:Up()      * offset[3]

    return src
end

function SWEP:GetShotgunSpreadOffset(num)
    local rotate = Angle()
    local spreadpt = self:GetBuff_Override("Override_ShotgunSpreadPattern") or self.ShotgunSpreadPattern or {}
    local spreadov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun") or self.ShotgunSpreadPatternOverrun or { Angle() }

    if istable(spreadpt) and istable(spreadov) then
        spreadpt["BaseClass"] = nil
        spreadov["BaseClass"] = nil

        if num > #spreadpt then
            if spo then
                num = num - #spreadpt
                num = math.fmod(num, #spreadov) + 1
                rotate = spreadov[num]
            else
                num = math.fmod(num, #spreadpt) + 1
                rotate = spreadpt[num]
            end
        else
            rotate = spreadpt[num]
        end
    end

    local rottoang = {}
    rottoang.num = num
    rottoang.ang = rotate

    rotate = self:GetBuff_Hook("Hook_ShotgunSpreadOffset", rottoang).ang

    return rotate or Angle()
end

function SWEP:GetDispersion()
    local owner = self:GetOwner()

    if vrmod and vrmod.IsPlayerInVR(owner) then return 0 end

    local hipdisp = self:GetBuff("HipDispersion")
    local sights  = self:GetState() == ArcCW.STATE_SIGHTS

    local hip = hipdisp

    local sightdisp = self:GetBuff("SightsDispersion")
    if sights then hip = Lerp(self:GetNWSightDelta(), sightdisp, hipdisp) end

    local speed = owner:GetAbsVelocity():Length()
    local maxspeed = owner:GetWalkSpeed() * self:GetBuff("SpeedMult")
    if sights then maxspeed = maxspeed * self:GetBuff("SightedSpeedMult") end
    speed = math.Clamp(speed / maxspeed, 0, 2)

    if owner:OnGround() or owner:WaterLevel() > 0 and owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + speed * self:GetBuff("MoveDispersion")
    elseif owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + math.max(speed * self:GetBuff("MoveDispersion"), self:GetBuff("JumpDispersion"))
    end

    if self:InBipod() then hip = hip * (self.BipodDispersion * self:GetBuff_Mult("Mult_BipodDispersion")) end

    if ArcCW.ConVars["mult_crouchdisp"]:GetFloat() != 1 and owner:OnGround() and owner:Crouching() then
        hip = hip * ArcCW.ConVars["mult_crouchdisp"]:GetFloat()
    end

    if ArcCW.ConVars["freeaim"]:GetInt() == 1 and !sights then
        hip = hip ^ 0.9
    end

    --local t = hook.Run("ArcCW_ModDispersion", self, {dispersion = hip})
    --hip = t and t.dispersion or hip
    hip = self:GetBuff_Hook("Hook_ModDispersion", hip) or hip

    return hip
end

function SWEP:DoShellEject(atti)
    local eff = self:GetBuff_Override("Override_ShellEffect") or self.ShellEffect or "arccw_shelleffect"

    if eff == "NONE" then return end

    local owner = self:GetOwner()

    if !IsValid(owner) then return end

    local vm = self

    if !owner:IsNPC() then owner:GetViewModel() end

    local att = vm:GetAttachment(atti or self:GetBuff_Override("Override_CaseEffectAttachment") or self.CaseEffectAttachment or 2)

    if !att then return end

    local pos, ang = att.Pos, att.Ang

    if pos and ang and self.ShellEjectPosCorrection then
        local up = ang:Up()
        local right = ang:Right()
        local forward = ang:Forward()
        pos = pos + up * self.ShellEjectPosCorrection.z + right * self.ShellEjectPosCorrection.x + forward * self.ShellEjectPosCorrection.y
    end

    local ed = EffectData()
    ed:SetOrigin(pos)
    ed:SetAngles(ang)
    ed:SetAttachment(atti or self:GetBuff_Override("Override_CaseEffectAttachment") or self.CaseEffectAttachment or 2)
    ed:SetScale(1)
    ed:SetEntity(self)
    ed:SetNormal(ang:Forward())
    ed:SetMagnitude(100)

    local efov = {}
    efov.eff = eff
    efov.fx  = ed

    if self:GetBuff_Hook("Hook_PreDoEffects", efov) == true then return end

    util.Effect(eff, ed)
end

function SWEP:DoEffects(att)
    if !game.SinglePlayer() and !IsFirstTimePredicted() then return end

    local ed = EffectData()
    ed:SetStart(self:GetShootSrc())
    ed:SetOrigin(self:GetShootSrc())
    ed:SetScale(1)
    ed:SetEntity(self)
    ed:SetAttachment(att or self:GetBuff_Override("Override_MuzzleEffectAttachment") or self.MuzzleEffectAttachment or 1)

    local efov = {}
    efov.eff = "arccw_muzzleeffect"
    efov.fx  = ed

    if self:GetBuff_Hook("Hook_PreDoEffects", efov) == true then return end

    util.Effect("arccw_muzzleeffect", ed)
end

function SWEP:DryFire()

    if self.Animations.fire_dry then
        return self:PlayAnimation("fire_dry", 1, true, 0, true)
    end
    self:MyEmitSound(self.ShootDrySound or "weapons/arccw/dryfire.wav", 75, 100, 1, CHAN_ITEM)
    self:SetNextPrimaryFire(CurTime() + 0.25)
end

function SWEP:DoRecoil()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("DoRecoil") end

    -- math.randomseed(self:GetBurstLength() + (self.Recoil * 409) + (self.RecoilSide * 519))

    local rec = {
        Recoil = 1,
        RecoilSide = 1,
        VisualRecoilMul = 1
    }
    rec = self:GetBuff_Hook("Hook_ModifyRecoil", rec) or rec

    local recoil = rec.Recoil
    local side   = rec.RecoilSide
    local visual = rec.VisualRecoilMul

    local rmul = (recoil or 1) * self:GetBuff_Mult("Mult_Recoil")
    local recv = (visual or 1) * self:GetBuff_Mult("Mult_VisualRecoilMult")
    local recs = (side or 1)   * self:GetBuff_Mult("Mult_RecoilSide")

    -- local rrange = math.Rand(-recs, recs) * self.RecoilSide

    -- local irec = math.Rand(rrange - 1, rrange + 1)
    -- local recu = math.Rand(0.5, 1)

    local irec = math.Rand(-1, 1)
    local recu = 1

    if self:InBipod() then
        local b = self.BipodRecoil * self:GetBuff_Mult("Mult_BipodRecoil")

        rmul = rmul * b
        recs = recs * b
        recv = recv * b
    end

    local recoiltbl = self:GetBuff_Override("Override_ShotRecoilTable") or self.ShotRecoilTable

    if recoiltbl and recoiltbl[self:GetBurstCount()] then rmul = rmul * recoiltbl[self:GetBurstCount()] end

    if ArcCW.ConVars["mult_crouchrecoil"]:GetFloat() != 1 and self:GetOwner():OnGround() and self:GetOwner():Crouching() then
        rmul = rmul * ArcCW.ConVars["mult_crouchrecoil"]:GetFloat()
    end

    local punch = Angle()

    punch = punch + (self:GetBuff_Override("Override_RecoilDirection", self.RecoilDirection) * math.max(self.Recoil, 0.25) * recu * recv * rmul)
    punch = punch + (self:GetBuff_Override("Override_RecoilDirectionSide", self.RecoilDirectionSide) * math.max(self.RecoilSide, 0.25) * irec * recv * rmul)
    punch = punch + Angle(0, 0, 90) * math.Rand(-1, 1) * math.Clamp(self.Recoil, 0.25, 1) * recv * rmul * 0.01
    punch = punch * (self.RecoilPunch or 1) * self:GetBuff_Mult("Mult_RecoilPunch")

    self:SetFreeAimAngle(self:GetFreeAimAngle() - punch)

    if CLIENT then self:OurViewPunch(punch) end

    if CLIENT or single then
        recv = recv * self.VisualRecoilMult

        self.RecoilAmount     = self.RecoilAmount + (self.Recoil * rmul * recu)
        self.RecoilAmountSide = self.RecoilAmountSide + (self.RecoilSide * irec * recs * rmul)
        self.RecoilPunchBack  = math.Clamp(self.RecoilAmount * recv * 5, 1, 5)

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = self.RecoilSide * 0.1 * irec * recv * rmul
        self.RecoilPunchUp   = self.RecoilRise * 0.1 * recu
    end

    -- math.randomseed(CurTime() + (self:EntIndex() * 3))
end

function SWEP:GetBurstLength()
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end
    --if clip == 0 then return 1 end

    local len = self:GetCurrentFiremode().Mode

    if !len then return self:GetBurstCount() + 10 end

    local hookedlen = self:GetBuff_Hook("Hook_GetBurstLength", len)

    if len == 1 then return 1 end
    if len >= 2 then return self:GetBurstCount() + 10 end

    if hookedlen != len then return hookedlen end

    if len < 0 then return -len end

    return self:GetBurstCount() + 10
end

function SWEP:FireAnimationEvent(pos, ang, event, options)
    return true
end

function SWEP:IsRampupWeapon()
    local ovr = self:GetBuff_Override("Override_IsRampupWeapon")
    if ovr != nil then return ovr end
    return self:GetBuff("Damage") < self:GetBuff("DamageMin")
end

function SWEP:GetMinMaxRange()
    local decrease = !self:IsRampupWeapon()

    local min = self:GetBuff_Override("Override_RangeMin", self.RangeMin or 0)
    local max = self:GetBuff_Override("Override_Range", self.Range)
    local min_add = self:GetBuff_Add("Add_RangeMin")
    local max_add = self:GetBuff_Add("Add_Range")
    local min_mult = self:GetBuff_Mult("Mult_RangeMin")
    local max_mult = self:GetBuff_Mult("Mult_Range")

    if decrease then
        -- MinRange is also affected by Mult_Range, this is intentional
        local total_min = math.max((min + min_add) * min_mult * max_mult, 0)
        return total_min, math.max((max + max_add) * max_mult, total_min)
    else
        -- For "rampup weapons" (dmgmin > dmg), range buffs *decrease* range, as it ramps up damage quicker
        -- After all, +Range is supposed to be a positive buff no matter the kind of gun
        local total_min = math.max((min - min_add) / min_mult / max_mult, 0)
        return total_min, math.max((max - max_add) / max_mult, total_min)
    end
end

function SWEP:GetRangeFraction(range)
    local min, max = self:GetMinMaxRange()
    if range < min then
        return 0
    else
        return math.Clamp((range - min) / (max - min), 0, 1)
    end
end

function SWEP:GetDamage(range, pellet)
    local ovr = self:GetBuff_Override("Override_Num")
    local add = self:GetBuff_Add("Add_Num")
    local mul = self:GetBuff_Mult("Mult_Num")

    local num = self.Num
    local nbr = (ovr or num) * mul + add
    local factor = 1

    -- Total damage should be unchanged regardless of whether the weapon originally fired 1 pellet or > 1
    -- If pellet is set, we return per-pellet damage instead of total damage
    if pellet and num == 1 then
        factor = 1 / ((ovr or 1) * mul + add)
    elseif num != nbr then
        factor = num / nbr
    end

    --factor = ((pellet and num == 1) and (1 / ((ovr or 1) + add))) or ((num != nbr) and (num / nbr)) or 1

    if !pellet then factor = factor * nbr end

    local dmgmax = self:GetBuff("Damage") * factor
    local dmgmin = self:GetBuff("DamageMin") * factor
    local delta = self:GetRangeFraction(range)

    local lerped = Lerp(delta, dmgmax, dmgmin)

    return lerped
end

function SWEP:SecondaryAttack()
    return self.Melee2 and self:Bash(true)
end

function SWEP:CanShootWhileSprint()
    return ArcCW.ConVars["mult_shootwhilesprinting"]:GetBool() or self:GetBuff_Override("Override_ShootWhileSprint", self.ShootWhileSprint)
end

--PATH lua/weapons/arccw_base/sh_model.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_reload.lua:


function SWEP:GetReloadTime()
    -- Only works with classic mag-fed weapons.
    local mult = self:GetBuff_Mult("Mult_ReloadTime")
    local anim = self:SelectReloadAnimation()

    if !self.Animations[anim] then return false end

    local full = self:GetAnimKeyTime(anim) * mult
    local magin = self:GetAnimKeyTime(anim, true) * mult

    return { full, magin }
end

function SWEP:SetClipInfo(load)
    load = self:GetBuff_Hook("Hook_SetClipInfo", load) or load
    self.LastLoadClip1 = load - self:Clip1()
    self.LastClip1 = load
end

function SWEP:Reload()
    if IsValid(self:GetHolster_Entity()) then return end
    if self:GetHolster_Time() > 0 then return end

    if self:GetOwner():IsNPC() then
        return
    end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        return
    end

    -- Switch to UBGL
    if self:GetBuff_Override("UBGL") and self:GetOwner():KeyDown(IN_USE) then
        if self:GetInUBGL() then
            --net.Start("arccw_ubgl")
            --net.WriteBool(false)
            --net.SendToServer()

            self:DeselectUBGL()
        else
            --net.Start("arccw_ubgl")
            --net.WriteBool(true)
            --net.SendToServer()

            self:SelectUBGL()
        end

        return
    end

    if self:GetInUBGL() then
        if self:GetNextSecondaryFire() > CurTime() then return end
            self:ReloadUBGL()
        return
    end

    if self:GetNextPrimaryFire() >= CurTime() then return end
    -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end


    if self.Throwing then return end
    if self.PrimaryBash then return end

    -- with the lite 3D HUD, you may want to check your ammo without reloading
    local Lite3DHUD = self:GetOwner():GetInfo("arccw_hud_3dfun") == "1"
    if self:GetOwner():KeyDown(IN_WALK) and Lite3DHUD then
        return
    end

    if self:GetMalfunctionJam() then
        local r = self:MalfunctionClear()
        if r then return end
    end

    if !self:GetMalfunctionJam() and self:Ammo1() <= 0 and !self:HasInfiniteAmmo() then return end

    if self:HasBottomlessClip() then return end

    if self:GetBuff_Hook("Hook_PreReload") then return end

    -- if we must dump our clip when reloading, our reserve ammo should be more than our clip
    local dumpclip = self:GetBuff_Hook("Hook_ReloadDumpClip")
    if dumpclip and !self:HasInfiniteAmmo() and self:Clip1() >= self:Ammo1() then
        return
    end

    self.LastClip1 = self:Clip1()

    local reserve = self:Ammo1()

    reserve = reserve + self:Clip1()
    if self:HasInfiniteAmmo() then reserve = self:GetCapacity() + self:Clip1() end

    local clip = self:GetCapacity()

    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    if self:GetNeedCycle() then chamber = 0 end

    local load = math.Clamp(clip + chamber, 0, reserve)

    if !self:GetMalfunctionJam() and load <= self:Clip1() then return end

    self:SetBurstCount(0)

    local shouldshotgunreload = self:GetBuff_Override("Override_ShotgunReload")
    local shouldhybridreload = self:GetBuff_Override("Override_HybridReload")

    if shouldshotgunreload == nil then shouldshotgunreload = self.ShotgunReload end
    if shouldhybridreload == nil then shouldhybridreload = self.HybridReload end

    if shouldhybridreload then
        shouldshotgunreload = self:Clip1() != 0
    end

    if shouldshotgunreload and self:GetShotgunReloading() > 0 then return end

    local mult = self:GetBuff_Mult("Mult_ReloadTime")

    if shouldshotgunreload then
        local anim = "sgreload_start"
        local insertcount = 0

        local empty = self:Clip1() == 0 --or self:GetNeedCycle()

        if self.Animations.sgreload_start_empty and empty then
            anim = "sgreload_start_empty"
            empty = false
            if (self.Animations.sgreload_start_empty or {}).ForceEmpty == true then
                empty = true
            end

            insertcount = (self.Animations.sgreload_start_empty or {}).RestoreAmmo or 1
        else
            insertcount = (self.Animations.sgreload_start or {}).RestoreAmmo or 0
        end

        anim = self:GetBuff_Hook("Hook_SelectReloadAnimation", anim) or anim

        local time = self:GetAnimKeyTime(anim)
        local time2 = self:GetAnimKeyTime(anim, true)

        if time2 >= time then
            time2 = 0
        end

        if insertcount > 0 then
            self:SetMagUpCount(insertcount)
            self:SetMagUpIn(CurTime() + time2 * mult)
        end
        self:PlayAnimation(anim, mult, true, 0, true, nil, true)

        self:SetReloading(CurTime() + time * mult)

        self:SetShotgunReloading(empty and 4 or 2)
    else
        local anim = self:SelectReloadAnimation()

        if !self.Animations[anim] then print("Invalid animation \"" .. anim .. "\"") return end

        self:PlayAnimation(anim, mult, true, 0, false, nil, true)

        local reloadtime = self:GetAnimKeyTime(anim, true) * mult
        local reloadtime2 = self:GetAnimKeyTime(anim, false) * mult

        self:SetNextPrimaryFire(CurTime() + reloadtime2)
        self:SetReloading(CurTime() + reloadtime2)

        self:SetMagUpCount(0)
        self:SetMagUpIn(CurTime() + reloadtime)
    end

    self:SetClipInfo(load)
    if game.SinglePlayer() then
        self:CallOnClient("SetClipInfo", tostring(load))
    end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.DamageOnReload then
            self:DamageAttachment(i, atttbl.DamageOnReload)
        end
    end

    if !self.ReloadInSights then
        self:ExitSights()
        self.Sighted = false
    end

    self:GetBuff_Hook("Hook_PostReload")
end

function SWEP:ReloadTimed()
    -- yeah my function names are COOL and QUIRKY and you can't say a DAMN thing about it.
    self:RestoreAmmo(self:GetMagUpCount() != 0 and self:GetMagUpCount())
    self:SetMagUpCount(0)
    self:SetLastLoad(self:Clip1())
    self:SetNthReload(self:GetNthReload() + 1)
end

function SWEP:Unload()
    if !self:GetOwner():IsPlayer() then return end
    if SERVER and self:Clip1() != ArcCW.BottomlessMagicNumber then
        self:GetOwner():GiveAmmo(self:Clip1(), self.Primary.Ammo or "", true)
    end
    self:SetClip1(0)
end

function SWEP:HasBottomlessClip()
    if ArcCW.ConVars["mult_bottomlessclip"]:GetBool() then return true end
    if self.BottomlessClip or self:GetBuff_Override("Override_BottomlessClip") then return true end
    return false
end

function SWEP:HasInfiniteAmmo()
    if ArcCW.ConVars["mult_infiniteammo"]:GetBool() then return true end
    if self:GetBuff_Override("Override_InfiniteAmmo", self.InfiniteAmmo) then return true end
    return false
end

function SWEP:RestoreAmmo(count)
    if self:GetOwner():IsNPC() then return end

    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    if self:GetNeedCycle() then chamber = 0 end

    local clip = self:GetCapacity()

    count = count or (clip + chamber)

    local reserve = (self:HasInfiniteAmmo() and math.huge or self:Ammo1())

    local dumpclip = self:GetBuff_Hook("Hook_ReloadDumpClip")
    if !dumpclip then
        reserve = reserve + self:Clip1()
    end

    local load = math.Clamp(self:Clip1() + count, 0, reserve)
    load = math.Clamp(load, 0, clip + chamber)
    reserve = reserve - load

    if !self:HasInfiniteAmmo() then
        self:GetOwner():SetAmmo(reserve, self.Primary.Ammo, true)
    end
    self:SetClip1(load)
end

-- local lastframeclip1 = 0

SWEP.LastClipOutTime = 0

function SWEP:GetVisualBullets()
    local h = self:GetBuff_Hook("Hook_GetVisualBullets")
    if h then return h end

    local _clip = self:Clip1()
    local _ammo = self:Ammo1()

    if self:HasInfiniteAmmo() then
        _ammo = math.huge
    end
    if self:HasBottomlessClip() then
        _clip = _ammo
    end

    if self.LastClipOutTime > CurTime() then
        return self.LastClip1_B or _clip
    else
        self.LastClip1_B = _clip

        if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and _clip == 0)) then
            return math.Clamp(_clip + _ammo, 0, self:GetCapacity() + self:GetChamberSize())
        else
            return _clip
        end
    end
end

function SWEP:GetVisualClip()
    -- local reserve = self:Ammo1()
    -- local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    -- local abouttoload = math.Clamp(self:GetCapacity() + chamber, 0, reserve + self:Clip1())

    -- local h = self:GetBuff_Hook("Hook_GetVisualClip")

    -- if h then return h end
    -- if self.LastClipOutTime > CurTime() then
    --     return self.LastClip1 or self:Clip1()
    -- else
    --     if !self.RevolverReload then
    --         self.LastClip1 = self:Clip1()
    --     else
    --         if self:Clip1() > lastframeclip1 then
    --             self.LastClip1 = self:Clip1()
    --         end

    --         lastframeclip1 = self:Clip1()
    --     end

    --     if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and self:Clip1() == 0)) then
    --         return abouttoload
    --     else
    --         return self.LastClip1 or self:Clip1()
    --     end
    -- end

    local reserve = self:Ammo1()
    if self:HasInfiniteAmmo() then
        reserve = math.huge
    end
    local chamber = math.Clamp(self:Clip1(), 0, self:GetChamberSize())
    local abouttoload = math.Clamp(self:GetCapacity() + chamber, 0, reserve + self:Clip1())

    local h = self:GetBuff_Hook("Hook_GetVisualClip")

    if h then return h end

    if self.LastClipOutTime > CurTime() then
        return self:GetLastLoad() or self:Clip1()
    end

    if self.RevolverReload then
        if self:GetReloading() and !(self.ShotgunReload or (self.HybridReload and self:Clip1() == 0)) then
            return abouttoload
        else
            return self:GetLastLoad() or self:Clip1()
        end
    else
        return self:Clip1()
    end
end

function SWEP:GetVisualLoadAmount()
    return self.LastLoadClip1 or self:Clip1()
end

function SWEP:SelectReloadAnimation()
    local ret

    if self.Animations.reload_empty and self:Clip1() == 0 then
        ret = "reload_empty"
    else
        ret = "reload"
    end

    ret = self:GetBuff_Hook("Hook_SelectReloadAnimation", ret) or ret

    return ret
end

function SWEP:ReloadInsert(empty)
    local total = self:GetCapacity()

    -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end

    if !empty and !self:GetNeedCycle() then
        total = total + (self:GetBuff("ChamberLoadNonEmpty", true) or self:GetChamberSize())
    else
        total = total + (self:GetBuff("ChamberLoadEmpty", true) or 0)
    end

    local mult = self:GetBuff_Mult("Mult_ReloadTime")

    if self:Clip1() >= total or (self:Ammo1() == 0 and !self:HasInfiniteAmmo()) or ((self:GetShotgunReloading() == 3 or self:GetShotgunReloading() == 5) and self:Clip1() > 0) then
        local ret = "sgreload_finish"

        if empty then
            if self.Animations.sgreload_finish_empty then
                ret = "sgreload_finish_empty"
            end
            if self:GetNeedCycle() then
                self:SetNeedCycle(false)
            end
        end

        ret = self:GetBuff_Hook("Hook_SelectReloadAnimation", ret) or ret

        self:PlayAnimation(ret, mult, true, 0, true, nil, true)
        self:SetReloading(CurTime() + (self:GetAnimKeyTime(ret, true) * mult))

        self:SetTimer(self:GetAnimKeyTime(ret, true) * mult,
        function()
            self:SetNthReload(self:GetNthReload() + 1)
            if self:GetOwner():KeyDown(IN_ATTACK2) then
                self:EnterSights()
            end
        end)

        self:SetShotgunReloading(0)
    else
        local insertcount = self:GetBuff_Override("Override_InsertAmount") or 1
        local insertanim = "sgreload_insert"

        local ret = self:GetBuff_Hook("Hook_SelectInsertAnimation", {count = insertcount, anim = insertanim, empty = empty})

        if ret then
            insertcount = ret.count
            insertanim = ret.anim
        end

        local load = self:GetCapacity() + math.min(self:Clip1(), self:GetChamberSize())
        if load - self:Clip1() > self:Ammo1() then load = self:Clip1() + self:Ammo1() end
        self:SetClipInfo(load)
        if game.SinglePlayer() then
            self:CallOnClient("SetClipInfo", tostring(load))
        end

        local time = self:GetAnimKeyTime(insertanim, false)
        local time2 = self:GetAnimKeyTime(insertanim, true)

        if time2 >= time then
            time2 = 0
        end

        self:SetMagUpCount(insertcount)
        self:SetMagUpIn(CurTime() + time2 * mult)

        self:SetReloading(CurTime() + time * mult)

        self:PlayAnimation(insertanim, mult, true, 0, true, nil, true)
        self:SetShotgunReloading(empty and 4 or 2)
    end
end

function SWEP:GetCapacity()
    local clip = self.RegularClipSize or self.Primary.ClipSize

    if !self.RegularClipSize then
        self.RegularClipSize = self.Primary.ClipSize
    end

    local level = 1

    if self:GetBuff_Override("MagExtender") then
        level = level + 1
    end

    if self:GetBuff_Override("MagReducer") then
        level = level - 1
    end

    if level == 0 then
        clip = self.ReducedClipSize
    elseif level == 2 then
        clip = self.ExtendedClipSize
    end

    clip = self:GetBuff("ClipSize", true, clip) or clip

    local ret = self:GetBuff_Hook("Hook_GetCapacity", clip)

    clip = ret or clip

    clip = math.Clamp(math.Round(clip), 0, math.huge)

    self.Primary.ClipSize = clip

    return clip
end

function SWEP:GetChamberSize()
    return self:GetBuff("ChamberSize") --(self:GetBuff_Override("Override_ChamberSize") or self.ChamberSize) + self:GetBuff_Add("Add_ChamberSize")
end
--PATH lua/weapons/arccw_base/sh_ubgl.lua:

function SWEP:SelectUBGL()
    if !self:GetBuff_Override("UBGL") then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(true)

    self:SetFireMode(1)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Selected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() then
            self:DoLHIKAnimation("enter")
        end
        self:MyEmitSound( self:GetBuff_Override("SelectUBGLSound") or self.SelectUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("enter_ubgl_empty", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl_empty"))
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl then
        self:PlayAnimation("enter_ubgl", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl"))
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnSelectUBGL")
end

function SWEP:DeselectUBGL()
    if !self:GetInUBGL() then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(false)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Deselected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() and bong then
            self:DoLHIKAnimation("exit")
        end
        self:MyEmitSound( self:GetBuff_Override("ExitUBGLSound") or self.ExitUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("exit_ubgl_empty", 1, true)
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl then
        self:PlayAnimation("exit_ubgl", 1, true)
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnDeselectUBGL")
end

function SWEP:RecoilUBGL()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("RecoilUBGL") end

    local amt = self:GetBuff_Override("UBGL_Recoil")
    local amtside = self:GetBuff_Override("UBGL_RecoilSide") or (self:GetBuff_Override("UBGL_Recoil") * 0.5)
    local amtrise = self:GetBuff_Override("UBGL_RecoilRise") or 1

    local r = math.Rand(-1, 1)
    local ru = math.Rand(0.75, 1.25)

    local m = 1 * amt
    local rs = 1 * amtside
    local vsm = 1

    local vpa = Angle(0, 0, 0)

    vpa = vpa + (Angle(1, 0, 0) * amt * m * vsm)

    vpa = vpa + (Angle(0, 1, 0) * r * amtside * m * vsm)

    if CLIENT then
        self:OurViewPunch(vpa)
    end

    if CLIENT or game.SinglePlayer() then

        self.RecoilAmount = self.RecoilAmount + (amt * m)
        self.RecoilAmountSide = self.RecoilAmountSide + (r * amtside * m * rs)

        self.RecoilPunchBack = amt * 2.5 * m

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = r * rs * m * 0.1 * vsm
        self.RecoilPunchUp = math.Clamp(ru * amt * m * 0.6 * vsm * amtrise, 0, 0.1)
    end
end

function SWEP:ShootUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return false end

    self.Primary.Automatic = self:GetBuff_Override("UBGL_Automatic")

    local ubglammo = self:GetBuff_Override("UBGL_Ammo")

    if self:Clip2() <= 0 and self:GetOwner():GetAmmoCount(ubglammo) <= 0 then
        self:DeselectUBGL()
        return
    end

    if self:Clip2() <= 0 then
        return
    end

    self:RecoilUBGL()

    local func, slot = self:GetBuff_Override("UBGL_Fire")

    if func then
        func(self, self.Attachments[slot].VElement)
    end

    self:SetNextSecondaryFire(CurTime() + (60 / self:GetBuff_Override("UBGL_RPM")))
end

function SWEP:ReloadUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end

    local reloadfunc, slot = self:GetBuff_Override("UBGL_Reload")

    if reloadfunc then
        reloadfunc(self, self.Attachments[slot].VElement)
    end
end

if SERVER then

function SWEP:DoLHIKAnimation(key, time)
    if game.SinglePlayer() then
        net.Start("arccw_sp_lhikanim")
        net.WriteString(key)
        net.WriteFloat(time or -1)
        net.Send(self:GetOwner())
    end
end

end
--PATH lua/weapons/arccw_cis_se14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "SE-14"
SWEP.Trivia_Class = "CIS Blaster Pistol"
SWEP.Trivia_Desc = "CIS Blaster for CQB enviroments"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_se14r.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 300
SWEP.DamageMin = 17
SWEP.Range = 600
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 560
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -4,
        RunawayBurst = true,
        PostBurstDelay = 0.2,
    },
    {
        Mode = 0
    },   
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/se14c.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-4, -8, 1.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "idle"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)


SWEP.DefaultElements = {"se14"}

SWEP.AttachmentElements = {
    ["se14"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, -3.5),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, 10),
                    ang = Angle(-0, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = {"optic_lp", "optic"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0.8, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 20, -55),
            wang = Angle(0, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(11, 11, 11),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -6.5, -0.5),
            vang = Angle(0, 90, 0),
            wpos = Vector(90 , 20, -40),
            wang = Angle(0, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(130, 20, -48),
            wang = Angle(-0, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 0.7, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 25, -55),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_dual_bx_e5.lua:
return gluapack()()
--PATH lua/weapons/arccw_dual_e5.lua:
return gluapack()()
--PATH lua/weapons/arccw_dual_rg4d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_grenade_base.lua:
SWEP.Base = "arccw_base_nade"
SWEP.Spawnable = false
SWEP.Category = "[ArcCW] 40k Explosive Base"
SWEP.AdminOnly = false

SWEP.PrintName = "Nade Base"
SWEP.DrawCrosshair = true

SWEP.IronSightStruct = false

SWEP.CrouchPos = Vector(0, -2, -0.5)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, -2, 0)
SWEP.CustomizeAng = Angle(0 , 0, 0)

SWEP.ThrowInertia = false

SWEP.CookPrimFire = false
SWEP.CookAltFire = false

SWEP.Lunge = true
SWEP.LungeLength = 72
SWEP.MeleeSwingSound = ""
SWEP.MeleeMissSound = ""
SWEP.MeleeHitSound = ""
SWEP.MeleeHitNPCSound = ""

SWEP.MeleeDamage = 50
SWEP.MeleeRange = 48
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.HipDispersion = 150
SWEP.MoveDispersion = 50

SWEP.Throwing = true
SWEP.Singleton = false

SWEP.WindupTime = 0
SWEP.WindupMinimum = 0.5

SWEP.ShootWhileSprint = false

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_charriccarbine.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Charric Carbine"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "Blaster Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/charriccarbine.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_charric_carbine.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 16
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.1, 0, 0.45),
    Ang = Vector(0, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, -1)
SWEP.ActiveAng = Angle(0, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, 2, 2.55),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-1.2, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 18, 1.1),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.6, -0.82, -0.45),
            vang = Angle(-20, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.7, 7.5, -0.7),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_coruscantguardshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false


SWEP.Slot = 0

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Coruscant Guard Shield"
SWEP.Trivia_Class = "Ballistic Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/atts/cg_shield.png"

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_cgshield.mdl"
SWEP.WorldModel = "models/arccw/kraken/republic/v_cgshield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/arccw/kraken/republic/v_cgshield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 35
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}
SWEP.MeleeHitNPCSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 1)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "kraken/cgi/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "kraken/cgi/shield/shield_equip_05.wav"
})
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "CR-2s"
SWEP.Trivia_Class = "Heavy Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol, also known more simply as a CR-2 blaster pistol, was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cr2s.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00110100000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_cr2.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(1.2, 0.6, -3.3),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.ShootSound = "ArcCW_Kraken.SW_CR2"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 250, 0)
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-1.99, 0, 1.2),
    Ang = Vector(0, 0.2, 2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(1, -0.0, 1.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10, 0.8, -1.1),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(10, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		MinProgress = 0.925,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_up.ogg", t = 0.0},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
            {s = path .. "wfoly_sm_secho_reload_magout.ogg", t = 0.433},
			{s = path .. "wfoly_sm_secho_reload_maghit.ogg", t = 0.867},
			{s = path .. "wfoly_sm_secho_reload_magin.ogg", t = 1.233},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.23},
			{s = path .. "wfoly_sm_secho_reload_end.ogg", t = 1.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        SoundTable = {
			{s = path .. "wfoly_sm_secho_reload_empty_up.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_reload_empty_magout.ogg", t = 0.467},
            {s = "ArcCW_Kraken.Overheat", t = 0.5 },
			{s = path .. "wfoly_sm_secho_reload_empty_mvmnt.ogg", t = 1.133},
			{s = path .. "wfoly_sm_secho_reload_empty_maghit.ogg", t = 1.25},
			{s = path .. "wfoly_sm_secho_reload_empty_magin.ogg", t = 1.35},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.36},
			{s = path .. "wfoly_sm_secho_reload_empty_charge.ogg", t = 1.64},
			{s = path .. "wfoly_sm_secho_reload_empty_end.ogg", t = 1.867},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise_first_up.ogg", t = 0.0},
            {s = path .. "wfoly_sm_secho_raise_first_charge.ogg", t = 0.5},
            {s = path .. "wfoly_sm_secho_raise_first_end.ogg", t = 0.667},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        LHIK = true,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
		FireASAP = true,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sm_secho_inspect_magout.ogg", t = 0.033},
			{s = path .. "wfoly_sm_secho_inspect_magin.ogg", t = 1.967},
			{s = path .. "wfoly_sm_secho_inspect_end.ogg", t = 3.4},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "wfoly_sm_secho_selectsemi_on.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc15sc.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_rifle_republic.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_rifle_republic.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17m Rifle"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17m.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17m.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 7.2, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 48
SWEP.DamageMin = 12
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}

SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17M"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17M"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.498, -10.992, 1.258),
    Ang = Vector(-1.846, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -1)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "DC-17M",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, -22, 0),
                    ang = Angle(0, 90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
}



SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "None", 
        Slot = "optic",
        Bone = "DC-17M",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.06, -2.75, -1.6),
            vang = Angle(0, 90, 180),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    }, 
    {
        PrintName = "Internal Compression",
        DefaultAttName = "DC-17m Rifle",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },      
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-17M", 
        Offset = {
            vpos = Vector(-1.5, -13, -0.1),
            vang = Angle(0, 90, 90),
        },
    },   
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-17M",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.94, 0.8, 2.6),
            vang = Angle(0, 90, 180),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17M",
        Offset = {
            vpos = Vector(1.48, 1.4, 1),
            vang = Angle(0, 90, 180),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapon_hand/reload_heavy/mag_eject/023d-00000080.mp3", t = 10 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000648.mp3", t = 90 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000668.mp3", t = 110 / 60},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp23.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp24.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_e9x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-9x"
SWEP.Trivia_Class = "Blaster Sniper"
SWEP.Trivia_Desc = "Before the E-10 and E-11, the E-9 existed as a prototype of the capabilities of the future weapons. It development started during the final months of the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.IconOverride = "entities/kraken/galactic/e9x.png"

-- Base
SWEP.DefaultBodygroups = "01000211000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_e11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-15, 8, -9),
    ang = Angle(-30, 25, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 98
SWEP.DamageMin = 67
SWEP.RangeMin = 0
SWEP.Range = 700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 4000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.7
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 0.9

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E9X"
SWEP.ShootSound = "ArcCW_Kraken.SW_E9X"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.379, -6.961, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, 1.5)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11_GUN",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 14, 0),
                   ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    },
    ["e11_grip_standard"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.12, -4.5, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "E11_GUN",
        Offset = {
            vpos = Vector(0.1, 14, 1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.5, 4, 1),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "Standard E-11 Grip",
        Slot = {"foregrip", "sw_ubgl", "e11_grid"},
        Bone = "E11_GUN",
        InstalledEles = {"e11_grip_standard"},
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, -90, -90),   
        },
        SlideAmount = {
        vmin = Vector(0.2, 4, 0.4),
        vmax = Vector(0.2, 6, 0.5),
        },    
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Red Tibanna",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11_GUN",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.13, -6.75, 1.11),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "E11_GUN",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.9, -1.1, 0.9),
            vang = Angle(0, -90, 0),
        },
    },
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/e9/e11_reload.wav", t = 0.1 },
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EL-16C"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The EL-16 blaster rifle was a blaster rifle manufactured by BlasTech Industries. A Heavy Field Edition of the EL-16, the EL-16HFE blaster rifle, was also used by the Resistance. The EL-16 was outdated by the time of the First Order's rise to power. One was given to Finn by Han Solo, but he lost it when Maz's castle was destroyed. He got a new one of the same model at the Resistance base on D'Qar. Both it and the EL-16HFE were utilized during the Battle of Crait."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/el16c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_el16.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 40
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 470
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.63

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.ShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, -2, -1.03),
    Ang = Vector(2.8, 0, -0.5),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -2)
SWEP.ActiveAng = Angle(2, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 0, 3.7),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        InstalledEles = {"muzzle_attach"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 10.9, 1.2),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "IQA-11e"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The IQA-11 Blaster Rifle was a model of sniper rifle with a sleek and inexpensive design that made it a weapon of choice for mercenaries and bounty hunters who sought reliability over longer ranges. The rifle could receive modifications, such as an extended barrel and a dual zoom scope. During the Clone Wars, the bounty hunter Rumi Paramita used an IQA-11 while defending Felucian farmers from the Ohnaka Gang. A Mon Calamari also utilized the weapon during the Imperial Era."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/iqa11e.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00110000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_iqa11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 3
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 120
SWEP.DamageMin = 101
SWEP.RangeMin = 0
SWEP.Range = 1200
SWEP.Penetration = 11
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 2
SWEP.RecoilSide = 1.2
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.ShootSound = "ArcCW_Kraken.SW_IQA"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.283, 0, 1.488),
    Ang = Vector(0, -0.143, 3.076),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -1, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "body",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.06, 0, 1.6),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0, 1.2, 20),
            vang = Angle(-90, 180, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        InstalledEles = {"muzzle_attach"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.9, 36),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "body",
        Offset = {
            vpos = Vector(0.4, 2.7, -2.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "body",
        Offset = {
            vpos = Vector(0.6, 1.5, 2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local pathRZ = "uplp_rz/awp/"
-- urbna!
local pathUT = "arccw/kraken/sw_galactic/weapons/iqa11/handling/"
local pathUTC = "uplp_urban_temp/common/"

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["draw"] = {
        Source = "draw",
        MinProgress = 0.75,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "raise.ogg", t = 0.1, v = 0.8 },
        },
    },
    ["holster"] = {
        Source = "holster",
        MinProgress = 0.5,
        LHIK = true,
        SoundTable = {
            { s = pathUTC .. "rattle2.ogg", t = 0, v = 0.8 },
        },
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload_ext",
        Mult = 1.1,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,

        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 6 / 30},
            { s = pathUTC .. "cloth_2.ogg", t = 0.1 / 30, c = ca, v = 0.8 },
            { s = pathUT .. "magout.ogg", t = 5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "magpouch.ogg", t = 13 / 30, v = 0.3 },
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24 / 30},
            { s = pathUT .. "magin.ogg", t = 22.5 / 30, c = ca, v = 0.8 },
            { s = pathUTC .. "rattle2.ogg", t = 35 / 30, c = ca, v = 0.8 },

        },
    },
    -- Inspecc --
    ["exit_inspect"] = {
        Source = "inspect",
        LHIK = true,
        MinProgress = 0.925,
    },
    ["enter_bipod"] = {
        Source = "modeswitch",
    },
    ["enter_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
    ["exit_bipod"] = {
        Source = "modeswitch",
    },
    ["exit_bipod_empty"] = {
        Source = "modeswitch_empty",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_kyd21.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_plx1_empire.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Empire PLX-1"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The Merr-Sonn PLX, or Plex, was a powerful missile launcher that was in service almost from the beginning of the Clone Wars and continued to be used in different militaries well after the conclusion of that cataclysmic conflict."
SWEP.Trivia_Manufacturer = "Merr-Sonn Munitions, Inc."
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/kraken/explosives/plx1_imperio.png"

-- Base
SWEP.DefaultBodygroups = "0010000000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.NoHideLeftHandInCustomization = false
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_plx1_empire.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/sw/explosives/v_plx1_empire_mirror.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-3, 1.3, -6),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_plx1"
SWEP.MuzzleVelocity = 12000

SWEP.Recoil = 4.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 2
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.65
SWEP.SightedSpeedMult = 0.64
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.62

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/explosives/heat_ignite.ogg"
SWEP.ShootSound = "kraken/explosives/heat_ignite.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 192, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(3, -6, 4),
    Ang = Angle(8, 0, 19),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(3, -2, 4)
SWEP.ActiveAng = Angle(8, 0, 19)

SWEP.SprintPos = Vector(0, 3, -0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(6, 4, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "tag_launcher_offset",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Offset = {
            vpos = Vector(14, -4.5, -1),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "tag_launcher_offset",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(5, -4.5, -1),
            vang = Angle(0, 0, 0),
        },
    },
}


---- LOCK-IN FUNCTIONS
SWEP.Hook_GetShootEntData = function(self, data)
    local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 1)

    if tracktime >= 1 and self.TargetEntity and IsValid(self.TargetEntity) then
        data.Target = self.TargetEntity
    end
end

SWEP.Hook_DrawHUD = function(self)
local TrackingIndicator = Material("VGUI/lockon.png")
    if self:GetNWState() == ArcCW.STATE_SIGHTS and self:Clip1() > 0 then
        if self.TargetEntity and IsValid(self.TargetEntity) and self:Clip1() > 0 then
             local toscreen = self.TargetEntity:WorldSpaceCenter():ToScreen()
             local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 2)
             
             if tracktime >= 1 then
                surface.SetMaterial(TrackingIndicator)
                surface.SetDrawColor(0,250,0,200)
                surface.DrawTexturedRect(toscreen.x - 30, toscreen.y - 30, 60, 60) 
             else
                surface.SetMaterial(TrackingIndicator)
                surface.SetDrawColor(255,0,0,200)
                surface.DrawTexturedRect(toscreen.x - 30, toscreen.y - 30, 60, 60) 
             end
        end
    end
end


SWEP.NextBeepTime = 0
SWEP.TargetEntity = nil
SWEP.StartTrackTime = 0
SWEP.LockTime = 2

SWEP.Hook_Think = function(self)

    if self:Clip1() > 0 and self:GetNWState() == ArcCW.STATE_SIGHTS then

        if self.NextBeepTime > CurTime() then return end

        local tracktime = math.Clamp((CurTime() - self.StartTrackTime) / self.LockTime, 0, 2)

        -- if CLIENT then
        if tracktime >= 1 and self.TargetEntity then
            if CLIENT then
                self:EmitSound("kraken/explosives/reticle_locked2.ogg", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.15
        elseif tracktime >= 0 and self.TargetEntity then
            if CLIENT then
                self:EmitSound("kraken/explosives/reticle_tracking2.ogg", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.4
        else
            if CLIENT then
                self:EmitSound("", 75, 100)
            end
            self.NextBeepTime = CurTime() + 0.4
        end
        -- end
        
        local Radius = 14000
        local closest = Radius 

        local targets = ents.FindInSphere(self:GetPos(), Radius)

        local best = nil
        local targetscore = 0

        for _, ent in ipairs(targets) do
            if ent:IsWorld() then continue end
            if ent == self:GetOwner() then continue end
            if ent.IsProjectile then continue end
            if ent.UnTrackable then continue end
            if ent:GetClass():find("prop_") then continue end
			
            local aa, bb = ent:GetRotatedAABB(ent:OBBMins(), ent:OBBMaxs())
            local vol = math.abs(bb.x - aa.x) * math.abs(bb.y - aa.y) * math.abs(bb.z - aa.z)
			if vol <= 20000 then continue end

            local dot = (ent:GetPos() - self:GetShootPos()):GetNormalized():Dot(self:GetShootDir():Forward())
            local entscore = 1
            if ent:IsPlayer() then entscore = entscore + 5 end
            if ent:IsNPC() or ent:IsNextBot() then entscore = entscore + 2 end
            if ent:IsVehicle() or ent.LVS then entscore = entscore + 10 end
            if ent:Health() > 0 then entscore = entscore + 5 end

            entscore = entscore + dot * 5

            entscore = entscore + (ent.ARC9TrackingScore or 0)

            if entscore > targetscore then
                local tr = util.TraceLine({
                    start = self:GetShootPos(),
                    endpos = ent:WorldSpaceCenter(),
                    filter = self:GetOwner(),
                    mask = MASK_SHOT
                })
                if tr.Entity == ent then
                best = ent
                bestang = dot
                targetscore = entscore
                end
            end
        end

        if !best then self.TargetEntity = nil return end

        if !self.TargetEntity then
            self.StartTrackTime = CurTime()
        end

        self.TargetEntity = best
    else
        self.TargetEntity = nil
    end
end

-- Animations!
local path = "kraken/launchers/plx1/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",
	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_plr_la_gromeo_reload_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_rotate.ogg", t = 22/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_rockettip_01.ogg", t = 38/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_grabrocket.ogg", t = 78/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_load_01.ogg", t = 82/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_flipup.ogg", t = 102/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_arm.ogg", t = 128/30},
			{s = path .. "wfoly_plr_la_gromeo_reload_end.ogg", t = 152/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_raise_first_up.ogg", t = 3/30},
			{s = path .. "wfoly_plr_la_gromeo_raise_first_settle.ogg", t = 18/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.4,
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_raise_up.ogg", t = 7/30},
			{s = path .. "wfoly_plr_la_gromeo_raise_settle.ogg", t = 22/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_plr_la_gromeo_drop.ogg", t = 0/30},
            {s = path .. "wfoly_plr_la_gromeo_drop_mech.ogg", t = 5/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee_miss",
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_smartlauncher.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "'Roba' M-45c"
SWEP.Trivia_Class = "Repeating Ion Blaster"
SWEP.Trivia_Desc = "The 'Roba' M-45 repeating ion blaster, manufactured by BlasTech Industries, was a heavy repeating ion blaster that saw use during the Galactic Civil War, typically pintel-mounted on UT-60D U-wing gunships."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/m45c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000012000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_m45.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -5),
    ang = Angle(-10, -90, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 45
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 42
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 666
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 350
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_M45"
SWEP.ShootSound = "ArcCW_Kraken.SW_M45"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.BulletBones = {
    [17] = "j_b_01",
    [16] = "j_b_02",
	[15] = "j_b_03",
	[14] = "j_b_04",
	[13] = "j_b_05",
	[12] = "j_b_06",
	[11] = "j_b_07",
	[10] = "j_b_08",
	[9] = "j_b_09",
	[8] = "j_b_10",
	[7] = "j_b_11",
	[6] = "j_b_12",
	[5] = "j_b_13",
	[4] = "j_b_14",
	[3] = "j_b_15",
	[2] = "j_b_16",
	[1] = "j_b_17",
}

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.07, -3, 0.7),
    Ang = Angle(-0.2, 0, -1.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 8, bg = 0}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(8, 0, 2.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(44.3, 0, 0.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"laser_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(21.1, 0.6, -0.9),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(16, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/m45/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise_first_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_lm_kilo121_raise_first_raise_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_drop.ogg", t = 11/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_rattle.ogg", t = 22/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 30/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 43/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_cloth01.ogg", t = 51/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_end.ogg", t = 59/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Source = "jam",
        Mult = 2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 35/30},
            {s = "ArcCW_Kraken.Grab", t = 36 / 30},
        },
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_raise.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_magout_01.ogg", t = 86/30},
			{s = path .. "wfoly_lm_kilo121_reload_boxmag.ogg", t = 110/30},
			{s = path .. "wfoly_lm_kilo121_reload_magin_01.ogg", t = 128/30},
			{s = path .. "wfoly_lm_kilo121_reload_click_01.ogg", t = 151/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 180/30},
			{s = path .. "wfoly_lm_kilo121_reload_coverclose_01.ogg", t = 174/30},
			{s = path .. "wfoly_lm_kilo121_reload_end.ogg", t = 201/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_empty_lift.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_clean.ogg", t = 83/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_inspect.ogg", t = 106/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magout_01.ogg", t = 114/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_raise_01.ogg", t = 126/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boxmag.ogg", t = 142/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magin_01.ogg", t = 155/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_beltmvmnt.ogg", t = 164/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_click_01.ogg", t = 176/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_mvmnt01.ogg", t = 193/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coverclose_01.ogg", t = 201/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 210/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 223/30},
        },
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_inspect_01.ogg", t = 0/30},
			{s = path .. "wfoly_lm_kilo121_inspect_02.ogg", t = 55/30},
			{s = path .. "wfoly_lm_kilo121_inspect_03.ogg", t = 113/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_bacta.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Bacta Grenade"
SWEP.Trivia_Class = "Hand Grenade, Healing Effect"
SWEP.Trivia_Desc = "Bacta grenades were grenades that released a mist of bacta upon impact that healed those within range. They were carried by clone medics during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr-Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Bacta"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/bacta.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_grenade_bacta.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}


-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_bacta"

SWEP.MuzzleVelocity = 850
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_base.lua:
SWEP.Base = "arccw_base_nade"
SWEP.Spawnable = false
SWEP.Category = "ArcCW - Kraken Explosives"
SWEP.AdminOnly = false

SWEP.PrintName = "Kraken Kabum"
SWEP.DrawCrosshair = true

SWEP.IronSightStruct = false

SWEP.CrouchPos = Vector(0, -2, -0.5)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, -2, 0)
SWEP.CustomizeAng = Angle(0 , 0, 0)

SWEP.ThrowInertia = false

SWEP.CookPrimFire = false
SWEP.CookAltFire = false

SWEP.Lunge = true
SWEP.LungeLength = 72
SWEP.MeleeMissSound = ""
SWEP.MeleeSwingSound = "weapons/arccw/m249/m249_draw.wav"
SWEP.MeleeHitSound = "weapons/arccw/knife/knife_hitwall1.wav"
SWEP.MeleeHitNPCSound = "physics/body/body_medium_break2.wav"

SWEP.MeleeDamage = 50
SWEP.MeleeRange = 48
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.HipDispersion = 150
SWEP.MoveDispersion = 50

SWEP.Throwing = true
SWEP.Singleton = false

SWEP.WindupTime = 0
SWEP.WindupMinimum = 0.5

SWEP.ShootWhileSprint = false -- You cannot throw nades while sprinting on apex, so i thought it should be the same here
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_detonite.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Detonite Charge"
SWEP.Trivia_Class = "Mine"
SWEP.Trivia_Desc = "A detonite charge was an explosive made of detonite. It was used during the Clone Wars. Several charges were used to wire the Republic Service Organization center with explosives."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "High Explosive"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/detonite.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_detonite.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_detonite"

SWEP.MuzzleVelocity = 800
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}



-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0,0,-5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4.5, -2, -1)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Animations
SWEP.DefaultElements = {"grenade"}
SWEP.AttachmentElements = {
    ["grenade"] = {
            WMElements = {
            {
                Model = "models/arccw/kraken/sw/explosives/v_detonite.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1,1,1),
                ModelBodygroups = "0000000000000000000",
                Offset = {
                    pos = Vector(-140,100,-20),
                    ang = Angle(0, 0, 180),
                },
            },
        },
    },
}WMOverride = "models/arccw/kraken/sw/explosives/v_detonite.mdl"

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0,
		Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
        FireASAP = true,
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.1
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.1
    },
    ["bash"] = {
        Source = {"melee"}
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_plasmagrenade.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Plasma Grenade"
SWEP.Trivia_Class = "Hand Grenade, Plasma"
SWEP.Trivia_Desc = "Plasma grenades were a type of grenade that used blaster technology. They were filled with highly pressurized gas that was energized by an XCiter unit, and the energized gas would then be detonated by a laser charge. The resulting explosion was similar in both appearance and effect to a blaster bolt, albeit over a wider area and much more powerful."
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr-Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Plasma"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/plasmagrenade.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_plasmagrenade.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_plasma"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "NT-242e"
SWEP.Trivia_Class = "Sniper"
SWEP.Trivia_Desc = "The NT-242 was a type of sniper rifle. The NT-242 was considered a tank buster by many users and was one of the heaviest longblasters. The NT-242 was powerful at range, and could be modified to have a disruptor shot which could engage vehicles."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/nt242e.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "02220000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_nt242.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 115
SWEP.DamageMin = 90
SWEP.RangeMin = 0
SWEP.Range = 1700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(150, 0, 250)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 2.8
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 2.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.ShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(150, 0, 250)
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.GMMuzzleEffect = false

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.48, -0, 0.5),
    Ang = Vector(3, 0.5, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(8, -0.0, 2.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        VMScale = Vector(1.3, 1.3, 1.3),
        WMScale = Vector(1.3, 1.3, 1.3),
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(51, -0.0, 0.45),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(23, 1, 0.4),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(20, 0, -0.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = "bolter_mag",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "bolter_cooling",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(4.8, -0.5, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(9, -1, 0.8),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/handling/nt242/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "ads_in",
	},
	["exit_sights"] = {
		Source = "ads_out",
	},
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = false,
    },
    ["dryfire"] = {
        Source = "dryfire",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sn_xmike109_reload_magrelease.ogg", t = 0.9},
			{s = path .. "wfoly_sn_xmike109_reload_magout.ogg", t = 1.4},
			{s = path .. "wfoly_sn_xmike109_reload_arm.ogg", t = 2.367},
			{s = path .. "wfoly_sn_xmike109_reload_magin_01.ogg", t = 2.867},
			{s = path .. "wfoly_sn_xmike109_reload_magin_02.ogg", t = 3.1},
			{s = path .. "wfoly_sn_xmike109_reload_end.ogg", t = 3.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_empty_up.ogg", t = 0.033},
            {s = path .. "wfoly_sn_xmike109_reload_empty_magrelease.ogg", t = 1.05},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magout.ogg", t = 1.45},
			{s = path .. "wfoly_sn_xmike109_reload_empty_arm.ogg", t = 2.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_01.ogg", t = 2.78},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_02.ogg", t = 3.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_rotate.ogg", t = 3.667},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltpull.ogg", t = 4.267},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltrelease.ogg", t = 4.8},
			{s = path .. "wfoly_sn_xmike109_reload_empty_end.ogg", t = 5.1},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0.1},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_pull.ogg", t = 0.6},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_release.ogg", t = 1.0},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 36/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        MinProgress = 0.3,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0/30},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 10/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_inspect_up.ogg", t = 0.1},
			{s = path .. "wfoly_sn_xmike109_inspect_grabrotate.ogg", t = 1.7},
			{s = path .. "wfoly_sn_xmike109_inspect_move.ogg", t = 3.7},
			{s = path .. "wfoly_sn_xmike109_inspect_end.ogg", t = 111/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_pulse40.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_pulse40.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "PULSE-40 Blaster"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/pulse40.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_pulse40.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18.5, 6, -5.4),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 29
SWEP.DamageMin = 21
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_PULSE"
SWEP.ShootSound = "ArcCW_Kraken.SW_PULSE"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1.4),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2, -2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.47, 5.2),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.42, -1.2, 1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.55, -1.3, 1),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.55, -1.3, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_republicshield.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "RT-97c"
SWEP.Trivia_Class = "Heavy Blaster Rifle"
SWEP.Trivia_Desc = "The RT-97C heavy blaster rifle was a model of heavy blaster rifle that saw use during the Galactic Civil War. It was a versatile heavy rifle, fitted with optics that allowed use at long range. Imperial sandtroopers were known to use them, as were jumptroopers."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/rt97c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0101000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_rt97c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 7, 2),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 45
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 550
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 85

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 0.8

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 350
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.ShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(25, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.133, -10.502, -7.042),
    Ang = Vector(2.184, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, -8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, -8)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -11)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, -8)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, -9)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.9, -0, 5.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(40, -0.1, 4.8),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(25, 0.4, 4.7),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(8, 0.1, 3.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2, -1.1, 4.75),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-3, -1.1, 4.65),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.925,
        Mult = 0.9,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 7},
        },
    },
    ["ready"] = {
        Source = "pullout_first",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.0},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.5},
        },
    },
    ["holster"] = {
        Source = "putaway",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "pullout",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["fix"] = {
        Source = "pullout_first",
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.6},
            {s = "ArcCW_Kraken.Overheat", t = 0.1},
            {s = "ArcCW_Kraken.OverheatFix", t = 0.9},
        },
    },
    ["idle_sprint"] = {
        Source = "base_sprint_loop",
    },
    ["exit_sprint"] = {
        Source = "base_sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "base_sprint_in",
		Time = 1.25,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97h.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_sb2.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_weapon_antimaterial.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_masita_explosives_base.lua:
return gluapack()()
--PATH lua/weapons/arccw_meeks_sw_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt19d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_tl50.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_a280cfe.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_b1na.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dca4.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dg29.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DG-29"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DG-29 blaster pistol was a stylish and reliable heavy blaster pistol that was manufactured by Antrech Arms, a subsidiary of BlasTech Industries. It was vaunted for its reliability and ease of maintenance, and heavily resembled a slugthrower revolver."
SWEP.Trivia_Manufacturer = "Antrech Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dg29.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dg29.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 56
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 120
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dg29.wav"
SWEP.ShootSound = "kraken/sops/dg29.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.132, 0, 2.684),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, 2, 8.5),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.27, -2.6, 2.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.5, -0.1, 7.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.5, -0.1, 4.05),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.91, -1, 2.6),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_mw20.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_wookieslug.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_z5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Z5 Red Hydra"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Red Hydra Z-5 was a blaster pistol. Red Hydra pistols were once favored by officers and squad leaders in the military forces of the Quohag sector until they were decommissioned by Imperial order."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/z5.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_z5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 17
SWEP.DamageMin = 15
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/z5.wav"
SWEP.ShootSound = "kraken/sops/z5.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.989, 1.11, 3.865),
    Ang = Vector(0, 0.389, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -3, 12),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Offset = {
            vpos = Vector(0.21, -0.15, 5.95),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.7, 0.1, 2.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.75, -0.45, -1.7),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_773firepuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Republic '773 Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/firepuncher_republica.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_firepuncher_republic.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-4, 7.4, -9.5),
    ang = Angle(-30, 50, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 97
SWEP.DamageMin = 67
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.45
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 120
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.ShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.458, 0, -0.923),
    Ang = Vector(3.062, 0.4, 8.208),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2.019, 0, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "Crossair_rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.1, 28, 1.6),
                   ang = Angle(0, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.1, 2.4, 2.76),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        InstalledEles = {"muzzle_attach"},
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(0.1, 24.5, 1.6),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.1, 12, -0.1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1.1, -5, 1.4),
            vang = Angle(90, -90, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1.2, 0, 1.2),
            vang = Angle(90, -90, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25 / 30},
            {s = "kraken/sops/firepuncher/reload.wav", t = 0.1 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_md12x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_t702.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "T-702"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The T-702 sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic. It was commonly used by Alpha-Class ARC Troopers during Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/t702.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_t702.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 3
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 140
SWEP.DamageMin = 98
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 10
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilRise = 2.5
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.4
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/t702.wav"
SWEP.ShootSound = "kraken/sops/t702.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.816, -6.048, -0.009),
    Ang = Vector(2.677, -0.336, 1.039),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 40),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.13, -2.3, 5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.8, -0.9, 30),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, 0.15, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -1.3, 4),
            vang = Angle(90, 0, -75),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -1.2, -2.2),
            vang = Angle(90, 0, -75),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH lua/weapons/arccw_z4.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_config.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_pliers.lua:
SWEP.PrintName              = "Pliers"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to fix electronics"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 2
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_c17/tools_pliers01a.mdl"
SWEP.WorldModel			    = "models/props_c17/tools_pliers01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() != "cityworker_electric" then return end
    if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

    CITYWORKER.Begin( self.Owner, ent )
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 4 + ang:Up() * -2

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 90 )
    ang:RotateAroundAxis( ang:Up(), 180 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 9 + ang:Forward() * 18 + ang:Up() * -9

    ang:RotateAroundAxis( ang:Right(), 90 )
    ang:RotateAroundAxis( ang:Up(), -90 )

    return pos, ang
end
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_shovel.lua:
return gluapack()()
--PATH lua/weapons/climb_swep2/cl_init.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
AddCSLuaFile()


-- Per Person Setting

CreateClientConVar("bc2_ShowCloakCharge", 1, false, false, "")

-- Visual

CreateConVar("bc2_CloakType", "Transparent", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMode", "Timer", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakUntilVel", 75, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumVisibility", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMaterial", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeGainMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeLossMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge1", 10, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge2", 20, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge3", 30, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumNPCVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_UncloakInVehicle", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakOverlay", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumIDVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakFireMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountFire", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeFire", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakDamageMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountHurt", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeHurt", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOn", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOff", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleTime", 3, FCVAR_ARCHIVE, "")

-- Audio

CreateConVar("bc2_DistortSound", 14, FCVAR_ARCHIVE, "")
CreateConVar("bc2_EnableSound", "npc/sniper/reload1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_DisableSound", "AlyxEMP.Discharge", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ForceDisableSound", "npc/roller/mine/combine_mine_deactivate1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleFailureSound", "npc/roller/mine/combine_mine_deploy1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_FootstepVolume", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntSound", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntVolume", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntDelay", 4, FCVAR_ARCHIVE, "")

hook.Add( "PopulateToolMenu", "ce_bc2_configmenu", function()
	spawnmenu.AddToolMenuOption( "Utilities", "JustCrimson", "ce_bc2_config", "Better Cloaking Config", "", "", function( panel )
		panel:ClearControls()
		local CloakTypeBox = panel:ComboBox("Cloak Type", "bc2_CloakType")
		
		CloakTypeBox:AddChoice("Transparent")
		CloakTypeBox:AddChoice("Material")
		
		local CloakModeBox = panel:ComboBox("Cloak Mode", "bc2_CloakMode")
		CloakModeBox:AddChoice("Timer")
		CloakModeBox:AddChoice("Charge")

		panel:TextEntry("Movement Sensitivity", "bc2_CloakUntilVel"):SetNumeric(true)

		panel:TextEntry("Toggle Time", "bc2_ToggleTime"):SetNumeric(true)

		panel:NumSlider("Minimum Visibility", "bc2_MinimumVisibility", 0, 255, 0)

		panel:TextEntry("Cloak Material", "bc2_CloakMaterial")

		local SoundDistortBox = panel:ComboBox("Sound Distortion", "bc2_DistortSound")
		SoundDistortBox:AddChoice("None", 0)
		SoundDistortBox:AddChoice("Light", 14)
		SoundDistortBox:AddChoice("Medium", 15)
		SoundDistortBox:AddChoice("Heavy", 16)

		panel:TextEntry("Enable Sound", "bc2_EnableSound")
		panel:TextEntry("Disable Sound", "bc2_DisableSound")
		panel:TextEntry("Toggle Fail Sound", "bc2_ToggleFailureSound")
		panel:TextEntry("Force Disable Sound", "bc2_ForceDisableSound")


		panel:NumSlider("Visibility For NPC Target", "bc2_MinimumNPCVisibility", 0, 255, 0)
		panel:NumSlider("Visibility To Show ID", "bc2_MinimumIDVisibility", 0, 255, 0)

		panel:NumSlider("Footstep Volume", "bc2_FootstepVolume", 0, 1, 2)

		panel:CheckBox("Uncloak In Vehicle", "bc2_UncloakInVehicle")

		panel:TextEntry("Cloak Overlay", "bc2_CloakOverlay")

		local CloakShootMode = panel:ComboBox("Shooting While Cloaked Mode", "bc2_CloakFireMode")
		CloakShootMode:AddChoice("Disable Cloak", 1)
		CloakShootMode:AddChoice("Lose Charge", 2)
		CloakShootMode:AddChoice("Temp Disable", 3)
		CloakShootMode:AddChoice("Nothing", 4)

		panel:TextEntry("Shooting Lose Charge Amount", "bc2_LoseChargeAmountFire"):SetNumeric(true)
		panel:TextEntry("Shooting Temp Disable Time", "bc2_TempDisableTimeFire"):SetNumeric(true)

		panel:TextEntry("Cloak 1 Max Charge", "bc2_MaxCharge1"):SetNumeric(true)
		panel:TextEntry("Cloak 2 Max Charge", "bc2_MaxCharge2"):SetNumeric(true)
		panel:TextEntry("Cloak 3 Max Charge", "bc2_MaxCharge3"):SetNumeric(true)

		panel:TextEntry("Charge Gain Multiplier", "bc2_ChargeGainMultiplier"):SetNumeric(true)
		panel:TextEntry("Charge Loss Multiplier", "bc2_ChargeLossMultiplier"):SetNumeric(true)

		local CloakDamageMode = panel:ComboBox("Damaged While Cloaked Mode", "bc2_CloakDamageMode")
		CloakDamageMode:AddChoice("Disable Cloak", 1)
		CloakDamageMode:AddChoice("Lose Charge", 2)
		CloakDamageMode:AddChoice("Temp Disable", 3)
		CloakDamageMode:AddChoice("Nothing", 4)
		
		panel:TextEntry("Damaged Lose Charge Amount", "bc2_LoseChargeAmountHurt"):SetNumeric(true)
		panel:TextEntry("Damaged Temp Disable Time", "bc2_TempDisableTimeHurt"):SetNumeric(true)

		panel:TextEntry("Cloak Enable Effect", "bc2_CloakEffectOn")
		panel:TextEntry("Cloak Disable Effect", "bc2_CloakEffectOff")

		panel:TextEntry("Taunt Sound", "bc2_TauntSound")
		panel:NumSlider("Taunt Volume", "bc2_TauntVolume", 0, 1, 2)
		panel:TextEntry("Taunt Delay", "bc2_TauntDelay"):SetNumeric(true)

	end )
end )

cloakconfig = {}

-- Visual
cloakconfig["CloakType"] = GetConVar("bc2_CloakType"):GetString()
cloakconfig["CloakMode"] = GetConVar("bc2_CloakMode"):GetString()
cloakconfig["CloakUntilVel"] = GetConVar("bc2_CloakUntilVel"):GetInt()
cloakconfig["MinimumVisibility"] = GetConVar("bc2_MinimumVisibility"):GetInt()
cloakconfig["CloakMaterial"] = GetConVar("bc2_CloakMaterial"):GetString()
cloakconfig["ChargeGainMultiplier"] = GetConVar("bc2_ChargeGainMultiplier"):GetFloat()
cloakconfig["ChargeLossMultiplier"] = GetConVar("bc2_ChargeLossMultiplier"):GetFloat()
cloakconfig["MaxCharge0"] = 0
cloakconfig["MaxCharge1"] = GetConVar("bc2_MaxCharge1"):GetInt()
cloakconfig["MaxCharge2"] = GetConVar("bc2_MaxCharge2"):GetInt()
cloakconfig["MaxCharge3"] = GetConVar("bc2_MaxCharge3"):GetInt()
cloakconfig["MinimumNPCVisibility"] = GetConVar("bc2_MinimumNPCVisibility"):GetInt()
cloakconfig["UncloakInVehicle"] = GetConVar("bc2_UncloakInVehicle"):GetBool()
cloakconfig["CloakOverlay"] = GetConVar("bc2_CloakOverlay"):GetString()
cloakconfig["MinimumIDVisibility"] = GetConVar("bc2_MinimumIDVisibility"):GetInt()
cloakconfig["CloakFireMode"] = GetConVar("bc2_CloakFireMode"):GetInt()
cloakconfig["LoseChargeAmountFire"] = GetConVar("bc2_LoseChargeAmountFire"):GetFloat()
cloakconfig["TempDisableTimeFire"] = GetConVar("bc2_TempDisableTimeFire"):GetFloat()
cloakconfig["CloakDamageMode"] = GetConVar("bc2_CloakDamageMode"):GetInt()
cloakconfig["LoseChargeAmountHurt"] = GetConVar("bc2_LoseChargeAmountHurt"):GetFloat()
cloakconfig["TempDisableTimeHurt"] = GetConVar("bc2_TempDisableTimeHurt"):GetFloat()
cloakconfig["CloakEffectOn"] = GetConVar("bc2_CloakEffectOn"):GetString()
cloakconfig["CloakEffectOff"] = GetConVar("bc2_CloakEffectOff"):GetString()
cloakconfig["ToggleTime"] = GetConVar("bc2_ToggleTime"):GetFloat()
-- Audio
cloakconfig["DistortSound"] = GetConVar("bc2_DistortSound"):GetInt()
cloakconfig["EnableSound"] = GetConVar("bc2_EnableSound"):GetString()
cloakconfig["DisableSound"] = GetConVar("bc2_DisableSound"):GetString()
cloakconfig["ForceDisableSound"] = GetConVar("bc2_ForceDisableSound"):GetString()
cloakconfig["ToggleFailureSound"] = GetConVar("bc2_ToggleFailureSound"):GetString()
cloakconfig["FootstepVolume"] = GetConVar("bc2_FootstepVolume"):GetFloat()
cloakconfig["TauntSound"] = GetConVar("bc2_TauntSound"):GetString()
cloakconfig["TauntVolume"] = GetConVar("bc2_TauntVolume"):GetFloat()
cloakconfig["TauntDelay"] = GetConVar("bc2_TauntDelay"):GetFloat()




for k,v in pairs(cloakconfig) do
    cvars.AddChangeCallback(k, function(convarName, oldValue, newValue) 

            tableCV[convarName] = newValue


    end)
end
--PATH lua/weapons/gmod_tool/stools/ledscreen.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/weapons/gmod_tool/stools/pcasino_creator.lua:
TOOL.Category = "pCasino"
TOOL.Name = "#tool.pcasino_creator.name"
TOOL.Command = nil
TOOL.Information = {
	{name = "left"},
	{name = "right"},
	{name = "reload"}
} 


if CLIENT then
	language.Add("tool.pcasino_creator.name", "Entity Creation")
	language.Add("tool.pcasino_creator.desc", "Used to place all the pCasino entities.")

    language.Add("tool.pcasino_creator.left", "Place the configured entity.")
    language.Add("tool.pcasino_creator.right", "Open the menu to configure an entity.")
    language.Add("tool.pcasino_creator.reload", "Remove the entity permanently.")
end

local cooldown = 0
local currentEnt
local offset = {
	["pcasino_slot_machine"] = function(ent) return Vector(0, 0, 48) end,
	["pcasino_roulette_table"] = function(ent) return Vector(0, 0, 20) end,
	["pcasino_blackjack_table"] = function(ent) return Vector(0, 0, 22) end,
	["pcasino_wheel_slot_machine"] = function(ent) return Vector(0, 0, 44) end,
	["pcasino_mystery_wheel"] = function(ent) return Vector(0, 0, 61) end,
	["pcasino_sign_plaque"] = function(ent) return ent:GetForward() * 4 end,
	["pcasino_sign_stand"] = function(ent) return Vector(0, 0, 27) end,
	["pcasino_sign_wall_logo"] = function(ent) return ent:GetForward() * 6 end,
	["pcasino_sign_interior_standing"] = function(ent) return Vector(0, 0, 29	) end,
	["pcasino_sign_interior_wall"] = function(ent) return ent:GetForward() * 2.5 end,
	["pcasino_chair"] = function(ent) return Vector(0, 0, 26) end,
	["pcasino_prize_plinth"] = function(ent) return Vector(0, 0, 0) end,
	["pcasino_npc"] = function(ent) return Vector(0, 0, 1) end
}
local ang = {
	["pcasino_chair"] = function(ent) return Angle(0, 180, 0) end
}

function TOOL:LeftClick(trace)
	if SERVER then return end
	if PerfectCasino.Cooldown.Check("ToolGun:Cooldown", 1) then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	if not PerfectCasino.UI.CurrentSettings.Entity then
		PerfectCasino.Core.Msg(PerfectCasino.Translation.ToolGun.NoEntity)
		return
	end

	if cooldown > CurTime() then return end
	cooldown = CurTime() + 1

	plyAngle = LocalPlayer():GetAngles()
	net.Start("pCasino:ToolGun:CreateEntity")
		net.WriteString(PerfectCasino.UI.CurrentSettings.Entity)
		net.WriteTable(PerfectCasino.UI.CurrentSettings.Settings)
		net.WriteVector(trace.HitPos + plyAngle:Forward() + plyAngle:Up() + (offset[PerfectCasino.UI.CurrentSettings.Entity] and offset[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or vector_origin))
		net.WriteAngle(Angle(0, math.Round(plyAngle.y/10)*10 + 180, plyAngle.z) + (ang[PerfectCasino.UI.CurrentSettings.Entity] and ang[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or angle_zero))
	net.SendToServer()
end

function TOOL:RightClick(trace)
	if SERVER then return end
	if PerfectCasino.Cooldown.Check("ToolGun:Cooldown", 1) then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	if cooldown > CurTime() then return end
	cooldown = CurTime() + 1
	PerfectCasino.UI.Config()
end

function TOOL:Reload(trace)
	if CLIENT then return end
	if not PerfectCasino.Core.Access(self:GetOwner()) then return end
	local entity = trace.Entity
	if not entity.DatabaseID then return end
	PerfectCasino.Database.DeleteEntityByID(entity.DatabaseID)
	entity:Remove()
end

concommand.Add("pcasino_remove_ent", function(ply)
	if CLIENT then return end
	if not PerfectCasino.Core.Access(ply) then return end
	local entity = ply:GetEyeTrace().Entity
	if not entity.DatabaseID then return end
	PerfectCasino.Database.DeleteEntityByID(entity.DatabaseID)
	entity:Remove()
end)

concommand.Add("pcasino_update_pos", function(ply)
	if CLIENT then return end
	if not IsValid(ply) then return end
	if not PerfectCasino.Core.Access(ply) then return end

	PerfectCasino.Database.UpdateAllPositions()
end)


function TOOL:Think()
	if SERVER then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	if not PerfectCasino.UI.CurrentSettings.Entity then
		if IsValid(currentEnt) then currentEnt:Remove() end
		return
	end

	if not IsValid(currentEnt) then
		currentEnt = ents.CreateClientProp()
		currentEnt:SetModel(PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model)
		currentEnt:SetMaterial("models/wireframe")
		currentEnt:Spawn()
	end
	if not (currentEnt:GetModel() == PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model) then
		currentEnt:SetModel(PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model)
	end
	trace = LocalPlayer():GetEyeTrace()
	plyAngle = LocalPlayer():GetAngles()
	currentEnt:SetPos(trace.HitPos + plyAngle:Forward() + plyAngle:Up() + (offset[PerfectCasino.UI.CurrentSettings.Entity] and offset[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or vector_origin))
	currentEnt:SetAngles(Angle(0, math.Round(plyAngle.y/10)*10 + 180, plyAngle.z) + (ang[PerfectCasino.UI.CurrentSettings.Entity] and ang[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or angle_zero))
end

function TOOL:Holster()
	if IsValid(currentEnt) then
		currentEnt:Remove()
		currentEnt = nil
	end
end

local darBack = Color(0, 0, 0, 240)
local red = Color(200, 0, 0)
function TOOL:DrawHUD()
	if not FPP then return end
	
	local ent = self.Owner:GetEyeTrace().Entity
	if not IsValid(ent) then return end
	if not PerfectCasino.Core.Entites[ent:GetClass()] then return end
	if FPP.canTouchEnt(self.Owner:GetEyeTrace().Entity, "Toolgun") then return end
	
	draw.RoundedBox(0, 0, ScrH()*0.5-50, ScrW(), 100, darBack)
	draw.SimpleText(PerfectCasino.Translation.ToolGun.DeletePermissions, "pCasino.Main.Static", ScrW()*0.5, ScrH()*0.5, red, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	draw.SimpleText(PerfectCasino.Translation.ToolGun.FPPCheck, "pCasino.Nav.Static", ScrW()*0.5, ScrH()*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
end
--PATH lua/weapons/gmod_tool/stools/permaprops.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/shareprops.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/streamradio_gui_skin.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_npcrelationship.lua:
TOOL.Name = "#tool.vjstool_npcrelationship.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
	{name = "reload"},
}

//TOOL.ClientConVar["playerinteract"] = 1
TOOL.ClientConVar["allytoplyallies"] = 1

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_npcrelationship_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_Relationship(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150,25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k,v in pairs(DefaultConVars) do
				if v == "" then
				LocalPlayer():ConCommand(k.." ".."None")
			else
				LocalPlayer():ConCommand(k.." "..v) end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcrelationship")
					GetPanel:ClearControls()
					DoBuildCPanel_Relationship(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)

		local tutorial = vgui.Create("DButton")
		tutorial:SetFont("DermaDefaultBold")
		tutorial:SetText("#tool.vjstool.menu.tutorialvideo")
		tutorial:SetSize(150, 20)
		tutorial:SetColor(Color(0,0,255,255))
		tutorial.DoClick = function()
			gui.OpenURL("http://www.youtube.com/watch?v=SnuQU8Sc4cg")
		end
		Panel:AddPanel(tutorial)

		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		Panel:ControlHelp("#tool.vjstool_npcrelationship.label1")
		
		VJ_NPCRELATION_TblCurrentValues = VJ_NPCRELATION_TblCurrentValues or {}
		local CheckList = vgui.Create("DListView")
			CheckList:SetTooltip(false)
			//CheckList:Center() -- No need since Size does it already
			CheckList:SetSize( 100, 300 ) -- Size
			CheckList:SetMultiSelect(false)
			CheckList:AddColumn("#tool.vjstool_npcrelationship.header")
			CheckList.OnRowSelected = function(rowIndex,row) chat.AddText(Color(0,255,0),"Double click to ",Color(255,100,0),"remove ",Color(0,255,0),"a class") end
			function CheckList:DoDoubleClick(lineID,line)
				chat.AddText(Color(255,100,0)," "..line:GetValue(1).." ",Color(0,255,0),"removed!")
				CheckList:RemoveLine(lineID)
				table.Empty(VJ_NPCRELATION_TblCurrentValues)
				for _,vLine in pairs(CheckList:GetLines()) do
					table.insert(VJ_NPCRELATION_TblCurrentValues,vLine:GetValue(1))
				end
			end
		Panel:AddItem(CheckList)
		for _,v in pairs(VJ_NPCRELATION_TblCurrentValues) do
			CheckList:AddLine(v)
		end
		
		local function InsertToTable(val)
			if string.len(val) > 0 then
				val = string.upper(val)
				if VJ_HasValue(VJ_NPCRELATION_TblCurrentValues,val) then
					chat.AddText(Color(220,20,60),"ERROR! ",Color(255,100,0),val.." ",Color(220,20,60),"already exists in the table!")
				else
					chat.AddText(Color(0,255,0),"Added",Color(255,100,0)," "..val.." ",Color(0,255,0),"to the class list!")
					table.insert(VJ_NPCRELATION_TblCurrentValues,val)
					timer.Simple(0.05,function()
						GetPanel = controlpanel.Get("vjstool_npcrelationship")
						GetPanel:ClearControls()
						DoBuildCPanel_Relationship(GetPanel)
					end)
				end
			end
		end
		local TextEntry = vgui.Create("DTextEntry")
		//TextEntry:SetText("Press enter to add class...")
		TextEntry.OnEnter = function()
			InsertToTable(TextEntry:GetValue())
		end
		Panel:AddItem(TextEntry)
		Panel:ControlHelp("#tool.vjstool_npcrelationship.label2")
		
		local button = vgui.Create("DButton")
		button:SetFont("DermaDefaultBold")
		button:SetText("#tool.vjstool_npcrelationship.button.combine")
		button:SetSize(50,20)
		button:SetColor(Color(0,0,0,255))
		button.DoClick = function()
			InsertToTable("CLASS_COMBINE")
		end
		Panel:AddPanel(button)
		
		button = vgui.Create("DButton")
		button:SetFont("DermaDefaultBold")
		button:SetText("#tool.vjstool_npcrelationship.button.antlion")
		button:SetSize(50,20)
		button:SetColor(Color(0,0,0,255))
		button.DoClick = function()
			InsertToTable("CLASS_ANTLION")
		end
		Panel:AddPanel(button)
		
		button = vgui.Create("DButton")
		button:SetFont("DermaDefaultBold")
		button:SetText("#tool.vjstool_npcrelationship.button.zombie")
		button:SetSize(50,20)
		button:SetColor(Color(0,0,0,255))
		button.DoClick = function()
			InsertToTable("CLASS_ZOMBIE")
		end
		Panel:AddPanel(button)
		
		button = vgui.Create("DButton")
		button:SetFont("DermaDefaultBold")
		button:SetText("#tool.vjstool_npcrelationship.button.player")
		button:SetSize(50,20)
		button:SetColor(Color(0,0,0,255))
		button.DoClick = function()
			InsertToTable("CLASS_PLAYER_ALLY")
		end
		Panel:AddPanel(button)
		Panel:AddControl("Checkbox", {Label = "#tool.vjstool_npcrelationship.togglealliedply", Command = "vjstool_npcrelationship_allytoplyallies"})
		Panel:ControlHelp(language.GetPhrase("#tool.vjstool_npcrelationship.label3").." CLASS_PLAYER_ALLY")
		
		//Panel:AddControl("Label", {Text = "For PLAYER entities Only:"})
		//Panel:AddControl("Checkbox", {Label = "Make NPCs interact with friendly player", Command = "vjstool_npcspawner_playerinteract"})
		//Panel:ControlHelp("Make NPCs be able to interact with friendly player, such follow when pressed E or get out of their way")
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_Relationship(Panel)
	end
	
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcrelationship_cl_select", function(len, ply)
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcrelationship" then
			//local ent = net.ReadEntity()
			local entname = net.ReadString()
			//local hasclasstbl = net.ReadBool()
			local classtbl = net.ReadTable()
			chat.AddText(Color(0,255,0),"Obtained",Color(255,100,0)," "..entname.."'s ",Color(0,255,0),"relationship class list!")
			//print(ent)
			//print(hasclasstbl)
			//PrintTable(classtbl)
			//print(#classtbl)
			VJ_NPCRELATION_TblCurrentValues = classtbl
			timer.Simple(0.05,function()
				GetPanel = controlpanel.Get("vjstool_npcrelationship")
				GetPanel:ClearControls()
				DoBuildCPanel_Relationship(GetPanel)
			end)
		end
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcrelationship_cl_leftclick", function(len, ply)
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcrelationship" then
			local ent = net.ReadEntity()
			local entname = net.ReadString()
			local clicktype = net.ReadString()
			local allynum = net.ReadFloat()
			if clicktype == "ReloadClick" then entname = "Yourself" end
			chat.AddText(Color(0,255,0),"#tool.vjstool_npcrelationship.print.applied",Color(255,100,0)," "..entname)
			net.Start("vj_npcrelationship_sr_leftclick")
			net.WriteEntity(ent)
			//net.WriteTable(self)
			//net.WriteString(clicktype)
			net.WriteTable(VJ_NPCRELATION_TblCurrentValues)
			net.WriteFloat(allynum)
			net.SendToServer()
		end
	end)
else
	util.AddNetworkString("vj_npcrelationship_cl_select")
	util.AddNetworkString("vj_npcrelationship_cl_leftclick")
	util.AddNetworkString("vj_npcrelationship_sr_leftclick")
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcrelationship_sr_leftclick", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcrelationship" then
			local ent = net.ReadEntity()
			//local clicktype = net.ReadString()
			local classtbl = net.ReadTable()
			local allynum = net.ReadFloat()
			if #classtbl > 0 then
				ent.VJ_NPC_Class = classtbl
				if ent.IsVJBaseSNPC == true then
					if table.HasValue(classtbl,"CLASS_PLAYER_ALLY") then
						if allynum == 1 then ent.FriendsWithAllPlayerAllies = true end
						ent.PlayerFriendly = true
					else
						ent.PlayerFriendly = false
					end
				end
			else
				ent.VJ_NPC_Class = {nil}
				ent.PlayerFriendly = false
			end
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	local ent = tr.Entity
	if IsValid(ent) && ent:IsPlayer() or ent:IsNPC() then
		local entname = ent:GetName()
		if entname == "" then entname = ent:GetClass() end
		net.Start("vj_npcrelationship_cl_leftclick")
		net.WriteEntity(ent)
		net.WriteString(entname)
		net.WriteString("LeftClick")
		net.WriteFloat(self:GetClientNumber("allytoplyallies"))
		net.Send(self:GetOwner())
		return true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	local ent = tr.Entity
	if IsValid(ent) && ent:IsPlayer() or ent:IsNPC() then
		//local hasclasstbl = false
		local classtbl = {nil}
		local entname = ent:GetName()
		if entname == "" then entname = ent:GetClass() end
		if (ent.VJ_NPC_Class) then
			//hasclasstbl = true
			//classtbl = ent.VJ_NPC_Class
			for _,v in ipairs(ent.VJ_NPC_Class) do
				table.insert(classtbl,v)
			end
			//if (classtbl.BaseClass) then table.remove(classtbl,BaseClass) end
		end
		//PrintTable(ent.VJ_NPC_Class)
		net.Start("vj_npcrelationship_cl_select")
		//net.WriteEntity(ent)
		net.WriteString(entname)
		//net.WriteBool(hasclasstbl)
		net.WriteTable(classtbl)
		net.Send(self:GetOwner())
		return true
	end
	/*	local trent = tr.Entity
		trent:SetHealth(self:GetClientNumber("health"))
		if tr.Entity:IsNPC() then
			if self:GetClientNumber("godmode") == 1 then trent.GodMode = true else trent.GodMode = false end
		end
		return true
	end*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	net.Start("vj_npcrelationship_cl_leftclick")
	net.WriteEntity(self:GetOwner())
	net.WriteString("Me")
	net.WriteString("ReloadClick")
	net.Send(self:GetOwner())
	return true
end
--PATH lua/weapons/jet_mk4.lua:
return gluapack()()
--PATH lua/weapons/jet_mk5.lua:
return gluapack()()
--PATH lua/weapons/jet_mk6.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jetpack Infinite Fuel"
SWEP.Category	= "Star Wars Jetpacks"
SWEP.Purpose    = "LMB - Equip/Unequip\n\nSPACE - Fly up\n\nCTRL - Fly down\n\nSHIFT - Hover"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		if (ply.LastJetExecuted or 0)+1 >= CurTime() then return end
		local jp = ents.Create('mk6')
		jp:SetSlotName('mk6')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('buttons/button16.wav')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15x.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Training DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_training.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 1
SWEP.RangeMin = 102
SWEP.DamageMin = 1
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(255, 145, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 174, 0)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17ext.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m_sniper.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc19.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/weapons/mvp_perfecthands.lua:
return gluapack()()
--PATH lua/weapons/nmg_eksoan_class_4ts_power_gen_bag.lua:
return gluapack()()
--PATH lua/weapons/repair_tool.lua:

SWEP.PrintName = "Repair Tool"
SWEP.Author = "Liam0102"
SWEP.Purpose = "Repair Star Wars Vehicles"
SWEP.Instructions = "Left Click to Repair"
SWEP.Category = "Star Wars"
SWEP.Base = "weapon_base"
SWEP.Slot = 3
SWEP.SlotPos = 5
SWEP.DrawAmmo	= false
SWEP.DrawCrosshair = true
SWEP.ViewModel = "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.AnimPrefix = "python"
SWEP.HoldType = "pistol"
SWEP.Spawnable = false
SWEP.AdminSpawnable = false
list.Set("SWVehicles.Weapons", SWEP.PrintName, SWEP);

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true;
SWEP.Primary.Ammo	= "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW); -- Animation

	return true
end

function SWEP:Initialize()
	self.Weapon:SetWeaponHoldType(self.HoldType)
end

if CLIENT then
	
	function SWEP:Initialize()
		surface.CreateFont( "REPAIR_Health", {
			font = "Arial",
			size = 32,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = true,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = false,
			additive = false,
			outline = true,
		} )
		self.Weapon:SetWeaponHoldType(self.HoldType)
	end
	
	local veh_Health = 0;
	local veh_StartHealth = 0;
	local shouldDraw = false;
	local Weapon;
	function SWEP:Think()
		local p = LocalPlayer();
		Weapon = self;
		veh_Health, veh_StartHealth = self:GetVehicleHealth();

	end

	local function RepairToolHUD()
		local p = LocalPlayer()
		if(veh_Health == nil or veh_StartHealth == nil) then return end;
		if(veh_Health > 0 and (p:GetActiveWeapon() == Weapon) and veh_StartHealth > 0) then
			surface.SetTextColor(255,255,255,255);
			surface.SetFont( "REPAIR_Health" )
			surface.SetTextPos(ScrW()/10*9,ScrH()/10*9);
			surface.DrawText("Hull: " .. (math.Round(veh_Health / veh_StartHealth * 100)) .. "%")
		end
	end

	hook.Add("HUDPaint", "RepairToolHUD", RepairToolHUD)


	function SWEP:GetVehicleHealth()
		local p = LocalPlayer();
		local EyeTrace = p:GetEyeTrace();
		if(EyeTrace.Hit) then
			if(IsValid(EyeTrace.Entity)) then
				local e = EyeTrace.Entity;
				local class = e:GetClass();
				if(GetStarWarsVehicle(class) or e.IsSWVehicle) then
					return e:GetNWInt("Health"), e.StartHealth;
				end
			end
		end
		return 0,0;
	end

end

function GetStarWarsVehicle(veh)
    
    local Vehicles = list.Get("SWVehicles");
	for k,v in pairs(Vehicles) do
		if(v.ClassName == veh) then
            return true;
        end
	end
	return false;

end

if SERVER then

AddCSLuaFile()


function SWEP:Initialize()
	self:SetWeaponHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
	local EyeTrace = self.Owner:GetEyeTrace();
	if(EyeTrace.Hit) then
		if(IsValid(EyeTrace.Entity)) then
			local e = EyeTrace.Entity;
			local class = e:GetClass();
			if(GetStarWarsVehicle(class) or e.IsSWVehicle) then
				local distance = (e:GetPos() - self.Owner:GetPos()):Length();
				if(distance <= 300) then
					local Health = e:GetNWInt("Health");
					
					if(Health < e.StartHealth) then
						self:RepairEffect(EyeTrace.HitPos);
					end
					
					if(Health <= e.StartHealth - 10) then
						Health = Health + 10;
						self:RepairEffect(EyeTrace.HitPos);						
					else
						Health = e.StartHealth;
					end
					
					if(e.CriticalDamage) then
						if(Health >= Health / e.StartHealth * 10) then
							e.CriticalDamage = false;
						end
					end
					e:SetNWInt("Health",Health);
					e.VehicleHealth = Health;
					if(Health >= e.StartHealth*0.1) then
						e.CriticalDamage = false;
					end

					if(Health >= e.StartHealth*0.2) then
						e.WeaponsDisabled = false;
					end					
				end
			end
		end
	end
	return true
end

function SWEP:RepairEffect(pos)
	local fx = EffectData()
		fx:SetOrigin( pos )
	util.Effect( "StunstickImpact", fx, true )

end


end
--PATH lua/weapons/tfa_gun_base/common/utils.lua:
TFA.RangeFalloffLUTStep = 0.01
TFA.RangeFalloffLUTStepInv = 1 / TFA.RangeFalloffLUTStep

SWEP.AmmoRangeTable = {
	["SniperPenetratedRound"] = 2,
	["SniperPenetratedBullet"] = 2,
	["buckshot"] = 0.5,
	["ar2"] = 1,
	["smg1"] = 0.7,
	["pistol"] = 0.33,
	["def"] = 1
}

function SWEP:AmmoRangeMultiplier()
	return self.AmmoRangeTable[self.Primary_TFA.Ammo or "def"] or self.AmmoRangeTable["def"] or 1
end

function SWEP:MetersToUnits(x)
	return x * 39.3701 * 4 / 3
end

function SWEP:GetLastSequenceString()
	if not self:VMIV() then return "" end

	if self:GetLastSequence() < 0 then return "" end
	return self.OwnerViewModel:GetSequenceName(self:GetLastSequence())
end

local cv_3dmode = GetConVar("cl_tfa_scope_sensitivity_3d")

SWEP.SensitivtyFunctions = {
	[0] = function() return 1 end,
	[1] = function(self, ...)
		local zoom = self:GetStatL("Secondary.ScopeZoom")

		if zoom and zoom >= 1 then
			return TFA.CalculateSensitivtyScale(90 / zoom, self:GetStatL("Secondary.OwnerFOV"), self:GetStatL("Secondary.ScopeScreenScale"))
		else
			return self.SensitivtyFunctions[2](self, ...)
		end
	end,
	[2] = function(self, ...)
		local rtfov = self:GetStatL("RTScopeFOV")

		if rtfov and rtfov > 0 then
			return TFA.CalculateSensitivtyScale(rtfov, self:GetStatL("Secondary.OwnerFOV"), self:GetStatL("Secondary.ScopeScreenScale"))
		else
			return self.SensitivtyFunctions[0](self, ...)
		end
	end,
	[3] = function(self, ...)
		local rtfov = self:GetStatL("RTScopeFOV")

		if rtfov and rtfov > 0 then
			return TFA.CalculateSensitivtyScale(rtfov, self:GetStatL("Secondary.OwnerFOV"), 1)
		else
			return self.SensitivtyFunctions[0](self, ...)
		end
	end
}

function SWEP:Get3DSensitivity()
	local f = self.SensitivtyFunctions[cv_3dmode:GetInt()]

	return f(self)
end

function SWEP:GetSeed()
	local sd = math.floor(self:Clip1() + self:Ammo1() + self:Clip2() + self:Ammo2() + self:GetLastActivity()) + self:GetNextIdleAnim() + self:GetNextPrimaryFire() + self:GetNextSecondaryFire()

	return math.Round(sd)
end

function SWEP:GetSeedIrradical()
	return math.floor(self:Clip1() + self:Ammo1() + self:Clip2() + self:Ammo2() + self:GetLastActivity()) + self:GetNextIdleAnim() + self:GetNextPrimaryFire() + self:GetNextSecondaryFire()
end

SWEP.SharedRandomValues = {}
local seed

--math.random equivalent
function SWEP:SharedRandom(min, max, id)
	if min and not max then
		max = min
		min = 1
	end

	min = math.Round(min)
	max = math.Round(max)
	local key = (id or "Weapon") .. min .. max
	seed = self:GetSeed()
	local val = math.floor(util.SharedRandom(id or "Weapon", min, max + 1, seed))

	if self.SharedRandomValues[key] and self.SharedRandomValues[key] == val then
		if min < val and max > val then
			math.randomseed(seed)

			if (math.Rand(0, 1) < 0.5) then
				math.randomseed(seed + 1)
				val = math.random(min, val - 1)
			else
				math.randomseed(seed + 1)
				val = math.random(val + 1, max)
			end
		elseif min < val then
			math.randomseed(seed + 1)
			val = math.random(min, val - 1)
		elseif max > val then
			math.randomseed(seed + 1)
			val = math.random(val + 1, max)
		end
	end

	if IsFirstTimePredicted() then
		timer.Simple(0, function()
			if IsValid(self) then
				self.SharedRandomValues[key] = val
			end
		end)
	end

	return val
end

local oiv = nil
local rlcv = GetConVar("sv_tfa_reloads_enabled")
local holding_result_cached = false
local last_held_check = -1
local sp = game.SinglePlayer()
local slo, sqlo
local nm

--[[
local sqind

function SWEP:TranslateSequenceActivityTable( tbl )
	if not self:VMIV() then return end
	for k,v in pairs(tbl) do
		if type(k) == "string" then
			sqind = self.OwnerViewModel:GetSequenceActivity( self.OwnerViewModel:LookupSequence( k ) or -1 ) or -1
			tbl[ sqind ] = tbl[sqind] or v
		end
		tbl[k] = nil
	end
end
]]
--
--, seq )
function SWEP:GetActivityLengthRaw(tanim, status, animType)
	local vm = self:VMIVNPC()
	if not vm then return 0 end

	if tanim == nil then
		-- we already track last sequence so, we can account sequence
		tanim = self:GetLastSequence()
		animType = TFA.Enum.ANIMATION_SEQ
	end

	if tanim < 0 then return 0 end

	if animType == nil or animType == TFA.Enum.ANIMATION_ACT then
		nm = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
	else
		nm = vm:GetSequenceName(tanim)
	end

	local sqlen

	if animType == TFA.Enum.ANIMATION_SEQ then
		sqlen = vm:SequenceDuration(tanim)
	elseif tanim == vm:GetSequenceActivity(vm:GetSequence()) then
		sqlen = vm:SequenceDuration(vm:GetSequence())
	else
		sqlen = vm:SequenceDuration(vm:SelectWeightedSequenceSeeded(math.max(tanim or 1, 1), self:GetSeedIrradical()))
	end

	slo = self:GetStatL("StatusLengthOverride." .. nm) or self:GetStatL("StatusLengthOverride." .. (tanim or "0"))
	sqlo = self:GetStatL("SequenceLengthOverride." .. nm) or self:GetStatL("SequenceLengthOverride." .. (tanim or "0"))

	if status and slo then
		sqlen = slo
	elseif sqlo then
		sqlen = sqlo
	end

	return sqlen
end

function SWEP:GetActivityLength(tanim, status, animType)
	if not self:VMIVNPC() then return 0 end
	local sqlen = self:GetActivityLengthRaw(tanim, status, animType)
	if sqlen <= 0 then return 0 end
	return sqlen / self:GetAnimationRate(tanim)
end

function SWEP:GetHolding()
	if CurTime() > last_held_check + 0.2 then
		last_held_check = CurTime()
		holding_result_cached = nil
	end

	if holding_result_cached == nil then
		holding_result_cached = false

		if not IsValid(self:GetOwner()) or not self:GetOwner():IsPlayer() then
			holding_result_cached = false

			return false
		end

		local ent = self:GetOwner():GetNW2Entity("LastHeldEntity")

		if not IsValid(ent) then
			holding_result_cached = false

			return false
		end

		if ent.IsPlayerHolding then
			ent:SetNW2Bool("PlayerHolding", ent:IsPlayerHolding())
		end

		if ent:GetNW2Bool("PlayerHolding") then
			holding_result_cached = true

			return true
		end
	end

	return holding_result_cached
end

function SWEP:CanInterruptShooting()
	return self:GetStatL("Primary.RPM") > 160 and not self:GetStatL("BoltAction") and not self:GetStatL("BoltAction_Forced")
end

function SWEP:ReloadCV()
	if rlcv then
		if (not rlcv:GetBool()) and (not self.Primary_TFA.ClipSize_PreEdit) then
			self.Primary_TFA.ClipSize_PreEdit = self.Primary_TFA.ClipSize
			self.Primary_TFA.ClipSize = -1
			self:ClearStatCache()
		elseif rlcv:GetBool() and self.Primary_TFA.ClipSize_PreEdit then
			self.Primary_TFA.ClipSize = self.Primary_TFA.ClipSize_PreEdit
			self.Primary_TFA.ClipSize_PreEdit = nil
			self:ClearStatCache()
		end
	end
end

function SWEP:OwnerIsValid()
	if oiv == nil then
		oiv = IsValid(self:GetOwner())
	end

	return oiv
end

function SWEP:NullifyOIV()
	if oiv ~= nil then
		self:GetHolding()
		oiv = nil
	end

	return self:VMIV()
end

function SWEP:VMIVNPC()
	local ply = self:GetOwner()

	if ply:IsPlayer() then return self:VMIV() end

	if ply:IsNPC() then
		return self
	end

	return false
end

function SWEP:VMIV()
	local owent = self:GetOwner()

	if not IsValid(self.OwnerViewModel) then
		if IsValid(owent) and owent.GetViewModel then
			self.OwnerViewModel = owent:GetViewModel()
		end

		return false
	else
		if not IsValid(owent) or not owent.GetViewModel then
			self.OwnerViewModel = nil

			return false
		end

		return self.OwnerViewModel
	end
end

function SWEP:CanChamber()
	if self.C_CanChamber ~= nil then
		return self.C_CanChamber
	else
		self.C_CanChamber = not self:GetStatL("BoltAction") and not self:GetStatL("LoopedReload") and not self.Revolver and not self:GetStatL("Primary.DisableChambering")

		return self.C_CanChamber
	end
end

function SWEP:GetPrimaryClipSize(calc)
	local targetclip = self:GetStatL("Primary.ClipSize")

	if self:CanChamber() and not (calc and self:Clip1() <= 0) then
		targetclip = targetclip + (self:GetStatL("IsAkimbo") and 2 or 1)
	end

	return math.max(targetclip, -1)
end

function SWEP:GetPrimaryClipSizeForReload(calc)
	local targetclip = self:GetStatL("Primary.ClipSize")

	if self:CanChamber() and not (calc and self:Clip1() <= 0) and not self:IsJammed() then
		targetclip = targetclip + (self:GetStatL("IsAkimbo") and 2 or 1)
	end

	return math.max(targetclip, -1)
end

function SWEP:GetSecondaryClipSize(calc)
	local targetclip = self:GetStatL("Secondary.ClipSize")

	return math.max(targetclip, -1)
end

--[[

function SWEP:GetPrimaryAmmoType()
	return self:GetStatL( "Primary.Ammo" ) or ""
end

function SWEP:GetPrimaryAmmoTypeC()
	return self:GetStatL( "Primary.Ammo" ) or self:GetPrimaryAmmoType()
end

function SWEP:Ammo1()
	return self:GetOwner():GetAmmoCount( self:GetPrimaryAmmoTypeC() or 0 )
end

function SWEP:GetSecondaryAmmoType()
	return self:GetStatL( "Secondary.Ammo" ) or ""
end

function SWEP:GetSecondaryAmmoTypeC()
	return self:GetStatL( "Secondary.Ammo" ) or self:GetSecondaryAmmoType()
end

function SWEP:Ammo2()
	return self:GetOwner():GetAmmoCount( self:GetSecondaryAmmoTypeC() or -1 )
end

]]
--
local at

function SWEP:GetPrimaryAmmoTypeC()
	at = self:GetStatL("Primary.Ammo")

	if at and at ~= self.Primary_TFA.Ammo then
		return at
	elseif self.GetPrimaryAmmoTypeOld then
		return self:GetPrimaryAmmoTypeOld()
	else
		return self:GetPrimaryAmmoType()
	end
end

function SWEP:GetSecondaryAmmoTypeC()
	at = self:GetStatL("Secondary.Ammo")

	if at and at ~= self.Secondary_TFA.Ammo then
		return at
	elseif self.GetSecondaryAmmoTypeOld then
		return self:GetSecondaryAmmoTypeOld()
	else
		return self:GetSecondaryAmmoType()
	end
end

function SWEP:Ammo1()
	if not self:GetOwner():IsValid() then return 0 end
	if self:GetOwner():IsNPC() then return 9999 end

	return self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoTypeC() or 0)
end

function SWEP:Ammo2()
	if not self:GetOwner():IsValid() then return 0 end
	if self:GetOwner():IsNPC() then return 9999 end

	return self:GetOwner():GetAmmoCount(self:GetSecondaryAmmoTypeC() or -1)
end

-- Returns absolute delta of change in ammo count
function SWEP:TakePrimaryAmmo(num, pool)
	num = math.floor(num)
	if num == 0 then return 0 end

	if num < 0 then
		-- Doesn't use clips
		if self:GetStatL("Primary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return -num end -- assume NPCs always take all the ammo
			return self:GetOwner():GiveAmmo(-num, self:GetPrimaryAmmoTypeC())
		else
			local old = self:Clip1()
			local new = math.max(self:Clip1() - num, 0)
			self:SetClip1(new)
			return new - old
		end
	else
		-- Doesn't use clips
		if self:GetStatL("Primary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return num end -- assume NPCs always provide all the ammo
			local old = self:Ammo1()
			if old <= 0 then return 0 end
			local toRemove = math.min(old, num)
			self:GetOwner():RemoveAmmo(toRemove, self:GetPrimaryAmmoTypeC())
			return toRemove
		else
			local old = self:Clip1()
			local new = math.max(self:Clip1() - num, 0)
			self:SetClip1(new)
			return old - new
		end
	end
end

-- Returns absolute delta of change in ammo count
function SWEP:TakeSecondaryAmmo(num, pool)
	num = math.floor(num)
	if num == 0 then return 0 end

	if num < 0 then
		-- Doesn't use clips
		if self:GetStatL("Secondary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return -num end -- assume NPCs always take all the ammo
			return self:GetOwner():GiveAmmo(-num, self:GetSecondaryAmmoTypeC())
		else
			local old = self:Clip2()
			local new = math.max(self:Clip2() - num, 0)
			self:SetClip2(new)
			return new - old
		end
	else
		-- Doesn't use clips
		if self:GetStatL("Secondary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return num end -- assume NPCs always provide all the ammo
			local old = self:Ammo2()
			if old <= 0 then return 0 end
			local toRemove = math.min(old, num)
			self:GetOwner():RemoveAmmo(toRemove, self:GetSecondaryAmmoTypeC())
			return toRemove
		else
			local old = self:Clip2()
			local new = math.max(self:Clip2() - num, 0)
			self:SetClip2(new)
			return old - new
		end
	end
end

-- Inserts up to num ammo rounds into gun's primary clip
-- negative values will unload clip back into ammo reserve (WITHOUT accounting for max ammo reserve!)
-- Returns absolute delta of change in ammo count
function SWEP:InsertPrimaryAmmo(num)
	num = math.floor(num)
	local self2 = self:GetTable()

	if num > 0 then
		num = math.min(math.max(self:GetMaxClip1() - self:Clip1(), 0), num)
		return self2.TakePrimaryAmmo(self, -self2.TakePrimaryAmmo(self, num, true))
	end

	return self2.TakePrimaryAmmo(self, -self2.TakePrimaryAmmo(self, num, true))
end

-- Inserts up to num ammo rounds into gun's secondary clip
-- negative values will unload clip back into ammo reserve (WITHOUT accounting for max ammo reserve!)
-- Returns absolute delta of change in ammo count
function SWEP:InsertSecondaryAmmo(num)
	num = math.floor(num)
	local self2 = self:GetTable()

	if num > 0 then
		num = math.min(math.max(self:GetMaxClip2() - self:Clip2(), 0), num)
		return self2.TakeSecondaryAmmo(self, -self2.TakeSecondaryAmmo(self, num, true))
	end

	return self2.TakeSecondaryAmmo(self, -self2.TakeSecondaryAmmo(self, num, true))
end

function SWEP:IsEmpty1()
	return self:GetStatL("Primary.ClipSize") > 0 and self:Clip1() == 0 or
		self:GetStatL("Primary.ClipSize") <= 0 and self:Ammo1() == 0
end

function SWEP:IsEmpty2()
	return self:GetStatL("Secondary.ClipSize") > 0 and self:Clip2() == 0 or
		self:GetStatL("Secondary.ClipSize") <= 0 and self:Ammo2() == 0
end

SWEP.TakeAmmo1 = SWEP.TakePrimaryAmmo
SWEP.TakeAmmo2 = SWEP.TakeSecondaryAmmo

function SWEP:GetFireDelay()
	if self:GetMaxBurst() > 1 and self:GetStatL("Primary.RPM_Burst") and self:GetStatL("Primary.RPM_Burst") > 0 then
		return 60 / self:GetStatL("Primary.RPM_Burst")
	elseif self:GetStatL("Primary.RPM_Semi") and not self.Primary_TFA.Automatic and self:GetStatL("Primary.RPM_Semi") and self:GetStatL("Primary.RPM_Semi") > 0 then
		return 60 / self:GetStatL("Primary.RPM_Semi")
	elseif self:GetStatL("Primary.RPM") and self:GetStatL("Primary.RPM") > 0 then
		return 60 / self:GetStatL("Primary.RPM")
	else
		return self:GetStatL("Primary.Delay") or 0.1
	end
end

function SWEP:GetBurstDelay(bur)
	if not bur then
		bur = self:GetMaxBurst()
	end

	if bur <= 1 then return 0 end
	if self:GetStatL("Primary.BurstDelay") then return self:GetStatL("Primary.BurstDelay") end

	return self:GetFireDelay() * 3
end

local tickrate = engine.TickInterval()

function SWEP:GetNextCorrectedPrimaryFire(delay)
	local nextfire = self:GetNextPrimaryFire()
	local delta = CurTime() - nextfire

	if delta < 0 or delta > tickrate then
		nextfire = CurTime()
	end

	return nextfire + delay
end

function SWEP:GetNextCorrectedSecondaryFire(delay)
	local nextfire = self:GetNextSecondaryFire()
	local delta = CurTime() - nextfire

	if delta < 0 or delta > tickrate then
		nextfire = CurTime()
	end

	return nextfire + delay
end

--[[
Function Name:  IsSafety
Syntax: self:IsSafety().
Returns:   Are we in safety firemode.
Notes:  Non.
Purpose:  Utility
]]
--
function SWEP:IsSafety()
	if not self:GetStatL("FireModes") then return false end
	local fm = self:GetStatL("FireModes")[self:GetFireMode()]
	local fmn = string.lower(fm and fm or self:GetStatL("FireModes")[1])

	if fmn == "safe" or fmn == "holster" then
		return true
	else
		return false
	end
end

function SWEP:UpdateMuzzleAttachment()
	if not self:VMIV() then return end
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	self.MuzzleAttachmentRaw = nil

	if not self.MuzzleAttachmentSilenced then
		self.MuzzleAttachmentSilenced = (vm:LookupAttachment("muzzle_silenced") <= 0) and self.MuzzleAttachment or "muzzle_silenced"
	end

	if self:GetSilenced() and self.MuzzleAttachmentSilenced then
		self.MuzzleAttachmentRaw = vm:LookupAttachment(self.MuzzleAttachmentSilenced)

		if not self.MuzzleAttachmentRaw or self.MuzzleAttachmentRaw <= 0 then
			self.MuzzleAttachmentRaw = nil
		end
	end

	if not self.MuzzleAttachmentRaw and self.MuzzleAttachment then
		self.MuzzleAttachmentRaw = vm:LookupAttachment(self.MuzzleAttachment)

		if not self.MuzzleAttachmentRaw or self.MuzzleAttachmentRaw <= 0 then
			self.MuzzleAttachmentRaw = 1
		end
	end

	local mzm = self:GetStatL("MuzzleAttachmentMod", 0)

	if mzm then
		if isstring(mzm) then
			self.MuzzleAttachmentRaw = vm:LookupAttachment(mzm)
		elseif mzm > 0 then
			self.MuzzleAttachmentRaw = mzm
		end
	end
end

function SWEP:UpdateConDamage()
	if not IsValid(self) then return end

	if not self.DamageConVar then
		self.DamageConVar = GetConVar("sv_tfa_damage_multiplier")
	end

	if self.DamageConVar and self.DamageConVar.GetFloat then
		self.ConDamageMultiplier = self.DamageConVar:GetFloat()
	end
end

--[[
Function Name:  IsCurrentlyScoped
Syntax: self:IsCurrentlyScoped().
Returns:   Is the player scoped in enough to display the overlay?  true/false, returns a boolean.
Notes:  Change SWEP.ScopeOverlayThreshold to change when the overlay is displayed.
Purpose:  Utility
]]
--
function SWEP:IsCurrentlyScoped()
	return (self:GetIronSightsProgress() > self:GetStatL("ScopeOverlayThreshold")) and self:GetStatL("Scoped")
end

--[[
Function Name:  IsCurrently3DScoped
Syntax: self:IsCurrently3DScoped().
Returns:   Is player aiming down the sights while having a RT-enabled scope equipped?
Notes:
Purpose:  Utility
]]
--
function SWEP:IsCurrently3DScoped()
	return (self:GetStatL("RTDrawEnabled") or self.RTCode ~= nil) and self:GetIronSights()
end

--[[
Function Name:  IsHidden
Syntax: self:IsHidden().
Returns:   Should we hide self?.
Notes:
Purpose:  Utility
]]
--
function SWEP:GetHidden()
	if not self:VMIV() then return true end
	if self.DrawViewModel ~= nil and not self.DrawViewModel then return true end
	if self.ShowViewModel ~= nil and not self.ShowViewModel then return true end
	if self:GetHolding() then return true end

	return self:IsCurrentlyScoped()
end

--[[
Function Name:  IsFirstPerson
Syntax: self:IsFirstPerson().
Returns:   Is the owner in first person.
Notes:  Broken in singplayer because gary.
Purpose:  Utility
]]
--
function SWEP:IsFirstPerson()
	if not IsValid(self) or not self:OwnerIsValid() then return false end
	if self:GetOwner():IsNPC() then return false end
	if CLIENT and (not game.SinglePlayer()) and self:GetOwner() ~= GetViewEntity() then return false end
	if sp and SERVER then return not self:GetOwner().TFASDLP end
	if self:GetOwner().ShouldDrawLocalPlayer and self:GetOwner():ShouldDrawLocalPlayer() then return false end
	if LocalPlayer and hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner()) then return false end

	return true
end

--[[
Function Name:  GetMuzzlePos
Syntax: self:GetMuzzlePos( hacky workaround that doesn't work anyways ).
Returns:   The AngPos for the muzzle attachment.
Notes:  Defaults to the first attachment, and uses GetFPMuzzleAttachment
Purpose:  Utility
]]
--
local fp

function SWEP:GetMuzzleAttachment()
	local vmod = self.OwnerViewModel
	local att = math.max(1, self.MuzzleAttachmentRaw or (sp and vmod or self):LookupAttachment(self.MuzzleAttachment))

	if self:GetStatL("IsAkimbo") then
		att = 1 + self:GetAnimCycle()
	end

	return att
end

function SWEP:GetMuzzlePos(ignorepos)
	fp = self:IsFirstPerson()
	local vm = self.OwnerViewModel

	if not IsValid(vm) then
		vm = self
	end

	-- Avoid returning strings inside MuzzleAttachmentMod, since this would decrease performance
	-- Better call :UpdateMuzzleAttachment() or return number in MuzzleAttachmentMod
	local obj = self:GetStatL("MuzzleAttachmentMod") or self.MuzzleAttachmentRaw or vm:LookupAttachment(self.MuzzleAttachment)

	if type(obj) == "string" then
		obj = tonumber(obj) or vm:LookupAttachment(obj)
	end

	local muzzlepos
	obj = math.Clamp(obj or 1, 1, 128)

	if fp then
		muzzlepos = vm:GetAttachment(obj)
	else
		muzzlepos = self:GetAttachment(obj)
	end

	return muzzlepos
end

function SWEP:FindEvenBurstNumber()
	local burstOverride = self:GetStatL("BurstFireCount")

	if burstOverride then
		return burstOverride
	end

	if (self:GetStatL("Primary.ClipSize") % 3 == 0) then
		return 3
	elseif (self:GetStatL("Primary.ClipSize") % 2 == 0) then
		return 2
	else
		local i = 4

		while i <= 7 do
			if self:GetStatL("Primary.ClipSize") % i == 0 then return i end
			i = i + 1
		end
	end

	return nil
end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower(self:GetStatL("FireModes")[fm])
	if fmn == "safe" or fmn == "holster" then return language.GetPhrase("tfa.firemode.safe") end
	if self:GetStatL("FireModeName") then return language.GetPhrase(self:GetStatL("FireModeName")) end
	if fmn == "auto" or fmn == "automatic" then return language.GetPhrase("tfa.firemode.auto") end

	if fmn == "semi" or fmn == "single" then
		if self:GetStatL("Revolver") then
			if (self:GetStatL("BoltAction")) then
				return language.GetPhrase("tfa.firemode.single")
			else
				return language.GetPhrase("tfa.firemode.revolver")
			end
		else
			if (self:GetStatL("BoltAction")) then
				return language.GetPhrase("tfa.firemode.bolt")
			else
				if self:GetStatL("LoopedReload") and self:GetStatL("Primary.RPM") < 250 then
					return language.GetPhrase("tfa.firemode.pump")
				else
					return language.GetPhrase("tfa.firemode.semi")
				end
			end
		end
	end

	local bpos = string.find(fmn, "burst")
	if bpos then return language.GetPhrase("tfa.firemode.burst"):format(string.sub(fmn, 1, bpos - 1)) end

	return ""
end

SWEP.BurstCountCache = {}

function SWEP:GetMaxBurst()
	local fm = self:GetFireMode()

	if not self.BurstCountCache[fm] then
		local fmt = self:GetStatL("FireModes")
		local fmn = string.lower(fmt[fm])
		local bpos = string.find(fmn, "burst")

		if bpos then
			self.BurstCountCache[fm] = tonumber(string.sub(fmn, 1, bpos - 1))
		else
			self.BurstCountCache[fm] = 1
		end
	end

	return self.BurstCountCache[fm]
end

--[[
Function Name:  CycleFireMode
Syntax: self:CycleFireMode()
Returns:  Nothing.
Notes: Cycles to next firemode.
Purpose:  Feature
]]
--
local l_CT = CurTime

SWEP.FireModesAutomatic = {
	["Automatic"] = true,
	["Auto"] = true,
}

SWEP.FireModeSound = Sound("Weapon_AR2.Empty") -- firemode toggle sound

function SWEP:CycleFireMode()
	local ct = l_CT()
	local fm = self:GetFireMode()
	fm = fm + 1

	if fm >= #self:GetStatL("FireModes") then
		fm = 1
	end

	self:SetFireMode(fm)
	local success, tanim, ttype = self:ChooseROFAnim()

	if success then
		self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
	else
		self:EmitSound(self:GetStatL("FireModeSound"))
		self:SetNextPrimaryFire(ct + math.max(self:GetFireDelay(), 0.25))
	end

	self.BurstCount = 0
	self:SetIsCyclingSafety(false)
	self:SetStatus(TFA.Enum.STATUS_FIREMODE, self:GetNextPrimaryFire())

	self.Primary.Automatic = self:IsFireModeAutomatic(fm)
	self.Primary_TFA.Automatic = self.Primary.Automatic
end

--[[
Function Name:  CycleSafety
Syntax: self:CycleSafety()
Returns:  Nothing.
Notes: Toggles safety
Purpose:  Feature
]]
--
function SWEP:CycleSafety()
	local ct = l_CT()
	local fm = self:GetFireMode()
	local fmt = self:GetStatL("FireModes")

	self.BurstCount = 0
	self:SetIsCyclingSafety(true)
	self:SetIronSightsRaw(false)

	if fm ~= #fmt then
		self.LastFireMode = fm
		self:SetFireMode(#fmt)
	else
		self:SetFireMode(self.LastFireMode or 1)
	end

	local success, tanim, ttype = self:ChooseROFAnim()

	if success then
		self:SetSafetyCycleAnimated(true)
		self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
	else
		self:SetSafetyCycleAnimated(false)
		self:EmitSound(self:GetStatL("FireModeSound"))
		self:SetNextPrimaryFire(ct + math.max(self:GetFireDelay(), 0.25))
	end

	self:SetStatus(TFA.Enum.STATUS_FIREMODE, self:GetNextPrimaryFire())

	if self:IsSafety() then
		self.Primary.Automatic = false
		self.Primary_TFA.Automatic = false
	else
		self.Primary.Automatic = self:IsFireModeAutomatic()
		self.Primary_TFA.Automatic = self.Primary.Automatic
	end
end

--[[
Function Name:  1FireMode
Syntax: self:ProcessFireMode()
Returns:  Nothing.
Notes: Processes fire mode changing and whether the swep is auto or not.
Purpose:  Feature
]]
--
function SWEP:ProcessFireMode()
	if self:GetOwner():IsNPC() then return end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_firemode", 0) > 0 then
		return
	end

	if self:OwnerIsValid() and self:KeyPressed(IN_RELOAD) and self:KeyDown(IN_USE) and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetStatL("SelectiveFire") and not self:KeyDown(IN_SPEED) then
			self:CycleFireMode()
		elseif self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
		end
	end
end

--[[
Function Name:  Unload
Syntax: self:Unload()
Returns:  Nothing.
Notes: Returns Clip1 ammo to reserve.
Purpose:  Utility
]]
--
function SWEP:Unload()
	local amm = self:Clip1()
	self:SetClip1(0)

	if self.OwnerIsValid and self:OwnerIsValid() and self.Owner.GiveAmmo then
		self:GetOwner():GiveAmmo(amm, self:GetPrimaryAmmoType(), true)
	end
end

--[[
Function Name:  Unload
Syntax: self:Unload()
Returns:  Nothing.
Notes: Returns Clip1 ammo to reserve.
Purpose:  Utility
]]
--
function SWEP:Unload2()
	local amm = self:Clip2()
	self:SetClip2(0)

	if self.OwnerIsValid and self:OwnerIsValid() and self.Owner.GiveAmmo then
		self:GetOwner():GiveAmmo(amm, self:GetSecondaryAmmoType(), true)
	end
end

local penetration_hitmarker_cvar = GetConVar("sv_tfa_penetration_hitmarker")

function SWEP:SendHitMarker(ply, traceres, dmginfo)
	if CLIENT or not penetration_hitmarker_cvar:GetBool() then return end
	if not IsValid(ply) or not ply:IsPlayer() then return end

	local hm3d = ply:GetInfoNum("cl_tfa_hud_hitmarker_3d_all", 0) > 0
	local hm3d_sg = ply:GetInfoNum("cl_tfa_hud_hitmarker_3d_shotguns", 0) > 0 and self:GetStatL("Primary.NumShots") > 1

	if hm3d or hm3d_sg then
		net.Start("tfaHitmarker3D", true)
		net.WriteVector(traceres.HitPos)
		net.Send(ply)
	else
		net.Start("tfaHitmarker", true)
		net.Send(ply)
	end
end

SWEP.VMSeqCache = {}
local vm -- are you fucking kidding me

function SWEP:CheckVMSequence(seqname)
	if not IsValid(self) then return false end
	vm = self.OwnerViewModel
	if not IsValid(vm) then return false end
	local mdl = vm:GetModel()
	if not mdl then return false end
	self.VMSeqCache[mdl] = self.VMSeqCache[mdl] or {}

	if self.VMSeqCache[mdl][seqname] == nil then
		self.VMSeqCache[mdl][seqname] = vm:LookupSequence(seqname) >= 0
	end

	return self.VMSeqCache[mdl][seqname]
end

do
	local function sorter(a, b)
		return a.range < b.range
	end

	local function linear(a) return a end

	function SWEP:BuildFalloffTable(input, step)
		if step == nil then step = TFA.RangeFalloffLUTStep end

		table.sort(input.lut, sorter)

		if input.lut[1].range > 0 then
			for i = #input.lut, 1, -1 do
				input.lut[i + 1] = input.lut[i]
			end

			input.lut[1] = {range = 0, damage = 1}
		end

		local div = (input.units == "hammer" or input.units == "inches" or input.units == "inch" or input.units == "hu") and 1 or 0.0254

		local build = {}
		local minimal = input.lut[1].range
		local maximal = input.lut[#input.lut].range

		local fnrange = isfunction(input.range_func) and input.range_func or
			input.range_func == "quintic" and TFA.Quintic or
			input.range_func == "cubic" and TFA.Cubic or
			input.range_func == "cosine" and TFA.Cosine or
			input.range_func == "sinusine" and TFA.Sinusine or
			linear

		if input.bezier then
			local build_range = {}
			local build_damage = {}

			for _, data in ipairs(input.lut) do
				table.insert(build_range, data.range / div)
				table.insert(build_damage, data.damage)
			end

			for i = 0, 1, step do
				local value = fnrange(i)
				table.insert(build, {TFA.tbezier(value, build_range), TFA.tbezier(value, build_damage)})
			end
		else
			local current, next = input.lut[1], input.lut[2]
			local nextindex = 1

			for i = 0, 1, step do
				local value = fnrange(i)
				local interp = Lerp(value, minimal, maximal)

				if next.range < interp then
					nextindex = nextindex + 1
					current, next = input.lut[nextindex], input.lut[nextindex + 1]
				end

				if not current or not next then break end -- safeguard
				table.insert(build, {interp / div, Lerp(1 - (next.range - interp) / (next.range - current.range), current.damage, next.damage)})
			end
		end

		return build
	end
end

function SWEP:IncreaseRecoilLUT()
	if not self:HasRecoilLUT() then return end

	local self2 = self:GetTable()
	local time = CurTime()

	if not self:GetRecoilThink() then
		self:SetRecoilThink(true)
	end

	if not self:GetRecoilLoop() then
		local newvalue = self:GetRecoilInProgress() + self2.Primary_TFA.RecoilLUT["in"].increase

		self:SetRecoilInProgress(math.min(1, newvalue))

		self:SetRecoilInWait(time + self2.Primary_TFA.RecoilLUT["in"].wait)

		if self:GetRecoilInProgress() >= 1 then
			self:SetRecoilLoop(true)
			self:SetRecoilLoopProgress(math.Clamp(newvalue % 1, 0, 1))
			self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)
		end

		return
	end

	local sub = 0

	if self:GetRecoilOutProgress() ~= 0 then
		local prev = self:GetRecoilOutProgress()
		local newvalue = math.max(0, prev - self2.Primary_TFA.RecoilLUT["out"].increase)
		self:SetRecoilOutProgress(newvalue)
		self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)

		if newvalue ~= 0 then
			return
		end

		sub = self2.Primary_TFA.RecoilLUT["out"].increase - prev
	end

	local newvalue = (self:GetRecoilLoopProgress() + self2.Primary_TFA.RecoilLUT["loop"].increase + sub) % 1
	self:SetRecoilLoopProgress(newvalue)
	self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)
end

function SWEP:HasRecoilLUT()
	return self.Primary_TFA.RecoilLUT ~= nil
end

do
	local function linear(a) return a end

	local function getfn(input)
		return isfunction(input.func) and input.func or
			input.func == "quintic" and TFA.Quintic or
			input.func == "cubic" and TFA.Cubic or
			input.func == "cosine" and TFA.Cosine or
			input.func == "sinusine" and TFA.Sinusine or
			linear
	end

	function SWEP:GetRecoilLUTAngle()
		if not self:GetRecoilThink() then
			return Angle()
		end

		local self2 = self:GetTable()
		local isp = 1 - self:GetIronSightsProgress() * self2.GetStatL(self, "Primary.RecoilLUT_IronSightsMult")

		if not self:GetRecoilLoop() then
			-- currently, we only playing IN animation

			local t = getfn(self2.Primary_TFA.RecoilLUT["in"])(self:GetRecoilInProgress())

			local pitch = TFA.tbezier(t, self2.Primary_TFA.RecoilLUT["in"].points_p)
			local yaw = TFA.tbezier(t, self2.Primary_TFA.RecoilLUT["in"].points_y)

			return Angle(pitch * isp, yaw * isp)
		end

		local out = getfn(self2.Primary_TFA.RecoilLUT["out"])(self:GetRecoilOutProgress())
		local loop = getfn(self2.Primary_TFA.RecoilLUT["loop"])(self:GetRecoilLoopProgress())

		local pitch = TFA.tbezier(loop, self2.Primary_TFA.RecoilLUT["loop"].points_p)
		local yaw = TFA.tbezier(loop, self2.Primary_TFA.RecoilLUT["loop"].points_y)

		if out ~= 0 then
			-- cooling out
			self2.Primary_TFA.RecoilLUT["out"].points_p[1] = pitch
			self2.Primary_TFA.RecoilLUT["out"].points_y[1] = yaw

			local pitch2 = TFA.tbezier(out, self2.Primary_TFA.RecoilLUT["out"].points_p)
			local yaw2 = TFA.tbezier(out, self2.Primary_TFA.RecoilLUT["out"].points_y)

			return Angle(pitch2 * isp, yaw2 * isp)
		end

		return Angle(pitch * isp, yaw * isp)
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function SWEP:GetAimVector()
	return self:GetAimAngle():Forward()
end

function SWEP:GetAimAngle()
	local ang = self:GetOwner():GetAimVector():Angle()

	if sv_tfa_recoil_legacy:GetBool() and self:GetOwner():IsPlayer() then
		ang:Add(self:GetOwner():GetViewPunchAngles())
	elseif self:HasRecoilLUT() then
		ang:Add(self:GetRecoilLUTAngle())
	else
		ang.p = ang.p + self:GetViewPunchP()
		ang.y = ang.y + self:GetViewPunchY()
	end

	ang:Normalize()
	return ang
end

function SWEP:EmitSoundNet(sound, ifp, shouldPause)
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not ifp then return end

	if shouldPause == nil then shouldPause = false end

	if CLIENT and sp then return end

	if CLIENT or sp then
		self:EmitSound(sound, nil, nil, nil, nil, shouldPause and SND_SHOULDPAUSE or SND_NOFLAGS)
		return
	end

	local filter = RecipientFilter()

	filter:AddPAS(self:GetPos())

	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		filter:RemovePlayer(self:GetOwner())
	end

	if filter:GetCount() == 0 then return end

	net.Start("tfaSoundEvent", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.WriteBool(shouldPause)
	net.Send(filter)
end

function SWEP:StopSoundNet(sound, ifp)
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not ifp then return end

	if CLIENT and sp then return end

	if CLIENT or sp then
		self:StopSound(sound)
		return
	end

	local filter = RecipientFilter()

	filter:AddPAS(self:GetPos())

	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		filter:RemovePlayer(self:GetOwner())
	end

	if filter:GetCount() == 0 then return end

	net.Start("tfaSoundEventStop", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.Send(filter)
end

function SWEP:IsFireModeAutomatic(fm)
	local fmn

	if type(fm) == "string" then
		fmn = fm
	elseif type(fm) == "number" then
		fmn = self:GetStatL("FireModes")[fm]
	else
		fmn = self:GetStatL("FireModes")[self:GetFireMode()]
	end

	return self:GetStatL("FireModesAutomatic." .. fmn) == true
end

function SWEP:ShouldEmitGunfireLoop(tableName)
	if self:IsFireModeAutomatic() then return true end
	if not self:GetStatL((tableName or "Primary") .. ".LoopSoundAutoOnly", false) then return true end

	return false
end

function SWEP:ShouldPlayLoopShootAnim()
	if self:IsFireModeAutomatic() then return true end
	if not self:GetStatL("ShootAnimationLoopAutoOnly", true) then return true end

	return false
end

--PATH lua/weapons/tfa_gun_base/common/stat.lua:
local tableCopy = table.Copy

function SWEP:GetStatRecursive(srctbl, stbl, ...)
	stbl = tableCopy(stbl)

	for _ = 1, #stbl do
		if #stbl > 1 then
			if srctbl[stbl[1]] then
				srctbl = srctbl[stbl[1]]
				table.remove(stbl, 1)
			else
				return true, ...
			end
		end
	end

	local val = srctbl[stbl[1]]

	if val == nil then
		return true, ...
	end

	if istable(val) and val.functionTable then
		local currentStat, isFinal, nocache, nct
		nocache = false

		for i = 1, #val do
			local v = val[i]

			if isfunction(v) then
				if currentStat == nil then
					currentStat, isFinal, nct = v(self, ...)
				else
					currentStat, isFinal, nct = v(self, currentStat)
				end

				nocache = nocache or nct

				if isFinal then break end
			elseif v then
				currentStat = v
			end
		end

		if currentStat ~= nil then
			return false, currentStat, nocache
		end

		return true, ...
	end

	return false, val
end

SWEP.StatCache_Blacklist = {
	["ViewModelBoneMods"] = true,
	["WorldModelBoneMods"] = true,
	["MaterialTable"] = true,
	["MaterialTable_V"] = true,
	["MaterialTable_W"] = true,
	["ViewModelBodygroups"] = true,
	["Bodygroups_V"] = true,
	["WorldModelBodygroups"] = true,
	["Skin"] = true
}

SWEP.StatCache = {}
SWEP.StatCache2 = {}
SWEP.StatStringCache = {}

SWEP.LastClearStatCache = 0
SWEP.ClearStatCacheWarnCount = 0
SWEP.ClearStatCacheWarned = false

local IdealCSCDeltaTime = engine.TickInterval() * 2

local LatestDataVersion = TFA.LatestDataVersion

function SWEP:ClearStatCache(vn)
	return self:ClearStatCacheVersioned(vn, 0)
end

function SWEP:ClearStatCacheL(vn)
	return self:ClearStatCacheVersioned(vn, LatestDataVersion)
end

local trigger_lut_rebuild = {
	FalloffMetricBased = true,
	Range = true,
	RangeFalloff = true,
}

function SWEP:ClearStatCacheVersioned(vn, path_version)
	local self2 = self:GetTable()
	self2.ignore_stat_cache = true
	local getpath, getpath2

	if isstring(vn) then
		vn = TFA.RemapStatPath(vn, path_version, self.TFADataVersion)
	end

	if not vn and not self2.ClearStatCacheWarned then
		local ct = CurTime()
		local delta = ct - self2.LastClearStatCache

		if delta < IdealCSCDeltaTime and debug.traceback():find("Think2") then
			self2.ClearStatCacheWarnCount = self2.ClearStatCacheWarnCount + 1

			if self2.ClearStatCacheWarnCount >= 5 then
				self2.ClearStatCacheWarned = true

				print(("[TFA Base] Weapon %s (%s) is abusing ClearStatCache function from Think2! This will lead to really bad performance issues, tell weapon's author to fix it ASAP!"):format(self2.PrintName, self:GetClass()))
			end
		elseif self2.ClearStatCacheWarnCount > 0 then
			self2.ClearStatCacheWarnCount = 0
		end

		self2.LastClearStatCache = ct
	end

	if vn then
		local list = TFA.GetStatPathChildren(vn, path_version, self.TFADataVersion)

		for i = 1, #list do
			self2.StatCache[list[i]] = nil
			self2.StatCache2[list[i]] = nil
		end

		getpath2 = self2.GetStatPath(self, vn)
		getpath = getpath2[1]
	else
		table.Empty(self2.StatCache)
		table.Empty(self2.StatCache2)
	end

	if vn == "Primary" or not vn then
		table.Empty(self2.Primary)

		local temp = {}

		setmetatable(self2.Primary, {
			__index = function(self3, key)
				return self2.GetStatVersioned(self, "Primary." .. key, self2.TFADataVersion)
			end,

			__newindex = function() end
		})

		for k in pairs(self2.Primary_TFA) do
			if isstring(k) then
				temp[k] = self2.GetStatVersioned(self, "Primary." .. k, self2.TFADataVersion)
			end
		end

		setmetatable(self2.Primary, nil)

		for k, v in pairs(temp) do
			self2.Primary[k] = v
		end

		if self2.Primary_TFA.RangeFalloffLUT_IsConverted then
			self2.Primary_TFA.RangeFalloffLUT = nil
			self2.AutoDetectRange(self)
		end

		local getLUT = self2.GetStatL(self, "Primary.RangeFalloffLUT", nil, true)

		if getLUT then
			self2.Primary.RangeFalloffLUTBuilt = self:BuildFalloffTable(getLUT)
		end

		if self2.Primary_TFA.RecoilLUT then
			if self2.Primary_TFA.RecoilLUT["in"] then
				self2.Primary_TFA.RecoilLUT["in"].points_p = {0}
				self2.Primary_TFA.RecoilLUT["in"].points_y = {0}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["in"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["in"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["in"].points_y, point.y)
				end
			end

			if self2.Primary_TFA.RecoilLUT["loop"] then
				self2.Primary_TFA.RecoilLUT["loop"].points_p = {}
				self2.Primary_TFA.RecoilLUT["loop"].points_y = {}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["loop"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_y, point.y)
				end

				table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_p, self2.Primary_TFA.RecoilLUT["loop"].points[1].p)
				table.insert(self2.Primary_TFA.RecoilLUT["loop"].points_y, self2.Primary_TFA.RecoilLUT["loop"].points[1].y)
			end

			if self2.Primary_TFA.RecoilLUT["out"] then
				self2.Primary_TFA.RecoilLUT["out"].points_p = {0}
				self2.Primary_TFA.RecoilLUT["out"].points_y = {0}

				for i, point in ipairs(self2.Primary_TFA.RecoilLUT["out"].points) do
					table.insert(self2.Primary_TFA.RecoilLUT["out"].points_p, point.p)
					table.insert(self2.Primary_TFA.RecoilLUT["out"].points_y, point.y)
				end

				table.insert(self2.Primary_TFA.RecoilLUT["out"].points_p, 0)
				table.insert(self2.Primary_TFA.RecoilLUT["out"].points_y, 0)
			end
		end
	elseif getpath == "Primary_TFA" and isstring(getpath2[2]) then
		if trigger_lut_rebuild[getpath2[2]] and self2.Primary_TFA.RangeFalloffLUT_IsConverted then
			self2.Primary_TFA.RangeFalloffLUT = nil
			self2.AutoDetectRange(self)
		end

		self2.Primary[getpath[2]] = self2.GetStatVersioned(self, vn, path_version)
	end

	if vn == "Secondary" or not vn then
		table.Empty(self2.Secondary)

		local temp = {}

		setmetatable(self2.Secondary, {
			__index = function(self3, key)
				return self2.GetStatVersioned(self, "Secondary." .. key, self2.TFADataVersion)
			end,

			__newindex = function() end
		})

		for k in pairs(self.Secondary_TFA) do
			if isstring(k) then
				temp[k] = self2.GetStatVersioned(self, "Secondary." .. k, self2.TFADataVersion)
			end
		end

		setmetatable(self2.Secondary, nil)

		for k, v in pairs(temp) do
			self2.Secondary[k] = v
		end
	elseif getpath == "Secondary_TFA" and isstring(getpath2[2]) then
		self2.Secondary[getpath[2]] = self2.GetStatVersioned(self, vn, path_version)
	end

	if CLIENT then
		self:RebuildModsRenderOrder()
	end

	self2.ignore_stat_cache = false
	hook.Run("TFA_ClearStatCache", self)
end

local ccv = GetConVar("cl_tfa_debug_cache")

function SWEP:GetStatPath(stat, path_version)
	return TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion)
end

function SWEP:RemapStatPath(stat, path_version)
	return TFA.RemapStatPath(stat, path_version or 0, self.TFADataVersion)
end

function SWEP:GetStatPathRaw(stat)
	return TFA.GetStatPathRaw(stat)
end

function SWEP:GetStatRaw(stat, path_version)
	local path = TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion, not IsValid(self))
	local value = self[path[1]]

	for i = 2, #path do
		if not istable(value) then return end
		value = value[path[i]]
	end

	return value
end

function SWEP:GetStatRawL(stat)
	return self:GetStatRaw(stat, LatestDataVersion)
end

function SWEP:SetStatRaw(stat, path_version, _value)
	local path = TFA.GetStatPath(stat, path_version or 0, self.TFADataVersion, not IsValid(self))

	if #path == 1 then
		self[path[1]] = _value
		return self
	end

	local value = self[path[1]]

	for i = 2, #path - 1 do
		if not istable(value) then return self end
		value = value[path[i]]
	end

	if istable(value) then
		value[path[#path]] = _value
	end

	return self
end

function SWEP:SetStatRawL(stat, _value)
	return self:SetStatRaw(stat, LatestDataVersion, _value)
end

function SWEP:GetStat(stat, default, dontMergeTables)
	return self:GetStatVersioned(stat, 0, default, dontMergeTables)
end

function SWEP:GetStatL(stat, default, dontMergeTables)
	return self:GetStatVersioned(stat, LatestDataVersion, default, dontMergeTables)
end

function SWEP:GetStatVersioned(stat, path_version, default, dontMergeTables)
	local self2 = self:GetTable()
	local statPath, currentVersionStat, translate = self2.GetStatPath(self, stat, path_version)

	if self2.StatCache2[currentVersionStat] ~= nil then
		local finalReturn

		if self2.StatCache[currentVersionStat] ~= nil then
			finalReturn = self2.StatCache[currentVersionStat]
		else
			local isDefault, retval = self2.GetStatRecursive(self, self2, statPath)

			if retval ~= nil then
				if not isDefault then
					self2.StatCache[currentVersionStat] = retval
				end

				finalReturn = retval
			else
				finalReturn = istable(default) and tableCopy(default) or default
			end
		end

		local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, finalReturn)
		if getstat ~= nil then return translate(getstat) end

		return translate(finalReturn)
	end

	if not self2.OwnerIsValid(self) then
		local finalReturn = default

		if IsValid(self) then
			local _
			_, finalReturn = self2.GetStatRecursive(self, self2, statPath, istable(default) and tableCopy(default) or default)
		end

		local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, finalReturn)
		if getstat ~= nil then return translate(getstat) end

		return translate(finalReturn)
	end

	local isDefault, statSelf = self2.GetStatRecursive(self, self2, statPath, istable(default) and tableCopy(default) or default)
	local isDefaultAtt, statAttachment, noCache = self2.GetStatRecursive(self, self2.AttachmentTableCache, statPath, istable(statSelf) and tableCopy(statSelf) or statSelf)
	local shouldCache = not noCache and
		not (self2.StatCache_Blacklist_Real or self2.StatCache_Blacklist)[currentVersionStat] and
		not (self2.StatCache_Blacklist_Real or self2.StatCache_Blacklist)[statPath[1]] and
		not (ccv and ccv:GetBool())

	if istable(statAttachment) and istable(statSelf) and not dontMergeTables then
		statSelf = table.Merge(tableCopy(statSelf), statAttachment)
	else
		statSelf = statAttachment
	end

	if shouldCache and not self2.ignore_stat_cache then
		if not isDefault or not isDefaultAtt then
			self2.StatCache[currentVersionStat] = statSelf
		end

		self2.StatCache2[currentVersionStat] = true
	end

	local getstat = hook.Run("TFA_GetStat", self, currentVersionStat, statSelf)
	if getstat ~= nil then return translate(getstat) end

	return translate(statSelf)
end

--PATH lua/weapons/tfa_gun_base/common/bullet.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/effects.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/viewmodel.lua:
local vector_origin = Vector()
local angle_zero = Angle()

local Vector = Vector
local Angle = Angle
local math = math
local LerpVector = LerpVector

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local cv_fov = GetConVar("fov_desired")
local cl_vm_nearwall = GetConVar("cl_tfa_viewmodel_nearwall")

local cl_tfa_viewmodel_offset_x = GetConVar("cl_tfa_viewmodel_offset_x")
local cl_tfa_viewmodel_offset_y = GetConVar("cl_tfa_viewmodel_offset_y")
local cl_tfa_viewmodel_offset_z = GetConVar("cl_tfa_viewmodel_offset_z")
local cl_tfa_viewmodel_centered = GetConVar("cl_tfa_viewmodel_centered")

local cl_tfa_viewmodel_vp_enabled = GetConVar("cl_tfa_viewmodel_vp_enabled")
local cl_tfa_viewmodel_vp_pitch = GetConVar("cl_tfa_viewmodel_vp_pitch")
local cl_tfa_viewmodel_vp_pitch_is = GetConVar("cl_tfa_viewmodel_vp_pitch_is")
local cl_tfa_viewmodel_vp_vertical = GetConVar("cl_tfa_viewmodel_vp_vertical")
local cl_tfa_viewmodel_vp_vertical_is = GetConVar("cl_tfa_viewmodel_vp_vertical_is")
local cl_tfa_viewmodel_vp_max_vertical = GetConVar("cl_tfa_viewmodel_vp_max_vertical")
local cl_tfa_viewmodel_vp_max_vertical_is = GetConVar("cl_tfa_viewmodel_vp_max_vertical_is")
local cl_tfa_viewmodel_vp_yaw = GetConVar("cl_tfa_viewmodel_vp_yaw")
local cl_tfa_viewmodel_vp_yaw_is = GetConVar("cl_tfa_viewmodel_vp_yaw_is")

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

local cv_customgunbob = GetConVar("cl_tfa_gunbob_custom")

local function Lerp(t, a, b)
	return a + (b - a) * t
end

local function Clamp(a, b, c)
	if a < b then return b end
	if a > c then return c end
	return a
end

local function GetClampedCVarFloat(cvar)
	return Clamp(cvar:GetFloat(), cvar:GetMin(), cvar:GetMax())
end

local math_max = math.max

local cl_vm_flip_cv = GetConVar("cl_tfa_viewmodel_flip")
local fovmod_add = GetConVar("cl_tfa_viewmodel_offset_fov")
local fovmod_mult = GetConVar("cl_tfa_viewmodel_multiplier_fov")

function SWEP:AirWalkScale()
	return (self:OwnerIsValid() and self:GetOwner():IsOnGround()) and 1 or 0.2
end

SWEP.OldPos = Vector(0, 0, 0)
SWEP.OldAng = Angle(0, 0, 0)

function SWEP:GetViewModelPosition(opos, oang, ...)
	local self2 = self:GetTable()

	if not self2.pos_cached then return opos, oang end

	local npos, nang = opos * 1, oang * 1

	nang:RotateAroundAxis(nang:Right(), self2.ang_cached.p)
	nang:RotateAroundAxis(nang:Up(), self2.ang_cached.y)
	nang:RotateAroundAxis(nang:Forward(), self2.ang_cached.r)
	npos:Add(nang:Right() * self2.pos_cached.x)
	npos:Add(nang:Forward() * self2.pos_cached.y)
	npos:Add(nang:Up() * self2.pos_cached.z)

	if cv_customgunbob:GetBool() then
		npos, nang = self:Sway(npos, nang)
		npos, nang = self:SprintBob(npos, nang, Lerp(self2.SprintProgressUnpredicted3 or self2.SprintProgressUnpredicted or self:GetSprintProgress(), 0, self2.SprintBobMult))
	end

	local pos, ang = self2.SightsAttPos, Angle(self2.SightsAttAng)
	if not pos or not ang then return npos, nang end

	local ofpos, ofang = WorldToLocal(npos, nang, opos, oang)

	self2.OldPos = npos
	self2.OldAng = nang

	if self.IronSightsProgressUnpredicted > 0.005 then
		local _opos, _oang = opos * 1, oang * 1

		-- tfa base vm offset
		local right, up, fwd = _oang:Right(), _oang:Up(), _oang:Forward()

		_opos = _opos - ofpos.y * right + ofpos.x * fwd + ofpos.z * up
		_oang:RotateAroundAxis(fwd, ofang.r)
		_oang:RotateAroundAxis(right, -ofang.p)
		_oang:RotateAroundAxis(up, ofang.y)

		-- sight offset

		_oang:RotateAroundAxis(_oang:Forward(), -ang.r)
		_oang:RotateAroundAxis(_oang:Right(), ang.p)
		_oang:RotateAroundAxis(_oang:Up(), -ang.y)

		right, up, fwd = _oang:Right(), _oang:Up(), _oang:Forward()

		_opos = _opos - pos.x * fwd + pos.y * right - pos.z * up

		self2.OldPos = LerpVector(self2.IronSightsProgressUnpredicted, npos, _opos)
		self2.OldAng = LerpAngle(self2.IronSightsProgressUnpredicted, nang, _oang)
	end

	return self2.OldPos, self2.OldAng
end

function SWEP:CalculateViewModelFlip()
	local self2 = self:GetTable()

	if self2.ViewModelFlipDefault == nil then
		self2.ViewModelFlipDefault = self2.ViewModelFlip
	end

	local righthanded = true

	if cl_vm_flip_cv:GetBool() then
		righthanded = false
	end

	local shouldflip = self2.ViewModelFlipDefault

	if not righthanded then
		shouldflip = not self2.ViewModelFlipDefault
	end

	if self2.ViewModelFlip ~= shouldflip then
		self2.ViewModelFlip = shouldflip
	end

	self2.ViewModelFOV_OG = self2.ViewModelFOV_OG or self2.ViewModelFOV

	local cam_fov = self2.LastTranslatedFOV or cv_fov:GetInt() or 90
	local iron_add = cam_fov * (1 - 90 / cam_fov) * math.max(1 - self2.GetStatL(self, "Secondary.OwnerFOV", 90) / 90, 0)

	local ironSightsProgress = TFA.Cosine(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress())
	self2.ViewModelFOV = Lerp(ironSightsProgress, self2.ViewModelFOV_OG, self2.GetStatL(self, "Secondary.ViewModelFOV", self2.ViewModelFOV_OG)) * GetClampedCVarFloat(fovmod_mult) + GetClampedCVarFloat(fovmod_add) + iron_add * ironSightsProgress
end

function SWEP:UpdateWeaponLength()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end
	local vm = self2.OwnerViewModel
	local mzpos = self:GetMuzzlePos()
	if not mzpos then return end
	if not mzpos.Pos then return end
	if GetViewEntity and GetViewEntity() ~= self:GetOwner() then return end
	local mzVec = vm:WorldToLocal(mzpos.Pos)
	self2.WeaponLength = math.abs(mzVec.x)
end

function SWEP:CalculateNearWall(p, a)
	local self2 = self:GetTable()
	if not self:OwnerIsValid() then return p, a end

	if not cl_vm_nearwall:GetBool() then return p, a end

	local ply = self:GetOwner()

	local sp = ply:GetShootPos()
	local ea = ply:EyeAngles()
	local et = util.QuickTrace(sp,ea:Forward()*128,{self,ply})--self:GetOwner():GetEyeTrace()
	local dist = et.HitPos:Distance(sp)

	if dist<1 then
		et=util.QuickTrace(sp,ea:Forward()*128,{self,ply,et.Entity})
		dist = et.HitPos:Distance(sp)
	end

	self:UpdateWeaponLength()

	local nw_offset_vec = LerpVector(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress(), self2.NearWallVector, self2.NearWallVectorADS)
	local off = self2.WeaponLength - dist
	self2.LastNearWallOffset = self2.LastNearWallOffset or 0

	local ft = RealFrameTime() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if off > self2.LastNearWallOffset then
		self2.LastNearWallOffset = math.min(self2.LastNearWallOffset + math.max(ft * 66, off * 0.1), off, 34)
	elseif off < self2.LastNearWallOffset then
		self2.LastNearWallOffset = math.max(self2.LastNearWallOffset - ft * 66, off, 0)
	end

	off = TFA.Cosine(self2.LastNearWallOffset / 34) * 34

	if off > 0 then
		p = p + nw_offset_vec * off / 2
		local posCompensated = sp * 1
		posCompensated:Add(ea:Right() * nw_offset_vec.x * off / 2 * (self2.ViewModelFlip and -1 or 1))
		posCompensated:Add(ea:Forward() * nw_offset_vec.y * off / 2)
		posCompensated:Add(ea:Up() * nw_offset_vec.z * off / 2)
		local angleComp = (et.HitPos - posCompensated):Angle()
		a.x = a.x - math.AngleDifference(angleComp.p, ea.p) / 2
		a.y = a.y + math.AngleDifference(angleComp.y, ea.y) / 2
	end

	return p, a
end

local centered_sprintpos = Vector(0, -1, 1)
local centered_sprintang = Vector(-15, 0, 0)

local bezierVectorBuffer = {}

local function bezierVector(t, vec1, vec2, vec3)
	local _1, _2 = vec1.x, vec3.x
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.x
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local x = TFA.tbezier(t, bezierVectorBuffer)

	_1, _2 = vec1.y, vec3.y
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.y
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local y = TFA.tbezier(t, bezierVectorBuffer)

	_1, _2 = vec1.z, vec3.z
	bezierVectorBuffer[1] = _1
	bezierVectorBuffer[2] = _1
	bezierVectorBuffer[3] = _1
	bezierVectorBuffer[4] = _1
	bezierVectorBuffer[5] = vec2.z
	bezierVectorBuffer[6] = _2
	bezierVectorBuffer[7] = _2
	bezierVectorBuffer[8] = _2
	bezierVectorBuffer[9] = _2

	local z = TFA.tbezier(t, bezierVectorBuffer)

	return Vector(x, y, z)
end

function SWEP:CalculateViewModelOffset(delta)
	local self2 = self:GetTable()

	local target_pos, target_ang
	local additivePos = self2.GetStatL(self, "AdditiveViewModelPosition")

	if additivePos then
		target_pos, target_ang = Vector(), Vector()
	else
		target_pos = Vector(self2.GetStatL(self, "ViewModelPosition"))
		target_ang = Vector(self2.GetStatL(self, "ViewModelAngle"))
	end

	local CenteredViewModelPosition = self2.GetStatL(self, "CenteredViewModelPosition")
	local CenteredViewModelAngle = self2.GetStatL(self, "CenteredViewModelAngle")
	local IronSightsPosition = self2.GetStatL(self, "IronSightsPosition", self2.SightsPos)
	local IronSightsAngle = self2.GetStatL(self, "IronSightsAngle", self2.SightsAng)

	local targetPosCenter, targetAngCenter

	if CenteredViewModelPosition then
		targetPosCenter = Vector(CenteredViewModelPosition)

		if CenteredViewModelAngle then
			targetAngCenter = Vector(CenteredViewModelAngle)
		end
	elseif IronSightsPosition then
		targetPosCenter = Vector((self2.IronSightsPositionCurrent or IronSightsPosition).x, target_pos.y, target_pos.z - 3)

		if IronSightsAngle then
			targetAngCenter = Vector(0, (self2.IronSightsAngleCurrent or IronSightsAngle).y, 0)
		end
	else
		targetPosCenter, targetAngCenter = target_pos, target_ang
	end

	local stat = self:GetStatus()

	local holsterStatus = TFA.Enum.HolsterStatus[stat] and self2.GetStatL(self, "ProceduralHolsterEnabled")
	local proceduralReloadStatus = TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "IsProceduralReloadBased")
	local holsterProgress = 0
	local statusProgress = self:GetStatusProgress()

	if proceduralReloadStatus then
		holsterProgress = TFA.Quintic(Clamp((statusProgress >= 0.5 and (2 - statusProgress * 2) or (statusProgress * 2)), 0, 1))
	elseif self2.GetStatL(self, "ProceduralHolsterEnabled") then
		if TFA.Enum.HolsterStatusFinal[stat] then
			holsterProgress = 1
		elseif TFA.Enum.HolsterStatus[stat] then
			holsterProgress = TFA.Quintic(Clamp(statusProgress * 1.1, 0, 1))
		end
	end

	local sprintAnimAllowed = self2.GetStatL(self, "Sprint_Mode") ~= TFA.Enum.LOCOMOTION_ANI

	local ironSights = self:GetIronSights()
	local sprintProgress = sprintAnimAllowed and TFA.Cubic(self2.SprintProgressUnpredicted2 or self2.SprintProgressUnpredicted or self:GetSprintProgress()) or 0
	local safetyProgress = Lerp(sprintProgress, TFA.Cubic(self2.SafetyProgressUnpredicted or 0), 0)

	local ironSightsProgress = Clamp(
		Lerp(
			math_max(holsterProgress, sprintProgress, safetyProgress),
			TFA.Cubic(self2.IronSightsProgressUnpredicted2 or self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()),
			0)
		, 0, 1)

	--local ironSightsProgress = TFA.tbezier(self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress(), IRON_SIGHTS_BEZIER)

	local crouchRatio = Lerp(math_max(ironSightsProgress, holsterProgress, Clamp(sprintProgress * 2, 0, 1), safetyProgress), TFA.Quintic(self2.CrouchingRatioUnpredicted or self:GetCrouchingRatio()), 0)

	if crouchRatio > 0.01 then
		target_pos = LerpVector(crouchRatio, target_pos, self2.GetStatL(self, "CrouchViewModelPosition"))
		target_ang = LerpVector(crouchRatio, target_ang, self2.GetStatL(self, "CrouchViewModelAngle"))
	end

	local isCentered = cl_tfa_viewmodel_centered:GetBool()
	if isCentered then
		target_pos:Set(targetPosCenter)
		target_ang:Set(targetAngCenter)
	end

	if holsterStatus or proceduralReloadStatus then
		local targetHolsterPos = Vector(self2.GetStatL(self, "ProceduralHolsterPosition"))
		local targetHolsterAng = Vector(self2.GetStatL(self, "ProceduralHolsterAngle"))

		if self2.ViewModelFlip then
			targetHolsterPos.x = -targetHolsterPos.x

			targetHolsterAng.y = -targetHolsterAng.y
			targetHolsterAng.z = -targetHolsterAng.z
		end

		target_pos = LerpVector(holsterProgress, target_pos, targetHolsterPos)
		target_ang = LerpVector(holsterProgress, target_ang, targetHolsterAng)
	end

	if
		(sprintProgress > 0.01 or safetyProgress > 0.01) and
		(sprintAnimAllowed and sprintProgress > 0.01 or safetyProgress > 0.01)
		and not TFA.Enum.BashStatus[stat]
	then
		local add_pos = isCentered and centered_sprintpos or vector_origin
		local add_ang = isCentered and centered_sprintang or vector_origin

		local sprint_pos = self2.GetStatL(self, "SprintViewModelPosition")
		local sprint_ang = self2.GetStatL(self, "SprintViewModelAngle")

		target_pos = LerpVector(safetyProgress, target_pos, self2.GetStatL(self, "SafetyPos", sprint_pos) + add_pos)
		target_ang = LerpVector(safetyProgress, target_ang, self2.GetStatL(self, "SafetyAng", sprint_ang) + add_ang)

		if sprintAnimAllowed then
			target_pos = LerpVector(sprintProgress, target_pos, sprint_pos + add_pos)
			target_ang = LerpVector(sprintProgress, target_ang, sprint_ang + add_ang)
		end
	end

	if ironSightsProgress > 0.02 and self2.GetStatL(self, "Sights_Mode") ~= TFA.Enum.LOCOMOTION_ANI then
		local score = self2.VM_IronPositionScore or 1
		local getSightsPos = self2.IronSightsPositionCurrent or IronSightsPosition or self2.GetStatL(self, "SightsPos", vector_origin)

		if targetPosCenter and score > 0.04 then
			target_pos = bezierVector(ironSightsProgress, target_pos, LerpVector(score, getSightsPos, targetPosCenter), getSightsPos)
		else
			target_pos = LerpVector(ironSightsProgress, target_pos, getSightsPos)
		end

		if targetAngCenter and score > 0.04 then
			local deviate = 30 * score

			if self2.VM_IsScopedIn then
				deviate = -deviate
			end

			if self2.ViewModelFlip then
				deviate = -deviate
			end

			local targetAngCenter2 = Vector(targetAngCenter.x * score, targetAngCenter.y * score, targetAngCenter.z * score + deviate)
			target_ang = bezierVector(ironSightsProgress, target_ang, targetAngCenter2, self2.IronSightsAngleCurrent or IronSightsAngle or self2.GetStatL(self, "SightsAng", vector_origin))
		else
			target_ang = LerpVector(ironSightsProgress, target_ang, self2.IronSightsAngleCurrent or IronSightsAngle or self2.GetStatL(self, "SightsAng", vector_origin))
		end
	end

	target_pos.x = target_pos.x + GetClampedCVarFloat(cl_tfa_viewmodel_offset_x) * (1 - ironSightsProgress)
	target_pos.y = target_pos.y + GetClampedCVarFloat(cl_tfa_viewmodel_offset_y) * (1 - ironSightsProgress)
	target_pos.z = target_pos.z + GetClampedCVarFloat(cl_tfa_viewmodel_offset_z) * (1 - ironSightsProgress)

	local customizationProgress = TFA.Quintic(self2.CustomizingProgressUnpredicted or self:GetInspectingProgress())

	if customizationProgress > 0.01 and self2.GetStatL(self, "Customize_Mode") ~= TFA.Enum.LOCOMOTION_ANI then
		if not self2.InspectPos then
			self2.InspectPos = Vector(self2.InspectPosDef)

			if self2.ViewModelFlip then
				self2.InspectPos.x = self2.InspectPos.x * -1
			end
		end

		if not self2.InspectAng then
			self2.InspectAng = Vector(self2.InspectAngDef)

			if self2.ViewModelFlip then
				self2.InspectAng.y = self2.InspectAngDef.y * -1
				self2.InspectAng.z = self2.InspectAngDef.z * -1
			end
		end

		target_pos = LerpVector(customizationProgress, target_pos, self2.GetStatL(self, "InspectPos"))
		target_ang = LerpVector(customizationProgress, target_ang, self2.GetStatL(self, "InspectAng"))
	end

	target_pos, target_ang = self:CalculateNearWall(target_pos, target_ang)

	if additivePos then
		target_pos:Add(self2.GetStatL(self, "ViewModelPosition"))
		target_ang:Add(self2.GetStatL(self, "ViewModelAngle"))
	end

	target_ang.z = target_ang.z + -7.5 * (1 - math.abs(0.5 - ironSightsProgress) * 2) * (self:GetIronSights() and 1 or 0.5) * (self2.ViewModelFlip and 1 or -1) * (self2.VM_IronPositionScore or 1)

	if self:GetHidden() then
		target_pos.z = target_pos.z - 5
	end

	if self2.GetStatL(self, "BlowbackEnabled") and self2.BlowbackCurrentRoot > 0.01 then
		local bbvec = self2.GetStatL(self, "BlowbackVector")
		target_pos = target_pos + bbvec * self2.BlowbackCurrentRoot
		local bbang = self2.GetStatL(self, "BlowbackAngle") or angle_zero
		bbvec = bbvec * 1
		bbvec.x = bbang.p
		bbvec.y = bbang.y
		bbvec.z = bbang.r
		target_ang = target_ang + bbvec * self2.BlowbackCurrentRoot
		bbang = self2.BlowbackRandomAngle * (1 - math.max(0, ironSightsProgress) * .8)
		bbvec.x = bbang.p
		bbvec.y = bbang.y
		bbvec.z = bbang.r
		target_ang = target_ang + bbvec * self2.BlowbackCurrentRoot
	end

	if not sv_tfa_recoil_legacy:GetBool() and cl_tfa_viewmodel_vp_enabled:GetBool() then
		if self:HasRecoilLUT() then
			if not ironSights then
				local ang = self:GetRecoilLUTAngle()

				target_ang.x = target_ang.x - ang.p / 2 * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchPitchMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch), self:GetStatL("ViewModelPunchPitchMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch_is))
				target_ang.y = target_ang.y + ang.y / 2 * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchYawMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw), self:GetStatL("ViewModelPunchYawMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw_is))
			end
		else
			target_ang.x = target_ang.x - self:GetViewPunchP() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchPitchMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch), self:GetStatL("ViewModelPunchPitchMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_pitch_is))
			target_ang.y = target_ang.y + self:GetViewPunchY() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunchYawMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw), self:GetStatL("ViewModelPunchYawMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_yaw_is))

			local ViewModelPunch_MaxVertialOffset = Lerp(ironSightsProgress, self:GetStatL("ViewModelPunch_MaxVertialOffset") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_max_vertical), self:GetStatL("ViewModelPunch_MaxVertialOffset_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_max_vertical_is))

			target_pos.y = target_pos.y + math.Clamp(
				self:GetViewPunchP() * Lerp(ironSightsProgress, self:GetStatL("ViewModelPunch_VertialMultiplier") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_vertical), self:GetStatL("ViewModelPunch_VertialMultiplier_IronSights") * GetClampedCVarFloat(cl_tfa_viewmodel_vp_vertical_is)),
				-ViewModelPunch_MaxVertialOffset,
				ViewModelPunch_MaxVertialOffset)
		end
	end

	if not cv_customgunbob:GetBool() then
		self2.pos_cached, self2.ang_cached = Vector(target_pos), Angle(target_ang.x, target_ang.y, target_ang.z)

		return
	end

	local intensityWalk = math.min(self:GetOwner():GetVelocity():Length2D() / self:GetOwner():GetWalkSpeed(), 1) * Lerp(ironSightsProgress, self2.WalkBobMult, self2.WalkBobMult_Iron or self2.WalkBobMult)
	local intensityBreath = Lerp(ironSightsProgress, self2.GetStatL(self, "BreathScale", 0.2), self2.GetStatL(self, "IronBobMultWalk", 0.5) * intensityWalk)
	intensityWalk = (1 - ironSightsProgress) * intensityWalk
	local intensityRun = Lerp(self2.SprintProgressUnpredicted3 or self2.SprintProgressUnpredicted or self:GetSprintProgress(), 0, self2.SprintBobMult)
	local velocity = math.max(self:GetOwner():GetVelocity():Length2D() * self:AirWalkScale() - self:GetOwner():GetVelocity().z * 0.5, 0)
	local rate = math.min(math.max(0.15, math.sqrt(velocity / self:GetOwner():GetRunSpeed()) * 1.75), self:GetSprinting() and 5 or 3)

	self2.pos_cached, self2.ang_cached = self:WalkBob(
		target_pos,
		Angle(target_ang.x, target_ang.y, target_ang.z),
		math.max(intensityBreath - intensityWalk - intensityRun, 0),
		math.max(intensityWalk - intensityRun, 0), rate, delta)
end

local rft, eyeAngles, viewPunch, oldEyeAngles, delta, motion, counterMotion, compensation, fac, positionCompensation, swayRate, wiggleFactor, flipFactor

local gunswaycvar = GetConVar("cl_tfa_gunbob_intensity")
local gunswayinvertcvar = GetConVar("cl_tfa_gunbob_invertsway")
local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

function SWEP:Sway(pos, ang, ftv)
	local self2 = self:GetTable()
	--sanity check
	if not self:OwnerIsValid() then return pos, ang end
	--convar
	fac = GetClampedCVarFloat(gunswaycvar) * 3 * ((1 - ((self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) or 0)) * 0.85 + 0.15)
	if gunswayinvertcvar:GetBool() then fac = -fac end
	flipFactor = (self2.ViewModelFlip and -1 or 1)
	--init vars
	delta = delta or Angle()
	motion = motion or Angle()
	counterMotion = counterMotion or Angle()
	compensation = compensation or Angle()

	if ftv then
		--grab eye angles
		eyeAngles = self:GetOwner():EyeAngles()
		viewPunch = self:GetOwner():GetViewPunchAngles()
		eyeAngles.p = eyeAngles.p - viewPunch.p
		eyeAngles.y = eyeAngles.y - viewPunch.y
		oldEyeAngles = oldEyeAngles or eyeAngles
		--calculate delta
		wiggleFactor = (1 - (sv_tfa_weapon_weight:GetBool() and self2.GetStatL(self, "RegularMoveSpeedMultiplier") or 1)) / 0.6 + 0.15
		swayRate = math.pow(sv_tfa_weapon_weight:GetBool() and self2.GetStatL(self, "RegularMoveSpeedMultiplier") or 1, 1.5) * 10
		rft = math.Clamp(ftv, 0.001, 1 / 20)
		local clampFac = 1.1 - math.min((math.abs(motion.p) + math.abs(motion.y) + math.abs(motion.r)) / 20, 1)
		delta.p = math.AngleDifference(eyeAngles.p, oldEyeAngles.p) / rft / 120 * clampFac
		delta.y = math.AngleDifference(eyeAngles.y, oldEyeAngles.y) / rft / 120 * clampFac
		delta.r = math.AngleDifference(eyeAngles.r, oldEyeAngles.r) / rft / 120 * clampFac
		oldEyeAngles = eyeAngles
		--calculate motions, based on Juckey's methods
		counterMotion = LerpAngle(rft * (swayRate * (0.75 + math.max(0, 0.5 - wiggleFactor))), counterMotion, -motion)
		compensation.p = math.AngleDifference(motion.p, -counterMotion.p)
		compensation.y = math.AngleDifference(motion.y, -counterMotion.y)
		motion = LerpAngle(rft * swayRate, motion, delta + compensation)
	end

	--modify position/angle
	positionCompensation = 0.2 + 0.2 * ((self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) or 0)
	pos:Add(-motion.y * positionCompensation * 0.66 * fac * ang:Right() * flipFactor) --compensate position for yaw
	pos:Add(-motion.p * positionCompensation * fac * ang:Up()) --compensate position for pitch
	ang:RotateAroundAxis(ang:Right(), motion.p * fac)
	ang:RotateAroundAxis(ang:Up(), -motion.y * 0.66 * fac * flipFactor)
	ang:RotateAroundAxis(ang:Forward(), counterMotion.r * 0.5 * fac * flipFactor)

	return pos, ang
end

local mirror = Matrix()

hook.Add("PostRender", "TFA:CacheSightsPos", function()
	local self = LocalPlayer():GetActiveWeapon()
	if not IsValid(self) then return end
	local self2 = self:GetTable()
	if not self2.IsTFAWeapon then return end
	if not self2.ViewModelFlip then return end

	if not self2.VMIV(self) then return end
	local vm = self2.OwnerViewModel

	self2.ViewModelFlip = false

	vm:SetRenderOrigin(vector_origin)
	vm:SetRenderAngles(angle_zero)

	vm:InvalidateBoneCache()
	vm:SetupBones()

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	if ViewModelElements and self2.HasInitAttachments then
		if not self2.vRenderOrder then
			self:RebuildModsRenderOrder()
		end

		TFA._IncNextSetupBones()

		for index = 1, #self2.vRenderOrder do
			local name = self2.vRenderOrder[index]
			local element = ViewModelElements[name]

			if not element then
				self:RebuildModsRenderOrder()
				break
			end

			if element.type ~= "Model" then goto CONTINUE end

			if element.hide then goto CONTINUE end
			if not element.bone then goto CONTINUE end

			if self2.GetStatL(self, "ViewModelElements." .. name .. ".active") == false then goto CONTINUE end

			local pos, ang = self:GetBoneOrientation(ViewModelElements, element, vm, nil, true)
			if not pos and not element.bonemerge then goto CONTINUE end

			self:PrecacheElement(element, true)

			local model = element.curmodel
			local sprite = element.spritemat

			if IsValid(model) then
				if not element.bonemerge then
					model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)
					ang:RotateAroundAxis(ang:Up(), element.angle.y)
					ang:RotateAroundAxis(ang:Right(), element.angle.p)
					ang:RotateAroundAxis(ang:Forward(), element.angle.r)
					model:SetAngles(ang)
					mirror:Identity()
					mirror:Scale(element.size)
					model:EnableMatrix("RenderMultiply", mirror)
				end

				if not self2.VElementsBodygroupsCache[index] then
					self2.VElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
				end

				if self2.VElementsBodygroupsCache[index] then
					for _b = 0, self2.VElementsBodygroupsCache[index] do
						local newbg = self2.GetStatL(self, "ViewModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

						if model:GetBodygroup(_b) ~= newbg then
							model:SetBodygroup(_b, newbg)
						end
					end
				end

				if element.bonemerge then
					if element.rel and ViewModelElements[element.rel] and IsValid(ViewModelElements[element.rel].curmodel) then
						element.parModel = ViewModelElements[element.rel].curmodel
					else
						element.parModel = self2.OwnerViewModel or self
					end

					if model:GetParent() ~= element.parModel then
						model:SetParent(element.parModel)
					end

					if not model:IsEffectActive(EF_BONEMERGE) then
						model:AddEffects(EF_BONEMERGE)
						model:AddEffects(EF_BONEMERGE_FASTCULL)
						model:SetMoveType(MOVETYPE_NONE)
						model:SetLocalPos(vector_origin)
						model:SetLocalAngles(angle_zero)
					end
				elseif model:IsEffectActive(EF_BONEMERGE) then
					model:RemoveEffects(EF_BONEMERGE)
					model:SetParent(NULL)
				end

				model:InvalidateBoneCache()
				model:SetupBones()
				model.tfa_next_setup_bones = TFA._GetNextSetupBones()
			end

			::CONTINUE::
		end
	end

	self:CacheSightsPos(vm, true)

	vm:SetRenderOrigin()
	vm:SetRenderAngles()

	self.ViewModelFlip = true
	vm:InvalidateBoneCache()
end)

function SWEP:CacheSightsPos(vm, flipped)
	self.SightsAttPos, self.SightsAttAng = nil, nil

	if not self:GetStat("ProceduralSight", false) then return end

	local model = vm
	local attname = self:GetStat("ProceduralSight_VElement")

	if attname then
		if not self:GetStat("VElements." .. attname .. ".active", false) then return end

		model = self.VElements[attname].curmodel
	end

	if not IsValid(model) then return end

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	TFA._IncNextSetupBones()

	if self:GetStat("ProceduralSight_PositionType", TFA.Enum.SIGHTSPOS_ATTACH) == TFA.Enum.SIGHTSPOS_BONE then
		local boneid = self:GetStat("ProceduralSight_Bone")
		if not boneid then return end

		if type(boneid) == "string" then
			boneid = model:LookupBone(boneid)
		end

		if not boneid or boneid < 0 then return end

		self.SightsAttPos, self.SightsAttAng = model:GetBonePosition(boneid)
	else
		local attid = self:GetStat("ProceduralSight_Attachment")
		if not attid then return end

		if type(attid) == "string" then
			attid = model:LookupAttachment(attid)
		end

		if not attid or attid <= 0 then return end

		local attpos = model:GetAttachment(attid)

		self.SightsAttPos, self.SightsAttAng = attpos.Pos, attpos.Ang
	end

	if self.SightsAttPos and self.SightsAttAng then
		if not flipped then
			local transform = Matrix()
			transform:Translate(vm:GetPos())
			transform:Rotate(vm:GetAngles())
			transform:Invert()

			transform:Translate(self.SightsAttPos)
			transform:Rotate(self.SightsAttAng)

			self.SightsAttPos, self.SightsAttAng = transform:GetTranslation(), transform:GetAngles()
		end

		local OffsetPos = self:GetStatL("ProceduralSight_OffsetPos")

		if OffsetPos then
			if GetConVarNumber("developer") > 0 then -- draw pre-offset pos
				local a, b = LocalToWorld(self.SightsAttPos, self.SightsAttAng, vm:GetPos(), vm:GetAngles())

				render.DrawLine(a, a + b:Forward() * 1, Color(127, 0, 0), false)
				render.DrawLine(a, a - b:Right() * 1, Color(0, 127, 0), false)
				render.DrawLine(a, a + b:Up() * 1, Color(0, 0, 127), false)
			end

			self.SightsAttPos:Add(self.SightsAttAng:Right() * OffsetPos.x)
			self.SightsAttPos:Add(self.SightsAttAng:Forward() * OffsetPos.y)
			self.SightsAttPos:Add(self.SightsAttAng:Up() * OffsetPos.z)
		end

		local OffsetAng = self:GetStatL("ProceduralSight_OffsetAng")

		if OffsetAng then
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Right(), OffsetAng.p)
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Up(), OffsetAng.y)
			self.SightsAttAng:RotateAroundAxis(self.SightsAttAng:Forward(), OffsetAng.r)
		end

		if GetConVarNumber("developer") > 0 then -- draw final pos
			local a, b = LocalToWorld(self.SightsAttPos, self.SightsAttAng, vm:GetPos(), vm:GetAngles())

			render.DrawLine(a, a + b:Forward() * 1, Color(255, 0, 0), false)
			render.DrawLine(a, a - b:Right() * 1, Color(0, 255, 0), false)
			render.DrawLine(a, a + b:Up() * 1, Color(0, 0, 255), false)
		end
	end
end
--PATH lua/weapons/tfa_gun_base/client/fov.lua:
local LocalPlayer = LocalPlayer
local math = math

local function GetScreenAspectRatio()
	return ScrW() / ScrH()
end

local function ScaleFOVByWidthRatio(fovDegrees, ratio)
	local halfAngleRadians = fovDegrees * (0.5 * math.pi / 180.0)
	local t = math.tan(halfAngleRadians)
	t = t * ratio
	local retDegrees = (180.0 / math.pi) * math.atan(t)

	return retDegrees * 2.0
end

local default_fov_cv = GetConVar("default_fov")

function SWEP:GetTrueFOV()
	local fov = TFADUSKFOV or default_fov_cv:GetFloat()
	local ply = LocalPlayer()

	if not ply:IsValid() then return fov end

	if ply:GetFOV() < ply:GetDefaultFOV() - 1 then
		fov = ply:GetFOV()
	end

	if TFADUSKFOV_FINAL then
		fov = TFADUSKFOV_FINAL
	end

	return fov
end

function SWEP:GetViewModelFinalFOV()
	local fov_default = default_fov_cv:GetFloat()
	local fov = self:GetTrueFOV()
	local flFOVOffset = fov_default - fov
	local fov_vm = self.ViewModelFOV - flFOVOffset
	local aspectRatio = GetScreenAspectRatio() * 0.75 -- (4/3)
	--local final_fov = ScaleFOVByWidthRatio( fov,  aspectRatio )
	local final_fovViewmodel = ScaleFOVByWidthRatio(fov_vm, aspectRatio)

	return final_fovViewmodel
end

--PATH lua/weapons/tfa_knife_base.lua:
return gluapack()()
--PATH lua/weapons/tfa_swsft_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--PATH lua/weapons/tfa_swsft_base/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_ak472/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 3
    SWEP.SlotPos = 0
    SWEP.IconLetter = "b"

    killicon.AddFont("weapon_ak472", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "AK47"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/cstrike/c_rif_ak47.mdl"
SWEP.WorldModel = "models/weapons/w_rif_ak47.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.HoldType = "ar2"
SWEP.LoweredHoldType = "passive"

SWEP.Primary.Sound = Sound("Weapon_AK47.Single")
SWEP.Primary.Recoil = 1.5
SWEP.Primary.Damage = 40
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.002
SWEP.Primary.ClipSize = 30
SWEP.Primary.Delay = 0.08
SWEP.Primary.DefaultClip = 30
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-6.6, -15, 2.6)
SWEP.IronSightsAng = Vector(2.6, 0.02, 0)

SWEP.MultiMode = true

--PATH lua/weapons/weapon_armorkit/animations.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_cs_base2/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_drakamassif/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/weapon_fiveseven2/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2pot/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pot"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pot.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pot.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 35
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 200
SWEP.HitRate			= 0.90
SWEP.MinDamage			= 10
SWEP.MaxDamage			= 15

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 10, 15 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_blockpoints.lua:

function SWEP:GetBPDrainPerHit()
	return (self:GetCombo().BPDrainPerHit or 25)
end

function SWEP:GetMaxBlockPoints()
	local combo = self:GetCombo()

	return (combo.MaxBlockPoints or 100)
end

function SWEP:GetBlockDistanceNormal()
	return (self:GetCombo().BlockDistanceNormal or 60)
end

function SWEP:GetBlockDistancePerfect()
	return (self:GetCombo().BlockDistancePerfect or 20)
end

function SWEP:DrainBP( amount )
	if amount then
		self:SetBlockPoints( math.Clamp( self:GetBlockPoints() - amount,0, self:GetMaxBlockPoints()) )

		if amount > 0 then
			self.NextBPr = CurTime() + 2
		end
	else
		self.NextBPr = CurTime() + 2
	end
end

if SERVER then
	function SWEP:CalcBPRegen( CurTime )
		local ply = self:GetOwner()

		if not IsValid( ply ) then return end

		if (self.NextBPr or 0) < CurTime then
			self.NextBPr = CurTime + 0.3

			local MaxVal = self:GetMaxBlockPoints()
			if self:GetGestureTime() < CurTime and ply:OnGround() and ply:GetVelocity():Length() < 225 then
				self:SetBlockPoints( self:GetBlockPoints() + math.min(MaxVal - self:GetBlockPoints(),3) )
			else
				if not ply:OnGround() then
					self:DrainBP( 1 )
				end
			end
		end

		if self._ResetHitTime and self._ResetHitTime < CurTime then
			self._ResetHitTime = CurTime + 1

			self:AddHit( -0.1 )
		end
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_worldmodel.lua:
SWEP.WorldModelCL = {}
SWEP.BladeModelCL = {}

function SWEP:DrawBladeModel( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
	local HiltMDL = self:GetWorldModel( HandID )

	if not IsValid( HiltMDL ) then return end

	local BladeMDL = self:GetBladeModel( HandID, BladeID )

	if IsValid( BladeMDL ) then
		local Ang = HiltAngles
		local Forward = HiltAngles:Up()
		local Right = HiltAngles:Right()

		Ang:RotateAroundAxis( Right, math.deg( math.acos( math.Clamp( Forward:Dot( PosData.dir ) ,-1,1) ) ) )

		BladeMDL:SetPos( PosData.pos )
		BladeMDL:SetAngles( Ang )
		BladeMDL:SetupBones()
		BladeMDL:DrawModel()

		if bladeObject.mdl_poseparameter then
			BladeMDL:SetPoseParameter(bladeObject.mdl_poseparameter, Mul  )
			BladeMDL:InvalidateBoneCache()
		end
	else
		local Model = ClientsideModel( bladeObject.mdl )
		Model:SetNoDraw( true )
		self.BladeModelCL[ HandID ][BladeID ] = Model
	end
end

function SWEP:GetBladeModel( HandID, BladeID )
	if not self.BladeModelCL[ HandID ] then
		self.BladeModelCL[ HandID ] = {}
	end

	if HandID and BladeID then
		if not self.BladeModelCL[ HandID ][BladeID ] then
			return false
		else
			return self.BladeModelCL[ HandID ][BladeID ]
		end
	else
		return self.BladeModelCL
	end
end

function SWEP:GetWorldModel( handID )
	if handID then
		return self.WorldModelCL[ handID ]
	else
		return self.WorldModelCL
	end
end

function SWEP:UpdateWorldModel( hand , hiltobject )
	if hand == self.HAND_RIGHT then
		if IsValid( self.WorldModelCL[ self.HAND_RIGHT ] ) then
			self.WorldModelCL[ self.HAND_RIGHT ]:Remove()
		end

		if hiltobject then
			local WorldModel = ClientsideModel( hiltobject.mdl )
			WorldModel:SetNoDraw( true )
			self.WorldModelCL[ self.HAND_RIGHT ] = WorldModel
		end
	end

	if hand == self.HAND_LEFT then
		if IsValid( self.WorldModelCL[ self.HAND_LEFT ] ) then
			self.WorldModelCL[ self.HAND_LEFT ]:Remove()
		end

		if hiltobject then
			local WorldModel = ClientsideModel( hiltobject.mdl )
			WorldModel:SetNoDraw( true )
			self.WorldModelCL[ self.HAND_LEFT ] = WorldModel
		end
	end
end

function SWEP:ClearWorldModel()
	for _, mdl in pairs( self.WorldModelCL ) do
		if not IsValid( mdl ) then continue end

		mdl:Remove()
	end
end

function SWEP:ClearBladeModel()
	for _, tbl in pairs( self.BladeModelCL ) do
		if not tbl then continue end

		for _, mdl in pairs( tbl ) do
			if not IsValid( mdl ) then continue end
			mdl:Remove()
		end
	end
end

function SWEP:DrawWorldModel( flags )
end

function SWEP:DrawWorldModelUnequipped( ply )
	local Pos = self:GetPos() 
	local Ang = self:GetAngles()

	for handID, hiltObject in pairs( self:GetHiltData() ) do
		local WorldModel = self:GetWorldModel( handID )

		if not IsValid( WorldModel ) then continue end

		WorldModel:SetPos( Pos )
		WorldModel:SetAngles( Ang )
		WorldModel:SetupBones()
		WorldModel:DrawModel()
	end
end

function SWEP:DrawWorldModelTranslucent( flags, target )
	local ply = self:GetOwner()

	if not IsValid( ply ) then
		self:DrawWorldModelUnequipped( ply )

		return
	end

	if self:IsThrown() then
		if IsValid( target ) then
			ply = target
		else
			return
		end
	end

	local BladeID = 1
	local Mul = self:GetLength()

	for handID, hiltObject in pairs( self:GetHiltData() ) do
		local WorldModel = self:GetWorldModel( handID )

		if not IsValid( WorldModel ) then 
			self:RefreshWorldModel()

			continue
		end

		local data = hiltObject.info.ParentData[ self.HAND_STRING[ handID ] ]

		local offsetVec = data.pos
		local offsetAng = data.ang
		local boneid = ply:LookupBone( data.bone )

		if not boneid then continue end

		local matrix = ply:GetBoneMatrix( boneid )

		if not matrix then continue end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		WorldModel:SetPos( newPos )
		WorldModel:SetAngles( newAng )
		WorldModel:SetupBones()
		WorldModel:DrawModel()

		if Mul <= 0 then continue end

		local Positions = hiltObject.info.GetBladePos( WorldModel, self, ply )

		if not Positions then continue end

		local COMBO = self:GetCombo()

		for _, PosData in ipairs( Positions ) do
			local BladeData = self:GetBladeData( handID )

			if not IsValid( target ) then
				if (handID == 2 and not COMBO.LeftSaberActive) then continue end
			end

			if BladeData then
				self:DrawBlade( handID, BladeID, PosData, BladeData, Mul, newAng )
				if not BladeData.no_trail and not PosData.no_trail then
					self:CalcTrail( handID, BladeID, PosData, BladeData, Mul )
				end
			end

			BladeID = BladeID + 1
		end
	end
end

function SWEP:RefreshWorldModel()
	self._oldHiltR = nil
	self._oldHiltL = nil
	self._oldBladeR = nil
	self._oldBladeL = nil
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_magnastaff.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_purgevibrosword.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Purge Sword"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("vibrosword1") 
		self:SetBladeR("elstl") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_sycthe.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Sycthe"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("sycthe") 
		self:SetBladeR("sycthecrys") 
	end
end
--PATH lua/weapons/weapon_lvsrepair.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_nanosword.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category			= "[LSCS]"
SWEP.PrintName		= "Dragon's Tooth Sword"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.Slot				= 0
SWEP.SlotPos			= 1

SWEP.Spawnable		= true
SWEP.AdminOnly		= true

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("nanosword")
		self:SetBladeR("nanoparticles")
	end
end

--PATH lua/weapons/weapon_shaman.lua:
AddCSLuaFile()

SWEP.VElements = {
	["Glowy"] = { type = "Sprite", sprite = "sprites/plasmaember", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 0.518), size = { x = 10, y = 10 }, color = Color(46, 255, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}
SWEP.WElements = {
	["Glowy"] = { type = "Sprite", sprite = "sprites/physcannon_blueglow", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.517, 1.84, -0.622), size = { x = 10, y = 10 }, color = Color(46, 255, 255, 103), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}
SWEP.HoldType = "slam"

SWEP.ViewModelFlip = false 

SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_grenade.mdl"

--SWEP.WorldModel = ""
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 27.777, 0) },
	["ValveBiped.Bip01_R_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 27.777, 0) },
	["ValveBiped.Bip01_R_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 36.666, 0) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-0.673, -1.879, 0) },
	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 34.444, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.245, 2.427, 0), angle = Angle(14.444, -16.667, 50) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0.071, 0, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0.555, 0, 0), angle = Angle(0, 5.556, -14.445) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1.003, 1.003, 1.003), pos = Vector(0, 0, 0), angle = Angle(-37.258, 52.847, 4.78) },
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(14.444, -5.557, -94.445) }
}


SWEP.PrintName				= "Shaman Heal"
SWEP.Author					= "robotboy655 & Riddick"
SWEP.Purpose			= "Heal people with your primary attack, or yourself with the secondary. Burst heal with Reload"

SWEP.Slot					= 5
SWEP.SlotPos				= 4

SWEP.Spawnable				= true

--SWEP.ViewModel				= Model( "models/weapons/c_medkit.mdl" )
--SWEP.WorldModel				= Model( "models/weapons/w_medkit.mdl" )
SWEP.ViewModelFOV			= 65
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 200
SWEP.Primary.DefaultClip	= 200
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"


SWEP.HealAmount				= 100	-- Maximum heal amount per use
SWEP.MaxAmmo				= 200	-- Maxumum ammo


local HealSound = Sound( "starwars/items/bacta.wav" )
local DenySound = Sound( "WallHealth.Deny" )

function SWEP:Initialize()
	
	self:SetHoldType( "slam" )
	self.ultdelay = CurTime()
	--self.Owner:GetViewModel( ):SetMaterial( "materials/reskin/healthkit01.vtf" )
	if ( CLIENT ) then 
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		end 

	timer.Create( "medkit_ammo" .. self:EntIndex(), .2, 0, function()
		if ( self:Clip1() < self.MaxAmmo ) then self:SetClip1( math.min( self:Clip1() + 100, self.MaxAmmo ) ) end
	end )

end

function SWEP:PrimaryAttack()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 256,
		filter = self.Owner
	} )

	local ent = tr.Entity
	
	local need
	if ( IsValid( ent ) ) then need = math.min( ent.var - ent:Health(), ent.var * .25 ) end

	if ( IsValid( ent ) && self:Clip1() >= 50 && ( ent:IsPlayer() || ent:IsNPC() ) && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( need )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 5 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		self.Owner:EmitSound( DenySound )
		self:SetNextPrimaryFire( CurTime() + .1 )

	end

end

function SWEP:SetNextUltFire(time)
    self.ultdelay = CurTime() + time
end

function SWEP:Think()

    if self.Owner:KeyPressed( IN_RELOAD ) and (self.ultdelay <= CurTime()) then
	self:SetNextUltFire(10)
	print("test")
        	local me = self.Owner
	
	local need = self.HealAmount
	//------------------------------------------------------------------------magic------------------------------------------------------------------------------------------------------------------------------------------------
	//util.BlastDamage( self, entowner, self.Entity:GetPos(), 165, 4 )
	local tobeblasted = ents.FindInSphere( me:GetPos(), 500 )
	for k, v in pairs( tobeblasted ) do
		 
		if v:IsPlayer() then
			
			//if v == entowner then return end

			if ( SERVER ) then
				v:SetHealth( math.min( v.var, v:Health() + (v.var * .5) ) )
				//v:Kill()
			end				
		end
		
	end
	me:EmitSound("bacta/wukie.wav", 100, 100,.3)
	//me:EmitSound("footsteps/concrete4.wav", 100, 75)
	local effectdata = EffectData() 
	effectdata:SetOrigin( me:GetPos() )
	//effectdata:SetScale( 1 )
	util.Effect("effect_magicheal",effectdata)
	//------------------------------------------------------------------------magic end ------------------------------------------------------------------------------------------------------------------------------------------------
		
		self:SetNextPrimaryFire( CurTime() + 1 )

    end
	
end
--[[
function SWEP:Reload()

	local me = self.Owner
	
	local need = self.HealAmount
	//------------------------------------------------------------------------magic------------------------------------------------------------------------------------------------------------------------------------------------
	//util.BlastDamage( self, entowner, self.Entity:GetPos(), 165, 4 )
	local tobeblasted = ents.FindInSphere( me:GetPos(), 500 )
	for k, v in pairs( tobeblasted ) do
		 
		if v:IsPlayer() then
			
			//if v == entowner then return end
			if ( SERVER ) then
				v:SetHealth( math.min( v.var, v:Health() + (v.var * .5) ) )
				//v:Kill()
			end				
		end
		
	end
	me:EmitSound("bacta/wukie.wav", 100, 75)
	local effectdata = EffectData() 
	effectdata:SetOrigin( me:GetPos() )
	//effectdata:SetScale( 1 )
	util.Effect("effect_magicheal",effectdata)
	//------------------------------------------------------------------------magic end ------------------------------------------------------------------------------------------------------------------------------------------------
		
		self:SetNextPrimaryFire( CurTime() + 1 )

	end
]]--
function SWEP:SecondaryAttack()

	if ( CLIENT ) then return end

	local ent = self.Owner
	--print (ent.var)
	local need
	
	if ( IsValid( ent ) ) then
	need = math.min( ent.var - ent:Health(), ent.var * .25 ) 
	end
	
	if ( IsValid( ent ) && self:Clip1() >= need && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( 50 )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		--self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() + 1 )
		self:SetNextSecondaryFire( CurTime() + 1 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		ent:EmitSound( DenySound )
		self:SetNextSecondaryFire( CurTime() + 1 )

	end

	end



function SWEP:OnRemove()

	timer.Stop( "medkit_ammo" .. self:EntIndex() )
	timer.Stop( "weapon_idle" .. self:EntIndex() )
	self:Holster()

end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	

	timer.Stop( "weapon_idle" .. self:EntIndex() )
	
	return true

end

function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {} 
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay

end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)
		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end
		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end
	function SWEP:CreateModels( tab )
		if (!tab) then return end
		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

--PATH lua/weapons/weapon_standardswordart/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_training_saber.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_blaster/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_k3/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "K-3"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.MadeForNPCsOnly 			= true -- Is this weapon meant to be for NPCs only?
SWEP.WorldModel					= "models/vj_weapons/w_k3.mdl"
SWEP.HoldType 					= "ar2"
	-- World Model ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(-10, 0, 180)
SWEP.WorldModel_CustomPositionOrigin = Vector(-10, -8, -61)
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 12 -- Damage
SWEP.Primary.Force				= 1 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 45 -- Max amount of bullets per clip
SWEP.Primary.Ammo				= "357" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/k3_armenian/k3_fire.wav"}
SWEP.Primary.DistantSound		= {"vj_weapons/k3_armenian/k3_fire_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = "muzzle"
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_RifleShell1"
--PATH lua/weapons/weapon_vj_m16a1/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_npccontroller/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_rpg/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "RPG"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 4 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.UseHands					= true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 5 -- Next time it can use primary fire
SWEP.NPC_TimeUntilFire	 		= 0.8 -- How much time until the bullet/projectile is fired?
SWEP.NPC_ReloadSound			= {"vj_weapons/reload_rpg.wav"}
SWEP.NPC_BulletSpawnAttachment = "missile" -- The attachment that the bullet spawns on, leave empty for base to decide!
SWEP.NPC_FiringDistanceScale = 2.5 -- Changes how far the NPC can fire | 1 = No change, x < 1 = closer, x > 1 = farther
SWEP.NPC_StandingOnly = true -- If true, the weapon can only be fired if the NPC is standing still
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/c_rpg7.mdl" // "models/weapons/c_rpg.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_ins_rpg7.mdl" // "models/weapons/w_rocket_launcher.mdl"
SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(-10, 0, 180)
SWEP.WorldModel_CustomPositionOrigin = Vector(-1.5, -0.5, 1)
SWEP.HoldType 					= "rpg"
SWEP.ViewModelFOV				= 60 -- Player FOV for the view model
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 5 -- Damage
SWEP.Primary.Force				= 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 1 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 0.6 -- How much recoil does the player get?
SWEP.Primary.Delay				= 0.3 -- Time until it can shoot again
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "RPG_Round" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/rpg/rpg_fire.wav"}
SWEP.Primary.DistantSound		= {"vj_weapons/rpg/rpg_fire_far.wav"}
SWEP.Primary.DisableBulletCode	= true -- The bullet won't spawn, this can be used when creating a projectile-based weapon
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_SpawnShells = false
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound				= true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.Reload_TimeUntilAmmoIsSet	= 0.8 -- Time until ammo is set to the weapon
SWEP.ReloadSound				= "vj_weapons/reload_rpg.wav"
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_BeforeShoot()
	if CLIENT then return end
	local owner = self:GetOwner()
	local proj = ents.Create("obj_vj_tank_shell")
	local ply_Ang = owner:GetAimVector():Angle()
	local ply_Pos = owner:GetShootPos() + ply_Ang:Forward()*-20 + ply_Ang:Up()*-9 + ply_Ang:Right()*10
	if owner:IsPlayer() then proj:SetPos(ply_Pos) else proj:SetPos(self:GetNW2Vector("VJ_CurBulletPos")) end
	if owner:IsPlayer() then proj:SetAngles(ply_Ang) else proj:SetAngles(owner:GetAngles()) end
	proj:SetOwner(owner)
	proj:Activate()
	proj:Spawn()
	
	local phys = proj:GetPhysicsObject()
	if IsValid(phys) then
		if owner:IsPlayer() then
			phys:SetVelocity(owner:GetAimVector() * 2500)
		else
			phys:SetVelocity(owner:CalculateProjectile("Line", self:GetNW2Vector("VJ_CurBulletPos"), owner:GetEnemy():GetPos() + owner:GetEnemy():OBBCenter(), 2500))
		end
	end
	
	self:SetBodygroup(1, 1)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttackEffects()
	//ParticleEffect("vj_rpg2_smoke1", self:GetAttachment(3).Pos, Angle(0,0,0), self)
	ParticleEffectAttach("smoke_exhaust_01a", PATTACH_POINT_FOLLOW, self, 2)
	ParticleEffectAttach("smoke_exhaust_01a", PATTACH_POINT_FOLLOW, self, 2)
	ParticleEffectAttach("smoke_exhaust_01a", PATTACH_POINT_FOLLOW, self, 2)
	timer.Simple(4, function() if IsValid(self) then self:StopParticles() end end)
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnReload_Finish()
	self:SetBodygroup(1, 0)
	return true
end
--PATH lua/entities/arccw_ammo_smg1.lua:
return gluapack()()
--PATH lua/entities/arccw_att_base/shared.lua:
return gluapack()()
--PATH lua/entities/arccw_att_dropped.lua:
AddCSLuaFile()

ENT.Base = "arccw_att_base"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Category = "ArcCW - Attachments"
ENT.PrintName = "Attachment Box"
ENT.Spawnable = false

ENT.Model = "models/Items/BoxMRounds.mdl"

function ENT:Draw()
    self:DrawModel()

    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

    if (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()
        local name = self:GetNWString("boxname", nil) or self.PrintName

        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)

        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 14), ang, 0.1)
            surface.SetFont("ArcCW_32_Unscaled")
            local w = surface.GetTextSize(name)

            surface.SetTextPos(-w / 2 + 2, 2)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(name)

            surface.SetTextPos(-w / 2, 0)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(name)

            local count = self:GetNWInt("boxcount", 0)
            local str = count .. " Attachment" .. (count != 1 and "s" or "")
            local w2 = surface.GetTextSize(str)

            surface.SetTextPos(-w2 / 2 + 2, 26)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(str)
            surface.SetTextPos(-w2 / 2, 24)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(str)
        cam.End3D2D()
    end
end
--PATH lua/entities/aura_lvs_9799/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Landers"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/starwars/syphadias/ships/c9799/c9799-prop.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 300000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 800, right = 0, up = 200}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 40
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(1150,200,400),
	[2] = Vector(1150,-200,400),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(180,0,-5),
	[2] = Angle(180,0,-5)
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 800},
	{forward = 1000, right = 0, up = 600},
	{forward = -1000, right = 0, up = 400},
	{forward = 0, right = 0, up = 800},
	{forward = 500, right = 2000, up = 800},
	{forward = 500, right = -2000, up = 800},
	{forward = -500, right = 0, up = 600},
	{forward = -1500, right = 0, up = 800},
}
--PATH lua/entities/aura_lvs_aa-9_liner/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | AA-9 Liner"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/airbus/syphadias/airbus.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_acclamator_mk2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_arquitens/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_arquitens/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo3/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo3/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo4/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo5/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_consular/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_consular/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Consulaire"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/diggerthings/consular/unarmed1.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 80000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-200,0,490),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 300, right = 0, up = 0},
	{forward = 1200, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
	{forward = -1200, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_cr25/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | CR25"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/kirillotron/rc ships/rep_dropship_fixed.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-300,0,460),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_hardcell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_lucrehulk/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_munificent_mk2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Munificent"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/munificent-class.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = 300}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/muni_fire.mp3")

ENT.PRIMARYDAMAGE			= 40
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(1950,-700,1380),
	[2] = Vector(3230,-500,1380),
	[3] = Vector(110,850,1700),
	[4] = Vector(110,-850,1700),
	[5] = Vector(110,850,1630),
	[6] = Vector(110,-850,1630),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(180,0,0),
	[2] = Angle(180,0,0),
	[3] = Angle(0,-90,0),
	[4] = Angle(0,90,0),
	[5] = Angle(0,-90,180),
	[6] = Angle(0,90,180),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 1800},
	{forward = 1000, right = 0, up = 1600},
	{forward = 2000, right = 0, up = 1400},
	{forward = 3000, right = 0, up = 1800},
	{forward = -1000, right = 0, up = 1600},
	{forward = -2500, right = 0, up = 1800},
}
--PATH lua/entities/aura_lvs_providence_mk2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_providence_mk2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_recusant/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_csi_2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_neu_1/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/b-wing.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_electric/shared.lua:
ENT.Type            = "anim"
ENT.Base            = "base_gmodentity"

ENT.PrintName       = "Electric"
ENT.Category        = "City Worker"
ENT.Author          = "Silhouhat"
ENT.Contact 	    = "contact@silhouhat.com"

ENT.Spawnable   	= false
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_leak/shared.lua:
return gluapack()()
--PATH addons/!jobs/lua/entities/custom_moneyprinter/cl_init.lua:
--[[---------------------------------------------------------------------------
This is an example of a custom entity.
---------------------------------------------------------------------------]]
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
    self:DrawModel()

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

    surface.SetFont("HUDNumber5")
    local text = DarkRP.getPhrase("money_printer")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(owner)

    Ang:RotateAroundAxis(Ang:Up(), 90)

    cam.Start3D2D(Pos + Ang:Up() * 11.5, Ang, 0.11)
        draw.WordBox(2, -TextWidth * 0.5, -30, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
        draw.WordBox(2, -TextWidth2 * 0.5, 18, owner, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()
end

function ENT:Think()
end

--PATH addons/!jobs/lua/entities/custom_moneyprinter/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_tip_jar/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Tip Jar"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsTipjar = true

function ENT:initVars()
    self.model = "models/props_lab/jar01a.mdl"
    self.damage = 100
    self.callOnRemoveId = "tipjar_activedonation_" .. self:EntIndex() .. "_"

    self.activeDonations = {}
    self.madeDonations = {}

    self.PlayerUse = true
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
end

function ENT:UpdateActiveDonation(ply, amount)
    local old = self.activeDonations[ply]
    self.activeDonations[ply] = amount

    self:PruneActiveDonations()

    ply:CallOnRemove(self.callOnRemoveId .. ply:UserID(), function()
        if not IsValid(self) then return end

        self:ExitActiveDonation(ply)
    end)

    hook.Call("tipjarUpdateActiveDonation", DarkRP.hooks, self, ply, amount, old)
end

function ENT:ExitActiveDonation(ply)
    local old = self.activeDonations[ply]

    self.activeDonations[ply] = nil

    self:PruneActiveDonations()
    hook.Call("tipjarExitActiveDonation", DarkRP.hooks, self, ply, old)

    self:RemoveCallOnRemove(self.callOnRemoveId .. ply:UserID())
end

function ENT:ClearActiveDonations()
    table.Empty(self.activeDonations)
    hook.Call("tipjarClearActiveDonation", DarkRP.hooks, self)
end

function ENT:PruneActiveDonations()
    for ply, _ in pairs(self.activeDonations) do
        if not IsValid(ply) then self.activeDonations[ply] = nil end
    end
end

function ENT:AddDonation(name, amount)
    local lastDonation = self.madeDonations[#self.madeDonations]

    if lastDonation and lastDonation.name == name then
        lastDonation.amount = lastDonation.amount + amount
    else
        table.insert(self.madeDonations, {
            name = name,
            amount = amount,
        })
   end

   -- Enforce maximum of 100 donations
   while #self.madeDonations > 100 do
       table.remove(self.madeDonations, 1)
   end
end

function ENT:ClearDonations()
    table.Empty(self.madeDonations)
end

--PATH lua/entities/delta.lua:
return gluapack()()
--PATH lua/entities/e60r_rocket2/cl_init.lua:
return gluapack()()
--PATH lua/entities/ent_realistic_hook.lua:
return gluapack()()
--PATH lua/entities/ent_rw_rocket/shared.lua:
return gluapack()()
--PATH lua/entities/ent_wballoon/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--PATH lua/entities/ent_wballoon/shared.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/entities/f_leaderboard/cl_init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/fire_spawned2/shared.lua:
-- Made by Matsilagi

AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false


function ENT:Draw()
	
end

function ENT:Initialize()
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/arccw/kraken/sw/explosives/world/w_thermalimploder.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
	end
	ParticleEffect( "molotov_explosion", self:GetPos(), self:GetAngles() )
	self:EmitSound( "ArcCW_Kraken.Explosives.IncendiaryLoop" )
end

function ENT:Think()
	if self:GetNWBool("extinguished",true) then
		ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
		if SERVER then
			self:Remove()
		end
	end
end

function ENT:OnRemove()
	self:EmitSound( "ArcCW_Kraken.Explosives.IncendiaryFadeOut" )
    self:StopSound( "ArcCW_Kraken.Explosives.IncendiaryLoop" )
end
--PATH gamemodes/starwarsrp/entities/entities/gunlab/shared.lua:
ENT.Base = "lab_base"
ENT.PrintName = "Gun Lab"

function ENT:initVars()
    self.model = "models/props_c17/TrapPropeller_Engine.mdl"
    self.initialPrice = GAMEMODE.Config.gunlabguncost
    self.labPhrase = DarkRP.getPhrase("gun_lab")
    self.itemPhrase = DarkRP.getPhrase("gun")
end

--PATH lua/entities/intercom/client.lua:
return gluapack()()
--PATH lua/entities/laat_hatch/shared.lua:
return gluapack()()
--PATH lua/entities/laat_rocketlauncher/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--PATH gamemodes/starwarsrp/entities/entities/letter/cl_init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_stance_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_holocron_base"
DEFINE_BASECLASS( "lscs_holocron_base" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.GlowMat = Material( "sprites/light_glow02_add" )
ENT.GlowCol = Color(255,200,0,255)

if CLIENT then
	function ENT:DrawTranslucent()
		self:DrawModel()
	end

	function ENT:Draw()
		-- ironic, in order to look nice the translucent sprite has to be rendered normal while the solid model has to be rendered translucent
		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self:GetPos(), 64, 64, self.GlowCol )
	end
end
--PATH lua/entities/lvs_armor.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_init.lua:
include("shared.lua")
include( "sh_weapons.lua" )
include( "cl_effects.lua" )
include( "cl_hud.lua" )
include( "cl_seatswitcher.lua" )
include( "cl_trailsystem.lua" )
include( "cl_boneposeparemeter.lua" )

local Zoom = 0

function ENT:LVSCalcFov( fov, ply )

	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 0 or 1

	Zoom = Zoom + (TargetZoom - Zoom) * RealFrameTime() * 10

	local newfov = fov * Zoom + (self.ZoomFov or 40) * (1 - Zoom)

	return newfov
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:PreDraw( flags )
	return true
end

function ENT:PreDrawTranslucent( flags )
	return true
end

function ENT:PostDraw( flags )
end

function ENT:PostDrawTranslucent( flags )
end

function ENT:Draw( flags )
	if self:PreDraw( flags ) then
		if self.lvsLegacyDraw then
			self:DrawModel() -- ugly, but required in order to fix old addons. Refract wont work on these.
		else
			self:DrawModel( flags )
		end
	end

	self:PostDraw( flags )
end

function ENT:DrawTranslucent( flags )
	self:DrawTrail()

	if self:PreDrawTranslucent( flags ) then
		self:DrawModel( flags )
	else
		self.lvsLegacyDraw = true -- insert puke simley
	end

	self:PostDrawTranslucent( flags )
end

function ENT:Initialize()
	self:OnSpawn()

	if not istable( self.GibModels ) then return end

	for _, modelName in ipairs( self.GibModels ) do
		util.PrecacheModel( modelName )
	end
end

function ENT:OnSpawn()
end

function ENT:OnFrameActive()
end

function ENT:OnFrame()
end

function ENT:OnEngineActiveChanged( Active )
end

function ENT:OnActiveChanged( Active )
end

ENT._oldActive = false
ENT._oldEnActive = false

function ENT:HandleActive()
	local EntTable = self:GetTable()

	local Active = self:GetActive()
	local EngineActive = self:GetEngineActive()
	local ActiveChanged = false

	if EntTable._oldActive ~= Active then
		EntTable._oldActive = Active
		EntTable:OnActiveChanged( Active )
		ActiveChanged = true
	end

	if EntTable._oldEnActive ~= EngineActive then
		EntTable._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
		ActiveChanged = true
	end

	if ActiveChanged then
		if Active or EngineActive then
			self:StartWindSounds()
		else
			self:StopWindSounds()
		end
	end

	if Active or EngineActive then
		self:DoVehicleFX()
	end

	self:FlyByThink()

	return EngineActive
end

function ENT:Think()
	if not self:IsInitialized() then return end
 
	if self:HandleActive() then
		self:OnFrameActive()
	end

	self:HandleTrail()
	self:OnFrame()
end

function ENT:OnRemove()
	self:StopEmitter()
	self:StopWindSounds()
	self:StopFlyBy()
	self:StopDeathSound()

	self:OnRemoved()
end

function ENT:OnRemoved()
end

function ENT:CalcDoppler( Ent )
	if not IsValid( Ent ) then return 1 end

	if Ent:IsPlayer() then
		local ViewEnt = Ent:GetViewEntity()
		local Vehicle = Ent:lvsGetVehicle()

		if IsValid( Vehicle ) then
			if Ent == ViewEnt then
				Ent = Vehicle
			end
		else
			if IsValid( ViewEnt ) then
				Ent = ViewEnt
			end
		end
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:GetCrosshairFilterEnts()
	if not self:IsInitialized() then return { self } end -- wait for the server to be ready

	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {self}

		-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	return self.CrosshairFilterEnts
end

function ENT:FlyByThink()
end

function ENT:StopFlyBy()
end

function ENT:StopDeathSound()
end

function ENT:OnDestroyed()
end

net.Receive( "lvs_vehicle_destroy", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not isfunction( ent.OnDestroyed ) then return end

	ent:OnDestroyed()
end )

--PATH lua/entities/lvs_base/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_trailsystem.lua:

ENT.TrailMaterial = Material( "trails/smoke" )
ENT.TrailRed = 255
ENT.TrailGreen = 255
ENT.TrailBlue = 255
ENT.TrailAlpha = 100

function ENT:OnTrail( active, id )
end

function ENT:HandleTrail()
	if not self.RegisteredTrailPositions then return end

	local FT = RealFrameTime()

	local pos = self:GetPos()
	local vel = self:GetVelocity()
	local vel_length = vel:Length()

	for id, data in pairs( self.RegisteredTrailPositions ) do
		local cur_pos = self:LocalToWorld( data.pos )
		local cur_vel = (cur_pos - data.oldpos) / FT

		local cur_velL = math.abs( self:WorldToLocal( pos + cur_vel ).z )

		if cur_velL > data.activation_speed and vel_length > data.min_flight_speed then
			if not data.id then
				data.id = self:StartTrail( data.pos, data.startsize, data.endsize, data.lifetime )
				self:OnTrail( true, data.id )
			end
		else
			if data.id then
				self:OnTrail( false, data.id )
				self:FinishTrail( data.id )
				data.id = nil
			end
		end

		data.oldpos = cur_pos
	end
end

function ENT:RegisterTrail( Pos, StartSize, EndSize, LifeTime, min_flight_speed, activation_speed )
	if not istable( self.RegisteredTrailPositions ) then
		self.RegisteredTrailPositions = {}
	end

	local data = {
		pos = Pos,
		oldpos = self:LocalToWorld( Pos ),
		startsize = StartSize,
		endsize = EndSize,
		lifetime = LifeTime,
		min_flight_speed = min_flight_speed,
		activation_speed = activation_speed,
	}

	table.insert( self.RegisteredTrailPositions, data )
end

function ENT:StartTrail( Pos, StartSize, EndSize, LifeTime )
	if not LVS.ShowTraileffects then return end

	if not istable( self.TrailActive ) then
		self.TrailActive = {}
	end

	local ID = 1
	for _,_ in ipairs( self.TrailActive ) do
		ID = ID + 1
	end

	self.TrailActive[ ID ] = {
		lifetime = LifeTime,
		start_size = StartSize,
		end_size = EndSize,
		pos = Pos,
		active = true,
		positions = {},
	}

	return ID
end

function ENT:FinishTrail( ID )
	self.TrailActive[ ID ].active = false
end

function ENT:DrawTrail()
	local EntTable = self:GetTable()

	if not EntTable.TrailActive then return end

	local Time = CurTime()

	EntTable._NextTrail = EntTable._NextTrail or 0

	local Set = EntTable._NextTrail < Time

	render.SetMaterial( EntTable.TrailMaterial )

	for ID, data in pairs( EntTable.TrailActive ) do

		for pos_id, pos_data in pairs( data.positions ) do
			if Time - pos_data.time > data.lifetime then
				data.positions[ pos_id ] = nil
			end
		end

		if Set then
			if data.active then
				local cur_pos = {
					time = Time,
					pos = self:LocalToWorld( data.pos ),
				}

				table.insert( data.positions, cur_pos )
				table.sort( data.positions, function( a, b ) return a.time > b.time end )
			end
		end

		local num = #data.positions

		if num == 0 then 
			if not data.active then
				EntTable.TrailActive[ ID ] = nil
			end

			continue
		end

		render.StartBeam( num )

		for _, pos_data in ipairs( data.positions ) do
			local Scale = (pos_data.time + data.lifetime - Time) / data.lifetime
			local InvScale = 1 - Scale

			render.AddBeam( pos_data.pos, data.start_size * Scale + data.end_size * InvScale, pos_data.time * 50, Color( EntTable.TrailRed, EntTable.TrailGreen, EntTable.TrailBlue, EntTable.TrailAlpha * Scale ^ 2 ) )
		end

		render.EndBeam()
	end

	if Set then
		EntTable._NextTrail = Time + 0.025
	end
end

--PATH lua/entities/lvs_base_fakehover/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/cl_deathsound.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_barc/cl_init.lua:
include("shared.lua")


function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-25,32.5,20) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-42.5,-32.5,20) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_muzzle_colorable", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 5 - self:GetUp() * -5, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "drive_airboat" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "lvs_muzzle_colorable" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "drive_airboat" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end


--PATH lua/entities/lvs_fakehover_iftx/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,-65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 40 - self:GetUp() * 20, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "sit_rollercoaster" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "sit_rollercoaster" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end

--PATH lua/entities/lvs_fakehover_soundemitter.lua:
AddCSLuaFile()

ENT.Base = "lvs_starfighter_soundemitter"

if SERVER then return end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle()
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local VolumeSetNow = false

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		VolumeSetNow = true
		self._lvsoldDrivingMe = DrivingMe
	end

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + Throttle * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = Throttle > data.FadeOut or Throttle < data.FadeIn
		if data.FadeOut >= 1 and Throttle > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(Throttle - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )
				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

--PATH lua/entities/lvs_gunship_hmp/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/sh_mainweapons.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_drawing.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_prediction.lua:

function ENT:PredictBTL()
	local pod = self:GetBTPodL()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosBTL()
	self:SetPoseParameterBTL( pod:lvsGetWeapon() )
end

function ENT:PredictBTR()
	local pod = self:GetBTPodR()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosBTR()
	self:SetPoseParameterBTR( pod:lvsGetWeapon() )
end

function ENT:PredictPoseParamaters()
	self:PredictBTL()
	self:PredictBTR()

	self:InvalidateBoneCache()
end
--PATH lua/entities/lvs_space_laat/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_space_laat_arc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.nextEFX = 0
	self.nextDFX = 0
	self.nextBeepSound = 0
	self.nextLFX = 0
	self.NextAlertSound = 0
	--self.ActiveTime = CurTime()
	self.bommed = false
	self.onact = false
end


local spotlight = Material("effects/lvs/laat_spotlight")
local glow_spotlight = Material("sprites/light_glow02_add")
local spotlight_color = Color(255, 255, 255)
local glow_color = Color(255, 255, 255, 10)
local glow_reactor = Material("sprites/light_glow02_add")
local lamp_pos = Vector(3, 0, 135)
local lamp_color_black = Color(0, 0, 0)
local lamp_color_red = Color(255, 0, 0)
local lamp_color_green = Color(0, 255, 0)
local reactor_color = Color(0, 127, 255)
local reactor_pos = {
	Vector(-270, -20, 265),
	Vector(-270, 20, 265),
}

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lfs_fb_wingturret_projector", effectdata )
	end
end



function ENT:OnFrame()
	self:Boom()

	self:WingTurretProjector()

	self:ENGCheck()

	self:DamageFX()

	self:ExhaustFX()

end

function ENT:Boom()
	if self:GetHP() > 2200 then
		self.bommed = false
		self:StopParticles()
	end
	if self.bommed == false then
		if self:GetHP() < 2200 then
			ParticleEffectAttach("env_fire_large_smoke", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("R_Heat_Hatch"))
			self.bommed = true
			local effectdata = EffectData()
				effectdata:SetOrigin(self:LocalToWorld(Vector(-300, 0, 180)))
			util.Effect("lvs_explosion_small", effectdata)
		end
	end
end

function ENT:ENGCheck()
	if self.onact == false then
		if self:GetEngineActive() == true then
			self.ActiveTime = CurTime()
			self.onact = true
			self.nextEFX = CurTime() + 1
		end
	end
	if self.onact == true then
		if self:GetEngineActive() == false then
			self.onact = false
			self.StopTime = CurTime()
		end
	end
	if self:GetEngineActive() == false then
		self.onact = false
	end
end

function ENT:ExhaustFX()
	local FullThrottle = self:GetThrottle() >= 35

	if self.OldFullThrottle ~= FullThrottle then
		self.OldFullThrottle = FullThrottle
		if FullThrottle then 
			self:EmitSound("laat_bf2/boost_"..math.random(1, 2)..".wav")
		end
	end

	if self:GetEngineActive() then
		if self.nextEFX < CurTime() then
			self.nextEFX = CurTime() + 0.01
			
			local emitter = ParticleEmitter(self:GetPos(), false)
			local Pos = {
				Vector(-270, -20, 265),
				Vector(-270, 20, 265),
			}

			if emitter then
				for _, v in pairs(Pos) do
					local vOffset = self:LocalToWorld( v )
					local vNormal = -self:GetForward()
					local vOffset2 = vOffset + vNormal * 5

					local particle = emitter:Add("sprites/heatwave", vOffset2)
					if not particle then return end
						particle:SetVelocity(vNormal * math.Rand(1500, 1000) + self:GetVelocity())
						particle:SetLifeTime(0)
						particle:SetDieTime(0.1)
						particle:SetStartAlpha(255)
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(35, 50))
						particle:SetEndSize(math.Rand(0, 5))
						particle:SetRoll(math.Rand(-1, 1) * 100)
						particle:SetColor(255, 255, 255)
				end
				
				emitter:Finish()
			end
		end
	end
end

function ENT:CanSound()
	self.NextSound = self.NextSound or 0
	return self.NextSound < CurTime()
end

function ENT:CanSound2()
	self.NextSound2 = self.NextSound2 or 0
	return self.NextSound2 < CurTime()
end

function ENT:DelayNextSound( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound = CurTime() + fDelay
end

function ENT:DelayNextSound2( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound2 = CurTime() + fDelay
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(math.Clamp(math.Clamp(80 + Pitch * 25, 50, 255) + Doppler, 0, 255))
		self.ENG:ChangeVolume(math.Clamp(-1 + Pitch * 6, 0.5, 1))
	end
	
	if self.DIST then
		local ply = LocalPlayer()
		local DistMul = math.min((self:GetPos() - ply:GetPos()):Length() / 8000, 1) ^ 2
		self.DIST:ChangePitch(math.Clamp(100 + Doppler * 0.2, 0, 255))
		self.DIST:ChangeVolume(math.Clamp(-1.5 + Pitch * 6, 0.5, 1) * DistMul)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP <= 0 or HP > self:GetMaxHP() * 0.5 then return end

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)

		if HP <= 2200 then
			if math.random(0, 45) < 3 then
				if math.random(1, 3) == 1 then
					local Pos = self:LocalToWorld(Vector(0, 0, 140) + VectorRand() * 20)
						effectdata:SetOrigin(Pos)
					util.Effect("cball_explode", effectdata, true, true)
					sound.Play("laat_bf2/spark"..math.random(1, 4)..".ogg", Pos, 75)
				end
			end

			local ply = LocalPlayer()
			if self.NextAlertSound < CurTime() then
				self.NextAlertSound = CurTime() + 0.27
				self:EmitSound( "laat_bf2/crash.mp3", 85 )

				--sound.Play("laat_bf2/crash.mp3", self:GetPos() + self:GetForward() * 190 + self:GetUp() * 160, 75)
			end
		end
	end
end



function ENT:Draw()
	self:DrawModel()

	if self:GetEngineActive() then
		render.SetMaterial(glow_reactor)
		local delta = CurTime() - self.ActiveTime
		local max = math.min(15 * ( delta / 1 ), 15)

		local t = 0
		for _, v in pairs(reactor_pos) do
			if self:GetHP() < 2200 then
				if self.nextLFX > CurTime() && t == 1 then continue end
				self.nextLFX = CurTime() + math.random(0, 2)
			end

			local vOffset = self:LocalToWorld(v)
			local vNormal = -self:GetForward()
			
			for i = 0, max do 
				local vUp = -self:GetUp()
				local ind = i * 2
				local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

				render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
			end

			t = t + 1
		end
	else
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 1)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[2])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
			
		end
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 2)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[1])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
		end
	end
	local StartPos = self:LocalToWorld(lamp_pos)
	render.SetMaterial(glow_spotlight)
	local lamp_mode = self:GetLampMode()
	render.DrawSprite(StartPos, 80, 80, lamp_mode == 0 && lamp_color_black || lamp_mode == 1 && lamp_color_red || lamp_color_green)

	if not self:IsSpotlightMounted() or not self:GetSpotlightOn() or not self:GetEngineActive() then 
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:OnRemove()
	self:RemoveLight()
	self:RemoveLight2()
end

function ENT:RemoveLight2()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	render.SetMaterial(glow_spotlight)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, spotlight_color)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color) 
	
	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
		spotlight:SetBrightness(10) 
		spotlight:SetTexture("effects/flashlight/soft")
		spotlight:SetColor(spotlight_color) 
		spotlight:SetEnableShadows(false) 
		spotlight:SetFarZ(5000) 
		spotlight:SetNearZ(75) 
		spotlight:SetFOV(40)
	
	return spotlight
end

function ENT:OnSpawn()

end

--[[


function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end
end
]]--
function ENT:OnStartBoost()
	self:EmitSound( "laat_bf2/boost_"..math.random(1, 2)..".wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod == self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

--[[
function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() or self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end]]

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight2()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 4000 ) 
		thelamp:SetNearZ( 1 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(332.26,-2.1,5.41),
		Ang = Angle(135.25,-0.01,0.71)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 0, 20, 20, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 0,  StartPos + Dir * 100, 90, 0, 1, Color( 255, 255, 255, 12) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end
--PATH lua/entities/lvs_starfighter_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Float",1, "HP" )
	self:NetworkVar( "Float",2, "MaxHP" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 0, 255, 255 ) )
	end

	function ENT:Think()
		local T = CurTime()
		local vehicle = self:GetBase()

		if not self:GetDestroyed() or not IsValid( vehicle ) or not vehicle:GetEngineActive() then self:NextThink( T + 1 ) return true end

		local PhysObj = vehicle:GetPhysicsObject()

		local Pos = self:GetPos()
		local Len = vehicle:WorldToLocal( Pos ):Length()

		PhysObj:ApplyForceOffset( -vehicle:GetVelocity() * (PhysObj:GetMass() / Len) * FrameTime() * 50, Pos )

		self:NextThink( T )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )
		end
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	self:DamageFX( vehicle )
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = vehicle:GetHP()
	local MaxHP = vehicle:GetMaxHP() 

	if HP <= 0 then return end

	if (self.nextDFX or 0) > T then return end

	self.nextDFX = T + 0.05

	local Destroyed = self:GetDestroyed()

	if Destroyed or HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_engine_blacksmoke", effectdata )
	end

	if not Destroyed then return end

	if HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( -self:GetForward() )
			effectdata:SetMagnitude( 2 )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_exhaust_fire", effectdata )
	end
end

--PATH lua/entities/lvs_starfighter_n1/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "N1 Starfighter"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Royal Naboo Security Force"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.MDL = "models/blu/naboostarfighter.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 500
ENT.MaxShield = 100

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(118.24,18.04 * i,49.96) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 8
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = ent:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Vector(147.82,0,39.52) ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--PATH lua/entities/lvs_starfighter_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 40, 5, Color( 255, 255, 255 ) )
	end

	function ENT:CheckWater( Base )
		if bit.band( util.PointContents( self:GetPos() ), CONTENTS_WATER ) ~= CONTENTS_WATER then
			if self.CountWater then
				self.CountWater = nil
			end

			return
		end

		if Base.WaterLevelAutoStop > 3 then return end

		self.CountWater = (self.CountWater or 0) + 1

		if self.CountWater < 4 then return end

		Base:StopEngine()
	end

	function ENT:Think()

		local Base = self:GetBase()

		if IsValid( Base ) and Base:GetEngineActive() then
			self:CheckWater( Base )
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

ENT._oldEnActive = false
ENT._ActiveSounds = {}

function ENT:Initialize()
end

function ENT:StopSounds()
	for id, sound in pairs( self._ActiveSounds ) do
		if istable( sound ) then
			for _, snd in pairs( sound ) do
				if snd then
					snd:Stop()
				end
			end
		else
			sound:Stop()
		end
		self._ActiveSounds[ id ] = nil
	end
end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle() - vehicle:GetThrustStrenght() * vehicle:GetThrottle() * 0.5
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		self._lvsoldDrivingMe = DrivingMe

		self:StopSounds()

		self._oldEnActive = nil

		return
	end

	local FT = RealFrameTime()

	self._smTHR = self._smTHR and self._smTHR + (Throttle - self._smTHR) * FT or 0

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + self._smTHR * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = self._smTHR > data.FadeOut or self._smTHR < data.FadeIn
		if data.FadeOut >= 1 and self._smTHR > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(self._smTHR - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )

				if vehicle:HasActiveSoundEmitters() then
					Volume = Volume * 0.25
					fadespeed = fadespeed * 0.5
				end

				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

function ENT:OnEngineActiveChanged( Active )
	if not Active then self:StopSounds() return end

	local ply = LocalPlayer()
	local DrivingMe = ply:lvsGetVehicle() == self:GetBase()

	for id, data in pairs( self.EngineSounds ) do
		if not isstring( data.sound ) then continue end

		self.EngineSounds[ id ].Pitch = data.Pitch or 80
		self.EngineSounds[ id ].PitchMin = data.PitchMin or 0
		self.EngineSounds[ id ].PitchMax = data.PitchMax or 255
		self.EngineSounds[ id ].PitchMul = data.PitchMul or 100
		self.EngineSounds[ id ].UseDoppler = data.UseDoppler ~= false
		self.EngineSounds[ id ].FadeIn = data.FadeIn or 0
		self.EngineSounds[ id ].FadeOut = data.FadeOut or 1
		self.EngineSounds[ id ].FadeSpeed = data.FadeSpeed or 1.5
		self.EngineSounds[ id ].SoundLevel = data.SoundLevel or 85

		if data.sound_int and data.sound_int ~= data.sound and DrivingMe then
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			if data.sound_int == "" then
				self._ActiveSounds[ id ] = {
					ext = sound,
					int = false,
				}
			else
				local sound_interior = CreateSound( self, data.sound_int )
				sound_interior:SetSoundLevel( data.SoundLevel )
				sound_interior:PlayEx(0,100)

				self._ActiveSounds[ id ] = {
					ext = sound,
					int = sound_interior,
				}
			end
		else
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			self._ActiveSounds[ id ] = sound
		end
	end
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	if not self.EngineSounds then
		self.EngineSounds = vehicle.EngineSounds

		return
	end

	local EngineActive = vehicle:GetEngineActive()

	if self._oldEnActive ~= EngineActive then
		self._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
	end

	if EngineActive then
		self:HandleEngineSounds( vehicle )
	else
		self._smTHR = 0
	end
end

function ENT:OnRemove()
	self:StopSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--PATH lua/entities/lvs_turret.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_wire_entity" )

ENT.PrintName		= "Projectile Turret"
ENT.WireDebugName = "Projectile Turret"

ENT.Author		= "Blu-x92"
ENT.Information		= "Projectile Turret"
ENT.Category		= "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.Editable = true

ENT.TracerOptions = {
	["LaserBlue"] = "lvs_laser_blue",
	["LaserRed"] = "lvs_laser_red",
	["LaserGreen"] = "lvs_laser_green",
	["TracerGreen"] = "lvs_tracer_green",
	["TracerOrange"] = "lvs_tracer_orange",
	["TracerWhite"] = "lvs_tracer_white",
	["TracerYellow"] = "lvs_tracer_yellow",
	["AutoCannon"] = "lvs_tracer_autocannon",
	["Cannon"] = "lvs_tracer_cannon",
}

ENT.SplashTypeOptions = {
	Shrapnel = "lvs_bullet_impact",
	Explosive = "lvs_bullet_impact_explosive"
}

function ENT:SetupDataTables()
	local TracerOptions = {}

	for id, name in pairs( self.TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end

		TracerOptions[ id ] = name
	end

	self:NetworkVar( "Float",1, "ShootDelay", { KeyName = "Shoot Delay", Edit = { type = "Float", order = 1,min = 0, max = 2, category = "Options"} } )
	self:NetworkVar( "Float",2, "Damage", { KeyName = "Damage", Edit = { type = "Float", order = 2,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",3, "Speed", { KeyName = "Speed", Edit = { type = "Float", order = 3,min = 10000, max = 100000, category = "Options"} } )
	self:NetworkVar( "Float",4, "Size", { KeyName = "Size", Edit = { type = "Float", order = 4,min = 0, max = 50, category = "Options"} } )
	self:NetworkVar( "Float",5, "Spread", { KeyName = "Spread", Edit = { type = "Float", order = 5,min = 0, max = 1, category = "Options"} } )
	self:NetworkVar( "Float",6, "Penetration", { KeyName = "Armor Penetration (mm)", Edit = { type = "Float", order = 6,min = 0, max = 500, category = "Options"} } )
	self:NetworkVar( "Float",7, "SplashDamage", { KeyName = "Splash Damage", Edit = { type = "Float", order = 7,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",8, "SplashDamageRadius", { KeyName = "Splash Damage Radius", Edit = { type = "Float", order = 8,min = 0, max = 750, category = "Options"} } )

	self:NetworkVar( "String", 1, "SplashDamageType", { KeyName = "Splash Damage Type", Edit = { type = "Combo",	order = 9,values = self.SplashTypeOptions,category = "Options"} } )

	self:NetworkVar( "String", 2, "Tracer", { KeyName = "Tracer", Edit = { type = "Combo",	order = 10,values = TracerOptions,category = "Options"} } )

	if SERVER then
		self:SetShootDelay( 0.05 )
		self:SetSpeed( 30000 )
		self:SetDamage( 15 )
		self:SetTracer( "lvs_tracer_orange" )
		self:SetSplashDamageType( "lvs_bullet_impact" )
	end
end

if CLIENT then
	function ENT:GetCrosshairFilterEnts()
		if not istable( self.CrosshairFilterEnts ) then
			self.CrosshairFilterEnts = {self}

			-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
			net.Start( "lvs_player_request_filter" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self.CrosshairFilterEnts
	end

	return
end

function ENT:GetCrosshairFilterEnts()
	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {}

		for _, Entity in pairs( constraint.GetAllConstrainedEntities( self ) ) do
			if not IsValid( Entity ) then continue end

			table.insert( self.CrosshairFilterEnts , Entity )
		end

		for _, Parent in pairs( self.CrosshairFilterEnts ) do
			for _, Child in pairs( Parent:GetChildren() ) do
				if not IsValid( Child ) then continue end

				table.insert( self.CrosshairFilterEnts , Child )
			end
		end
	end

	return self.CrosshairFilterEnts
end

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local ent = ents.Create( ClassName )
	ent.Attacker = ply
	ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:TriggerInput( name, value )
	if name == "Fire" then
		self.TriggerFire = value >= 1
	end
end

function ENT:Initialize()	
	self:SetModel( "models/props_junk/PopCan01a.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )
	self:SetCollisionGroup( COLLISION_GROUP_WEAPON  ) 
	
	self:PhysWake()
	
	self.Inputs = WireLib.CreateInputs( self,{"Fire"} )
end

function ENT:SetNextShoot( time )
	self.NextShoot = time
end

function ENT:CanShoot()
	if not self.TriggerFire then return false end
	
	self.NextShoot = self.NextShoot or 0
	
	return self.NextShoot < CurTime()
end

local IsCannon = {
	["lvs_tracer_autocannon"] = 0.25,
	["lvs_tracer_cannon"] = 1,
}

function ENT:Shoot()
	if not self:CanShoot() then return end

	local Tracer = self:GetTracer()

	local bullet = {}
	bullet.Src 	= self:GetPos()
	bullet.Dir 	= self:GetUp()
	bullet.Spread 	= Vector(self:GetSpread(),self:GetSpread(),self:GetSpread())
	bullet.TracerName = Tracer
	bullet.Force	= self:GetPenetration() * 100
	bullet.HullSize 	= self:GetSize()
	bullet.Damage	= self:GetDamage()
	bullet.Velocity = self:GetVelocity():Length() + self:GetSpeed()

	if IsCannon[ Tracer ] then
		self:SetShootDelay( math.max( self:GetShootDelay(), IsCannon[ Tracer ] ) )
	end

	local SplashDamage = self:GetSplashDamage()
	local SplashDamageRadius = self:GetSplashDamageRadius()

	if SplashDamage ~= 0 and SplashDamageRadius ~= 0 then
		bullet.SplashDamage = SplashDamage
		bullet.SplashDamageRadius = SplashDamageRadius

		local SplashEffect = self:GetSplashDamageType()
		local BlastDamage = SplashEffect == "lvs_bullet_impact_explosive"

		bullet.SplashDamageEffect = SplashEffect
		bullet.SplashDamageType = BlastDamage and DMG_BLAST or DMG_SONIC

		if BlastDamage then
			self:SetShootDelay( math.max( self:GetShootDelay(), 0.5 ) )
		end
	end

	bullet.Attacker = IsValid( self.Attacker ) and self.Attacker or self

	bullet.Entity = self
	bullet.SrcEntity = vector_origin

	LVS:FireBullet( bullet )

	self:SetNextShoot( CurTime() + self:GetShootDelay() )
end

function ENT:Think()	

	self.BaseClass.Think( self )
	
	self:Shoot()

	self:NextThink( CurTime() )
	
	return true
end
--PATH lua/entities/lvs_turret_ai/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_ai_red/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_av_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Vehicle Turret"
ENT.Author = "Luna"
ENT.Information = "Hard-hitting, but very limited firing arc. Good for dealing with pesky tanks."
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antivehicleturret/Anti-VehicleTurret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 7500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 8 or AimAngles.p <= -10)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.67
	weapon.HeatRateDown = 0.2
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 450
		bullet.Velocity = 20000
		bullet.SplashDamage	= 150
		bullet.SplashDamageRadius	= 200
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleLeft = self:GetAttachment( ID_L )
		local MuzzleRight = self:GetAttachment( ID_R )

		if not MuzzleLeft or not MuzzleRight then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleLeft.Pos or MuzzleRight.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleLeft.Ang or MuzzleRight.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_vehicle_air_refil.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Refil Balloon"
ENT.Author = "Luna"
ENT.Information = "Refils Ammo on Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.RenderGroup = RENDERGROUP_BOTH 

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/balloons/hot_airballoon.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Balloon terminated.")

			return
		end

		pObj:SetMass( 1000 ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:StartMotionController()

		self:PhysWake()
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local StartPos = self:LocalToWorld( self:OBBCenter() )
		local traceUp = util.TraceLine( {
			start = StartPos,
			endpos = StartPos + Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )
		local traceDown = util.TraceLine( {
			start = StartPos,
			endpos = StartPos - Vector(0,0,50000),
			filter = self,
			mask = MASK_SOLID
		} )

		local Force = (traceUp.HitPos + traceDown.HitPos) * 0.5 - StartPos

		local ForceLinear, ForceAngle = phys:CalculateForceOffset( Force, phys:LocalToWorld( phys:GetMassCenter() + Vector(0,0,1) ) )

		ForceLinear = ForceLinear - phys:GetVelocity()
		ForceAngle = ForceAngle - phys:GetAngleVelocity()

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local SpriteColor = Color( 255, 150, 0, 255 )
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/refil.png" )

	function ENT:Draw()
	end

	function ENT:DrawTranslucent()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:LocalToWorld( self:OBBCenter() )

		if Small then
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 1 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				cam.End3D2D()
			end
		else
			for i = 0, 180, 180 do
				cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(0,i,90) ), 0.75 )
					surface.SetDrawColor( 255, 150, 0, 255 )

					surface.SetMaterial( FrameMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )

					surface.SetMaterial( RepairMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				cam.End3D2D()
			end
		end
	end

	function ENT:OnRemove()
		if IsValid( self._RepairMDL ) then
			self._RepairMDL:Remove()
		end
	end
end
--PATH lua/entities/lvs_walker_atrt_rotary/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_standart/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_legs.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_legs.lua:

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()

	local RearEnt = self:GetRearEntity()

	if not IsValid( RearEnt ) then return end

	if self:GetIsRagdoll() then 
		self:LegClearAll()
		RearEnt:LegClearAll()

		return
	end

	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Vel = self:GetVelocity()
	
	local Stride = 40
	local Lift = 20
	
	local FT = math.min(FrameTime(),0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.

	local Rate = FT * 20

	if Vel:Length() < 10 then -- sync with server animation when not moving
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal( self:GetPos() + Vel ).x * FT * 1.8 or 0
	end
	
	local Cycl1 = self.Move
	local Cycl2 = self.Move + 180
	local Cycl3 = self.Move + 90
	local Cycl4 = self.Move + 270
	local Cycl5 = self.Move
	local Cycl6 = self.Move + 180
	
	local IsMoving = self:GetIsMoving()
	
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld( Vector(200,70,180) )
		self.TRACEPOS2 = self:LocalToWorld( Vector(200,-70,180) )
		self.TRACEPOS3 = RearEnt:LocalToWorld( Vector(-160,-70,180) )
		self.TRACEPOS4 = RearEnt:LocalToWorld( Vector(-160,70,180) )
		self.TRACEPOS5 = RearEnt:LocalToWorld( Vector(0,-140,150) )
		self.TRACEPOS6 = RearEnt:LocalToWorld( Vector(0,140,150) )
		Cycl1 = 0
		Cycl2 = 0
		Cycl3 = 0
		Cycl4 = 0
		Cycl5 = 0
		Cycl6 = 0
		IsMoving = true
	end

	local MoveRoll = math.cos( math.rad(self:GetMove()) ) * 2

	-- FRONT LEFT
	local X = 20 + math.cos( math.rad(Cycl1) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl1) ), 0) * Lift
	local STARTPOS = self:LocalToWorld( Vector(179.38,49.49,135.76) )
	self.TRACEPOS1 = self.TRACEPOS1 and self.TRACEPOS1 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS1 = self.TRACEPOS1 + (STARTPOS + Forward * X - self.TRACEPOS1) * Rate
		self.FSOG1 = false
	else
		self.FSOG1 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (45+Z)
	if self.FSOG1 ~= self.oldFSOG1 then
		self.oldFSOG1 = self.FSOG1
		if self.FSOG1 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,-90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,-90,0), Pos = Vector(3,4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,0,MoveRoll), Pos = Vector(0,-4,0)}
	}
	self:GetLegEnts( 1, 60, 65, self:LocalToWorldAngles( Angle(90,-10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- FRONT RIGHT
	local STARTPOS = self:LocalToWorld( Vector(179.38,-49.49,135.76) )
	local X = 20 + math.cos( math.rad(Cycl2) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl2) ), 0) * Lift
	self.TRACEPOS2 = self.TRACEPOS2 and self.TRACEPOS2 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS2 = self.TRACEPOS2 + (STARTPOS + Forward * X - self.TRACEPOS2) * Rate
		self.FSOG2 = false
	else
		self.FSOG2 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG2 ~= self.oldFSOG2 then
		self.oldFSOG2 = self.FSOG2
		if self.FSOG2 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,90,0), Pos = Vector(-3,-4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,180,-MoveRoll), Pos = Vector(0,4,0)}
	}
	
	self:GetLegEnts( 2, 60, 65, self:LocalToWorldAngles( Angle(90,10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	local Forward = RearEnt:GetForward()
	local Up = RearEnt:GetUp()

	-- REAR RIGHT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-144.56,-68.16,126.39) )
	local X = -20 + math.cos( math.rad(Cycl5) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl5) ), 0) * Lift
	self.TRACEPOS3 = self.TRACEPOS3 and self.TRACEPOS3 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS3 = self.TRACEPOS3 + (STARTPOS + Forward * X - self.TRACEPOS3) * Rate
		self.FSOG3 = false
	else
		self.FSOG3 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS3 - Up * 50, endpos = self.TRACEPOS3 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG3 ~= self.oldFSOG3 then
		self.oldFSOG3 = self.FSOG3
		if self.FSOG3 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,-90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,-90,0), Pos = Vector(3,4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,180,0), Pos = Vector(0,4,0)}
	}
	
	RearEnt:GetLegEnts( 3, 60, 65, RearEnt:LocalToWorldAngles( Angle(90,180,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- REAR LEFT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-144.56,68.16,126.39) )
	local X = -20 + math.cos( math.rad(Cycl6) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl6) ), 0) * Lift
	self.TRACEPOS4 = self.TRACEPOS4 and self.TRACEPOS4 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS4 = self.TRACEPOS4 + (STARTPOS + Forward * X - self.TRACEPOS4) * Rate
		self.FSOG4 = false
	else
		self.FSOG4 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS4 - Up * 50, endpos = self.TRACEPOS4 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	if self.FSOG4 ~= self.oldFSOG4 then
		self.oldFSOG4 = self.FSOG4
		if self.FSOG4 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4).."_light.ogg" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/hydraulic"..math.random(1,7)..".ogg" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/blu/atte_smallleg_part3.mdl", Ang = Angle(-90,90,0), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/atte_smallleg_part2.mdl", Ang = Angle(-90,90,0), Pos = Vector(-3,-4,0)},
		Foot = {MDL = "models/blu/atte_smallleg_part1.mdl", Ang = Angle(0,0,0), Pos = Vector(0,-4,0)}
	}
	
	RearEnt:GetLegEnts( 4, 60, 65, RearEnt:LocalToWorldAngles( Angle(90,180,0) ), STARTPOS, ENDPOS, ATTACHMENTS )


	local Right = RearEnt:GetRight()

	-- MID RIGHT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-11.37,-45,139.61) )
	local X = 30 + math.cos( math.rad(Cycl3) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl3) ), 0) * Lift
	self.TRACEPOS5 = self.TRACEPOS5 and self.TRACEPOS5 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS5 = self.TRACEPOS5 + (STARTPOS + Forward * X + Right * 90 - self.TRACEPOS5) * Rate
		self.FSOG5 = false
	else
		self.FSOG5 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS5 - Up * 50, endpos = self.TRACEPOS5 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (60+Z)
	if self.FSOG5 ~= self.oldFSOG5 then
		self.oldFSOG5 = self.FSOG5
		if self.FSOG5 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,65) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/lift"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
		end
	end
	
	local ATTACHMENTS = {
		Leg2 = {MDL = "models/blu/atte_bigleg.mdl", Ang = Angle(-90,180,0), Pos = Vector(0,0,0)},
		Foot = {MDL = "models/blu/atte_bigfoot.mdl", Ang = Angle(0,180,0), Pos = Vector(-16,3,0)}
	}
	
	RearEnt:GetLegEnts( 5, 60, 94, RearEnt:LocalToWorldAngles( Angle(135,100,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	
	-- MID LEFT
	local STARTPOS = RearEnt:LocalToWorld( Vector(-11.37,45,139.61) )
	local X = 30 + math.cos( math.rad(Cycl4) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl4) ), 0) * Lift
	self.TRACEPOS6 = self.TRACEPOS6 and self.TRACEPOS6 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS6 = self.TRACEPOS6 + (STARTPOS + Forward * X - Right * 90 - self.TRACEPOS6) * Rate
		self.FSOG6 = false
	else
		self.FSOG6 = true
	end
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS6 - Up * 50, endpos = self.TRACEPOS6 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end } ).HitPos + Up * (60+Z)
	if self.FSOG6 ~= self.oldFSOG6 then
		self.oldFSOG6 = self.FSOG6
		if self.FSOG6 then
			sound.Play( Sound( "lvs/vehicles/atte/stomp"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,65) )
			util.Effect( "lvs_walker_stomp", effectdata )
		else
			sound.Play( Sound( "lvs/vehicles/atte/lift"..math.random(1,4)..".ogg" ), ENDPOS, SNDLVL_100dB )
		end
	end
	
	local ATTACHMENTS = {
		Leg2 = {MDL = "models/blu/atte_bigleg.mdl", Ang = Angle(-90,180,0), Pos = Vector(0,0,0)},
		Foot = {MDL = "models/blu/atte_bigfoot.mdl", Ang = Angle(0,0,0), Pos = Vector(16,-3,0)}
	}
	
	RearEnt:GetLegEnts( 6, 60, 94, RearEnt:LocalToWorldAngles( Angle(135,-100,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
end
--PATH lua/entities/lvs_walker_atte/sh_gunner.lua:

function ENT:GetGunnerAimAng( ent, base, RearEnt )
	local trace = ent:GetEyeTrace()

	local Pos = RearEnt:LocalToWorld( Vector(-208,0,170) )
	local wAng = (trace.HitPos - Pos):GetNormalized():Angle()

	local _, Ang = WorldToLocal( Pos, wAng, Pos, RearEnt:LocalToWorldAngles( Angle(0,180,0) ) )

	return Ang, trace.HitPos, (Ang.p < 30 and Ang.p > -10 and math.abs( Ang.y ) < 60)
end

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:InitGunner()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then base:SetHeat( 0 ) return true end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end

		local _, AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		if not InRange then return true end
	
		local ID1 = RearEnt:LookupAttachment( "muzzle_right" )
		local ID2 = RearEnt:LookupAttachment( "muzzle_left" )

		local Muzzle1 = RearEnt:GetAttachment( ID1 )
		local Muzzle2 = RearEnt:GetAttachment( ID2 )

		if not Muzzle1 or not Muzzle2 then return end

		local FirePos = { 
			[1] = Muzzle1,
			[2] = Muzzle2
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 1
	
		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 15000
		bullet.HullSize 	= 30
		bullet.Damage	= 100
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 8000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base.SNDRear:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local Ang, HitPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		RearEnt:SetPoseParameter("gun_pitch", math.Clamp(Ang.p,-10,30) )
		RearEnt:SetPoseParameter("gun_yaw", Ang.y )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local _,AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		local Pos2D = AimPos:ToScreen()

		local Col = InRange and white or red

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end

	self:AddWeapon( weapon, 3 )
end
--PATH lua/entities/lvs_walker_atte_hoverscript/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte_hoverscript/shared.lua:

ENT.Base = "lvs_base"

ENT.PrintName = "[LVS] Generic Hover"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 140
ENT.HoverTraceLength = 200
ENT.HoverHullRadius = 20

ENT.HoverCollisionFilter = {
	[COLLISION_GROUP_DEBRIS] = true,
	[COLLISION_GROUP_DEBRIS_TRIGGER] = true,
	[COLLISION_GROUP_PLAYER] = true,
	[COLLISION_GROUP_WEAPON] = true,
	[COLLISION_GROUP_VEHICLE_CLIP] = true,
	[COLLISION_GROUP_WORLD] = true,
}

ENT.DisableBallistics = true

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:GetCrosshairFilterLookup()
	if self._EntityLookUp then return self._EntityLookUp end

	self._EntityLookUp = {}

	for _, ent in pairs( self:GetCrosshairFilterEnts() ) do
		self._EntityLookUp[ ent:EntIndex() ] = true
	end

	return self._EntityLookUp
end

function ENT:GetVehicleType()
	return "walker"
end
--PATH lua/entities/lvs_walker_hsd/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("cl_prediction.lua")
include("sh_weapons.lua")

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:ProjectorBeam()
	self:DamageFX()
end

function ENT:ProjectorBeam()
	local ProjectorBeam = self:GetProjectorBeam()

	if ProjectorBeam == self.OldProjectorBeam then return end

	self.OldProjectorBeam = ProjectorBeam

	if not ProjectorBeam then return end

	local effectdata = EffectData()
	effectdata:SetEntity( self )
	util.Effect( "lvs_hsd_dish_projector", effectdata )
end
	
function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,250) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,260) + VectorRand() * 80 ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

ENT.GlowPos1 = Vector(46,-2.89,294.88)
ENT.GlowPos2 = Vector(41.15,5.82,295.63)
ENT.GlowColor = Color( 255, 0, 0, 255)
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()

	if self:GetIsRagdoll() then return false end

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( self:LocalToWorld( self.GlowPos1 ), 32, 32, self.GlowColor )
	render.DrawSprite( self:LocalToWorld( self.GlowPos2 ), 16, 16, self.GlowColor )

	return false
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSHudPaint( X, Y, ply )
	if ply ~= self:GetDriver() then
		return
	end

	local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end

--PATH lua/entities/mk2.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jump Pack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 9 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/jetpack/jetpack.mdl" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(1)	--drain in seconds
		self:SetFuelRecharge( 3 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 3000 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 2 , 80 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--PATH lua/entities/mk4.lua:
return gluapack()()
--PATH lua/entities/mortar/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

--PATH lua/entities/mortar/shared.lua:
return gluapack()()
--PATH lua/entities/mortar_shell/shared.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/entities/mqs_ent/shared.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/entities/mqs_ent/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Quest Item"
ENT.Author = "Mactavish"

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "CModel")
	self:NetworkVar("Entity", 0, "TPly")
	self:NetworkVar("Entity", 1, "Reroot")
	self:NetworkVar("Bool", 0, "Distractible")
	self:NetworkVar("Bool", 1, "EnablePhys")
	self:NetworkVar("Bool", 2, "ShowPointer")
	self:NetworkVar("Int", 0, "UseHold")
	self:NetworkVar("Float", 0, "PickProgress")
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_decoy/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_flash/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_impact.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_smoke/shared.lua:
-- Made by Matsilagi
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Smoke Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.BounceSound = "kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"
ENT.ExplodeSound = "kraken/explosives/smoke/start" .. math.random(1,5) .. ".wav"
ENT.WithinSmoke = {}

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel("models/arccw/kraken/sw/explosives/world/w_grenade_smoke.mdl")
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_NONE)
        self:DrawShadow(false)
        self.Delay = CurTime() + 3
        self.NextParticle = 0
        self.ParticleCount = 0
        self.First = true
        self.IsDetonated = false
    end

    --self:EmitSound("weapons/csgo/smokegrenade/smokegrenade_draw.wav", 75, 100, 1, CHAN_AUTO)
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        self.HitP = data.HitPos
        self.HitN = data.HitNormal

        if self:GetVelocity():Length() > 60 then
            self:EmitSound(self.BounceSound)
        end

        if self:GetVelocity():Length() < 5 then
            self:SetMoveType(MOVETYPE_NONE)
        end

        local tgt = data.HitEntity

        if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
            self.NextHit = CurTime() + 0.1
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_GENERIC)
            dmginfo:SetDamage(10)
            dmginfo:SetAttacker(self:GetOwner())
            dmginfo:SetInflictor(self)
            dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
            tgt:TakeDamageInfo(dmginfo)

            if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity

                timer.Simple(0, function()
                    if IsValid(self) then
                        self:SetAngles(ang)
                        self:SetPos(pos)
                        self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                    end
                end)
            end
        end

        for k, v in pairs(ents.FindInSphere(self:GetPos(), 155)) do
            if v:GetClass() == "fire_spawned1" or v:GetClass() == "fire_spawned2" and self.IsDetonated == false then
                self:Detonate(self, self:GetPos())
                self.IsDetonated = true
            end
        end
    end
end

function ENT:Think()
    if !SERVER then return end

    if !self.IsDetonated and CurTime() > self.Delay then
        self:Detonate(self, self:GetPos())
        self.IsDetonated = true
    end

    if self.IsDetonated then

        for ent, _ in pairs(self.WithinSmoke or {}) do
            if IsValid(ent) and ent:GetPos():DistToSqr(self:GetPos()) >= 155 * 155 then
                self.WithinSmoke[ent] = nil
                if ent:IsPlayer() then
                    ent:RemoveFlags(FL_NOTARGET)
                else
                    ent:SetCurrentWeaponProficiency(ent.OldProfiecency or WEAPON_PROFICIENCY_AVERAGE)
                end
            end
        end

        for k, v in pairs(ents.FindInSphere(self:GetPos(), 155)) do
            if (v:GetClass() == "fire_spawned1" or v:GetClass() == "fire_spawned2") and v:IsValid() then
                v:SetNWBool("extinguished", true)
                ParticleEffect("extinguish_fire", self:GetPos(), self:GetAngles())
            end

            if !self.WithinSmoke[v] then
                if v:IsPlayer() then
                    self.WithinSmoke[v] = true
                    v:SetNoTarget(true)
                elseif v:IsNPC() or v:IsNextBot() then
                    v:SetCurrentWeaponProficiency(WEAPON_PROFICIENCY_POOR)
                    v.OldProfiecency = v:GetCurrentWeaponProficiency()
                end
            end
        end

        self:NextThink(CurTime() + 0.5)
        return true
    end
end

function ENT:Detonate(self, pos)
    self.ParticleCreated = false
    self.ExtinguishParticleCreated = false

    if SERVER then
        if not self:IsValid() then return end
        self:SetNWBool("IsDetonated", true)
        self:EmitSound(self.ExplodeSound)
        local gas = EffectData()
        gas:SetOrigin(pos)
        gas:SetEntity(self:GetOwner()) --i dunno, just use it!
        util.Effect("csgo_nade_smokenade", gas)
    end

    if self.ParticleCreated ~= true then
        ParticleEffectAttach("explosion_child_smoke03e", PATTACH_ABSORIGIN_FOLLOW, self, 0)
        ParticleEffectAttach("explosion_child_core06b", PATTACH_POINT_FOLLOW, self, 0)
        ParticleEffectAttach("explosion_child_smoke07b", PATTACH_ABSORIGIN_FOLLOW, self, 0)
        ParticleEffectAttach("explosion_child_smoke07c", PATTACH_POINT_FOLLOW, self, 0)
        ParticleEffectAttach("explosion_child_distort01c", PATTACH_POINT_FOLLOW, self, 0)
        self.ParticleCreated = true
    end

    for k, v in pairs(ents.FindInSphere(self:GetPos(), 155)) do
        if (v:GetClass("fire_spawned1") or v:GetClass("fire_spawned2")) and v:IsValid() then
            v:SetNWBool("extinguished", true)
        end

        if v:GetNWBool("extinguished", true) and self.ParticleCreated == false then
            ParticleEffect("extinguish_fire", self:GetPos(), self:GetAngles())
            self.ExtinguishParticleCreated = true
        end
    end

    self:SetMoveType(MOVETYPE_NONE)

    if SERVER then
        SafeRemoveEntityDelayed(self, 15)
    end
end

function ENT:OnRemove()
    for ent, _ in pairs(self.WithinSmoke or {}) do
        if IsValid(ent) then
            if ent:IsPlayer() then
                ent:RemoveFlags(FL_NOTARGET)
            else
                ent:SetCurrentWeaponProficiency(ent.OldProfiecency or WEAPON_PROFICIENCY_AVERAGE)
            end
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_stun/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_thermalimploder.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= "  "
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = "SBD"
	local LangName = "npc_vj_sbdnew"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_tankg_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "VJ Tank Gunner Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make SNPCs."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.IsVJBaseSNPC_Tank = true -- Is it a VJ Base tank SNPC?
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsUpdate(physobj)
end
--PATH lua/entities/npc_vj_tridroidgun/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_tridroidgunfixnew/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_grenade.lua:
return gluapack()()
--PATH lua/entities/obj_vj_grenade_rifle.lua:
return gluapack()()
--PATH lua/entities/obj_vj_projectile_base/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_rcgg_rocket_swrc1/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Leste"
ENT.Author 			= "SOMEBODY SAY HO!"
ENT.Contact 		= "http://steamcommunity.com/profiles/76561198180831682/"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"

if (CLIENT) then
	local Name = "Leste"
	local LangName = "obj_1187_leste"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
--PATH lua/entities/obj_vj_sbdshoot.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2020 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Blaster Rod"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "Projectiles"
---------------------------------------------------------------------------------------------------------------------------------------------
if (CLIENT) then
	local Name = "Blaster Rod"
	local LangName = "obj_vj_blasterrod"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !(SERVER) then return end

ENT.Model = {"models/weapons/w_missile_launch.mdl"} -- The models it should spawn with | Picks a random one from the table
/*ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 10 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 10 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_SHOCK -- Damage type
ENT.RadiusDamageForce = 50 -- Put the force amount it should apply | false = Don't apply any force
ENT.RadiusDamageForceTowardsPhysics = 1000 -- How much force should it deal to props?*/
ENT.DoesDirectDamage = true -- Should it do a direct damage when it hits something?
ENT.DirectDamage = 60 -- How much damage should it do when it hits something
ENT.DirectDamageType = DMG_SHOCK -- Damage type
ENT.DecalTbl_DeathDecals = {"fadingscorch"}
ENT.SoundTbl_OnCollide = {""}
ENT.SoundTbl_Startup = {"sbd/wep_GEN_sbdRocket_01.wav"}
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	self:SetMaterial("models/effects/vol_light001.mdl")
	self:DrawShadow(false)
	self:SetColor(Color(255,0,0))
	
	util.SpriteTrail(self, 0, Color(255,0,0,255), false, 255, 255, 0.3, 1/(10+1)*0.5, "VJ_Base/sprites/vj_trial1.vmt") //cable/redlaser.vmt
	//util.SpriteTrail(self,6,Color(200,0,0),true,6,6,0.1,1/(6+6)*0.5,"VJ_Base/sprites/vj_trial1.vmt")
	//ParticleEffectAttach("vj_rpg1_smoke", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	
	local eyeglow2 = ents.Create("env_sprite")
	eyeglow2:SetKeyValue("model","vj_base/sprites/vj_glow1.vmt")
	eyeglow2:SetKeyValue("scale","0.04")
	eyeglow2:SetKeyValue("rendermode","5")
	eyeglow2:SetKeyValue("rendercolor","255 0 0")
	eyeglow2:SetKeyValue("spawnflags","1") -- If animated
	eyeglow2:SetPos(self:GetPos())
	eyeglow2:SetParent(self)
	//eyeglow2:Fire("SetParentAttachment","eye2",0)
	eyeglow2:Spawn()
	eyeglow2:Activate()
	self:DeleteOnRemove(eyeglow2)

	/*self.StartLight1 = ents.Create("light_dynamic")
	self.StartLight1:SetKeyValue("brightness", "1")
	self.StartLight1:SetKeyValue("distance", "200")
	self.StartLight1:SetLocalPos(self:GetPos())
	self.StartLight1:SetLocalAngles( self:GetAngles() )
	self.StartLight1:Fire("Color", "255 0 0")
	self.StartLight1:SetParent(self)
	self.StartLight1:Spawn()
	self.StartLight1:Activate()
	self.StartLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight1)*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DeathEffects(data,phys)
	local effectdata = EffectData()
	effectdata:SetOrigin(data.HitPos)
	//effectdata:SetMagnitude(500)
	util.Effect("StunstickImpact", effectdata)

	

	/*self.ExplosionLight1 = ents.Create("light_dynamic")
	self.ExplosionLight1:SetKeyValue("brightness", "1")
	self.ExplosionLight1:SetKeyValue("distance", "100")
	self.ExplosionLight1:SetLocalPos(data.HitPos)
	self.ExplosionLight1:SetLocalAngles(self:GetAngles())
	self.ExplosionLight1:Fire("Color", "255 0 0")
	self.ExplosionLight1:SetParent(self)
	self.ExplosionLight1:Spawn()
	self.ExplosionLight1:Activate()
	self.ExplosionLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.ExplosionLight1)*/
end
/*-----------------------------------------------
	*** Copyright (c) 2012-2020 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
-----------------------------------------------*/
--PATH lua/entities/obj_vj_spawner_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "base_anim"
ENT.Type 			= "anim"
ENT.PrintName 		= "VJ Spawner Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make spawners."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false

ENT.IsVJBaseSpawner = true

if CLIENT then
	function ENT:Draw() self:DrawModel() end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_panel/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_table/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_wall/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_plaque/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_plaque/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.letters = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	local letterMap = PerfectCasino.Core.Letter

	-- Letter calculations
	local startPoint = self:GetRight() * 25
	local curLength = vector_origin
	local right = self:GetRight()

	for k, v in ipairs(string.Split(string.lower(self.data.general.text), "")) do
		if not letterMap[v] then -- It's either a space or a character we don't support
			curLength = curLength + (self:GetRight() * 5)
			continue
		end

		-- Create the letter
		local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
		table.insert(self.letters, letter)
		letter:SetParent(self)
		curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
		letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
		letter:SetAngles(self:GetAngles())
		letter:SetBodygroup(1, letterMap[v].b)
	end
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.letters) do
		if not IsValid(v) then continue end

		v:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_wall_logo/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_wall_logo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Wall Logo"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_wall_logo", {
},
"models/freeman/owain_casinosign_wall.mdl")
--PATH lua/entities/pfx1_01.lua:
return gluapack()()
--PATH lua/entities/pfx1_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Molotov Fire 1"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]molotov_ground"
--PATH lua/entities/pfx1_04.lua:
return gluapack()()
--PATH lua/entities/pfx1_05.lua:
return gluapack()()
--PATH lua/entities/pfx1_06.lua:
return gluapack()()
--PATH lua/entities/pfx1_06~.lua:
return gluapack()()
--PATH lua/entities/pfx1_08__l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Red]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_red"
--PATH lua/entities/pfx1_0c.lua:
return gluapack()()
--PATH lua/entities/pfx2_02_a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood [Alien, Large]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood_alien*"



--PATH lua/entities/pfx4_00_s~.lua:
return gluapack()()
--PATH lua/entities/pfx4_01.lua:
return gluapack()()
--PATH lua/entities/pfx4_01_s~.lua:
return gluapack()()
--PATH lua/entities/pfx4_02~.lua:
return gluapack()()
--PATH lua/entities/pfx4_03.lua:
return gluapack()()
--PATH lua/entities/pfx4_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g"
--PATH lua/entities/pfx4_05~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs [Small]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1_small"
--PATH lua/entities/pfx4_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_b"
--PATH lua/entities/pfx5_00_alt_ss.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Micro Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_mmicro_b"
--PATH lua/entities/pfx7_01.lua:
return gluapack()()
--PATH lua/entities/pfx_base.lua:
--          CAT -> PPE: [Fire, Smoke, Weather, Tech, Nature, Cosmic, Other]
--          ENT -> PFX:[~]
AddCSLuaFile()
ENT.Author       = "The man who can even beat E1M1 on Nightmare on Nokia 3310 Java port and this person really thinks that nothing is easier than to beat E1M1 on Nighmare on Nokia 3310 Java port but he just hasn't tried to run Crysis on the calculator yet."
ENT.Type         = "anim"
ENT.Base         = "base_anim"
ENT.PrintName    = "Base"
ENT.Category     = "Particle Effects"
ENT.Spawnable    = false
ENT.AdminOnly    = false
ENT.pfxname      = "[*]pfx_test"
if SERVER then
    function ENT:Initialize()
        self:SetModel("models/hunter/blocks/cube025x025x025.mdl")
        self:SetNoDraw(true) 
        self:SetSkin(1)      
		self:DrawShadow(false)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        ParticleEffectAttach(self.pfxname, 1, self, 1)
    end
end
--PATH lua/entities/rep_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Republic Rocket Launcher"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/arccw/kraken/rocketprojectile.mdl"
ENT.FuseTime = 14
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
			phys:SetMass(2)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "effects/old_explosive/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "effects/old_explosive/sexp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(100, 100, 225) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_heatfs.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "HEATFS Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 32, 500)
    util.BlastDamage(self, attacker, self:GetPos(), 300, 110)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    for k, v in pairs(ents.FindInSphere(self:GetPos(), 32)) do
        if IsValid(v) and (v.LFS or v.LVS) then
            if v.LFS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 35 )
            end
            if v.LVS then
                v:StopEngine()
                v:SetShield(0)
                v:SetHP( v:GetHP()/ 35 )
            end
        end
    end

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 225, 175) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_rps.lua:
return gluapack()()
--PATH lua/entities/roy_eta2_lvs/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Eta-2 Interceptor"
ENT.Author = "Royster"
ENT.Information = "Eta-2 Actis-Class Light Interceptor"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/roystarwars/eta2.mdl"

--[[
ENT.GibModels = {

}
]]--

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.25
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1.66

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 750
ENT.MaxShield = 130

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(150.632,-13.724,-3.184),
		Vector(150.632,13.724-3.184),
	}

	self.LightPositions = {
		 Vector(74.669,59.924,-13.864),
		 Vector(74.669,-59.924,-13.864),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.3
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.LightPositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize = 15
		bullet.Damage	= 20
		bullet.SplashDamage = 60
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 80000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 200
	weapon.Delay = 0.4
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.SplashDamage = 50
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--PATH lua/entities/rw_sw_dispencer_grenade/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Rocket Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 4
--PATH lua/entities/sammyservers_textscreen/cl_init.lua:
return gluapack()()
--PATH lua/entities/sent_streamradio/cl_init.lua:
include("shared.lua")
DEFINE_BASECLASS("base_streamradio_gui")

local StreamRadioLib = StreamRadioLib

function ENT:StopTuneSound()
	if not self.NoiseSound then return end

	local stream = self.StreamObj
	if IsValid(streamj) then
		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")
	end

	self.NoiseSound:Stop( )
	self.NoiseSound = nil
end

function ENT:FadeoutTuneSound(time)
	if not self.NoiseSound then return end

	local stream = self.StreamObj
	if IsValid(streamj) then
		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")
	end

	if not self.NoiseSound:IsPlaying() then
		return
	end

	self.NoiseSound_vol = 0
	self.NoiseSound_volFadeTime = 0.5
end

function ENT:StartTuneSound(delay)
	local stream = self.StreamObj
	if not IsValid(stream) then
		return
	end

	stream:TimerRemove("tunesound")
	stream:TimerRemove("tunesoundstart")

	delay = delay or 0

	stream:TimerOnce("tunesoundstart", delay, function()
		if not IsValid(self) then return end

		if IsValid(stream) then
			stream:TimerRemove("tunesound")
			stream:TimerRemove("tunesoundstart")
		end

		if IsValid(stream:GetChannel()) then
			self:StopTuneSound()
			return
		end

		local noiseSound = self:CreateTuneSound()

		if not noiseSound then
			return
		end

		self.NoiseSound_vol = 1
		self.NoiseSound_volFadeTime = 2

		if not noiseSound:IsPlaying() then
			noiseSound:PlayEx(0, 100)
		end
	end)
end

function ENT:CreateTuneSound()
	if self.NoiseSound then
		return self.NoiseSound
	end

	if not self.Sounds_Noise then return end
	if self.Sounds_Noise == "" then return end

	self.NoiseSound = CreateSound(self, self.Sounds_Noise)
	self.NoiseSound:Stop()

	return self.NoiseSound
end

function ENT:ApplyTuneSound()
	local stream = self.StreamObj
	if not IsValid(stream) then return end

	local applyTuneSoundInternal = function()
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")

		local isStopMode = stream:IsStopMode()
		if isStopMode then
			self.streamswitchsound = true
			self:StopTuneSound()
			return
		end

		if stream:GetMuted() then
			self.streamswitchsound = nil
			self:StopTuneSound()
			return
		end

		if stream:IsKilled() then
			self.streamswitchsound = true
			self:StopTuneSound()
			return
		end

		if IsValid(stream:GetChannel()) then
			self:FadeoutTuneSound()
			return
		end

		if stream:IsLoading() then
			self:StartTuneSound(2)
			return
		end

		if stream:HasError() then
			self.streamswitchsound = true
			self:StartTuneSound(0)
			return
		end
	end

	stream:TimerOnce("tunesound", 0.5, applyTuneSoundInternal)
	applyTuneSoundInternal()
end

function ENT:Initialize()
	BaseClass.Initialize(self)

	self.streamswitchsound = true
	self.slavesradios = {}
	self.old = {}

	local stream = self.StreamObj
	if IsValid(stream) then
		stream:SetEvent("OnPlayModeChange", self, function()
			if not IsValid(self) then return end
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnSearch", self, function()
			if not IsValid(self) then return end
			if not self.streamswitchsound then return end

			self:EmitSoundIfExist(self.Sounds_Tune, 50, 100, 1, CHAN_ITEM)
			self.streamswitchsound = nil
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnConnect", self, function()
			if not IsValid(self) then return end
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnError", self, function(this, errorCode)
			if not IsValid(self) then return end

			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnMute", self, function(this, muted)
			if not IsValid(self) then return end

			if muted then
				self:StopTuneSound()
			else
				self:ApplyTuneSound()
			end
		end)
	end

	self:MarkForUpdatePlaybackLoopMode()
end

function ENT:OnModelSetup()
	self:StreamStopAnimModel()
end

function ENT:GetWallTraceParamenters()
	local wallTraceParamenters = self.WallTraceParamenters

	if not wallTraceParamenters then
		self.WallTraceParamenters = {}

		wallTraceParamenters = self.WallTraceParamenters
		wallTraceParamenters.mask = MASK_SHOT_PORTAL
		wallTraceParamenters.filter = {}
	end

	wallTraceParamenters.output = wallTraceParamenters.output or {}

	local camera = StreamRadioLib.GetCameraEnt(ent)
	local cameraVehicle = false

	if IsValid(camera) then
		cameraVehicle = camera.GetVehicle and camera:GetVehicle() or false
	else
		camera = false
	end

	local tmp = {}

	tmp[self] = self
	tmp[camera] = camera
	tmp[cameraVehicle] = cameraVehicle

	local filter = wallTraceParamenters.filter
	table.Empty(filter)

	for _, filterEnt in pairs(tmp) do
		if not IsValid(filterEnt) then continue end
		table.insert(filter, filterEnt)
	end

	for _, filterEnt in pairs(StreamRadioLib.SpawnedRadios) do
		table.insert(filter, filterEnt)
	end

	wallTraceParamenters.filter = filter
	return wallTraceParamenters
end

function ENT:TraceToCamera(frompos)
	local endpos = StreamRadioLib.GetCameraViewPos()
	local traceparams = self:GetWallTraceParamenters()

	traceparams.start = frompos
	traceparams.endpos = endpos

	util.TraceLine(traceparams)

	local result = traceparams.output

	-- Tracers Debug
	-- debugoverlay.Line(frompos, result.HitPos or endpos, 0.5, color_white, false)
	-- debugoverlay.Line(result.HitPos or endpos, endpos, 0.5, color_black, false)

	return result
end

function ENT:TraceWalls(radius)
	local startpos = self.SoundPos

	local camtrace = self:TraceToCamera(startpos)
	if not camtrace then return 1 end
	if not camtrace.Hit then return 1 end
	if not camtrace.HitPos then return 1 end

	local traceparams = self:GetWallTraceParamenters()

	traceparams.start = startpos

	local traces = StreamRadioLib.StarTrace(traceparams, radius)

	local blockcount = 0
	local wallcount = 0

	for i, trace in ipairs(traces) do
		if not trace.Hit then
			continue
		end

		if not trace.HitPos then
			continue
		end

		wallcount = wallcount + 1

		local camtrace = self:TraceToCamera(trace.HitPos)
		if not camtrace then continue end
		if not camtrace.Hit then continue end
		if not camtrace.HitPos then continue end

		blockcount = blockcount + 1
	end

	if wallcount <= 0 then
		return 1
	end

	if blockcount <= 0 then
		return 1
	end

	local f = blockcount / wallcount

	f = (1 - f) * 2

	local volfactor = math.Clamp(f, 0, 1)
	return volfactor
end

function ENT:GetWallVolumeFactor()
	if self.Muted then
		self.wallvolcache = nil
		return 0
	end

	if self:GetVolume() <= 0 then
		self.wallvolcache = nil
		return 0
	end

	local coveredvol = StreamRadioLib.GetCoveredVolume()

	if coveredvol >= 1 then
		self.wallvolcache = nil
		return 1
	end

	local streamingRadioCount = StreamRadioLib.GetStreamingRadioCount()
	if streamingRadioCount <= 0 then
		self.wallvolcache = nil
		return 1
	end

	local now = RealTime()

	self.wallvolcache = self.wallvolcache or {}
	local cache = self.wallvolcache
	local oldvalue = cache.value or 0

	if cache.nexttime and cache.nexttime > now then
		return math.max(oldvalue, coveredvol)
	end

	local startTime = SysTime()

	local value = self:TraceWalls(self.Radius) or 1

	local endTime = SysTime()
	local runtime = endTime - startTime

	local mintime = math.max(RealFrameTime() * 30, runtime * streamingRadioCount * 50, 0.1)

	if oldvalue <= 0 and value <= 0 then
		-- already quiet radios should retest less often
		mintime = math.max(mintime * 3, 0.5)
	elseif oldvalue >= 1 and value >= 1 then
		-- already clear radios should retest less often
		mintime = math.max(mintime * 3, 0.5)
	end

	mintime = math.Rand(mintime, mintime * 2)
	mintime = math.min(mintime, 3)

	cache.nexttime = now + mintime

	cache.value = value
	return math.max(value, coveredvol)
end

function ENT:GetWallVolumeFactorSmoothed()
	local now = RealTime()
	local last = self._wallvoltime or now
	self._wallvoltime = now

	local ticktime = now - last

	if ticktime <= 0 then
		return self._wallvolvalue or 0
	end

	local curwallvol = self:GetWallVolumeFactor()
	self._wallvolvalue = self._wallvolvalue or 0

	if self._wallvolvalue == curwallvol then
		return curwallvol
	end

	local speed = ticktime * 2

	self._wallvolvalue = math.Approach(self._wallvolvalue, curwallvol, speed)
	return self._wallvolvalue
end

function ENT:IsMuted()
	local ply = LocalPlayer()

	if not IsValid(ply) then return true end
	if not ply:IsPlayer() then return true end
	if ply:IsBot() then return true end

	if StreamRadioLib.IsMuted(ply, self:GetRealRadioOwner()) then
		return true
	end

	if self:GetSVMute() then
		return true
	end

	if self:GetCLMute() then
		return true
	end

	local willMute = self:IsMutedForPlayer(ply)
	local now = RealTime()

	if willMute then
		if not self._mutedTimer then
			self._mutedTimer = now + 1
		end

		if self._mutedTimer < now then
			return true
		end

		return false
	else
		self._mutedTimer = nil
	end

	return false
end

function ENT:UpdateStream()
	local streamObj = self.StreamObj

	if not IsValid(streamObj) then
		self:StreamStopAnimModel()
		return
	end

	if streamObj:IsStopMode() then
		self:StreamStopAnimModel()
		return
	end

	local ply = LocalPlayer()

	streamObj:Set3D(StreamRadioLib.Is3DSound() and self:GetSound3D())
	self.Sound3D = streamObj:Get3D()

	self.Radius = self:GetRadius() or 0
	streamObj:Set3DFadeDistance(self.Radius / 3)

	local muted = self:IsMuted()
	local clVolume = self:GetCLVolume()

	local wallVolume = 0
	local distVolume = 0
	local playerDistance = nil

	if not muted then
		playerDistance = self:DistanceToEntity(ply, nil, StreamRadioLib.GetCameraViewPos(ply))

		wallVolume = self:GetWallVolumeFactorSmoothed()
		distVolume = StreamRadioLib.CalcDistanceVolume(playerDistance, self.Radius)
	end

	self.PlayerDistance = playerDistance

	local StreamVol = distVolume * clVolume * wallVolume

	streamObj:SetMuted(muted)
	streamObj:SetClientVolume(StreamVol)

	self.Muted = muted

	if self.NoiseSound then
		local noiseSoundVol = self.NoiseSound_vol or 0

		local globalVolume = StreamRadioLib.GetGlobalVolume()
		globalVolume = math.Clamp(globalVolume, 0, 1)

		self.NoiseSound:ChangeVolume(streamObj:GetVolume() * globalVolume * clVolume * wallVolume * noiseSoundVol, 0.5)
	end

	self:StreamAnimModel()
end

function ENT:StreamAnimModel()
	local stream = self.StreamObj

	if not IsValid(stream) then
		self:StreamStopAnimModel()
		return
	end

	if not self.ModelData then
		self:StreamStopAnimModel()
		return
	end

	if self:IsDormant() then
		self:StreamStopAnimModel()
		return
	end

	if self.Muted then
		self:StreamStopAnimModel()
		return
	end

	if not self.PlayerDistance or self.PlayerDistance >= StreamRadioLib.GetSpectrumDistance() then
		self:StreamStopAnimModel()
		return
	end

	if stream:IsLoading() or stream:IsCheckingUrl() or stream:IsBuffering() then
		self:CallModelFunction("WhileLoading")
		return
	end

	if stream:HasError() then
		self:CallModelFunction("WhileError")
		return
	end

	if not stream:IsPlaying() then
		self:StreamStopAnimModel()
		return
	end

	local calcsl = self:HasModelFunction("SoundLevel")
	local calcspeaker = self:HasModelFunction("Speaker")
	local fftFunc = self:GetModelFunction("FFT")

	local modalData = self.ModelData

	if calcsl then
		self.AnimStopped = false

		self:CallModelFunction("SoundLevel", stream:GetAverageLevel())
	end

	if calcspeaker then
		self.AnimStopped = false

		local speakerlevel = 0
		local minfrq = modalData.SpeakerMinFRQ
		local maxfrq = modalData.SpeakerMaxFRQ
		local Resolution = modalData.SpeakerFRQResolution or 10

		stream:GetSpectrumComplex(Resolution, function( index, frq, level_length, level_ang, level_R, level_I )
			if not level_ang then
				local lambda = (1 / frq) / 2
				level_ang = math.random( -lambda, lambda )
			end

			local sin = math.sin( frq * math.pi * 2 + level_ang ) * level_length

			speakerlevel = speakerlevel + sin
			return true
		end, minfrq, maxfrq)

		speakerlevel = speakerlevel
		speakerlevel = math.Clamp( speakerlevel, -1, 1 )

		self:CallModelFunction("Speaker", speakerlevel)
	end

	if fftFunc then
		self.AnimStopped = false

		stream:GetSpectrumComplex( 7, function( index, frq, level_length, level_ang, level_R, level_I )
			fftFunc(modalData, index, frq, level_length)
		end)
	end
end

function ENT:FastThink()
	BaseClass.FastThink(self)

	self:MasterRadioSyncThink()
end

function ENT:InternalThink()
	BaseClass.InternalThink(self)

	self:UpdateStream()

	self:CallModelFunction("Think")
end

function ENT:InternalSlowThink()
	BaseClass.InternalSlowThink(self)

	self:PlaybackLoopModeThink()
	self:PanelThink()

	return true
end

function ENT:OnMasterradioChange(masterradio, oldmasterradio)
	local eventname = tostring(self) .. "_master_sync"
	local timername = eventname .. "_errorretry"

	local this_st = self.StreamObj

	this_st:RemoveEvent("OnError", eventname)
	this_st:RemoveEvent("OnConnect", eventname)
	this_st:TimerRemove(timername)

	if IsValid(oldmasterradio) then
		if IsValid(oldmasterradio.StreamObj) then
			oldmasterradio.StreamObj:RemoveEvent("OnConnect", eventname)
		end
	end

	if IsValid(masterradio) then
		local master_st = masterradio.StreamObj

		master_st:RemoveEvent("OnConnect", eventname)
		master_st:SetEvent("OnConnect", eventname, function()
			if not IsValid(self) then
				master_st:RemoveEvent("OnConnect", eventname)
				return
			end

			if not IsValid(masterradio) then
				master_st:RemoveEvent("OnConnect", eventname)
				return
			end

			if this_st:IsRunning() and this_st:GetError() == 0 then
				return
			end

			this_st:TimerRemove(timername)
			this_st:Reconnect()
		end)

		this_st:SetEvent("OnError", eventname, function()
			this_st:TimerRemove(timername)

			if not IsValid(self) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			if not IsValid(masterradio) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			if not IsValid(master_st) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			this_st:TimerOnce(eventname .. "_errorretry", 10, function()
				if not IsValid(self) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if not IsValid(masterradio) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if not IsValid(master_st) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if this_st:IsRunning() and this_st:GetError() == 0 then
					return
				end

				this_st:Reconnect()
			end)
		end)
	end
end

function ENT:DrawTranslucent(...)
	BaseClass.DrawTranslucent(self, ...)
	self:CallModelFunction("Draw", ...)
end

function ENT:PostFakeRemove()
	self:ApplyTuneSound()
end

function ENT:OnRemove()
	self:OnRemoveShared()

	BaseClass.OnRemove(self)

	self:StopTuneSound()
end

--PATH lua/entities/shield_deployer.lua:
return gluapack()()
--PATH lua/entities/soulless.lua:

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Soulless One"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: CIS"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/soulless/soulless1.mdl"
ENT.Vehicle = "Soulless"
ENT.StartHealth = 1500;
ENT.Allegiance = "CIS";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("soulless");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetUp()*60+self:GetForward()*100+self:GetRight()*-80,
		Right = self:GetPos()+self:GetUp()*60+self:GetForward()*100+self:GetRight()*80,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2250;
	self.ForwardSpeed = 1200;
	self.UpSpeed = 550;
	self.AccelSpeed = 7;
	self.CanStandby = true;
	self.CanBack = false;
	self.CanRoll = true;
	self.Cooldown = 2;

	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(50,"red");
	self.FireDelay = 0;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right",};

	//self.ExitModifier = {x=0,y=225,z=100};
	
	self.BaseClass.Initialize(self);
end


end

if CLIENT then
	
	ENT.CanFPV = false;
	ENT.Sounds={
		Engine=Sound("ambient/atmosphere/ambience_base.wav"),
	}
	
	function ENT:Initialize()
		self.Emitter = ParticleEmitter(self:GetPos());
		self.BaseClass.Initialize(self);
	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 300;
	
	function ENT:Effects()
	
		self.ThrusterLocations = {
			self:GetPos()+self:GetUp()*35+self:GetForward()*-60+self:GetRight()*-115,
			self:GetPos()+self:GetUp()*35+self:GetForward()*-60+self:GetRight()*115,
		}
		local p = LocalPlayer();
		local roll = math.Rand(-45,45);
		local normal = (self.Entity:GetForward() * -1):GetNormalized();
		local id = self:EntIndex();
		for k,v in pairs(self.ThrusterLocations) do

			local heatwv = self.Emitter:Add("sprites/heatwave",v);
			heatwv:SetVelocity(normal*2);
			heatwv:SetDieTime(0.1);
			heatwv:SetStartAlpha(255);
			heatwv:SetEndAlpha(255);
			heatwv:SetStartSize(20);
			heatwv:SetEndSize(15);
			heatwv:SetColor(255,255,255);
			heatwv:SetRoll(roll);
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.05)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(20)
			blue:SetEndSize(15)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;

		end
	end
	
	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			if(!TakeOff and !Land) then
				self:Effects();
			end
		end
		
	end
	
	function SoullessReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingSoulless");
		local self = p:GetNWEntity("Soulless");
		if(Flying and IsValid(self)) then
			
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);

			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "SoullessReticle", SoullessReticle)

end
--PATH gamemodes/starwarsrp/entities/entities/spawned_money/cl_init.lua:
include("shared.lua")

local color_red = Color(140, 0, 0, 100)
local color_white = color_white

function ENT:Draw()
    self:DrawModel()

    -- Do not draw labels when a different model is used.
    -- If you want a different model with labels, make your own money entity and use GM.Config.MoneyClass.
    if self:GetModel() ~= "models/props/cs_assault/money.mdl" then return end

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    surface.SetFont("ChatFont")
    local text = DarkRP.formatMoney(self:Getamount())
    local TextWidth = surface.GetTextSize(text)

    cam.Start3D2D(Pos + Ang:Up() * 0.82, Ang, 0.1)
        draw.WordBox(2, -TextWidth * 0.5, -10, text, "ChatFont", color_red, color_white)
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Right(), 180)

    cam.Start3D2D(Pos, Ang, 0.1)
        draw.WordBox(2, -TextWidth * 0.5, -10, text, "ChatFont", color_red, color_white)
    cam.End3D2D()
end

function ENT:Think()
end

--PATH addons/[miecze] moce i hilty/lua/entities/star_metor/shared.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_impact.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_poison.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/dioxisgrenade.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
    for k, v in pairs( ents.FindInSphere( self:GetPos(), 216 ) ) do
            if v:IsPlayer() or v:IsNPC() then
                damage = DamageInfo()
                damage:SetDamage( math.random( 3, 7 ) )
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamageType( DMG_NERVEGAS )
                v:TakeDamageInfo( damage )
                v:ViewPunch( Angle( math.random( -3, 3 ), math.random( -3, 3 ), math.random( -3, 3 ) ) )
            end
        end
    end
    self:NextThink( CurTime() + 0.25 )
    return true
end
		
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner) //i dunno, just use it!
		util.Effect("tfa_csgo_poisonade", gas)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,30)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_thermal.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_base/cl_init.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_timed.lua:
return gluapack()()
--PATH lua/entities/tfa_thrown_blade/cl_init.lua:
return gluapack()()
--PATH lua/entities/tfa_thrown_blade/shared.lua:
return gluapack()()
--PATH lua/entities/tfa_thrown_blade/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Thrown Blade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true

ENT.HitSounds = {
	[MAT_DIRT] = {Sound("physics/metal/metal_grenade_impact_hard1.wav"), Sound("physics/metal/metal_grenade_impact_hard2.wav"), Sound("physics/metal/metal_grenade_impact_hard3.wav")},
	[MAT_FLESH] = {Sound("physics/flesh/flesh_impact_bullet1.wav"), Sound("physics/flesh/flesh_impact_bullet2.wav"), Sound("physics/flesh/flesh_impact_bullet3.wav")}
}

ENT.ImpactSound = Sound("weapons/blades/impact.mp3")
--PATH lua/entities/torpedo_blast.lua:
return gluapack()()
--PATH lua/entities/trace2/cl_init.lua:
return gluapack()()
--PATH lua/entities/turbolaser2/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Turbolaser"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.Force		= 21000
ENT.Damage		= 150
ENT.Magnitude		= 200

ENT.Phys		= nil
ENT.Once		= false

function ENT:SetupDataTables()

self:NetworkVar( "String", "3", "Colour" );

end

--PATH lua/entities/unitys-lvs-tx-2112/shared.lua:
return gluapack()()
--PATH lua/entities/vulture.lua:


ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Vulture"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: CIS"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/vulture/vulture1.mdl"
ENT.Vehicle = "Vulture"
ENT.StartHealth = 500;
ENT.Allegiance = "CIS";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};

AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("vulture");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {	
		BottomLeft = self:GetPos()+self:GetRight()*-110+self:GetUp()*24+self:GetForward()*42,
		BottomRight = self:GetPos()+self:GetRight()*110+self:GetUp()*24+self:GetForward()*42,
		TopLeft = self:GetPos()+self:GetRight()*-110+self:GetUp()*35+self:GetForward()*42,
		TopRight = self:GetPos()+self:GetRight()*110+self:GetUp()*35+self:GetForward()*42,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1400;
	self.UpSpeed = 500;
	self.AccelSpeed = 8;
	self.CanRoll = true;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(30,"red");
	self.CanStandby = true;
	
	self.BaseClass.Initialize(self);
end


end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/droid/droid_fly.wav"),
	}
	ENT.CanFPV = false;
	
	local Health = 0;
	local Overheat = 0;
	local Overheated = false;
	function ENT:Think()
		
		self.BaseClass.Think(self);
		
		local p = LocalPlayer();
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity;
		if(IsFlying and IsDriver) then
			Health = self:GetNWInt("Health");
			Overheat = self:GetNWInt("Overheat");
			Overheated = self:GetNWBool("Overheated");
		end
	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;

	function VultureReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingVulture");
		local self = p:GetNWEntity("Vulture");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
	
			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "VultureReticle", VultureReticle)

end
--PATH lua/effects/aq_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 12000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"aquamarine_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 0
		mLight.g = 40
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/arc9_aftershoteffect.lua:
return gluapack()()
--PATH lua/effects/arc9_opencrate.lua:
local materials = {
    [0] = "effects/peanut",
    [1] = "effects/fas_debris_add_a"
}

function EFFECT:Init(data)
    local vOffset = data:GetOrigin()
    local vMat = data:GetMaterialIndex() or 0
    local NumParticles = 200
    local emitter = ParticleEmitter(vOffset, true)

    for i = 0, NumParticles do
        -- local Pos = Vector(math.Rand(-1.5, 1.5), math.Rand(-1.5, 1.5), math.Rand(-.5, .5))
        local Pos = Vector(math.sin(math.rad(i * 1.5)) * math.Rand(-1.5, 1.5), math.cos(math.rad(i * 1.5)) * math.Rand(-1.5, 1.5), math.Rand(0, .5)) -- :trollscream:
        local particle = emitter:Add(materials[data:GetMaterialIndex()], vOffset + Pos * 10)

        if particle then
            if data:GetMaterialIndex() == 0 then
                particle:SetVelocity(Pos * 80)
                particle:SetLifeTime(0)
                particle:SetDieTime(0.5 + vMat)
                particle:SetStartAlpha(255)
                particle:SetEndAlpha(vMat * 200)
                local Size = math.Rand(2, 3) * (vMat + 1)
                particle:SetStartSize(Size)
                particle:SetEndSize(0)
                particle:SetRoll(math.Rand(0, 360))
                -- particle:SetRoll(145)
                particle:SetRollDelta(math.Rand(-2, 2))
                particle:SetAirResistance(50)
                particle:SetGravity(Vector(0, 0, -300))
                particle:SetColor(180, 180, 180)
                particle:SetCollide(true)
                particle:SetAngleVelocity(Angle(math.Rand(-160, 160), math.Rand(-160, 160), math.Rand(-160, 160)))
                particle:SetBounce(0.3 + vMat)
                particle:SetLighting(false)
            else
                particle:SetVelocity(Pos * 200 + Vector(0, 0, math.Rand(-100, 100)))
                particle:SetLifeTime(0)
                particle:SetDieTime(2)
                particle:SetStartAlpha(255)
                particle:SetEndAlpha(vMat * 200)
                local Size = math.Rand(1, 4)
                particle:SetStartSize(Size)
                particle:SetEndSize(0)
                particle:SetRoll(math.Rand(0, 360))
                -- particle:SetRoll(145)
                particle:SetRollDelta(math.Rand(-2, 2))
                particle:SetAirResistance(50)
                particle:SetGravity(Vector(0, 0, -600))
                particle:SetColor(180, 180, 180)
                particle:SetCollide(true)
                particle:SetAngleVelocity(Angle(math.Rand(-160, 160), math.Rand(-160, 160), math.Rand(-160, 160)))
                particle:SetBounce(math.Rand(0.3, 1.1))
                particle:SetLighting(true)
            end
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return
end

function EFFECT:Render()
end

--PATH lua/effects/arc9_shelleffect.lua:
EFFECT.Type = 1

EFFECT.Pitch = 100

EFFECT.Model = "models/shells/shell_57.mdl"

EFFECT.AlreadyPlayedSound = false
EFFECT.ShellTime = 0.5
EFFECT.SpawnTime = 0

EFFECT.VMContext = true

EFFECT.PCFs = {}

local arc9_eject_time = GetConVar("arc9_eject_time")
local arc9_eject_fx = GetConVar("arc9_eject_fx")

function EFFECT:Init(data)

    local att = data:GetAttachment()
    local ent = data:GetEntity()

    if !IsValid(ent) then self:Remove() return end
    if !IsValid(ent:GetOwner()) then self:Remove() return end

    if ent:GetOwner() != LocalPlayer() or LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = (ent.WModel or {})[1] or ent
        self.VMContext = false
    else
        mdl = LocalPlayer():GetViewModel()

        if ent:ShouldTPIK() then
            self.VMContext = false
        else
            table.insert(ent.ActiveEffects, self)
        end
    end

    if !IsValid(ent) then self:Remove() return end
    if !mdl or !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    if (LocalPlayer():ShouldDrawLocalPlayer() or ent.Owner != LocalPlayer()) then
        wm = true
    end

    -- ang:RotateAroundAxis(ang:Up(), -90)

    -- ang:RotateAroundAxis(ang:Right(), (ent.ShellRotateAngle or Angle(0, 0, 0))[1])
    -- ang:RotateAroundAxis(ang:Up(), (ent.ShellRotateAngle or Angle(0, 0, 0))[2])
    -- ang:RotateAroundAxis(ang:Forward(), (ent.ShellRotateAngle or Angle(0, 0, 0))[3])

    local model = ent:GetProcessedValue("ShellModel", true)
    local material = ent:GetProcessedValue("ShellMaterial", true)
    local scale = ent:GetProcessedValue("ShellScale", true)
    local physbox = ent:GetProcessedValue("ShellPhysBox", true)
    local pitch = ent:GetProcessedValue("ShellPitch", true)
    local sounds = ent:GetProcessedValue("ShellSounds", true)
    local soundsvolume = ent:GetProcessedValue("ShellVolume", true)
    local smoke = ent:GetProcessedValue("ShellSmoke", true)
    local velocity = ent:GetProcessedValue("ShellVelocity", true) or math.Rand(1, 2)

    local index = data:GetFlags()

    if index != 0 then
        local shelldata = ent:GetProcessedValue("ExtraShellModels", true)[index]

        if shelldata then
            model = shelldata.model or model
            material = shelldata.material or material
            scale = shelldata.scale or scale
            physbox = shelldata.physbox or physbox
            pitch = shelldata.pitch or pitch
            sounds = shelldata.sounds or sounds
            soundsvolume = shelldata.soundsvolume or soundsvolume
            if shelldata.smoke != nil then
                smoke = shelldata.smoke
            end
            velocity = shelldata.velocity or velocity
            if istable(velocity) then velocity = math.Rand(velocity[1], velocity[2]) end
        end
    end

    self.ShellTime = self.ShellTime + arc9_eject_time:GetFloat()

    local dir = ang:Forward()

    local correctang = ent:GetProcessedValue("ShellCorrectAng", true) or angle_zero
    ang:RotateAroundAxis(ang:Forward(), 90 + correctang.p)
    ang:RotateAroundAxis(ang:Right(), correctang.y)
    ang:RotateAroundAxis(ang:Up(), correctang.r)

    self:SetPos(origin)
    self:SetModel(model or "")
    self:SetMaterial(material or "")
    self:DrawShadow(true)
    self:SetAngles(ang)
    self:SetModelScale(scale or 1)

    if self.VMContext then
        self:SetNoDraw(true)
    end

    self.ShellPitch = pitch

    -- if !LocalPlayer():ShouldDrawLocalPlayer() and ent:GetOwner() == LocalPlayer() then
    --     self:SetNoDraw(true)
    -- end

    -- table.insert(ent.EjectedShells, self)

    self.Sounds = sounds or ARC9.ShellSoundsTable

	self.SoundsVolume = soundsvolume or 1

    local pb_z = physbox.z
    local pb_y = physbox.y
    local pb_x = physbox.x

    local mag = 150

    self:PhysicsInitBox(Vector(-pb_z,-pb_y,-pb_x), Vector(pb_z,pb_x,pb_y))

    self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

    local phys = self:GetPhysicsObject()

    local plyvel = vector_origin

    if IsValid(ent.Owner) then
        plyvel = ent.Owner:GetAbsVelocity()
    end

    phys:Wake()
    phys:SetDamping(0, 0)
    phys:SetMass(1)
    phys:SetMaterial("gmod_silent")
    -- phys:SetMaterial("default_silent")

    phys:SetVelocity((dir * mag * velocity) + plyvel)

    phys:AddAngleVelocity(VectorRand() * 100)
    phys:AddAngleVelocity(ang:Up() * 2500 * velocity / 0.75)

    if !arc9_eject_fx:GetBool() then
        smoke = false
    end

    if smoke then
        local pcf = CreateParticleSystem(mdl, "port_smoke", PATTACH_POINT_FOLLOW, att)

        if IsValid(pcf) then
            pcf:StartEmission()
        end

        local smkpcf = CreateParticleSystem(self, "shellsmoke", PATTACH_ABSORIGIN_FOLLOW, 0)

        if IsValid(smkpcf) then
            smkpcf:StartEmission()
        end

        if self.VMContext then
            table.insert(ent.PCFs, pcf)
            table.insert(ent.PCFs, smkpcf)

            pcf:SetShouldDraw(false)
            smkpcf:SetShouldDraw(false)
        end
    end

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide(colData)
    if self.AlreadyPlayedSound then return end
    local phys = self:GetPhysicsObject()
    phys:SetVelocityInstantaneous(colData.HitNormal * -150)
    self:StopSound("Default.ImpactHard")

    self.VMContext = false
    self:SetNoDraw(false)

    sound.Play(self.Sounds[math.random(#self.Sounds)], self:GetPos(), 75, self.ShellPitch, self.SoundsVolume, CHAN_WEAPON)

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if self:GetVelocity():Length() > 20 then self.SpawnTime = CurTime() end
    self:StopSound("Default.ScrapeRough")

    if (self.SpawnTime + self.ShellTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.ShellTime + 0.25) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.ShellTime + 0.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end

    self:DrawModel()
end

function EFFECT:DrawTranslucent()
    if !IsValid(self) then return end

    self:DrawModel()
end
--PATH lua/effects/arccw_shelleffect.lua:

EFFECT.Sounds = {}
EFFECT.Pitch = 90
EFFECT.Scale = 1.5
EFFECT.PhysScale = 1
EFFECT.Model = "models/shells/shell_57.mdl"
EFFECT.Material = nil
EFFECT.JustOnce = true
EFFECT.AlreadyPlayedSound = false
EFFECT.ShellTime = 1

EFFECT.SpawnTime = 0

function EFFECT:Init(data)

    local att = data:GetAttachment()
    local ent = data:GetEntity()
    local mag = data:GetMagnitude()

    local mdl = LocalPlayer():GetViewModel()

    if LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if !IsValid(ent) then self:Remove() return end

    local owner = ent:GetOwner()
    if owner != LocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if owner != LocalPlayer() and !ArcCW.ConVars["shelleffects"]:GetBool() then self:Remove() return end
    if !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    ang:RotateAroundAxis(ang:Right(), -90 + ent.ShellRotate)

    ang:RotateAroundAxis(ang:Right(), (ent.ShellRotateAngle or Angle(0, 0, 0))[1])
    ang:RotateAroundAxis(ang:Up(), (ent.ShellRotateAngle or Angle(0, 0, 0))[2])
    ang:RotateAroundAxis(ang:Forward(), (ent.ShellRotateAngle or Angle(0, 0, 0))[3])

    local dir = ang:Up()

    local st = ArcCW.ConVars["shelltime"]:GetFloat()

    if ent then
        self.Model = ent:GetBuff_Override("Override_ShellModel") or ent.ShellModel
        self.Material = ent:GetBuff_Override("Override_ShellMaterial") or ent.ShellMaterial
        self.Scale = ent:GetBuff("ShellScale") or 1--ent:GetBuff_Override("Override_ShellScale") or ent.ShellScale or 1
        self.PhysScale = ent:GetBuff_Override("Override_ShellPhysScale") or ent.ShellPhysScale or 1
        self.Pitch = ent:GetBuff_Override("Override_ShellPitch") or ent.ShellPitch or 100
        self.Sounds = ent:GetBuff_Override("Override_ShellSounds") or ent.ShellSounds
        self.ShellTime = (ent.ShellTime or 0) + st

        if self.Sounds == "autocheck" and ent:GetPrimaryAmmoType() then
            local t = ent:GetPrimaryAmmoType()
            if t == game.GetAmmoID("buckshot") then
                self.Sounds = ArcCW.ShotgunShellSoundsTable
            elseif ent.Trivia_Calibre and string.find(ent.Trivia_Calibre, ".22") then
                self.Sounds = ArcCW.TinyShellSoundsTable
            elseif t == game.GetAmmoID("pistol") or t == game.GetAmmoID("357") or t == game.GetAmmoID("AlyxGun") then
                self.Sounds = ArcCW.PistolShellSoundsTable
            elseif t == game.GetAmmoID("ar2") then
                self.Sounds = ArcCW.MediumShellSoundsTable
            else
                self.Sounds = ArcCW.ShellSoundsTable
            end
        end
    end

    self:SetPos(origin)
    self:SetModel(self.Model)
    self:SetModelScale(self.Scale)
    self:DrawShadow(true)
    self:SetAngles(ang)

    if self.Material then
        self:SetMaterial(self.Material)
    end

    local pb_vert = 2 * self.Scale * self.PhysScale
    local pb_hor = 0.5 * self.Scale * self.PhysScale

    self:PhysicsInitBox(Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor))

    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)

    local phys = self:GetPhysicsObject()

    local plyvel = Vector(0, 0, 0)

    if IsValid(owner) then
        plyvel = owner:GetAbsVelocity()
    end


    phys:Wake()
    phys:SetDamping(0, 0)
    phys:SetMass(1)
    phys:SetMaterial("gmod_silent")

    phys:SetVelocity((dir * mag * math.Rand(1, 2)) + plyvel)

    phys:AddAngleVelocity(VectorRand() * 100)
    phys:AddAngleVelocity(ang:Up() * 2500 * math.Rand(0.75, 1.25))

    self.HitPitch = self.Pitch + math.Rand(-5,5)

    local emitter = ParticleEmitter(origin)

    for i = 1, 3 do
        local particle = emitter:Add("particles/smokey", origin + (dir * 2))

        if (particle) then
            particle:SetVelocity(VectorRand() * 10 + (dir * i * math.Rand(48, 64)) + plyvel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.05, 0.15))
            particle:SetStartAlpha(math.Rand(40, 60))
            particle:SetEndAlpha(0)
            particle:SetStartSize(0)
            particle:SetEndSize(math.Rand(18, 24))
            particle:SetRoll(math.rad(math.Rand(0, 360)))
            particle:SetRollDelta(math.Rand(-1, 1))
            particle:SetLighting(true)
            particle:SetAirResistance(96)
            particle:SetGravity(Vector(-7, 3, 20))
            particle:SetColor(150, 150, 150)
        end
    end

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide()
    if self.AlreadyPlayedSound and self.JustOnce then return end

    sound.Play(self.Sounds[math.random(#self.Sounds)], self:GetPos(), 65, self.HitPitch, 1)

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if (self.SpawnTime + self.ShellTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.ShellTime + 1) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.ShellTime + 1.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end
    self:DrawModel()
end
--PATH lua/effects/blue_tracer_fx.lua:
return gluapack()()
--PATH lua/effects/cod2019_muzzle_db/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_muzzle_inc/init.lua:
function EFFECT:Init(data, weapon, dmgInfo, tr)
    local pos = data:GetOrigin()
    local ang = data:GetAngles()
    ParticleEffect("muzzleflash_pistol", pos, ang, nil)
    --sound.Play("COD2019.DB_Hit", data:GetOrigin(), SNDLVL_75dB, 100, 0.1)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/cod2019_nade_flash_light/init.lua:
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	local dlight = DynamicLight(pos)

	if (dlight) then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 255
		dlight.b = 255
		dlight.brightness = 2
		dlight.Size = 400
		dlight.Decay = 768
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/cod2019_tracer_slow/init.lua:
return gluapack()()
--PATH lua/effects/corruptor_tracer.lua:
AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed 	= 12000
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )
EFFECT.ParticleCast = false
EFFECT.Time = nil

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local start = data:GetStart()

		if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entity = data:GetEntity()
			
			if( !IsValid( entity ) ) then 
				return start 
			end
			
			if( !game.SinglePlayer() && entity:IsEFlagSet( EFL_DORMANT ) ) then 
				return start 
			end
			
			local bFirstPersonFix = false
			
			if( entity:IsWeapon() && entity:IsCarriedByLocalPlayer() ) then
				local pl = entity:GetOwner()
				if( IsValid( pl ) ) then
					local vm = pl:GetViewModel()
					if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
						if ( game.SinglePlayer() ) && ( entity:GetSciFiState() == SCIFI_STATE_ADS && entity:Clip1() > 2 ) then
							bFirstPersonFix = true
						end
						
						entity = vm
					else 					
						if( entity.WorldModel ) then
							entity:SetModel( entity.WorldModel )
						end
					end
				end
			end

			local attachment = entity:GetAttachment( data:GetAttachment() )
			if( attachment ) then
				start = attachment.Pos
				
				if ( bFirstPersonFix ) then
					-- debugoverlay.Line( start, start + attachment.Ang:Forward() * 32, 4, Color( 255, 0, 0 ), true )
					-- debugoverlay.Line( start, start + attachment.Ang:Up() * 32, 4, Color( 0, 255, 0 ), true )
					-- debugoverlay.Line( start, start + attachment.Ang:Right() * 32, 4, Color( 0, 0, 255 ), true )
					start = start + attachment.Ang:Up() * -24 + attachment.Ang:Right() * 4
					-- debugoverlay.Cross( start, 16, 4, color_white, true )
				end
			end

		end
		
		return start
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end

function EFFECT:Think()
	
	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"corruptor_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			true, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local dlight = DynamicLight( -1 )
	if ( dlight ) then
		dlight.pos = lightorigin
		dlight.r = 230
		dlight.g = 60
		dlight.b = 40
		dlight.brightness = 1 * Fraction
		dlight.Size = 120 + 120 * Fraction
		dlight.Decay = 1024
		dlight.Style = 1
		dlight.DieTime = CurTime() + FrameTime() * 2
	end
	
	return false

end
--PATH lua/effects/crsv_dissolve.lua:
return gluapack()()
--PATH lua/effects/cryon_frozen.lua:
local mat_ice = Material( "models/elemental/frozen_alpha" )
local overlay_cache = Material( "models/elemental/frozen_overlay" )
local overlay = "models/elemental/frozen_overlay"

function EFFECT:Init( data )

	self.Time = data:GetScale() -- 2
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + ( EyePos() - PPos ):GetNormal() )
	
	local bFrozen = self.ParentEntity:GetNWBool( "bliz_frozen" )

	if ( !self.HasBeenFrozen ) then
		self.HasBeenFrozen = bFrozen
	end

	if ( !bFrozen && self.HasBeenFrozen ) then
		return false
	end
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()
	
	local ply = self:GetParent()
	
	if ( ply:IsPlayer() ) && ( ply == LocalPlayer() ) then
		DrawMaterialOverlay( overlay, 0.2 )
	end

end

function EFFECT:RenderOverlay( entity )

	local Fraction = (self.LifeTime - CurTime()) / self.Time
	local ColFrac = (Fraction-0.5) * 2
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	ColFrac =  math.Clamp( ColFrac, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( mat_ice )
	
		entity:DrawModel()
		render.MaterialOverride( 0 )
	cam.End3D()

end


function EFFECT:RenderParent()	
	
--	local bones = self:GetBoneCount() --GetPhysicsObjectCount()
--	for bone = 1, bones-1 do
--		self:ManipulateBoneScale( bone, Vector( math.random( 1.1, 1.2 ), math.random( 1.1, 1.2 ), math.random( 1.1, 1.2 ) ) * 42 )
--	end	
	
	self:DrawModel()
	
	-- render.SetColorModulation( 1, 1.1, 1.2 )	
	
	if !( IsValid( self ) && IsValid( self.SpawnEffect ) ) then return end

	self.SpawnEffect:RenderOverlay( self )

end
--PATH lua/effects/csgo_muzzle_assaultrifle_comp/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_assaultrifle_silenced/init.lua:
local ang

EFFECT.WeaponEnt = nil

local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_assaultrifle_silenced"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_magnum/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_magnum"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_pistol/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_pistol_elite/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_elite_laser_beam/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swrc/elite_beam" );
local MaterialFront			= Material( "effects/swrc/elite_beam_impact" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 25, 0, 1, color_white );
	
end

--PATH lua/effects/effect_astw2_swrc_laser_red/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swrc/blaster_bolt_red" );
local MaterialFront			= Material( "effects/swrc/a_FLASHRED" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--PATH lua/effects/effect_sw_laser_blue_akimbo/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_blue_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_green/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green_akimbo/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_white_akimbo_pu/init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/effects/electric_spark.lua:
function EFFECT:Init(data)
    self.Position = data:GetOrigin()
    self.Scale = data:GetMagnitude() or 1 -- Adjust scale as needed

    local entindex = data:GetEntity():EntIndex()

    -- Start a coroutine to create the electric spark effect
    coroutine.wrap(function()
        for i = 1, math.random(5, 10) do
            local lightning = ents.Create("point_tesla")
            lightning:SetPos(self.Position)
            lightning:SetKeyValue("m_SoundName", "")
            lightning:SetKeyValue("texture", "sprites/bluelight1.spr")
            lightning:SetKeyValue("m_Color", "255 255 150")
            lightning:SetKeyValue("m_flRadius", "150")
            lightning:SetKeyValue("beamcount_max", "15")
            lightning:SetKeyValue("thick_min", "15")
            lightning:SetKeyValue("thick_max", "30")
            lightning:SetKeyValue("lifetime_min", "0.15")
            lightning:SetKeyValue("lifetime_max", "0.4")
            lightning:SetKeyValue("interval_min", "0.15")
            lightning:SetKeyValue("interval_max", "0.25")
            lightning:Spawn()
            lightning:Fire("DoSpark", "", 0)
            lightning:Fire("kill", "", 0.2)

            local light = ents.Create("light_dynamic")
            light:SetPos(self.Position)
            light:Spawn()
            light:SetKeyValue("_light", "100 100 255")
            light:SetKeyValue("distance", "550")
            light:Fire("Kill", "", 0.20)

            sound.Play("k_lab.teleport_spark", self.Position, 110)

            -- Wait for a random interval before creating the next spark
            local interval = math.Rand(0.03, 0.1)
            coroutine.yield(interval)
        end
    end)()
end

function EFFECT:Think()
    -- No need to continue thinking
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/emg_tracer_hybrid.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 64000
EFFECT.Length	= 32
EFFECT.Trace	= Material( "particle/muzzleflash_burst_add_upsidedown" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Color = Color( 255, 20, 0, 255 )

--EFFECT.Speed = 32000

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed

end

function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"emg_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end

	self.LifeTime = self.LifeTime - FrameTime() * 0.5
	self.StartTime = self.StartTime + FrameTime() * 0.5
	
	return ( self.LifeTime > 0 ) -- CurTime() ) 
	
end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance * 2

	render.SetMaterial( self.Trace )
	render.DrawBeam( startPos, endPos, 24, 0, 1, self.Color )

	local Fraction = math.Clamp( self.Length / endDistance, 0, 1 )

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = startPos
		mLight.r = 255
		mLight.g = 20
		mLight.b = 0
		mLight.brightness = 0.4 + 1 * Fraction
		mLight.Size = 256 + 64 * Fraction
		mLight.Decay = 1024 + 1024 * Fraction
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[miecze] moce i hilty/lua/effects/force_barrier.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_barrier.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()
	
	self.mat = Material( "effects/select_ring" )
	
	self.LifeTime = 0.6
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )
	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,100,150,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or not self.Ent:Alive() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_cleave.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_heal.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "sprites/light_glow02_add" )


function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )

	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,255,0,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or (self.Ent.Alive and not self.Ent:Alive()) then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end

	if IsValid( self.Model ) then
		self.Model:SetColor( Color(0,255 * (self.DieTime - CurTime()) / self.LifeTime,0,255) )
	end

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Ent:LocalToWorld( Vector(0,0,40) ), 200 * Scale, 200 * Scale, Color( 0, 150 * Scale, 0, 150 * Scale ) )
end
	

--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementii_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 21, 255, 0) ) -- DETRLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiii_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningx.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255 --EDT
					dlight.g = 0 --EDT
					dlight.b = 0 --EDT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightningx_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255 --EDT
							dlight.g = 0 --EDT
							dlight.b = 0 --EDT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 255, 0, 0) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 255, 0, 0, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 0, 0) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 0 + 150 * Width, 0, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 0, 0, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 0, 0) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningx_hit.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/green_tracer_fx.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_green_main" );
local MaterialFront			= Material( "effects/sw_laser_green_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * (endDistance*1.2);
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 32, 24, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white );
	
end

--PATH lua/effects/hmp_concussion_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.9
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,255,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255,255,255 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "hmp/destruction_explosions_modular_sfx_small_disruption_var_05.mp3", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 500 * Scale, Color( 255,255,255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255,255,255) )
end

--PATH lua/effects/hwave_dissolve.lua:
return gluapack()()
--PATH lua/effects/lfs_blacksmoke.lua:
return gluapack()()
--PATH lua/effects/lvs_capital_red_geono.lua:
EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1500 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )

	render.DrawBeam( endpos - dir * len, endpos + dir * len * 0.1, 10, 1, 0, Color( 75, 0, 130, 255 ) )
	render.DrawBeam( endpos - dir * len * 0.5, endpos + dir * len * 0.1, 5, 1, 0, Color( 255, 150, 0, 255 ) )

	render.SetMaterial( self.MatSprite ) 
	render.DrawSprite( endpos, 400, 400, Color( 75, 0, 130, 255 ) )
end
--PATH lua/effects/lvs_capital_red_laser.lua:
EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1500 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )

	render.DrawBeam( endpos - dir * len, endpos + dir * len * 0.1, 10, 1, 0, Color( 255, 100, 0, 255 ) )
	render.DrawBeam( endpos - dir * len * 0.5, endpos + dir * len * 0.1, 5, 1, 0, Color( 255, 150, 0, 255 ) )

	render.SetMaterial( self.MatSprite ) 
	render.DrawSprite( endpos, 400, 400, Color( 255, 0, 0, 255 ) )
end
--PATH lua/effects/lvs_exhaust_fire.lua:
return gluapack()()
--PATH lua/effects/lvs_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
	end
	
	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i
				
				self:Explosion( p, math.Rand(0.5,0.8) )
			end
		end)
	end

	self:Debris( Pos )

	local traceSky = util.TraceLine( {
		start = Pos,
		endpos = Pos + Vector(0,0,50000),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = Pos - Vector(0,0,100),
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = Pos + Vector(0,0,100),
			endpos = Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 10 do
				local StartPos = trace.HitPos + Vector(math.random(-25,25) * i,math.random(-25,25) * i,0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
					mask = MASK_SOLID_BRUSHONLY,
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(2,3), math.Rand(2,3) )
			end
		end
	end
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( math.Rand(0.75,1.5) * scale )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(60,120) * scale )
			particle:SetEndSize( math.Rand(220,320) * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_explosion_bomb.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = Vector(0,0,1)
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = 3

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 3 do
				local StartPos = trace.HitPos + Vector(math.random(-200,200),math.random(-200,200),0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(3,6), math.Rand(3,6) )
			end
		end
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BOMB_EXPLOSION", Pos )
			sound.Play( "LVS.BOMB_EXPLOSION_DYNAMIC", Pos )
		end )
	end

	for i = 1, 10 do
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1, 10 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

		if not particle then continue end

		particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * scale )
		particle:SetDieTime( (i / 8) * DieTime )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( 20 * i * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
		particle:SetGravity( Vector(0,0,-600) * scale )
		particle:SetCollide( false )
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if particle then
			local ang = i * 15
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(1500,2000)

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( math.Rand(1,3) )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 )
			particle:SetEndSize( 600 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		local vel = VectorRand() * math.Rand(800,1600)
		vel.z = math.Rand(1000,4000)

		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.random(5,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -2000 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -450 * InvScale, 30,30, Color( 255, 200, 150, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -500 * InvScale, 30,30, Color( 255, 200, 150, 100 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -550 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 600 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
	end
end

--PATH lua/effects/lvs_laat_left_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_left" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end

	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--PATH lua/effects/lvs_laat_right_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_right" )
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTRFire() then
		return false
	end
	
	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )

			local vel = VectorRand()  * 100 + dir * 40

			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--PATH lua/effects/lvs_laser_charge.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_red.lua:
return gluapack()()
--PATH lua/effects/lvs_shield_impact.lua:

local LastImpact = 0

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	local T = CurTime()

	self.LifeTime = 0.2
	self.DieTime = T + self.LifeTime

	local DontHurtEars = math.Clamp( T - LastImpact, 0.4, 1 ) ^ 2

	LastImpact = T

	sound.Play( "lvs/shield_deflect.ogg", self.Pos, 120, 100, DontHurtEars )

	self:Spark( self.Pos )

	if IsValid( self.Ent ) then
		self.Model = ClientsideModel( self.Ent:GetModel(), RENDERMODE_TRANSCOLOR )
		self.Model:SetMaterial("models/alyx/emptool_glow")
		self.Model:SetColor( Color(200,220,255,255) )
		self.Model:SetParent( self.Ent, 0 )
		self.Model:SetMoveType( MOVETYPE_NONE )
		self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
		self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
		self.Model:AddEffects( EF_BONEMERGE )
	end
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )

		local vel = VectorRand() * 500

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 0, 127, 255 )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then
		if IsValid( self.Model ) then
			self.Model:Remove()
		end
	end

	if self.DieTime < CurTime() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 200 * Scale, 200 * Scale, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/nio_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/pulsar_tracer_noattach_red.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	util.ParticleTracerEx( 
		"pulsar_beam_red", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/rb655_extinguisher_effect.lua:

function EFFECT:Init( data )

	self.Player = data:GetEntity()
	self.Origin = data:GetOrigin()
	self.Attachment = data:GetAttachment()
	self.Forward = data:GetNormal()
	self.Scale = data:GetScale()

	if ( !IsValid( self.Player ) || !IsValid( self.Player:GetActiveWeapon() ) ) then return end

	self.Angle = self.Forward:Angle()
	self.Position = self:GetTracerShootPos( self.Origin, self.Player:GetActiveWeapon(), self.Attachment )

	if ( self.Position == self.Origin ) then
		local att = self.Player:GetAttachment( self.Player:LookupAttachment( "anim_attachment_RH" ) )
		if ( att ) then self.Position = att.Pos + att.Ang:Forward() * -2 end
	end

	local teh_effect = ParticleEmitter( self.Player:GetPos(), true )
	if ( !teh_effect ) then return end

	for i = 1, 12 * self.Scale do
		local particle = teh_effect:Add( "effects/splash4", self.Position )
		if ( particle ) then
			local Spread = 0.3
			particle:SetVelocity( ( Vector( math.sin( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.cos( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.sin( math.random() ) * math.Rand( -Spread, Spread ) ) + self.Forward ) * 750 )

			local ang = self.Angle
			if ( i / 2 == math.floor( i / 2 ) ) then ang = ( self.Forward * -1 ):Angle() end
			particle:SetAngles( ang )
			particle:SetDieTime( 0.25 )
			particle:SetColor( 255, 255, 255 )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 0 )
			particle:SetCollide( 1 )
			particle:SetCollideCallback( function( particleC, HitPos, normal )
				particleC:SetAngleVelocity( Angle( 0, 0, 0 ) )
				particleC:SetVelocity( Vector( 0, 0, 0 ) )
				particleC:SetPos( HitPos + normal * 0.1 )
				particleC:SetGravity( Vector( 0, 0, 0 ) )

				local angles = normal:Angle()
				angles:RotateAroundAxis( normal, particleC:GetAngles().y )
				particleC:SetAngles( angles )

				particleC:SetLifeTime( 0 )
				particleC:SetDieTime( 10 )
				particleC:SetStartSize( 8 )
				particleC:SetEndSize( 0 )
				particleC:SetStartAlpha( 128 )
				particleC:SetEndAlpha( 0 )
			end )
		end
	end

	teh_effect:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/rw_sw_dual_laser_aqua.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_aqua")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_aqua")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 160
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_green.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_purple.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_orange.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_orange" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_redpink.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_redpink" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_laser_red.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_laser_yellow.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH addons/[miecze] moce i hilty/lua/effects/saber_block.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime
	
	self:Spark( self.Pos, self.Dir )
end

function EFFECT:Spark( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 200 + dir * 80
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(2,4) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos + self.Dir, 150 * Scale, 150 * Scale, Color( 255, 255, 200, 255) ) 
end

--PATH lua/effects/serv_passive_heal.lua:
EFFECT.Mat1 = Material( "particle/particle_ring_wave_8" )
EFFECT.Mat2 = Material( "sprites/key_12" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HPMax = math.max( math.Round( data:GetMagnitude() ),0)
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(50, 150, 50, 255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.HealingAm = math.Clamp((self.Entity:GetMaxHealth()-self.Entity:Health())/2, 0, 10)

	self.FollowPlayer = self.Entity:GetPos()

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )
	self.Color["a"] = math.max(255-(self.Life*60),0)

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles
	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat1, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*15) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(2) 
		particle:SetStartAlpha( 20+(self.HealingAm*5) )
		particle:SetEndAlpha(0)
		particle:SetStartSize(30) 
		particle:SetEndSize(70)
		particle:SetAngles( Angle(math.random( 0, 360 ),math.random( 0, 360 ),math.random( 0, 360 )) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetRoll(math.random( 0, 360 ))
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, 0 ) ) 
		particle:SetVelocity( Vector(math.random( -30, 30 ), math.random( -30, 30 ), math.random( 50, 75 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()

	local emitter = ParticleEmitter( self.FollowPlayer, false )
	local particle = emitter:Add( self.Mat2, (self.FollowPlayer+Vector(0,0,20))+(VectorRand()*30) )
	if (particle) then
		particle:SetLifeTime(0) 
		particle:SetDieTime(1.2) 
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(self.HealingAm) 
		particle:SetEndSize(0)
		particle:SetAngles( Angle(0,0,0) )
		particle:SetAngleVelocity( Angle(math.random( 0, 1 ),math.random( 0, 1 ),math.random( 0, 1 )) ) 
		particle:SetColor( self.Color["r"], self.Color["g"], self.Color["b"] )
		particle:SetGravity( Vector(0, 0, math.random( 50, 150 ) ) ) 
		particle:SetVelocity( Vector(math.random( -50, 50 ), math.random( -50, 50 ), math.random( 20, 50 ) ) ) 
		particle:SetAirResistance(50)  
		particle:SetCollide(true)
		particle:SetBounce(0)
	end
	emitter:Finish()
end
--PATH lua/effects/servius_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/snx_passive_stun.lua:
return gluapack()()
--PATH lua/effects/spectra_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()
	
	util.ParticleTracerEx( 
		"_wrath_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/sw_explosion.lua:
return gluapack()()
--PATH lua/effects/swep_flamethrower_explosion/init.lua:
//Main function
function EFFECT:Init(data)


//Default performance settings
local DrawFlame = 1
local DrawSmoke = 1
local DrawRefraction = 0

//Adjust performance depending on user settings
local PerfIndex = GetConVar("flamethrower_fx"):GetInt()
if PerfIndex == 3 then DrawRefraction = 1 end


//Play impact sound
sound.Play("ambient/fire/ignite.wav", self:GetPos(), 54, math.random(82,112))


	//Draw burst of flame
	if DrawFlame == 1 then

	//Create particle emmiter
	local FlameEmitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 16 do

			//Safeguard
			if !FlameEmitter then return end

			//Pool of flame sprites
			local FlameMat = {}
			FlameMat[1] = "effects/muzzleflash2"
			FlameMat[2] = "effects/muzzleflash2edit"
			FlameMat[3] = "effects/muzzleflash3"

			local FlameParticle = FlameEmitter:Add( FlameMat[math.random(1,3)], data:GetOrigin() )

			//Refraction is too expensive to render on most machines
			if DrawRefraction == 1 then
			if math.random(1,12) == 12 then
			FlameParticle = FlameEmitter:Add( "sprites/heatwave", data:GetOrigin() )
			end
			end

			if (FlameParticle) then

				FlameParticle:SetVelocity( VectorRand() * 172 )
				
				FlameParticle:SetLifeTime(0)
				FlameParticle:SetDieTime(0.72)
				
				FlameParticle:SetStartAlpha(210)
				FlameParticle:SetEndAlpha(0)
				
				FlameParticle:SetStartSize(0)
				FlameParticle:SetEndSize(64)
				
				FlameParticle:SetRoll(math.Rand(-210, 210))
				FlameParticle:SetRollDelta(math.Rand(-3.2, 3.2))
				
				FlameParticle:SetAirResistance(350)
				
				FlameParticle:SetGravity(Vector(0, 0, 64))

			end
		end

	//We're done with this emmiter
	FlameEmitter:Finish()

	//Finished with flame
	end


	//Draw stream of smoke
	if DrawSmoke == 1 then

	//Create particle emmiter
	local SmokeEmitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 4 do

			//Safeguard
			if !SmokeEmitter then return end

			SmokeParticle = SmokeEmitter:Add( "particle/smokesprites_000" .. math.random(1,8) .. "", data:GetOrigin() )

			if (SmokeParticle) then

				SmokeParticle:SetVelocity( VectorRand() * 210 )
				
				SmokeParticle:SetLifeTime(0)
				SmokeParticle:SetDieTime( math.Rand(1.92, 2.82) )
				
				SmokeParticle:SetStartAlpha(82)
				SmokeParticle:SetEndAlpha(0)
				
				SmokeParticle:SetStartSize(21)
				SmokeParticle:SetEndSize(82)
				
				SmokeParticle:SetRoll(math.Rand(-320, 320))
				SmokeParticle:SetRollDelta(math.Rand(-1.32, 1.32))
				
				SmokeParticle:SetAirResistance(420)
				
				SmokeParticle:SetGravity(Vector( 0, 0, math.random(112, 132) ))

				SmokeParticle:SetLighting(1)

			end
		end

	//We're done with this emmiter
	SmokeEmitter:Finish()

	//Finished with smoke
	end


end

//Kill effect
function EFFECT:Think()
return false
end

//Unused
function EFFECT:Render()
end
--PATH lua/effects/tfa_csgo_healnade/init.lua:
return gluapack()()
--PATH lua/effects/tfa_csgo_poisonade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 25 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 35 )
			else
				particle:SetDieTime( math.Rand( 30,35 ) )
			end
			particle:SetStartAlpha( math.Rand( 116, 216 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 116 )
			particle:SetEndSize( 216 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 95, 125, 60 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--PATH lua/effects/tfa_csgo_smokenade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 100 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 400) )
			if i <= 1 then 
				particle:SetDieTime( 25 )
			else
				particle:SetDieTime( math.Rand( 23,28 ) )
			end
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 44 )
			particle:SetEndSize( 144 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 65, 65, 65 ) 
			particle:SetAirResistance( 100 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--PATH lua/effects/tfa_muzzleflash_gauss/init.lua:
local blankvec = Vector(0, 0, 0)

local vector_origin = Vector()

function EFFECT:Init(data)
	self.Position = blankvec
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = self.WeaponEnt
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()
	end

	if not IsValid(owent) then
		owent = self.WeaponEnt:GetParent()
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG:GetStatL("IsAkimbo") then
			self.Attachment = 2 - self.WeaponEntOG:GetAnimCycle()
		end
	end

	local angpos = self.WeaponEnt:GetAttachment(self.Attachment)

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	self.Position = self:GetTracerShootPos(angpos.Pos, self.WeaponEnt, self.Attachment)
	self.Norm = self.Dir
	self.vOffset = self.Position
	local dir = self.Norm
	local dlight

	if IsValid(self.WeaponEnt) then
		dlight = DynamicLight(self.WeaponEnt:EntIndex())
	else
		dlight = DynamicLight(0)
	end

	local fadeouttime = 0.2

	if (dlight) then
		dlight.Pos = self.Position + dir * 1 - dir:Angle():Right() * 5
		dlight.r = 25
		dlight.g = 200
		dlight.b = 255
		dlight.Brightness = 4.0
		dlight.size = 96
		dlight.decay = 1000
		dlight.DieTime = CurTime() + fadeouttime
	end

	ParticleEffectAttach("tfa_muzzle_gauss", PATTACH_POINT_FOLLOW, self.WeaponEnt, data:GetAttachment())
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_pistol/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_sniper/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 1.5
EFFECT.FlashSize = 1.2
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1.3
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_penetrate/init.lua:
return gluapack()()
--PATH lua/effects/tfa_shell/init.lua:
EFFECT.Velocity = {120, 160}
EFFECT.VelocityRand = {-15, 40}
EFFECT.VelocityAngle = Vector(1,1,10)
EFFECT.VelocityRandAngle = Vector(10,10,5)

local modelReplaceLookup = {
	["models/hdweapons/rifleshell.mdl"] = "models/tfa/rifleshell.mdl",
	["models/hdweapons/rifleshell_hd.mdl"] = "models/tfa/rifleshell.mdl",
	["models/weapons/rifleshell_hd.mdl"] = "models/tfa/rifleshell.mdl",
	["models/hdweapons/shell.mdl"] = "models/tfa/pistolshell.mdl",
	["models/hdweapons/shell_hd.mdl"] = "models/tfa/pistolshell.mdl",
	["models/weapons/shell_hd.mdl"] = "models/tfa/pistolshell.mdl",
	["models/hdweapons/shotgun_shell.mdl"] = "models/tfa/shotgunshell.mdl",
	["models/hdweapons/shotgun_shell_hd.mdl"] = "models/tfa/shotgunshell.mdl",
	["models/weapons/shotgun_shell_hd.mdl"] = "models/tfa/shotgunshell.mdl",
}

EFFECT.ShellPresets = {
	["sniper"] = {"models/tfa/rifleshell.mdl", math.pow(0.487 / 1.236636, 1 / 3), 90}, --1.236636 is shell diameter, then divide base diameter into that for 7.62x54mm
	["rifle"] = {"models/tfa/rifleshell.mdl", math.pow(0.4709 / 1.236636, 1 / 3), 90}, --1.236636 is shell diameter, then divide base diameter into that for standard nato rifle
	["pistol"] = {"models/tfa/pistolshell.mdl", math.pow(0.391 / 0.955581, 1 / 3), 90}, --0.955581 is shell diameter, then divide base diameter into that for 9mm luger
	["smg"] = {"models/tfa/pistolshell.mdl", math.pow(.476 / 0.955581, 1 / 3), 90}, --.45 acp
	["shotgun"] = {"models/tfa/shotgunshell.mdl", 1, 90}
}

EFFECT.SoundFiles = {Sound(")player/pl_shell1.wav"), Sound(")player/pl_shell2.wav"), Sound(")player/pl_shell3.wav")}
EFFECT.SoundFilesSG = {Sound(")weapons/fx/tink/shotgun_shell1.wav"), Sound(")weapons/fx/tink/shotgun_shell2.wav"), Sound(")weapons/fx/tink/shotgun_shell3.wav")}
EFFECT.SoundLevel = {45, 55}
EFFECT.SoundPitch = {80, 120}
EFFECT.SoundVolume = {0.85, 0.95}
EFFECT.LifeTime = 15
EFFECT.FadeTime = 0.5
EFFECT.SmokeTime = {3, 3}
EFFECT.SmokeParticle = "tfa_ins2_weapon_shell_smoke"
local cv_eject
local cv_life
local upVec = Vector(0,0,1)

function EFFECT:ComputeSmokeLighting()
	if not self.PCFSmoke then return end
	local licht = render.ComputeLighting(self:GetPos() + upVec * 2, upVec)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	self.PCFSmoke:SetControlPoint(1, lichtFinal)
end

function EFFECT:Init(data)
	self.IsTFAShell = true

	if not cv_eject then
		cv_eject = GetConVar("cl_tfa_fx_ejectionsmoke")
	end

	if not cv_life then
		cv_life = GetConVar("cl_tfa_fx_ejectionlife")
	end

	if cv_life then
		self.LifeTime = cv_life:GetFloat()
	end

	self.StartTime = CurTime()
	self.Emitter = ParticleEmitter(self:GetPos())
	self.SmokeDelta = 0

	if cv_eject:GetBool() then
		self.SmokeDeath = self.StartTime + math.Rand(self.SmokeTime[1], self.SmokeTime[2])
	else
		self.SmokeDeath = -1
	end

	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.WeaponEntOG = self.WeaponEnt
	if self.WeaponEntOG.LuaShellEffect and self.WeaponEntOG.LuaShellEffect == "" then return end
	self.Attachment = data:GetAttachment()
	self.Dir = data:GetNormal()
	self.DirAng = data:GetNormal():Angle()
	self.OriginalOrigin = data:GetOrigin()
	local owent = self.WeaponEnt:GetOwner()

	if self.LifeTime <= 0 or not IsValid(owent) then
		self.StartTime = -1000
		self.SmokeDeath = -1000

		return
	end

	if owent:IsPlayer() and owent == GetViewEntity() and not owent:ShouldDrawLocalPlayer() then
		self.WeaponEnt = self.WeaponEnt.OwnerViewModel
		if not IsValid(self.WeaponEnt) then return end
	end

	local model, scale, yaw = self:FindModel(self.WeaponEntOG)
	model = self.WeaponEntOG:GetStatL("ShellModel") or self.WeaponEntOG:GetStatL("LuaShellModel") or model
	model = modelReplaceLookup[model] or model
	scale = self.WeaponEntOG:GetStatL("ShellScale") or self.WeaponEntOG:GetStatL("LuaShellScale") or scale
	yaw = self.WeaponEntOG:GetStatL("ShellYaw") or self.WeaponEntOG:GetStatL("LuaShellYaw") or yaw

	if model:lower():find("shotgun") then
		self.Shotgun = true
	end

	self:SetModel(model)
	self:SetModelScale(scale, 0)
	self:SetPos(data:GetOrigin())
	local mdlang = self.DirAng * 1
	mdlang:RotateAroundAxis(mdlang:Up(), yaw)
	local owang = IsValid(owent) and owent:EyeAngles() or mdlang
	self:SetAngles(owang)
	self:SetRenderMode(RENDERMODE_TRANSALPHA)
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self:SetCollisionBounds(self:OBBMins(), self:OBBMaxs())
	self:PhysicsInitBox(self:OBBMins(), self:OBBMaxs())
	local velocity = self.Dir * math.Rand(self.Velocity[1], self.Velocity[2]) + owang:Forward() * math.Rand(self.VelocityRand[1], self.VelocityRand[2])

	if IsValid(owent) then
		velocity = velocity + owent:GetVelocity()
	end

	local physObj = self:GetPhysicsObject()

	if physObj:IsValid() then
		physObj:SetDamping(0.1, 1)
		physObj:SetMass(5)
		physObj:SetMaterial("gmod_silent")
		physObj:SetVelocity(velocity)
		local localVel = velocity:Length() * self.WeaponEnt:WorldToLocalAngles(velocity:Angle()):Forward()
		physObj:AddAngleVelocity(localVel.y * self.VelocityAngle)
		physObj:AddAngleVelocity(VectorRand() * velocity:Length() * self.VelocityRandAngle * 0.5)
	end

	local ss = self.WeaponEntOG:GetStatL("ShellSound") or self.WeaponEntOG:GetStatL("LuaShellSound")

	if ss then
		self.ImpactSound = ss
	else
		self.ImpactSound = self.Shotgun and self.SoundFilesSG[math.random(1, #self.SoundFiles)] or self.SoundFiles[math.random(1, #self.SoundFiles)]
	end

	self.setup = true
end

function EFFECT:FindModel(wep)
	if not IsValid(wep) then return unpack(self.ShellPresets["rifle"]) end
	local ammotype = (wep.Primary.Ammo or wep:GetPrimaryAmmoType()):lower()
	local guntype = (wep.Type or wep:GetHoldType()):lower()

	if guntype:find("sniper") or ammotype:find("sniper") or guntype:find("dmr") then
		return unpack(self.ShellPresets["sniper"])
	elseif guntype:find("rifle") or ammotype:find("rifle") then
		return unpack(self.ShellPresets["rifle"])
	elseif ammotype:find("pist") or guntype:find("pist") then
		return unpack(self.ShellPresets["pistol"])
	elseif ammotype:find("smg") or guntype:find("smg") then
		return unpack(self.ShellPresets["smg"])
	elseif ammotype:find("buckshot") or ammotype:find("shotgun") or guntype:find("shot") then
		return unpack(self.ShellPresets["shotgun"])
	end

	return unpack(self.ShellPresets["rifle"])
end

function EFFECT:BounceSound()
	sound.Play(self.ImpactSound, self:GetPos(), math.Rand(self.SoundLevel[1], self.SoundLevel[2]), math.Rand(self.SoundPitch[1], self.SoundPitch[2]), math.Rand(self.SoundVolume[1], self.SoundVolume[2]))
end

function EFFECT:PhysicsCollide(data)
	if self:WaterLevel() > 0 then return end

	if TFA.GetEJSmokeEnabled() and not self.PCFSmoke and CurTime() < self.SmokeDeath then
		self.PCFSmoke = CreateParticleSystem(self, self.SmokeParticle, self:GetAttachment(1) ~= nil and PATTACH_POINT_FOLLOW or PATTACH_ABSORIGIN_FOLLOW, 1)
		if IsValid(self.PCFSmoke) then
			self:ComputeSmokeLighting()
			self.PCFSmoke:StartEmission()
		else
			self.PCFSmoke = nil
		end
	end

	if data.Speed > 60 then
		self:BounceSound()
		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal) * 0.33
		local phys = self:GetPhysicsObject()

		if phys:IsValid() then
			phys:ApplyForceCenter(impulse)
		end
	end
end

function EFFECT:Think()
	if CurTime() > self.SmokeDeath and self.PCFSmoke then
		self.PCFSmoke:StopEmission()
		self.PCFSmoke = nil
	else
		self:ComputeSmokeLighting()
	end

	if self:WaterLevel() > 0 and not self.WaterSplashed then
		self.WaterSplashed = true
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		ef:SetScale(1)
		util.Effect("watersplash", ef)
	end

	if CurTime() > self.StartTime + self.LifeTime then
		if self.Emitter then
			self.Emitter:Finish()
		end

		return false
	else
		return true
	end
end

function EFFECT:Render()
	if not self.setup then return end
	self:SetColor(ColorAlpha(color_white, (1 - math.Clamp(CurTime() - (self.StartTime + self.LifeTime - self.FadeTime), 0, self.FadeTime) / self.FadeTime) * 255))
	self:SetupBones()
	self:DrawModel()
end

hook.Add("EntityEmitSound", "TFA_BlockShellScrapeSound", function(sndData)
	if IsValid(sndData.Entity) and sndData.Entity.IsTFAShell and sndData.SoundName:find("scrape") then
		return false
	end
end)
--PATH lua/effects/tfa_shell_legacy/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_blue/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_gauss/init.lua:
local vector_origin = Vector()

EFFECT.Thickness = 16
EFFECT.Life = 0.25
EFFECT.RotVelocity = 30
EFFECT.InValid = false
local Mat_Impact = Material("effects/combinemuzzle2")
local Mat_Beam = Material("effects/tool_tracer")
local Mat_TracePart = Material("effects/select_ring")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end


	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:EyePos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = 0
end

function EFFECT:Think()
	if self.InValid then return false end
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

local beamcol = table.Copy(color_white)
local beamcol2 = Color(0, 225, 255, 255)

function EFFECT:Render()
	if self.InValid then return false end
	self.StartPos = self:GetTracerShootPos(self.StartPos, self.WeaponEnt, self.Attachment)
	local startPos = self.StartPos
	local endPos = self.EndPos
	local tracerpos
	beamcol.a = self.LifeTime / self.Life * 255
	self.rot = self.rot + FrameTime() * self.RotVelocity
	render.SetMaterial(Mat_Impact)
	render.DrawSprite(endPos, 12, 12, ColorAlpha(color_white, beamcol.a))
	render.SetMaterial(Mat_TracePart)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.15, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.2, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	render.SetMaterial(Mat_Beam)
	render.DrawBeam(startPos, endPos, self.Thickness, 0 + beamcol.a / 128, endPos:Distance(startPos) / 64 + beamcol.a / 128, beamcol)
end

--PATH lua/effects/tfa_tracer_plasma/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(128, 255, 255) --Color(225,225,225,225)
EFFECT.Col2 = Color(97, 218, 255)
EFFECT.Speed = 4096
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
render.SetMaterial(self.Mat)
lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
local startbeampos = Lerp(self.Life, self.StartPos, self.EndPos)
local endbeampos = Lerp(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_purple/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_yellow/init.lua:
return gluapack()()
--PATH lua/effects/vj_blood1/init.lua:
return gluapack()()
--PATH lua/effects/vj_small_dust1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Cloud of smoke that goes up
	for i = 1,8 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
		EffectCode:SetDieTime(math.Rand(7,9)) -- How much time until it dies
		EffectCode:SetStartAlpha(150) -- Transparency
		EffectCode:SetStartSize(math.Rand(20,40)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(100,120)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
		EffectCode:SetColor(80,60,20) -- The color of the effect
		EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
		EffectCode:SetAirResistance(15)
	end
	Emitter:Finish()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH addons/[tfres] frest_levels/lua/fstands2/levels/config.lua:
return gluapack()()
--PATH lua/prone/config.lua:
-------------------
-- General Settings
-------------------
-- What should we multiply fall damage by while prone. Set to 1 to disable.
prone.Config.FallDamageMultiplier = 1.75


-----------------------
-- Key-related settings
-----------------------
-- NOTICE:	Every setting in this section can later be changed
--			by the user with the "prone_config" command.

-- By default is the bind key enabled.
prone.Config.DefaultBindKey_Enabled = true

-- What is the default bind key set by the server.
-- See http://wiki.garrysmod.com/page/Enums/KEY
prone.Config.DefaultBindKey = KEY_LCONTROL

-- By default should the player double tap the bind key to go prone.
prone.Config.DefaultBindKey_DoubleTap = true

-- By default can the user press the jump key to get up.
prone.Config.DefaultJumpToGetUp = true

-- By default must the user double press the jump key to get up.
prone.Config.DefaultJumpToGetUp_DoubleTap = false

--------------
-- Move speeds
--------------
-- How fast they move while prone.
prone.Config.MoveSpeed = 50

-- How fast they move while getting up or going down.
-- Prefer to keep this at 0, otherwise if they move somewhere they cant fit while getting up
-- they will be forced back into prone.
prone.Config.TransitionSpeed = 0

----------------------------
-- Shooting related settings
----------------------------
-- There are no moving and shooting animations while prone so it would look like
-- players aren't shooting when they are. You probably don't want to change this to false.
prone.Config.MoveShoot_Restrict = true

-- Weapons in this list can be shot while moving
prone.Config.MoveShoot_Whitelist = {
	weapon_physgun			= true,
	weapon_physcannon		= true,		-- Gravity Gun
	gmod_tool				= true,		-- Toolgun
	gmod_camera				= true,
	weapon_medkit			= true,
	weaponchecker			= true,		-- (DarkRP)
	keys					= true,		-- (DarkRP)
	pocket					= true,		-- (DarkRP)
	weapon_keypadchecker	= true,		-- (DarkRP)
	unarrest_stick			= true,		-- (DarkRP)
	arrest_stick			= true,		-- (DarkRP)
	weapon_zm_carry			= true,		-- (TTT) Magneto Stick
	weapon_ttt_binoculars	= true,		-- (TTT)
	weapon_ttt_unarmed		= true		-- (TTT)
}


--------------------------
-- DarkRP related settings
--------------------------
-- Should we restrict prone by job.
prone.Config.Darkrp_RestrictJobs = false

-- Is the job list a whitelist? False for blacklist.
prone.Config.Darkrp_IsWhitelist = true

-- If the above setting is true this is the job whitelist. Blacklist otherwise.
prone.Config.Darkrp_Joblist = {
	TEAM_POLICE,
	TEAM_GANG
}

-- Any players of these ranks can go prone, no matter of their job.
prone.Config.Darkrp_BypassRanks = {
	"superadmin",
	"admin"
}

--------------------
-- Advanced Settings
--------------------
-- Sets the hull height while prone. What you can fit under.
prone.Config.HullHeight = 24

-- Sets how low the player's view will be while prone.
prone.Config.View = Vector(0, 0, 20)

prone.Animations.gettingdown = "pronedown_stand"
prone.Animations.gettingup = "proneup_stand"
prone.Animations.passive = "prone_walkpassive"

-- These two are not in use right now.
prone.Animations.gettingdown_crouch = "pronedown_crouch"
prone.Animations.gettingup_crouch = "proneup_crouch"

prone.Animations.WeaponAnims = {
	moving = {
		ar2			= "prone_walktwohand",
		camera		= "prone_walkonehand",
		crossbow	= "prone_walkcrossbow",
		duel		= "prone_walkcrossbow",
		fist		= "prone_walkpassive",
		grenade		= "prone_walkonehand",
		knife		= "prone_walkpassive",
		magic		= "prone_walkpassive",
		melee		= "prone_walkonehand",
		melee2		= "prone_walkonehand",
		normal		= "prone_walkpassive",
		passive		= "prone_walkpassive",
		pistol		= "prone_walkonehand",
		physgun		= "prone_walkphysgun",
		revolver	= "prone_walkonehand",
		rpg			= "prone_walkrpg",
		shotgun		= "prone_walktwohand",
		slam		= "prone_walkonehand",
		smg			= "prone_walktwohand"
	},

	idle = {
		ar2			= "prone_ar2",
		camera		= "prone_camera",
		crossbow	= "prone_crossbow",
		duel		= "prone_crossbow",
		fist		= "prone_knife",
		grenade		= "prone_grenade",
		knife		= "prone_knife",
		magic		= "prone_knife",
		melee		= "prone_melee",
		melee2		= "prone_melee2",
		normal		= "prone_passive",
		passive		= "prone_passive",
		pistol		= "prone_pistol",
		physgun		= "prone_physgun",
		revolver	= "prone_revolver",
		rpg			= "prone_rpg",
		shotgun		= "prone_shotgun",
		slam		= "prone_slam",
		smg			= "prone_smg1"
	}
}
--PATH lua/rd_claim_boards/core/client/cl_net.lua:
local function OpenStatus(ent)
    if ent:GetClaimBoardOpen() then
        return 1
    else
        return 2
    end
end

local COL_1 = Color(255, 255, 255)
local COL_2 = Color(41, 128, 185)
local COL_3 = Color(41, 185, 84)
local COL_4 = Color(23, 23, 23, 255)

local function CreateDivider(SCROLL, TEXT)
    local w, h = SCROLL:GetSize()

    local TLABEL = vgui.Create("DLabel", SCROLL)
    TLABEL:Dock(TOP)
    TLABEL:DockMargin(0, h * 0.02, 0, h * 0.02)
    TLABEL:SetText(TEXT)
    TLABEL:SetContentAlignment(5)
    TLABEL:SetFont("RD_FONTS_CORE_LABEL_LOWER")
    TLABEL:SetTextColor(COL_1)
end

net.Receive("RD_CLAIMBOARD_OPEN", function()
    local entity = net.ReadEntity()
    local open = true

    local BATTALION
    local STATUS
    local BAT_INT


    local BATTALIONS = RDV.CLAIMBOARDS.GetBattalions()

    local FRAME = vgui.Create("RDV_LIBRARY_FRAME")
    FRAME:SetTitle(RDV.LIBRARY.GetLang(nil, "CLAIMB_CBLabel"))
    FRAME:SetSize(ScrW() * 0.25, ScrH() * 0.5)
    FRAME:Center()
    FRAME:MakePopup()

    local w, h = FRAME:GetSize()

    local SCROLL = vgui.Create("RDV_LIBRARY_SCROLL", FRAME)
    SCROLL:Dock(FILL)
    SCROLL.Think = function(s)
        local HTEXT = ""
        local TITLE
        local HEADER
        local w, h = s:GetSize()

        CreateDivider(s, RDV.LIBRARY.GetLang(nil, "CLAIMB_headerLabel"))

        if RDV.CLAIMBOARDS.CFG.CustomHeaders then
            TITLE = vgui.Create("RDV_LIBRARY_TextEntry", s)
            TITLE:SetHeight(h * 0.075)
            TITLE:Dock(TOP)
            TITLE.OnChange = function(self, text)
                HTEXT = self:GetValue()
            end
            TITLE:DockMargin(w * 0.05, 0, w * 0.05, 0)
        else
            HEADER = vgui.Create("DComboBox", s)
            HEADER:SetText( RDV.LIBRARY.GetLang(nil, "CLAIMB_headerLabel") )
            HEADER:Dock(TOP)
            HEADER:SetSortItems(false)
            HEADER:DockMargin(w * 0.05, 0, w * 0.05, 0)
            HEADER.OnSelect = function(self, index, value)
                HTEXT = value
            end
            HEADER.PerformLayout = function(s)
                s:SetWide(w)
            end
    
            for k, v in ipairs(RDV.CLAIMBOARDS.CFG.DefaultHeaders) do
                HEADER:AddChoice(v, k)
            end
        end

        --
        -- Label 1 - Battalion and Status
        --

        CreateDivider(s, RDV.LIBRARY.GetLang(nil, "CLAIMB_battalionLabel"))

        local BATTALION = vgui.Create("DComboBox", s)
        BATTALION:SetText( RDV.LIBRARY.GetLang(nil, "CLAIMB_battalionLabel") )
        BATTALION:Dock(TOP)
        BATTALION:SetSortItems(false)
        BATTALION:DockMargin(w * 0.05, 0, w * 0.05, 0)

        BATTALION.OnSelect = function(self, index, value)
            local TAB = RDV.CLAIMBOARDS.CFG.BATTALIONS[value]
            if !TAB then return end

            BAT_INT = TAB.KEY

            STR_BAT = value
        end


        local JOB = team.GetName(LocalPlayer():Team())

        for k, v in ipairs(BATTALIONS) do
            local SJobs = v.SJobs
            local JOBS = v.Jobs
            local NAME = v.NAME
            
            if ( #SJobs <= 0 ) or JOBS[JOB] then
                BATTALION:AddChoice(NAME, k)
            end
        end

        CreateDivider(s, RDV.LIBRARY.GetLang(nil, "CLAIMB_statusLabel"))

        local STATUS = vgui.Create("DComboBox", s)
        STATUS:SetText( RDV.LIBRARY.GetLang(nil, "CLAIMB_statusLabel") )
        STATUS:Dock(TOP)
        STATUS:SetSortItems(false)
        STATUS:DockMargin(w * 0.05, 0, w * 0.05, 0)

        STATUS.OnSelect = function(self, index, value)
            if index == 1 then
                open = true
            else
                open = false
            end
        end


        STATUS:AddChoice(RDV.LIBRARY.GetLang(nil, "CLAIMB_OpenLabel"), 1)
        STATUS:AddChoice(RDV.LIBRARY.GetLang(nil, "CLAIMB_ClosedLabel"), 2)

        --
        -- Label 2 - Claim and Unclaim
        --

        local SAVE = vgui.Create("RDV_LIBRARY_TextButton", FRAME)
        SAVE:SetText(RDV.LIBRARY.GetLang(nil, "CLAIMB_SaveLabel"))
        SAVE:Dock(BOTTOM)
        SAVE:DockMargin(w * 0.05, 0, w * 0.05, h * 0.01)
        SAVE:SetHeight(SAVE:GetTall() * 1.5)

        SAVE.DoClick = function()
            if HTEXT ~= "" and ( BAT_INT and BAT_INT ~= 0 ) then
                net.Start("RD_CLAIMBOARD_UPDATE")
                    net.WriteEntity(entity)
                    net.WriteUInt(BAT_INT, 8)
                    net.WriteString(HTEXT)
                    net.WriteBool(open)
                net.SendToServer()

                surface.PlaySound("reality_development/ui/ui_accept.ogg")
            else
                local pre = RDV.CLAIMBOARDS.CFG.Prefix.Appension
                local precolor = RDV.CLAIMBOARDS.CFG.Prefix.Color

                chat.AddText(precolor, "["..pre.."] ", COL_1, RDV.LIBRARY.GetLang(nil, "CLAIMB_moreInformation"))
                surface.PlaySound("common/talk.wav")
            end

            FRAME:Remove()
        end

        local UNCLAIM = vgui.Create("RDV_LIBRARY_TextButton", FRAME)
        UNCLAIM:SetText(RDV.LIBRARY.GetLang(nil, "CLAIMB_unclaimLabel"))
        UNCLAIM:Dock(BOTTOM)
        UNCLAIM:DockMargin(w * 0.05, 0, w * 0.05, h * 0.01)
        UNCLAIM:SetHeight(UNCLAIM:GetTall() * 1.5)

        UNCLAIM.DoClick = function()
            net.Start("RD_CLAIMBOARD_UNCLAIM")
                net.WriteEntity(entity)
            net.SendToServer()

            FRAME:Remove()
        end

        if entity:GetClaimBoardClaimed() then
            if RDV.CLAIMBOARDS.CFG.CustomHeaders then
                TITLE:SetValue(entity:GetClaimBoardTitle())
            else
                for k, v in ipairs(HEADER.Choices) do
                    if v == entity:GetClaimBoardTitle() then
                        HEADER:ChooseOptionID(k)
                        
                        break
                    end
                end
            end

            STATUS:ChooseOptionID(OpenStatus(entity))
            
            local TAB = RDV.CLAIMBOARDS.CFG.BATTALIONS[entity:GetClaimBoardBat()]
            
            if TAB then
                BAT_INT = TAB.KEY
            end

            for k, v in ipairs(BATTALION.Choices) do
                if ( entity:GetClaimBoardBat() == v ) then
                    BATTALION:ChooseOptionID(k)
                    break
                end
            end

            HTEXT = entity:GetClaimBoardTitle()
            open = entity:GetClaimBoardOpen()
        end

        s.Think = function() end
    end
end)
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/posw.lua:
local APP = {}

APP.Name = "Powiadczenia"                   -- Nazwa
APP.Restricted = true               -- Dosownie nic nie zmienia
APP.Rank = true                   -- Czy jest od oficera

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    
    local tyt = vgui.Create("DTextEntry",pan)
    tyt:SetSize(x*0.5,tyt:GetTall())
    tyt:Center()
    tyt:SetPlaceholderText("Za co dostaj reputacje")
    tyt:SetPos(tyt:GetX(), y*0.05)

    local ile = vgui.Create("DTextEntry",pan)
    ile:SetSize(x*0.5,ile:GetTall())
    ile:Center()
    ile:SetPlaceholderText("Ile czasu? 1 = minuta")
    ile:SetPos(ile:GetX(), y*0.1)
    ile:SetNumeric(true)

    local gracze = vgui.Create("DListView",pan)
    gracze:SetSize(x*0.3,y*0.6)
    gracze:Center()
    gracze:SetPos(gracze:GetX(),y*0.2)
    gracze:AddColumn( "Nick" )
    gracze:AddColumn( "Reputacja" )
    gracze:AddColumn( "SteamID" )

    for k,v in ipairs(ents.FindInSphere(LocalPlayer():GetPos(),500)) do
        if !IsValid(v) then continue end
        if !v:IsPlayer() then continue end
        local lvl = v:getJobTable().lvl
        local clvl = lvl ~= nil and v:GetLevel(lvl) or 0
        gracze:AddLine( v:Nick(), 0, v:SteamID() )
    end

    local wystaw = vgui.Create("DButton",pan)
    wystaw:Dock(BOTTOM)
    wystaw:SetText("Wystaw")
    wystaw:SetSize(1,y*0.05)
    function wystaw:DoClick()
        local seld = gracze:GetSelected()
        local pl = {}
        for k,v in ipairs(seld) do
            local steamid = v:GetColumnText(3)
            pl[steamid] = true
        end
        

        tfres.Global:NetServer("Datapad_posw",{players = pl,czas = ile:GetInt(),tyt = tyt:GetValue()})
    end

end





return APP
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/test.lua:
return gluapack()()